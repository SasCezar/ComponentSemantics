b'\xef\xbb\xbf# NumCpp: A Templatized Header Only C++ Implementation of the [Python NumPy Library](http://www.numpy.org)\n\n## Author: David Pilger dpilger26@gmail.com\n\n## Version: 1.2\n\n## License\n\nCopyright 2019 David Pilger\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this\nsoftware and associated documentation files(the "Software"), to deal in the Software\nwithout restriction, including without limitation the rights to use, copy, modify,\nmerge, publish, distribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be included in all copies\nor substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n## Testing\n\n**C++ Standards:** C++11, C++14, and C++17  \n**Compilers:** VS 2017/2019, GCC 7.4.0/8.3/9.1, and Clang 6.0/8.0\n**Boost Versions:** 1.68 and 1.70  \n\n## [Documentation](https://dpilger26.github.io/NumCpp)\n\n## [GitHub](https://github.com/dpilger26/NumCpp)\n\n## [Installation](https://dpilger26.github.io/NumCpp/doxygen/html/md__c_1__users_pilgeda__documents__git_hub__num_cpp_install__r_e_a_d_m_e.html)\n\n## From NumPy To NumCpp \xe2\x80\x93 A Quick Start Guide\n\nThis quick start guide is meant as a very brief overview of some of the things\nthat can be done with **NumCpp**.  For a full breakdown of everything available\nin the **NumCpp** library please visit the [Full Documentation](https://dpilger26.github.io/NumCpp).\n\n### CONTAINERS\n\nThe main data structure in **NumpCpp** is the `NdArray`.  It is inherently a 2D array class, with 1D arrays being implemented as 1xN arrays.  There is also a `DataCube` class that is provided as a convenience container for storing an array of 2D `NdArray`s, but it has limited usefulness past a simple container.\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```a = np.array([[1, 2], [3, 4], [5, 6]])```             | ```nc::NdArray<int> a = { {1, 2}, {3, 4}, {5, 6} }```    |\n| ```a.reshape([2, 3])```                                  | ```a.reshape(2, 3)```                                    |\n| ```a.astype(np.double)```                                | ```a.astype<double>()```                                 |\n\n### INITIALIZERS\n\nMany initializer functions are provided that return `NdArray`s for common needs.\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.linspace(1, 10, 5)```                              | ```nc::linspace<dtype>(1, 10, 5)```                      |\n| ```np.arange(3, 7)```                                    | ```nc::arange<dtype>(3, 7)```                            |\n| ```np.eye(4)```                                          | ```nc::eye<dtype>(4)```                                  |\n| ```np.zeros([3, 4])```                                   | ```nc::zeros<dtype>(3, 4)```                             |\n|                                                          | ```nc::NdArray<dtype>(3, 4) a = 0```                     |\n| ```np.ones([3, 4])```                                    | ```nc::ones<dtype>(3, 4)```                              |\n|                                                          | ```nc::NdArray<dtype>(3, 4) a = 1```                     |\n| ```np.nans([3, 4])```                                    | ```nc::nans(3, 4)```                                     |\n|                                                          | ```nc::NdArray<double>(3, 4) a = nc::constants::nan```   |\n| ```np.empty([3, 4])```                                   | ```nc::empty<dtype>(3, 4)```                             |\n|                                                          | ```nc::NdArray<dtype>(3, 4) a```                         |\n\n### SLICING/BROADCASTING\n\n**NumpCpp** offers **NumPy** style slicing and broadcasting.\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```a[2, 3]```                                            | ```a(2, 3)```                                            |\n| ```a[2:5, 5:8]```                                        | ```a(nc::Slice(2, 5), nc::Slice(5, 8))```                |\n|                                                          | ```a({2, 5}, {5, 8})```                                  |\n| ```a[:, 7]```                                            | ```a(a.rSlice(), 7)```                                   |\n| ```a[a > 5]```                                           | ```a[a > 50]```                                          |\n| ```a[a > 5] = 0```                                       | ```a.putMask(a > 50, 666)```                             |\n\n### RANDOM\n\nThe random module provides simple ways to create random arrays.\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.random.seed(666)```                                | ```nc::random::seed(666)```                              |\n| ```np.random.randn(3, 4)```                              | ```nc::random::randn<double>(nc::Shape(3,4))```          |\n|                                                          | ```nc::random::randn<double>({3, 4})```                  |\n| ```np.random.randint(0, 10, [3, 4])```                   | ```nc::random::randInt<int>(nc::Shape(3,4),0,10)```      |\n|                                                          | ```nc::random::randInt<int>({3, 4},0,10)```              |\n| ```np.random.rand(3, 4)```                               | ```nc::random::rand<double>(nc::Shape(3,4))```           |\n|                                                          | ```nc::random::rand<double>({3, 4})```                   |\n| ```np.random.choice(a, 3)```                             | ```nc::random::choice(a, 3)```                           |\n\n### CONCATENATION\n\nMany ways to concatenate `NdArray` are available.\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.stack([a, b, c], axis=0)```                        | ```nc::stack({a, b, c}, nc::Axis::ROW)```                |\n| ```np.vstack([a, b, c])```                               | ```nc::vstack({a, b, c})```                              |\n| ```np.hstack([a, b, c])```                               | ```nc::hstack({a, b, c})```                              |\n| ```np.append(a, b, axis=1)```                            | ```nc::append(a, b, nc::Axis::COL)```                    |\n\n### DIAGONAL, TRIANGULAR, AND FLIP\n\nThe following return new `NdArray`s.\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.diagonal(a)```                                     | ```nc::diagonal(a)```                                    |\n| ```np.triu(a)```                                         | ```nc::triu(a)```                                        |\n| ```np.tril(a)```                                         | ```nc::tril(a)```                                        |\n| ```np.flip(a, axis=0)```                                 | ```nc::flip(a, nc::Axis::ROW)```                         |\n| ```np.flipud(a)```                                       | ```nc::flipud(a)```                                      |\n| ```np.fliplr(a)```                                       | ```nc::fliplr(a)```                                      |\n\n### ITERATION\n\n**NumpCpp** follows the idioms of the C++ STL providing iterator pairs to iterate on arrays in different fashions.\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```for value in a```                                     | ```for(auto it = a.begin(); it < a.end(); ++it)```       |\n|                                                          | ```for(auto& value : a)```                               |\n\n### LOGICAL\n\nLogical FUNCTIONS in **NumpCpp** behave the same as **NumPy**.\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.where(a > 5, a, b)```                              | ```nc::where(a > 5, a, b)```                             |\n| ```np.any(a)```                                          | ```nc::any(a)```                                         |\n| ```np.all(a)```                                          | ```nc::all(a)```                                         |\n| ```np.logical_and(a, b)```                               | ```nc::logical_and(a, b)```                              |\n| ```np.logical_or(a, b)```                                | ```nc::logical_or(a, b)```                               |\n| ```np.isclose(a, b)```                                   | ```nc::isclose(a, b)```                                  |\n| ```np.allclose(a, b)```                                  | ```nc::allclose(a, b)```                                 |\n\n### COMPARISONS\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.equal(a, b)```                                     | ```nc::equal(a, b)```                                    |\n|                                                          | ```a == b```                                             |\n| ```np.not_equal(a, b)```                                 | ```nc::not_equal(a, b)```                                |\n|                                                          | ```a != b```                                             |\n| ```rows, cols = np.nonzero(a)```                         | ```auto [rows, cols] = nc::nonzero(a)```                 |\n\n### MINIMUM, MAXIMUM, SORTING\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.min(a)```                                          | ```nc::min(a)```                                         |\n| ```np.max(a)```                                          | ```nc::max(a)```                                         |\n| ```np.argmin(a)```                                       | ```nc::argmin(a)```                                      |\n| ```np.argmax(a)```                                       | ```nc::argmax(a)```                                      |\n| ```np.sort(a, axis=0)```                                 | ```nc::sort(a, nc::Axis::ROW)```                         |\n| ```np.argsort(a, axis=1)```                              | ```nc::argsort(a, nc::Axis::COL)```                      |\n| ```np.unique(a)```                                       | ```nc::unique(a)```                                      |\n| ```np.setdiff1d(a, b)```                                 | ```nc::setdiff1d(a, b)```                                |\n| ```np.diff(a)```                                         | ```nc::diff(a)```                                        |\n\n### REDUCERS\n\nReducers accumulate values of `NdArray`s along specified axes. When no axis is specified, values are accumulated along all axes.\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.sum(a)```                                          | ```nc::sum(a)```                                         |\n| ```np.sum(a, axis=0)```                                  | ```nc::sum(a, nc::Axis::ROW)```                          |\n| ```np.prod(a)```                                         | ```nc::prod(a)```                                        |\n| ```np.prod(a, axis=0)```                                 | ```nc::prod(a, nc::Axis::ROW)```                         |\n| ```np.mean(a)```                                         | ```nc::mean(a)```                                        |\n| ```np.mean(a, axis=0)```                                 | ```nc::mean(a, nc::Axis::ROW)```                         |\n| ```np.count_nonzero(a)```                                | ```nc::count_nonzero(a)```                               |\n| ```np.count_nonzero(a, axis=0)```                        | ```nc::count_nonzero(a, nc::Axis::ROW)```                |\n\n### I/O\n\nPrint and file output methods.  All **NumpCpp** classes support a `print()` method and `<<` stream operators.\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```print(a)```                                           | ```a.print()```                                          |\n|                                                          | ```std::cout << a```                                     |\n| ```a.tofile(filename, sep=\xe2\x80\x99\\n\xe2\x80\x99)```                       | ```a.tofile(filename, "\\n")```                           |\n| ```np.fromfile(filename, sep=\xe2\x80\x99\\n\xe2\x80\x99)```                    | ```nc::fromfile<dtype>(filename, "\\n")```                |\n| ```np.dump(a, filename)```                               | ```nc::dump(a, filename)```                              |\n| ```np.load(filename)```                                  | ```nc::load<dtype>(filename)```                          |\n\n### MATHEMATICAL FUNCTIONS\n\n**NumpCpp** universal functions are provided for a large set number of mathematical functions.\n\n#### BASIC FUNCTIONS\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.abs(a)```                                          | ```nc::abs(a)```                                         |\n| ```np.sign(a)```                                         | ```nc::sign(a)```                                        |\n| ```np.remainder(a, b)```                                 | ```nc::remainder(a, b)```                                |\n| ```np.clip(a, 3, 8)```                                   | ```nc::clip(a, 3, 8)```                                  |\n| ```np.interp(x, xp, fp)```                               | ```nc::interp(x, xp, fp)```                              |\n\n#### EXPONENTIAL FUNCTIONS\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.exp(a)```                                          | ```nc::exp(a)```                                         |\n| ```np.expm1(a)```                                        | ```nc::expm1(a)```                                       |\n| ```np.log(a)```                                          | ```nc::log(a)```                                         |\n| ```np.log1p(a)```                                        | ```nc::log1p(a)```                                       |\n\n#### POWER FUNCTIONS\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.power(a, 4)```                                     | ```nc::power(a, 4)```                                    |\n| ```np.sqrt(a)```                                         | ```nc::sqrt(a)```                                        |\n| ```np.square(a)```                                       | ```nc::square(a)```                                      |\n| ```np.cbrt(a)```                                         | ```nc::cbrt(a)```                                        |\n\n#### TRIGONOMETRIC FUNCTIONS\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.sin(a)```                                          | ```nc::sin(a)```                                         |\n| ```np.cos(a)```                                          | ```nc::cos(a)```                                         |\n| ```np.tan(a)```                                          | ```nc::tan(a)```                                         |\n\n#### HYPERBOLIC FUNCTIONS\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.sinh(a)```                                         | ```nc::sinh(a)```                                        |\n| ```np.cosh(a)```                                         | ```nc::cosh(a)```                                        |\n| ```np.tanh(a)```                                         | ```nc::tanh(a)```                                        |\n\n#### CLASSIFICATION FUNCTIONS\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.isnan(a)```                                        | ```nc::isnan(a)```                                       |\n| ```np.isinf(a)```                                        | ```nc::isinf(a)```                                       |\n\n#### LINEAR ALGEBRA\n\n| **NumPy**                                                | **NumCpp**                                               |\n|:--------------------------------------------------------:|:--------------------------------------------------------:|\n| ```np.linalg.norm(a)```                                  | ```nc::norm(a)```                                        |\n| ```np.dot(a, b)```                                       | ```nc::dot(a, b)```                                      |\n| ```np.linalg.det(a)```                                   | ```nc::linalg::det(a)```                                 |\n| ```np.linalg.inv(a)```                                   | ```nc::linalg::inv(a)```                                 |\n| ```np.linalg.lstsq(a, b)```                              | ```nc::linalg::lstsq(a, b)```                            |\n| ```np.linalg.matrix_power(a, 3)```                       | ```nc::linalg::matrix_power(a, 3)```                     |\n| ```Np.linalg.multi_dot(a, b, c)```                       | ```nc::linalg::multi_dot({a, b, c})```                   |\n| ```np.linalg.svd(a)```                                   | ```nc::linalg::svd(a)```                                 |\n'