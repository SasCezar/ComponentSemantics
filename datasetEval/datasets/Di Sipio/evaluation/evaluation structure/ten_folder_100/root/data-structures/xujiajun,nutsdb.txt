b'# NutsDB [![GoDoc](https://godoc.org/github.com/xujiajun/nutsdb?status.svg)](https://godoc.org/github.com/xujiajun/nutsdb)  [![Go Report Card](https://goreportcard.com/badge/github.com/xujiajun/nutsdb)](https://goreportcard.com/report/github.com/xujiajun/nutsdb) <a href="https://travis-ci.org/xujiajun/nutsdb"><img src="https://travis-ci.org/xujiajun/nutsdb.svg?branch=master" alt="Build Status"></a> [![Coverage Status](https://coveralls.io/repos/github/xujiajun/nutsdb/badge.svg?branch=master)](https://coveralls.io/github/xujiajun/nutsdb?branch=master) [![License](http://img.shields.io/badge/license-Apache_2-blue.svg?style=flat-square)](https://raw.githubusercontent.com/xujiajun/nutsdb/master/LICENSE) [![Mentioned in Awesome Go](https://awesome.re/mentioned-badge.svg)](https://github.com/avelino/awesome-go#database)  \n\nEnglish | [\xe7\xae\x80\xe4\xbd\x93\xe4\xb8\xad\xe6\x96\x87](https://github.com/xujiajun/nutsdb/blob/master/README-CN.md)\n\nNutsDB is a simple, fast, embeddable and persistent key/value store written in pure Go. \n\nIt supports fully serializable transactions and many data structures such as list\xe3\x80\x81set\xe3\x80\x81sorted set. All operations happen inside a Tx. Tx represents a transaction, which can be read-only or read-write. Read-only transactions can read values for a given bucket and a given key or iterate over a set of key-value pairs. Read-write transactions can read, update and delete keys from the DB.\n\n## Motivation\nI wanted a simple, fast, embeddable and persistent key/value store written in pure Go. And if it supports more data structures such as list, set, sorted set\xef\xbc\x8cit will be better.\n\nThere are some options around the embeddable key/value store in Go: \n\nBoltDB is based on B+ tree, has a good random read performance and awesome sequential scan performance, and it supports  ACID transactions with serializable isolation, but it is terrible at random write performance and not supports more data structures such as list, etc. \n\nGoLevelDB is based on a log-structured merge-tree (LSM tree), but it does not support more data structures.\n\nBadger is based on LSM tree with value log. It designed for SSDs. It also supports transactions. But its write performance is not as good as I thought. And it also does not support more data structures.\n\nMoreover, I was curious about how to implement a key/value database. The database can be said to be the core of the system, to understand the database kernel or their own implementation, better use of the same kind of database or the next time according to the business custom database is very helpful.\n\nSo I tried to build a key/value store by myself, I wanted to find a simple store engine model as a reference. \nFinally, I found the Bitcask model. It is simple and easy to implement. However, it has its limitation, like range or prefix queries, are not efficient. For example, you cannot easily scan over all keys between user000000 and user999999, you had to look up each key individually in the hashmap. \n\nIn order to break the limitation, I tried to optimize them. Finally, I did it and named `NutsDB`. NutsDB offers a high read/write performance and supports transactions. And it still has a lot of room for optimization. Welcome [contributions to NutsDB](https://github.com/xujiajun/nutsdb#contributing).\n\n## Table of Contents\n\n- [Getting Started](#getting-started)\n  - [Installing](#installing)\n  - [Opening a database](#opening-a-database)\n  - [Options](#options)\n    - [Default Options](#default-options)\n  - [Transactions](#transactions)\n    - [Read-write transactions](#read-write-transactions)\n    - [Read-only transactions](#read-only-transactions)\n    - [Managing transactions manually](#managing-transactions-manually)\n  - [Using buckets](#using-buckets)\n  - [Using key/value pairs](#using-keyvalue-pairs)\n  - [Using TTL(Time To Live)](#using-ttltime-to-live)\n  - [Iterating over keys](#iterating-over-keys)\n    - [Prefix scans](#prefix-scans)\n    - [Range scans](#range-scans)\n    - [Get all](#get-all)\n  - [Merge Operation](#merge-operation)\n  - [Database backup](#database-backup)\n- [Using Other data structures](#using-other-data-structures)\n   - [List](#list)\n     - [RPush](#rpush)\n     - [LPush](#lpush)\n     - [LPop](#lpop)\n     - [LPeek](#lpeek)\n     - [RPop](#rpop)\n     - [RPeek](#rpeek)\n     - [LRange](#lrange)\n     - [LRem](#lrem)\n     - [LSet](#lset)\t\n     - [Ltrim](#ltrim)\n     - [LSize](#lsize)  \t\n   - [Set](#set)\n     - [SAdd](#sadd)\n     - [SAreMembers](#saremembers)\n     - [SCard](#scard)\n     - [SDiffByOneBucket](#sdiffbyonebucket)\n     - [SDiffByTwoBuckets](#sdiffbytwobuckets)\n     - [SHasKey](#shaskey)\n     - [SIsMember](#sismember)\n     - [SMembers](#smembers)\n     - [SMoveByOneBucket](#smovebyonebucket)\n     - [SMoveByTwoBuckets](#smovebytwobuckets)\n     - [SPop](#spop)\n     - [SRem](#srem)\n     - [SUnionByOneBucket](#sunionbyonebucket)\n     - [SUnionByTwoBucket](#sunionbytwobuckets)\n   - [Sorted Set](#sorted-set)\n     - [ZAdd](#zadd)\n     - [ZCard](#zcard)\n     - [ZCount](#zcount)\n     - [ZGetByKey](#zgetbykey)\n     - [ZMembers](#zmembers)\n     - [ZPeekMax](#zpeekmax)\n     - [ZPeekMin](#zpeekmin)\n     - [ZPopMax](#zpopmax)\n     - [ZPopMin](#zpopmin)\n     - [ZRangeByRank](#zrangebyrank)\n     - [ZRangeByScore](#zrangebyscore)\n     - [ZRank](#zrank)\n     - [ZRevRank](#zrevrank)\n     - [ZRem](#zrem)\n     - [ZRemRangeByRank](#zremrangebyrank)\n     - [ZScore](#zscore)\n- [Comparison with other databases](#comparison-with-other-databases)\n   - [BoltDB](#boltdb)\n   - [LevelDB, RocksDB](#leveldb-rocksdb)\n   - [Badger](#badger)\n- [Benchmarks](#benchmarks)\n- [Caveats & Limitations](#caveats--limitations)\n- [Contact](#contact)\n- [Contributing](#contributing)\n- [Acknowledgements](#acknowledgements)\n- [License](#license)\n\n## Getting Started\n\n### Installing\n\nTo start using NutsDB, first needs [Go](https://golang.org/dl/) installed (version 1.11+ is required).  and run go get:\n\n```\ngo get -u github.com/xujiajun/nutsdb\n```\n\n### Opening a database\n\nTo open your database, use the nutsdb.Open() function,with the appropriate options.The `Dir` , `EntryIdxMode`  and  `SegmentSize`  options are must be specified by the client. About options see [here](https://github.com/xujiajun/nutsdb#options) for detail.\n\n```golang\npackage main\n\nimport (\n\t"log"\n\n\t"github.com/xujiajun/nutsdb"\n)\n\nfunc main() {\n\t// Open the database located in the /tmp/nutsdb directory.\n\t// It will be created if it doesn\'t exist.\n\topt := nutsdb.DefaultOptions\n\topt.Dir = "/tmp/nutsdb"\n\tdb, err := nutsdb.Open(opt)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t...\n}\n```\n\n### Options\n\n* Dir                  string  \n\n`Dir` represents Open the database located in which dir.\n\n* EntryIdxMode         EntryIdxMode \n\n`EntryIdxMode` represents using which mode to index the entries. `EntryIdxMode` includes three options: `HintKeyValAndRAMIdxMode`,`HintKeyAndRAMIdxMode` and `HintBPTSparseIdxMode`. `HintKeyValAndRAMIdxMode` represents ram index (key and value) mode, `HintKeyAndRAMIdxMode` represents ram index (only key) mode and `HintBPTSparseIdxMode` represents b+ tree sparse index mode.\n\n* RWMode               RWMode  \n\n`RWMode` represents the read and write mode. `RWMode` includes two options: `FileIO` and `MMap`.\nFileIO represents the read and write mode using standard I/O. And MMap represents the read and write mode using mmap.\n\n* SegmentSize          int64 \n\nNutsDB will truncate data file if the active file is larger than `SegmentSize`.\nCurrent verison default `SegmentSize` is 8MB,but you can custom it.\nOnce set, it cannot be changed. see [caveats--limitations](https://github.com/xujiajun/nutsdb#caveats--limitations) for detail.\n\n* NodeNum              int64\n\n`NodeNum` represents the node number.Default NodeNum is 1. `NodeNum` range [1,1023] .\n\n* SyncEnable           bool\n\n`SyncEnable` represents if call Sync() function.\nif `SyncEnable` is false, high write performance but potential data loss likely.\nif `SyncEnable` is true, slower but persistent.\n\n* StartFileLoadingMode RWMode\n\n`StartFileLoadingMode` represents when open a database which RWMode to load files.\n\t\n#### Default Options\n\nRecommend to use the `DefaultOptions` . Unless you know what you\'re doing.\n\n```\nvar DefaultOptions = Options{\n\tEntryIdxMode:         HintKeyValAndRAMIdxMode,\n\tSegmentSize:          defaultSegmentSize,\n\tNodeNum:              1,\n\tRWMode:               FileIO,\n\tSyncEnable:           true,\n\tStartFileLoadingMode: MMap,\n}\n```\n\n### Transactions\n\nNutsDB allows only one read-write transaction at a time but allows as many read-only transactions as you want at a time. Each transaction has a consistent view of the data as it existed when the transaction started.\n\nWhen a transaction fails, it will roll back, and revert all changes that occurred to the database during that transaction.\nif set the option `SyncEnable` true When a read/write transaction succeeds all changes are persisted to disk.\n\nCreating transaction from the `DB` is thread safe.\n\n#### Read-write transactions\n\n```golang\nerr := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t...\n\treturn nil\n})\n\n```\n\n#### Read-only transactions\n\n```golang\nerr := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t...\n\treturn nil\n})\n\n```\n\n#### Managing transactions manually\n\nThe `DB.View()`  and  `DB.Update()`  functions are wrappers around the  `DB.Begin()`  function. These helper functions will start the transaction, execute a function, and then safely close your transaction if an error is returned. This is the recommended way to use NutsDB transactions.\n\nHowever, sometimes you may want to manually start and end your transactions. You can use the DB.Begin() function directly but please be sure to close the transaction. \n\n```golang\n // Start a write transaction.\ntx, err := db.Begin(true)\nif err != nil {\n    return err\n}\n\nbucket := "bucket1"\nkey := []byte("foo")\nval := []byte("bar")\n\n// Use the transaction.\nif err = tx.Put(bucket, key, val, Persistent); err != nil {\n\t// Rollback the transaction.\n\ttx.Rollback()\n} else {\n\t// Commit the transaction and check for error.\n\tif err = tx.Commit(); err != nil {\n\t\ttx.Rollback()\n\t\treturn err\n\t}\n}\n```\n\n### Using buckets\n\nBuckets are collections of key/value pairs within the database. All keys in a bucket must be unique.\nBucket can be interpreted as a table or namespace. So you can store the same key in different bucket. \n\n```golang\n\nkey := []byte("key001")\nval := []byte("val001")\n\nbucket001 := "bucket001"\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif err := tx.Put(bucket001, key, val, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nbucket002 := "bucket002"\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif err := tx.Put(bucket002, key, val, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\n```\n\n### Using key/value pairs\n\nTo save a key/value pair to a bucket, use the `tx.Put` method:\n\n```golang\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\tkey := []byte("name1")\n\tval := []byte("val1")\n\tbucket := "bucket1"\n\tif err := tx.Put(bucket, key, val, 0); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}); err != nil {\n\tlog.Fatal(err)\n}\n\n```\n\nThis will set the value of the "name1" key to "val1" in the bucket1 bucket.\n\nTo update the the value of the "name1" key,we can still use the `tx.Put` function:\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\tkey := []byte("name1")\n\tval := []byte("val1-modify") // Update the value\n\tbucket := "bucket1"\n\tif err := tx.Put(bucket, key, val, 0); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}); err != nil {\n\tlog.Fatal(err)\n}\n\n```\n\nTo retrieve this value, we can use the `tx.Get` function:\n\n```golang\nif err := db.View(\nfunc(tx *nutsdb.Tx) error {\n\tkey := []byte("name1")\n\tbucket := "bucket1"\n\tif e, err := tx.Get(bucket, key); err != nil {\n\t\treturn err\n\t} else {\n\t\tfmt.Println(string(e.Value)) // "val1-modify"\n\t}\n\treturn nil\n}); err != nil {\n\tlog.Println(err)\n}\n```\n\nUse the `tx.Delete()` function to delete a key from the bucket.\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\tkey := []byte("name1")\n\tbucket := "bucket1"\n\tif err := tx.Delete(bucket, key); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n### Using TTL(Time To Live)\n\nNusDB supports TTL(Time to Live) for keys, you can use `tx.Put` function with a `ttl` parameter.\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\tkey := []byte("name1")\n\tval := []byte("val1")\n\tbucket := "bucket1"\n\t\n\t// If set ttl = 0 or Persistent, this key will nerver expired.\n\t// Set ttl = 60 , after 60 seconds, this key will expired.\n\tif err := tx.Put(bucket, key, val, 60); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}); err != nil {\n\tlog.Fatal(err)\n}\n```\n### Iterating over keys\n\nNutsDB stores its keys in byte-sorted order within a bucket. This makes sequential iteration over these keys extremely fast.\n\n#### Prefix scans\n\nTo iterate over a key prefix, we can use `PrefixScan` function, and the paramter `limitNum` constrain the number of entries returned :\n\n```golang\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tprefix := []byte("user_")\n\t\tbucket := "user_list"\n\t\t// Constrain 100 entries returned \n\t\tif entries, err := tx.PrefixScan(bucket, prefix, 100); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfor _, entry := range entries {\n\t\t\t\tfmt.Println(string(entry.Key), string(entry.Value))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tlog.Fatal(err)\n}\n\n```\n\n#### Range scans\n\nTo scan over a range, we can use `RangeScan` function. For example\xef\xbc\x9a\n\n```golang\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\t// Assume key from user_0000000 to user_9999999.\n\t\t// Query a specific user key range like this.\n\t\tstart := []byte("user_0010001")\n\t\tend := []byte("user_0010010")\n\t\tbucket := "user_list"\n\t\tif entries, err := tx.RangeScan(bucket, start, end); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfor _, entry := range entries {\n\t\t\t\tfmt.Println(string(entry.Key), string(entry.Value))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n#### Get all\n\nTo scan all keys and values of the bucket stored, we can use `GetAll` function. For example:\n\n```go\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "user_list"\n\t\tentries, err := tx.GetAll(bucket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, entry := range entries {\n\t\t\tfmt.Println(string(entry.Key),string(entry.Value))\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\tlog.Println(err)\n}\n```\n### Merge Operation\n\nNutsDB supports merge operation. you can use `db.Merge()` function removes dirty data and reduce data redundancy. Call this function from a read-write transaction. It will effect other write request. So you can execute it at the appropriate time.\n\n```golang\nerr := db.Merge()\nif err != nil {\n    ...\n}\n```\n\nNotice: the `HintBPTSparseIdxMode` mode does not support the merge operation of the current version.\n\n### Database backup\n\nNutsDB is easy to backup. You can use the `db.Backup()` function at given dir, call this function from a read-only transaction, it will perform a hot backup and not block your other database reads and writes.\n\n```golang\nerr = db.Backup(dir)\nif err != nil {\n   ...\n}\n```\n\n### Using other data structures\n\nThe syntax here is modeled after [Redis commands](https://redis.io/commands)\n\n#### List\n\n##### RPush\n\nInserts the values at the tail of the list stored in the bucket at given bucket,key and values.\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\tval := []byte("val1")\n\t\treturn tx.RPush(bucket, key, val)\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### LPush \n\nInserts the values at the head of the list stored in the bucket at given bucket,key and values.\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\tval := []byte("val2")\n\t\treturn tx.LPush(bucket, key, val)\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### LPop \n\nRemoves and returns the first element of the list stored in the bucket at given bucket and key.\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\tif item, err := tx.LPop(bucket, key); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("LPop item:", string(item))\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### LPeek\n\nReturns the first element of the list stored in the bucket at given bucket and key.\n\n```golang\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\tif item, err := tx.LPeek(bucket, key); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("LPeek item:", string(item)) //val11\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### RPop \n\nRemoves and returns the last element of the list stored in the bucket at given bucket and key.\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\tif item, err := tx.RPop(bucket, key); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("RPop item:", string(item))\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### RPeek\n\nReturns the last element of the list stored in the bucket at given bucket and key.\n\n```golang\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\tif item, err := tx.RPeek(bucket, key); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("RPeek item:", string(item))\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### LRange \n\nReturns the specified elements of the list stored in the bucket at given bucket,key, start and end.\nThe offsets start and stop are zero-based indexes 0 being the first element of the list (the head of the list),\n1 being the next element and so on. \nStart and end can also be negative numbers indicating offsets from the end of the list,\nwhere -1 is the last element of the list, -2 the penultimate element and so on.\n\n```golang\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\tif items, err := tx.LRange(bucket, key, 0, -1); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\t//fmt.Println(items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println(string(item))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### LRem \n\nRemoves the first count occurrences of elements equal to value from the list stored in the bucket at given bucket,key,count.\nThe count argument influences the operation in the following ways:\n\n* count > 0: Remove elements equal to value moving from head to tail.\n* count < 0: Remove elements equal to value moving from tail to head.\n* count = 0: Remove all elements equal to value.\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\treturn tx.LRem(bucket, key, 1)\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### LSet \n\nSets the list element at index to value.\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\tif err := tx.LSet(bucket, key, 0, []byte("val11")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("LSet ok, index 0 item value => val11")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### Ltrim \n\nTrims an existing list so that it will contain only the specified range of elements specified.\nthe offsets start and stop are zero-based indexes 0 being the first element of the list (the head of the list),\n1 being the next element and so on.Start and end can also be negative numbers indicating offsets from the end of the list,\nwhere -1 is the last element of the list, -2 the penultimate element and so on.\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\treturn tx.LTrim(bucket, key, 0, 1)\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### LSize \n\nReturns the size of key in the bucket in the bucket at given bucket and key.\n\n```golang\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForList"\n\t\tkey := []byte("myList")\n\t\tif size,err := tx.LSize(bucket, key); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("myList size is ",size)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n#### Set\n\n##### SAdd\n\nAdds the specified members to the set stored int the bucket at given bucket,key and items.\n\n```go\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t        bucket := "bucketForSet"\n\t\tkey := []byte("mySet")\n\t\treturn tx.SAdd(bucket, key, []byte("a"), []byte("b"), []byte("c"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### SAreMembers \n\nReturns if the specified members are the member of the set int the bucket at given bucket,key and items.\n\n```go\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "bucketForSet"\n\t\tkey := []byte("mySet")\n\t\tif ok, err := tx.SAreMembers(bucket, key, []byte("a"), []byte("b"), []byte("c")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SAreMembers:", ok)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### SCard \n\nReturns the set cardinality (number of elements) of the set stored in the bucket at given bucket and key.\n\n```go\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "bucketForSet"\n\t\tkey := []byte("mySet")\n\t\tif num, err := tx.SCard(bucket, key); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SCard:", num)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\n```\n##### SDiffByOneBucket \n\nReturns the members of the set resulting from the difference between the first set and all the successive sets in one bucket.\n\n```go\n\nkey1 := []byte("mySet1")\nkey2 := []byte("mySet2")\nbucket := "bucketForSet"\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket, key1, []byte("a"), []byte("b"), []byte("c"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket, key2, []byte("c"), []byte("d"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif items, err := tx.SDiffByOneBucket(bucket, key1, key2); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SDiffByOneBucket:", items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println("item", string(item))\n\t\t\t}\n\t\t\t//item a\n\t\t\t//item b\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\n```\n\n##### SDiffByTwoBuckets \n\nReturns the members of the set resulting from the difference between the first set and all the successive sets in two buckets.\n\n```go\nbucket1 := "bucket1"\nkey1 := []byte("mySet1")\n\nbucket2 := "bucket2"\nkey2 := []byte("mySet2")\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket1, key1, []byte("a"), []byte("b"), []byte("c"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket2, key2, []byte("c"), []byte("d"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif items, err := tx.SDiffByTwoBuckets(bucket1, key1, bucket2, key2); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SDiffByTwoBuckets:", items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println("item", string(item))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\n```\n##### SHasKey \n\nReturns if the set in the bucket at given bucket and key.\n\n```go\n\nbucket := "bucketForSet"\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif ok, err := tx.SHasKey(bucket, []byte("mySet")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SHasKey", ok)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\n```\n##### SIsMember \n\nReturns if member is a member of the set stored int the bucket at given bucket,key and item.\n\n```go\nbucket := "bucketForSet"\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif ok, err := tx.SIsMember(bucket, []byte("mySet"), []byte("a")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SIsMember", ok)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### SMembers \n\nReturns all the members of the set value stored int the bucket at given bucket and key.\n\n```\nbucket := "bucketForSet"\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif items, err := tx.SMembers(bucket, []byte("mySet")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SMembers", items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println("item", string(item))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### SMoveByOneBucket \n\nMoves member from the set at source to the set at destination in one bucket.\n\n```go\nbucket3 := "bucket3"\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn SAdd(bucket3, []byte("mySet1"), []byte("a"), []byte("b"), []byte("c"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket3, []byte("mySet2"), []byte("c"), []byte("d"), []byte("e"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif ok, err := tx.SMoveByOneBucket(bucket3, []byte("mySet1"), []byte("mySet2"), []byte("a")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SMoveByOneBucket", ok)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif items, err := tx.SMembers(bucket3, []byte("mySet1")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("after SMoveByOneBucket bucket3 mySet1 SMembers", items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println("item", string(item))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif items, err := tx.SMembers(bucket3, []byte("mySet2")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("after SMoveByOneBucket bucket3 mySet2 SMembers", items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println("item", string(item))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### SMoveByTwoBuckets \n\nMoves member from the set at source to the set at destination in two buckets.\n\n```go\nbucket4 := "bucket4"\nbucket5 := "bucket5"\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket4, []byte("mySet1"), []byte("a"), []byte("b"), []byte("c"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket5, []byte("mySet2"), []byte("c"), []byte("d"), []byte("e"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif ok, err := tx.SMoveByTwoBuckets(bucket4, []byte("mySet1"), bucket5, []byte("mySet2"), []byte("a")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SMoveByTwoBuckets", ok)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif items, err := tx.SMembers(bucket4, []byte("mySet1")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("after SMoveByTwoBuckets bucket4 mySet1 SMembers", items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println("item", string(item))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif items, err := tx.SMembers(bucket5, []byte("mySet2")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("after SMoveByTwoBuckets bucket5 mySet2 SMembers", items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println("item", string(item))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### SPop \n\nRemoves and returns one or more random elements from the set value store in the bucket at given bucket and key.\n\n```go\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tkey := []byte("mySet")\n\t\tif item, err := tx.SPop(bucket, key); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SPop item from mySet:", string(item))\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### SRem \n\nRemoves the specified members from the set stored int the bucket at given bucket,key and items.\n\n```go\nbucket6:="bucket6"\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket6, []byte("mySet"), []byte("a"), []byte("b"), []byte("c"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif err := tx.SRem(bucket6, []byte("mySet"), []byte("a")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SRem ok")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif items, err := tx.SMembers(bucket6, []byte("mySet")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SMembers items:", items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println("item:", string(item))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### SUnionByOneBucket \n\nThe members of the set resulting from the union of all the given sets in one bucket.\n\n```go\nbucket7 := "bucket1"\nkey1 := []byte("mySet1")\nkey2 := []byte("mySet2")\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket7, key1, []byte("a"), []byte("b"), []byte("c"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket7, key2, []byte("c"), []byte("d"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif items, err := tx.SUnionByOneBucket(bucket7, key1, key2); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SUnionByOneBucket:", items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println("item", string(item))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### SUnionByTwoBuckets \n\nThe members of the set resulting from the union of all the given sets in two buckets.\n\n```go\nbucket8 := "bucket1"\nkey1 := []byte("mySet1")\n\nbucket9 := "bucket2"\nkey2 := []byte("mySet2")\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket8, key1, []byte("a"), []byte("b"), []byte("c"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\treturn tx.SAdd(bucket9, key2, []byte("c"), []byte("d"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tif items, err := tx.SUnionByTwoBuckets(bucket8, key1, bucket9, key2); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("SUnionByTwoBucket:", items)\n\t\t\tfor _, item := range items {\n\t\t\t\tfmt.Println("item", string(item))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n#### Sorted Set\n\n##### ZAdd\n\nAdds the specified member with the specified score and the specified value to the sorted set stored at bucket.\n\n```go\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet1"\n\t\tkey := []byte("key1")\n\t\treturn tx.ZAdd(bucket, key, 1, []byte("val1"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### ZCard \n\nReturns the sorted set cardinality (number of elements) of the sorted set stored at bucket.\n\n```go\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet1"\n\t\tif num, err := tx.ZCard(bucket); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZCard num", num)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### ZCount \n\nReturns the number of elements in the sorted set at bucket with a score between min and max and opts.\n\nOpts includes the following parameters:\n\n* Limit        int  // limit the max nodes to return\n* ExcludeStart bool // exclude start value, so it search in interval (start, end] or (start, end)\n* ExcludeEnd   bool // exclude end value, so it search in interval [start, end) or (start, end)\n\n```go\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet1"\n\t\tif num, err := tx.ZCount(bucket, 0, 1, nil); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZCount num", num)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### ZGetByKey \n\nReturns node in the bucket at given bucket and key.\n\n```go\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet1"\n\t\tkey := []byte("key2")\n\t\tif node, err := tx.ZGetByKey(bucket, key); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZGetByKey key2 val:", string(node.Value))\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### ZMembers \n\nReturns all the members of the set value stored at bucket.\n\n```go\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet1"\n\t\tif nodes, err := tx.ZMembers(bucket); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZMembers:", nodes)\n\n\t\t\tfor _, node := range nodes {\n\t\t\t\tfmt.Println("member:", node.Key(), string(node.Value))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### ZPeekMax \n\nReturns the member with the highest score in the sorted set stored at bucket.\n\n```go\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet1"\n\t\tif node, err := tx.ZPeekMax(bucket); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZPeekMax:", string(node.Value))\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### ZPeekMin \n\nReturns the member with lowest score in the sorted set stored at bucket.\n\n```go\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet1"\n\t\tif node, err := tx.ZPeekMin(bucket); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZPeekMin:", string(node.Value))\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### ZPopMax \n\nRemoves and returns the member with the highest score in the sorted set stored at bucket.\n\n```go\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet1"\n\t\tif node, err := tx.ZPopMax(bucket); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZPopMax:", string(node.Value)) //val3\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### ZPopMin \n\nRemoves and returns the member with the lowest score in the sorted set stored at bucket.\n\n```go\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet1"\n\t\tif node, err := tx.ZPopMin(bucket); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZPopMin:", string(node.Value)) //val1\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### ZRangeByRank \n\nReturns all the elements in the sorted set in one bucket at bucket and key with a rank between start and end (including elements with rank equal to start or end).\n\n```go\n// ZAdd add items\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet2"\n\t\tkey1 := []byte("key1")\n\t\treturn tx.ZAdd(bucket, key1, 1, []byte("val1"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet2"\n\t\tkey2 := []byte("key2")\n\t\treturn tx.ZAdd(bucket, key2, 2, []byte("val2"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet2"\n\t\tkey3 := []byte("key3")\n\t\treturn tx.ZAdd(bucket, key3, 3, []byte("val3"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\n// ZRangeByRank\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet2"\n\t\tif nodes, err := tx.ZRangeByRank(bucket, 1, 2); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZRangeByRank nodes :", nodes)\n\t\t\tfor _, node := range nodes {\n\t\t\t\tfmt.Println("item:", node.Key(), node.Score())\n\t\t\t}\n\t\t\t\n\t\t\t//item: key1 1\n\t\t\t//item: key2 2\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### ZRangeByScore \n\nReturns all the elements in the sorted set at key with a score between min and max.\nAnd the parameter `Opts` is the same as ZCount\'s.\n\n```go\n// ZAdd\nif err := db.Update(\n\t\tfunc(tx *nutsdb.Tx) error {\n\t\t\tbucket := "myZSet3"\n\t\t\tkey1 := []byte("key1")\n\t\t\treturn tx.ZAdd(bucket, key1, 70, []byte("val1"))\n\t\t}); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet3"\n\t\tkey2 := []byte("key2")\n\t\treturn tx.ZAdd(bucket, key2, 90, []byte("val2"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet3"\n\t\tkey3 := []byte("key3")\n\t\treturn tx.ZAdd(bucket, key3, 86, []byte("val3"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\n// ZRangeByScore\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet3"\n\t\tif nodes, err := tx.ZRangeByScore(bucket, 80, 100,nil); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZRangeByScore nodes :", nodes)\n\t\t\tfor _, node := range nodes {\n\t\t\t\tfmt.Println("item:", node.Key(), node.Score())\n\t\t\t}\n\t\t\t//item: key3 86\n\t\t\t//item: key2 90\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\t\n```\n##### ZRank\n\nReturns the rank of member in the sorted set stored in the bucket at given bucket and key, with the scores ordered from low to high.\n\n```go\n\n// ZAdd\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet4"\n\t\tkey1 := []byte("key1")\n\t\treturn tx.ZAdd(bucket, key1, 70, []byte("val1"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet4"\n\t\tkey2 := []byte("key2")\n\t\treturn tx.ZAdd(bucket, key2, 90, []byte("val2"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet4"\n\t\tkey3 := []byte("key3")\n\t\treturn tx.ZAdd(bucket, key3, 86, []byte("val3"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\n// ZRank\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet4"\n\t\tkey1 := []byte("key1")\n\t\tif rank, err := tx.ZRank(bucket, key1); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("key1 ZRank :", rank) // key1 ZRank : 1\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n#### ZRevRank\n\nReturns the rank of member in the sorted set stored in the bucket at given bucket and key,with the scores ordered from high to low.\n\n```go\n// ZAdd\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet8"\n\t\tkey1 := []byte("key1")\n\t\treturn tx.ZAdd(bucket, key1, 10, []byte("val1"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet8"\n\t\tkey2 := []byte("key2")\n\t\treturn tx.ZAdd(bucket, key2, 20, []byte("val2"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet8"\n\t\tkey3 := []byte("key3")\n\t\treturn tx.ZAdd(bucket, key3, 30, []byte("val3"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\n// ZRevRank\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet8"\n\t\tif rank, err := tx.ZRevRank(bucket, []byte("key3")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZRevRank key1 rank:", rank) //ZRevRank key3 rank: 1\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n\n##### ZRem \n\nRemoves the specified members from the sorted set stored in one bucket at given bucket and key.\n\n```go\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet5"\n\t\tkey1 := []byte("key1")\n\t\treturn tx.ZAdd(bucket, key1, 10, []byte("val1"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet5"\n\t\tkey2 := []byte("key2")\n\t\treturn tx.ZAdd(bucket, key2, 20, []byte("val2"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet5"\n\t\tif nodes,err := tx.ZMembers(bucket); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("before ZRem key1, ZMembers nodes",nodes)\n\t\t\tfor _,node:=range nodes {\n\t\t\t\tfmt.Println("item:",node.Key(),node.Score())\n\t\t\t}\n\t\t}\n\t\t// before ZRem key1, ZMembers nodes map[key1:0xc00008cfa0 key2:0xc00008d090]\n\t\t// item: key1 10\n\t\t// item: key2 20\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet5"\n\t\tif err := tx.ZRem(bucket, "key1"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet5"\n\t\tif nodes,err := tx.ZMembers(bucket); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("after ZRem key1, ZMembers nodes",nodes)\n\t\t\tfor _,node:=range nodes {\n\t\t\t\tfmt.Println("item:",node.Key(),node.Score())\n\t\t\t}\n\t\t\t// after ZRem key1, ZMembers nodes map[key2:0xc00008d090]\n\t\t\t// item: key2 20\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\n```\n\n##### ZRemRangeByRank \n\nRemoves all elements in the sorted set stored in one bucket at given bucket with rank between start and end.\nThe rank is 1-based integer. Rank 1 means the first node; Rank -1 means the last node.\n\n```go\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet6"\n\t\tkey1 := []byte("key1")\n\t\treturn tx.ZAdd(bucket, key1, 10, []byte("val1"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet6"\n\t\tkey2 := []byte("key2")\n\t\treturn tx.ZAdd(bucket, key2, 20, []byte("val2"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet6"\n\t\tkey3 := []byte("key3")\n\t\treturn tx.ZAdd(bucket, key3, 30, []byte("val2"))\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet6"\n\t\tif nodes,err := tx.ZMembers(bucket); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("before ZRemRangeByRank, ZMembers nodes",nodes)\n\t\t\tfor _,node:=range nodes {\n\t\t\t\tfmt.Println("item:",node.Key(),node.Score())\n\t\t\t}\n\t\t\t// before ZRemRangeByRank, ZMembers nodes map[key3:0xc00008d450 key1:0xc00008d270 key2:0xc00008d360]\n\t\t\t// item: key1 10\n\t\t\t// item: key2 20\n\t\t\t// item: key3 30\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.Update(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet6"\n\t\tif err := tx.ZRemRangeByRank(bucket, 1,2); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet6"\n\t\tif nodes,err := tx.ZMembers(bucket); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("after ZRemRangeByRank, ZMembers nodes",nodes)\n\t\t\tfor _,node:=range nodes {\n\t\t\t\tfmt.Println("item:",node.Key(),node.Score())\n\t\t\t}\n\t\t\t// after ZRemRangeByRank, ZMembers nodes map[key3:0xc00008d450]\n\t\t\t// item: key3 30\n\t\t\t// key1 ZScore 10\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n##### ZScore\n\nReturns the score of member in the sorted set in the bucket at given bucket and key.\n\n```go\nif err := db.View(\n\tfunc(tx *nutsdb.Tx) error {\n\t\tbucket := "myZSet7"\n\t\tif score,err := tx.ZScore(bucket, []byte("key1")); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println("ZScore key1 score:",score)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\tlog.Fatal(err)\n}\n```\n### Comparison with other databases\n\n#### BoltDB\n\nBoltDB is similar to NutsDB, both use B+tree and support transaction. However, Bolt uses a B+tree internally and only a single file, and NutsDB is based on bitcask model with  multiple log files. NutsDB supports TTL and many data structures, but BoltDB not supports them .\n\n#### LevelDB, RocksDB\n\nLevelDB and RocksDB are based on a log-structured merge-tree (LSM tree).An LSM tree optimizes random writes by using a write ahead log and multi-tiered, sorted files called SSTables. LevelDB does not have transactions. It supports batch writing of key/values pairs and it supports read snapshots but it will not give you the ability to do a compare-and-swap operation safely. NutsDB supports many data structures, but they not support them.\n\n#### Badger\n\nBadger is based in LSM tree with value log. It designed for SSDs. It also supports transaction and TTL. But in my benchmark its write performance is not as good as i thought. In addition, NutsDB supports data structures such as list\xe3\x80\x81set\xe3\x80\x81sorted set, but Badger not supports them.\n\n### Benchmarks\n\n## Tested kvstore \n\nSelected kvstore which is embedded, persistence and support transactions.\n\n* [BadgerDB](https://github.com/dgraph-io/badger) (master branch with default options)\n* [BoltDB](https://github.com/boltdb/bolt) (master branch  with default options)\n* [NutsDB](https://github.com/xujiajun/nutsdb) (master branch with default options or custom options)\n\n## Benchmark System:\n\n* Go Version : go1.11.4 darwin/amd64\n* OS: Mac OS X 10.13.6\n* Architecture: x86_64\n* 16 GB 2133 MHz LPDDR3\n* CPU: 3.1 GHz Intel Core i7\n\n##  Benchmark results:\n\n```\nbadger 2019/03/11 18:06:05 INFO: All 0 tables opened in 0s\ngoos: darwin\ngoarch: amd64\npkg: github.com/xujiajun/kvstore-bench\nBenchmarkBadgerDBPutValue64B-8    \t   10000\t    112382 ns/op\t    2374 B/op\t      74 allocs/op\nBenchmarkBadgerDBPutValue128B-8   \t   20000\t     94110 ns/op\t    2503 B/op\t      74 allocs/op\nBenchmarkBadgerDBPutValue256B-8   \t   20000\t     93480 ns/op\t    2759 B/op\t      74 allocs/op\nBenchmarkBadgerDBPutValue512B-8   \t   10000\t    101407 ns/op\t    3271 B/op\t      74 allocs/op\nBenchmarkBadgerDBGet-8            \t 1000000\t      1552 ns/op\t     416 B/op\t       9 allocs/op\nBenchmarkBoltDBPutValue64B-8      \t   10000\t    203128 ns/op\t   21231 B/op\t      62 allocs/op\nBenchmarkBoltDBPutValue128B-8     \t    5000\t    229568 ns/op\t   13716 B/op\t      64 allocs/op\nBenchmarkBoltDBPutValue256B-8     \t   10000\t    196513 ns/op\t   17974 B/op\t      64 allocs/op\nBenchmarkBoltDBPutValue512B-8     \t   10000\t    199805 ns/op\t   17064 B/op\t      64 allocs/op\nBenchmarkBoltDBGet-8              \t 1000000\t      1122 ns/op\t     592 B/op\t      10 allocs/op\nBenchmarkNutsDBPutValue64B-8      \t   30000\t     53614 ns/op\t     626 B/op\t      14 allocs/op\nBenchmarkNutsDBPutValue128B-8     \t   30000\t     51998 ns/op\t     664 B/op\t      13 allocs/op\nBenchmarkNutsDBPutValue256B-8     \t   30000\t     53958 ns/op\t     920 B/op\t      13 allocs/op\nBenchmarkNutsDBPutValue512B-8     \t   30000\t     55787 ns/op\t    1432 B/op\t      13 allocs/op\nBenchmarkNutsDBGet-8              \t 2000000\t       661 ns/op\t      88 B/op\t       3 allocs/op\nBenchmarkNutsDBGetByHintKey-8     \t   50000\t     27255 ns/op\t     840 B/op\t      16 allocs/op\nPASS\nok  \tgithub.com/xujiajun/kvstore-bench\t83.856s\n```\n\n## Conclusions:\n\n### Put(write) Performance: \n\nNutsDB is fastest. NutsDB is 2-5x faster than BoltDB, 0.5-2x faster than BadgerDB.\nAnd BadgerDB is 1-3x faster than BoltDB.\n\n### Get(read) Performance: \n\nAll are fast. And NutsDB is 1x faster than others.\nAnd NutsDB reads with HintKey option is much slower than its default option way. \n\n\nthe benchmark code can be found in the [gokvstore-bench](https://github.com/xujiajun/gokvstore-bench) repo.\n\n### Caveats & Limitations\n\n#### Index mode\n\nFrom the version v0.3.0, NutsDB supports two modes about entry index: `HintKeyValAndRAMIdxMode`  and  `HintKeyAndRAMIdxMode`. From the version v0.5.0, NutsDB supports `HintBPTSparseIdxMode` mode.\n\nThe default mode use `HintKeyValAndRAMIdxMode`, entries are indexed base on RAM, so its read/write performance is fast. but can\xe2\x80\x99t handle databases much larger than the available physical RAM. If you set the `HintKeyAndRAMIdxMode` mode, HintIndex will not cache the value of the entry. Its write performance is also fast. To retrieve a key by seeking to offset relative to the start of the data file, so its read performance more slowly that RAM way, but it can save memory. The mode `HintBPTSparseIdxMode` is based b+ tree sparse index, this mode saves memory very much (1 billion data only uses about 80MB of memory). And other data structures such as ***list, set, sorted set only supported with mode HintKeyValAndRAMIdxMode***.\n***It cannot switch back and forth between modes because the index structure is different***.\n\nNutsDB will truncate data file if the active file is larger than  `SegmentSize`, so the size of an entry can not be set larger than `SegmentSize` , defalut `SegmentSize` is 8MB, you can set it(opt.SegmentSize) as option before DB opening. ***Once set, it cannot be changed***.\n\n#### Support OS\n\nNutsDB currently works on Mac OS, Linux and Windows.  \n\n#### About merge operation\n\nThe HintBPTSparseIdxMode mode does not support the merge operation of the current version.\n\n#### About transactions\n\nRecommend use the latest version.\n\n### Contact\n\n* [xujiajun](https://github.com/xujiajun)\n\n### Contributing\n\nSee [CONTRIBUTING](https://github.com/xujiajun/nutsdb/blob/master/CONTRIBUTING.md) for details on submitting patches and the contribution workflow.\n\n### Acknowledgements\n\nThis package is inspired by the following:\n\n* [Bitcask-intro](https://github.com/basho/bitcask/blob/develop/doc/bitcask-intro.pdf)\n* [BoltDB](https://github.com/boltdb)\n* [BuntDB](https://github.com/tidwall/buntdb)\n* [Redis](https://redis.io)\n* [Sorted Set](https://github.com/wangjia184/sortedset)\n\n### License\n\nThe NutsDB is open-sourced software licensed under the [Apache 2.0 license](https://github.com/xujiajun/nutsdb/blob/master/LICENSE).\n'