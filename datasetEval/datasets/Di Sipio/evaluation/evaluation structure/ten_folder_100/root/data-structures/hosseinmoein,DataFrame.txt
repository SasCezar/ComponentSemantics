b'[![Build status](https://ci.appveyor.com/api/projects/status/hjw01qui3bvxs8yi?svg=true)](https://ci.appveyor.com/project/hosseinmoein/dataframe)\n[![Build Status](https://travis-ci.org/hosseinmoein/DataFrame.svg?branch=master)](https://travis-ci.org/hosseinmoein/DataFrame)\n![GitHub](https://img.shields.io/github/license/hosseinmoein/DataFrame.svg?color=red&style=popout)\n![GitHub tag (latest by date)](https://img.shields.io/github/tag-date/hosseinmoein/DataFrame.svg?color=blue&label=Official%20Release&style=popout)\n[![C++17](https://img.shields.io/badge/C%2B%2B-17-blue.svg)](https://isocpp.org/std/the-standard )\n\n<img src="docs/pandalion.png" alt="drawing" width="500"/>\n\n# DataFrame\nThis is a C++ statistical library that provides an interface similar to Pandas package in Python.<BR>\n<B>A DataFrame can have one index column and many data columns of any built-in or user-defined type</B>.<BR>\nYou could do almost everything you could do with Pandas within the C++ syntax and type checking framework. You can add/delete any data column type, slice, run summarization functors, transpose, etc. like Pandas.<BR><BR>\n<B>Views</B><BR>\n- You can slice the data frame and instead of getting another data frame you can opt to get a view. A view is a data frame that is a reference to a slice of the original data frame. So if you change the data in the view the corresponding data in the original data frame will also be changed.<BR>\n\n<B>Multithreading</B><BR>\n1. DataFrame uses static containers to achieve type heterogeneity. By default, these static containers are unprotected. This is done by design. So by default, there is no locking overhead. If you use DataFrame in a multithreaded program you must provide a _SpinLock_ defined in <a href="include/DataFrame/Utils/ThreadGranularity.h">ThreadGranularity.h</a> file. DataFrame will use your _SpinLock_ to protect the containers.<BR>\nPlease see <a href="docs/DataFrameDoc.pdf">documentation</a>, _set_lock()_, _remove_lock()_, and <a href="test/dataframe_tester.cc#L3562">dataframe_tester.cc</a> for code example.\n2. In addition, instances of DataFrame are not multithreaded safe either. In other words, a single instance of DataFrame must not be used in multiple threads without protection.\n3. In the meantime, DataFrame utilizes multithreading in two different ways internally:\n    1. There are asynchronous versions of some methods. For example, you have both _sort()_ and _sort_async()_. The latter returns a _std::future_ that could execute in parallel.\n    2. DataFrame uses multiple threads, internally and unbeknown to the user, in some of its algorithms when appropriate. User can control (or turn off) the multithreading by calling _set_thread_level()_ which sets the max number of threads to be used. The default is 0. The optimal number of threads is a function of users hardware/software environment and usually obtained by trail and error. _set_thread_level()_ and threading level in general is a static property and once set, it applies to all instances.<BR>\n\n<B><a href="docs/DateTimeDoc.pdf">DateTime</a></B><BR>\n- DateTime class included in this library is a very cool and handy object to manipulate date/time with nanosecond precision.\n\n---\n\n<B>Example Code</B>\n```CPP\nusing namespace hmdf;\n\n// Define a DataFrame with unsigned long index type\ntypedef StdDataFrame<unsigned long> MyDataFrame;\n\nMyDataFrame                df;\nstd::vector<int>           intvec = { 1, 2, 3, 4, 5 };\nstd::vector<double>        dblvec = { 1.2345, 2.2345, 3.2345, 4.2345, 5.2345 };\nstd::vector<double>        dblvec2 = { 0.998, 0.3456, 0.056, 0.15678, 0.00345,\n                                       0.923, 0.06743, 0.1 };\nstd::vector<std::string>   strvec = { "Insight", "John Dow", "Alakazam",\n                                      "Persian Prince", "Bugs Bunny" };\nstd::vector<unsigned long> ulgvec = { 1UL, 2UL, 3UL, 4UL, 5UL, 8UL, 7UL, 6UL }\nstd::vector<unsigned long> xulgvec = ulgvec;\n\n// This is only one way of loading data into a DataFrame instance. There are\n// many different ways of doing it. Please see the documentation,\n// or dataframe_tester.cc\nint rc = df.load_data(std::move(ulgvec),  // Index column\n                      std::make_pair("int_col", intvec),\n                      std::make_pair("dbl_col", dblvec),\n                      std::make_pair("dbl_col_2", dblvec2),\n                      std::make_pair("str_col", strvec),\n                      std::make_pair("ul_col", xulgvec));\n\n// This is another way of loading a DataFrame\nMyDataFrame       df2;\nstd::future<bool> fut = df2.read_async("sample_data.csv", io_format::csv);\n\nfut.get();\n\n// Sort the Frame by index\ndf.sort<MyDataFrame::TimeStamp, int, double, std::string>();\n// Sort the Frame by column \xe2\x80\x9cdbl_col_2\xe2\x80\x9d\ndf.sort<double, int, double, std::string>("dbl_col_2");\n\n// A functor to calculate mean, variance, skew, kurtosis, defined in\n// DataFrameVisitors.h file.\n// You can implement your own algorithms and extend the DataFrame easily\nStatsVisitor<double>  stats_visitor;\n// Calculate the stats on column \xe2\x80\x9cdbl_col\xe2\x80\x9d\ndf.visit<double>("dbl_col", stats_visitor);\n```\n\n---\n\n## [DataFrame Documentation](docs/DataFrameDoc.pdf)\n[DateTime Documentation](docs/DateTimeDoc.pdf)\n\n---\n\n[DataFrame Test File](test/dataframe_tester.cc)<BR>\n[Heterogeneous Vectors Test File](test/vectors_tester.cc)<BR>\n[Date/Time Test File](test/date_time_tester.cc)\n\n---\n\n[Contributions](docs/CONTRIBUTING.md)<BR>\n[License](License)\n\n---\n\n### Installing using CMake\n```bash\nmkdir [Debug | Release]\ncd [Debug | Release]\ncmake -DCMAKE_BUILD_TYPE=[Debug | Release] ..\nmake\nmake install\n```\n\n### Uninstalling\n\n```bash\ncd [Debug | Release]\nmake uninstall\n```\n---\n\n### Performance\nThere is a test program [dataframe_performance](test/dataframe_performance.cc) that should give you some sense of how this library performs. As a comparison, there is also a Pandas Python [pandas_performance](test/pandas_performance.py) script that does exactly the same thing.<BR>\ndataframe_performance.cc is compiled with gcc compiler with -O3 flag.<BR>\npandas_performance.py is ran with Python 3.7.<BR>\nI ran both on my mac-book, doing the following:<BR>\n<img src="docs/MacSize.png" alt="drawing" width="500"/>\n\n1. Generate ~1.6 billion second resolution timestamps and load it into the DataFrame/Pandas as index.\n2. Generate ~1.6 billion random numbers each for 3 columns with normal, log normal, and exponential distributions and load them into the DataFrame/Pandas.\n3. Calculate the mean of each of the 3 columns.\n\nResult:\n```bash\nMacBook> time python pandas_performance.py\nAll memory allocations are done. Calculating means ...\n\nreal  17m18.916s\nuser  4m47.113s\nsys   5m31.901s\nMacBook>\nMacBook>\nMacBook> time ../bin/Linux.GCC64/dataframe_performance\nAll memory allocations are done. Calculating means ...\n\nreal  6m40.222s\nuser  2m54.362s\nsys   2m14.951s\n```\n<B>The interesting part:</B><BR>\n1. Pandas script, I believe, is entirely implemented in Numpy which is in C.\n2. In case of Pandas, allocating memory + random number generation and calculating means take almost the same time.\n3. In case of DataFrame 85% of the time is spent in allocating memory + random number generation.\n4. You load data once, but calculate statistics many times. So DataFrame, in general, is about 8x faster than parts of Pandas that are implemented in Numpy. I leave parts of Pandas that are purely in Python to imagination.\n\n'