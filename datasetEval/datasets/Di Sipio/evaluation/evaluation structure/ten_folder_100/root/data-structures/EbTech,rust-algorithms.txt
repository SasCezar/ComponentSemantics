b"# Contest Algorithms in Rust\n\n[![Build Status](https://travis-ci.org/EbTech/rust-algorithms.svg?branch=master)](https://travis-ci.org/EbTech/rust-algorithms)\n[![Latest Version](https://img.shields.io/crates/v/contest-algorithms.svg)](https://crates.io/crates/contest-algorithms)\n\nA collection of classic data structures and algorithms, emphasizing usability, beauty and clarity over full generality. As such, this should be viewed not as a blackbox *library*, but as a whitebox *cookbook* demonstrating the design and implementation of algorithms. I hope it will be useful to students and educators, as well as fans of algorithmic programming contests.\n\nThis repository is distributed under the [MIT License](LICENSE). The license text need not be included in contest submissions, though I would appreciate linking back to this repo for others to find. Enjoy!\n\n## For Students and Educators\n\nWhen learning a new algorithm or data structure, it's often helpful to see or play with a concrete implementation. As such, this repository catalogues several classic algorithms in their simplest forms.\n\nIn addition, the Rust language has outstanding pedagogical attributes. Its compiler acts as a teacher, enforcing strict discipline while pointing to clearer ways to structure one's logic.\n\n## For Programming Contests\n\nThe original intent of this project was to build a reference for use in programming contests ranging from [Codeforces](https://codeforces.com) to [Google's Kick Start and Code Jam](https://codingcompetitions.withgoogle.com), [LeetCode](https://leetcode.com/contest) and [HackerRank](https://www.hackerrank.com/contests). As a result, it contains algorithms that are frequently useful to have in one's toolkit, with an emphasis on code that is concise and easy to modify under time pressure.\n\nMost competitive programmers rely on C++ for its fast execution time. However, it's notoriously unsafe, diverting a considerable share of the contestant's time and attention on mistake prevention and debugging. Java is the next most popular choice, offering a little safety at some expense to speed of coding and execution.\n\nTo my delight, I found that Rust eliminates entire classes of bugs, while reducing visual clutter to make the rest easier to spot. And, it's *fast*. There's a learning curve, to be sure. However, a proficient Rust programmer stands to gain a competitive advantage as well as a more pleasant experience!\n\nFor help in getting started, you may check out [some of my past submissions](https://codeforces.com/contest/1168/submission/55200038).\n\nOther online judges that support Rust:\n- [Kattis](https://open.kattis.com/help/rust)\n- [Timus](http://acm.timus.ru/help.aspx?topic=rust)\n- [SPOJ](https://www.spoj.com/)\n\n## Programming Language Advocacy\n\nMy other goal is to appeal to developers who feel limited by mainstream, arguably outdated, programming languages. Perhaps we have a better option.\n\nRather than try to persuade you with words, this repository aims to show by example. If you're new to Rust, see [Jim Blandy's *Why Rust?*](http://www.oreilly.com/programming/free/files/why-rust.pdf) for a brief introduction, or just [dive in!](https://doc.rust-lang.org/book/)\n\n## Contents\n\n- [Basic graph representations](src/graph/mod.rs): adjacency lists, minimum spanning tree, Euler path, disjoint set union \n- [Network flows](src/graph/flow.rs): Dinic's blocking flow, Hopcroft-Karp bipartite matching, min cost max flow\n- [Connected components](src/graph/connectivity.rs): 2-edge-, 2-vertex- and strongly connected components, bridges, articulation points, topological sort, 2-SAT\n- [Associative range query](src/range_query): known colloquially as *segtrees*, and Mo's query square root decomposition\n- [GCD Math](src/math/mod.rs): canonical solution to Bezout's identity\n- [Arithmetic](src/math/num.rs): rational and complex numbers, linear algebra, safe modular arithmetic\n- [FFT](src/math/fft.rs): fast Fourier transform, number theoretic transform, convolution\n- [Scanner](src/scanner.rs): utility for reading input data ergonomically\n- [String processing](src/string_proc.rs): Knuth-Morris-Pratt string matching, suffix arrays, Manacher's palindrome search\n"