b'= Spring boot starter for http://www.grpc.io/[gRPC framework.]\n:toc:\n\nimage:https://img.shields.io/maven-central/v/io.github.lognet/grpc-spring-boot-starter.svg?label=Maven%20Central[link=https://search.maven.org/search?q=g:%22io.github.lognet%22%20AND%20a:%22grpc-spring-boot-starter%22]\nimage:https://travis-ci.org/LogNet/grpc-spring-boot-starter.svg?branch=master[Build Status,link=https://travis-ci.org/LogNet/grpc-spring-boot-starter]\nimage:https://codecov.io/gh/LogNet/grpc-spring-boot-starter/branch/master/graph/badge.svg["Codecov", link="https://codecov.io/gh/LogNet/grpc-spring-boot-starter/branch/master"]\n\n:toc:\n:source-highlighter: prettify\n:numbered:\n:icons: font\n\n\n\n== Features\nAuto-configures and runs the embedded gRPC server with @GRpcService-enabled beans as part of spring-boot application. +\n\nThe starter can be used both by *1.5.X* and *2.X.X* spring boot applications.\n\n== Setup\n\n[source,gradle]\n----\nrepositories {  \n    mavenCentral()\n   //maven { url "https://oss.sonatype.org/content/repositories/snapshots" } //for snashot builds\n   \n}\ndependencies {\n    compile \'io.github.lognet:grpc-spring-boot-starter:3.5.0\'\n}\n\n\n----\n\n[IMPORTANT]\nStarting from release `3.0.0` the artifacts are published to *maven central*.\nPay attention that `group` has changed from `org.lognet` to `io.github.lognet`.\n\n\n\n\n\n[NOTE]\nThe release notes with compatibility matrix can be found link:ReleaseNotes.adoc[here^]\n\n== Usage\n\n* Start by https://github.com/google/protobuf-gradle-plugin[generating] stub and server interface(s) from your `.proto` file(s).\n* Annotate your server interface implementation(s) with `@org.lognet.springboot.grpc.GRpcService`\n* Optionally configure the server port in your `application.yml/properties`. Default port is `6565`.\n\n[source,yaml]\n----\n grpc:\n    port: 6565\n----\n[NOTE]\nA random port can be defined by setting the port to `0`. +\nThe actual port being used can then be retrieved by using `@LocalRunningGrpcPort` annotation on `int` field which will inject the running port (explicitly configured or randomly selected)\n\n* Optionally enable server reflection (see https://github.com/grpc/grpc-java/blob/master/documentation/server-reflection-tutorial.md)\n\n[source,yaml]\n----\n grpc:\n    enableReflection: true\n----\n\nThe starter supports also the `in-process server`, which should be used for testing purposes :\n\n[source,yaml]\n----\n grpc:\n    enabled: false <1>\n    inProcessServerName: myTestServer <2>\n----\n<1> Disables the default server (`NettyServer`).\n<2> Enables the `in-process` server.\n\n[NOTE]\nIf you enable both the `NettyServer` and `in-process` server, they will both share the same instance of `HealthStatusManager` and `GRpcServerBuilderConfigurer` (see <<Custom gRPC Server Configuration>>).\n\n\n\n== Show case\n\nIn the `grpc-spring-boot-starter-demo` project you can find fully functional examples with integration tests. +\nThe `grpc-spring-boot2-starter-demo` project runs the same demo services and tests with *spring boot 2*.\n\n=== Service implementation\nThe service definition from `.proto` file looks like this :\n[source,proto]\n----\nservice Greeter {\n    rpc SayHello ( HelloRequest) returns (  HelloReply) {}\n}\n----\n\nNote the generated `io.grpc.examples.GreeterGrpc.GreeterImplBase` class that extends `io.grpc.BindableService`.(The generated classes were intentionally committed for demo purposes).\n\nAll you need to do is to annotate your service implementation with `@org.lognet.springboot.grpc.GRpcService`\n\n[source,java]\n----\n    @GRpcService\n    public static class GreeterService extends  GreeterGrpc.GreeterImplBase{\n        @Override\n        public void sayHello(GreeterOuterClass.HelloRequest request, StreamObserver<GreeterOuterClass.HelloReply> responseObserver) {\n            final GreeterOuterClass.HelloReply.Builder replyBuilder = GreeterOuterClass.HelloReply.newBuilder().setMessage("Hello " + request.getName());\n            responseObserver.onNext(replyBuilder.build());\n            responseObserver.onCompleted();\n        }\n    }\n----\n\n=== Interceptors support\nThe starter supports the registration of two kinds of interceptors: _Global_  and _Per Service_. +\nIn both cases the interceptor has to implement `io.grpc.ServerInterceptor` interface.\n\n- Per service\n\n[source,java]\n----\n@GRpcService(interceptors = { LogInterceptor.class })\npublic  class GreeterService extends  GreeterGrpc.GreeterImplBase{\n    // ommited\n}\n----\n`LogInterceptor` will be instantiated via spring factory if there is bean of type `LogInterceptor`, or via no-args constructor otherwise.\n\n- Global\n\n[source,java]\n----\n@GRpcGlobalInterceptor\npublic  class MyInterceptor implements ServerInterceptor{\n    // ommited\n}\n----\n\nThe annotation on java config factory method is also supported :\n\n[source,java]\n----\n @Configuration\n public class MyConfig{\n     @Bean\n     @GRpcGlobalInterceptor\n     public  ServerInterceptor globalInterceptor(){\n         return new ServerInterceptor(){\n             @Override\n             public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call, Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n                // your logic here\n                 return next.startCall(call, headers);\n             }\n         };\n     }\n }\n----\nGlobal interceptors can be ordered using Spring\'s `@Ordered` or `@Priority` annotations. Following Spring\'s ordering semantics, lower order values have higher priority and will be executed first in the interceptor chain.\n\n[source,java]\n----\n@GRpcGlobalInterceptor\n@Order(10)\npublic  class A implements ServerInterceptor{\n    // will be called before B\n}\n\n@GRpcGlobalInterceptor\n@Order(20)\npublic  class B implements ServerInterceptor{\n    // will be called after A\n}\n----\n\n\nThe particular service also has the opportunity to disable the global interceptors :\n\n[source,java]\n----\n@GRpcService(applyGlobalInterceptors = false)\npublic  class GreeterService extends  GreeterGrpc.GreeterImplBase{\n    // ommited\n}\n----\n\n=== Transport Security (TLS)\n\nThe transport security can be configured using root certificate and it\'s private key paths:\n\n[source,yaml]\n----\n grpc:\n    security:\n      cert-chain: classpath:cert/server-cert.pem\n      private-key: file:../grpc-spring-boot-starter-demo/src/test/resources/cert/server-key.pem\n----\n\nThe value of both properties is in form supported by https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/io/ResourceEditor.html[ResourceEditor]. +\n\nThe client side should be configured accordingly :\n\n[source,java]\n----\n((NettyChannelBuilder)channelBuilder)\n .useTransportSecurity()\n .sslContext(GrpcSslContexts.forClient().trustManager(certChain).build());\n----\n\nThis starter will pull the `io.netty:netty-tcnative-boringssl-static` dependency by default to support SSL. +\nIf  you need another SSL/TLS support, please exclude this dependency and follow https://github.com/grpc/grpc-java/blob/master/SECURITY.md[Security Guide].\n\n[NOTE]\nIf the more detailed tuning is needed for security setup, please use custom configurer described in <<Custom gRPC Server Configuration>>\n\n=== Custom gRPC Server Configuration\n\nTo intercept the `io.grpc.ServerBuilder` instance used to build the `io.grpc.Server`, you can add bean that inherits from `org.lognet.springboot.grpc.GRpcServerBuilderConfigurer` to your context  and override the `configure` method. +\nBy the time of invocation of `configure` method, all discovered services, including theirs interceptors, had been added to the passed builder. +\nIn your implementation of `configure` method, you can add your custom configuration:\n\n[source,java]\n----\n@Component\npublic class MyGRpcServerBuilderConfigurer extends GRpcServerBuilderConfigurer{\n        @Override\n        public void configure(ServerBuilder<?> serverBuilder){\n            serverBuilder\n                .executor(YOUR EXECUTOR INSTANCE)\n                .compressorRegistry(YOUR COMPRESSION REGISTRY)\n                .decompressorRegistry(YOUR DECOMPRESSION REGISTRY)\n                .useTransportSecurity(YOUR TRANSPORT SECURITY SETTINGS);\n            ((NettyServerBuilder)serverBuilder)// cast to NettyServerBuilder (which is the default server) for further customization\n                    .sslContext(GrpcSslContexts  // security fine tuning\n                                    .forServer(...)\n                                    .trustManager(...)\n                                    .build())\n                    .maxConnectionAge(...)\n                    .maxConnectionAgeGrace(...);\n\n        }\n    };\n}\n----\n\n[NOTE]\nIf you enable both `NettyServer` and `in-process` servers, the `configure` method will be invoked on the same instance of configurer. +\nIf you need to differentiate between the passed `serverBuilder` s, you can check the type. +\nThis is the current limitation.\n\n== Consul Integration\n\nStarting from version `3.3.0`, the starter will auto-register the running grpc server in Consul registry  if `org.springframework.cloud:spring-cloud-starter-consul-discovery` is in classpath. +\nThe registered service name will be prefixed with `grpc-` ,i.e. `grpc-${spring.application.name}` to not interfere with standard registered web-service name if you choose to run both embedded `Grpc` and `Web` servers. +\n\nYou can find the test that demonstrates the feature link:grpc-spring-boot2-starter-demo/src/test/java/org/lognet/springboot/grpc/ConsulRegistrationTest.java[here].\n\n== Eureka Integration\n\nWhen building production-ready services, the advise is to have separate project for your service(s) gRPC API that holds only proto-generated classes both for server and client side usage. +\nYou will then add this project as `compile` dependency to your `gRPC client` and `gRPC server` projects.\n\nTo integrate `Eureka` simply follow the great https://spring.io/guides/gs/service-registration-and-discovery/[guide] from Spring.\n\nBelow are the essential parts of configurations for both server and client projects.\n\n===  gRPC Server Project\n\n* Add eureka starter as dependency of your server project together with generated classes from `proto` files:\n\n[source, gradle]\n.build.gradle\n----\n dependencies {\n     compile(\'org.springframework.cloud:spring-cloud-starter-eureka\')\n     compile project(":yourProject-api")\n }\n----\n\n\n* Configure gRPC server to register itself with Eureka.\n\n\n[source, yaml]\n.bootstrap.yaml\n----\nspring:\n    application:\n        name: my-service-name <1>\n----\n<1> Eureka\'s `ServiceId` by default is the spring application name, provide it before the service registers itself with Eureka.\n\n[source,yaml]\n.application.yaml\n----\ngrpc:\n    port: 6565 <1>\neureka:\n    instance:\n        nonSecurePort: ${grpc.port} <2>\n    client:\n        serviceUrl:\n            defaultZone: http://${eureka.host:localhost}:${eureka.port:8761}/eureka/ <3>\n----\n<1> Specify the port number the gRPC is listening on.\n<2> Register the eureka service port to be the same as `grpc.port` so client will know where to send the requests to.\n<3> Specify the  registry URL, so the service will register itself with. \n\n\n* Expose the gRPC service as part of Spring Boot Application.\n\n[source, java]\n.EurekaGrpcServiceApp.java\n----\n @SpringBootApplication\n @EnableEurekaClient\n public class EurekaGrpcServiceApp {\n\n     @GRpcService\n     public static class GreeterService extends GreeterGrpc.GreeterImplBase {\n         @Override\n         public void sayHello(GreeterOuterClass.HelloRequest request, StreamObserver<GreeterOuterClass.HelloReply> responseObserver) {\n\n         }\n     }\n\n     public static void main(String[] args) {\n         SpringApplication.run(DemoApp.class,args);\n     }\n }\n----\n\n===  gRPC Client Project\n\n* Add eureka starter as dependency of your client project together with generated classes from `proto` files:\n\n[source, gradle]\n.build.gradle\n----\n dependencies {\n     compile(\'org.springframework.cloud:spring-cloud-starter-eureka\')\n     compile project(":yourProject-api")\n }\n----\n\n* Configure client to find the eureka service registry:\n\n[source,yaml]\n.application.yaml\n----\neureka:\n  client:\n    register-with-eureka: false <1>\n    service-url:\n      defaultZone: http://${eureka.host:localhost}:${eureka.port:8761}/eureka/ <2>\n----\n<1> `false` if this project is not meant to act as  a service to another client.\n<2>  Specify the  registry URL, so this client  will know where to look up the required service.\n\n\n[source,java]\n.GreeterServiceConsumerApplication.java\n----\n@EnableEurekaClient\n@SpringBootApplication\npublic class GreeterServiceConsumerApplication {\n public static void main(String[] args) {\n   SpringApplication.run(GreeterServiceConsumerApplication.class, args);\n }\n}\n----\n\n* Use EurekaClient to get the coordinates of gRPC service instance from Eureka and consume the service :\n\n[source,java]\n.GreeterServiceConsumer.java\n----\n@EnableEurekaClient\n@Component\npublic class GreeterServiceConsumer {\n    @Autowired\n    private EurekaClient client;\n    \n    public void greet(String name) {\n        final InstanceInfo instanceInfo = client.getNextServerFromEureka("my-service-name", false);<1>\n        final ManagedChannel channel = ManagedChannelBuilder.forAddress(instanceInfo.getIPAddr(), instanceInfo.getPort())\n                .usePlaintext()\n                .build(); <2>\n        final GreeterServiceGrpc.GreeterServiceFutureStub stub = GreeterServiceGrpc.newFutureStub(channel); <3>\n        stub.greet(name); <4>\n\n    }\n}\n----\n<1> Get the information about the `my-service-name` instance.\n<2> Build `channel` accordingly.\n<3> Create stub using the `channel`.\n<4> Invoke the service.\n\n\n\n== License\n\nApache 2.0\n'