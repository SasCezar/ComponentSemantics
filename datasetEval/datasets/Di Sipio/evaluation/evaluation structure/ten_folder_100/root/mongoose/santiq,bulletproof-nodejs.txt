b'# Bulletproof Node.js architecture \xf0\x9f\x9b\xa1\xef\xb8\x8f\n\nThis is the example repository from the blog post [\'Bulletproof node.js project architecture\'](https://softwareontheroad.com/ideal-nodejs-project-structure?utm_source=github&utm_medium=readme)\n\nPlease read the blog post in order to have a good understanding of the server architecture.\n\nAlso, I added lots of comments to the code that are not in the blog post, because they explain the implementation and the reason behind the choices of libraries and some personal opinions and some bad jokes.\n\nThe API by itself doesn\'t do anything fancy, it\'s just a user CRUD with authentication capabilities.\nMaybe we can transform this into something useful, a more advanced example, just open an issue and let\'s discuss the future of the repo.\n\n## Development\n\nWe use `node` version `10.15.0`\n\n```\nnvm install 10.15.0\n```\n\n```\nnvm use 10.15.0\n```\n\nThe first time, you will need to run\n\n```\nnpm install\n```\n\nThen just start the server with \n\n```\nnpm run start\n```\nIt uses nodemon for livereloading :peace-fingers:\n\n# API Validation\n \n By using celebrate the req.body schema becomes clary defined at route level, so even frontend devs can read what an API endpoint expects without need to writting a documentation that can get outdated quickly.\n\n ```js\n route.post(\'/signup\', \n  celebrate({\n    body: Joi.object({\n      name: Joi.string().required(),\n      email: Joi.string().required(),\n      password: Joi.string().required(),\n    }),\n  }),\n  controller.signup)\n ```\n\n **Example error**\n\n ```json\n {\n  "errors": {\n    "message": "child \\"email\\" fails because [\\"email\\" is required]"\n  }\n } \n ```\n\n[Read more about celebrate here](https://github.com/arb/celebrate) and [the Joi validation API](https://github.com/hapijs/joi/blob/v15.0.1/API.md)\n\n# Roadmap\n- [x] API Validation layer (Celebrate+Joi)\n- [ ] Unit tests examples\n- [ ] [Cluster mode](https://softwareontheroad.com/nodejs-scalability-issues?utm_source=github&utm_medium=readme)\n- [x] The logging _\'layer\'_ \n- [ ] Add ageda dashboard\n- [x] Continuous integration with CircleCI \xf0\x9f\x98\x8d\n- [ ] Deploys script and docs for AWS Elastic Beanstalk and Heroku\n- [ ] Integration test with newman \xf0\x9f\x98\x89\n- [ ] Instructions on typescript debugging with VSCode\n\n\n# FAQ \n\n ## Where should I put the FrontEnd code? Is this a good backend for Angular or React or Vue or _whatever_ ?\n\n  [It\'s not a good idea to have node.js serving static assets a.k.a the frontend](https://softwareontheroad.com/nodejs-scalability-issues?utm_source=github&utm_medium=readme)\n\n  Also, I don\'t wanna take part in frontend frameworks wars \xf0\x9f\x98\x85\n\n  Just use the frontend framework you like the most _or hate the least_. It will work \xf0\x9f\x98\x81\n\n ## Don\'t you think you can add X layer to do Y? Why do you still use express if the Serverless Framework is better and it\'s more reliable?\n\n  I know this is not a perfect architecture but it\'s the most scalable that I know with less code and headache that I know.\n\n  It\'s meant for small startups or one-developer army projects.\n\n  I know if you start moving layers into another technology, you will end up with your business/domain logic into npm packages, your routing layer will be pure AWS Lambda functions and your data layer a combination of DynamoDB, Redis, maybe redshift, and Agolia.\n\n  Take a deep breath and go slowly, let the business grow and then scale up your product. You will need a team and talented developers anyway.\n'