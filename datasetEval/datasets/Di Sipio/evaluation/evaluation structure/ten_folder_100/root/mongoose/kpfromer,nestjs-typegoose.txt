b'# nestjs-typegoose\n\n[![NPM](https://nodei.co/npm/nestjs-typegoose.png)](https://nodei.co/npm/nestjs-typegoose/)\n[![npm version](https://badge.fury.io/js/nestjs-typegoose.svg)](https://badge.fury.io/js/nestjs-typegoose)\n[![Build Status](https://travis-ci.org/kpfromer/nestjs-typegoose.svg?branch=master)](https://travis-ci.org/kpfromer/nestjs-typegoose)\n[![Coverage Status](https://coveralls.io/repos/github/kpfromer/nestjs-typegoose/badge.svg?branch=master)](https://coveralls.io/github/kpfromer/nestjs-typegoose?branch=master)\n\n## Description\n\nInjects [typegoose](https://github.com/szokodiakos/typegoose) models for [nest](https://github.com/nestjs/nest) components and controllers. Typegoose equivalant for [@nestjs/mongoose.](https://docs.nestjs.com/techniques/mongodb)\n\nUsing Typegoose removes the need for having a Model interface.\n\n## Installation\n\n`npm install --save nestjs-typegoose`\n\n## Basic usage\n\n**app.module.ts**\n\n```typescript\nimport { Module } from "@nestjs/common";\nimport { TypegooseModule } from "nestjs-typegoose";\n\n@Module({\n  imports: [\n    TypegooseModule.forRoot("mongodb://localhost:27017/nest", {\n      useNewUrlParser: true\n    }),\n    CatsModule\n  ]\n})\nexport class ApplicationModule {}\n```\n\nCreate class that extends [Typegoose](https://github.com/szokodiakos/typegoose#motivation)\n\n**cat.model.ts**\n\n```typescript\nimport { prop } from "@typegoose/typegoose";\nimport { IsString } from "class-validator";\n\nexport class Cat {\n  @IsString()\n  @prop({ required: true })\n  name: string;\n}\n```\n\nInject Cat for `CatsModule`\n\n**cat.module.ts**\n\n```typescript\nimport { Module } from "@nestjs/common";\nimport { TypegooseModule } from "nestjs-typegoose";\nimport { Cat } from "./cat.model";\nimport { CatsController } from "./cats.controller";\nimport { CatsService } from "./cats.service";\n\n@Module({\n  imports: [TypegooseModule.forFeature([Cat])],\n  controllers: [CatsController],\n  providers: [CatsService]\n})\nexport class CatsModule {}\n```\n\nGet the cat model in a service\n\n**cats.service.ts**\n\n```typescript\nimport { Injectable } from "@nestjs/common";\nimport { InjectModel } from "nestjs-typegoose";\nimport { Cat } from "./cat.model";\nimport { ReturnModelType } from "@typegoose/typegoose";\n\n@Injectable()\nexport class CatsService {\n  constructor(@InjectModel(Cat) private readonly catModel: ReturnModelType<typeof Cat>) {}\n\n  async create(createCatDto: { name: string }): Promise<Cat> {\n    const createdCat = new this.catModel(createCatDto);\n    return await createdCat.save();\n  }\n\n  async findAll(): Promise<Cat[] | null> {\n    return await this.catModel.find().exec();\n  }\n}\n```\n\nFinally, use the service in a controller!\n\n**cats.controller.ts**\n\n```typescript\nimport { Controller, Get, Post, Body } from "@nestjs/common";\nimport { CatsService } from "./cats.service";\n\n@Controller("cats")\nexport class CatsController {\n  constructor(private readonly catsService: CatsService) {}\n\n  @Get()\n  async getCats(): Promise<Cat[] | null> {\n    return await this.catsService.findAll();\n  }\n\n  @Post()\n  async create(@Body() cat: Cat): Promise<Cat> {\n    return await this.catsService.create(cat);\n  }\n}\n```\n\n### Mongoose Schema Options\n\nTo add custom [mongoose schema options](http://mongoosejs.com/docs/guide.html#options)\nyou can simply change `Typegoose.forFeature` to the following format:\n\n```typescript\n@Module({\n  imports: [\n    TypegooseModule.forFeature([\n      {\n        typegooseClass: Cat,\n        schemaOptions: {\n          collection: "ADifferentCollectionNameForCats"\n        }\n      }\n    ])\n  ]\n})\nexport class CatsModule {}\n```\n\n### Async Mongoose Schema Options\n\nTo provide asynchronous mongoose schema options (similar to [nestjs mongoose implementation](https://docs.nestjs.com/techniques/mongodb)) you can use the `TypegooseModule.forRootAsync`\n\n```typescript\n@Module({\n  imports: [\n    TypegooseModule.forRootAsync({\n      imports: [ConfigModule],\n      useFactory: async (configService: ConfigService) => ({\n        uri: configService.getString("MONGODB_URI")\n        // ...typegooseOptions (Note: config is spread with the uri)\n      }),\n      inject: [ConfigService]\n    })\n  ]\n})\nexport class CatsModule {}\n```\n\n#### Note: typegooseOptions with async\n\nThe typegooseOptions is spread with the `uri`. The `uri` is required!\n\nYou can also use a class with `useClass`\n\n```typescript\nimport {\n  TypegooseOptionsFactory,\n  TypegooseModuleOptions\n} from "nestjs-typegoose";\n\nclass TypegooseConfigService extends TypegooseOptionsFactory {\n  createTypegooseOptions():\n    | Promise<TypegooseModuleOptions>\n    | TypegooseModuleOptions {\n    return {\n      uri: "mongodb://localhost/nest"\n    };\n  }\n}\n\n@Module({\n  imports: [\n    TypegooseModule.forAsyncRoot({\n      useClass: TypegooseConfigService\n    })\n  ]\n})\nexport class CatsModule {}\n```\n\nOr if you want to prevent creating another `TypegooseConfigService` class and want to use it from another imported module then use `useExisting`\n\n```typescript\n@Module({\n  imports: [\n    TypegooseModule.forAsyncRoot({\n      imports: [ConfigModule],\n      useExisting: ConfigService\n    })\n  ]\n})\nexport class CatsModule {}\n```\n\n### Multiple MongoDB Connections\n\nTo have multiple mongoDB connections one needs to add a `connectionName` string to `forRoot` and `forFeature`.\n\n**app.module.ts**\n\n```typescript\nimport { Module } from "@nestjs/common";\nimport { TypegooseModule } from "nestjs-typegoose";\n\n@Module({\n  imports: [\n    TypegooseModule.forRoot("mongodb://localhost:27017/otherdb", {\n      useNewUrlParser: true,\n      connctionName: "other-mongodb"\n    }),\n    CatsModule\n  ]\n})\nexport class ApplicationModule {}\n```\n\n**cat.module.ts**\n\n```typescript\n@Module({\n  imports: [TypegooseModule.forFeature([Cat], "other-mongodb")],\n  controllers: [CatsController],\n  providers: [CatsService]\n})\nexport class CatsModule {}\n```\n\nAnd for `forAsyncRoot` add `connectionName` to the options as well.\n\n```typescript\n@Module({\n  imports: [\n    TypegooseModule.forAsyncRoot({\n      connectionName: "other-mongodb",\n      imports: [ConfigModule],\n      useFactory: async (configService: ConfigService) => ({\n        uri: configService.getString("MONGODB_URI"),\n        connectionName: config\n        // ...typegooseOptions (Note: config is spread with the uri)\n      }),\n      inject: [ConfigService]\n    })\n  ]\n})\nexport class CatsModule {}\n```\n\n## Testing\n\nLike [@nestjs/mongoose](https://docs.nestjs.com/v5/techniques/mongodb) (see the testing section) nestjs-typegoose\'s `forFeature` and `forRoot` rely on a database connection to work. To unit test your `CatService` without connecting to a mongo database you need to create a fake model using a [custom provider](https://docs.nestjs.com/fundamentals/custom-providers).\n\n```typescript\nimport { getModelToken } from "nestjs-typegoose";\n\n...\n\n@Module({\n  ProductService,\n  {\n    provide: getModelToken(\'Product\'),\n    useValue: fakeProductModel\n  }\n})\n```\n\nIn a spec file this would look like:\n\n```typescript\nconst module: TestingModule = await Test.createTestingModule({\n  providers: [\n    {\n      provide: getModelToken("Product"),\n      useValue: productModel\n    },\n    ProductService\n  ]\n}).compile();\n```\n\nThe string given to `getModelToken` function should be the class name of the typegoose model that you are testing.\n\n## FAQ\n\n---\n\n**Q:** \'useNewUrlParser\' does not exist in type \'TypegooseConnectionOptions\'\n\n**A:** Make sure that you have the typings for mongoose installed. `npm install --save-dev @types/mongoose`\n\n---\n\n## Requirements\n\n1.  @typegoose/typegoose +6.0.0\n2.  @nestjs/common +5.0.0\n3.  @nestjs/core +5.0.0\n4.  mongoose (with typings `@types/mongoose`) +5.1.1\n\n## License\n\nnestjs-typegoose is [MIT licensed](LICENSE).\n'