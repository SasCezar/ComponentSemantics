b'# graphql-compose-mongoose\n\n[![travis build](https://img.shields.io/travis/graphql-compose/graphql-compose-mongoose.svg)](https://travis-ci.org/graphql-compose/graphql-compose-mongoose)\n[![codecov coverage](https://img.shields.io/codecov/c/github/graphql-compose/graphql-compose-mongoose.svg)](https://codecov.io/github/graphql-compose/graphql-compose-mongoose)\n[![npm](https://img.shields.io/npm/v/graphql-compose-mongoose.svg)](https://www.npmjs.com/package/graphql-compose-mongoose)\n[![trends](https://img.shields.io/npm/dt/graphql-compose-mongoose.svg)](http://www.npmtrends.com/graphql-compose-mongoose)\n[![Join the chat at https://gitter.im/graphql-compose/Lobby](https://badges.gitter.im/graphql-compose/graphql-compose.svg)](https://gitter.im/graphql-compose/Lobby)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n\nThis is a plugin for [graphql-compose](https://github.com/graphql-compose/graphql-compose), which derives GraphQLType from your [mongoose model](https://github.com/Automattic/mongoose). Also derives bunch of internal GraphQL Types. Provide all CRUD resolvers, including `graphql connection`, also provided basic search via operators ($lt, $gt and so on).\n\n## Installation\n\n```bash\nnpm install graphql graphql-compose mongoose graphql-compose-mongoose --save\n```\n\nModules `graphql`, `graphql-compose`, `mongoose` are in `peerDependencies`, so should be installed explicitly in your app. They have global objects and should not have ability to be installed as submodule.\n\nIf you want to add additional resolvers [`connection`](https://github.com/graphql-compose/graphql-compose-connection) and/or [`pagination`](https://github.com/graphql-compose/graphql-compose-pagination) - just install following packages and `graphql-compose-mongoose` will add them automatically.\n\n```bash\nnpm install graphql-compose-connection graphql-compose-pagination --save\n```\n\n### Different builds\n\nThis library contains different builds for any purposes:\n\n```js\n// Default import for using under node v6 and above\nimport { composeWithMongoose } from \'graphql-compose-mongoose\';\n\n// For using node 8 and above (native async/await)\nimport { composeWithMongoose } from \'graphql-compose-mongoose/node8\';\n\n// Source code without Flowtype declarations\nimport { composeWithMongoose } from \'graphql-compose-mongoose/es\';\n```\n\n## Example\n\nLive demo: [https://graphql-compose.herokuapp.com/](https://graphql-compose.herokuapp.com/)\n\nSource code: https://github.com/graphql-compose/graphql-compose-examples\n\nSmall explanation for variables naming:\n\n- `UserSchema` - this is a mongoose schema\n- `User` - this is a mongoose model\n- `UserTC` - this is a `ObjectTypeComposer` instance for User. `ObjectTypeComposer` has `GraphQLObjectType` inside, avaliable via method `UserTC.getType()`.\n- Here and in all other places of code variables suffix `...TC` means that this is `ObjectTypeComposer` instance, `...ITC` - `InputTypeComposer`, `...ETC` - `EnumTypeComposer`.\n\n```js\nimport mongoose from \'mongoose\';\nimport { composeWithMongoose } from \'graphql-compose-mongoose\';\nimport { schemaComposer } from \'graphql-compose\';\n\n// STEP 1: DEFINE MONGOOSE SCHEMA AND MODEL\nconst LanguagesSchema = new mongoose.Schema({\n  language: String,\n  skill: {\n    type: String,\n    enum: [ \'basic\', \'fluent\', \'native\' ],\n  },\n});\n\nconst UserSchema = new mongoose.Schema({\n  name: String, // standard types\n  age: {\n    type: Number,\n    index: true,\n  },\n  languages: {\n    type: [LanguagesSchema], // you may include other schemas (here included as array of embedded documents)\n    default: [],\n  },\n  contacts: { // another mongoose way for providing embedded documents\n    email: String,\n    phones: [String], // array of strings\n  },\n  gender: { // enum field with values\n    type: String,\n    enum: [\'male\', \'female\', \'ladyboy\'],\n  },\n  someMixed: {\n    type: mongoose.Schema.Types.Mixed,\n    description: \'Can be any mixed type, that will be treated as JSON GraphQL Scalar Type\',\n  },\n});\nconst User = mongoose.model(\'User\', UserSchema);\n\n\n\n// STEP 2: CONVERT MONGOOSE MODEL TO GraphQL PIECES\nconst customizationOptions = {}; // left it empty for simplicity, described below\nconst UserTC = composeWithMongoose(User, customizationOptions);\n\n// STEP 3: Add needed CRUD User operations to the GraphQL Schema\n// via graphql-compose it will be much much easier, with less typing\nschemaComposer.Query.addFields({\n  userById: UserTC.getResolver(\'findById\'),\n  userByIds: UserTC.getResolver(\'findByIds\'),\n  userOne: UserTC.getResolver(\'findOne\'),\n  userMany: UserTC.getResolver(\'findMany\'),\n  userCount: UserTC.getResolver(\'count\'),\n  userConnection: UserTC.getResolver(\'connection\'),\n  userPagination: UserTC.getResolver(\'pagination\'),\n});\n\nschemaComposer.Mutation.addFields({\n  userCreateOne: UserTC.getResolver(\'createOne\'),\n  userCreateMany: UserTC.getResolver(\'createMany\'),\n  userUpdateById: UserTC.getResolver(\'updateById\'),\n  userUpdateOne: UserTC.getResolver(\'updateOne\'),\n  userUpdateMany: UserTC.getResolver(\'updateMany\'),\n  userRemoveById: UserTC.getResolver(\'removeById\'),\n  userRemoveOne: UserTC.getResolver(\'removeOne\'),\n  userRemoveMany: UserTC.getResolver(\'removeMany\'),\n});\n\nconst graphqlSchema = schemaComposer.buildSchema();\nexport default graphqlSchema;\n```\n\nThat\'s all!\nYou think that is to much code?\nI don\'t think so, because by default internally was created about 55 graphql types (for input, sorting, filtering). So you will need much much more lines of code to implement all these CRUD operations by hands.\n\n### Working with Mongoose Collection Level Discriminators\n\nVariable Namings\n\n- `...DTC` - Suffix for a `DiscriminatorTypeComposer` instance, which is also an instance of `ObjectTypeComposer`. All fields and Relations manipulations on this instance affects all registered discriminators and the Discriminator Interface.\n\n```js\n  import mongoose from \'mongoose\';\n  import { schemaComposer } from \'graphql-compose\';\n  import { composeWithMongooseDiscriminators } from \'graphql-compose-mongoose\';\n\n  // pick a discriminatorKey\n  const DKey = \'type\';\n\n  const enumCharacterType = {\n    PERSON: \'Person\',\n    DROID: \'Droid\',\n  };\n\n  // DEFINE BASE SCHEMA\n  const CharacterSchema = new mongoose.Schema({\n    // _id: field...\n    type: {\n      type: String,\n      require: true,\n      enum: (Object.keys(enumCharacterType): Array<string>),\n      description: \'Character type Droid or Person\',\n    },\n\n    name: String,\n    height: Number,\n    mass: Number,\n    films: [String],\n  });\n\n  // DEFINE DISCRIMINATOR SCHEMAS\n  const DroidSchema = new mongoose.Schema({\n    makeDate: String,\n    primaryFunction: [String],\n  });\n\n  const PersonSchema = new mongoose.Schema({\n    gender: String,\n    hairColor: String,\n    starships: [String],\n  });\n\n  // set discriminator Key\n  CharacterSchema.set(\'discriminatorKey\', DKey);\n\n  // create base Model\n  const CharacterModel = mongoose.model(\'Character\', CharacterSchema);\n\n  // create mongoose discriminator models\n  const DroidModel = CharacterModel.discriminator(enumCharacterType.DROID, DroidSchema);\n  const PersonModel = CharacterModel.discriminator(enumCharacterType.PERSON, PersonSchema);\n\n  // create DiscriminatorTypeComposer\n  const baseOptions = { // regular TypeConverterOptions, passed to composeWithMongoose\n    fields: {\n      remove: [\'friends\'],\n    }\n  }\n  const CharacterDTC = composeWithMongooseDiscriminators(CharacterModel, baseOptions);\n\n  // create Discriminator Types\n  const droidTypeConverterOptions = {  // this options will be merged with baseOptions -> customisationsOptions\n    fields: {\n      remove: [\'makeDate\'],\n    }\n  };\n  const DroidTC = CharacterDTC.discriminator(DroidModel, droidTypeConverterOptions);\n  const PersonTC = CharacterDTC.discriminator(PersonModel);  // baseOptions -> customisationsOptions applied\n\n  // You may now use CharacterDTC to add fields to all Discriminators\n  // Use DroidTC, `PersonTC as any other ObjectTypeComposer.\n  schemaComposer.Mutation.addFields({\n    droidCreate: DroidTC.getResolver(\'createOne\'),\n    personCreate: PersonTC.getResolver(\'createOne\'),\n  });\n\n  const schema = schemaComposer.buildSchema();\n\n  describe(\'createOne\', () => {\n    it(\'should create child document without specifying DKey\', async () => {\n      const res = await graphql.graphql(\n        schema,\n        `mutation CreateCharacters {\n          droidCreate(record: {name: "Queue XL", modelNumber: 360 }) {\n            record {\n              __typename\n              type\n              name\n              modelNumber\n            }\n          }\n\n          personCreate(record: {name: "mernxl", dob: 57275272}) {\n            record {\n              __typename\n              type\n              name\n              dob\n            }\n          }\n        }`\n      );\n\n      expect(res).toEqual({\n        data: {\n          droidCreate: {\n            record: { __typename: \'Droid\', type: \'Droid\', name: \'Queue XL\', modelNumber: 360 },\n          },\n          personCreate: {\n            record: { __typename: \'Person\', type: \'Person\', name: \'mernxl\', dob: 57275272 },\n          },\n        },\n      });\n    });\n  });\n```\n\n## FAQ\n\n### Can I get generated vanilla GraphQL types?\n\n```js\nconst UserTC = composeWithMongoose(User);\nUserTC.getType(); // returns GraphQLObjectType\nUserTC.getInputType(); // returns GraphQLInputObjectType, eg. for args\nUserTC.get(\'languages\').getType(); // get GraphQLObjectType for nested field\nUserTC.get(\'fieldWithNesting.subNesting\').getType(); // get GraphQL type of deep nested field\n```\n\n### How to add custom fields?\n\n```js\nUserTC.addFields({\n  lonLat: ObjectTypeComposer.create(\'type LonLat { lon: Float, lat: Float }\'),\n  notice: \'String\', // shorthand definition\n  noticeList: { // extended\n    type: \'[String]\', // String, Int, Float, Boolean, ID, Json\n    description: \'Array of notices\',\n    resolve: (source, args, context, info) => \'some value\',\n  },\n  bio: {\n    type: GraphQLString,\n    description: \'Providing vanilla GraphQL type\'\n  }\n})\n```\n\n### How to build nesting/relations?\n\nSuppose you `User` model has `friendsIds` field with array of user ids. So let build some relations:\n\n```js\nUserTC.addRelation(\n  \'friends\',\n  {\n    resolver: () => UserTC.getResolver(\'findByIds\'),\n    prepareArgs: { // resolver `findByIds` has `_ids` arg, let provide value to it\n      _ids: (source) => source.friendsIds,\n    },\n    projection: { friendsIds: 1 }, // point fields in source object, which should be fetched from DB\n  }\n);\nUserTC.addRelation(\n  \'adultFriendsWithSameGender\',\n  {\n    resolver: () => UserTC.get(\'$findMany\'), // shorthand for `UserTC.getResolver(\'findMany\')`\n    prepareArgs: { // resolver `findMany` has `filter` arg, we may provide mongoose query to it\n      filter: (source) => ({\n        _operators : { // Applying criteria on fields which have\n                       // operators enabled for them (by default, indexed fields only)\n          _id : { in: source.friendsIds },\n          age: { gt: 21 }\n        },\n        gender: source.gender,\n      }),\n      limit: 10,\n    },\n    projection: { friendsIds: 1, gender: 1 }, // required fields from source object\n  }\n);\n```\n\n### Reusing the same mongoose Schema in embedded object fields\n\nSuppose you have a common structure you use as embedded object in multiple Schemas.\nAlso suppose you want the structure to have the same GraphQL type across all parent types.\n(For instance, to allow reuse of fragments for this type)\nHere are Schemas to demonstrate:\n\n```js\nimport { Schema } from \'mongoose\';\n\nconst ImageDataStructure = Schema({\n  url: String,\n  dimensions : {\n    width: Number,\n    height: Number\n  }\n}, { _id: false });\n\nconst UserProfile = Schema({\n  fullName: String,\n  personalImage: ImageDataStructure\n});\n\nconst Article = Schema({\n  title: String,\n  heroImage: ImageDataStructure\n});\n```\n\nIf you want the `ImageDataStructure` to use the same GraphQL type in both `Article` and `UserProfile` you will need create it as a mongoose schema (not a standard javascript object) and to explicitly tell `graphql-compose-mongoose` the name you want it to have. Otherwise, without the name, it would generate the name according to the first parent this type was embedded in.\n\nDo the following:\n\n```js\nimport { schemaComposer } from \'graphql-compose\'; // get the default schemaComposer or your created schemaComposer\nimport { convertSchemaToGraphQL } from \'graphql-compose-mongoose\';\n\nconvertSchemaToGraphQL(ImageDataStructure, \'EmbeddedImage\', schemaComposer); // Force this type on this mongoose schema\n```\n\nBefore continuing to convert your models to TypeComposers:\n\n```js\nimport mongoose from \'mongoose\';\nimport { composeWithMongoose } from \'graphql-compose-mongoose\';\n\nconst UserProfile = mongoose.model(\'UserProfile\', UserProfile);\nconst Article = mongoose.model(\'Article\', Article);\n\nconst UserProfileTC = composeWithMongoose(UserProfile);\nconst ArticleTC = composeWithMongoose(Article);\n```\n\nThen, you can use queries like this:\n\n```graphql\nquery {\n  topUser {\n    fullName\n    personalImage {\n      ...fullImageData\n    }\n  }\n  topArticle {\n    title\n    heroImage {\n      ...fullImageData\n    }\n  }\n}\nfragment fullImageData on EmbeddedImage {\n  url\n  dimensions {\n    width height\n  }\n}\n```\n\n### Access and modify mongoose doc before save\n\nThis library provides some amount of ready resolvers for fetch and update data which was mentioned above. And you can [create your own resolver](https://github.com/graphql-compose/graphql-compose) of course. However you can find that add some actions or light modifications of mongoose document directly before save at existing resolvers appears more simple than create new resolver. Some of resolvers accepts *before save hook* which can be provided in *resolver params* as param named `beforeRecordMutate`. This hook allows to have access and modify mongoose document before save. The resolvers which supports this hook are:\n\n- createOne\n- createMany\n- removeById\n- removeOne\n- updateById\n- updateOne\n\nThe prototype of before save hook:\n\n```js\n(doc: mixed, rp: ResolverResolveParams) => Promise<*>,\n```\n\nThe typical implementation may be like this:\n\n```js\n// extend resolve params with hook\nrp.beforeRecordMutate = async function(doc, rp) {\n  doc.userTouchedAt = new Date();\n\n  const canMakeUpdate  = await performAsyncTask( ...provide data from doc... )\n  if (!canMakeUpdate) {\n    throw new Error(\'Forbidden!\');\n  }\n\n  return doc;\n}\n```\n\nYou can provide your implementation directly in type composer:\n\n```js\nUserTC.wrapResolverResolve(\'updateById\', next => async rp => {\n\n  // extend resolve params with hook\n  rp.beforeRecordMutate = async (doc, resolveParams) => { ... };\n\n  return next(rp);\n});\n```\n\nor you can create wrappers for example to protect access:\n\n```js\nfunction adminAccess(resolvers) {\n  Object.keys(resolvers).forEach((k) => {\n    resolvers[k] = resolvers[k].wrapResolve(next => async rp => {\n\n      // extend resolve params with hook\n      rp.beforeRecordMutate = async function(doc, rp) { ... }\n\n      return next(rp)\n    })\n  })\n  return resolvers\n}\n\n// and wrap the resolvers\nschemaComposer.Mutation.addFields({\n  createResource: ResourceTC.getResolver(\'createOne\'),\n  createResources: ResourceTC.getResolver(\'createMany\'),\n  ...adminAccess({\n    updateResource: ResourceTC.getResolver(\'updateById\'),\n    removeResource: ResourceTC.getResolver(\'removeById\'),\n  }),\n});\n```\n\n### How can I push/pop or add/remove values to arrays?\n\nThe default resolvers, by design, will replace (overwrite) any supplied array object when using e.g. `updateById`. If you want to push or pop a value in an array you can use a custom resolver with a native MongoDB call.\n\nFor example (push):-\n\n```js\n// Define new resolver \'pushToArray\'\nUserTC.addResolver({\n  name: \'pushToArray\',\n  type: UserTC,\n  args: { userId: \'MongoID!\', valueToPush: \'String\' },\n  resolve: async ({ source, args, context, info }) => {\n    const user = await User.update({ _id: args.userId }, { $push: { arrayToPushTo: args.valueToPush } } })\n    if (!user) return null // or gracefully return an error etc...\n    return User.findOne({ _id: args.userId }) // return the record\n  }\n})\n\n// Then add \'pushToArray\' as a graphql field e.g.\nschemaComposer.Mutation.addFields({userPushToArray: UserTC.getResolver(\'pushToArray\')})\n```\n\n`User` is the corresponding Mongoose model. If you do not wish to allow duplicates in the array then replace `$push` with `$addToSet`. Read the graphql-compose docs on custom resolvers for more info: https://graphql-compose.github.io/docs/en/basics-resolvers.html\n\nNB if you set `unique: true` on the array then using the `update` `$push` approach will not check for duplicates, this is due to a MongoDB bug: https://jira.mongodb.org/browse/SERVER-1068. For more usage examples with `$push` and arrays see the MongoDB docs here https://docs.mongodb.com/manual/reference/operator/update/push/. Also note that `$push` will preserve order in the array (append to end of array) whereas `$addToSet` will not.\n\n### Is it possible to use several schemas?\n\nBy default `composeWithMongoose` uses global `schemaComposer` for generated types. If you need to create different GraphQL schemas you need create own `schemaComposer`s and provide them to `customizationOptions`:\n\n```js\nimport { SchemaComposer } from \'graphql-compose\';\n\nconst schema1 = new SchemaComposer();\nconst schema2 = new SchemaComposer();\n\nconst UserTCForSchema1 = composeWithMongoose(User, { schemaComposer: schema1 });\nconst UserTCForSchema2 = composeWithMongoose(User, { schemaComposer: schema2 });\n```\n\n## Customization options\n\nWhen we convert model `const UserTC = composeWithMongoose(User, customizationOptions);` you may tune every piece of future derived types and resolvers.\n\n### Here is flow typed definition of this options:\n\nThe top level of customization options. Here you setup name and description for the main type, remove fields or leave only desired fields.\n\n```js\nexport type customizationOptions = {\n  schemaComposer?: SchemaComposer<TContext>, // will be used global schema if not provided specific instance\n  name?: string,\n  description?: string,\n  fields?: {\n    only?: string[],\n    remove?: string[],\n  },\n  inputType?: typeConverterInputTypeOpts,\n  resolvers?: false | typeConverterResolversOpts,\n};\n```\n\nThis is `opts.inputType` level of options for default InputTypeObject which will be provided to all resolvers for `filter` and `input` args.\n\n```js\nexport type typeConverterInputTypeOpts = {\n  name?: string,\n  description?: string,\n  fields?: {\n    only?: string[],\n    remove?: string[],\n    required?: string[]\n  },\n};\n```\n\nThis is `opts.resolvers` level of options.\nIf you set the option to `false` it will disable resolver or some of its input args.\nEvery resolver\'s arg has it own options. They described below.\n\n```js\nexport type typeConverterResolversOpts = {\n  findById?: false,\n  findByIds?: false | {\n    limit?: limitHelperArgsOpts | false,\n    sort?: sortHelperArgsOpts | false,\n  },\n  findOne?: false | {\n    filter?: filterHelperArgsOpts | false,\n    sort?: sortHelperArgsOpts | false,\n    skip?: false,\n  },\n  findMany?: false | {\n    filter?: filterHelperArgsOpts | false,\n    sort?: sortHelperArgsOpts | false,\n    limit?: limitHelperArgsOpts | false,\n    skip?: false,\n  },\n  updateById?: false | {\n    record?: recordHelperArgsOpts | false,\n  },\n  updateOne?: false | {\n    record?: recordHelperArgsOpts | false,\n    filter?: filterHelperArgsOpts | false,\n    sort?: sortHelperArgsOpts | false,\n    skip?: false,\n  },\n  updateMany?: false | {\n    record?: recordHelperArgsOpts | false,\n    filter?: filterHelperArgsOpts | false,\n    sort?: sortHelperArgsOpts | false,\n    limit?: limitHelperArgsOpts | false,\n    skip?: false,\n  },\n  removeById?: false,\n  removeOne?: false | {\n    filter?: filterHelperArgsOpts | false,\n    sort?: sortHelperArgsOpts | false,\n  },\n  removeMany?: false | {\n    filter?: filterHelperArgsOpts | false,\n  },\n  createOne?: false | {\n    record?: recordHelperArgsOpts | false,\n  },\n  createMany?: false | {\n    records?: recordHelperArgsOpts | false,\n  },\n  count?: false | {\n    filter?: filterHelperArgsOpts | false,\n  },\n  connection?: false | {\n    uniqueFields: string[],\n    sortValue: mixed,\n    directionFilter: (<T>(filterArg: T, cursorData: CursorDataType, isBefore: boolean) => T),\n  },\n  pagination?: false | {\n    perPage?: number,\n  },\n};\n```\n\nThis is `opts.resolvers.[resolverName].[filter|sort|record|limit]` level of options.\nYou may tune every resolver\'s args independently as you wish.\nHere you may setup every argument and override some fields from the default input object type, described above in `opts.inputType`.\n\n```js\nexport type filterHelperArgsOpts = {\n  filterTypeName?: string, // type name for `filter`\n  isRequired?: boolean, // set `filter` arg as required (wraps in GraphQLNonNull)\n  onlyIndexed?: boolean, // leave only that fields, which is indexed in mongodb\n  requiredFields?: string | string[], // provide fieldNames, that should be required\n  operators?: filterOperatorsOpts | false, // provide filtering fields by operators, eg. $lt, $gt\n                                           // if left empty - provides all operators on indexed fields\n};\n\n// supported operators names in filter `arg`\nexport type filterOperatorNames =  \'gt\' | \'gte\' | \'lt\' | \'lte\' | \'ne\' | \'in[]\' | \'nin[]\';\nexport type filterOperatorsOpts = { [fieldName: string]: filterOperatorNames[] | false };\n\nexport type sortHelperArgsOpts = {\n  sortTypeName?: string, // type name for `sort`\n};\n\nexport type recordHelperArgsOpts = {\n  recordTypeName?: string, // type name for `record`\n  isRequired?: boolean, // set `record` arg as required (wraps in GraphQLNonNull)\n  removeFields?: string[], // provide fieldNames, that should be removed\n  requiredFields?: string[], // provide fieldNames, that should be required\n};\n\nexport type limitHelperArgsOpts = {\n  defaultValue?: number, // set your default limit, if it not provided in query (default: 1000)\n};\n```\n\n## Used plugins\n\n### [graphql-compose-connection](https://github.com/graphql-compose/graphql-compose-connection)\n\nThis plugin adds `connection` resolver. Build in mechanism allows sort by any unique indexes (not only by id). Also supported compound sorting (by several fields).\n\nBesides standard connection arguments `first`, `last`, `before` and `after`, also added great arguments:\n\n- `filter` arg - for filtering records\n- `sort` arg - for sorting records\n\nThis plugin completely follows to [Relay Cursor Connections Specification](https://facebook.github.io/relay/graphql/connections.htm).\n\n### [graphql-compose-pagination](https://github.com/graphql-compose/graphql-compose-pagination)\n\nThis plugin adds `pagination` resolver.\n\n## License\n\n[MIT](https://github.com/graphql-compose/graphql-compose-mongoose/blob/master/LICENSE.md)\n'