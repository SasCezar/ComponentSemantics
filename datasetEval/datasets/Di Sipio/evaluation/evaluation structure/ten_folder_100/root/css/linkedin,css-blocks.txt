b'<p align="center">\n  <img alt="CSS Blocks" width="480px" src="http://css-blocks.com/static/media/wordmark-animated.012177e4.svg" />\n</p>\n<h2 align="center">Blazing fast CSS for your Design Systems and App Components </h2>\n\n[![Build Status](https://travis-ci.com/linkedin/css-blocks.svg?token=StHPTowsdWydAGro7djA&branch=master)](https://travis-ci.com/linkedin/css-blocks) [![Greenkeeper badge](https://badges.greenkeeper.io/linkedin/css-blocks.svg)](https://greenkeeper.io/)\n\n---\n\nCSS Blocks is an ergonomic, component-oriented CSS authoring system that compiles to high-performance stylesheets.\n\nBy combining an opinionated authoring system, build-time analysis and rewriting of templates, and a new type of CSS optimizer, css-blocks breathes new power and ease of use into the technologies and best practices that stylesheet developers already know and love.\n\n> Interested in contributing, or just seeing CSS Blocks in action? Head over to [CONTRIBUTING.md](./CONTRIBUTING.md) to learn how to spin up the project!\n\n<details>\n  <summary>Table of Contents</summary>\n\n<!-- toc -->\n\n- [Why CSS Blocks?](#why-css-blocks)\n  * [The \xe2\x9a\xa1\xef\xb8\x8f of Static Analysis](#the-\xef\xb8\x8f-of-static-analysis)\n- [\xe2\x9a\x99\xef\xb8\x8f Supported Integrations](#\xef\xb8\x8f-supported-integrations)\n- [\xf0\x9f\x8e\x81 API Features](#-api-features)\n- [\xf0\x9f\x8e\xa8 What is a Block?](#-what-is-a-block)\n  * [The Scope Selector](#the-scope-selector)\n  * [Class Selectors](#class-selectors)\n  * [State Selectors](#state-selectors)\n  * [Sub-State Selectors](#sub-state-selectors)\n  * [Its Just CSS!\xe2\x84\xa2\xef\xb8\x8f (mostly)](#its-just-css\xef\xb8\x8f-mostly)\n  * [Blocks in Your Templates](#blocks-in-your-templates)\n- [\xf0\x9f\x8f\x97 Block Composition](#-block-composition)\n  * [Block References](#block-references)\n- [Object Oriented Features of Blocks](#object-oriented-features-of-blocks)\n  * [Block Implementation](#block-implementation)\n- [Style Composition](#style-composition)\n  * [Block Paths](#block-paths)\n  * [Composition in Templates](#composition-in-templates)\n  * [Block Resolutions](#block-resolutions)\n  * [External Selectors](#external-selectors)\n  * [Global States](#global-states)\n\n<!-- tocstop -->\n\n</details>\n\n# Why CSS Blocks?\nWith css-blocks added to your project, you receive:\n\n - \xf0\x9f\x92\x8e One CSS File Per Component\n - \xf0\x9f\x93\xa6 Scoped Styles\n - \xf0\x9f\x94\x8e Nearly Non-Existent Runtime (~500b)\n - \xf0\x9f\x94\xa5 Blazing Fast Stylesheets\n - \xf0\x9f\x9a\x80 Project-Wide Optimization\n - \xf0\x9f\x9a\xa8 Build Time CSS Errors\n - \xf0\x9f\xa7\x9f Dead Code Elimination\n - \xe2\x9c\xa8 Object Oriented Inheritance\n\nBut, most importantly, CSS Blocks is **\xe2\x9a\xa1\xef\xb8\x8fStatically Analyzable**.\n\n## The \xe2\x9a\xa1\xef\xb8\x8f of Static Analysis\nStatic analysis means css-blocks can look at your project and know with *certainty* that any given CSS declaration will, will not, or might under certain conditions, be used on any given element in your templates.\n\nMost stylesheet architectures have to walk a fine line between performance and\nmaintainability. Tilt too far in either direction and either your users or the developers\nwill end up paying the cost. With CSS Blocks, you can focus on making sure your\nstylesheets are easy to maintain as your application changes, and with the new\nCSS optimizer, [OptiCSS](https://github.com/linkedin/opticss), the small size of your\napp\'s production stylesheets after compression will amaze you.\n\nGone are the days where you spend several minutes debugging your app only to discover a subtle typo that caused a selector to not match \xe2\x80\x93 CSS Blocks will give you a build error and suggest possible fixes. With IDE integration, projects using CSS Blocks will be able to quickly navigate to selector definitions that match your current template element and find which template elements match your current selector, autocomplete class names. With CSS Blocks new resolution system, cascade conflicts will be caught for you before you even know they exist and you will never have to fight a specificity war ever again.\n\n![CSS Blocks Example](https://user-images.githubusercontent.com/7856443/39090683-78ca1966-459a-11e8-8128-f50a9b2a1810.jpg)\n\n> CSS Blocks is inspired by [CSS Modules](https://github.com/css-modules/css-modules), [BEM](http://getbem.com/) and [Atomic CSS](https://acss.io/)\n>\n> For a full deep-dive of the project architecture, I heavily recommend you review the [CSS Blocks Architecture README](./ARCHITECTURE.md)!\n\n# \xe2\x9a\x99\xef\xb8\x8f Supported Integrations\n\nCSS Blocks requires deep integration with your build system and templating language. To learn how to install css-blocks for in your application, please consult the specific docs for your templating system and build system.\n\nCSS Blocks is available for use in the following templating languages:\n\n - [JSX / React][JSX]\n - [Glimmer][GLIMMER]\n\nAnd has integrations with the following build systems:\n\n - [Webpack][WEBPACK]\n - [Broccoli][BROCCOLI]\n - [Ember-CLI][EMBER_CLI] (Glimmer Only)\n\n> Don\'t see your preferred platform yet?\n>\n> Learn how to make your own [Template Integration](./ARCHITECTURE.md#template-integrations) or [Build System Integration](./ARCHITECTURE.md#build-system-integrations) and contribute it back!\n\n# \xf0\x9f\x8e\x81 API Features\n\nCSS Blocks is under active development and there are a number of features that have not yet been implemented! You can get a snapshot of the feature-set state here.\n\n> \xe2\x9c\x85 = Implemented  |  \xe2\x9d\x8c = Not Implemented  |  \xf0\x9f\x92\x80 = Deprecated  |  \xf0\x9f\x96\x8c = In Proposal  |\n\n|**Status**| **Feature** | **Description** |\n|:--:|:--|:--|\n| **Selectors** ||\n| \xe2\x9c\x85 | `:scope` | Scope selector for component root. |\n| \xe2\x9c\x85 | `.class` | Class selectors for component sub-elements. |\n| \xe2\x9c\x85 | <code>.class[name]</code> | State that is applied to scope and class selectors on state existence. |\n| \xe2\x9c\x85 | <code>.class[name="value"]</code> | Mutually exclusive sub-states for scope and class selectors to be applied when a sub-state value matches. |\n| \xe2\x9d\x8c | <code>[name=value]</code> | Bare state (not associated with an Originating Element) and optional substate selectors for targeting all elements in the Block that possess the state and/or sub-state. |\n| \xf0\x9f\x96\x8c | <code>.class[name=value default]</code> | Default state value to be applied when there is no other match. |\n| **At Rules** ||\n| \xe2\x9c\x85 | `@block local-name from "./file/path.css"` | Reference another Block using a local name. |\n| \xe2\x9c\x85 | `@block-debug block-name to channel` | Debug call that will print a block interface to a "channel": `comment`, `stderr`, or `stdout`. |\n| \xe2\x9c\x85 | `@block-global block.path` | Declare a Block class or state as public. It may be used as a context selector in other Blocks. |\n| **Properties** ||\n| \xe2\x9c\x85 | `block-name: "custom-name";` | Provide custom Block names in `:scope` for a nicer debugging experience. |\n| \xe2\x9c\x85 | `implements: block-name;` | A Block can declare that it implements one or more other Block\'s interfaces in its `:scope` selector and the compiler will ensure that all of those states and classes are styled locally. |\n| \xe2\x9c\x85 | `extends: block-name;` | A Block may specify it extends another Block in its `:scope` selector to inherit and extend all the class and state implementations therein. |\n| \xe2\x9c\x85 | `composes: "block.path";` | Mixin-Style class and state composition. Apply other Blocks\' Styles to one of yours.  |\n| **Functions** ||\n| \xe2\x9c\x85 | `resolve("block.path");` | Provide an explicit resolution for a given property against another Block. |\n| \xe2\x9d\x8c | `constrain(val1, val2 ... valN);` | Constrain this property to a list of specific values that may be set when this Block is extended. |\n| \xe2\x9d\x8c | `range(min, max);` | Constrain this property to a range of values that may be set when this Block is extended.  |\n\n# \xf0\x9f\x8e\xa8 What is a Block?\nA "Block" is an isolated stylesheet, written in its own file, that contains all rulesets for any elements, and their various modes and interaction states, for a discrete unit of styling \xe2\x80\x93 like a component or design pattern.\n\nTypically, a single Block will contain styles for a particular component or concept, but it is entirely natural \xe2\x80\x93 and encouraged \xe2\x80\x93 for a template to consume multiple blocks and compose them together in the markup.\n\nA Block file may contain:\n\n## The Scope Selector\nThe scope ruleset contains styles applied to the root of the scoped style subtree. All other elements assigned styles from a Block must be contained in the document subtree of an element assigned to the block\'s :scope. We use the special [`:scope` pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/:scope) to represent these styles.\n\nThe `:scope` selector may contain the special `block-name` property so you may provide your own Block name for easy debugging and BEM class generation. If no `block-name` is provided, we will infer the Block name from the file name.\n\n> \xf0\x9f\x92\xa1 **Feature Note: Block Names**\n>\n> If two Blocks in your project have the same name, CSS Blocks will automatically generate a unique, but still human-readable, name for BEM output mode.\n\n```css\n:scope {\n  block-name: custom-block-name;\n  /* \xf0\x9f\x91\x86 optional! */\n  /* ... more styles ... */\n}\n```\n\n## Class Selectors\nBlocks may can contain other classes that may be applied to elements inside the scoped style sub-tree. These are just class selectors, but they are local to that Block and isolated from all other similarly named classes in other Blocks.\n\n```css\n.sub-element { /* ... */ }\n.other-sub-element { /* ... */ }\n```\n\nTogether, the `:scope` selector and all declared `.class` selectors define the full interface of stylable elements available to a Block\'s consumer.\n\n## State Selectors\nStates represent a mode or interaction state that the `:scope` or a class \xe2\x80\x93 called the state\'s **originating element** \xe2\x80\x93 may be in. States are written as attribute selectors with the special `state` namespace.\n\n```css\n:scope { /* ... */ }\n:scope[enabled] { /* ... */ }\n\n.sub-element { /* ... */ }\n.sub-element[is-active] { /* ... */ }\n```\n\n> **\xe2\x81\x89\xef\xb8\x8f What the pipe is going on here?**\n>\n> Once upon a time, developers fell in love with XML and thus was born xhtml, a flavor of HTML that allowed HTML elements to be mixed together with elements from other XML syntaxes like SVG and MathML. CSS went along for the ride and so, while many have never seen or used the feature, CSS has support for namespaced elements and attributes. In CSS, the `|` symbol is used to delimit between a namespace identifier (assigned by the `@namespace` at-rule) and the element or attribute name (also called a [qualified name](https://drafts.csswg.org/css-namespaces-3/#css-qualified-name)).\n>\n> In markup, instead of a pipe symbol, the colon is used to delimit a namespace identifier and a qualified name. Yes, this is confusing -- but we don\'t make CSS syntax, we just use it.\n\n## Sub-State Selectors\nStates on the `:scope` selector or a class selector may contain sub-states for more granular styling. Sub-states of a State are **mutually exclusive** and an element may only be in one sub-state of that state at any given time.\n\n```css\n:scope { /* ... */ }\n:scope[theme="inverse"] { /* ... */ }\n\n.sub-element { /* ... */ }\n\n/* Applied for *any* value of `color`, including no value. */\n.sub-element[color] { /* ... */ }\n\n/* Applied for *specific* values of `color */\n.sub-element[color="red"] { /* ... */ }\n.sub-element[color="blue"] { /* ... */ }\n.sub-element[color="yellow"] { /* ... */ }\n```\n\n## Its Just CSS!\xe2\x84\xa2\xef\xb8\x8f (mostly)\n\nCSS Blocks implements a **strict subset of CSS**. This means we\'ve intentionally restricted some of the features you\'re allowed to use in a Block file to ensure we can optimize your stylesheets as much as possible!\n\n> As Opticss improves, we may choose to loosen some of these restrictions \xe2\x80\x93 keep an eye out for syntax updates as we approach the `v1.0.0` release!\n\n### \xf0\x9f\x8e\x89 That means you may freely use:\n\n - `::before`, `::after`, and [all other pseudo-elements](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements)\n - `:hover`, `:active`, and [all other pseudo-classes](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes),\n - `@media`, `@breakpoint`, and [all other `@at-rules`](https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule)\n - The **cascade** and **selector specificity**.\n - **Progressive enhancement** and **graceful degradation**.\n\n### \xf0\x9f\x9a\xa8 However:\n\n - `!important` is **forbidden** \xe2\x80\x93\xc2\xa0you won\'t be needing it!\n - The `tag`, non-state `[attribute]`, `#id` and `*` selectors are **forbidden** (for now!)\n - The [Logical Combinators](https://www.w3.org/TR/selectors-4/#logical-combination) `:matches()`, `:not()`, `:something()` and `:has()` are **forbidden** (for now!)\n - Selectors must remain **shallow**.\n\nIn css-blocks, **shallow selectors** mean:\n\n#### 1) Only one [combinator](https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Combinators_and_multiple_selectors) per selector.\n\n```css\n/* \xe2\x9c\x85 Allowed! */\n:scope:hover > .my-class { /* ... */ }\n\n/* \xe2\x9d\x8c Illegal! */\n:scope:hover > .my-class + .my-class { /* ... */ }\n```\n\n#### 2) The Hierarchical Combinators\' ([" "](https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_selectors) and "[>](https://developer.mozilla.org/en-US/docs/Web/CSS/Child_selectors)") context selector must be a `:scope` states, sub-states, or pseudo-classes.\n\n```css\n/* \xe2\x9c\x85 Allowed! */\n:scope:hover .my-class { /* ... */ }\n:scope[active] > .my-class { /* ... */ }\n:scope[color=red] .my-class { /* ... */ }\n\n/* \xe2\x9d\x8c Illegal! */\n.container:hover > .my-class { /* ... */ }\n.container[active] .my-class { /* ... */ }\n.container[color=red] .my-class { /* ... */ }\n```\n\n#### 3) The Sibling Combinators\' ("[+](https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_selectors)", "[~](https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_selectors)") context selector must target the **same class or `:scope`** used in the key selector.\n\n```css\n/* \xe2\x9c\x85 Allowed! */\n.my-class + .my-class { /* ... */ }\n.my-class:hover ~ .my-class { /* ... */ }\n.my-class[active] + .my-class { /* ... */ }\n\n/* \xe2\x9d\x8c Illegal! */\n:scope + .my-class { /* ... */ }\n.another-class:hover ~ .my-class { /* ... */ }\n.another-class[active] + .my-class { /* ... */ }\n```\n\n> \xf0\x9f\x92\xa1 **Feature Note: Global States and Selectors**\n>\n> "Global States" have their own rules on how they can be used in Block selectors! Keep an eye out for them a little later in this doc.\n\nOf course, because we statically analyze and compile all your code before it ever hits the browser, you will get a helpful error if any of these syntax restrictions are violated.\n\n## Blocks in Your Templates\nEvery specific template integration with css-blocks will have their own slightly unique syntax for how to interface with Block files. However, they all will allow you to apply classes and states in a way that is analyzable and rewritable at build time.\n\n> \xf0\x9f\x92\xa1 **Feature Note: Template Integrations**\n>\n> Each integration implements a slightly different API. Ex: JSX lets you `import` Block files, Ember looks for, through convention, a `stylesheet.css` alongside every component template. Check out the README for your template language for full details.\n\nHowever, whatever the implementation is, it will feel as though you\'re interfacing with regular CSS on the platform. For example, in Glimmer you just write the classes and states exactly as you would expect when working with a normal stylesheet:\n\n```css\n:scope { /* ... */ }\n:scope[enabled] { /* ... */ }\n.button { /* ... */ }\n.icon { /* ... */ }\n.icon[inverse] { /* ... */ }\n```\n\n```hbs\n{{!-- :scope selector is automagically applied to the template\'s root-level element. Thanks Glimmer! --}}\n<section block:enabled={{isEnabled}}>\n  <button block:class="button">\n    <div block:class="icon" block:inverse={{isInverse}}></div>\n    {{value}}\n  </button>\n</section>\n```\n\nThere are only two (2) common-sense rules to follow when using Block styles in your template:\n\n 1. You **may not** use a Block class outside of it\'s `:scope`\'s subtree.\n 2. Two classes *from the same Block* **may not** be applied to the same HTML element.\n\n# \xf0\x9f\x8f\x97 Block Composition\nBlocks styles are, by design, scoped to the file they are written in, but we all know that in a real app your styles can\'t live in a vacuum!\n\nAs you\'ll see below, there are many methods to compose blocks together in your application. However, most of these methods will begin with the humble `@block`.\n\n## Block References\nA Block may declare a dependency on another Block by using a `@block` at the top of your file. A `@block` creates a locally scoped alias where you can access the public API (declared classes and states) of the referenced block.\n\nBlock references don\'t cause any styles to be included. Instead, they are like an ES6 `import` statement -- they make it possible to refer to the public interface of another Block from within the current Block.\n\nAdding a `@block` is as simple as this:\n\n```css\n/* block-1.block.css */\n:scope { block-name: block-1; }\n.my-class { /* ... */ }\n.my-class[my-state] { /* ... */ }\n```\n\n```css\n/* block-2.block.css */\n@block other-block from "./block-1.block.css";\n\n:scope { block-name: block-2; }\n```\n\n> \xf0\x9f\x94\xae **Future Feature: Node Modules Block Resolution**\n>\n> Whether you\'re integrating with a 3rd party library, or pulling in dependencies internal to your company, at some point you\'ll want to integrate with styles delivered via NPM! The resolution logic for `@block`s to `node_modules` hasn\'t yet been implemented yet, but you can track progress (or even help out!) [over on Github](https://github.com/linkedin/css-blocks/issues/112).\n\nWith the above code, `block-2` now has a local reference `other-block` which points to `block-1`. We can now freely use the `other-block` identifier inside of `block-2` when we want to reference reference `block-1`. This comes in handy! Especially with features like:\n\n# Object Oriented Features of Blocks\n\n## Block Implementation\nA Block\'s public interface is defined by the states and classes it styles. A block may declare that it implements one or more other referenced blocks\' interfaces, and the compiler will ensure that all the states and classes it defines are also in the implementing block. In this way, the compiler can guarantee it is safe to use different blocks to style the same markup in a component.\n\nYou do this via the special `implements` property in a Block\'s `:scope` selector:\n\n```css\n/* block-1.block.css */\n:scope { block-name: block-1; }\n.my-class { /* ... */ }\n.my-class[my-state] { /* ... */ }\n```\n\n```css\n/* block-2.block.css */\n@block other-block from "./block-1.block.css";\n\n:scope {\n  block-name: block-2;\n  implements: other-block;\n}\n```\n\n> \xf0\x9f\x92\xa1 **Feature Note: Implements Property**\n>\n> The `implements` property is only available in the `:scope` selector. If you use it in any other selector, it will be ignored.\n\nHowever, the above code will throw an error at build time!\n\n```bash\n$ Error: Missing implementations for .my-class, .my-class[my-state] from ./block-1.block.css\n```\n\nFor the build to pass, we need to implement the *full public interface* of `block-1` in `block-2`:\n\n```css\n/* block-2.block.css */\n@block other-block from "./block-1.block.css";\n\n:scope {\n  block-name: block-2;\n  implements: other-block;\n}\n.my-class { /* ... */ }\n.my-class[my-state] { /* ... */ }\n```\n\n### Block Inheritance\n\nA Block may also choose to extend another referenced Block. This exposes all declared styles from the extended Block on the extending Block.\n\nThose inherited styles may then be used in a template by accessing them on the extending block, and can even be augmented by re-declaring the styles in the extending block!\n\nYou do this via the special `extends` property in a Block\'s `:scope` selector.\n\nLets say we have a component called `<basic-form>`. Basic forms have an input element, and a big green button. Simple enough:\n\n```css\n/* basic-form.block.css */\n.button {\n  font-size: 1.4rem;\n  color: white;\n  background-color: green;\n}\n.button[disabled] {\n  color: #333;\n  background-color: lightgray;\n}\n.input { font-weight: bold }\n```\n\nBut, as the project evolves we realize we need a new form for submitting information for a dangerous action, we\'re asked to create a new kind of form called `<danger-form>`. Danger forms look and function exactly the same as a basic form, except the button and labels are red. We *could* re-implement the entire stylesheet to create `<danger-form>`, but that would be a such a waste of all the hard work we already put in to `<basic-form>`!\n\nInstead, we can simply extend the `<basic-form>` Block, and only apply the small style changes we need:\n\n```css\n/* danger-form.block.css */\n@block basic-form from "./basic-form.block.css";\n\n:scope  { extends: basic-form; }\n.button { background-color: darkred; }\n.label  { color: darkred; }\n```\n\nDuring rewrite, references to an inherited style will translate into the class(es) for the\ndirectly referenced style as well as all the classes that it inherits from so developers do\nnot need to bring the complexity of the inheritance relationship into their templates.\nFor example, a reference to `danger-form.button` would result in adding both `.basic-form__button`,\nas well as `.danger-form__button` to the element\'s list of classes.\n\nWhen the blocks are compiled, property overrides are detected and automatically resolved.\nThe selectors generated serve two purposes:\n\n1. Concatenation order independence - Once compiled, a CSS block file can be\n   concatenated in any order with other compiled block output.\n2. Optimization hints - Normally, if there are selectors with the same\n   specificity that set same property to different values on the same element,\n   the optimizer would take care not to merge those declarations such that it\n   might cause a cascade resolution change. But the selectors in the output from\n   CSS Blocks allows OptiCSS to merge declarations more aggressively, because it\n   can prove that it knows the value of those selectors when combined.\n\n```css\n.basic-form__button { font-size: 1.4rem; color: white; background-color: green; }\n.basic-form__button--disabled { color: #333; background-color: lightgray; }\n.basic-form__input { font-weight: bold; }\n.danger-form__button { background-color: darkred; }\n.basic-form__button.danger-form__button { background-color: darkred; }\n.danger-form__button--disabled { background-color: #957d7d; }\n.basic-form__button.danger-form__button--disabled { background-color: #957d7d; }\n.basic-form__button--disabled.danger-form__button--disabled { background-color: #957d7d; }\n.danger-form__label { color: darkred; }\n```\n\nWhile this output is highly repetitive and may seem excessive, it\'s exactly the kind of repetition\nthat OptiCSS is designed to search for and remove. From an authoring experience and in production,\nit\'s a laser-focused override with no performance impact.\n\n> \xf0\x9f\x92\xa1 **Feature Note: Extends Property**\n>\n> The `extends` property is only available in the `:scope` selector. If you use it in any other selector, it will be ignored.\n\nAn extending block is able to re-define any property on any style it inherits from. CSS declarations defined in the extending Block will **always** take priority over the definitions inherited by the same named Style in the base Block.\n\n> \xf0\x9f\x94\xae **Future Feature: Extension Constraints**\n>\n> Sometimes, properties inside of a component are **so** important, that authors may want to constrain the values that extenders and implementors are able to set. In the near future, css-blocks will enable this use case through the custom `constrain()` and `range()` CSS functions and possibly through other ideas like [custom constraints and conflicts](https://github.com/linkedin/css-blocks/issues/51). You can come help out over on Github to make this happen faster!\n\n# Style Composition\n\n## Block Paths\nAs your Blocks begin interacting with each other in increasingly complex ways, you will find yourself needing to reference specific classes or states on another Block, as you\'ll see later in this document. You do this using a small query syntax called a [Block Path](./packages/css-blocks/src/BlockSyntax/BlockPath.ts).\n\nBlock Paths take the form:\n\n```\nblock.class[name=\'value\']\n```\n\nAll sections of this selector \xe2\x80\x93 except the leading Block name \xe2\x80\x93 are optional. The leading Block name *must* refer to an imported `@block` at the top of the file. If css-blocks is unable to resolve a Block Path at build time, you will get a friendly error message in your console!\n\nAll the following syntaxes are legal to select any given stylable on a referenced Block:\n\n|Stylable|Syntax|\n|:--|:--|\n|Scope|`block`|\n|Scope State|<code>block[name]</code>|\n|Scope Sub-State|<code>block[name=value]</code>|\n|Class|`block.class`|\n|Class State|<code>block.class[name]</code>|\n|Class Sub-State|<code>block.class[name=value]</code>|\n\n> \xf0\x9f\x94\xae **Future Feature: Block Path Wildcards**\n>\n> In some situations, you may want to select multiple classes, states or sub-states on a referenced block. In the near future you will be able to do so with a wildcard syntax: `block.*`, `block.class[*]`, `block.class[name=*]`. Feel free to track progress of this feature [here]()\n\n## Composition in Templates\nEvery template integration will provide a way to use more than one Block inside of a template. The syntax for this may change depending on your templating system, so please check with your specific template integration\'s documentation.\n\nFor Glimmer, using multiple blocks in a single template will look something like this:\n\n```css\n/* hoverable.css */\n:scope {\n  block-name: hoverable;\n  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.2);\n  transition: box-shadow .28s;\n}\n:scope:hover {\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2)\n}\n.button {\n  background-color: rgba(255, 255, 255, .5);\n  color: black;\n  transition: background-color .28s;\n}\n:scope:hover .button {\n  background-color: rgba(255, 255, 255, 1);\n}\n```\n\n```css\n/* stylesheet.css */\n@block other from "./hoverable.css";\n\n:scope { block-name: main; }\n.form {\n  border: 1px solid gray;\n  border-radius: 2px;\n  padding: 16px;\n}\n.button {\n  background-color: green;\n  color: white;\n  height: 32px;\n  width: 100%;\n}\n```\n\n```hbs\n{{!-- :scope selector from `stylesheet.css` is automagically applied to the template\'s wrapper element. Thanks Glimmer! --}}\n<section>\n  <form class="form other">\n    <button class="button other.button">Click Me!</button>\n  </form>\n</section>\n```\n\nAbove we have a simple template that contains a form with a single button that says "Click Me!". We style it with styles from the default Block for the template, `stylesheet.css`, and with styles from the referenced Block `hoverable.css`, referenced in this context as `other`.\n\nIn this template, we have the `<form>` element assigned the scoped root for `other`, and we apply the `button` class from both blocks to the `<button>` element.\n\nBut wait! If you try and run the css-blocks build with this code, you\'d find an error in your console!\n\n```bash\nThe following property conflicts must be resolved for these co-located Styles: (template.hbs:4:19)\n\n          color:\n            main.button (stylesheet.css:12:2)\n            hoverable.button (hoverable.css:12:2)\n\n          background-color:\n            main.button (stylesheet.css:11:2)\n            hoverable.button (hoverable.css:11:2)\n```\n\nWoah, what does this mean?! Well, if we stop and think for a second about what we just asked css-blocks to do, we\'ll realize that this error makes perfect sense.\n\nBecause Blocks have their own entirely independently scoped cascades, and right now no Block file is aware of any other Block\'s styles, css-blocks doesn\'t inherently know which Block should take priority over another when used together.\n\nSo, when css-blocks was asked to put the `.button` class from both the default template stylesheet, and from `hoverable` onto the same element, it noticed that both classes are claiming to set the `color` and `background-color` properties \xe2\x80\x93 and with this we have encountered our first **Indeterminate Cascade Resolution**.\n\nWhich Block should win in this situation? Right now, the compiler has no idea. To answer that, css-blocks needs a little help from you. We are able to provide explicit cross-Block cascade resolutions to the compiler by using `resolve()`. Lets learn how we can fix our above error by moving on to the next section: **Block Resolutions**.\n\n## Block Resolutions\nThe special `resolve()` function provides explicit resolution guidance for properties that are in conflict across two or more Block files. They look like any other property declaration:\n\n```css\nselector {\n  property-name: resolve("<block-path>");\n}\n```\n\nYou will be asked by the css-blocks compiler to add resolutions if and when two styles are found on the same element in your templates that attempt to set the same CSS property.\n\nResolve declarations work just like progressive enhancement and graceful degradation! The last declaration defined in the ruleset will win. This means that declaration order matters. There are two ways to resolve any given property:\n\n### Override Resolution\nOverride resolutions tell css-blocks that when these two styles  are used together, we want this Block to **override** the value of the other Style\'s property.\n\nHere, we tell css-blocks to use the `color` value from `my-class` instead of `other.selector` when both styles are applied to the same element:\n\n```css\n.my-class {\n  color: resolve("other.selector");\n  color: red;\n}\n```\n\n### Yield Resolution\nYield resolutions tell css-blocks that when these two styles  are used together, we want this Block to **yield** to the value of the other Style\'s property.\n\nHere, we tell css-blocks to use the `color` value from `other.selector` instead of `my-selector` when both styles are applied to the same element:\n\n```css\n.my-class {\n  color: red;\n  color: resolve("other.selector");\n}\n```\n\n> \xf0\x9f\x94\xae **Future Feature: Resolve All Shorthand**\n>\n> For straightforward resolutions where you just want to yield or assume full control of styling against another block, feel free to use the CSS `all` property to quickly override or yield to all property conflict with another block. The downside of doing this is that as new properties are added to another element, you don\'t get a chance to review them and decide:\n\n```css\n.my-class {\n  color: red;\n  background: blue;\n\n  /* Yields all conflicts to `other.selector` */\n  all: resolve("other.selector");\n}\n```\n\n> \xf0\x9f\x92\xa1 **Feature Note: Advanced Property Conflicts**\n>\n> The css-blocks compiler is smart! If you have dynamic classes or states in your template, it will ask you to provide explicit resolutions between Blocks that even only have a *chance* of being used together on the same element. This way, we can guarantee that your styles will work regardless of the state your application may find itself it.\n>\n> Css Blocks is also aware of CSS shorthands and will ask you to resolve the lowest common denominator on conflicting shorthand/longhand expressions as well.\n\nSo, continuing with the example from the previous section \xe2\x80\x93  **Composition in Templates** \xe2\x80\x93 we can satisfy the css-blocks compiler by adding in two explicit resolutions for `color` and `background-color` like so:\n\n```css\n/* stylesheet.css */\n/* ... */\n\n.button {\n  /* Override Resolution */\n  background-color: resolve("hoverable.button");\n  background-color: green;\n\n  /* Override Resolution */\n  color: resolve("hoverable.button");\n  color: white;\n\n  /* ... */\n}\n```\n\nHere we have told css-blocks that when our component\'s `.button` class is used with hoverable\'s `.button` class, we want our component\'s style declarations to win! We have declared an **override resolution** for both properties.\n\nIf we were to switch around the order a bit so our `background-color` resolution comes *after* our component\'s declaration, it means that when these two classes are used together, hoverable\'s `.button` class will win, but only for that property. This is why you will never have to fight the cascade or use `!important` ever again!\n\n```css\n/* stylesheet.css */\n/* ... */\n\n.button {\n  /* Yield Resolution */\n  background-color: green;\n  background-color: resolve("hoverable.button");\n\n  /* Override Resolution */\n  color: resolve("hoverable.button");\n  color: white;\n\n  /* ... */\n}\n```\n\n> \xf0\x9f\x92\xa1 **Feature Note: States and Pseudo-Classes**\n>\n> **States** and **Pseudo-Classes** inherit **all**  resolutions set on their containing **Class** or `:scope`.\n>\n> This means that in the above example, where we **yield** for `background-color`, and **override** for `color`, the button element where both classes are used will still use `hoverable.button:hover`\'s `background-color`, but it\'s color will remain `white`, like our component styles define!\n\n### Resolving Pseudo Elements\nIt is important to note that **Pseudo-Elements** do not inherit any resolutions from their container class and must be explicitly resolved in the source stylesheets when found to be in conflict.\n\nSo, for the following two Blocks where `my-class-1[enabled]` and `my-class-2` are used on the same element, one of the Blocks will need to resolve the conflicting `border-width` property:\n\n```css\n/* other */\n\n.my-class-1[enabled]::before {\n  border: 1px solid red;\n}\n```\n\n```css\n/* main.css */\n\n@block other from "./other.css";\n\n.my-class-2::before {\n  border-width: 2px;\n  border-width: resolve("other.my-class-2[enabled]");\n}\n```\n\n## External Selectors\nSometime a class, identifier, or tag name comes from an external source, and the only thing you can do is use them as is. In these situations the Block must declare all external simple selectors it intendeds to use. These simple selectors may then be used as key selectors inside this Block. You\'ll get an error for any declared external selectors that aren\'t used or if they are used in the context selector.\n\nStyles targeting an external selector are not rewritten and their declarations cannot be optimized! Style collisions\non an external selector are not detected or resolved. As a result, it is allowed to use `!important` on declarations targeting an external selector.\n\nWarning: If external selectors and CSS block objects both target the same HTML element in their key selectors you will get unpredictable results. It\'s best to avoid this.\n\n```css\n@external h2.some-rando-class;\n\n.foo h2.some-rando-class {\n  font-size: 32px !important;\n}\n```\n\n\n## Global States\n\nIn rare occasions, a Block may choose to declare declare that a certain State is **global**. These states are special in that they can be used in other Blocks like they are local to that block.\n\nThis is most useful for global application states \xe2\x80\x93 like during initial application boot, or when a modal is displayed.\n\n> \xe2\x9a\x99\xef\xb8\x8f **Performance Note: Global States**\n>\n> When you apply classes and other attributes to elements like `<html>` or `<body>` it invalidates a lot of internal caches in the browser. It is still often a performance win compared to querying the document in javascript and applying classes on many elements.\n\n```css\n/* application.block.css */\n\n@block-global [is-loading];\n@block-global [is-saving];\n```\n\n```css\n/* navigation.block.css */\n\n@block app from "application.block.css";\n\n/* Gray out signout button when app is saving */\n:scope[app|is-saving] .signout {\n  color: gray;\n  pointer-events: none;\n}\n\n/* Animate the logo when app is loading data */\n:scope[app|is-loading] .logo {\n  animation-name: bounce;\n}\n```\n\n[CORE]: ./packages/@css-blocks/css-blocks\n[RUNTIME]: ./packages/@css-blocks/runtime\n[JSX]: ./packages/@css-blocks/jsx\n[GLIMMER]: ./packages/@css-blocks/glimmer\n[EMBER_CLI]: ./packages/@css-blocks/ember-cli\n[WEBPACK]: ./packages/@css-blocks/webpack\n[BROCCOLI]: ./packages/@css-blocks/broccoli\n[WEBSITE]: ./packages/@css-blocks/website\n[PLAYGROUND]: ./packages/@css-blocks/playground\n'