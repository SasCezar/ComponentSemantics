b'[![Solana crate](https://img.shields.io/crates/v/solana-core.svg)](https://crates.io/crates/solana-core)\n[![Solana documentation](https://docs.rs/solana-core/badge.svg)](https://docs.rs/solana-core)\n[![Build status](https://badge.buildkite.com/8cc350de251d61483db98bdfc895b9ea0ac8ffa4a32ee850ed.svg?branch=master)](https://buildkite.com/solana-labs/solana/builds?branch=master)\n[![codecov](https://codecov.io/gh/solana-labs/solana/branch/master/graph/badge.svg)](https://codecov.io/gh/solana-labs/solana)\n\nBlockchain Rebuilt for Scale\n===\n\nSolana&trade; is a new blockchain architecture built from the ground up for scale. The architecture supports\nup to 710 thousand transactions per second on a gigabit network.\n\nDisclaimer\n===\n\nAll claims, content, designs, algorithms, estimates, roadmaps, specifications, and performance measurements described in this project are done with the author\'s best effort.  It is up to the reader to check and validate their accuracy and truthfulness.  Furthermore nothing in this project constitutes a solicitation for investment.\n\nIntroduction\n===\n\nIt\'s possible for a centralized database to process 710,000 transactions per second on a standard gigabit network if the transactions are, on average, no more than 176 bytes. A centralized database can also replicate itself and maintain high availability without significantly compromising that transaction rate using the distributed system technique known as Optimistic Concurrency Control [\\[H.T.Kung, J.T.Robinson (1981)\\]](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.65.4735). At Solana, we\'re demonstrating that these same theoretical limits apply just as well to blockchain on an adversarial network. The key ingredient? Finding a way to share time when nodes can\'t trust one-another. Once nodes can trust time, suddenly ~40 years of distributed systems research becomes applicable to blockchain!\n\n> Perhaps the most striking difference between algorithms obtained by our method and ones based upon timeout is that using timeout produces a traditional distributed algorithm in which the processes operate asynchronously, while our method produces a globally synchronous one in which every process does the same thing at (approximately) the same time. Our method seems to contradict the whole purpose of distributed processing, which is to permit different processes to operate independently and perform different functions. However, if a distributed system is really a single system, then the processes must be synchronized in some way. Conceptually, the easiest way to synchronize processes is to get them all to do the same thing at the same time. Therefore, our method is used to implement a kernel that performs the necessary synchronization--for example, making sure that two different processes do not try to modify a file at the same time. Processes might spend only a small fraction of their time executing the synchronizing kernel; the rest of the time, they can operate independently--e.g., accessing different files. This is an approach we have advocated even when fault-tolerance is not required. The method\'s basic simplicity makes it easier to understand the precise properties of a system, which is crucial if one is to know just how fault-tolerant the system is. [\\[L.Lamport (1984)\\]](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.71.1078)\n\nFurthermore, and much to our surprise, it can be implemented using a mechanism that has existed in Bitcoin since day one. The Bitcoin feature is called nLocktime and it can be used to postdate transactions using block height instead of a timestamp. As a Bitcoin client, you\'d use block height instead of a timestamp if you don\'t trust the network. Block height turns out to be an instance of what\'s being called a Verifiable Delay Function in cryptography circles. It\'s a cryptographically secure way to say time has passed. In Solana, we use a far more granular verifiable delay function, a SHA 256 hash chain, to checkpoint the ledger and coordinate consensus. With it, we implement Optimistic Concurrency Control and are now well en route towards that theoretical limit of 710,000 transactions per second.\n\nArchitecture\n===\n\nBefore you jump into the code, review the online book [Solana: Blockchain Rebuilt for Scale](https://docs.solana.com/book/).\n\n(The _latest_ development version of the online book is also [available here](https://docs.solana.com/book/v/master/).)\n\nRelease Binaries\n===\nOfficial release binaries are available at [Github Releases](https://github.com/solana-labs/solana/releases).\n\nAdditionally we provide pre-release binaries for the latest code on the edge and\nbeta channels.  Note that these pre-release binaries may be less stable than an\nofficial release.\n\n### Edge channel\n#### Linux (x86_64-unknown-linux-gnu)\n* [solana.tar.bz2](http://release.solana.com/edge/solana-release-x86_64-unknown-linux-gnu.tar.bz2)\n* [solana-install-init](http://release.solana.com/edge/solana-install-init-x86_64-unknown-linux-gnu) as a stand-alone executable\n#### mac OS (x86_64-apple-darwin)\n* [solana.tar.bz2](http://release.solana.com/edge/solana-release-x86_64-apple-darwin.tar.bz2)\n* [solana-install-init](http://release.solana.com/edge/solana-install-init-x86_64-apple-darwin) as a stand-alone executable\n#### Windows (x86_64-pc-windows-msvc)\n* [solana.tar.bz2](http://release.solana.com/edge/solana-release-x86_64-pc-windows-msvc.tar.bz2)\n* [solana-install-init.exe](http://release.solana.com/edge/solana-install-init-x86_64-pc-windows-msvc.exe) as a stand-alone executable\n#### All platforms\n* [solana-metrics.tar.bz2](http://release.solana.com.s3.amazonaws.com/edge/solana-metrics.tar.bz2)\n\n### Beta channel\n#### Linux (x86_64-unknown-linux-gnu)\n* [solana.tar.bz2](http://release.solana.com/beta/solana-release-x86_64-unknown-linux-gnu.tar.bz2)\n* [solana-install-init](http://release.solana.com/beta/solana-install-init-x86_64-unknown-linux-gnu) as a stand-alone executable\n#### mac OS (x86_64-apple-darwin)\n* [solana.tar.bz2](http://release.solana.com/beta/solana-release-x86_64-apple-darwin.tar.bz2)\n* [solana-install-init](http://release.solana.com/beta/solana-install-init-x86_64-apple-darwin) as a stand-alone executable\n#### Windows (x86_64-pc-windows-msvc)\n* [solana.tar.bz2](http://release.solana.com/beta/solana-release-x86_64-pc-windows-msvc.tar.bz2)\n* [solana-install-init.exe](http://release.solana.com/beta/solana-install-init-x86_64-pc-windows-msvc.exe) as a stand-alone executable\n#### All platforms\n* [solana-metrics.tar.bz2](http://release.solana.com.s3.amazonaws.com/beta/solana-metrics.tar.bz2)\n\nDeveloping\n===\n\nBuilding\n---\n\nInstall rustc, cargo and rustfmt:\n\n```bash\n$ curl https://sh.rustup.rs -sSf | sh\n$ source $HOME/.cargo/env\n$ rustup component add rustfmt\n```\n\nIf your rustc version is lower than 1.39.0, please update it:\n\n```bash\n$ rustup update\n```\n\nOn Linux systems you may need to install libssl-dev, pkg-config, zlib1g-dev, etc.  On Ubuntu:\n\n```bash\n$ sudo apt-get install libssl-dev pkg-config zlib1g-dev llvm clang\n```\n\nDownload the source code:\n\n```bash\n$ git clone https://github.com/solana-labs/solana.git\n$ cd solana\n```\n\nBuild\n\n```bash\n$ cargo build\n```\n\nThen to run a minimal local cluster\n```bash\n$ ./run.sh\n```\n\nTesting\n---\n\nRun the test suite:\n\n```bash\n$ cargo test\n```\n\nLocal Testnet\n---\n\nStart your own testnet locally, instructions are in the book [Solana: Blockchain Rebuild for Scale: Getting Started](https://docs.solana.com/book/getting-started).\n\nRemote Testnets\n---\n\nWe maintain several testnets:\n\n* `testnet` - public stable testnet accessible via testnet.solana.com. Runs 24/7\n* `testnet-beta` - public beta channel testnet accessible via beta.testnet.solana.com. Runs 24/7\n* `testnet-edge` - public edge channel testnet accessible via edge.testnet.solana.com. Runs 24/7\n\n## Deploy process\n\nThey are deployed with the `ci/testnet-manager.sh` script through a list of [scheduled\nbuildkite jobs](https://buildkite.com/solana-labs/testnet-management/settings/schedules).\nEach testnet can be manually manipulated from buildkite as well.\n\n## How do I reset the testnet?\nManually trigger the [testnet-management](https://buildkite.com/solana-labs/testnet-management) pipeline\nand when prompted select the desired testnet\n\n## How can I scale the tx generation rate?\n\nIncrease the TX rate by increasing the number of cores on the client machine which is running\n`bench-tps` or run multiple clients. Decrease by lowering cores or using the rayon env\nvariable `RAYON_NUM_THREADS=<xx>`\n\n## How can I test a change on the testnet?\n\nCurrently, a merged PR is the only way to test a change on the testnet.  But you\ncan run your own testnet using the scripts in the `net/` directory.\n\n## Adjusting the number of clients or validators on the testnet\nEdit `ci/testnet-manager.sh`\n\n\n## Metrics Server Maintenance\nSometimes the dashboard becomes unresponsive. This happens due to glitch in the metrics server.\nThe current solution is to reset the metrics server. Use the following steps.\n\n1. The server is hosted in a GCP VM instance. Check if the VM instance is down by trying to SSH\n into it from the GCP console. The name of the VM is ```metrics-solana-com```.\n2. If the VM is inaccessible, reset it from the GCP console.\n3. Once VM is up (or, was already up), the metrics services can be restarted from build automation.\n    1. Navigate to https://buildkite.com/solana-labs/metrics-dot-solana-dot-com in your web browser\n    2. Click on ```New Build```\n    3. This will show a pop up dialog. Click on ```options``` drop down.\n    4. Type in ```FORCE_START=true``` in ```Environment Variables``` text box.\n    5. Click ```Create Build```\n    6. This will restart the metrics services, and the dashboards should be accessible afterwards.\n\n## Debugging Testnet\nTestnet may exhibit different symptoms of failures. Primary statistics to check are\n1. Rise in Confirmation Time\n2. Nodes are not voting\n3. Panics, and OOM notifications\n\nCheck the following if there are any signs of failure.\n1. Did testnet deployment fail?\n    1. View buildkite logs for the last deployment: https://buildkite.com/solana-labs/testnet-management\n    2. Use the relevant branch\n    3. If the deployment failed, look at the build logs. The build artifacts for each remote node is uploaded.\n       It\'s a good first step to triage from these logs.\n2. You may have to log into remote node if the deployment succeeded, but something failed during runtime.\n    1. Get the private key for the testnet deployment from ```metrics-solana-com``` GCP instance.\n    2. SSH into ```metrics-solana-com``` using GCP console and do the following.\n    ```bash\n    sudo bash\n    cd ~buildkite-agent/.ssh\n    ls\n    ```\n    3. Copy the relevant private key to your local machine\n    4. Find the public IP address of the AWS instance for the remote node using AWS console\n    5. ```ssh -i <private key file> ubuntu@<ip address of remote node>```\n    6. The logs are in ```~solana\\solana``` folder\n\n\nBenchmarking\n---\n\nFirst install the nightly build of rustc. `cargo bench` requires use of the\nunstable features only available in the nightly build.\n\n```bash\n$ rustup install nightly\n```\n\nRun the benchmarks:\n\n```bash\n$ cargo +nightly bench\n```\n\nRelease Process\n---\nThe release process for this project is described [here](RELEASE.md).\n\n\nCode coverage\n---\n\nTo generate code coverage statistics:\n\n```bash\n$ scripts/coverage.sh\n$ open target/cov/lcov-local/index.html\n```\n\n\nWhy coverage? While most see coverage as a code quality metric, we see it primarily as a developer\nproductivity metric. When a developer makes a change to the codebase, presumably it\'s a *solution* to\nsome problem.  Our unit-test suite is how we encode the set of *problems* the codebase solves. Running\nthe test suite should indicate that your change didn\'t *infringe* on anyone else\'s solutions. Adding a\ntest *protects* your solution from future changes. Say you don\'t understand why a line of code exists,\ntry deleting it and running the unit-tests. The nearest test failure should tell you what problem\nwas solved by that code. If no test fails, go ahead and submit a Pull Request that asks, "what\nproblem is solved by this code?" On the other hand, if a test does fail and you can think of a\nbetter way to solve the same problem, a Pull Request with your solution would most certainly be\nwelcome! Likewise, if rewriting a test can better communicate what code it\'s protecting, please\nsend us that patch!\n'