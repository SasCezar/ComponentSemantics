b'[![Build Status](https://travis-ci.org/richardkiss/pycoin.png?branch=master)](https://travis-ci.org/richardkiss/pycoin)\n[![codecov.io](https://codecov.io/github/richardkiss/pycoin/coverage.svg?branch=master)](https://codecov.io/github/richardkiss/pycoin)\n\n\npycoin -- Python Cryptocoin Utilities\n=====================================\n\nThe pycoin library implements many utilities useful when dealing with bitcoin and some bitcoin-like\nalt-coins. It has been tested with Python 2.7, 3.6 and 3.7.\n\nSee also [pycoinnet](http://github.com/richardkiss/pycoinnet/) for a library that speaks the bitcoin protocol.\n\nDocumentation at [readthedocs](http://pycoin.readthedocs.io/en/latest/)\n\nDiscussion at [zulipchat](https://pycoin.zulipchat.com/)\n\n\nNetworks\n--------\n\nAs of 0.9, pycoin supports many coins to various degrees via the "network" class. Since specifications\nvary based on the network (for example, bitcoin mainnet addresses start with a "1", but testnet\naddresses start with an "m" or "n"), all API descends from a network object. Everything related to a\nparticular network is scoped under this class.\n\nBitcoin has the highest level of support, including keys, transactions, validation of signed transactions, and\nsigning unsigned transactions, including partial signing of multisig transactions. These are in level of\nincreasing complexity, so features for other coins will likely be supported in that order.\n\nThere are two main ways to get a network:\n\n```\nfrom pycoin.symbols.btc import network\n```\n\nOR\n\n```\nfrom pycoin.networks.registry import network_for_netcode\nnetwork = network_for_netcode("BTC")\n```\n\n\nKeys\n----\n\nYou can create a private key and get the corresponding address.\n\n```\nfrom pycoin.symbols.btc import network\n\nkey = network.keys.private(secret_exponent=1)  # this is a terrible key because it\'s very guessable\nprint(key.wif())\nprint(key.sec())\nprint(key.address())\nprint(key.address(is_compressed=False))\n\nsame_key = network.parse.private(key.wif())\nprint(same_key.address())\n```\n\n\nBIP32\n-----\n\nYou can create a BIP32 key.\n\n```\nkey = network.keys.bip32_seed(b"foo")  # this is a terrible key because it\'s very guessable\nprint(key.hwif(as_private=1))\nprint(key.hwif())\nprint(key.wif())\nprint(key.sec())\nprint(key.address())\n```\n\nYou can parse a BIP32 key.\n\n```\nkey = network.parse.bip32("xprv9s21ZrQH143K31AgNK5pyVvW23gHnkBq2wh5aEk6g1s496M"\n      "8ZMjxncCKZKgb5jZoY5eSJMJ2Vbyvi2hbmQnCuHBujZ2WXGTux1X2k9Krdtq")\nprint(key.hwif(as_private=1))\nprint(key.hwif())\nprint(key.wif())\nprint(key.sec())\nprint(key.address())\n```\n\nWARNING: be extremely careful giving out public wallet keys. If someone has access to a private wallet key P, of\ncourse they have access to all descendent wallet keys of P. But if they also have access to a public wallet key K\nwhere P is a subkey of K, you can actually work your way up the tree to determine the private key that corresponds\nto the public wallet key K (unless private derivation was used at some point between the two keys)! Be sure you\nunderstand this warning before giving out public wallet keys!\n\nMuch of this API is exposed in the `ku` command-line utility. See also [COMMAND-LINE-TOOLS.md](./COMMAND-LINE-TOOLS.md).\n\nSee [BIP32.txt](./BIP32.txt) for more information.\n\n\nTransactions\n------------\n\nThe command-line utility `tx` is a Swiss Army knife of transaction utilities. See also [COMMAND-LINE-TOOLS.md](./COMMAND-LINE-TOOLS.md).\n\n\nServices\n--------\n\nWhen signing or verifying signatures on a transaction, the source transactions are generally needed. If you set two\nenvironment variables in your `.profile` like this:\n\n    PYCOIN_CACHE_DIR=~/.pycoin_cache\n    PYCOIN_BTC_PROVIDERS="blockchain.info blockexplorer.com chain.so"\n    export PYCOIN_CACHE_DIR PYCOIN_BTC_PROVIDERS\n    export PYCOIN_XTN_PROVIDERS="blockchain.info"  # For Bitcoin testnet\n\nand then `tx` will automatically fetch transactions from the web sites listed and cache the results in\n`PYCOIN_CACHE_DIR` when they are needed.\n\n(The old syntax with `PYCOIN_SERVICE_PROVIDERS` is deprecated.)\n\nThe module pycoin.services includes two functions `spendables_for_address`, `get_tx_db` that look at the\nenvironment variables set to determine which web sites to use to fetch the underlying information. The sites are\npolled in the order they are listed in the environment variable.\n\n\nBlocks\n------\n\nThe command-line utility `block` will dump a block in a human-readable format. For further information, look at\n`pycoin.block`, which includes the object `Block` which will parse and stream the binary format of a block.\n\n\nECDSA Signing and Verification\n------------------------------\n\nThe module `pycoin.ecdsa` deals with ECDSA keys directly. Important structures include:\n\n- the `secret_exponent` (a large integer that represents a private key)\n- the `public_pair` (a pair of large integers x and y that represent a public key)\n\nThere are a handful of functions: you can do things like create a signature, verify a signature, generate the public\npair from the secret exponent, and flush out the public pair from just the x value (there are two possible values\nfor y of opposite even/odd parity, so you include a flag indicating which value for y you want).\n\nThe `pycoin.ecdsa.native` module looks for both OpenSSL and libsecp256k1 (with hints from\n`PYCOIN_LIBCRYPTO_PATH` and `PYCOIN_LIBSECP256K1_PATH`) and calls out to these libraries if\nthey are present to accelerate ecdsa operations. Set `PYCOIN_NATIVE` to `openssl`,\n`secp256k1` or `none` to tweak this.\n\nExample:\n\n```\n$ PYCOIN_NATIVE=openssl\n$ export PYCOIN_NATIVE\n```\n\n\nDonate\n------\n\nWant to donate? Feel free. Send to 1KissZi1jr5eD7Rb9fepRHiS4ur2hc9PwS.\nI\'m also available for bitcoin consulting... him@richardkiss.com.\n\n\n[BIP0032](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n'