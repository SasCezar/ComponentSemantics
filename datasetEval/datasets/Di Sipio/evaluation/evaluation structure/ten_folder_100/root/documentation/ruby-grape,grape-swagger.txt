b'[![Gem Version](https://badge.fury.io/rb/grape-swagger.svg)](http://badge.fury.io/rb/grape-swagger)\n[![Build Status](https://travis-ci.org/ruby-grape/grape-swagger.svg?branch=master)](https://travis-ci.org/ruby-grape/grape-swagger)\n[![Coverage Status](https://coveralls.io/repos/github/ruby-grape/grape-swagger/badge.svg?branch=master)](https://coveralls.io/github/ruby-grape/grape-swagger?branch=master)\n[![Code Climate](https://codeclimate.com/github/ruby-grape/grape-swagger.svg)](https://codeclimate.com/github/ruby-grape/grape-swagger)\n\n##### Table of Contents\n\n* [What is grape-swagger?](#what)\n* [Related Projects](#related)\n* [Compatibility](#version)\n* [Swagger-Spec](#swagger-spec)\n* [Installation](#install)\n* [Usage](#usage)\n* [Model Parsers](#model_parsers)\n* [Configure](#configure)\n* [Routes Configuration](#routes)\n* [Using Grape Entities](#grape-entity)\n* [Securing the Swagger UI](#oauth)\n* [Example](#example)\n* [Rake Tasks](#rake)\n\n\n## What is grape-swagger? <a name="what"></a>\n\nThe grape-swagger gem provides an autogenerated documentation for your [Grape](https://github.com/ruby-grape/grape) API. The generated documentation is Swagger-compliant, meaning it can easily be discovered in [Swagger UI](https://github.com/wordnik/swagger-ui). You should be able to point [the petstore demo](http://petstore.swagger.io/) to your API.\n\n![Demo Screenshot](example/swagger-example.png)\n\nThis screenshot is based on the [Hussars](https://github.com/LeFnord/hussars) sample app.\n\n\n## Related Projects <a name="related"></a>\n\n* [Grape](https://github.com/ruby-grape/grape)\n* [Grape Swagger Entity](https://github.com/ruby-grape/grape-swagger-entity)\n  * [Grape Entity](https://github.com/ruby-grape/grape-entity)\n* [Grape Swagger Representable](https://github.com/ruby-grape/grape-swagger-representable)\n* [Swagger UI](https://github.com/wordnik/swagger-ui)\n\n\n\n## Compatibility <a name="version"></a>\n\nThe following versions of grape, grape-entity and grape-swagger can currently be used together.\n\ngrape-swagger | swagger spec | grape                   | grape-entity | representable |\n--------------|--------------|-------------------------|--------------|---------------|\n0.10.5        |     1.2      | >= 0.10.0 ... <= 0.14.0 |  < 0.5.0     | n/a           |\n0.11.0        |     1.2      |               >= 0.16.2 |  < 0.5.0     | n/a           |\n0.25.2        |     2.0      | >= 0.14.0 ... <= 0.18.0 | <= 0.6.0     | >= 2.4.1      |\n0.26.0        |     2.0      | >= 0.16.2     <= 1.1.0  | <= 0.6.1     | >= 2.4.1      |\n0.27.0        |     2.0      | >= 0.16.2 ... <= 1.1.0  | >= 0.5.0     | >= 2.4.1      |\n0.32.0        |     2.0      | >= 0.16.2               | >= 0.5.0     | >= 2.4.1      |\n\n\n## Swagger-Spec <a name="swagger-spec"></a>\n\nGrape-swagger generates documentation per [Swagger / OpenAPI Spec 2.0](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md).\n\n<!-- validating it with: http://bigstickcarpet.com/swagger-parser/www/index.html -->\n\n\n## Installation <a name="install"></a>\n\nAdd to your Gemfile:\n\n```ruby\ngem \'grape-swagger\'\n```\n\n## Upgrade\n\nPlease see [UPGRADING](UPGRADING.md) when upgrading from a previous version.\n\n\n\n## Usage <a name="usage"></a>\n\nMount all your different APIs (with `Grape::API` superclass) on a root node. In the root class definition, include `add_swagger_documentation`, this sets up the system and registers the documentation on \'/swagger_doc\'. See [example/config.ru](example/config.ru) for a simple demo.\n\n\n```ruby\nrequire \'grape-swagger\'\n\nmodule API\n  class Root < Grape::API\n    format :json\n    mount API::Cats\n    mount API::Dogs\n    mount API::Pirates\n    add_swagger_documentation\n  end\nend\n```\n\nTo explore your API, either download [Swagger UI](https://github.com/wordnik/swagger-ui) and set it up yourself or go to the [online swagger demo](http://petstore.swagger.wordnik.com/) and enter your localhost url documentation root in the url field (probably something in the line of http://localhost:3000/swagger_doc).\n\n\n\n## Model Parsers <a name="model_parsers"></a>\n\nSince 0.21.0, `Grape::Entity` is not a part of grape-swagger, you need to add `grape-swagger-entity` manually to your Gemfile.\nAlso added support for [representable](https://github.com/apotonick/representable) via `grape-swagger-representable`.\n\n```ruby\n# For Grape::Entity ( https://github.com/ruby-grape/grape-entity )\ngem \'grape-swagger-entity\'\n# For representable ( https://github.com/apotonick/representable )\ngem \'grape-swagger-representable\'\n```\n\nIf you are not using Rails, make sure to load the parser inside your application initialization logic, e.g., via `require \'grape-swagger/entity\'` or `require \'grape-swagger/representable\'`.\n\n### Custom Model Parsers\n\nYou can create your own model parser, for example for [roar](https://github.com/apotonick/roar).\n\n```ruby\nmodule GrapeSwagger\n  module Roar\n    class Parser\n      attr_reader :model\n      attr_reader :endpoint\n\n      def initialize(model, endpoint)\n        @model = model\n        @endpoint = endpoint\n      end\n\n      def call\n        # Parse your model and return hash with model schema for swagger\n      end\n    end\n  end\nend\n```\n\nThen you should register your custom parser.\n\n```ruby\nGrapeSwagger.model_parsers.register(GrapeSwagger::Roar::Parser, Roar::Decorator)\n```\n\nTo control model parsers sequence, you can insert your parser before or after another parser.\n\n#### insert_before\n\n```ruby\nGrapeSwagger.model_parsers.insert_before(GrapeSwagger::Representable::Parser, GrapeSwagger::Roar::Parser, Roar::Decorator)\n```\n\n#### insert_after\n\n```ruby\nGrapeSwagger.model_parsers.insert_after(GrapeSwagger::Roar::Parser, GrapeSwagger::Representable::Parser, Representable::Decorator)\n```\n\nAs we know, `Roar::Decorator` uses `Representable::Decorator` as a superclass, this allows to avoid a problem when Roar objects are processed by `GrapeSwagger::Representable::Parser` instead of `GrapeSwagger::Roar::Parser`.\n\n\n### CORS\n\nIf you use the online demo, make sure your API supports foreign requests by enabling CORS in Grape, otherwise you\'ll see the API description, but requests on the API won\'t return. Use [rack-cors](https://github.com/cyu/rack-cors) to enable CORS.\n\n```ruby\nrequire \'rack/cors\'\nuse Rack::Cors do\n  allow do\n    origins \'*\'\n    resource \'*\', headers: :any, methods: [ :get, :post, :put, :delete, :options ]\n  end\nend\n```\n\nAlternatively you can set CORS headers in a Grape `before` block.\n\n```ruby\nbefore do\n  header[\'Access-Control-Allow-Origin\'] = \'*\'\n  header[\'Access-Control-Request-Method\'] = \'*\'\nend\n```\n\n\n\n## Configure <a name="configure"></a>\n\n* [host](#host)\n* [base_path](#base_path)\n* [mount_path](#mount_path)\n* [add_base_path](#add_base_path)\n* [add_root](#add_root)\n* [add_version](#add_version)\n* [doc_version](#doc_version)\n* [endpoint_auth_wrapper](#endpoint_auth_wrapper)\n* [swagger_endpoint_guard](#swagger_endpoint_guard)\n* [token_owner](#token_owner)\n* [security_definitions](#security_definitions)\n* [security](#security)\n* [models](#models)\n* [tags](#tags)\n* [hide_documentation_path](#hide_documentation_path)\n* [info](#info)\n* [array_use_braces](#array_use_braces)\n* [api_documentation](#api_documentation)\n* [specific_api_documentation](#specific_api_documentation)\n\nYou can pass a hash with optional configuration settings to ```add_swagger_documentation```.\nThe examples show the default value.\n\n\nThe `host` and `base_path` options also accept a `proc` or a `lambda` to evaluate, which is passed a [request](http://www.rubydoc.info/github/rack/rack/Rack/Request) object:\n\n```ruby\nadd_swagger_documentation \\\n  base_path: proc { |request| request.host =~ /^example/ ? \'/api-example\' : \'/api\' }\n```\n\n\n#### host: <a name="host"></a>\nSets explicit the `host`, default would be taken from `request`.\n```ruby\nadd_swagger_documentation \\\n   host: \'www.example.com\'\n```\n\n\n#### base_path: <a name="base_path"></a>\nBase path of the API that\'s being exposed, default would be taken from `request`.\n```ruby\nadd_swagger_documentation \\\n   base_path: nil\n```\n\n`host` and `base_path` are also accepting a `proc` or `lambda`\n\n\n#### mount_path: <a name="mount_path"></a>\nThe path where the API documentation is loaded, default is: `/swagger_doc`.\n```ruby\nadd_swagger_documentation \\\n   mount_path: \'/swagger_doc\'\n```\n\n#### add_base_path: <a name="add_base_path"></a>\nAdd `basePath` key to the documented path keys, default is: `false`.\n```ruby\nadd_swagger_documentation \\\n   add_base_path: true # only if base_path given\n```\n\n#### add_root: <a name="add_root"></a>\nAdd root element to all the responses, default is: `false`.\n```ruby\nadd_swagger_documentation \\\n   add_root: true\n```\n\n#### add_version: <a name="add_version"></a>\n\nAdd `version` key to the documented path keys, default is: `true`,\nhere the version is the API version, specified by `grape` in [`path`](https://github.com/ruby-grape/grape/#path)\n\n```ruby\nadd_swagger_documentation \\\n   add_version: true\n```\n\n\n#### doc_version: <a name="doc_version"></a>\n\nSpecify the version of the documentation at [info section](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#info-object), default is: `\'0.0.1\'`\n```ruby\nadd_swagger_documentation \\\n   doc_version: \'0.0.1\'\n```\n\n\n#### endpoint_auth_wrapper: <a name="endpoint_auth_wrapper"></a>\n\nSpecify the middleware to use for securing endpoints.\n\n```ruby\nadd_swagger_documentation \\\n   endpoint_auth_wrapper: WineBouncer::OAuth2\n```\n\n\n#### swagger_endpoint_guard: <a name="swagger_endpoint_guard"></a>\nSpecify the method and auth scopes, used by the middleware for securing endpoints.\n\n```ruby\nadd_swagger_documentation \\\n   swagger_endpoint_guard: \'oauth2 false\'\n```\n\n\n#### token_owner: <a name="token_owner"></a>\nSpecify the token_owner method, provided by the middleware, which is typically named \'resource_owner\'.\n\n```ruby\nadd_swagger_documentation \\\n   token_owner: \'resource_owner\'\n```\n\n\n#### security_definitions: <a name="security_definitions"></a>\nSpecify the [Security Definitions Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#security-definitions-object)\n\n_NOTE: [Swagger-UI is supporting only implicit flow yet](https://github.com/swagger-api/swagger-ui/issues/2406#issuecomment-248651879)_\n\n```ruby\nadd_swagger_documentation \\\n  security_definitions: {\n    api_key: {\n      type: "apiKey",\n      name: "api_key",\n      in: "header"\n    }\n  }\n```\n\n#### security: <a name="security"></a>\n\nSpecify the [Security Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject)\n\n```ruby\nadd_swagger_documentation \\\n  security: [\n    {\n      api_key: []\n    }\n  ]\n```\n\n\n#### models: <a name="models"></a>\nA list of entities to document. Combine with the [grape-entity](https://github.com/ruby-grape/grape-entity) gem.\n\nThese would be added to the definitions section of the swagger file.\n\n```ruby\nadd_swagger_documentation \\\n   models: [\n     TheApi::Entities::UseResponse,\n     TheApi::Entities::ApiError\n   ]\n```\n\n\n#### tags: <a name="tags"></a>\n\nA list of tags to document.  By default tags are automatically generated\nfor endpoints based on route names.\n\n```ruby\nadd_swagger_documentation \\\n  tags: [\n    { name: \'widgets\', description: \'A description of widgets\' }\n  ]\n```\n\n\n#### hide_documentation_path: (default: `true`) <a name="hide_documentation_path"></a>\n\n```ruby\nadd_swagger_documentation \\\n   hide_documentation_path: true\n```\n\nDon\'t show the `/swagger_doc` path in the generated swagger documentation.\n\n\n#### info: <a name="info"></a>\n\n```ruby\nadd_swagger_documentation \\\n  info: {\n    title: "The API title to be displayed on the API homepage.",\n    description: "A description of the API.",\n    contact_name: "Contact name",\n    contact_email: "Contact@email.com",\n    contact_url: "Contact URL",\n    license: "The name of the license.",\n    license_url: "www.The-URL-of-the-license.org",\n    terms_of_service_url: "www.The-URL-of-the-terms-and-service.com",\n  }\n```\n\nA hash merged into the `info` key of the JSON documentation.\n\n#### array_use_braces: <a name="array_use_braces"></a>\n\n```ruby\nadd_swagger_documentation \\\n  array_use_braces: true\n```\n This setting must be `true` in order for params defined as an `Array` type to submit each element properly.\n ```ruby\nparams do\n  optional :metadata, type: Array[String]\nend\n```\n with `array_use_braces: true`:\n```\nmetadata[]: { "name": "Asset ID", "value": "12345" }\nmetadata[]: { "name": "Asset Tag", "value": "654321"}\n```\n with `array_use_braces: false`:\n```\nmetadata: {"name": "Asset ID", "value": "123456"}\nmetadata: {"name": "Asset Tag", "value": "654321"}\n```\n\n#### api_documentation\n\nCustomize the Swagger API documentation route, typically contains a `desc` field. The default description is "Swagger compatible API description".\n\n```ruby\nadd_swagger_documentation \\\n   api_documentation: { desc: \'Reticulated splines API swagger-compatible documentation.\' }\n```\n\n#### specific_api_documentation\n\nCustomize the Swagger API specific documentation route, typically contains a `desc` field. The default description is "Swagger compatible API description for specific API".\n\n```ruby\nadd_swagger_documentation \\\n   specific_api_documentation: { desc: \'Reticulated splines API swagger-compatible endpoint documentation.\' }\n```\n\n## Routes Configuration <a name="routes"></a>\n\n* [Swagger Header Parameters](#headers)\n* [Hiding an Endpoint](#hiding)\n* [Overriding Auto-Generated Nicknames](#overriding-auto-generated-nicknames)\n* [Specify endpoint details](#details)\n* [Overriding the route summary](#summary)\n* [Overriding the tags](#overriding_the_tags)\n* [Deprecating routes](#deprecating-routes)\n* [Overriding the name of the body parameter](#body-param)\n* [Defining an endpoint as an array](#array)\n* [Using an options hash](#options)\n* [Overriding parameter type](#overriding-param-type)\n* [Overriding data type of the parameter](#overriding-type-of-param)\n* [Multiple types](#multiple-types)\n* [Array of data type](#array-type)\n* [Collection Format](#collection-format)\n* [Hiding parameters](#hiding-parameters)\n* [Setting a Swagger default value](#default-value)\n* [Response documentation](#response)\n* [Changing default status codes](#change-status)\n* [File response](#file-response)\n* [Extensions](#extensions)\n* [Response examples documentation](#response-examples)\n* [Response headers documentation](#response-headers)\n* [Adding root element to responses](#response-root)\n\n#### Swagger Header Parameters  <a name="headers"></a>\n\nSwagger also supports the documentation of parameters passed in the header. Since grape\'s ```params[]``` doesn\'t return header parameters we can specify header parameters seperately in a block after the description.\n\n```ruby\ndesc "Return super-secret information", {\n  headers: {\n    "XAuthToken" => {\n      description: "Valdates your identity",\n      required: true\n    },\n    "XOptionalHeader" => {\n      description: "Not really needed",\n      required: false\n    }\n  }\n}\n```\n\n\n#### Hiding an Endpoint <a name="hiding"></a>\n\nYou can hide an endpoint by adding ```hidden: true``` in the description of the endpoint:\n\n```ruby\ndesc \'Hide this endpoint\', hidden: true\n```\n\nOr by adding ```hidden: true``` on the verb method of the endpoint, such as `get`, `post` and `put`:\n\n```ruby\nget \'/kittens\', hidden: true do\n```\n\nOr by using a route setting:\n\n```ruby\nroute_setting :swagger, { hidden: true }\nget \'/kittens\' do\n```\n\nEndpoints can be conditionally hidden by providing a callable object such as a lambda which evaluates to the desired\nstate:\n\n```ruby\ndesc \'Conditionally hide this endpoint\', hidden: lambda { ENV[\'EXPERIMENTAL\'] != \'true\' }\n```\n\n\n#### Overriding Auto-Generated Nicknames <a name="overriding-auto-generated-nicknames"></a>\n\nYou can specify a swagger nickname to use instead of the auto generated name by adding `:nickname \'string\'` in the description of the endpoint.\n\n```ruby\ndesc \'Get a full list of pets\', nickname: \'getAllPets\'\n```\n\n\n#### Specify endpoint details <a name="details"></a>\n\nTo specify further details for an endpoint, use the `detail` option within a block passed to `desc`:\n\n```ruby\ndesc \'Get all kittens!\' do\n  detail \'this will expose all the kittens\'\nend\nget \'/kittens\' do\n```\n\n\n#### Overriding the route summary <a name="summary"></a>\n\nTo override the summary, add `summary: \'[string]\'` after the description.\n\n```ruby\nnamespace \'order\' do\n  desc \'This will be your summary\',\n    summary: \'Now this is your summary!\'\n  get :order_id do\n    ...\n  end\nend\n```\n\n\n#### Overriding the tags <a name="overriding_the_tags"></a>\n\nTags are used for logical grouping of operations by resources or any other qualifier. To override the\ntags array, add `tags: [\'tag1\', \'tag2\']` after the description.\n\n```ruby\nnamespace \'order\' do\n  desc \'This will be your summary\', tags: [\'orders\']\n  get :order_id do\n    ...\n  end\nend\n```\n\n\n#### Deprecating routes <a name="deprecating-routes"></a>\n\nTo deprecate a route add `deprecated: true` after the description.\n\n```ruby\nnamespace \'order\' do\n  desc \'This is a deprecated route\', deprecated: true\n  get :order_id do\n    ...\n  end\nend\n```\n\n\n#### Overriding the name of the body parameter <a name="body-param"></a>\n\nBy default, body parameters have a generated name based on the operation. For\ndeeply nested resources, this name can get very long. To override the name of\nbody parameter add `body_name: \'post_body\'` after the description.\n\n```ruby\nnamespace \'order\' do\n  desc \'Create an order\', body_name: \'post_body\'\n  post do\n    ...\n  end\nend\n```\n\n\n#### Defining an endpoint as an array <a name="array"></a>\n\nYou can define an endpoint as an array by adding `is_array` in the description:\n\n```ruby\ndesc \'Get a full list of pets\', is_array: true\n```\n\n\n#### Using an options hash <a name="options"></a>\n\nThe Grape DSL supports either an options hash or a restricted block to pass settings. Passing the `nickname`, `hidden` and `is_array` options together with response codes is only possible when passing an options hash.\nSince the syntax differs you\'ll need to adjust it accordingly:\n\n```ruby\ndesc \'Get all kittens!\', {\n  hidden: true,\n  is_array: true,\n  nickname: \'getKittens\',\n  success: Entities::Kitten, # or success\n  failure: [[401, \'KittenBitesError\', Entities::BadKitten]] # or failure\n  # also explicit as hash: [{ code: 401, message: \'KittenBitesError\', model: Entities::BadKitten }]\n  produces: [ "array", "of", "mime_types" ],\n  consumes: [ "array", "of", "mime_types" ]\n  }\nget \'/kittens\' do\n```\n\n\n#### Overriding parameter type <a name="overriding-param-type"></a>\n\nYou can override paramType, using the documentation hash. See [parameter object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#parameter-object) for available types.\n\n```ruby\nparams do\n  requires :action, type: Symbol, values: [:PAUSE, :RESUME, :STOP], documentation: { param_type: \'query\' }\nend\npost :act do\n  ...\nend\n```\n\n\n#### Overriding data type of the parameter <a name="overriding-type-of-param"></a>\n\nYou can override type, using the documentation hash.\n\n```ruby\nparams do\n  requires :input, type: String, documentation: { type: \'integer\' }\nend\npost :act do\n  ...\nend\n```\n\n```json\n{\n  "in": "formData",\n  "name": "input",\n  "type": "integer",\n  "format": "int32",\n  "required": true\n}\n```\n\n\n#### Multiple types <a name="multiple-types"></a>\n\nBy default when you set multiple types, the first type is selected as swagger type\n\n```ruby\nparams do\n  requires :action, types: [String, Integer]\nend\npost :act do\n  ...\nend\n```\n\n```json\n{\n  "in": "formData",\n  "name": "action",\n  "type": "string",\n  "required": true\n}\n```\n\n\n#### Array of data type <a name="array-type"></a>\n\nArray types are also supported.\n\n```ruby\nparams do\n  requires :action_ids, type: Array[Integer]\nend\npost :act do\n  ...\nend\n```\n\n```json\n{\n  "in": "formData",\n  "name": "action_ids",\n  "type": "array",\n  "items": {\n      "type": "integer"\n  },\n  "required": true\n}\n```\n\n\n#### Collection format of arrays <a name="collection-format"></a>\n\nYou can set the collection format of an array, using the documentation hash.\n\nCollection format determines the format of the array if type array is used. Possible values are:\n*  csv - comma separated values foo,bar.\n*  ssv - space separated values foo bar.\n*  tsv - tab separated values foo\\tbar.\n*  pipes - pipe separated values foo|bar.\n*  multi - corresponds to multiple parameter instances instead of multiple values for a single instance foo=bar&foo=baz. This is valid only for parameters in "query" or "formData".\n\n```ruby\nparams do\n  requires :statuses, type: Array[String], documentation: { collectionFormat: \'multi\' }\nend\npost :act do\n  ...\nend\n```\n\n```json\n{\n  "in": "formData",\n  "name": "statuses",\n  "type": "array",\n  "items": {\n      "type": "string"\n  },\n  "collectionFormat": "multi",\n  "required": true\n}\n```\n\n\n#### Hiding parameters <a name="hiding-parameters"></a>\n\nExclude single optional parameter from the documentation\n\n```ruby\nparams do\n  optional :one, documentation: { hidden: true }\n  optional :two, documentation: { hidden: -> { true } }\nend\npost :act do\n  ...\nend\n```\n\n\n#### Setting a Swagger default value <a name="default-value"></a>\n\nGrape allows for an additional documentation hash to be passed to a parameter.\n\n```ruby\nparams do\n  requires :id, type: Integer, desc: \'Coffee ID\'\n  requires :temperature, type: Integer, desc: \'Temperature of the coffee in celcius\', documentation: { default: 72 }\nend\n```\n\nThe example parameter will populate the Swagger UI with the example value, and can be used for optional or required parameters.\n\nGrape uses the option `default` to set a default value for optional parameters. This is different in that Grape will set your parameter to the provided default if the parameter is omitted, whereas the example value above will only set the value in the UI itself. This will set the Swagger `defaultValue` to the provided value. Note that the example value will override the Grape default value.\n\n```ruby\nparams do\n  requires :id, type: Integer, desc: \'Coffee ID\'\n  optional :temperature, type: Integer, desc: \'Temperature of the coffee in celcius\', default: 72\nend\n```\n\n\n#### Expose nested namespace as standalone route\n\nUse the `nested: false` property in the `swagger` option to make nested namespaces appear as standalone resources.\nThis option can help to structure and keep the swagger schema simple.\n\n```ruby\nnamespace \'store/order\', desc: \'Order operations within a store\', swagger: { nested: false } do\n  get :order_id do\n  \t...\n  end\nend\n```\n\nAll routes that belong to this namespace (here: the `GET /order_id`) will then be assigned to the `store_order` route instead of the `store` resource route.\n\nIt is also possible to expose a namespace within another already exposed namespace:\n\n```ruby\nnamespace \'store/order\', desc: \'Order operations within a store\', swagger: { nested: false } do\n  get :order_id do\n  \t...\n  end\n  namespace \'actions\', desc: \'Order actions\' do, nested: false\n    get \'evaluate\' do\n      ...\n    end\n  end\nend\n```\nHere, the `GET /order_id` appears as operation of the `store_order` resource and the `GET /evaluate` as operation of the `store_orders_actions` route.\n\n\n##### With a custom name\n\nAuto generated names for the standalone version of complex nested resource do not have a nice look.\nYou can set a custom name with the `name` property inside the `swagger` option, but only if the namespace gets exposed as standalone route.\nThe name should not contain whitespaces or any other special characters due to further issues within swagger-ui.\n\n```ruby\nnamespace \'store/order\', desc: \'Order operations within a store\', swagger: { nested: false, name: \'Store-orders\' } do\n  get :order_id do\n  \t...\n  end\nend\n```\n\n\n#### Response documentation <a name="response"></a>\n\nYou can also document the HTTP status codes with a description and a specified model, as ref in the schema to the definitions, that your API returns with one of the following syntax.\n\nIn the following cases, the schema ref would be taken from route.\n\n```ruby\ndesc \'thing\', failure: [ { code: 400, message: \'Invalid parameter entry\' } ]\nget \'/thing\' do\n  # ...\nend\n```\n\n```ruby\ndesc \'thing\' do\n  params Entities::Something.documentation\n  failure [ { code: 400, message: \'Invalid parameter entry\' } ]\nend\nget \'/thing\' do\n  # ...\nend\n```\n\n```ruby\nget \'/thing\', failure: [\n  { code: 400, message: \'Invalid parameter entry\' },\n  { code: 404, message: \'Not authorized\' },\n] do\n  # ...\nend\n```\n\nBy adding a `model` key, e.g. this would be taken.\n```ruby\nget \'/thing\', failure: [\n  { code: 400, message: \'General error\' },\n  { code: 422, message: \'Invalid parameter entry\', model: Entities::ApiError }\n] do\n  # ...\nend\n```\nIf no status code is defined [defaults](/lib/grape-swagger/endpoint.rb#L210) would be taken.\n\nThe result is then something like following:\n\n```json\n"responses": {\n  "200": {\n    "description": "get Horses",\n    "schema": {\n      "$ref": "#/definitions/Thing"\n    }\n  },\n  "401": {\n    "description": "HorsesOutError",\n    "schema": {\n      "$ref": "#/definitions/ApiError"\n    }\n  }\n},\n```\n\n\n#### Changing default status codes <a name="change-status"></a>\n\nThe default status codes, one could be found (-> [status codes](lib/grape-swagger/doc_methods/status_codes.rb)) can be changed to your specific needs, to achive it, you have to change it for grape itself and for the documentation.\n\n```ruby\ndesc \'Get a list of stuff\',\n    success: { code: 202, model: Entities::UseResponse, message: \'a changed status code\' }\nget do\n  status 202\n  # your code comes here\nend\n```\n\n```json\n"responses": {\n  "202": {\n    "description": "ok",\n    "schema": {\n      "$ref": "#/definitions/UseResponse"\n    }\n  }\n},\n```\n\n#### Multiple status codes for response <a name="multiple-status-response"></a>\n\nMultiple values can be provided for `success` and `failure` attributes in the response.\n\n```ruby\ndesc \'Attach a field to an entity through a PUT\',\n    success: [\n      { code: 201, model: Entities::UseResponse, message: \'Successfully created\' },\n      { code: 204, message: \'Already exists\' }\n    ],\n    failure: [\n      { code: 400, message: \'Bad request\' },\n      { code: 404, message: \'Not found\' }\n    ]\nput do\n  # your code comes here\nend\n```\n\n```json\n"responses": {\n  "201": {\n    "description": "Successfully created",\n    "schema": {\n      "$ref": "#/definitions/UseResponse"\n    }\n  },\n  "204": {\n    "description": "Already exists"\n  },\n  "400": {\n    "description": "Bad request"\n  },\n  "404": {\n    "description": "Not found"\n  }\n},\n```\n\n\n#### File response <a name="file-response"></a>\n\nSetting `success` to `File` sets a default `produces` of `application/octet-stream`.\n\n```ruby\ndesc \'Get a file\',\n    success: File\nget do\n  # your file response\nend\n```\n\n```json\n"produces": [\n  "application/octet-stream"\n],\n"responses": {\n  "200": {\n    "description": "Get a file",\n    "schema": {\n      "type": "file"\n    }\n  }\n}\n```\n\n\n#### Extensions <a name="extensions"></a>\n\nSwagger spec2.0 supports extensions on different levels, for the moment,\nthe documentation on the root level object and the `info`, `verb`, `path` and `definition` levels are supported.\n\nThe documented key would be generated from the `x` + `-` + key of the submitted hash,\nfor possibilities refer to the [extensions spec](spec/lib/extensions_spec.rb).\nTo get an overview *how* the extensions would be defined on grape level, see the following examples:\n\n- root object extension, add a `x` key to the root hash when calling ```add_swagger_documentation```:\n```ruby\n  add_swagger_documentation \\\n    x: {\n      some: \'stuff\'\n    },\n    info: {\n    }\n```\nthis would generate:\n```json\n{\n  "x-some": "stuff",\n  "info":{\n  }\n}\n```\n\n- `info` extension, add a `x` key to the `info` hash when calling ```add_swagger_documentation```:\n```ruby\n  add_swagger_documentation \\\n    info: {\n      x: { some: \'stuff\' }\n    }\n```\nthis would generate:\n```json\n"info":{\n  "x-some":"stuff"\n}\n```\n\n- `verb` extension, add a `x` key to the `desc` hash:\n```ruby\ndesc \'This returns something with extension on verb level\',\n  x: { some: \'stuff\' }\n```\nthis would generate:\n```json\n"/path":{\n  "get":{\n    "\xe2\x80\xa6":"\xe2\x80\xa6",\n    "x-some":"stuff"\n  }\n}\n```\n\n- `operation` extension, by setting via route settings::\n```ruby\nroute_setting :x_operation, { some: \'stuff\' }\n```\nthis would generate:\n```json\n"/path":{\n  "get":{\n    "\xe2\x80\xa6":"\xe2\x80\xa6",\n    "x-some":"stuff"\n  }\n}\n```\n\n- `path` extension, by setting via route settings:\n```ruby\nroute_setting :x_path, { some: \'stuff\' }\n```\nthis would generate:\n```json\n"/path":{\n  "x-some":"stuff",\n  "get":{\n    "\xe2\x80\xa6":"\xe2\x80\xa6",\n  }\n}\n```\n\n- `definition` extension, again by setting via route settings,\nhere the status code must be provided, for which definition the extensions should be:\n```ruby\nroute_setting :x_def, { for: 422, other: \'stuff\' }\n```\nthis would generate:\n```json\n"/definitions":{\n  "ApiError":{\n    "x-other":"stuff",\n    "\xe2\x80\xa6":"\xe2\x80\xa6",\n  }\n}\n```\nor, for more definitions:\n```ruby\nroute_setting :x_def, [{ for: 422, other: \'stuff\' }, { for: 200, some: \'stuff\' }]\n```\n\n\n#### Response examples documentation <a name="response-examples"></a>\n\nYou can also add examples to your responses by using the `desc` DSL with block syntax.\n\nBy specifying examples to `success` and `failure`.\n\n```ruby\ndesc \'This returns examples\' do\n  success model: Thing, examples: { \'application/json\' => { description: \'Names list\', items: [{ id: \'123\', name: \'John\' }] } }\n  failure [[404, \'NotFound\', ApiError, { \'application/json\' => { code: 404, message: \'Not found\' } }]]\nend\nget \'/thing\' do\n  ...\nend\n```\n\nThe result will look like following:\n\n```json\n  "responses": {\n    "200": {\n      "description": "This returns examples",\n      "schema": {\n        "$ref": "#/definitions/Thing"\n      },\n      "examples": {\n        "application/json": {\n          "description": "Names list",\n          "items": [\n            {\n              "id": "123",\n              "name": "John"\n            }\n          ]\n        }\n      }\n    },\n    "404": {\n      "description": "NotFound",\n      "schema": {\n        "$ref": "#/definitions/ApiError"\n      },\n      "examples": {\n        "application/json": {\n          "code": 404,\n          "message": "Not found"\n        }\n      }\n    }\n  }\n```\n\nFailure information can be passed as an array of arrays or an array of hashes.\n\n#### Response headers documentation <a name="response-headers"></a>\n\nYou can also add header information to your responses by using the `desc` DSL with block syntax.\n\nBy specifying headers to `success` and `failure`.\n\n```ruby\ndesc \'This returns headers\' do\n  success model: Thing, headers: { \'Location\' => { description: \'Location of resource\', type: \'string\' } }\n  failure [[404, \'NotFound\', ApiError, { \'application/json\' => { code: 404, message: \'Not found\' } }, { \'Date\' => { description: \'Date of failure\', type: \'string\' } }]]\nend\nget \'/thing\' do\n  ...\nend\n```\n\nThe result will look like following:\n\n```json\n  "responses": {\n    "200": {\n      "description": "This returns examples",\n      "schema": {\n        "$ref": "#/definitions/Thing"\n      },\n      "headers": {\n        "Location": {\n          "description": "Location of resource",\n          "type": "string"\n        }\n      }\n    },\n    "404": {\n      "description": "NotFound",\n      "schema": {\n        "$ref": "#/definitions/ApiError"\n      },\n      "examples": {\n        "application/json": {\n          "code": 404,\n          "message": "Not found"\n        }\n      },\n      "headers": {\n        "Date": {\n          "description": "Date of failure",\n          "type": "string"\n        }\n      }\n    }\n  }\n```\n\nFailure information can be passed as an array of arrays or an array of hashes.\n\n#### Adding root element to responses <a name="response-root"></a>\n\nYou can specify a custom root element for a successful response:\n\n```ruby\nroute_setting :swagger, root: \'cute_kitten\'\ndesc \'Get a kitten\' do\n  http_codes [{ code: 200, model: Entities::Kitten }]\nend\nget \'/kittens/:id\' do\nend\n```\n\nThe result will look like following:\n\n```\n  "responses": {\n    "200": {\n      "description": "Get a kitten",\n      "schema": {\n        "type": "object",\n        "properties": { "cute_kitten": { "$ref": "#/definitions/Kitten" } }\n      }\n    }\n  }\n```\n\nIf you specify `true`, the value of the root element will be deduced based on the model name.\nE.g. in the following example the root element will be "kittens":\n\n```ruby\nroute_setting :swagger, root: true\ndesc \'Get kittens\' do\n  is_array true\n  http_codes [{ code: 200, model: Entities::Kitten }]\nend\nget \'/kittens\' do\nend\n```\n\nThe result will look like following:\n\n```\n  "responses": {\n    "200": {\n      "description": "Get kittens",\n      "schema": {\n        "type": "object",\n        "properties": { "type": "array", "items": { "kittens": { "$ref": "#/definitions/Kitten" } } }\n      }\n    }\n  }\n```\n\n## Using Grape Entities <a name="grape-entity"></a>\n\nAdd the [grape-entity](https://github.com/ruby-grape/grape-entity) and [grape-swagger-entity](https://github.com/ruby-grape/grape-swagger-entity) gem to your Gemfile.\n\nThe following example exposes statuses. And exposes statuses documentation adding :type, :desc and :required.\nThe documented class/definition name could be set via `#entity_name`.\n\n```ruby\nmodule API\n  module Entities\n    class Status < Grape::Entity\n      expose :text, documentation: { type: \'string\', desc: \'Status update text.\', required: true }\n      expose :links, using: Link, documentation: { type: \'link\', is_array: true }\n      expose :numbers, documentation: { type: \'integer\', desc: \'favourite number\', values: [1,2,3,4] }\n    end\n\n    class Link < Grape::Entity\n      expose :href, documentation: { type: \'url\' }\n      expose :rel, documentation: { type: \'string\'}\n\n      def self.entity_name\n        \'LinkedStatus\'\n      end\n\n    end\n  end\n\n  class Statuses < Grape::API\n    version \'v1\'\n\n    desc \'Statuses index\',\n      entity: API::Entities::Status\n    get \'/statuses\' do\n      statuses = Status.all\n      type = current_user.admin? ? :full : :default\n      present statuses, with: API::Entities::Status, type: type\n    end\n\n    desc \'Creates a new status\',\n      entity: API::Entities::Status,\n      params: API::Entities::Status.documentation\n    post \'/statuses\' do\n        ...\n    end\n  end\nend\n```\n\n\n### Relationships\n\nYou may safely omit `type` from relationships, as it can be inferred. However, if you need to specify or override it, use the full name of the class leaving out any modules named `Entities` or `Entity`.\n\n\n#### 1xN\n\n```ruby\nmodule API\n  module Entities\n    class Client < Grape::Entity\n      expose :name, documentation: { type: \'string\', desc: \'Name\' }\n      expose :addresses, using: Entities::Address,\n        documentation: { type: \'Entities::Address\', desc: \'Addresses.\', param_type: \'body\', is_array: true }\n    end\n\n    class Address < Grape::Entity\n      expose :street, documentation: { type: \'string\', desc: \'Street.\' }\n    end\n  end\n\n  class Clients < Grape::API\n    version \'v1\'\n\n    desc \'Clients index\',\n      params: Entities::Client.documentation,\n      success: Entities::Client\n    get \'/clients\' do\n      ...\n    end\n  end\n\n  add_swagger_documentation\nend\n```\n\n\n#### 1x1\n\nNote: `is_array` is `false` by default.\n\n```ruby\nmodule API\n  module Entities\n    class Client < Grape::Entity\n      expose :name, documentation: { type: \'string\', desc: \'Name\' }\n      expose :address, using: Entities::Address,\n        documentation: { type: \'Entities::Address\', desc: \'Addresses.\', param_type: \'body\', is_array: false }\n    end\n\n    class Address < Grape::Entity\n      expose :street, documentation: { type: \'string\', desc: \'Street\' }\n    end\n  end\n\n  class Clients < Grape::API\n    version \'v1\'\n\n    desc \'Clients index\',\n      params: Entities::Client.documentation,\n      success: Entities::Client\n    get \'/clients\' do\n      ...\n    end\n  end\n\n  add_swagger_documentation\nend\n```\n\n\n\n## Securing the Swagger UI <a name="oauth"></a>\n\nThe Swagger UI on Grape could be secured from unauthorized access using any middleware, which provides certain methods:\n\n- some guard method, which could receive as argument a string or an array of authorization scopes;\n- a *before* method to be run in the Grape controller for authorization purpose;\n- a set of methods which will process the access token received in the HTTP request headers (usually in the\n\'HTTP_AUTHORIZATION\' header) and try to return the owner of the token.\n\nBelow are some examples of securing the Swagger UI on Grape installed along with Ruby on Rails:\n\n- The WineBouncer and Doorkeeper gems are used in the examples;\n- \'rails\' and \'wine_bouncer\' gems should be required prior to \'grape-swagger\' in boot.rb;\n- This works with a fresh PR to WineBouncer which is yet unmerged - [WineBouncer PR](https://github.com/antek-drzewiecki/wine_bouncer/pull/64).\n\nThis is how to configure the grape_swagger documentation:\n\n```ruby\n  add_swagger_documentation base_path: \'/\',\n                            title: \'My API\',\n                            doc_version: \'0.0.1\',\n                            hide_documentation_path: true,\n                            endpoint_auth_wrapper: WineBouncer::OAuth2, # This is the middleware for securing the Swagger UI\n                            swagger_endpoint_guard: \'oauth2 false\',     # this is the guard method and scope\n                            token_owner: \'resource_owner\'               # This is the method returning the owner of the token\n```\n\nThe guard method should inject the Security Requirement Object into the endpoint\'s route settings (see Grape::DSL::Settings.route_setting method).\n\nThe \'oauth2 false\' added to swagger_documentation is making the main Swagger endpoint protected with OAuth, i.e. the\naccess_token is being retreiving from the HTTP request, but the \'false\' scope is for skipping authorization and\nshowing the UI for everyone. If the scope would be set to something else, like \'oauth2 admin\', for example, than the UI\n wouldn\'t be displayed at all to unauthorized users.\n\nFurther on, the guard could be used, where necessary, for endpoint access protection. Put it prior to the endpoint\'s method:\n\n```ruby\n  resource :users do\n    oauth2 \'read, write\'\n    get do\n      render_users\n    end\n\n    oauth2 \'admin\'\n    post do\n      User.create!...\n    end\n  end\n```\n\nAnd, finally, if you want to not only restrict the access, but to completely hide the endpoint from unauthorized\nusers, you could pass a lambda to the :hidden key of a endpoint\'s description:\n\n```ruby\n  not_admins = lambda { |token_owner = nil| token_owner.nil? || !token_owner.admin? }\n\n  resource :users do\n    desc \'Create user\', hidden: not_admins\n    oauth2 \'admin\'\n    post do\n      User.create!...\n    end\n  end\n```\n\nThe lambda is checking whether the user is authenticated (if not, the token_owner is nil by default), and has the admin\nrole - only admins can see this endpoint.\n\n\n\n## Example <a name="example"></a>\n\nGo into example directory and run it: `$ bundle exec rackup`\ngo to: `http://localhost:9292/swagger_doc` to get it\n\nFor request examples load the [postman file]()\n\n#### Grouping the API list using Namespace\n\nUse namespace for grouping APIs\n\n![grape-swagger-v2-new-corrected](https://cloud.githubusercontent.com/assets/1027590/13516020/979cfefa-e1f9-11e5-9624-f4a6b17a3c8a.png)\n\n#### Example Code\n\n```ruby\nclass NamespaceApi < Grape::API\n  namespace :hudson do\n    desc \'Document root\'\n    get \'/\' do\n    end\n\n    desc \'This gets something.\',\n      detail: \'_test_\'\n\n    get \'/simple\' do\n      { bla: \'something\' }\n    end\n  end\n\n  namespace :download do\n    desc \'download files\',\n         success: File,\n         produces: [\'text/csv\']\n    get \':id\' do\n      # file response\n    end\n  end\nend\n  \xe2\x80\xa6\n\n```\n\n\n\n## Rake Tasks <a name="rake"></a>\n\nAdd these lines to your Rakefile, and initialize the Task class with your Api class \xe2\x80\x93 be sure your Api class is available.\n\n```ruby\nrequire \'grape-swagger/rake/oapi_tasks\'\nGrapeSwagger::Rake::OapiTasks.new(::Api::Base)\n```\n\n#### OpenApi/Swagger Documentation\n\n```\nrake oapi:fetch\nparams:\n- store={ true | file_name } \xe2\x80\x93 save as JSON (optional)\n- resource=resource_name     \xe2\x80\x93 get only for this one (optional)\n```\n\n#### OpenApi/Swagger Validation\n\n**requires**: `npm` and `swagger-cli` to be installed\n\n\n```\nrake oapi:validate\nparams:\n- resource=resource_name \xe2\x80\x93 get only for this one (optional)\n```\n\n\n## Contributing to grape-swagger\n\nSee [CONTRIBUTING](CONTRIBUTING.md).\n\n## Copyright and License\n\nCopyright (c) 2012-2016 Tim Vandecasteele, ruby-grape and contributors. See [LICENSE.txt](LICENSE.txt) for details.\n'