b'<p align="center">\n    <img alt="logo" src="logo.svg" width="300px">\n</p>\n\n<h1><p align="center">standardese</p></h1>\n\n<p align="center">\n  <img src="https://img.shields.io/badge/License-MIT-blue.svg" alt="License: MIT">\n  <a href="https://travis-ci.org/foonathan/standardese"><img src="https://travis-ci.org/foonathan/standardese.svg?branch=master" alt="Travis CI"></a>\n  <a href="https://ci.appveyor.com/project/foonathan/standardese/branch/master"><img src="https://ci.appveyor.com/api/projects/status/1aw8ml5lawu4mtyv/branch/master?svg=true" alt="Appveyor"></a>\n  <a href="https://gitter.im/foonathan/standardese?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge"><img src="https://badges.gitter.im/foonathan/standardese.svg" alt="Gitter"></a>\n</p>\n\n<p align="center">The nextgen <a href="https://doxygen.org">Doxygen</a> for C++</p>\n<hr>\n\n\n***Note:** The development branch is currently getting a major overhaul, this README is partly out of date and some features are missing.*\n\nStandardese aims to be a nextgen [Doxygen](http://doxygen.org).\nIt consists of two parts: a library and a tool.\n\nThe library aims at becoming *the* documentation frontend that can be easily extended and customized.\nIt parses C++ code with the help of [libclang](http://clang.llvm.org/doxygen/group__CINDEX.html) and provides access to it.\n\nThe tool drives the library to generate documentation for user-specified files.\nIt supports a couple of output formats including Markdown and HTML as well as experimental Latex and Man pages.\n\nRead more in the introductory [blog post](http://foonathan.github.io/blog/2016/05/06/standardese-nextgen-doxygen.html).\n\n[![Patreon](https://c5.patreon.com/external/logo/become_a_patron_button.png)](https://patreon.com/foonathan)\n\nIf you like this project, consider supporting me on Patreon.\nIt would really help!\n\n## Basic example\n\nConsider the following C++ header file named `swap.hpp`:\n\n```cpp\n#include <type_traits>\n\nnamespace std\n{\n\n    /// \\effects Exchanges values stored in two locations.\n    /// \\requires Type `T` shall be `MoveConstructible` and `MoveAssignable`.\n    template <class T>\n    void swap(T &a, T &b) noexcept(is_nothrow_move_constructible<T>::value &&\n                                    is_nothrow_move_assignable<T>::value);\n}\n```\n\nThis will generate the following documentation:\n\n> # Header file `swap.hpp`\n>\n>\n> ```cpp\n> #include <type_traits>\n>\n> namespace std\n> {\n>     template <typename T>\n>     void swap(T & a, T & b) noexcept(is_nothrow_move_constructible<T>::value &&\n>     is_nothrow_move_assignable<T>::value);\n> }\n> ```\n>\n>\n> ## Function template ``swap<T>``\n>\n>\n> ```cpp\n> template <typename T>\n> void swap(T & a, T & b) noexcept(is_nothrow_move_constructible<T>::value &&\n> is_nothrow_move_assignable<T>::value);\n> ```\n>\n>\n> *Effects:* Exchanges values stored in two locations.\n>\n> *Requires:* Type `T` shall be `MoveConstructible` and `MoveAssignable`.\n\nThe example makes it already clear:\nStandardese aims to provide a documentation in a similar way to the C++ standard - hence the name.\n\nThis means that it provides commands to introduce so called *sections* in the documentation.\nThe current sections are all the C++ standard lists in `[structure.specifications]/3` like `\\effects`, `\\requires`, `\\returns` and `\\throws`.\n\nFor a more complete example check out [my Meeting C++ Lightning Talk](https://www.youtube.com/watch?v=zoSGHMi-0lE).\n\n## Installation\n\n### Very Easy: Pre-compiled Binaries\n\nTODO\n\n### Easy: Docker\n\nThe easiest way to build standardese is to download the docker image `foonathan/standardese_dev` and run it like so:\n\n```\ndocker pull foonathan/standardese_dev\ndocker run -v "/path/to/standardese/source:/root/standardese" -v "$(pwd):/root/output" foonathan/standardese_dev\n```\n\nIt will compile `standardese` as a fully statically linked binary and copy it to the current working directory.\nThe binary is compatible with any Linux distribution.\n\n### Harder: Building From Source\n\nThe build system takes care of all dependencies automatically, except for two: Boost and libclang.\n\nIt needs to have Boost.ProgramOptions and Boost.Filesystem as statically linked binaries.\nIf they\'re installed, they should be found automatically.\n\nIt also needs libclang.\nIf you are under a Linux system, it should find the `llvm-config` binary automatically and everything works,\notherwise things are a bit harder.\nRead the [cppast build instructions](https://github.com/foonathan/cppast#installation) for more information, they also apply here.\n\nOnce they\'re installed, compiling is a simple:\n\n```\ncmake /path/to/standardese/source\ncmake --build . --target standardese_tool\n```\n\nThe result is the executable `tool/standardese`.\n\nTODO: cmake installation\n\n## Documentation\n\n> If you need help or encounter a problem please contact me [on gitter](https://gitter.im/foonathan/standardese?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge), I\'ll usually answer within a day or faster.\n\n### Basic commandline usage\n\nThe tool uses Boost.ProgramOptions for the options parsing, `--help` gives a good overview.\n\nBasic usage is: `standardese [options] inputs`\n\nThe inputs can be both files or directories, in case of directory each file is documented, unless an input option is specified (see below).\nThe tool will currently generate a corresponding Markdown file with the documentation for each file it gets as input.\nFiles that are not source files (determined by the `input.source_ext` option), will be treated as template files (see below).\n\n> Note: You only need and should give header files to standardese.\n> The source files are unnecessary.\n\nThe options listed under "Generic options:" must be given to the commandline.\nThey include things like getting the version, enabling verbose output (please provide it for issues) or passing an additional configuration file.\n\nThe options listed under "Configuration" can be passed both to the commandline and to the config file.\nThey are subdivided into various sections:\n\n* The `input.*` options are related to the inputs given to the tool.\nThey can be used to filter, both the files inside a directory and the entities in the source code.\n\n* The `compilation.*` options are related to the compilation of the source.\nYou can pass macro definitions and include directories as well as a `commands_dir`.\nThis is a directory where a `compile_commands.json` file is located.\nstandardese will pass *all* the flags of all files to libclang.\n\n> This has technical reasons because you give header files whereas the compile commands use only source files.\n\n* The `comment.*` options are related to the syntax of the documentation markup.\nYou can set both the leading character and the name for each command, for example.\n\n* The `template.*` options are related to the syntax of the template markup.\nYou can set both the delimiters and the name for each command, for example.\n\n* The `output.*` options are related to the output generation.\nIt contains an option to set the human readable name of a section, for example.\n\nThe configuration file you can pass with `--config` uses an INI style syntax, e.g:\n\n```\n[compilation]\ninclude_dir=foo/\nmacro_definition=FOO\n\n[input]\nblacklist_namespace=detail\nextract_private=true\n```\n\n### Basic CMake usage\n\nTo ease the compilation options, you can call standardese from CMake like so:\n\n```\nfind_package(standardese REQUIRED) # find standardese after installation\n\n# generates a custom target that will run standardese to generate the documentation\nstandardese_generate(my_target CONFIG path/to/config_file\n                     INCLUDE_DIRECTORY ${my_target_includedirs}\n                     INPUT ${headers})\n```\n\nIt will use a custom target that runs standardese.\nYou can specify the compilation options and inputs directly in CMake to allow shared variables.\nAll other options must be given in a config file.\n\nIf you don\'t have standardese installed, you can also include it directly:\n\n```\nset(STANDARDESE_TOOL /path/to/standardese/binary)\ninclude(/path/to/standardese/standardese-config.cmake)\n\n# call standardese_generate() like normal\n```\n\nSee `standardese-config.cmake` for a documentation of `standardese_generate()`.\n\n### Documentation syntax overview\n\nstandardese looks for documentation comments as shown in the following example:\n\n```cpp\n/// A regular C++ style documentation comment.\n/// Multiple C++ style comments are merged automatically.\n///   This line has *two* leading whitespaces because one is always skipped.\n\n//! A C++ style comment using an exclamation mark.\n/// It will also merge with other C++ style comments.\n//! But don\'t worry, also with the exclamation mark styles.\n\n/** A C style documentation commment. */\n/** This is a different comment, they aren\'t merged.\n * But you can be fancy with the star at the beginning of the line.\n * It will ignore all whitespace, the star and the first following whitespace.\n */\n\n/*! You can also use an exclamation mark. */\n/// But neither will merge with any other comment.\n\nint x; //< An end-of-line comment.\n/// It will merge with C++ style comments.\nint y; //< But this is a different end-of-line comment.\n```\n\nA comment corresponds to the entity on the line directly below or on the same line.\nYou can document all entities that way except files (use `file` command), namespaces (use `entity` command),\nand inline entities such as parameters or base classes (use `param/tparam/base` command or `entity` command).\n\nInside the comment you can use arbitrary\\* Markdown\\* in the documentation comments and it will be rendered appropriately.\n\n> The Markdown flavor used is [CommonMark](https://commonmark.org).\n> standardese does not support inline HTML (for obvious reasons) or images.\n> Inline HTML that isn\'t a raw HTML block will be treated as literal text.\n> This allows writing `vector<T>` without markup or escaping in the comment, for example.\n\n*Note: CommonMark allows hard line breaks with a backslash at the end of the line.\nBut the C preprocessor uses a backslash to combine multiple lines into one.\nFor that reason you cannot use a backslash there,\ninstead you can use a forward slash.*\n\n#### Linking\n\nTo link to an entity, use the syntax `[link-text](<> "unique-name")` (a CommonMark link with empty URL and a title of `unique-name`). If you don\'t want a special `link-text`, this can be shortened to `[unique-name]()` (a CommonMark link with empty URL and the name of an entity as text).\nYou can also use an URL of the following form `[link-text](standardese://unique-name/ "optional-title")` (a normal CommonMark link with the `standardese://` protocol, the \'/\' at the end is important).\nIn either case `standardese` will insert the correct URL by searching for the entity with the given `unique-name`.\n\nThe `unique-name` of an entity is the name with all scopes, i.e. `foo::bar::baz`.\n\n* For templates (but not function templates) you need to append all parameters, i.e. `foo<A, B, C>`.\n\n* For functions you need to append the signature (parameter types and cv and ref qualifier), i.e. `func()`, `bar(int,char)` or `type::foo() const &&`. If the signature is `()`, you can omit it.\n\n* For (template) parameters it is of the form `function-unique-name.parameter-name`\n\n* For base classes it is of the form `derived-class::base-class`\n\nThe `unique-name` doesn\'t care about whitespace, so `bar(const char*)`, `bar(const char *)` and `bar (constchar*)` are all the same.\nBecause it is sometimes long and ugly, you can override the unique name via the `unique_name` command (see below).\n\n> For example you can override `bar(long, list, of, parameters)` to `bar()`.\n> But keep in mind that it must be unique with regard to all overloads etc.\n> Usually numbering would be a good choice, so `bar() (1)` or similar.\n\nYou can also use a short `unique-name` if there aren\'t multiple entities resolved to the same short name.\nThe short name is the `unique-name` but without a signature or template parameters, i.e. for `foo<T>::func<U>(int) const`, the short name is `foo::func`.\n\n##### Name lookup\n\nIf you prefix a unique name with `*` or `?`, this will do a name lookup, looking for the entity.\nThis only works inside a comment associated with an entity, not in template files etc.\n\nIt does a similar search to the actual name lookup in C++:\nIt starts at the associated entity and appends its scope to the partial unique name given,\ngoing to the next higher entity if no matching entity can be found, etc.\n\nFor example:\n\n```cpp\n/// a.\nstruct a {};\n\nnamespace ns\n{\n    /// ns::a.\n    struct a {};\n\n    /// [This will link to ::a, no lookup here](standardese://a/).\n    /// [This will link to ns::a](standardese://*a/).\n    void foo();\n\n    /// b\n    template <typename T>\n    struct b\n    {\n        /// c.\n        void c();\n\n        /// [This will link to ns::b<T>::c()](standardese://*c/).\n        void foo();\n    };\n}\n```\n\n##### External links\n\nYou can also link to external documentations via the tool option `--comment.external_doc prefix=url`.\nAll `unique-name`s starting with `prefix` will be linked to the `url`.\nIf the `url` contains two dollar signs `$$`, they will be replaced by the `unique-name`.\nBy default the tool supports http://en.cppreference.com/w/ with a prefix of `std::` by default.\n\n> You can override to a different URL by specifying `--comment.external_doc std::=new-url`.\n\n#### Special commands\n\nstandardese adds its own sets of special commands.\nA command is introduced by the *command character* (a backslash by default) at the beginning of each line in the comment.\n\nThere are three kinds of special commands: *commands*, *sections* and *inlines*.\n\n---\n\nA *command* is used to control the documentation generation in some way.\nA text that begins with a *command* doesn\'t appear in the output documentation at all.\n\nThere are the following *commands*:\n\n* `verbatim` - This command isn\'t like the other commands.\nIt can happen anywhere in a line \xe2\x80\x94 i.e. where CommonMark allows an inline entity like emphasis.\nThe text following the command until an `end` command or the end of the line will be inserted as-is into the output.\n\n* `end` - This command ends the currently active section, see below.\nThis can be used to extend a section to multiple paragraphs.\n\n* `exclude {arg}` - Manually excludes an entity or part of it from the documentation.\nIf you don\'t specify an argument, it won\'t appear at all, not even in the synopsis.\nIt is as if the entity never existed in the first place.\nIf you specify `return` as argument, the return type of the function will be hidden in the synopsis.\nIf you specify `target` as argument, the target of the namespace/type alias or underlying type of the enum will be hidden in the synopsis.\n\n*   `unique_name {name}` - Overrides the unique name of an entity (e.g. for linking):\n    ```cpp\n    /// Some documentation.\n    /// I can now link to `bar()` by writing [foo]().\n    ///\n    /// \\unique_name foo\n    void bar(int a, int c);\n    ```\n    Note that if you override the unique name of a parent entity, this will also affect the unique names of child entities.\n    If the unique name starts with \'*\' or \'?\', it will be a *relative* unique name,\n    i.e. the unique name of the parent entity will be prepended to it (with seperator \'::\' if needed).\n\n* `output_name {name}` - Overrides the output name of a file.\nThis will only change the base name, the `doc_` prefix and extension are still handled separately.\nUseful if there are multiple files with the same base name in a project, e.g a `.hpp` and `.h` header.\n\n* `synopsis {string}` - Overrides the synopsis in the output.\nYou can pass any string that will be rendered instead of the actual synopsis.\nUse `\\n` to render a newline and use `\\t` to render a tab.\n\n* `synopsis_return {string}` - Like `synopsis`, but only overrides the return type of the function.\n\n*   `group <name> [heading]` - Add the entity to a member group.\n    A member group consists of multiple entities that are direct members of the same entity (i.e. class, file, namespace,...) which will be grouped together in the output.\n    For example:\n    ```cpp\n    /// \\group foo A heading\n    /// This is in the group `foo`.\n    /// Because this is the first entity in the group, it will be the "master".\n    /// the group comment will be this comment, the group unique name will be this unique name, ...\n    /// The optional heading (everything after the first whitespace) will be shown as heading in the output.\n    void func();\n\n    /// \\group foo\n    /// This entity will be added to the same group.\n    /// As it is not the first occurence of the group,\n    /// this comment here will be ignored.\n    /// But you can still use commands to modify this entity.\n    void func(int);\n\n    /// This entity is not part of the group.\n    void func(char);\n\n    /// \\group foo\n    /// But this one is (again, comment ignored).\n    void func(short);\n    ```\n    This will write the synopsis of all group members together and use the documentation text of the first entity.\n    The group name only needs to be unique for one given scope.\n    *Note: It will only show inline documentation for children, so don\'t use it on containers.*\n\n*   `module {name}` - Add the entity to a module.\n    A module is just a way to group entities together,\n    it will be inherited by all children.\n    There is no need to define a module, but if you do,\n    simply use the command in first place of a module and you can add documentation for it:\n    ```cpp\n    /// This is an entity in the module \'bar\'.\n    /// \\module bar\n    void foo();\n\n    /// \\module bar\n    /// This is the documentation for the module \'bar\',\n    /// because the command was the first one.\n    ```\n\n*   `output_section {name}` - Generates a little section comment in the synopsis above the entity.\n    This is implictly used for member groups with the group name as output section name,\n    if the option `output.show_group_output_section` is `true` (the default).\n    If a member group name starts with \'-\', it will never be used (the minus won\'t be shown).\n    Given the following input:\n    ```cpp\n    /// Some int getter.\n    /// \\output_section Getter functions\n    int get_i();\n\n    /// Some float getter.\n    float get_f();\n\n    /// Some int setter.\n    /// \\output_section Setter functions\n    void set_i(int val);\n\n    /// Some float setter.\n    void set_f(float f);\n    ```\n    It will generate a synopsis like this:\n    ```cpp\n    //=== Getter functions ===//\n    int get_i();\n\n    float get_f();\n\n    //=== Setter functions ===//\n    void set_i(int val);\n\n    void set_f(float f);\n    ```\n\n*   `entity {unique-name}` - If put in the first place of a comment, names the entity to document,\n    this allows "remote" comments:\n    ```cpp\n    void foo();\n\n    /// \\entity foo\n    /// This comment has no corresponding entity.\n    /// But the command specifies the entity it will belong to.\n    ```\n    It also mixes with `unique_name` as you might expect.\n\n* `file` - A shorthand for `\\entity current-file-name`.\n\n---\n\nA *section* is the basic way of standardese documentation.\nIt supports all the sections the C++ standard uses, as explained in the example.\nThose sections will create a paragraph in the output prefixed with a human readable name.\nThere are two special sections, `brief` and `details`.\nThey are not labeled in the output.\n\nUnlike for a *command* text following a *section* is included in the output.\nA *section* is active for the rest of the paragraph, a hard line break or until another special command is encountered.\nAny `brief` sections will be merged together automatically.\n\nIf you don\'t specify a section for a paragraph, the first paragraph will be implictly `brief`, all others implictly `details`.\n\n```cpp\n/// \\brief This text is brief.\n///\n/// This is implictly details.\n/// \\effects This is effects.\n/// This is still effects.\n/// \\returns This is returns./\n/// Due to the hard break this is details again.\n///\n/// \\notes This is notes.\n/// \\notes This is a different notes.\n```\n\nIf you have a section with the form `\\<section> <arg> - <text>`, it will generate a key value list in the output.\nThen you can also add other key-value pairs in each line.\nUse `_` as argument for an empty key.\nSurround the argument in `[<arg>]` and it will create a link where `<arg>` is also the destination,\ni.e. like a regular entity link of the form `[<arg>]()`.\n\n*Note: Due to implementation reason you can\'t use a real CommonMark link as key.*\n\nThe value consists of CommonMark inline formatting until the reset of the section or a new key is encountered.\nFor example:\n\n```cpp\n/// This is documentation text (implictly brief btw).\n/// \\returns 0 - Everything okay (first key-value pair).\n/// 1 - There was an input error (second key-value pair).\n/// This is *still* the second key-value pair.\n///\n/// This is normal text as the paragraph ended.\n```\n\nThis will generate a list of possible return values in the output.\n\nThis is also how the `see` section is intended:\n\n```cpp\n/// Some documentation...\n/// \\see [this_type] - Put a description here (optional)\n/// [this_func()] -\n/// [std::vector<T>] -\n```\n\nIt will generate a "See also:" list in the output with links to the entities.\n\n---\n\nA *inline* is a special kind of command.\nThey are `param`, `tparam` and `base` and used to document (template) parameters and base classes,\nbecause you cannot put a corresponding comment there.\nAs such they are shorthands for the `\\entity unique-name` command.\nThey are followed by the name of entity they refer to.\n\nThe *inline* and argument is stripped from the text.\nThe rest of the line will be treated as `brief` documentation.\nLike a *section*, an *inline* ends when a new special command or hard line break is encountered or a paragraph ends.\nYou can include sections in inlines, however.\n\nFor example:\n\n```cpp\n/// Normal documentation for the function.\n///\n/// \\param foo Brief documentation for the parameter `foo`.\n/// It continues here with details.\n/// \\param bar\n/// \\exclude\n///\n/// The `\\exclude` is part of the documentation for `bar`.\nvoid func(int foo, int bar);\n```\n\n### Template syntax overview\n\n> *Note:* Not implemented on develop at the moment.\n\nIf you pass a file that is not a source file, it will be treated as template file and processed.\nThis allows advanced control over the output or writing additional documentation files.\n\nstandardese will read the file and replace two things:\n\n* URLs with the `standardese://` protocol will be converted to the correct URL for the given entity.\nThis allows referring to documentation entities from other files without manually having to deal with the URLs.\n\n* Special commands inside two curly braces by default (\'{{ \xe2\x80\xa6 }}\').\n\n> Note: standardese is dumb and does not do any other formatting with the template file otherwise.\n> Most importantly, it will create lot of unnecessary empty lines,\n> so does not really work with formats where newlines are important.\n\nThe special commands allow querying standardese for information.\nIt will look for delimiters and commands starting with `standardese_`.\nAll other commands will be silently ignored.\n\n> This allows mixing "normal" template syntax with standardese syntax.\n> Process the file with standardese, then your template engine.\n\nThere are the following commands available,\n`entity` always means the unique name of an entity here.\n\n* `standardese_doc <entity> <format>`: Will be replaced with the documentation output for `entity` in the given `format`.\nFor example `{{ standardese_doc file.hpp html }}` will be replaced with the same HTML standardese will generate for the header file `file.hpp`.\n\n* `standardese_doc_text <entity> <format>`: Will be replaced with the comment of `entity` in the given format.\n\n* `standardese_doc_synopsis <entity> <format>`: Will be replaced with the synopsis of `entity` in the given format.\n\n* `standardese_doc_anchor <unique_name> <format>`: If `unique_name` refers to an existing entity, all links to that entity will link to the anchor in the template file generated in the given format.\nOtherwise it will create a new entity named `unique_name` you can link to throughout the documentation.\n\n* `standardese_name/index_name/unique_name <entity>`: Will be replaced with the name/index name/unique name of the given entity (just a raw character sequence without formatting).\n\n* `standardese_module`: Will be replaced by the module name of the given entity (just a raw character sequence without formatting).\n\n* `standardese_for <variable> <entity>`: Will loop over each child of `entity` and copy the processed next block, the unique name of the current child is stored in the given `variable`. For example, this will print the names of all children of an entity:\n```\n{{ standardese_for $child some_entity }}\n    {{ standardese_name $child }}\n{{ standardese_end }}\n```\n\n* `standardese_if/else_if/else <entity> <op> [args...]`: Will ignore a block if a condition is not fulfilled. See below for a list of conditions. For example, this will do something different depending on the unique name of an entity:\n```\n{{ standardese_if $entity name a }}\n    Name is a!\n{{ standardese_else_if $entity name b }}\n    Name is b!\n{{ standardese_else }}\n    Name is something else.\n{{ standardese_end }}\n```\n\n* `standardese_end`: Ends the block that was started last.\n\nThere are the following if operations available:\n\n* `<entity> name <name>`: Checks if `entity` has the given unique name.\n\n* `<child> first_child <parent>`: Checks if `child` is the first child of `parent`.\n\n* `<entity> has_children`: Checks if `entity` has children.\n\n* `<entity> inline_entity`: Checks if `entity` is an inline entity (parameter, base class, enum value,...) and inline entities will be shown inline in the documentation output (`output.inline_doc`).\n\n* `<entity> member_group`: Checks if `entity` refers to a member group.\n\n* `<entity> index`: Check if `entity` refers to an index file\n\nYou can also provide a default template that can be used to customize the output globally.\nThen there are two special variables available: `$file`, which refers to the current file, and `$format`, which refers to the set output format.\nThe most basic template will just generate the output as standardese would do normally:\n\n```cpp\n{{ standardese_doc $file $format }}\n```\n\n## Acknowledgements\n\nThis project is greatly supported by my [patrons](https://patreon.com/foonathan).\nIn particular thanks to the individual supporters:\n\n* Reiner Eiteljoerge\n* Sina\n\nThanks a lot to the contributors as well:\n\n* Manu @Manu343726 S\xc3\xa1nchez, as always\n\n* Jason @jpleau Pleau, for much feedback and requests on Gitter\n\n* Mark @DarkerStar Gibbs, for feature suggestions\n\n* Tristan @tcbrindle Brindle, for (better) clang support\n\n* Marek @mkurdej Kurdej, for (better) MSVC support\n\n* Victor @vitaut Zverovich, for bugfixes\n\n* John @johnmcfarlane McFarlane, for issue reporting\n\n* Filipe @verri Verri, for maintaining the AUR package\n\n* @topisani, for issue reporting and bugfixes\n\n* Trim @bresilla Bresilla, for our logo\n\nAnd everyone else who shares and uses this project!\n'