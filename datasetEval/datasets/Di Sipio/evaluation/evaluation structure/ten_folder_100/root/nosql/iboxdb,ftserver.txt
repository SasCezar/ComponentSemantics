b'## Lightweight Full Text Search Server for Java\n\n### Setup\n\n```\nUse NetBeans with [JDK8] to build or download fts.zip(WAR) from WAR Folder\nDeploy to tomcat/jetty\n```\n\n\n![](https://github.com/iboxdb/ftserver/raw/master/FTServer/web/css/fts2.png)\n\n### Dependencies\n[iBoxDB](http://www.iboxdb.com)\n\n[Semantic-UI](http://semantic-ui.com/)\n\n[Jsoup](http://jsoup.org/)\n\n\n\n### The Results Order\nthe results order based on the ID number in IndexTextX(.. **long id**, ...),  descending order.\n\nevery page has two index-IDs, normal-id and rankup-id, the rankup-id is a big number and used to keep the important text on the **top**.  (the front results from SearchDistinct(IBox, String) )\n````java\nEngine.IndexTextX(..., p.Id, p.Content, ...);\nEngine.IndexTextX(..., p.RankUpId(), p.RankUpDescription(), ...);\n````\n\nthe RankUpId()\n````java\npublic long RankUpId()\n{\n    return id | (1L << 60);\n}\n````\n\nif you have more more important text , you can add one more index-id\n````java\npublic long AdvertisingId()\n{\n    return id | (1L << 61);\n}\n````\n````java\npublic static long RankDownId(long id)\n{\n    return id & (~(1L << 60 | 1L << 61)) ;\n}\npublic static boolean IsAdvertisingId(long id)\n{\n    return id > (1L << 61) ;\n}\n````\n\n\nthe Page.GetRandomContent() method is used to keep the Search-Page-Content always changing, doesn\'t affect the real page order.\n\nif you have many pages(>100,000),  use the ID number to control the order instead of loading all pages to memory. Or you can load top 100-1000 pages to memory then re-order it by favor. \n\n\n#### Search Format\n\n[Word1 Word2 Word3] => text has **Word1** and **Word2** and **Word3**\n\n["Word1 Word2 Word3"] => text has **"Word1 Word2 Word3"** as a whole\n\nSearch [https http] => get almost all pages\n\n#### Search Method\nsearchDistinct (... String keywords, long **startId**, long **count**)\n\n**startId** => which ID(the id when you called IndexText(,**id**,text)) to start, use (startId=Long.MaxValue) to read from the top, descending order\n\n**count** => records to read,  **important parameter**, the search speed depends on this parameter, not how big the data is.\n\n##### Next Page\nset the startId as the last id from the results of searchDistinct() minus one\n\n```java\nkeywords = function(searchDistinct(box, "keywords", startId, count));\nnextpage_startId = keywords[last].ID - 1 \n...\n//read next page\nsearchDistinct(box, "keywords", nextpage_startId, count)\n```\n\nmostly, the nextpage_startId is posted from client browser when user reached the end of webpage, and set the default nextpage_startId=Long.MaxValue, in javascript the big number have to write as String ("\'" + nextpage_startId + "\'")\n\n\n#### The Page-Text and the Text-Index -Process flow\n\nWhen Insert\n\n1.insert page --> 2.insert index\n````java\nDB.Insert ("Page", page);\nEngine.IndexTextX( IsRemove = false );\n...IndexTextX...\n````\n\n\nWhen Delete\n\n1.delete index --> 2.delete page\n````java\nEngine.IndexTextX( IsRemove = true );\n...IndexTextX...\nDB.Delete("Page", page.Id);\n````\n\n#### Memory\n````java\nindexTextWithTran(IBox, id, String, boolean) // faster, more memories\n\nindexTextNoTran(AutoBox, commitCount, id, String, boolean) //less memory, not recommended.\n````\n\nHow to set big cache\n```java\n//-Xmx8G\nDatabaseConfig dbcfg = db.getConfig().DBConfig; \ndbcfg.CacheLength = dbcfg.mb(2048);\n//Or\ndbcfg.CacheLength = 2048L * 1024L * 1024L;\n\n//Wrong, overflow\n//dbcfg.CacheLength = 2048 * 1024 * 1024;\n```\n\n\n#### Private Server\nOpen \n```java\npublic Page Html.get(String url);\n```\nSet your private WebSite text\n```java\nPage page = new Page();\npage.url = url;\npage.title = "..."\npage.description = "..."\npage.content = "..."\nreturn page;\n```\n\n#### More\n[C# ASP.NET Core Version](https://github.com/iboxdb/ftserver-cs)\n\n\n\n'