b'![](http://media.charlesleifer.com/blog/photos/unqlite-python-logo.png)\n\nFast Python bindings for [UnQLite](http://unqlite.org/), a lightweight, embedded NoSQL database and JSON document store.\n\n### Please note\n\n**Read the issue tracker for [this database](https://github.com/symisc/unqlite/issues/)**\nbefore considering using it.\n\n### Features\n\nUnQLite features:\n\n* Embedded, zero-conf database\n* Transactional (ACID)\n* Single file or in-memory database\n* Key/value store\n* Cursor support and linear record traversal\n* JSON document store\n* Thread-safe\n* Terabyte-sized databases\n\nUnQLite-Python features:\n\n* Compiled library, extremely fast with minimal overhead.\n* Supports key/value operations, cursors, and transactions using Pythonic APIs.\n* Support for Jx9 scripting.\n* APIs for working with Jx9 JSON document collections.\n* Supports both Python 2 and Python 3.\n\nThe previous version (0.2.0) of `unqlite-python` utilized `ctypes` to wrap the UnQLite C library. By switching to Cython, key/value, cursor and Jx9 collection operations are an order of magnitude faster. In particular, filtering collections using user-defined Python functions is now *much*, *much* more performant.\n\nLinks:\n\n* [unqlite-python documentation](https://unqlite-python.readthedocs.io/)\n* [UnQLite\'s C API](http://unqlite.symisc.net/c_api.html)\n\nIf you like UnQLite, you might also want to check out [Vedis](http://vedis.symisc.net), an embedded key/value database modeled after Redis (python bindings: [vedis-python](https://vedis-python.readthedocs.io)).\n\n## Installation\n\nYou can install unqlite using `pip`.\n\n    pip install unqlite\n\n## Basic usage\n\nBelow is a sample interactive console session designed to show some of the basic features and functionality of the unqlite-python library. Also check out the [full API documentation](https://unqlite-python.readthedocs.io/en/latest/api.html).\n\nTo begin, instantiate an ``UnQLite`` object. You can specify either the path to a database file, or use UnQLite as an in-memory database.\n\n```pycon\n>>> from unqlite import UnQLite\n>>> db = UnQLite()  # Create an in-memory database.\n```\n\n### Key/value features\n\nUnQLite can be used as a key/value store.\n\n```pycon\n>>> db[\'foo\'] = \'bar\'  # Use as a key/value store.\n>>> print db[\'foo\']\nbar\n\n>>> for i in range(4):\n...     db[\'k%s\' % i] = str(i)\n...\n\n>>> \'k3\' in db\nTrue\n>>> \'k4\' in db\nFalse\n>>> del db[\'k3\']\n\n>>> db.append(\'k2\', \'XXXX\')\n>>> db[\'k2\']\n\'2XXXX\'\n```\n\nThe database can also be iterated through directly:\n\n```pycon\n>>> [item for item in db]\n[(\'foo\', \'bar\'), (\'k0\', \'0\'), (\'k1\', \'1\'), (\'k2\', \'2XXXX\')]\n```\n\n### Cursors\n\nFor finer-grained record traversal, you can use cursors.\n\n```pycon\n>>> with db.cursor() as cursor:\n...     cursor.seek(\'k0\')\n...     for key, value in cursor:\n...         print key, \'=>\', value\n...\nk0 => 0\nk1 => 1\nk2 => 2XXXX\n\n>>> with db.cursor() as cursor:\n...     cursor.seek(\'k2\')\n...     print cursor.value()\n...\n2\n\n>>> with db.cursor() as cursor:\n...     cursor.seek(\'k0\')\n...     print list(cursor.fetch_until(\'k2\', include_stop_key=False))\n...\n[(\'k0\', \'0\'), (\'k1\', \'1\')]\n```\n\nThere are many different ways of interacting with cursors, which are described in the [Cursor API documentation](https://unqlite-python.readthedocs.io/en/latest/api.html#Cursor).\n\n### Document store features\n\nIn my opinion the most interesting feature of UnQLite is its JSON document store. The [Jx9 scripting language](http://unqlite.org/jx9.html) is used to interact with the document store, and it is a wacky mix of PHP and maybe JavaScript (?).\n\nInteracting with the document store basically consists of creating a Jx9 script (you might think of it as an imperative SQL query), compiling it, and then executing it.\n\n```pycon\n>>> script = """\n...     db_create(\'users\');\n...     db_store(\'users\', $list_of_users);\n...     $users_from_db = db_fetch_all(\'users\');\n... """\n\n>>> list_of_users = [\n...     {\'username\': \'Huey\', \'age\': 3},\n...     {\'username\': \'Mickey\', \'age\': 5}\n... ]\n\n>>> with db.vm(script) as vm:\n...     vm[\'list_of_users\'] = list_of_users\n...     vm.execute()\n...     users_from_db = vm[\'users_from_db\']\n...\nTrue\n\n>>> users_from_db  # UnQLite assigns items in a collection an ID.\n[{\'username\': \'Huey\', \'age\': 3, \'__id\': 0},\n {\'username\': \'Mickey\', \'age\': 5, \'__id\': 1}]\n```\n\nThis is just a taste of what is possible with Jx9. In the near future I may add some wrappers around common Jx9 collection operations, but for now hopefully it is not too difficult to work with.\n\nMore information can be found in the [VM API documentation](https://unqlite-python.readthedocs.io/en/latest/api.html#VM).\n\n### Collections\n\nTo simplify working with JSON document collections, `unqlite-python` provides a light API for\nexecuting Jx9 queries on collections. A collection is an ordered list of JSON objects\n(records). Records can be appended or deleted, and in the next major release of UnQLite there will\nbe support for updates as well.\n\nTo begin working with collections, you can use the factory method on ``UnQLite``:\n\n```pycon\n>>> users = db.collection(\'users\')\n>>> users.create()  # Create the collection if it does not exist.\n>>> users.exists()\nTrue\n```\n\nYou can use the ``store()`` method to add one or many records. To add a single record just pass in a python ``dict``. To add multiple records, pass in a list of dicts. Records can be fetched and deleted by ID.\n\n```pycon\n>>> users.store([\n...     {\'name\': \'Charlie\', \'color\': \'green\'},\n...     {\'name\': \'Huey\', \'color\': \'white\'},\n...     {\'name\': \'Mickey\', \'color\': \'black\'}])\nTrue\n>>> users.store({\'name\': \'Leslie\', \'color\': \'also green\'})\nTrue\n\n>>> users.fetch(0)  # Fetch the first record.\n{\'__id\': 0, \'color\': \'green\', \'name\': \'Charlie\'}\n\n>>> users.delete(0)  # Delete the first record.\nTrue\n>>> users.delete(users.last_record_id())  # Delete the last record.\nTrue\n```\n\nYou can retrieve all records in the collection, or specify a filtering function. The filtering function will be registered as a foreign function with the Jx9 VM and called *from* the VM.\n\n```pycon\n>>> users.all()\n[{\'__id\': 1, \'color\': \'white\', \'name\': \'Huey\'},\n {\'__id\': 2, \'color\': \'black\', \'name\': \'Mickey\'}]\n\n>>> users.filter(lambda obj: obj[\'name\'].startswith(\'H\'))\n[{\'__id\': 1, \'color\': \'white\', \'name\': \'Huey\'}]\n```\n\n### Transactions\n\nUnQLite supports transactions for file-backed databases (since transactions occur at the filesystem level, they have no effect on in-memory databases).\n\nThe easiest way to create a transaction is with the context manager:\n\n```pycon\n>>> db = UnQLite(\'/tmp/test.db\')\n>>> with db.transaction():\n...     db[\'k1\'] = \'v1\'\n...     db[\'k2\'] = \'v2\'\n...\n>>> db[\'k1\']\n\'v1\'\n```\n\nYou can also use the transaction decorator which will wrap a function call in a transaction and commit upon successful execution (rolling back if an exception occurs).\n\n```pycon\n>>> @db.commit_on_success\n... def save_value(key, value, exc=False):\n...     db[key] = value\n...     if exc:\n...         raise Exception(\'uh-oh\')\n...\n>>> save_value(\'k3\', \'v3\')\n>>> save_value(\'k3\', \'vx\', True)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\n  File "unqlite/core.py", line 312, in wrapper\n    return fn(*args, **kwargs)\n  File "<stdin>", line 5, in save_value\nException: uh-oh\n>>> db[\'k3\']\n\'v3\'\n```\n\nFor finer-grained control you can call `db.begin()`, `db.rollback()` and `db.commit()` manually:\n\n```pycon\n>>> db.begin()\n>>> db[\'k3\'] = \'v3-xx\'\n>>> db.commit()\nTrue\n>>> db[\'k3\']\n\'v3-xx\'\n```\n\n-------------------------------------------\n\nThis code is based in part on [buaabyl\'s pyUnQLite](https://github.com/buaabyl/pyUnQLite/).\n'