b'# nuster\n\n[Wiki](https://github.com/jiangwenyuan/nuster/wiki) | [English](README.md) | [\xe4\xb8\xad\xe6\x96\x87](README-CN.md) | [\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e](README-JP.md)\n\nA high-performance HTTP proxy cache server and RESTful NoSQL cache server based on HAProxy.\n\n# Table of Contents\n\n* [Introduction](#introduction)\n* [Performance](#performance)\n* [Getting Started](#getting-started)\n* [Usage](#usage)\n* [Directives](#directives)\n* [Cache](#cache)\n  * [Management](#cache-management)\n  * [Enable/Disable](#cache-rule-enable-and-disable)\n  * [TTL](#cache-ttl)\n  * [Purging](#cache-purging)\n  * [Stats](#cache-stats)\n* [NoSQL](#nosql)\n  * [Set](#set)\n  * [Get](#get)\n  * [Delete](#delete)\n* [Disk persistence](#disk-persistence)\n* [Sample fetches](#sample-fetches)\n* [FAQ](#faq)\n\n# Introduction\n\nnuster is a high-performance HTTP proxy cache server and RESTful NoSQL cache server based on HAProxy.\nIt is 100% compatible with HAProxy and takes full advantage of the ACL functionality of HAProxy to provide fine-grained caching policy based on the content of request, response or server status.\n\n## Features\n\n### As HTTP/TCP loader balancer\n\nnuster can be used as an HTTP/TCP load balancer just like HAProxy.\n\n* All features of HAProxy are inherited, 100% compatible with HAProxy\n* Load balancing\n* HTTPS supports on both frontend and backend\n* HTTP compression\n* HTTP rewriting and redirection\n* HTTP fixing\n* HTTP2\n* Monitoring\n* Stickiness\n* ACLs and conditions\n* Content switching\n\n### As HTTP cache server\n\nnuster can also be used as an HTTP proxy cache server like Varnish or Nginx to cache dynamic and static HTTP response.\n\n* All features from HAProxy(HTTPS, HTTP/2, ACL, etc)\n* Extremely fast\n* Powerful dynamic cache ability\n  * Based on HTTP method, URI, path, query, header, cookies, etc\n  * Based on HTTP request or response contents, etc\n  * Based on environment variables, server state, etc\n  * Based on SSL version, SNI, etc\n  * Based on connection rate, number, byte, etc\n* Cache management\n* Cache purging\n* Cache stats\n* Cache TTL\n* Disk persistence\n\n### As RESTful NoSQL cache server\n\nnuster can also be used as a RESTful NoSQL cache server, using HTTP `POST/GET/DELETE` to set/get/delete Key/Value object.\n\nIt can be used as an internal NoSQL cache sits between your application and database like Memcached or Redis as well as a user-facing NoSQL cache that sits between end-user and your application.\nIt supports headers, cookies, so you can store per-user data to the same endpoint.\n\n* All features from HAProxy(HTTPS, HTTP/2, ACL, etc)\n* Conditional cache\n* Internal KV cache\n* User facing RESTful cache\n* Support any kind of data\n* Support all programming languages as long as HTTP is supported\n* Disk persistence\n\n# Performance\n\nnuster is very fast, some test shows nuster is almost three times faster than nginx when both using single core, and nearly two times faster than nginx and three times faster than varnish when using all cores.\n\nSee [detailed benchmark](https://github.com/jiangwenyuan/nuster/wiki/Web-cache-server-performance-benchmark:-nuster-vs-nginx-vs-varnish-vs-squid)\n\n# Getting Started\n\n## Download\n\nDownload stable version from [Download](Download.md) page for production use, otherwise git clone the source code.\n\n## Build\n\n```\nmake TARGET=linux2628 USE_LUA=1 LUA_INC=/usr/include/lua5.3 USE_OPENSSL=1 USE_PCRE=1 USE_ZLIB=1\nmake install PREFIX=/usr/local/nuster\n```\n\n> use `USE_PTHREAD_PSHARED=1` to use pthread lib\n\n> omit `USE_LUA=1 LUA_INC=/usr/include/lua5.3 USE_OPENSSL=1 USE_PCRE=1 USE_ZLIB=1` if unnecessary\n\nSee [HAProxy README](README) for details.\n\n## Create a config file\n\nA minimal config file: `nuster.cfg`\n\n```\nglobal\n    nuster cache on data-size 100m uri /_nuster\n    nuster nosql on data-size 200m\n    master-worker # since v3\ndefaults\n    mode http\nfrontend fe\n    bind *:8080\n    #bind *:4433 ssl crt example.com.pem alpn h2,http/1.1\n    use_backend be2 if { path_beg /_kv/ }\n    default_backend be1\nbackend be1\n    nuster cache on\n    nuster rule img ttl 1d if { path_beg /img/ }\n    nuster rule api ttl 30s if { path /api/some/api }\n    server s1 127.0.0.1:8081\n    server s2 127.0.0.1:8082\nbackend be2\n    nuster nosql on\n    nuster rule r1 ttl 3600\n```\n\nnuster listens on port 8080 and accepts HTTP requests.\nRequests start with `/_kv/` go to backend `be2`, you can make `POST/GET/DELETE` requests to `/_kv/any_key` to `set/get/delete` K/V object.\nOther requests go to backend `be1`, and will be passed to servers `s1` or `s2`. Among those requests, `/img/*` will be cached for 1 day and `/api/some/api` will be cached for 30 seconds.\n\n## Start\n\n`/usr/local/nuster/sbin/nuster -f nuster.cfg`\n\n## Docker\n\n```\ndocker pull nuster/nuster\ndocker run -d -v /path/to/nuster.cfg:/etc/nuster/nuster.cfg:ro -p 8080:8080 nuster/nuster\n```\n\n# Usage\n\nnuster is based on HAProxy, all directives from HAProxy are supported in nuster.\n\n## Basic\n\nThere are four basic `section`s: `global`, `defaults`, `frontend` and `backend` as you can find out in the above config file.\n\n* global\n  * defines process-wide and often OS-specific parameters\n  * `nuster cache on` or `nuster nosql on` must be declared in this section in order to use cache or nosql functionality\n* defaults\n  * defines default parameters for all other `frontend`, `backend` sections\n  * and can be overwritten in specific `frontend` or `backend` section\n* frontend\n  * describes a set of listening sockets accepting client connections\n* backend\n  * describes a set of servers to which the proxy will connect to forward incoming connections\n  * `nuster cache on` or `nuster nosql on` must be declared in this section\n  * `nuster rule` must be declared here\n\nYou can define multiple `frontend` or `backend` sections. If `nuster cache|nosql off` is declared or no `nuster cache|nosql on|off` declared, nuster acts just like HAProxy, as a TCP and HTTP load balancer.\n\nAlthough `listen` is a complete proxy with its frontend and backend parts combined in one section, you cannot use nuster in `listen`, use `frontend` and `backend` pairs.\n\nYou can find HAProxy documentation in `/doc`, and [Online HAProxy Documentation](https://cbonte.github.io/haproxy-dconv/)\n\n## As TCP loader balancer\n\n```\nfrontend mysql-lb\n   bind *:3306\n   mode tcp\n   default_backend mysql-cluster\nbackend mysql-cluster\n   balance roundrobin\n   mode tcp\n   server s1 10.0.0.101:3306\n   server s2 10.0.0.102:3306\n   server s3 10.0.0.103:3306\n```\n\n## As HTTP/HTTPS loader balancer\n\n```\nfrontend web-lb\n   bind *:80\n   #bind *:443 ssl crt XXX.pem\n   mode http\n   default_backend apps\nbackend apps\n   balance roundrobin\n   mode http\n   server s1 10.0.0.101:8080\n   server s2 10.0.0.102:8080\n   server s3 10.0.0.103:8080\n   #server s4 10.0.0.101:8443 ssl verify none\n```\n\n## As HTTP cache server\n\n```\nglobal\n    nuster cache on data-size 200m\nfrontend fe\n    bind *:8080\n    default_backend be\nbackend be\n    nuster cache on\n    nuster rule all\n    server s1 127.0.0.1:8081\n```\n\n## As RESTful NoSQL cache server\n\n```\nglobal\n    nuster nosql on data-size 200m\nfrontend fe\n    bind *:8080\n    default_backend be\nbackend be\n    nuster nosql on\n    nuster rule r1 ttl 3600\n```\n\n# Directives\n\n## global: nuster cache|nosql\n\n**syntax:**\n\nnuster cache on|off [data-size size] [dict-size size] [dir DIR] [dict-cleaner n] [data-cleaner n] [disk-cleaner n] [disk-loader n] [disk-saver n] [purge-method method] [uri uri]\n\nnuster nosql on|off [data-size size] [dict-size size] [dir DIR] [dict-cleaner n] [data-cleaner n] [disk-cleaner n] [disk-loader n] [disk-saver n]\n\n**default:** *none*\n\n**context:** *global*\n\nDetermines whether to use cache/nosql or not.\n\nA memory zone with a size of `data-size + dict-size` will be created.\n\nExcept for temporary data created and destroyed within a request, all cache related data including HTTP response data, keys and overheads are stored in this memory zone and shared between all processes.\nIf no more memory can be allocated from this memory zone, new requests that should be cached according to defined rules will not be cached unless some memory is freed.\nTemporary data are stored in a memory pool which allocates memory dynamically from system in case there is no available memory in the pool.\nA global internal counter monitors the memory usage of all HTTP response data across all processes, new requests will not be cached if the counter exceeds `data-size`.\n\n### data-size\n\nDetermines the size of the memory zone along with `dict-size`.\n\nIt accepts units like `m`, `M`, `g` and `G`. By default, the size is 1024 * 1024 bytes, which is also the minimal size.\n\n### dict-size\n\nDetermines the size of memory used by the hash table.\n\nIt accepts units like `m`, `M`, `g` and `G`. By default, the size is 1024 * 1024 bytes, which is also the minimal size.\n\nNote that it only decides the memory used by hash table buckets, not keys. In fact, keys are stored in the memory zone which is limited by `data-size`.\n\n**dict-size(number of buckets)** is different from **number of keys**. New keys can still be added to the hash table even if the number of keys exceeds dict-size(number of buckets) as long as there is enough memory.\n\nNevertheless, it may lead to a potential performance drop if `number of keys` is greater than `dict-size(number of buckets)`. An approximate number of keys multiplied by 8 (normally) as `dict-size` should be fine.\n\n> dict-size will be removed in a future release, automatically resizing the hash table in the first version will be added back.\n\n### dir\n\nSpecify the root directory of the disk persistence. This has to be set in order to use disk persistence.\n\n### dict-cleaner\n\nPrior to v2.x, manager tasks like removing invalid cache data, resetting dict entries are executed in iterations in each HTTP request. Corresponding indicators or pointers are increased or advanced in each iteration.\n\nIn v3.x these tasks are moved to the master process and also done in iterations, and these parameters can be set to control the number of times of certain task during one iteration.\n\nDuring one iteration `dict-cleaner` entries are checked, invalid entries will be deleted (by default, 100).\n\n### data-cleaner\n\nDuring one iteration `data-cleaner` data are checked, invalid data will be deleted (by default, 100).\n\n### disk-cleaner\n\nIf disk persistence is enabled, data are stored in files. These files are checked by master process and will be deleted if invalid, for example, expired.\n\nDuring one iteration `disk-cleaner` files are checked, invalid files will be deleted (by default, 100).\n\n### disk-loader\n\nAfter the start of nuster, master process will load information about data previously stored on disk into memory.\n\nDuring one iteration `disk-loader` files are loaded(by default, 100).\n\n### disk-saver\n\nMaster process will save `disk async` cache data periodically.\n\nDuring one iteration `disk-saver` data are checked and saved to disk if necessary (by default, 100).\n\nSee [nuster rule disk mode](#disk-mode) for details.\n\n### purge-method [cache only]\n\nDefine a customized HTTP method with a max length of 14 to purge cache, it is `PURGE` by default.\n\n### uri [cache only]\n\nEnable cache manager/stats API and define the endpoint:\n\n`nuster cache on uri /_my/_unique/_/_cache/_uri`\n\nBy default, the cache manager/stats are disabled. When it is enabled, remember to restrict the access(see [FAQ](#how-to-restrict-access)).\n\nSee [Cache Management](#cache-management) and [Cache stats](#cache-stats) for details.\n\n## proxy: nuster cache|nosql\n\n**syntax:**\n\nnuster cache [on|off]\n\nnuster nosql [on|off]\n\n**default:** *on*\n\n**context:** *backend*\n\nDetermines whether or not to use cache/nosql on this proxy, additional `nuster rule` should be defined.\nIf there are filters on this proxy, put this directive after all other filters.\n\n## nuster rule\n\n**syntax:** nuster rule name [key KEY] [ttl TTL] [code CODE] [disk MODE] [if|unless condition]\n\n**default:** *none*\n\n**context:** *backend*\n\nDefine rule to specify cache/nosql creating conditions, properties. At least one rule should be defined.\n\n```\nnuster cache on\n\n# cache request `/asdf` for 30 seconds\nnuster rule asdf ttl 30 if { path /asdf }\n\n# cache if the request path begins with /img/\nnuster rule img if { path_beg /img/ }\n\n# cache if the response header `cache` is `yes`\nacl resHdrCache res.hdr(cache) yes\nnuster rule r1 if resHdrCache\n```\n\nIt is possible and recommended to declare multiple rules in the same section. The order is important because the matching process stops on the first match.\n\n```\nacl pathA path /a.html\nnuster cache on\nnuster rule all ttl 3600\nnuster rule path01 ttl 60 if pathA\n```\n\nrule `path01` will never match because the first rule will cache everything.\n\n### name\n\nDefine a name for this rule.\n\nIt will be used in cache manager API, it does not have to be unique, but it might be a good idea to make it unique. Rules with the same name are treated as one.\n\n### key KEY\n\nDefine the key for cache/nosql, it takes a string combined by following keywords with `.` separator:\n\n * method:       http method, GET/POST...\n * scheme:       http or https\n * host:         the host in the request\n * uri:          first slash to end of the url\n * path:         the URL path of the request\n * delimiter:    \'?\' if query exists otherwise empty\n * query:        the whole query string of the request\n * header\\_NAME: the value of header `NAME`\n * cookie\\_NAME: the value of cookie `NAME`\n * param\\_NAME:  the value of query `NAME`\n * body:         the body of the request\n\nThe default key of CACHE is `method.scheme.host.uri`, and default key of NoSQL is `GET.scheme.host.uri`.\n\nExample\n\n```\nGET http://www.example.com/q?name=X&type=Y\n\nhttp header:\nGET /q?name=X&type=Y HTTP/1.1\nHost: www.example.com\nASDF: Z\nCookie: logged_in=yes; user=nuster;\n```\n\nShould result:\n\n * method:       GET\n * scheme:       http\n * host:         www.example.com\n * uri:          /q?name=X&type=Y\n * path:         /q\n * delimiter:    ?\n * query:        name=X&type=Y\n * header\\_ASDF: Z\n * cookie\\_user: nuster\n * param\\_type:  Y\n * body:         (empty)\n\nSo default key produces `GET\\0http\\0www.example.com\\0/q?name=X&type=Y\\0`, and `key method.scheme.host.path.header_ASDF.cookie_user.param_type` produces `GET\\0http\\0www.example.com\\0/q\\0Z\\0nuster\\0Y\\0`.\n\n> `\\0` is NULL character\n\nIf a request has the same key as a cached HTTP response data, then cached data will be sent to the client.\n\n### ttl TTL\n\nSet a TTL on key, after the TTL has expired, the key will be deleted.\n\nIt accepts units like `d`, `h`, `m` and `s`. Default ttl is `0` which does not expire the key.\n\n### code CODE1,CODE2...\n\nCache only if the response status code is CODE.\n\nBy default, only 200 response is cached. You can use `all` to cache all responses.\n\n```\nnuster rule only200\nnuster rule 200and404 code 200,404\nnuster rule all code all\n```\n\n### disk MODE\n\nSpecify how and where to save the cached data. There are four MODEs.\n\n* off:   default, disable disk persistence, data are stored in memory only\n* only:  save data to disk only, do not store in memory\n* sync:  save data to memory and disk(kernel), then return to the client\n* async: save data to memory and return to the client, cached data will be saved to disk later by the master process\n\n### if|unless condition\n\nDefine when to cache using HAProxy ACL.\n\nThe evaluation involves two stages: request stage and response stage.\n\nCache will be performed if:\n\n1. The evaluation in the request stage is true,\n2. The evaluation in the request stage is false but true in the response stage.\n\n**Please be very careful if you use negation in the condition or samples not available in certain stage**\n\nFor example,\n\n1.  Cache if the request path begins with `/img/`\n\n    nuster rule img if { path_beg /img/ }\n\nThis will work because the evaluation in the request stage will either be true or false and will never be true in the response stage as `path` is not available in the response stage.\n\n2. Cache if `Content-Type` in response is `image/jpeg`\n\n    nuster rule jpeg if { res.hdr(Content-Type) image/jpeg }\n\nThis will work because the evaluation in the request stage is always false as `res.hdr` is not available in the request stage, and will be either true or false in the response stage.\n\n3. Cache if the request path begins with `/img/` and `Content-Type` in response is `image/jpeg`\n\nIt won\'t work if you define the rule as:\n\n    nuster rule img if { path_beg /img/ } { res.hdr(Content-Type) image/jpeg }\n\nbecause `path` is not available in the response stage and `res.hdr` is not available in the request stage, so the evaluation will never be true.\n\nIn order the make this work, `path` needs to be allocated for further use in reponse stage:\n\n    http-request set-var(txn.pathImg) path\n    acl pathImg var(txn.pathImg) -m beg /img/\n    acl resHdrCT res.hdr(Content-Type) image/jpeg\n    nuster rule r3 if pathImg resHdrCT\n\n4. Another example, cache if the request path does not begin with `/api/`\n\nIt won\'t work neither:\n\n    acl NoCache path_beg /api/\n    nuster rule r3 if !NoCache\n\nBecause the evaluation of `NoCache` against `/api/` in the request stage is true, and the negation is false, which is the desired state, but in response stage, the evaluation of `NoCache` is always false as `path` is not available in response stage, and it will be cached as the negation `!NoCache` is true.\n\nThis will work:\n\n    http-request set-var(txn.path) path\n    acl NoCache var(txn.path) -m beg /api/\n    nuster rule r1 if !NoCache\n\nI will add several new sample fetch methods to simplify this kind of tasks in future versions.\n\nSee **7. Using ACLs and fetching samples** section in [HAProxy configuration](doc/configuration.txt)\n\n# Cache\n\nnuster can be used as an HTTP proxy cache server like Varnish or Nginx to cache dynamic and static HTTP response.\n\nYou can use HAProxy functionalities to terminate SSL, normalize HTTP, support HTTP2, rewrite the URL or modify headers and so on, and additional functionalities provided by nuster to control cache.\n\n## Cache Management\n\nCache can be managed via a manager API which endpoints is defined by `uri` and can be accessed by making HTTP requests along with some headers.\n\n**Enable and define the endpoint**\n\n```\nnuster cache on uri /nuster/cache\n```\n\n**Basic usage**\n\n`curl -X POST -H "X: Y" http://127.0.0.1/nuster/cache`\n\n**REMEMBER to enable access restriction**\n\n## Cache rule enable and disable\n\nRule can be disabled at run time through manager uri. Disabled rule will not be processed, nor will the cache created by that.\n\n***headers***\n\n| header | value       | description\n| ------ | -----       | -----------\n| state  | enable      | enable  rule\n|        | disable     | disable rule\n| name   | rule NAME   | the rule to be enabled/disabled\n|        | proxy NAME  | all rules belong to proxy NAME\n|        | *           | all rules\n\nKeep in mind that if name is not unique, **all** rules with that name will be disabled/enabled.\n\n***Examples***\n\n* Disable cache rule r1\n\n  `curl -X POST -H "name: r1" -H "state: disable" http://127.0.0.1/nuster/cache`\n\n* Disable all cache rule defined in proxy app1b\n\n  `curl -X POST -H "name: app1b" -H "state: disable" http://127.0.0.1/nuster/cache`\n\n* Enable all cache rule\n\n  `curl -X POST -H "name: *" -H "state: enable" http://127.0.0.1/nuster/cache`\n\n## Cache TTL\n\nChange the TTL. It only affects the TTL of the responses to be cached, **does not** update the TTL of existing caches.\n\n***headers***\n\n| header | value      | description\n| ------ | -----      | -----------\n| ttl    | new TTL    | see `ttl` in `nuster rule`\n| name   | rule NAME  | the cache rule to be changed\n|        | proxy NAME | all cache rules belong to proxy NAME\n|        | *          | all cache rules\n\n***Examples***\n\n```\ncurl -X POST -H "name: r1" -H "ttl: 0" http://127.0.0.1/nuster/cache\ncurl -X POST -H "name: r2" -H "ttl: 2h" http://127.0.0.1/nuster/cache\n```\n\n## Update state and TTL\n\nstate and ttl can be updated at the same time\n\n```\ncurl -X POST -H "name: r1" -H "ttl: 0" -H "state: enabled" http://127.0.0.1/nuster/cache\n```\n\n## Cache Purging\n\nThere are several ways to purge cache by making HTTP `PURGE` requests to the manager uri defined by `uri`.\n\nYou can define customized HTTP method using `purge-method MYPURGE` other than the default `PURGE` in case you need to forward `PURGE` to backend servers.\n\n### Purge one specific url\n\nThis method deletes the specific url that is being requested, like this:\n\n`curl -XPURGE https://127.0.0.1/imgs/test.jpg`\n\nIt creates a key of `GET.scheme.host.uri` and deletes the cache with that key.\n\nNote by default cache key contains `Host` if you cache a request like `http://example.com/test` and purge from localhost you need to specify `Host` header:\n\n`curl -XPURGE -H "Host: example.com" http://127.0.0.1/test`\n\n\n### Purge by name\n\nCache can be purged by making HTTP `PURGE`(or `purge-method`) requests to the manager uri along with a `name` HEADER.\n\n***headers***\n\n| header | value            | description\n| ------ | -----            | -----------\n| name   | nuster rule NAME | caches belong to rule ${NAME} will be purged\n|        | proxy NAME       | caches belong to proxy ${NAME}\n|        | *                | all caches\n\n***Examples***\n\n```\n# purge all caches\ncurl -X PURGE -H "name: *" http://127.0.0.1/nuster/cache\n# purge all caches belong to proxy applb\ncurl -X PURGE -H "name: app1b" http://127.0.0.1/nuster/cache\n# purge all caches belong to rule r1\ncurl -X PURGE -H "name: r1" http://127.0.0.1/nuster/cache\n```\n\n### Purge by host\n\nYou can also purge cache by host, all caches belong to that host will be deleted:\n\n***headers***\n\n| header | value | description\n| ------ | ----- | -----------\n| x-host | HOST  | the ${HOST}\n\n***Examples***\n\n```\ncurl -X PURGE -H "x-host: 127.0.0.1:8080" http://127.0.0.1/nuster/cache\n```\n\n### Purge by path\n\nBy default, the query part is also used as a cache key, so there will be multiple caches if the query differs.\n\nFor example, for cache rule `nuster rule imgs if { path_beg /imgs/ }`, and request\n\n```\ncurl https://127.0.0.1/imgs/test.jpg?w=120&h=120\ncurl https://127.0.0.1/imgs/test.jpg?w=180&h=180\n```\n\nThere will be two cache objects since the default key contains the query part.\n\nIn order to delete that, you can\n\n***delete one by one in case you know all queries***\n\n```\ncurl -XPURGE https://127.0.0.1/imgs/test.jpg?w=120&h=120\ncurl -XPURGE https://127.0.0.1/imgs/test.jpg?w=180&h=180\n```\n\nIt does not work if you don\'t know all queries.\n\n***use a customized key and delete once in case that the query part is irrelevant***\n\nDefine a key like `nuster rule imgs key method.scheme.host.path if { path_beg /imgs }`, in this way only one cache will be created, and you can purge without query:\n\n`curl -XPURGE https://127.0.0.1/imgs/test.jpg`\n\nIt does not work if the query part is required.\n\n***delete by rule NAME***\n\n`curl -X PURGE -H "name: imgs" http://127.0.0.1/nuster/cache`\n\nIt does not work if the nuster rule is defined something like `nuster rule static if { path_beg /imgs/ /css/ }`.\n\nThis method provides a way to purge just by path:\n\n***headers***\n\n| header | value | description\n| ------ | ----- | -----------\n| path   | PATH  | caches with ${PATH} will be purged\n| x-host | HOST  | and host is ${HOST}\n\n***Examples***\n\n```\n#delete all caches which path is /imgs/test.jpg\ncurl -X PURGE -H "path: /imgs/test.jpg" http://127.0.0.1/nuster/cache\n#delete all caches which path is /imgs/test.jpg and belongs to 127.0.0.1:8080\ncurl -X PURGE -H "path: /imgs/test.jpg" -H "x-host: 127.0.0.1:8080" http://127.0.0.1/nuster/cache\n```\n\n### Purge by regex\n\nYou can also purge cache by regex, the caches which path match the regex will be deleted.\n\n***headers***\n\n| header | value | description\n| ------ | ----- | -----------\n| regex  | REGEX | caches which path match with ${REGEX} will be purged\n| x-host | HOST  | and host is ${HOST}\n\n***Examples***\n\n```\n#delete all caches which path starts with /imgs and ends with .jpg\ncurl -X PURGE -H "regex: ^/imgs/.*\\.jpg$" http://127.0.0.1/nuster/cache\n#delete all caches which path starts with /imgs and ends with .jpg and belongs to 127.0.0.1:8080\ncurl -X PURGE -H "regex: ^/imgs/.*\\.jpg$" -H "127.0.0.1:8080" http://127.0.0.1/nuster/cache\n```\n\n**PURGE CAUTION**\n\n1. **ENABLE ACCESS RESTRICTION**\n\n2. If there are mixed headers, use the precedence of `name`, `path & host`, `path`, `regex & host`, `regex`, `host`\n\n   `curl -XPURGE -H "name: rule1" -H "path: /imgs/a.jpg"`: purge by name\n\n3. If there are redundant headers, use the first occurrence\n\n   `curl -XPURGE -H "name: rule1" -H "name: rule2"`: purge by `rule1`\n\n4. `regex` is **NOT glob**\n\n   For example, all jpg files under /imgs should be `^/imgs/.*\\.jpg$` instead of `/imgs/*.jpg`\n\n5. Purging cache files by rule name or proxy name only works in current session. If nuster restarts, then cache files cannot be purged by rule name or proxy name as information like rule name and proxy name is not persisted in the cache fiels.\n\n6. Purging cache files by host or path or regex only works after the disk loader process is finished. You can check the status through stats url.\n\n## Cache Stats\n\nCache stats can be accessed by making HTTP GET request to the endpoint defined by `uri`;\n\n### Enable and define the endpoint\n\n```\nnuster cache on uri /nuster/cache\n```\n\n### Usage\n\n`curl http://127.0.0.1/nuster/cache`\n\n### Output\n\n* used\\_mem:  The memory used for response, not include overheads.\n* req\\_total: Total request number handled by cache enabled backends, not include the requests handled by backends without cache enabled\n* req\\_hit:   Number of requests handled by cache\n* req\\_fetch: Fetched from backends\n* req\\_abort: Aborted when fetching from backends\n\nOthers are very straightforward.\n\n# NoSQL\n\nnuster can be used as a RESTful NoSQL cache server, using HTTP `POST/GET/DELETE` to set/get/delete Key/Value object.\n\n## Basic Operations\n\n### Set\n\n```\ncurl -v -X POST -d value1 http://127.0.0.1:8080/key1\ncurl -v -X POST --data-binary @icon.jpg http://127.0.0.1:8080/imgs/icon.jpg\n```\n\n### Get\n\n`curl -v http://127.0.0.1:8080/key1`\n\n### Delete\n\n`curl -v -X DELETE http://127.0.0.1:8080/key1`\n\n## Response\n\nCheck status code.\n\n* 200 OK\n  * POST/GET: succeeds\n  * DELETE: always\n* 400 Bad request\n  * empty value\n  * incorrect acl, rules, etc\n* 404 Not Found\n  * POST: failed on all rule tests\n  * GET: not found\n* 405 Method Not Allowed\n  * other methods\n* 500 Internal Server Error\n  * any error occurs\n* 507 Insufficient Storage\n  * exceeds max data-size\n\n## Per-user data\n\nBy using header or cookie in key, you can save per-user data to the same endpoint.\n\n```\nnuster rule r1 key method.scheme.host.uri.header_userId if { path /mypoint }\nnuster rule r2 key method.scheme.host.uri.cookie_sessionId if { path /mydata }\n```\n\n### Set\n\n\n```\ncurl -v -X POST -d "333" -H "userId: 1000" http://127.0.0.1:8080/mypoint\ncurl -v -X POST -d "555" -H "userId: 1001" http://127.0.0.1:8080/mypoint\n\ncurl -v -X POST -d "userA data" --cookie "sessionId=ijsf023xe" http://127.0.0.1:8080/mydata\ncurl -v -X POST -d "userB data" --cookie "sessionId=rosre329x" http://127.0.0.1:8080/mydata\n```\n\n### Get\n\n```\ncurl -v http://127.0.0.1:8080/mypoint\n< 404 Not Found\n\ncurl -v -H "userId: 1000" http://127.0.0.1:8080/mypoint\n< 200 OK\n333\n\ncurl -v --cookie "sessionId=ijsf023xe" http://127.0.0.1:8080/mydata\n< 200 OK\nuserA data\n```\n\n## Clients\n\nYou can use any tools or libs which support HTTP: `curl`, `postman`, python `requests`, go `net/http`, etc.\n\n# Disk persistence\n\nDisk persistence is introduced in v3, it supports 4 persistence modes as described above.\n\nA minimal config file looks like\n\n```\nglobal\n    master-worker\n    nuster cache on data-size 10m dir /tmp/cache\n    nuster nosql on data-size 10m dir /tmp/nosql\nbackend be\n    nuster cache on\n    nuster rule off   disk off   ttl 1m if { path_beg /disk-off }\n    nuster rule only  disk only  ttl 1d if { path_beg /disk-only }\n    nuster rule sync  disk sync  ttl 1h if { path_beg /disk-sync }\n    nuster rule async disk async ttl 2h if { path_beg /disk-async }\n    nuster rule others ttl 100\n```\n\n1. `/disk-off` will be cached only in memory\n2. `/disk-only` will be cached only in disk\n3. `/disk-sync` will be cached in memory and in disk, then return to the client\n4. `/disk-async` will be cached in memory and return to the client, cached data will be saved to disk later\n5. other requests will be cached only in memory\n\n# Sample fetches\n\nNuster introduced following sample fetches\n\n## nuster.cache.hit: boolean\n\nReturns a boolean indicating whether it\'s a HIT or not and can be used like\n\n    http-response set-header x-cache hit if { nuster.cache.hit }\n\n# FAQ\n\n## Cannot start: not in master-worker mode\n\nSet `master-worker` in `global` section, or start `nuster` with `-W`.\n\n## How to debug?\n\nSet `debug` in `global` section, or start `nuster` with `-d`.\n\nNuster related debug messages start with `[nuster`.\n\n## How to cache POST request?\n\nEnable `option http-buffer-request` and set `body` in cache rule `key`.\n\nBy default, the cache key does not include the body of the request, remember to put `body` in key field.\n\nNote that the size of the request body must be smaller than `tune.bufsize - tune.maxrewrite - request_header_size`, which by default is `16384 - 1024 - request_header_size`.\n\nRefer to **option http-buffer-request** and **tune.bufsize** section in [HAProxy configuration](doc/configuration.txt) for details.\n\nAlso, it might be a good idea to put it separately in a dedicated backend as the example does.\n\n## How to restrict access?\n\nYou can use the powerful HAProxy ACL, something like this\n\n```\nacl network_allowed src 127.0.0.1\nacl purge_method method PURGE\nhttp-request deny if purge_method !network_allowed\n```\n\n## How to enable HTTP2\n\n```\nbind :443 ssl crt pub.pem alpn h2,http/1.1\n```\n\n# Example\n\n```\nglobal\n    nuster cache on data-size 100m\n    nuster nosql on data-size 100m\n    master-worker # since v3\n    # daemon\n    # debug\ndefaults\n    retries 3\n    option redispatch\n    timeout client  30s\n    timeout connect 30s\n    timeout server  30s\nfrontend web1\n    bind *:8080\n    mode http\n    acl pathPost path /search\n    use_backend app1a if pathPost\n    default_backend app1b\nbackend app1a\n    balance roundrobin\n    # mode must be http\n    mode http\n\n    # http-buffer-request must be enabled to cache post request\n    option http-buffer-request\n\n    acl pathPost path /search\n\n    # enable cache for this proxy\n    nuster cache\n\n    # cache /search for 120 seconds. Only works when POST/PUT\n    nuster rule rpost key method.scheme.host.uri.body ttl 120 if pathPost\n\n    server s1 10.0.0.10:8080\nbackend app1b\n    balance     roundrobin\n    mode http\n\n    nuster cache on\n\n    # cache /a.jpg, not expire\n    acl pathA path /a.jpg\n    nuster rule r1 ttl 0 if pathA\n\n    # cache /mypage, key contains cookie[userId], so it will be cached per user\n    acl pathB path /mypage\n    nuster rule r2 key method.scheme.host.path.delimiter.query.cookie_userId ttl 60 if pathB\n\n    # cache /a.html if response\'s header[cache] is yes\n    http-request set-var(txn.pathC) path\n    acl pathC var(txn.pathC) -m str /a.html\n    acl resHdrCache1 res.hdr(cache) yes\n    nuster rule r3 if pathC resHdrCache1\n\n    # cache /heavy for 100 seconds if be_conn greater than 10\n    acl heavypage path /heavy\n    acl tooFast be_conn ge 100\n    nuster rule heavy ttl 100 if heavypage tooFast\n\n    # cache all if response\'s header[asdf] is fdsa\n    acl resHdrCache2 res.hdr(asdf)  fdsa\n    nuster rule resCache ttl 0 if resHdrCache1\n\n    server s1 10.0.0.10:8080\n\nfrontend web2\n    bind *:8081\n    mode http\n    default_backend app2\nbackend app2\n    balance     roundrobin\n    mode http\n\n    # disable cache on this proxy\n    nuster cache off\n    nuster rule all\n\n    server s2 10.0.0.11:8080\n\nfrontend nosql_fe\n    bind *:9090\n    default_backend nosql_be\nbackend nosql_be\n    nuster nosql on\n    nuster rule r1 ttl 3600\n```\n\n# Contributing\n\n* Join the development\n* Give feedback\n* Report issues\n* Send pull requests\n* Spread nuster\n\n# License\n\nCopyright (C) 2017-2019, [Jiang Wenyuan](https://github.com/jiangwenyuan), < koubunen AT gmail DOT com >\n\nAll rights reserved.\n\nLicensed under GPL, the same as HAProxy\n\nHAProxy and other sources license notices: see relevant individual files.\n'