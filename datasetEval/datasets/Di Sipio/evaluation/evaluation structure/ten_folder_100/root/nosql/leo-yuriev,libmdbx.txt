b'### The [repository now only mirrored on the Github](https://abf.io/erthink/libmdbx) due to illegal discriminatory restrictions for Russian Crimea and for sovereign crimeans.\n<!-- Required extensions: pymdownx.betterem, pymdownx.tilde, pymdownx.emoji, pymdownx.tasklist, pymdownx.superfences -->\n-----\n\nlibmdbx\n======================================\n\n_libmdbx_ is an extremely fast, compact, powerful, embedded\ntransactional [key-value\nstore](https://en.wikipedia.org/wiki/Key-value_database)\ndatabase, with permissive [OpenLDAP Public License](LICENSE).\n_libmdbx_ has a specific set of properties and capabilities,\nfocused on creating unique lightweight solutions with\nextraordinary performance.\n\nThe next version is under active non-public development and will be\nreleased as **_MithrilDB_** and `libmithrildb` for libraries & packages.\nAdmittedly mythical [Mithril](https://en.wikipedia.org/wiki/Mithril) is\nresembling silver but being stronger and lighter than steel. Therefore\n_MithrilDB_ is rightly relevant name.\n> _MithrilDB_ will be radically different from _libmdbx_ by the new\n> database format and API based on C++17, as well as the [Apache 2.0\n> License](https://www.apache.org/licenses/LICENSE-2.0). The goal of this\n> revolution is to provide a clearer and robust API, add more features and\n> new valuable properties of database.\n\n*The Future will (be) [Positive](https://www.ptsecurity.com). \xd0\x92\xd1\x81\xd1\x91 \xd0\xb1\xd1\x83\xd0\xb4\xd0\xb5\xd1\x82 \xd1\x85\xd0\xbe\xd1\x80\xd0\xbe\xd1\x88\xd0\xbe.*\n\n[![Build Status](https://travis-ci.org/leo-yuriev/libmdbx.svg?branch=master)](https://travis-ci.org/leo-yuriev/libmdbx)\n[![Build status](https://ci.appveyor.com/api/projects/status/ue94mlopn50dqiqg/branch/master?svg=true)](https://ci.appveyor.com/project/leo-yuriev/libmdbx/branch/master)\n[![Coverity Scan Status](https://scan.coverity.com/projects/12915/badge.svg)](https://scan.coverity.com/projects/reopen-libmdbx)\n\n## Table of Contents\n- [Overview](#overview)\n    - [Comparison with other databases](#comparison-with-other-databases)\n    - [History & Acknowledgments](#history)\n- [Description](#description)\n    - [Key features](#key-features)\n    - [Improvements over LMDB](#improvements-over-lmdb)\n    - [Gotchas](#gotchas)\n- [Usage](#usage)\n    - [Building](#building)\n    - [Bindings](#bindings)\n- [Performance comparison](#performance-comparison)\n    - [Integral performance](#integral-performance)\n    - [Read scalability](#read-scalability)\n    - [Sync-write mode](#sync-write-mode)\n    - [Lazy-write mode](#lazy-write-mode)\n    - [Async-write mode](#async-write-mode)\n    - [Cost comparison](#cost-comparison)\n\n-----\n\n## Overview\n\n_libmdbx_ is revised and extended descendant of amazing [Lightning\nMemory-Mapped\nDatabase](https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database).\n_libmdbx_ inherits all features and characteristics from\n[LMDB](https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database),\nbut resolves some issues and adds several features.\n\n - _libmdbx_ guarantee data integrity after crash unless this was explicitly\nneglected in favour of write performance.\n\n - _libmdbx_ allows multiple processes to read and update several key-value\ntables concurrently, while being\n[ACID](https://en.wikipedia.org/wiki/ACID)-compliant, with minimal\noverhead and Olog(N) operation cost.\n\n - _libmdbx_ enforce\n[serializability](https://en.wikipedia.org/wiki/Serializability) for\nwriters by single\n[mutex](https://en.wikipedia.org/wiki/Mutual_exclusion) and affords\n[wait-free](https://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom)\nfor parallel readers without atomic/interlocked operations, while\nwriting and reading transactions do not block each other.\n\n - _libmdbx_ uses [B+Trees](https://en.wikipedia.org/wiki/B%2B_tree) and\n[Memory-Mapping](https://en.wikipedia.org/wiki/Memory-mapped_file),\ndoesn\'t use [WAL](https://en.wikipedia.org/wiki/Write-ahead_logging)\nwhich might be a caveat for some workloads.\n\n - _libmdbx_ implements a simplified variant of the [Berkeley\nDB](https://en.wikipedia.org/wiki/Berkeley_DB) and/or\n[dbm](https://en.wikipedia.org/wiki/DBM_(computing)) API.\n\n - _libmdbx_ supports Linux, Windows, MacOS, FreeBSD and other systems\ncompliant with POSIX.1-2008.\n\n### Comparison with other databases\nFor now please refer to [chapter of "BoltDB comparison with other\ndatabases"](https://github.com/coreos/bbolt#comparison-with-other-databases)\nwhich is also (mostly) applicable to _libmdbx_.\n\n### History\nAt first the development was carried out within the\n[ReOpenLDAP](https://github.com/leo-yuriev/ReOpenLDAP) project. About a\nyear later _libmdbx_ was separated into standalone project, which was\n[presented at Highload++ 2015\nconference](http://www.highload.ru/2015/abstracts/1831.html).\n\nSince 2017 _libmdbx_ is used in [Fast Positive Tables](https://github.com/leo-yuriev/libfpta),\nand development is funded by [Positive Technologies](https://www.ptsecurity.com).\n\n### Acknowledgments\nHoward Chu <hyc@openldap.org> is the author of LMDB, from which\noriginated the MDBX in 2015.\n\nMartin Hedenfalk <martin@bzero.se> is the author of `btree.c` code, which\nwas used for begin development of LMDB.\n\n-----\n\nDescription\n===========\n\n## Key features\n\n1. Key-value pairs are stored in ordered map(s), keys are always sorted,\nrange lookups are supported.\n\n2. Data is [memory-mapped](https://en.wikipedia.org/wiki/Memory-mapped_file)\ninto each worker DB process, and could be accessed zero-copy from transactions.\n\n3. Transactions are\n[ACID](https://en.wikipedia.org/wiki/ACID)-compliant, through to\n[MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)\nand [CoW](https://en.wikipedia.org/wiki/Copy-on-write). Writes are\nstrongly serialized and aren\'t blocked by reads, transactions can\'t\nconflict with each other. Reads are guaranteed to get only commited data\n([relaxing serializability](https://en.wikipedia.org/wiki/Serializability#Relaxing_serializability)).\n\n4. Read transactions are\n[non-blocking](https://en.wikipedia.org/wiki/Non-blocking_algorithm),\ndon\'t use [atomic operations](https://en.wikipedia.org/wiki/Linearizability#High-level_atomic_operations).\nReaders don\'t block each other and aren\'t blocked by writers. Read\nperformance scales linearly with CPU core count.\n  > Nonetheless, "connect to DB" (starting the first read transaction in a thread) and\n  > "disconnect from DB" (closing DB or thread termination) requires a lock\n  > acquisition to register/unregister at the "readers table".\n\n5. Keys with multiple values are stored efficiently without key\nduplication, sorted by value, including integers (valuable for\nsecondary indexes).\n\n6. Efficient operation on short fixed length keys,\nincluding 32/64-bit integer types.\n\n7. [WAF](https://en.wikipedia.org/wiki/Write_amplification) (Write\nAmplification Factor) \xd0\xb8 RAF (Read Amplification Factor) are Olog(N).\n\n8. No [WAL](https://en.wikipedia.org/wiki/Write-ahead_logging) and\ntransaction journal. In case of a crash no recovery needed. No need for\nregular maintenance. Backups can be made on the fly on working DB\nwithout freezing writers.\n\n9. No additional memory management, all done by basic OS services.\n\n\n## Improvements over LMDB\n\n_libmdbx_ is superior to _legendary [LMDB](https://symas.com/lmdb/)_ in\nterms of features and reliability, not inferior in performance. In\ncomparison to LMDB, _libmdbx_ make things "just work" perfectly and\nout-of-the-box, not silently and catastrophically break down. The list\nbelow is pruned down to the improvements most notable and obvious from\nthe user\'s point of view.\n\n1. Automatic on-the-fly database size control by preset parameters, both\nreduction and increment.\n  > _libmdbx_ manage the database size according to parameters specified\n  > by `mdbx_env_set_geometry()` function,\n  > ones include the growth step and the truncation threshold.\n\n2. Automatic continuous zero-overhead database compactification.\n  > _libmdbx_ logically move as possible a freed pages\n  > at end of allocation area into unallocated space,\n  > and then release such space if a lot of.\n\n3. LIFO policy for recycling a Garbage Collection items. On systems with a disk\nwrite-back cache, this can significantly increase write performance, up to\nseveral times in a best case scenario.\n  > LIFO means that for reuse pages will be taken which became unused the lastest.\n  > Therefore the loop of database pages circulation becomes as short as possible.\n  > In other words, the number of pages, that are overwritten in memory\n  > and on disk during a series of write transactions, will be as small as possible.\n  > Thus creates ideal conditions for the efficient operation of the disk write-back cache.\n\n4. Fast estimation of range query result volume, i.e. how many items can\nbe found between a `KEY1` and a `KEY2`. This is prerequisite for build\nand/or optimize query execution plans.\n  > _libmdbx_ performs a rough estimate based only on b-tree pages that\n  > are common for the both stacks of cursors that were set to corresponing\n  > keys.\n\n5. `mdbx_chk` tool for database integrity check.\n\n6. Guarantee of database integrity even in asynchronous unordered write-to-disk mode.\n  > _libmdbx_ propose additional trade-off by implementing append-like manner for updates\n  > in `NOSYNC` and `MAPASYNC` modes, that avoid database corruption after a system crash\n  > contrary to LMDB. Nevertheless, the `MDBX_UTTERLY_NOSYNC` mode available to match LMDB behaviour,\n  > and for a special use-cases.\n\n7. Automated steady flush to disk upon volume of changes and/or by\ntimeout via cheap polling.\n\n8. Sequence generation and three cheap persistent 64-bit markers with ACID.\n\n9. Support for keys and values of zero length, including multi-values\n(aka sorted duplicates).\n\n10. The handler of lack-of-space condition with a callback,\nthat allow you to control and resolve such situations.\n\n11. Support for opening a database in the exclusive mode, including on a network share.\n\n12. Extended transaction info, including dirty and leftover space info\nfor a write transaction, reading lag and hold over space for read\ntransactions.\n\n13. Extended whole-database info (aka environment) and reader enumeration.\n\n14. Extended update or delete, _at once_ with getting previous value\nand addressing the particular item from multi-value with the same key.\n\n15. Support for explicitly updating the existing record, not insertion a new one.\n\n16. All cursors are uniformly, can be reused and should be closed explicitly,\nregardless ones were opened within write or read transaction.\n\n17. Correct update of current record with `MDBX_CURRENT` flag when size\nof key or data was changed, including sorted duplicated.\n\n18. Opening database handles is spared from race conditions and\npre-opening is not needed.\n\n19. Ability to determine whether the particular data is on a dirty page\nor not, that allows to avoid copy-out before updates.\n\n20. Ability to determine whether the cursor is pointed to a key-value\npair, to the first, to the last, or not set to anything.\n\n21. Returning `MDBX_EMULTIVAL` error in case of ambiguous update or delete.\n\n22. On **MacOS** the `fcntl(F_FULLFSYNC)` syscall is used _by\ndefault_ to synchronize data with the disk, as this is [the only way to\nguarantee data\ndurability](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/fsync.2.html)\nin case of power failure. Unfortunately, in scenarios with high write\nintensity, the use of `F_FULLFSYNC` significant degrades performance\ncompared to LMDB, where the `fsync()` syscall is used. Therefore,\n_libmdbx_ allows you to override this behavior by defining the\n`MDBX_OSX_SPEED_INSTEADOF_DURABILITY=1` option while build the library.\n\n23. On **Windows** the `LockFileEx()` syscall is used for locking, since\nit allows place the database on network drives, and provides protection\nagainst incompetent user actions (aka\n[poka-yoke](https://en.wikipedia.org/wiki/Poka-yoke)). Therefore\n_libmdbx_ may be a little lag in performance tests from LMDB where a\nnamed mutexes are used.\n\n\n## Gotchas\n\n1. There cannot be more than one writer at a time.\n  > On the other hand, this allows serialize an updates and eliminate any\n  > possibility of conflicts, deadlocks or logical errors.\n\n2. No [WAL](https://en.wikipedia.org/wiki/Write-ahead_logging) means\nrelatively big [WAF](https://en.wikipedia.org/wiki/Write_amplification)\n(Write Amplification Factor). Because of this syncing data to disk might\nbe quite resource intensive and be main performance bottleneck during\nintensive write workload.\n  > As compromise _libmdbx_ allows several modes of lazy and/or periodic\n  > syncing, including `MAPASYNC` mode, which modificate data in memory and\n  > asynchronously syncs data to disk, moment to sync is picked by OS.\n  >\n  > Although this should be used with care, synchronous transactions in a DB\n  > with transaction journal will require 2 IOPS minimum (probably 3-4 in\n  > practice) because of filesystem overhead, overhead depends on\n  > filesystem, not on record count or record size. In _libmdbx_ IOPS count\n  > will grow logarithmically depending on record count in DB (height of B+\n  > tree) and will require at least 2 IOPS per transaction too.\n\n3. [CoW](https://en.wikipedia.org/wiki/Copy-on-write) for\n[MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)\nis done on memory page level with\n[B+trees](https://ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE).\nTherefore altering data requires to copy about Olog(N) memory pages,\nwhich uses [memory bandwidth](https://en.wikipedia.org/wiki/Memory_bandwidth) and is main\nperformance bottleneck in `MDBX_MAPASYNC` mode.\n  > This is unavoidable, but isn\'t that bad. Syncing data to disk requires\n  > much more similar operations which will be done by OS, therefore this is\n  > noticeable only if data sync to persistent storage is fully disabled.\n  > _libmdbx_ allows to safely save data to persistent storage with minimal\n  > performance overhead. If there is no need to save data to persistent\n  > storage then it\'s much more preferable to use `std::map`.\n\n4. Massive altering of data during a parallel long read operation will\nincrease the process work set, may exhaust entire free database space and\nresult in subsequent write performance degradation.\n  > _libmdbx_ mostly solve this issue by lack-of-space callback and `MDBX_LIFORECLAIM` mode.\n  > See [`mdbx.h`](mdbx.h) with API description for details.\n  > The "next" version of libmdbx (MithrilDB) will completely solve this.\n\n5. There are no built-in checksums or digests to verify database integrity.\n  > The "next" version of _libmdbx_ (MithrilDB) will solve this issue employing [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).\n\n--------------------------------------------------------------------------------\n\nUsage\n=====\n\n## Source code embedding\n\n_libmdbx_ provides two official ways for integration in source code form:\n\n1. Using the amalgamated source code.\n  > The amalgamated source code includes all files requires to build and\n  > use _libmdbx_, but not for testing _libmdbx_ itself.\n\n2. Adding the complete original source code as a `git submodule`.\n  > This allows you to build as _libmdbx_ and testing tool.\n  >  On the other hand, this way requires you to pull git tags, and use C++11 compiler for test tool.\n\n**_Please, avoid using any other techniques._** Otherwise, at least\ndon\'t ask for support and don\'t name such chimeras `libmdbx`.\n\nThe amalgamated source code could be created from original clone of git\nrepository on Linux by executing `make dist`. As a result, the desired\nset of files will be formed in the `dist` subdirectory.\n\n## Building\n\nBoth amalgamated and original source code provides build through the use\n[CMake](https://cmake.org/) or [GNU\nMake](https://www.gnu.org/software/make/) with\n[bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell)). All build ways\nare completely traditional and have minimal prerequirements like\n`build-essential`, i.e. the non-obsolete C/C++ compiler and a\n[SDK](https://en.wikipedia.org/wiki/Software_development_kit) for the\ntarget platform. Obviously you need building tools itself, i.e. `git`,\n`cmake` or GNU `make` with `bash`.\n\nSo just use CMake or GNU Make in your habitual manner and feel free to\nfill an issue or make pull request in the case something will be\nunexpected or broken down.\n\n#### DSO/DLL unloading and destructors of Thread-Local-Storage objects\nWhen building _libmdbx_ as a shared library or use static _libmdbx_ as a\npart of another dynamic library, it is advisable to make sure that your\nsystem ensures the correctness of the call destructors of\nThread-Local-Storage objects when unloading dynamic libraries.\n\nIf this is not the case, then unloading a dynamic-link library with\n_libmdbx_ code inside, can result in either a resource leak or a crash\ndue to calling destructors from an already unloaded DSO/DLL object. The\nproblem can only manifest in a multithreaded application, which makes\nthe unloading of shared dynamic libraries with _libmdbx_ code inside,\nafter using _libmdbx_. It is known that TLS-destructors are properly\nmaintained in the following cases:\n\n- On all modern versions of Windows (Windows 7 and later).\n\n- On systems with the\n[`__cxa_thread_atexit_impl()`](https://sourceware.org/glibc/wiki/Destructor%20support%20for%20thread_local%20variables)\nfunction in the standard C library, including systems with GNU libc\nversion 2.18 and later.\n\n- On systems with libpthread/ntpl from GNU libc with bug fixes\n[#21031](https://sourceware.org/bugzilla/show_bug.cgi?id=21031) and\n[#21032](https://sourceware.org/bugzilla/show_bug.cgi?id=21032), or\nwhere there are no similar bugs in the pthreads implementation.\n\n### Linux and other platforms with GNU Make\nTo build the library it is enough to execute `make all` in the directory\nof source code, and `make check` for execute the basic tests.\n\nIf the `make` installed on the system is not GNU Make, there will be a\nlot of errors from make when trying to build. In this case, perhaps you\nshould use `gmake` instead of `make`, or even `gnu-make`, etc.\n\n### FreeBSD and related platforms\nAs a rule, in such systems, the default is to use Berkeley Make. And GNU\nMake is called by the gmake command or may be missing. In addition,\n[bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell)) may be absent.\n\nYou need to install the required components: GNU Make, bash, C and C++\ncompilers compatible with GCC or CLANG. After that, to build the\nlibrary, it is enough execute `gmake all` (or `make all`) in the\ndirectory with source code, and `gmake check` (or `make check`) to run\nthe basic tests.\n\n### Windows\nFor build _libmdbx_ on Windows the _original_ CMake and [Microsoft Visual\nStudio](https://en.wikipedia.org/wiki/Microsoft_Visual_Studio) are\nrecommended.\n\nBuilding by MinGW, MSYS or Cygwin is potentially possible. However,\nthese scripts are not tested and will probably require you to modify the\nCMakeLists.txt or Makefile respectively.\n\nIt should be noted that in _libmdbx_ was efforts to resolve\nruntime dependencies from CRT and other libraries Visual Studio.\nFor this is enough define the `MDBX_AVOID_CRT` during build.\n\nAn example of running a basic test script can be found in the\n[CI-script](appveyor.yml) for [AppVeyor](https://www.appveyor.com/). To\nrun the [long stochastic test scenario](test/long_stochastic.sh),\n[bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell)) is required, and\nthe such testing is recommended with place the test data on the\n[RAM-disk](https://en.wikipedia.org/wiki/RAM_drive).\n\n### MacOS\nCurrent [native build tools](https://en.wikipedia.org/wiki/Xcode) for\nMacOS include GNU Make, CLANG and an outdated version of bash.\nTherefore, to build the library, it is enough to run `make all` in the\ndirectory with source code, and run `make check` to execute the base\ntests. If something goes wrong, it is recommended to install\n[Homebrew](https://brew.sh/) and try again.\n\nTo run the [long stochastic test scenario](test/long_stochastic.sh), you\nwill need to install the current (not outdated) version of\n[bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell)). To do this, we\nrecommend that you install [Homebrew](https://brew.sh/) and then execute\n`brew install bash`.\n\n## Bindings\n\n  | Runtime  | GitHub | Author |\n  | -------- | ------ | ------ |\n  | Java     | [mdbxjni](https://github.com/castortech/mdbxjni)   | [Castor Technologies](https://castortech.com/) |\n  | .NET     | [mdbx.NET](https://github.com/wangjia184/mdbx.NET) | [Jerry Wang](https://github.com/wangjia184) |\n\n\n--------------------------------------------------------------------------------\n\nPerformance comparison\n======================\n\nAll benchmarks were done by [IOArena](https://github.com/pmwkaa/ioarena)\nand multiple [scripts](https://github.com/pmwkaa/ioarena/tree/HL%2B%2B2015)\nruns on Lenovo Carbon-2 laptop, i7-4600U 2.1 GHz, 8 Gb RAM,\nSSD SAMSUNG MZNTD512HAGL-000L1 (DXT23L0Q) 512 Gb.\n\n## Integral performance\n\nHere showed sum of performance metrics in 3 benchmarks:\n\n - Read/Search on 4 CPU cores machine;\n\n - Transactions with [CRUD](https://en.wikipedia.org/wiki/CRUD)\n operations in sync-write mode (fdatasync is called after each\n transaction);\n\n - Transactions with [CRUD](https://en.wikipedia.org/wiki/CRUD)\n operations in lazy-write mode (moment to sync data to persistent storage\n is decided by OS).\n\n*Reasons why asynchronous mode isn\'t benchmarked here:*\n\n  1. It doesn\'t make sense as it has to be done with DB engines, oriented\n  for keeping data in memory e.g. [Tarantool](https://tarantool.io/),\n  [Redis](https://redis.io/)), etc.\n\n  2. Performance gap is too high to compare in any meaningful way.\n\n![Comparison #1: Integral Performance](https://raw.githubusercontent.com/wiki/leo-yuriev/libmdbx/img/perf-slide-1.png)\n\n--------------------------------------------------------------------------------\n\n## Read Scalability\n\nSummary performance with concurrent read/search queries in 1-2-4-8\nthreads on 4 CPU cores machine.\n\n![Comparison #2: Read Scalability](https://raw.githubusercontent.com/wiki/leo-yuriev/libmdbx/img/perf-slide-2.png)\n\n--------------------------------------------------------------------------------\n\n## Sync-write mode\n\n - Linear scale on left and dark rectangles mean arithmetic mean\n transactions per second;\n\n - Logarithmic scale on right is in seconds and yellow intervals mean\n execution time of transactions. Each interval shows minimal and maximum\n execution time, cross marks standard deviation.\n\n**10,000 transactions in sync-write mode**. In case of a crash all data\nis consistent and state is right after last successful transaction.\n[fdatasync](https://linux.die.net/man/2/fdatasync) syscall is used after\neach write transaction in this mode.\n\nIn the benchmark each transaction contains combined CRUD operations (2\ninserts, 1 read, 1 update, 1 delete). Benchmark starts on empty database\nand after full run the database contains 10,000 small key-value records.\n\n![Comparison #3: Sync-write mode](https://raw.githubusercontent.com/wiki/leo-yuriev/libmdbx/img/perf-slide-3.png)\n\n--------------------------------------------------------------------------------\n\n## Lazy-write mode\n\n - Linear scale on left and dark rectangles mean arithmetic mean of\n thousands transactions per second;\n\n - Logarithmic scale on right in seconds and yellow intervals mean\n execution time of transactions. Each interval shows minimal and maximum\n execution time, cross marks standard deviation.\n\n**100,000 transactions in lazy-write mode**. In case of a crash all data\nis consistent and state is right after one of last transactions, but\ntransactions after it will be lost. Other DB engines use\n[WAL](https://en.wikipedia.org/wiki/Write-ahead_logging) or transaction\njournal for that, which in turn depends on order of operations in\njournaled filesystem. _libmdbx_ doesn\'t use WAL and hands I/O operations\nto filesystem and OS kernel (mmap).\n\nIn the benchmark each transaction contains combined CRUD operations (2\ninserts, 1 read, 1 update, 1 delete). Benchmark starts on empty database\nand after full run the database contains 100,000 small key-value\nrecords.\n\n\n![Comparison #4: Lazy-write mode](https://raw.githubusercontent.com/wiki/leo-yuriev/libmdbx/img/perf-slide-4.png)\n\n--------------------------------------------------------------------------------\n\n## Async-write mode\n\n - Linear scale on left and dark rectangles mean arithmetic mean of\n thousands transactions per second;\n\n - Logarithmic scale on right in seconds and yellow intervals mean\n execution time of transactions. Each interval shows minimal and maximum\n execution time, cross marks standard deviation.\n\n**1,000,000 transactions in async-write mode**. In case of a crash all\ndata will be consistent and state will be right after one of last\ntransactions, but lost transaction count is much higher than in\nlazy-write mode. All DB engines in this mode do as little writes as\npossible on persistent storage. _libmdbx_ uses\n[msync(MS_ASYNC)](https://linux.die.net/man/2/msync) in this mode.\n\nIn the benchmark each transaction contains combined CRUD operations (2\ninserts, 1 read, 1 update, 1 delete). Benchmark starts on empty database\nand after full run the database contains 10,000 small key-value records.\n\n![Comparison #5: Async-write mode](https://raw.githubusercontent.com/wiki/leo-yuriev/libmdbx/img/perf-slide-5.png)\n\n--------------------------------------------------------------------------------\n\n## Cost comparison\n\nSummary of used resources during lazy-write mode benchmarks:\n\n - Read and write IOPS;\n\n - Sum of user CPU time and sys CPU time;\n\n - Used space on persistent storage after the test and closed DB, but not\n waiting for the end of all internal housekeeping operations (LSM\n compactification, etc).\n\n_ForestDB_ is excluded because benchmark showed it\'s resource\nconsumption for each resource (CPU, IOPS) much higher than other engines\nwhich prevents to meaningfully compare it with them.\n\nAll benchmark data is gathered by\n[getrusage()](http://man7.org/linux/man-pages/man2/getrusage.2.html)\nsyscall and by scanning data directory.\n\n![Comparison #6: Cost comparison](https://raw.githubusercontent.com/wiki/leo-yuriev/libmdbx/img/perf-slide-6.png)\n\n--------------------------------------------------------------------------------\n\n```\n$ objdump -f -h -j .text libmdbx.so\n\nlibmdbx.so:     file format elf64-x86-64\narchitecture: i386:x86-64, flags 0x00000150:\nHAS_SYMS, DYNAMIC, D_PAGED\nstart address 0x0000000000003710\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n 11 .text         00015eff  0000000000003710  0000000000003710  00003710  2**4\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n```\n'