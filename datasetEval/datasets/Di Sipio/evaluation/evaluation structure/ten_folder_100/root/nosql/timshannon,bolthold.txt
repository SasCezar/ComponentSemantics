b'# BoltHold\n[![Build Status](https://travis-ci.org/timshannon/bolthold.svg?branch=master)](https://travis-ci.org/timshannon/bolthold) [![GoDoc](https://godoc.org/github.com/timshannon/bolthold?status.svg)](https://godoc.org/github.com/timshannon/bolthold) [![Coverage Status](https://coveralls.io/repos/github/timshannon/bolthold/badge.svg?branch=master)](https://coveralls.io/github/timshannon/bolthold?branch=master) [![Go Report Card](https://goreportcard.com/badge/github.com/timshannon/bolthold)](https://goreportcard.com/report/github.com/timshannon/bolthold)\n\n\nBoltHold is a simple querying and indexing layer on top of a Bolt DB instance.  For a similar library built on\n[Badger](https://github.com/dgraph-io/badger) see [BadgerHold](https://github.com/timshannon/badgerhold).\n\nThe goal is to create a simple,\nhigher level interface on top of Bolt DB that simplifies dealing with Go Types and finding data, but exposes the underlying\nBolt DB for customizing as you wish.  By default the encoding used is Gob, so feel free to use the GobEncoder/Decoder\ninterface for faster serialization.  Or, alternately, you can use any serialization you want by supplying encode / decode\nfuncs to the `Options` struct on Open.\n\nOne Go Type will have one bucket, and multiple index buckets in a BoltDB file, so you can store multiple Go Types in the\nsame database.\n\n## Why not just use Bolt DB directly?\nI love BoltDB, and I\'ve used it in several projects.  However, I find myself writing the same code over and over again,\nfor encoding and decoding objects and searching through data.  I figure formalizing how I\'ve been using BoltDB\nand including tests and benchmarks will, at a minimum, be useful to me.  Maybe it\'ll be useful to others as well.\n\n## Indexes\nIndexes allow you to skip checking any records that don\'t meet your index criteria.  If you have 1000 records and only\n10 of them are of the Division you want to deal with, then you don\'t need to check to see if the other 990 records match\nyour query criteria if you create an index on the Division field.  The downside of an index is added disk reads and writes\non every write operation.  For read heavy operations datasets, indexes can be very useful.\n\nIn every BoltHold store, there will be a reserved bucket *_indexes* which will be used to hold indexes that point back\nto another bucket\'s Key system.  Indexes will be defined by setting the `boltholdIndex` struct tag on a field in a type.\n\n```Go\ntype Person struct {\n\tName string\n\tDivision string `boltholdIndex:"Division"`\n}\n\n```\n\nThis means that there will be an index created for `Division` that will contain the set of unique divisions, and the\nmain record keys they refer to.  More information on how indexes work can be found [here](https://github.com/timshannon/bolthold/issues/36#issuecomment-414720348)\n\nOptionally, you can implement the `Storer` interface, to specify your own indexes, rather than using the `boltHoldIndex`\nstruct tag.\n\n## Queries\nQueries are chain-able constructs that filters out any data that doesn\'t match it\'s criteria. An index will be used if\nthe `.Index()` chain is called, otherwise bolthold won\'t use any index.\n\nQueries will look like this:\n```Go\ns.Find(bolthold.Where("FieldName").Eq(value).And("AnotherField").Lt(AnotherValue).Or(bolthold.Where("FieldName").Eq(anotherValue)))\n\n```\n\nFields must be exported, and thus always need to start with an upper-case letter.  Available operators include:\n* Equal - `Where("field").Eq(value)`\n* Not Equal - `Where("field").Ne(value)`\n* Greater Than - `Where("field").Gt(value)`\n* Less Than - `Where("field").Lt(value)`\n* Less than or Equal To - `Where("field").Le(value)`\n* Greater Than or Equal To - `Where("field").Ge(value)`\n* In - `Where("field").In(val1, val2, val3)`\n* IsNil - `Where("field").IsNil()`\n* Regular Expression - `Where("field").RegExp(regexp.MustCompile("ea"))`\n* Matches Function \n  * `Where("field").MatchFunc(func(ra *RecordAccess) (bool, error)) // see RecordAccess Type`\n  * `Where("field").MatchFunc(func(m *MyType) (bool, error))`\n  * `Where("field").MatchFunc(func(field string) (bool, error))`\n* Skip - `Where("field").Eq(value).Skip(10)`\n* Limit - `Where("field").Eq(value).Limit(10)`\n* SortBy - `Where("field").Eq(value).SortBy("field1", "field2")`\n* Reverse - `Where("field").Eq(value).SortBy("field").Reverse()`\n* Index - `Where("field").Eq(value).Index("indexName")`\n* Not - `Where("field").Not().In(val1, val2, val3)`\n* Contains - `Where("field").Contains(val1)`\n* ContainsAll - `Where("field").Contains(val1, val2, val3)`\n* ContainsAny - `Where("field").Contains(val1, val2, val3)`\n\n\nIf you want to run a query\'s criteria against the Key value, you can use the `bolthold.Key` constant:\n```Go\n\nstore.Find(&result, bolthold.Where(bolthold.Key).Ne(value))\n\n```\n\nYou can access nested structure fields in queries like this:\n\n```Go\ntype Repo struct {\n  Name string\n  Contact ContactPerson\n}\n\ntype ContactPerson struct {\n  Name string\n}\n\nstore.Find(&repo, bolthold.Where("Contact.Name").Eq("some-name")\n```\n\nInstead of passing in a specific value to compare against in a query, you can compare against another field in the same\nstruct.  Consider the following struct:\n\n```Go\ntype Person struct {\n\tName string\n\tBirth time.Time\n\tDeath time.Time\n}\n\n```\n\nIf you wanted to find any invalid records where a Person\'s death was before their birth, you could do the following:\n\n```Go\n\nstore.Find(&result, bolthold.Where("Death").Lt(bolthold.Field("Birth")))\n\n```\n\nQueries can be used in more than just selecting data.  You can delete or update data that matches a query.\n\nUsing the example above, if you wanted to remove all of the invalid records where Death < Birth:\n\n```Go\n\n// you must pass in a sample type, so BoltHold knows which bucket to use and what indexes to update\nstore.DeleteMatching(&Person{}, bolthold.Where("Death").Lt(bolthold.Field("Birth")))\n\n```\n\nOr if you wanted to update all the invalid records to flip/flop the Birth and Death dates:\n```Go\n\nstore.UpdateMatching(&Person{}, bolthold.Where("Death").Lt(bolthold.Field("Birth")), func(record interface{}) error {\n\tupdate, ok := record.(*Person) // record will always be a pointer\n\tif !ok {\n\t\treturn fmt.Errorf("Record isn\'t the correct type!  Wanted Person, got %T", record)\n\t}\n\n\tupdate.Birth, update.Death = update.Death, update.Birth\n\n\treturn nil\n})\n```\n\nIf you simply want to count the number of records returned by a query use the `Count` method:\n```Go\n // need to pass in empty datatype so bolthold knows what type to count\ncount, err := store.Count(&Person{}, bolthold.Where("Death").Lt(bolthold.Field("Birth")))\n```\n\n### Keys in Structs\n\nA common scenario is to store the bolthold Key in the same struct that is stored in the boltDB value.  You can\nautomatically populate a record\'s Key in a struct by using the `boltholdKey` struct tag when running `Find` queries.\n\nAnother common scenario is to insert data with an auto-incrementing key assigned by the database.\nWhen performing an `Insert`, if the type of the key matches the type of the `boltholdKey` tagged field,\nthe data is passed in by reference, **and** the field\'s current value is the zero-value for that type,\nthen it is set on the data _before_ insertion.\n\n```Go\ntype Employee struct {\n\tID string `boltholdKey:"ID"`  // the tagName isn\'t required, but some linters will complain without it\n\tFirstName string\n\tLastName string\n\tDivision string\n\tHired time.Time\n}\n```\nBolthold assumes only one of such struct tags exists. If a value already exists in the key field, it will be overwritten.\n\nIf you want to insert an auto-incrementing Key you can pass the `bolthold.NextSequence()` func as the Key value.\n\n```Go\nerr := store.Insert(bolthold.NextSequence(), data)\n```\n\nThe key value will be a `uint64`.\n\nIf you want to know the value of the auto-incrementing Key that was generated using `bolthold.NextSequence()`,\nthen make sure to pass your data by value and that the `boltholdKey` tagged field is of type `uint64`.\n\n```Go\nerr := store.Insert(bolthold.NextSequence(), &data)\n```\n\n\n### Slices in Structs and Queries\nWhen querying slice fields in structs you can use the `Contains`, `ContainsAll` and `ContainsAny` criterion.\n\n```Go\nval := struct {\n    Set []string\n}{\n    Set: []string{"1", "2", "3"},\n}\nbh.Where("Set").Contains("1") // true\nbh.Where("Set").ContainsAll("1", "3") // true\nbh.Where("Set").ContainsAll("1", "3", "4") // false\nbh.Where("Set").ContainsAny("1", "7", "4") // true\n```\n\nThe `In`, `ContainsAll` and `ContainsAny` critierion accept a slice of `interface{}` values.  This means you can build\nyour queries by passing in your values as arguments:\n```\nwhere := bolthold.Where("Id").In("1", "2", "3")\n```\n\nHowever if you have an existing slice of values to test against, you can\'t pass in that slice because it is not of type\n`[]interface{}`.\n\n```Go\nt := []string{"1", "2", "3", "4"}\nwhere := bolthold.Where("Id").In(t...) // compile error\n```\n\nInstead you need to copy your slice into another slice of empty interfaces:\n```Go\nt := []string{"1", "2", "3", "4"}\ns := make([]interface{}, len(t))\nfor i, v := range t {\n    s[i] = v\n}\nwhere := bolthold.Where("Id").In(s...)\n```\n\nYou can use the helper function `bolthold.Slice` which does exactly that.\n```Go\nt := []string{"1", "2", "3", "4"}\nwhere := bolthold.Where("Id").In(bolthold.Slice(t)...)\n\n```\n\n### Aggregate Queries\n\nAggregate queries are queries that group results by a field.  For example, lets say you had a collection of employees:\n\n```Go\ntype Employee struct {\n\tFirstName string\n\tLastName string\n\tDivision string\n\tHired time.Time\n}\n```\n\nAnd you wanted to find the most senior (first hired) employee in each division:\n\n```Go\n\nresult, err := store.FindAggregate(&Employee{}, nil, "Division") //nil query matches against all records\n```\n\nThis will return a slice of `Aggregate Result` from which you can extract your groups and find Min, Max, Avg, Count,\netc.\n\n```Go\nfor i := range result {\n\tvar division string\n\temployee := &Employee{}\n\n\tresult[i].Group(&division)\n\tresult[i].Min("Hired", employee)\n\n\tfmt.Printf("The most senior employee in the %s division is %s.\\n",\n\t\tdivision, employee.FirstName + " " + employee.LastName)\n}\n```\n\nAggregate queries become especially powerful when combined with the sub-querying capability of `MatchFunc`.\n\n\nMany more examples of queries can be found in the [find_test.go](https://github.com/timshannon/bolthold/blob/master/find_test.go)\nfile in this repository.\n\n## Comparing\n\nJust like with Go, types must be the same in order to be compared with each other.  You cannot compare an int to a int32.\nThe built-in Go comparable types (ints, floats, strings, etc) will work as expected.  Other types from the standard library\ncan also be compared such as `time.Time`, `big.Rat`, `big.Int`, and `big.Float`.  If there are other standard library\ntypes that I missed, let me know.\n\nYou can compare any custom type either by using the `MatchFunc` criteria, or by satisfying the `Comparer` interface with\nyour type by adding the Compare method: `Compare(other interface{}) (int, error)`.\n\nIf a type doesn\'t have a predefined comparer, and doesn\'t satisfy the Comparer interface, then the types value is converted\nto a string and compared lexicographically.\n\n## Behavior Changes\nSince BoltHold is a higher level interface than BoltDB, there are some added helpers.  Instead of *Put*, you\nhave the options of:\n* *Insert* - Fails if key already exists.\n* *Update* - Fails if key doesn\'t exist `ErrNotFound`.\n* *Upsert* - If key doesn\'t exist, it inserts the data, otherwise it updates the existing record.\n\nWhen getting data instead of returning `nil` if a value doesn\'t exist, BoltHold returns `bolthold.ErrNotFound`, and\nsimilarly when deleting data, instead of silently continuing if a value isn\'t found to delete, BoltHold returns\n`bolthold.ErrNotFound`.  The exception to this is when using query based functions such as `Find` (returns an empty slice),\n`DeleteMatching` and `UpdateMatching` where no error is returned.\n\n\n## When should I use BoltHold?\nBoltHold will be useful in the same scenarios where BoltDB is useful, with the added benefit of being able to retire\nsome of your data filtering code and possibly improved performance.\n\nYou can also use it instead of SQLite for many scenarios.  BoltHold\'s main benefit over SQLite is its simplicity when\nworking with Go Types.  There is no need for an ORM layer to translate records to types, simply put types in, and get\ntypes out.  You also don\'t have to deal with database initialization.  Usually with SQLite you\'ll need several scripts\nto create the database, create the tables you expect, and create any indexes.  With BoltHold you simply open a new file\nand put any type of data you want in it.\n\n```Go\nstore, err := bolthold.Open(filename, 0666, nil)\nif err != nil {\n\t//handle error\n}\nerr = store.Insert("key", &Item{\n\tName:    "Test Name",\n\tCreated: time.Now(),\n})\n\n```\n\nThat\'s it!\n\nBolthold currently has over 80% coverage in unit tests, and it\'s backed by BoltDB which is a very solid and well built\npiece of software, so I encourage you to give it a try.\n\nIf you end up using BoltHold, I\'d love to hear about it.\n'