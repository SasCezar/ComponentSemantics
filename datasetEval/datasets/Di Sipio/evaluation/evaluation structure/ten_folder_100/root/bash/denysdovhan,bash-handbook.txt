b'# bash-handbook\n\n[![CC 4.0][cc-image]][cc-url]\n[![NPM version][npm-image]][npm-url]\n[![Gitter][gitter-image]][gitter-url]\n\nThis document was written for those who want to learn Bash without diving in too deeply.\n\n> **Tip**: Try [**learnyoubash**](https://git.io/learnyoubash) \xe2\x80\x94 an interactive workshopper based on this handbook!\n\n# Node Packaged Manuscript\n\nYou can install this handbook using `npm`. Just run:\n\n```\n$ npm install -g bash-handbook\n```\n\nYou should be able to run `bash-handbook` at the command line now. This will open the manual in your selected `$PAGER`. Otherwise, you may continue reading on here.\n\nThe source is available here: <https://github.com/denysdovhan/bash-handbook>\n\n# Translations\n\nCurrently, there are these translations of **bash-handbook**:\n\n- [Portugu\xc3\xaas (Brasil)](/translations/pt-BR/README.md)\n- [\xe7\xae\x80\xe4\xbd\x93\xe4\xb8\xad\xe6\x96\x87 (\xe4\xb8\xad\xe5\x9b\xbd)](/translations/zh-CN/README.md)\n- [\xe7\xb9\x81\xe9\xab\x94\xe4\xb8\xad\xe6\x96\x87\xef\xbc\x88\xe5\x8f\xb0\xe7\x81\xa3\xef\xbc\x89](/translations/zh-TW/README.md)\n- [\xed\x95\x9c\xea\xb5\xad\xec\x96\xb4 (\xed\x95\x9c\xea\xb5\xad)](/translations/ko-KR/README.md)\n\n[**Request another translation**][tr-request]\n\n[tr-request]: https://github.com/denysdovhan/bash-handbook/issues/new?title=Translation%20Request:%20%5BPlease%20enter%20language%20here%5D&body=I%20am%20able%20to%20translate%20this%20language%20%5Byes/no%5D\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n# Table of Contents\n\n- [Introduction](#introduction)\n- [Shells and modes](#shells-and-modes)\n  - [Interactive mode](#interactive-mode)\n  - [Non-interactive mode](#non-interactive-mode)\n  - [Exit codes](#exit-codes)\n- [Comments](#comments)\n- [Variables](#variables)\n  - [Local variables](#local-variables)\n  - [Environment variables](#environment-variables)\n  - [Positional parameters](#positional-parameters)\n- [Shell expansions](#shell-expansions)\n  - [Brace expansion](#brace-expansion)\n  - [Command substitution](#command-substitution)\n  - [Arithmetic expansion](#arithmetic-expansion)\n  - [Double and single quotes](#double-and-single-quotes)\n- [Arrays](#arrays)\n  - [Array declaration](#array-declaration)\n  - [Array expansion](#array-expansion)\n  - [Array slice](#array-slice)\n  - [Adding elements into an array](#adding-elements-into-an-array)\n  - [Deleting elements from an array](#deleting-elements-from-an-array)\n- [Streams, pipes and lists](#streams-pipes-and-lists)\n  - [Streams](#streams)\n  - [Pipes](#pipes)\n  - [Lists of commands](#lists-of-commands)\n- [Conditional statements](#conditional-statements)\n  - [Primary and combining expressions](#primary-and-combining-expressions)\n  - [Using an `if` statement](#using-an-if-statement)\n  - [Using a `case` statement](#using-a-case-statement)\n- [Loops](#loops)\n  - [`for` loop](#for-loop)\n  - [`while` loop](#while-loop)\n  - [`until` loop](#until-loop)\n  - [`select` loop](#select-loop)\n  - [Loop control](#loop-control)\n- [Functions](#functions)\n  - [Debugging](#debugging)\n- [Afterword](#afterword)\n- [Want to learn more?](#want-to-learn-more)\n- [Other resources](#other-resources)\n- [License](#license)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# Introduction\n\nIf you are a developer, then you know the value of time. Optimizing your work process is one of the most important aspects of the job.\n\nIn that path towards efficiency and productivity, we are often posed with actions that must be repeated over and over again, like:\n\n* taking a screenshot and uploading it to a server\n* processing text that may come in many shapes and forms\n* converting files between different formats\n* parsing a program\'s output\n\nEnter **Bash**, our savior.\n\nBash is a Unix shell written by [Brian Fox][] for the GNU Project as a free software replacement for the [Bourne shell](https://en.wikipedia.org/wiki/Bourne_shell). It was released in 1989 and has been distributed as the Linux and macOS default shell for a long time.\n\n[Brian Fox]: https://en.wikipedia.org/wiki/Brian_Fox_(computer_programmer)\n<!-- link this format, because some MD processors handle \'()\' in URLs poorly -->\n\nSo why do we need to learn something that was written more than 30 years ago? The answer is simple: this _something_ is today one of the most powerful and portable tools for writing efficient scripts for all Unix-based systems. And that\'s why you should learn bash. Period.\n\nIn this handbook, I\'m going to describe the most important concepts in bash with examples. I hope this compendium will be helpful to you.\n\n# Shells and modes\n\nThe user bash shell can work in two modes - interactive and non-interactive.\n\n## Interactive mode\n\nIf you are working on Ubuntu, you have seven virtual terminals available to you.\nThe desktop environment takes place in the seventh virtual terminal, so you can return to a friendly GUI\nusing the `Ctrl-Alt-F7` keybinding.\n\nYou can open the shell using the `Ctrl-Alt-F1` keybinding. After that, the familiar GUI will disappear and one of the virtual terminals will be shown.\n\nIf you see something like this, then you are working in interactive mode:\n\n    user@host:~$\n\nHere you can enter a variety of Unix commands, such as `ls`, `grep`, `cd`, `mkdir`, `rm` and see the result of their execution.\n\nWe call this shell interactive because it interacts directly with the user.\n\nUsing a virtual terminal is not really convenient. For example, if you want to edit a document and execute another command at the same time, you are better off using virtual terminal emulators like:\n\n- [GNOME Terminal](https://en.wikipedia.org/wiki/GNOME_Terminal)\n- [Terminator](https://en.wikipedia.org/wiki/Terminator_(terminal_emulator))\n- [iTerm2](https://en.wikipedia.org/wiki/ITerm2)\n- [ConEmu](https://en.wikipedia.org/wiki/ConEmu)\n\n## Non-interactive mode\n\nIn non-interactive mode, the shell reads commands from a file or a pipe and executes them. When the interpreter reaches the end of the file, the shell process terminates the session and returns to the parent process.\n\nUse the following commands for running the shell in non-interactive mode:\n\n    sh /path/to/script.sh\n    bash /path/to/script.sh\n\nIn the example above, `script.sh` is just a regular text file that consists of commands the shell interpreter can evaluate and `sh` or `bash` is the shell\'s interpreter program. You can create `script.sh` using your preferred text editor (e.g. vim, nano, Sublime Text, Atom, etc).\n\nYou can also simplify invoking the script by making it an executable file using the `chmod` command:\n\n\n    chmod +x /path/to/script.sh\n\nAdditionally, the first line in the script must indicate which program it should use to run the file, like so:\n\n```bash\n#!/bin/bash\necho "Hello, world!"\n```\n\nOr if you prefer to use `sh` instead of `bash`, change `#!/bin/bash` to `#!/bin/sh`. This `#!` character sequence is known as the [shebang](http://en.wikipedia.org/wiki/Shebang_%28Unix%29). Now you can run the script like this:\n\n    /path/to/script.sh\n\nA handy trick we used above is using `echo` to print text to the terminal screen.\n\nAnother way to use the shebang line is as follows:\n\n```bash\n#!/usr/bin/env bash\necho "Hello, world!"\n```\n\nThe advantage of this shebang line is it will search for the program (in this case `bash`) based on the `PATH` environment variable. This is often preferred over the first method shown above, as the location of a program on a filesystem cannot always be assumed. This is also useful if the `PATH` variable on a system has been configured to point to an alternate version of the program. For instance, one might install a newer version of `bash` while preserving the original version and insert the location of the newer version into the `PATH` variable. The use of `#!/bin/bash` would result in using the original `bash`, while `#!/usr/bin/env bash` would make use of the newer version.\n\n\n## Exit codes\n\nEvery command returns an **exit code** (**return status** or **exit status**). A successful command always returns `0` (zero-code), and a command that has failed returns a non-zero value (error code). Failure codes must be positive integers between 1 and 255.\n\nAnother handy command we can use when writing a script is `exit`. This command is used to terminate the current execution and deliver an exit code to the shell. Running an `exit` code without any arguments, will terminate the running script and return the exit code of the last command executed before `exit`.\n\nWhen a program terminates, the shell assigns its **exit code** to the `$?` environment variable. The `$?` variable is how we usually test whether a script has succeeded or not in its execution.\n\nIn the same way we can use `exit` to terminate a script, we can use the `return` command to exit a function and return an **exit code** to the caller. You can use `exit` inside a function too and this will exit the function _and_ terminate the program.\n\n# Comments\n\nScripts may contain _comments_. Comments are special statements ignored by the `shell` interpreter. They begin with a `#` symbol and continue on to the end of the line.\n\nFor example:\n\n```bash\n#!/bin/bash\n# This script will print your username.\nwhoami\n```\n\n> **Tip**: Use comments to explain what your script does and _why_.\n\n# Variables\n\nLike in most programming languages, you can also create variables in bash.\n\nBash knows no data types. Variables can contain only numbers or a string of one or more characters. There are three kinds of variables you can create: local variables, environment variables and variables as _positional arguments_.\n\n## Local variables\n\n**Local variables** are variables that exist only within a single script. They are inaccessible to other programs and scripts.\n\nA local variable can be declared using `=` sign (as a rule, there **should not** be any spaces between a variable\'s name, `=` and its value) and its value can be retrieved using the `$` sign. For example:\n\n```bash\nusername="denysdovhan"  # declare variable\necho $username          # display value\nunset username          # delete variable\n```\n\nWe can also declare a variable local to a single function using the `local` keyword. Doing so causes the variable to disappear when the function exits.\n\n```bash\nlocal local_var="I\'m a local value"\n```\n\n## Environment variables\n\n**Environment variables** are variables accessible to any program or script running in current shell session. They are created just like local variables, but using the keyword `export` instead.\n\n```bash\nexport GLOBAL_VAR="I\'m a global variable"\n```\n\nThere are _a lot_ of global variables in bash. You will meet these variables fairly often, so here is a quick lookup table with the most practical ones:\n\n| Variable     | Description                                                   |\n| :----------- | :------------------------------------------------------------ |\n| `$HOME`      | The current user\'s home directory.                            |\n| `$PATH`      | A colon-separated list of directories in which the shell looks for commands. |\n| `$PWD`       | The current working directory.                                |\n| `$RANDOM`    | Random integer between 0 and 32767.                           |\n| `$UID`       | The numeric, real user ID of the current user.                |\n| `$PS1`       | The primary prompt string.                                    |\n| `$PS2`       | The secondary prompt string.                                  |\n\nFollow [this link](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html#sect_03_02_04) to see an extended list of environment variables in Bash.\n\n## Positional parameters\n\n**Positional parameters** are variables allocated when a function is evaluated and are given positionally. The following table lists positional parameter variables and other special variables and their meanings when you are inside a function.\n\n| Parameter      | Description                                                 |\n| :------------- | :---------------------------------------------------------- |\n| `$0`           | Script\'s name.                                              |\n| `$1 \xe2\x80\xa6 $9`      | The parameter list elements from 1 to 9.                     |\n| `${10} \xe2\x80\xa6 ${N}` | The parameter list elements from 10 to N.                    |\n| `$*` or `$@`   | All positional parameters except `$0`.                      |\n| `$#`           | The number of parameters, not counting `$0`.                 |\n| `$FUNCNAME`    | The function name (has a value only inside a function).     |\n\nIn the example below, the positional parameters will be `$0=\'./script.sh\'`,  `$1=\'foo\'` and `$2=\'bar\'`:\n\n    ./script.sh foo bar\n\nVariables may also have _default_ values. We can define as such using the following syntax:\n\n```bash\n # if variables are empty, assign them default values\n: ${VAR:=\'default\'}\n: ${$1:=\'first\'}\n# or\nFOO=${FOO:-\'default\'}\n```\n\n# Shell expansions\n\n_Expansions_ are performed on the command line after it has been split into _tokens_. In other words, these expansions are a mechanism to calculate arithmetical operations, to save results of commands\' executions and so on.\n\nIf you are interested, you can read [more about shell expansions](https://www.gnu.org/software/bash/manual/bash.html#Shell-Expansions).\n\n## Brace expansion\n\nBrace expansion allows us to generate arbitrary strings. It\'s similar to _filename expansion_. For example:\n\n```bash\necho beg{i,a,u}n # begin began begun\n```\n\nAlso brace expansions may be used for creating ranges, which are iterated over in loops.\n\n```bash\necho {0..5} # 0 1 2 3 4 5\necho {00..8..2} # 00 02 04 06 08\n```\n\n## Command substitution\n\nCommand substitution allow us to evaluate a command and substitute its value into another command or variable assignment. Command substitution is performed when a command is enclosed by ``` `` ``` or `$()`.  For example, we can use it as follows:\n\n```bash\nnow=`date +%T`\n# or\nnow=$(date +%T)\n\necho $now # 19:08:26\n```\n\n## Arithmetic expansion\n\nIn bash we are free to do any arithmetical operations. But the expression must enclosed by `$(( ))` The format for arithmetic expansions is:\n\n```bash\nresult=$(( ((10 + 5*3) - 7) / 2 ))\necho $result # 9\n```\n\nWithin arithmetic expansions, variables should generally be used without a `$` prefix:\n\n```bash\nx=4\ny=7\necho $(( x + y ))     # 11\necho $(( ++x + y++ )) # 12\necho $(( x + y ))     # 13\n```\n\n## Double and single quotes\n\nThere is an important difference between double and single quotes. Inside double quotes variables or command substitutions are expanded. Inside single quotes they are not. For example:\n\n```bash\necho "Your home: $HOME" # Your home: /Users/<username>\necho \'Your home: $HOME\' # Your home: $HOME\n```\n\nTake care to expand local variables and environment variables within quotes if they could contain whitespace. As an innocuous example, consider using `echo` to print some user input:\n\n```bash\nINPUT="A string  with   strange    whitespace."\necho $INPUT   # A string with strange whitespace.\necho "$INPUT" # A string  with   strange    whitespace.\n```\n\nThe first `echo` is invoked with 5 separate arguments \xe2\x80\x94 $INPUT is split into separate words, `echo` prints a single space character between each. In the second case, `echo` is invoked with a single argument (the entire $INPUT value, including whitespace).\n\nNow consider a more serious example:\n\n```bash\nFILE="Favorite Things.txt"\ncat $FILE   # attempts to print 2 files: `Favorite` and `Things.txt`\ncat "$FILE" # prints 1 file: `Favorite Things.txt`\n```\n\nWhile the issue in this example could be resolved by renaming FILE to `Favorite-Things.txt`, consider input coming from an environment variable, a positional parameter, or the output of another command (`find`, `cat`, etc). If the input *might* contain whitespace, take care to wrap the expansion in quotes.\n\n# Arrays\n\nLike in other programming languages, an array in bash is a variable that allows you to refer to multiple values. In bash, arrays are also zero-based, that is, the first element in an array has index 0.\n\nWhen dealing with arrays, we should be aware of the special environment variable `IFS`. **IFS**, or **Input Field Separator**, is the character that separates elements in an array. The default value is an empty space `IFS=\' \'`.\n\n## Array declaration\n\nIn bash you create an array by simply assigning a value to an index in the array variable:\n\n```bash\nfruits[0]=Apple\nfruits[1]=Pear\nfruits[2]=Plum\n```\n\nArray variables can also be created using compound assignments such as:\n\n```bash\nfruits=(Apple Pear Plum)\n```\n\n## Array expansion\n\nIndividual array elements are expanded similar to other variables:\n\n```bash\necho ${fruits[1]} # Pear\n```\n\nThe entire array can be expanded by using `*` or `@` in place of the numeric index:\n\n```bash\necho ${fruits[*]} # Apple Pear Plum\necho ${fruits[@]} # Apple Pear Plum\n```\n\nThere is an important (and subtle) difference between the two lines above: consider an array element containing whitespace:\n\n```bash\nfruits[0]=Apple\nfruits[1]="Desert fig"\nfruits[2]=Plum\n```\n\nWe want to print each element of the array on a separate line, so we try to use the `printf` builtin:\n\n```bash\nprintf "+ %s\\n" ${fruits[*]}\n# + Apple\n# + Desert\n# + fig\n# + Plum\n```\n\nWhy were `Desert` and `fig` printed on separate lines? Let\'s try to use quoting:\n\n```bash\nprintf "+ %s\\n" "${fruits[*]}"\n# + Apple Desert fig Plum\n```\n\nNow everything is on one line \xe2\x80\x94 that\'s not what we wanted! Here\'s where `${fruits[@]}` comes into play:\n\n```bash\nprintf "+ %s\\n" "${fruits[@]}"\n# + Apple\n# + Desert fig\n# + Plum\n```\n\nWithin double quotes, `${fruits[@]}` expands to a separate argument for each element in the array; whitespace in the array elements is preserved.\n\n## Array slice\n\nBesides, we can extract a slice of array using the _slice_ operators:\n\n```bash\necho ${fruits[@]:0:2} # Apple Desert fig\n```\n\nIn the example above, `${fruits[@]}` expands to the entire contents of the array, and `:0:2` extracts the slice of length 2, that starts at index 0.\n\n## Adding elements into an array\n\nAdding elements into an array is quite simple too. Compound assignments are specially useful in this case. We can use them like this:\n\n```bash\nfruits=(Orange "${fruits[@]}" Banana Cherry)\necho ${fruits[@]} # Orange Apple Desert fig Plum Banana Cherry\n```\n\nThe example above, `${fruits[@]}` expands to the entire contents of the array and substitutes it into the compound assignment, then assigns the new value into the `fruits` array mutating its original value.\n\n## Deleting elements from an array\n\nTo delete an element from an array, use the `unset` command:\n\n```bash\nunset fruits[0]\necho ${fruits[@]} # Apple Desert fig Plum Banana Cherry\n```\n\n# Streams, pipes and lists\n\nBash has powerful tools for working with other programs and their outputs. Using streams we can send the output of a program into another program or file and thereby write logs or whatever we want.\n\nPipes give us opportunity to create conveyors and control the execution of commands.\n\nIt is paramount we understand how to use this powerful and sophisticated tool.\n\n## Streams\n\nBash receives input and sends output as sequences or **streams** of characters. These streams may be redirected into files or one into another.\n\nThere are three descriptors:\n\n| Code | Descriptor | Description          |\n| :--: | :--------: | :------------------- |\n| `0`  | `stdin`    | The standard input.  |\n| `1`  | `stdout`   | The standard output. |\n| `2`  | `stderr`   | The errors output.   |\n\nRedirection makes it possible to control where the output of a command goes to, and where the input of a command comes from. For redirecting streams these operators are used:\n\n| Operator | Description                                  |\n| :------: | :------------------------------------------- |\n| `>`      | Redirecting output                           |\n| `&>`     | Redirecting output and error output          |\n| `&>>`    | Appending redirected output and error output |\n| `<`      | Redirecting input                            |\n| `<<`     | [Here documents](http://tldp.org/LDP/abs/html/here-docs.html) syntax |\n| `<<<`    | [Here strings](http://www.tldp.org/LDP/abs/html/x17837.html) |\n\nHere are few examples of using redirections:\n\n```bash\n# output of ls will be written to list.txt\nls -l > list.txt\n\n# append output to list.txt\nls -a >> list.txt\n\n# all errors will be written to errors.txt\ngrep da * 2> errors.txt\n\n# read from errors.txt\nless < errors.txt\n```\n\n## Pipes\n\nWe could redirect standard streams not only in files, but also to other programs. **Pipes** let us use the output of a program as the input of another.\n\nIn the example below, `command1` sends its output to `command2`, which then passes it on to the input of `command3`:\n\n    command1 | command2 | command3\n\nConstructions like this are called **pipelines**.\n\nIn practice, this can be used to process data through several programs. For example, here the output of `ls -l` is sent to the `grep` program, which  prints only files with a `.md` extension, and this output is finally sent to the `less` program:\n\n    ls -l | grep .md$ | less\n\nThe exit status of a pipeline is normally the exit status of the last command in the pipeline. The shell will not return a status until all the commands in the pipeline have completed. If you want your pipelines to be considered a failure if any of the commands in the pipeline fail, you should set the pipefail option with:\n\n    set -o pipefail\n\n## Lists of commands\n\nA **list of commands** is a sequence of one or more pipelines separated by `;`, `&`, `&&` or `||` operator.\n\nIf a command is terminated by the control operator `&`, the shell executes the command asynchronously in a subshell. In other words, this command will be executed in the background.\n\nCommands separated by a `;` are executed sequentially: one after another. The shell waits for the finish of each command.\n\n```bash\n# command2 will be executed after command1\ncommand1 ; command2\n\n# which is the same as\ncommand1\ncommand2\n```\n\nLists separated by `&&` and `||` are called _AND_ and _OR_ lists, respectively.\n\nThe _AND-list_ looks like this:\n\n```bash\n# command2 will be executed if, and only if, command1 finishes successfully (returns 0 exit status)\ncommand1 && command2\n```\n\nThe _OR-list_ has the form:\n\n```bash\n# command2 will be executed if, and only if, command1 finishes unsuccessfully (returns code of error)\ncommand1 || command2\n```\n\nThe return code of an _AND_ or _OR_ list is the exit status of the last executed command.\n\n# Conditional statements\n\nLike in other languages, Bash conditionals let us decide to perform an action or not.  The result is determined by evaluating an expression, which should be enclosed in `[[ ]]`.\n\nConditional expression may contain `&&` and `||` operators, which are _AND_ and _OR_ accordingly. Besides this, there many [other handy expressions](#primary-and-combining-expressions).\n\nThere are two different conditional statements: `if` statement and `case` statement.\n\n## Primary and combining expressions\n\nExpressions enclosed inside `[[ ]]` (or `[ ]` for `sh`) are called **test commands** or **primaries**. These expressions help us to indicate results of a conditional. In the tables below, we are using `[ ]`, because it works for `sh` too. Here is an answer about [the difference between double and single square brackets in bash](http://serverfault.com/a/52050).\n\n**Working with the file system:**\n\n| Primary       | Meaning                                                      |\n| :-----------: | :----------------------------------------------------------- |\n| `[ -e FILE ]` | True if `FILE` **e**xists.                                   |\n| `[ -f FILE ]` | True if `FILE` exists and is a regular **f**ile.             |\n| `[ -d FILE ]` | True if `FILE` exists and is a **d**irectory.                |\n| `[ -s FILE ]` | True if `FILE` exists and not empty (**s**ize more than 0).  |\n| `[ -r FILE ]` | True if `FILE` exists and is **r**eadable.                   |\n| `[ -w FILE ]` | True if `FILE` exists and is **w**ritable.                   |\n| `[ -x FILE ]` | True if `FILE` exists and is e**x**ecutable.                 |\n| `[ -L FILE ]` | True if `FILE` exists and is symbolic **l**ink.              |\n| `[ FILE1 -nt FILE2 ]` | FILE1 is **n**ewer **t**han FILE2.                   |\n| `[ FILE1 -ot FILE2 ]` | FILE1 is **o**lder **t**han FILE2.                   |\n\n**Working with strings:**\n\n| Primary        | Meaning                                                     |\n| :------------: | :---------------------------------------------------------- |\n| `[ -z STR ]`   | `STR` is empty (the length is **z**ero).                    |\n| `[ -n STR ]`   |`STR` is not empty (the length is **n**on-zero).             |\n| `[ STR1 == STR2 ]` | `STR1` and `STR2` are equal.                            |\n| `[ STR1 != STR2 ]` | `STR1` and `STR2` are not equal.                        |\n\n**Arithmetic binary operators:**\n\n| Primary             | Meaning                                                |\n| :-----------------: | :----------------------------------------------------- |\n| `[ ARG1 -eq ARG2 ]` | `ARG1` is **eq**ual to `ARG2`.                         |\n| `[ ARG1 -ne ARG2 ]` | `ARG1` is **n**ot **e**qual to `ARG2`.                 |\n| `[ ARG1 -lt ARG2 ]` | `ARG1` is **l**ess **t**han `ARG2`.                    |\n| `[ ARG1 -le ARG2 ]` | `ARG1` is **l**ess than or **e**qual to `ARG2`.        |\n| `[ ARG1 -gt ARG2 ]` | `ARG1` is **g**reater **t**han `ARG2`.                 |\n| `[ ARG1 -ge ARG2 ]` | `ARG1` is **g**reater than or **e**qual to `ARG2`.     |\n\nConditions may be combined using these **combining expressions:**\n\n| Operation      | Effect                                                      |\n| :------------: | :---------------------------------------------------------- |\n| `[ ! EXPR ]`   | True if `EXPR` is false.                                    |\n| `[ (EXPR) ]`   | Returns the value of `EXPR`.                                |\n| `[ EXPR1 -a EXPR2 ]` | Logical _AND_. True if `EXPR1` **a**nd `EXPR2` are true. |\n| `[ EXPR1 -o EXPR2 ]` | Logical _OR_. True if `EXPR1` **o**r `EXPR2` are true.|\n\nSure, there are more useful primaries and you can easily find them in the [Bash man pages](http://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html).\n\n## Using an `if` statement\n\n`if` statements work the same as in other programming languages. If the expression within the braces is true, the code between `then` and `fi` is executed.  `fi` indicates the end of the conditionally executed code.\n\n```bash\n# Single-line\nif [[ 1 -eq 1 ]]; then echo "true"; fi\n\n# Multi-line\nif [[ 1 -eq 1 ]]; then\n  echo "true"\nfi\n```\n\nLikewise, we could use an `if..else` statement such as:\n\n```bash\n# Single-line\nif [[ 2 -ne 1 ]]; then echo "true"; else echo "false"; fi\n\n# Multi-line\nif [[ 2 -ne 1 ]]; then\n  echo "true"\nelse\n  echo "false"\nfi\n```\n\nSometimes `if..else` statements are not enough to do what we want to do. In this case we shouldn\'t forget about the existence of `if..elif..else` statements, which always come in handy.\n\nLook at the example below:\n\n```bash\nif [[ `uname` == "Adam" ]]; then\n  echo "Do not eat an apple!"\nelif [[ `uname` == "Eva" ]]; then\n  echo "Do not take an apple!"\nelse\n  echo "Apples are delicious!"\nfi\n```\n\n## Using a `case` statement\n\nIf you are confronted with a couple of different possible actions to take, then using a `case` statement may be more useful than nested `if` statements. For more complex conditions use `case` like below:\n\n```bash\ncase "$extension" in\n  "jpg"|"jpeg")\n    echo "It\'s image with jpeg extension."\n  ;;\n  "png")\n    echo "It\'s image with png extension."\n  ;;\n  "gif")\n    echo "Oh, it\'s a giphy!"\n  ;;\n  *)\n    echo "Woops! It\'s not image!"\n  ;;\nesac\n```\n\nEach case is an expression matching a pattern. The `|` sign is used for separating multiple patterns, and the `)` operator terminates a pattern list. The commands for the first match are executed. `*` is the pattern for anything else that doesn\'t match the defined patterns. Each block of commands should be divided with the `;;` operator.\n\n# Loops\n\nHere we won\'t be surprised. As in any programming language, a loop in bash is a block of code that iterates as long as the control conditional is true.\n\nThere are four types of loops in Bash: `for`, `while`, `until` and `select`.\n\n## `for` loop\n\nThe `for` is very similar to its sibling in C. It looks like this:\n\n```bash\nfor arg in elem1 elem2 ... elemN\ndo\n  # statements\ndone\n```\n\nDuring each pass through the loop, `arg` takes on the value from `elem1` to `elemN`. Values may also be wildcards or [brace expansions](#brace-expansion).\n\nAlso, we can write `for` loop in one line, but in this case there needs to be a semicolon before `do`, like below:\n\n```bash\nfor i in {1..5}; do echo $i; done\n```\n\nBy the way, if `for..in..do` seems a little bit weird to you, you can also write `for` in C-like style such as:\n\n```bash\nfor (( i = 0; i < 10; i++ )); do\n  echo $i\ndone\n```\n\n`for` is handy when we want to do the same operation over each file in a directory. For example, if we need to move all `.bash` files into the `script` folder and then give them execute permissions, our script would look like this:\n\n```bash\n#!/bin/bash\n\nfor FILE in $HOME/*.bash; do\n  mv "$FILE" "${HOME}/scripts"\n  chmod +x "${HOME}/scripts/${FILE}"\ndone\n```\n\n## `while` loop\n\nThe `while` loop tests a condition and loops over a sequence of commands so long as that condition is _true_. A condition is nothing more than a [primary](#primary-and-combining-expressions) as used in `if..then` conditions. So a `while` loop looks like this:\n\n```bash\nwhile [[ condition ]]\ndo\n  # statements\ndone\n```\n\nJust like in the case of the `for` loop, if we want to write `do` and condition in the same line, then we must use a semicolon before `do`.\n\nA working example might look like this:\n\n```bash\n#!/bin/bash\n\n# Squares of numbers from 0 through 9\nx=0\nwhile [[ $x -lt 10 ]]; do # value of x is less than 10\n  echo $(( x * x ))\n  x=$(( x + 1 )) # increase x\ndone\n```\n\n## `until` loop\n\nThe `until` loop is the exact opposite of the `while` loop. Like a `while` it checks a test condition, but it keeps looping as long as this condition is _false_:\n\n```bash\nuntil [[ condition ]]; do\n  #statements\ndone\n```\n\n## `select` loop\n\nThe `select` loop helps us to organize a user menu. It has almost the same syntax as the `for` loop:\n\n```bash\nselect answer in elem1 elem2 ... elemN\ndo\n  # statements\ndone\n```\n\nThe `select` prints all `elem1..elemN` on the screen with their sequence numbers, after that it prompts the user. Usually it looks like `$?` (`PS3` variable). The answer will be saved in `answer`. If `answer` is the number between `1..N`, then `statements` will execute and `select` will go to the next iteration \xe2\x80\x94 that\'s because we should use the `break` statement.\n\nA working example might look like this:\n\n```bash\n#!/bin/bash\n\nPS3="Choose the package manager: "\nselect ITEM in bower npm gem pip\ndo\n  echo -n "Enter the package name: " && read PACKAGE\n  case $ITEM in\n    bower) bower install $PACKAGE ;;\n    npm)   npm   install $PACKAGE ;;\n    gem)   gem   install $PACKAGE ;;\n    pip)   pip   install $PACKAGE ;;\n  esac\n  break # avoid infinite loop\ndone\n```\n\nThis example, asks the user what package manager {s,he} would like to use. Then, it will ask what package we want to install and finally proceed to install it.\n\nIf we run this, we will get:\n\n```\n$ ./my_script\n1) bower\n2) npm\n3) gem\n4) pip\nChoose the package manager: 2\nEnter the package name: bash-handbook\n<installing bash-handbook>\n```\n\n## Loop control\n\nThere are situations when we need to stop a loop before its normal ending or step over an iteration. In these cases, we can use the shell built-in `break` and `continue` statements. Both of these work with every kind of loop.\n\nThe `break` statement is used to exit the current loop before its ending. We have already met with it.\n\nThe `continue` statement steps over one iteration. We can use it as such:\n\n```bash\nfor (( i = 0; i < 10; i++ )); do\n  if [[ $(( i % 2 )) -eq 0 ]]; then continue; fi\n  echo $i\ndone\n```\n\nIf we run the example above, it will print all odd numbers from 0 through 9.\n\n# Functions\n\nIn scripts we have the ability to define and call functions. As in any programming language, functions in bash are chunks of code, but there are differences.\n\nIn bash, functions are a sequence of commands grouped under a single name, that is the _name_ of the function. Calling a function is the same as calling any other program, you just write the name and the function will be _invoked_.\n\nWe can declare our own function this way:\n\n```bash\nmy_func () {\n  # statements\n}\n\nmy_func # call my_func\n```\n\nWe must declare functions before we can invoke them.\n\nFunctions can take on arguments and return a result \xe2\x80\x94 exit code. Arguments, within functions, are treated in the same manner as arguments given to the script in [non-interactive](#non-interactive-mode) mode \xe2\x80\x94 using [positional parameters](#positional-parameters). A result code can be _returned_ using the `return` command.\n\nBelow is a function that takes a name and returns `0`, indicating successful execution.\n\n```bash\n# function with params\ngreeting () {\n  if [[ -n $1 ]]; then\n    echo "Hello, $1!"\n  else\n    echo "Hello, unknown!"\n  fi\n  return 0\n}\n\ngreeting Denys  # Hello, Denys!\ngreeting        # Hello, unknown!\n```\n\nWe already discussed [exit codes](#exit-codes). The `return` command without any arguments returns the exit code of the last executed command. Above, `return 0` will return a successful exit code. `0`.\n\n## Debugging\n\nThe shell gives us tools for debugging scripts. If we want to run a script in debug mode, we use a special option in our script\'s shebang:\n\n```bash\n#!/bin/bash options\n```\n\nThese options are settings that change shell behavior. The following table is a list of options which might be useful to you:\n\n| Short | Name        | Description                                            |\n| :---: | :---------- | :----------------------------------------------------- |\n| `-f`  | noglob      | Disable filename expansion (globbing).                 |\n| `-i`  | interactive | Script runs in _interactive_ mode.                     |\n| `-n`  | noexec      | Read commands, but don\'t execute them (syntax check).  |\n|       | pipefail    | Make pipelines fail if any commands fail, not just if the final command fail. |\n| `-t`  | \xe2\x80\x94           | Exit after first command.                              |\n| `-v`  | verbose     | Print each command to `stderr` before executing it.    |\n| `-x`  | xtrace      | Print each command and its expanded arguments to `stderr` before executing it. |\n\nFor example, we have script with `-x` option such as:\n\n```bash\n#!/bin/bash -x\n\nfor (( i = 0; i < 3; i++ )); do\n  echo $i\ndone\n```\n\nThis will print the value of the variables to `stdout` along with other useful information:\n\n```\n$ ./my_script\n+ (( i = 0 ))\n+ (( i < 3 ))\n+ echo 0\n0\n+ (( i++  ))\n+ (( i < 3 ))\n+ echo 1\n1\n+ (( i++  ))\n+ (( i < 3 ))\n+ echo 2\n2\n+ (( i++  ))\n+ (( i < 3 ))\n```\n\nSometimes we need to debug a part of a script. In this case using the `set` command is convenient. This command can enable and disable options. Options are turned on using `-` and turned off using `+`:\n\n```bash\n#!/bin/bash\n\necho "xtrace is turned off"\nset -x\necho "xtrace is enabled"\nset +x\necho "xtrace is turned off again"\n```\n\n# Afterword\n\nI hope this small handbook was interesting and helpful. To be honest, I wrote this handbook for myself so as to not forget the bash basics. I tried to write concisely but meaningfully, and I hope you will appreciate that.\n\nThis handbook narrates my own experience with Bash. It does not purport to be comprehensive, so if you still want more, please run `man bash` and start there.\n\nContributions are absolutely welcome and I will be grateful for any corrections or questions you can send my way. For all of that create a new [issue](https://github.com/denysdovhan/bash-handbook/issues).\n\nThanks for reading this handbook!\n\n# Want to learn more?\n\nHere\'s a list of other literature covering Bash:\n\n* Bash man page.  In many environments that you can run Bash, the help system `man` can display information about Bash, by running the command `man bash`.  For more information on the `man` command, see the web page ["The man Command"](http://www.linfo.org/man.html) hosted at [The Linux Information Project](http://www.linfo.org/).\n* ["Bourne-Again SHell manual"](https://www.gnu.org/software/bash/manual/) in many formats, including HTML, Info, TeX, PDF, and Texinfo.  Hosted at <https://www.gnu.org/>.  As of 2016/01, this covers version 4.3, last updated 2015/02/02.\n\n# Other resources\n\n* [awesome-bash](https://github.com/awesome-lists/awesome-bash) is a curated list of Bash scripts and resources\n* [awesome-shell](https://github.com/alebcay/awesome-shell) is another curated list of shell resources\n* [bash-it](https://github.com/Bash-it/bash-it) provides a solid framework for using, developing and maintaining shell scripts and custom commands for your daily work.\n* [Bash Guide for Beginners](http://tldp.org/LDP/Bash-Beginners-Guide/html/) a good resource between the [HOWTO](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html) and the [Bash Scripting](http://tldp.org/LDP/abs/html/) guide.\n* [dotfiles.github.io](http://dotfiles.github.io/) is a good source of pointers to the various dotfiles collections and shell frameworks available for bash and other shells.\n* [learnyoubash](https://github.com/denysdovhan/learnyoubash) helps you write your first bash script\n* [shellcheck](https://github.com/koalaman/shellcheck) is a static analysis tool for shell scripts. You can either use it from a web page at [www.shellcheck.net](http://www.shellcheck.net/) or run it from the command line. Installation instructions are on the [koalaman/shellcheck](https://github.com/koalaman/shellcheck) github repository page.\n\nFinally, Stack Overflow has many questions that are [tagged as bash](https://stackoverflow.com/questions/tagged/bash) that you can learn from and is a good place to ask if you\'re stuck.\n\n# License\n\n[![CC 4.0][cc-image]][cc-url]\n\n&copy; [Denys Dovhan](http://denysdovhan.com)\n\n[cc-url]: http://creativecommons.org/licenses/by/4.0/\n[cc-image]: https://img.shields.io/badge/License-CC%20BY%204.0-lightgrey.svg?style=flat-square\n\n[npm-url]: https://npmjs.org/package/bash-handbook\n[npm-image]: https://img.shields.io/npm/v/bash-handbook.svg?style=flat-square\n\n[gitter-url]: https://gitter.im/denysdovhan/bash-handbook\n[gitter-image]: https://img.shields.io/gitter/room/nwjs/nw.js.svg?style=flat-square\n'