b'# bash-completion\n\n[![Build Status](https://travis-ci.org/scop/bash-completion.svg?branch=master)](https://travis-ci.org/scop/bash-completion)\n\n## Installation\n\nThe easiest way to install this software is to use a package; refer to\n[Repology](https://repology.org/project/bash-completion) for a comprehensive\nlist of operating system distributions, package names, and available versions.\n\nDepending on the package, you may still\nneed to source it from either `/etc/bashrc` or `~/.bashrc` (or any\nother file sourcing those). You can do this by simply using:\n\n```shell\n# Use bash-completion, if available\n[[ $PS1 && -f /usr/share/bash-completion/bash_completion ]] && \\\n    . /usr/share/bash-completion/bash_completion\n```\n\n(if you happen to have *only* bash >= 4.1 installed, see further if not)\n\nIf you don\'t have the package readily available for your distribution, or\nyou simply don\'t want to use one, you can install bash completion using the\nstandard commands for GNU autotools packages:\n\n```shell\nautoreconf -i  # if not installing from prepared release tarball\n./configure\nmake\nmake check # optional, requires python3 with pytest >= 3.6 and pexpect, dejagnu, and tcllib\nmake install # as root\n```\n\nThese commands install the completions and helpers, as well as a\n`profile.d` script that loads `bash_completion` where appropriate.\n\nIf your system does not use the `profile.d` directory (usually below\n`/etc`) mechanism\xe2\x80\x94i.e. does not automatically source shell scripts in\nit\xe2\x80\x94you can source the `$sysconfdir/profile.d/bash_completion.sh`\nscript in `/etc/bashrc` or `~/.bashrc`.\n\nThe `profile.d` script provides a configuration file hook that can be\nused to prevent loading `bash_completion` on per user basis when it\'s\ninstalled system wide. To do this:\n\n1. Turn off programmable completion with `shopt -u progcomp` in\n   `$XDG_CONFIG_HOME/bash_completion` (or `~/.config/bash_completion`\n   if `$XDG_CONFIG_HOME` is not set)\n2. Turn it back on (for example in `~/.bashrc`) if you want to use\n   programmable completion for other purposes.\n\n### macOS (OS X)\n\nIf you\'re using macOS (formerly OS X), `/etc/bashrc` is apparently not sourced at\nall. In that case, you can put the `bash_completion` file in `/sw/etc`\nand add the following code to `~/.bash_profile`:\n\n```shell\nif [ -f /sw/etc/bash_completion ]; then\n   . /sw/etc/bash_completion\nfi\n```\n\n\n## Troubleshooting\n\nIf you find that a given function is producing errors or does not work\nas it should under certain circumstances when you attempt completion,\ntry running `set -v` or `set -x` prior to attempting the completion\nagain. This will produce useful debugging output that will aid us in\nfixing the problem if you are unable to do so yourself. Turn off the\ntrace output by running either `set +v` or `set +x`.\n\nTo debug dynamic loading of a completion, tracing needs to be turned\non before the debugged completion is attempted the first time. The\neasiest way to do this is to start a new shell session, and to turn\ntracing on in it before doing anything else there.\n\n\n## Known problems\n\n1. There seems to be some issue with using the bash built-in `cd` within\n   Makefiles. When invoked as `/bin/sh` within `Makefile`s, bash seems\n   to have a problem changing directory via the `cd` command. A\n   work-around for this is to define `SHELL=/bin/bash` within your\n   `Makefile`. This is believed to be a bug in bash.\n\n2. Many of the completion functions assume GNU versions of the various\n   text utilities that they call (e.g. `grep`, `sed`, and `awk`). Your\n   mileage may vary.\n\n3. If you are seeing \'unbound variable\' warnings from bash when\n   hitting <kbd>&lt;Tab></kbd>, this is because you have either `set -u`\n   or `set -o nounset` somewhere in your start-up files. This causes bash\n   to flag the use of any uninitialised shell variables as an error.\n\n   Whilst we try to avoid references to uninitialised variables in the\n   code, there seem to be at least some cases where bash issues this\n   warning even though the variable in question has been initialised.\n\n   One place this appears to occur is within the `_muttconffiles()`\n   helper function used by `mutt` completion, where the function calls\n   itself recursively. This seems to confuse bash and it issues\n   spurious warnings if `nounset` is set.\n\n\n## FAQ\n\n**Q. The bash completion code inhibits some commands from completing on\n   files with extensions that are legitimate in my environment. Do I\n   have to disable completion for that command in order to complete on\n   the files that I need to?**\n\nA. No. Use `M-/` to (in the words of the bash man page) attempt file\n   name completion on the text to the left of the cursor. This will\n   circumvent any file type restrictions put in place by the bash\n   completion code.\n\n**Q. How can I override a completion shipped by bash-completion?**\n\nA. Install a local completion of your own appropriately for the desired\n   command, and it will take precedence over the one shipped by us. See the\n   next answer for details where to install it, if you are doing it on per\n   user basis. If you want to do it system wide, you can install eagerly\n   loaded files in `compatdir` (see a couple of questions further down for\n   more info) and install a completion for the commands to override our\n   completion for in them.\n\n   If you want to use bash\'s default completion instead of one of ours,\n   something like this should work (where `$cmd` is the command to override\n   completion for): `complete -o default -o bashdefault $cmd`\n\n**Q. Where should I install my own local completions?**\n\nA. Put them in the `completions` subdir of `$BASH_COMPLETION_USER_DIR`\n   (defaults to `$XDG_DATA_HOME/bash-completion` or\n    `~/.local/share/bash-completion`\n   if `$XDG_DATA_HOME` is not set) to have them loaded on demand.\n   See also the next question\'s answer for considerations for these\n   files\' names, they apply here as well. Alternatively, you can write\n   them directly in `~/.bash_completion` which is loaded eagerly by\n   our main script.\n\n**Q. I author/maintain package X and would like to maintain my own\n   completion code for this package. Where should I put it to be sure\n   that interactive bash shells will find it and source it?**\n\nA. Install it in one of the directories pointed to by\n   bash-completion\'s `pkgconfig` file variables. There are two\n   alternatives:\n\n   - The recommended directory is `completionsdir`, which you can get with\n   `pkg-config --variable=completionsdir bash-completion`. From this\n   directory, completions are loaded on-demand based on invoked commands\' names,\n   so be sure to name your completion file accordingly, and to include\n   (for example) symbolic links in case the file provides completions\n   for more than one command.\n   - The other directory (which only present for backwards compatibility)\n     is `compatdir` (get it with\n   `pkg-config --variable=compatdir bash-completion`) from which files\n   are loaded when `bash_completion` is loaded.\n\n   For packages using GNU autotools the installation can be handled\n   for example like this in `configure.ac`:\n\n   ```\n   PKG_CHECK_VAR(bashcompdir, [bash-completion], [completionsdir], ,\n     bashcompdir="${sysconfdir}/bash_completion.d")\n   AC_SUBST(bashcompdir)\n   ```\n\n   ...accompanied by this in `Makefile.am`:\n\n   ```makefile\n   bashcompdir = @bashcompdir@\n   dist_bashcomp_DATA = # completion files go here\n   ```\n\n   For cmake we ship the `bash-completion-config.cmake` and\n   `bash-completion-config-version.cmake` files. Example usage:\n\n   ```\n   find_package(bash-completion)\n   if(BASH_COMPLETION_FOUND)\n     message(STATUS\n       "Using bash completion dir ${BASH_COMPLETION_COMPLETIONSDIR}")\n   else()\n     set (BASH_COMPLETION_COMPLETIONSDIR "/etc/bash_completion.d")\n     message (STATUS\n       "Using fallback bash completion dir ${BASH_COMPLETION_COMPLETIONSDIR}")\n   endif()\n\n   install(FILES your-completion-file DESTINATION\n     ${BASH_COMPLETION_COMPLETIONSDIR})\n   ```\n\n**Q. I use CVS in combination with passwordless SSH access to my remote\n   repository. How can I have the `cvs` command complete on remotely\n   checked-out files where relevant?**\n\nA. Define `$COMP_CVS_REMOTE`. Setting this to anything will result in\n   the behaviour you would like.\n\n**Q. When I\'m running a `./configure` script and completion returns a list\n   of long options to me, some of these take a parameter,\n   e.g. `--this-option=DESCRIPTION`.**\n\n   **Running `./configure --help` lists these descriptions, but\n   everything after the `=` is stripped when returning completions, so\n   I don\'t know what kind of data is expected as a given option\'s\n   parameter.**\n\n   **Is there a way of getting `./configure` completion to return the\n   entire option string, so that I can see what kind of data is\n   required and then simply delete the descriptive text and add my own\n   data?**\n\nA. Define `$COMP_CONFIGURE_HINTS`. Setting this to anything will\n   result in the behaviour you would like.\n\n**Q. When doing tar completion on a file within a tar file like this:**\n\n   ```\n   tar tzvf foo.tar.gz <Tab>\n   ```\n\n   **the pathnames contained in the tar file are not displayed\n   correctly. The slashes are removed, and everything looks like it\'s\n   in a single directory. Why is this?**\n\nA. It\'s a choice we had to make. bash\'s programmable completion is\n   limited in how it handles the list of possible completions it\n   returns.\n\n   Because the paths returned from within the tar file are likely not\n   existing paths on the file system, `-o dirnames` must be passed to\n   the `complete` built-in to make it treat them as such. However,\n   then bash will append a space when completing on directories during\n   pathname completion to the tar files themselves.\n\n   It\'s more important to have proper completion of paths to tar files\n   than it is to have completion for their contents, so this sacrifice\n   was made and `-o filenames` is used with complete instead.\n\n   If you would rather have correct path completion for tar file\n   contents, define `$COMP_TAR_INTERNAL_PATHS` *before* sourcing\n   `bash_completion`.\n\n**Q. When completing on a symlink to a directory, bash does not append\n   the trailing `/` and I have to hit <kbd>&lt;Tab></kbd> again.\n   I don\'t like this.**\n\nA. This has nothing to do with `bash_completion`. It\'s the default for\n   completing symlinks to directories since bash 2.05a, and was added\n   because sometimes you want to operate on the symlink itself, rather\n   than what it points to.\n\n   You can get the pre-2.05a behaviour back by putting `set\n   mark-symlinked-directories on` in your `/etc/inputrc` or\n   `~/.inputrc` file.\n\n**Q. Completion goes awry when I try to complete on something that contains\n   a colon.**\n\nA. This is actually a \'feature\' of bash. bash recognises a colon as\n   starting a new completion token, which is often what you want when\n   completing something like a `PATH` variable:\n\n   ```shell\n   export PATH=/bin:/sbin:/usr<Tab>\n   ```\n\n   Without the special treatment of the colon, the above wouldn\'t work\n   without programmable completion, so it has long been a feature of\n   the shell.\n\n   Unfortunately, you don\'t want the colon to be treated as a special\n   case when doing something like:\n\n   ```shell\n   man File::B<Tab>\n   ```\n\n   Here, the colons make bash think that it\'s completing a new token\n   that begins with \'B\'.\n\n   Unfortunately, there\'s no way to turn this off. The only thing you\n   can do is escape the colons with a backslash.\n\n**Q. Why is `rpm` completion so slow with `-q`?**\n\nA. Probably because the database is being queried every time and this uses a\n   lot of memory.\n\n   You can make this faster by pregenerating the list of installed\n   packages on the system. Make sure you have a readable file called\n   `/var/log/rpmpkgs`.  It\'s generated by `/etc/cron.daily/rpm` on\n   some Red Hat and Mandrake and derivative Linux systems.\n\n   If you don\'t have such a cron job, make one:\n\n   ```shell\n   #!/bin/sh\n\n   rpm -qa --qf \'%{name}-%{version}-%{release}.%{arch}.rpm\\n\' 2>&1 \\\n           | sort >/var/log/rpmpkgs\n   ```\n\n   rpm completion will use this flat text file instead of the RPM database,\n   unless it detects that the database has changed since the file was created,\n   in which case it will still use the database to ensure accuracy.\n\n**Q. bash-completion interferes with my `command_not_found_handler` function!**\n\nA. If your `command_not_found_handler` function is not intended to\n   address (possibly missing) commands invoked during bash\n   programmable completion functions, you can account for this\n   by, for example, testing if the `$COMP_`\\* variables are set and\n   taking appropriate bypass or other action.\n\n**Q. Can tab completion be made even easier?**\n\nA. The `readline(3)` library offers a few settings that can make tab\n   completion easier (or at least different) to use.\n\n   For example, try putting the following in either `/etc/inputrc` or\n   `~/.inputrc`:\n\n   ```\n   set show-all-if-ambiguous on\n   ```\n\n   This will allow single tab completion as opposed to requiring a\n   double tab. This makes things much more pleasant, in our opinion.\n\n   ```\n   set visible-stats on\n   ```\n\n   This will suffix each returned file completion with a character\n   denoting its type, in a similar way to `ls(1)` with `-F` or `--classify`.\n\n   ```\n   set page-completions off\n   ```\n\n   This turns off the use of the internal pager when returning long\n   completion lists.\n\n**Q. Is bash the be-all-and-end-all of completion as far as shells go?**\n\nA. Absolutely not. zsh has an extremely sophisticated completion system\n   that offers many features absent from the bash implementation. Its\n   users often cannot resist pointing this out. More information can\n   be found at: http://www.zsh.org/\n'