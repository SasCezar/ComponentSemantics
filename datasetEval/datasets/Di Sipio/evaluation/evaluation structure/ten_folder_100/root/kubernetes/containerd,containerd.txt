b'![containerd banner](https://raw.githubusercontent.com/cncf/artwork/master/projects/containerd/horizontal/color/containerd-horizontal-color.png)\n\n[![GoDoc](https://godoc.org/github.com/containerd/containerd?status.svg)](https://godoc.org/github.com/containerd/containerd)\n[![Build Status](https://travis-ci.org/containerd/containerd.svg?branch=master)](https://travis-ci.org/containerd/containerd)\n[![Windows Build Status](https://ci.appveyor.com/api/projects/status/github/containerd/containerd?branch=master&svg=true)](https://ci.appveyor.com/project/mlaventure/containerd-3g73f?branch=master)\n![](https://github.com/containerd/containerd/workflows/Nightly/badge.svg)\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bhttps%3A%2F%2Fgithub.com%2Fcontainerd%2Fcontainerd.svg?type=shield)](https://app.fossa.io/projects/git%2Bhttps%3A%2F%2Fgithub.com%2Fcontainerd%2Fcontainerd?ref=badge_shield)\n[![Go Report Card](https://goreportcard.com/badge/github.com/containerd/containerd)](https://goreportcard.com/report/github.com/containerd/containerd)\n[![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/1271/badge)](https://bestpractices.coreinfrastructure.org/projects/1271)\n\ncontainerd is an industry-standard container runtime with an emphasis on simplicity, robustness and portability. It is available as a daemon for Linux and Windows, which can manage the complete container lifecycle of its host system: image transfer and storage, container execution and supervision, low-level storage and network attachments, etc.\n\ncontainerd is designed to be embedded into a larger system, rather than being used directly by developers or end-users.\n\n![architecture](design/architecture.png)\n\n## Getting Started\n\nSee our documentation on [containerd.io](https://containerd.io):\n* [for ops and admins](docs/ops.md)\n* [namespaces](docs/namespaces.md)\n* [client options](docs/client-opts.md)\n\nSee how to build containerd from source at [BUILDING](BUILDING.md).\n\nIf you are interested in trying out containerd see our example at [Getting Started](docs/getting-started.md).\n\n## Nightly builds\n\nThere are nightly builds available for download [here](https://github.com/containerd/containerd/actions?query=workflow%3ANightly).\nBinaries are generated from `master` branch every night for `Linux` and `Windows`.\n\nPlease be aware: nightly builds might have critical bugs, it\'s not recommended for use in prodution and no support provided.\n\n## Runtime Requirements\n\nRuntime requirements for containerd are very minimal. Most interactions with\nthe Linux and Windows container feature sets are handled via [runc](https://github.com/opencontainers/runc) and/or\nOS-specific libraries (e.g. [hcsshim](https://github.com/Microsoft/hcsshim) for Microsoft). The current required version of `runc` is always listed in [RUNC.md](/RUNC.md).\n\nThere are specific features\nused by containerd core code and snapshotters that will require a minimum kernel\nversion on Linux. With the understood caveat of distro kernel versioning, a\nreasonable starting point for Linux is a minimum 4.x kernel version.\n\nThe overlay filesystem snapshotter, used by default, uses features that were\nfinalized in the 4.x kernel series. If you choose to use btrfs, there may\nbe more flexibility in kernel version (minimum recommended is 3.18), but will\nrequire the btrfs kernel module and btrfs tools to be installed on your Linux\ndistribution.\n\nTo use Linux checkpoint and restore features, you will need `criu` installed on\nyour system. See more details in [Checkpoint and Restore](#checkpoint-and-restore).\n\nBuild requirements for developers are listed in [BUILDING](BUILDING.md).\n\n## Features\n\n### Client\n\ncontainerd offers a full client package to help you integrate containerd into your platform.\n\n```go\n\nimport (\n  "github.com/containerd/containerd"\n  "github.com/containerd/containerd/cio"\n)\n\n\nfunc main() {\n\tclient, err := containerd.New("/run/containerd/containerd.sock")\n\tdefer client.Close()\n}\n\n```\n\n### Namespaces\n\nNamespaces allow multiple consumers to use the same containerd without conflicting with each other.  It has the benefit of sharing content but still having separation with containers and images.\n\nTo set a namespace for requests to the API:\n\n```go\ncontext = context.Background()\n// create a context for docker\ndocker = namespaces.WithNamespace(context, "docker")\n\ncontainerd, err := client.NewContainer(docker, "id")\n```\n\nTo set a default namespace on the client:\n\n```go\nclient, err := containerd.New(address, containerd.WithDefaultNamespace("docker"))\n```\n\n### Distribution\n\n```go\n// pull an image\nimage, err := client.Pull(context, "docker.io/library/redis:latest")\n\n// push an image\nerr := client.Push(context, "docker.io/library/redis:latest", image.Target())\n```\n\n### Containers\n\nIn containerd, a container is a metadata object.  Resources such as an OCI runtime specification, image, root filesystem, and other metadata can be attached to a container.\n\n```go\nredis, err := client.NewContainer(context, "redis-master")\ndefer redis.Delete(context)\n```\n\n### OCI Runtime Specification\n\ncontainerd fully supports the OCI runtime specification for running containers.  We have built in functions to help you generate runtime specifications based on images as well as custom parameters.\n\nYou can specify options when creating a container about how to modify the specification.\n\n```go\nredis, err := client.NewContainer(context, "redis-master", containerd.WithNewSpec(oci.WithImageConfig(image)))\n```\n\n### Root Filesystems\n\ncontainerd allows you to use overlay or snapshot filesystems with your containers.  It comes with builtin support for overlayfs and btrfs.\n\n```go\n// pull an image and unpack it into the configured snapshotter\nimage, err := client.Pull(context, "docker.io/library/redis:latest", containerd.WithPullUnpack)\n\n// allocate a new RW root filesystem for a container based on the image\nredis, err := client.NewContainer(context, "redis-master",\n\tcontainerd.WithNewSnapshot("redis-rootfs", image),\n\tcontainerd.WithNewSpec(oci.WithImageConfig(image)),\n)\n\n// use a readonly filesystem with multiple containers\nfor i := 0; i < 10; i++ {\n\tid := fmt.Sprintf("id-%s", i)\n\tcontainer, err := client.NewContainer(ctx, id,\n\t\tcontainerd.WithNewSnapshotView(id, image),\n\t\tcontainerd.WithNewSpec(oci.WithImageConfig(image)),\n\t)\n}\n```\n\n### Tasks\n\nTaking a container object and turning it into a runnable process on a system is done by creating a new `Task` from the container.  A task represents the runnable object within containerd.\n\n```go\n// create a new task\ntask, err := redis.NewTask(context, cio.Stdio)\ndefer task.Delete(context)\n\n// the task is now running and has a pid that can be use to setup networking\n// or other runtime settings outside of containerd\npid := task.Pid()\n\n// start the redis-server process inside the container\nerr := task.Start(context)\n\n// wait for the task to exit and get the exit status\nstatus, err := task.Wait(context)\n```\n\n### Checkpoint and Restore\n\nIf you have [criu](https://criu.org/Main_Page) installed on your machine you can checkpoint and restore containers and their tasks.  This allow you to clone and/or live migrate containers to other machines.\n\n```go\n// checkpoint the task then push it to a registry\ncheckpoint, err := task.Checkpoint(context)\n\nerr := client.Push(context, "myregistry/checkpoints/redis:master", checkpoint)\n\n// on a new machine pull the checkpoint and restore the redis container\ncheckpoint, err := client.Pull(context, "myregistry/checkpoints/redis:master")\n\nredis, err = client.NewContainer(context, "redis-master", containerd.WithNewSnapshot("redis-rootfs", checkpoint))\ndefer container.Delete(context)\n\ntask, err = redis.NewTask(context, cio.Stdio, containerd.WithTaskCheckpoint(checkpoint))\ndefer task.Delete(context)\n\nerr := task.Start(context)\n```\n\n### Snapshot Plugins\n\nIn addition to the built-in Snapshot plugins in containerd, additional external\nplugins can be configured using GRPC. An external plugin is made available using\nthe configured name and appears as a plugin alongside the built-in ones.\n\nTo add an external snapshot plugin, add the plugin to containerd\'s config file\n(by default at `/etc/containerd/config.toml`). The string following\n`proxy_plugin.` will be used as the name of the snapshotter and the address\nshould refer to a socket with a GRPC listener serving containerd\'s Snapshot\nGRPC API. Remember to restart containerd for any configuration changes to take\neffect.\n\n```\n[proxy_plugins]\n  [proxy_plugins.customsnapshot]\n    type = "snapshot"\n    address =  "/var/run/mysnapshotter.sock"\n```\n\nSee [PLUGINS.md](PLUGINS.md) for how to create plugins\n\n### Releases and API Stability\n\nPlease see [RELEASES.md](RELEASES.md) for details on versioning and stability\nof containerd components.\n\nDownloadable 64-bit Intel/AMD binaries of all official releases are available on\nour [releases page](https://github.com/containerd/containerd/releases), as well as\nauto-published to the [cri-containerd-release storage bucket](https://console.cloud.google.com/storage/browser/cri-containerd-release?pli=1).\n\nFor other architectures and distribution support, you will find that many\nLinux distributions package their own containerd and provide it across several\narchitectures, such as [Canonical\'s Ubuntu packaging](https://launchpad.net/ubuntu/bionic/+package/containerd).\n\n#### Enabling command auto-completion\n\nStarting with containerd 1.4, the urfave client feature for auto-creation of bash and zsh\nautocompletion data is enabled. To use the autocomplete feature in a bash shell for example, source\nthe autocomplete/ctr file in your `.bashrc`, or manually like:\n\n```\n$ source ./contrib/autocomplete/ctr\n```\n\n#### Distribution of `ctr` autocomplete for bash and zsh\n\nFor bash, copy the `contrib/autocomplete/ctr` script into\n`/etc/bash_completion.d/` and rename it to `ctr`. The `zsh_autocomplete`\nfile is also available and can be used similarly for zsh users.\n\nProvide documentation to users to `source` this file into their shell if\nyou don\'t place the autocomplete file in a location where it is automatically\nloaded for the user\'s shell environment.\n\n### Communication\n\nFor async communication and long running discussions please use issues and pull requests on the github repo.\nThis will be the best place to discuss design and implementation.\n\nFor sync communication we have a community slack with a #containerd channel that everyone is welcome to join and chat about development.\n\n**Slack:** Catch us in the #containerd and #containerd-dev channels on dockercommunity.slack.com.\n[Click here for an invite to docker community slack.](https://dockr.ly/slack)\n\n### Security audit\n\nA third party security audit was performed by Cure53 in 4Q2018; the [full report](docs/SECURITY_AUDIT.pdf) is available in our docs/ directory.\n\n### Reporting security issues\n\n__If you are reporting a security issue, please reach out discreetly at security@containerd.io__.\n\n## Licenses\n\nThe containerd codebase is released under the [Apache 2.0 license](LICENSE.code).\nThe README.md file, and files in the "docs" folder are licensed under the\nCreative Commons Attribution 4.0 International License. You may obtain a\ncopy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.\n\n## Project details\n\n**containerd** is the primary open source project within the broader containerd GitHub repository.\nHowever, all projects within the repo have common maintainership, governance, and contributing\nguidelines which are stored in a `project` repository commonly for all containerd projects.\n\nPlease find all these core project documents, including the:\n * [Project governance](https://github.com/containerd/project/blob/master/GOVERNANCE.md),\n * [Maintainers](https://github.com/containerd/project/blob/master/MAINTAINERS),\n * and [Contributing guidelines](https://github.com/containerd/project/blob/master/CONTRIBUTING.md)\n\ninformation in our [`containerd/project`](https://github.com/containerd/project) repository.\n\n## Adoption\n\nInterested to see who is using containerd? Are you using containerd in a project?\nPlease add yourself via pull request to our [ADOPTERS.md](./ADOPTERS.md) file.\n'