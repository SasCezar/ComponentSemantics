b'# Hoard\n\nHoard is a stateless, deterministically encrypted, content-addressed object store.\n\n![hoarding marmot](docs/images/hoard.jpg)\n\n## Introduction\nIt convergently encrypts an object using its (SHA256) hash as the secret key (which can than be shared as a \'grant\').\nThe address is then deterministically generated from the encrypted object\'s (SHA256) digest and allocated to the configured storage back-end:\n\n- In-Memory\n- Filesystem\n- [AWS](https://aws.amazon.com/s3/)\n- [GCP](https://cloud.google.com/storage/)\n- [Azure](https://azure.microsoft.com/en-gb/services/storage/)\n- [IPFS](https://ipfs.io/)\n\n## Installing\nHoard should be go-gettable with:\n\n```shell\n# Install Hoard-Daemon:\ngo get github.com/monax/hoard/cmd/hoard\n\n# Install Hoard-Control:\ngo get github.com/monax/hoard/cmd/hoarctl\n```\n\n## Usage\nHoard runs as a daemon providing a GRPC service to other clients including the command line client `hoarctl`. The purpose of the daemon is to read local secrets (such as PGP or other keys) and to configure itself to use a particular storage backend. You can run the daemon with:\n\n```shell\n# Run the daemon\nhoard\n\n# or with logging\nhoard --logging\n```\n\nYou can initialise a Hoard config by running one of:\n\n```shell\n# Initialise Hoard with memory backend\nhoard config --init memory\n\n# Initialise Hoard with filesystem backend\nhoard config --init filesystem\n\n# Initialise Hoard with AWS (S3) backend\nhoard config --init aws\n\n# Initialise Hoard with Azure backend\nhoard config --init azure\n\n# Initialise Hoard with GCP backend\nhoard config --init gcp\n\n# Initialise Hoard with IPFS backend\nhoard config --init ipfs\n```\n\nThese will provide base configurations you can configure to meet your needs. The config is located by default in `$HOME/.config/hoard.conf` but you can specify a file with `hoard -c /path/to/config`. The XDG base directory specification is used to search for config.\n\nYou can interact with Hoard using the go client `hoarctl`:\n\n```shell\n# Store an object:\nref=$(echo bar | hoarctl put)\n\n# Retrieve \'bar\' from its (deterministic) reference\necho $ref | hoarctl get\n\n# Or get information about the object without decrypting\necho $ref | hoarctl stat\n\n# This one-liner exercises the entire API:\necho foo | hoarctl put | hoarctl get | hoarctl putseal | hoarctl unsealget | hoarctl encrypt | hoarctl insert | hoarctl stat | hoarctl cat | hoarctl decrypt -k tbudgBSg+bHWHiHnlteNzN8TUvI80ygS9IULh4rklEw= | hoarctl ref | hoarctl seal | hoarctl reseal | hoarctl unseal | hoarctl get\n```\n\nYou can chop off segments of the final command to see the output of each intermediate command. It is contrived so that the outputs can be used as inputs for the next pipeline step. `hoarctl` either returns JSON references or raw bytes depending on the command. You may find the excellent [jq](https://stedolan.github.io/jq/) useful for working with single-line JSON files on the command line.\n\n## Config\nUsing the filesystem storage backend as an example (generated with `hoard init -o- fs`) you can configure Hoard with a file like:\n\n```toml\n# The listen address, also supported is "unix:///tmp/hoard.socket" for a unix domain socket\nListenAddress = "tcp://localhost:53431"\n\n[Storage]\n  StorageType = "filesystem"\n  # One of: base64, base32, or hex (base 16)\n  AddressEncoding = "base64"\n  RootDirectory = "/home/user/.local/share/hoard"\n\n[Logging]\n  LoggingType = "logfmt"\n  # Removing "trace" from this array will reduce log output\n  Channels = ["info", "trace"]\n```\n\nThe default directory is `$HOME/.config/hoard.toml` or you can pass the file with `hoard -c`.\n\n## Specification\nSee [hoard.proto](protobuf/hoard.proto) for the protobuf3 definition of the API. Hoard uses [GRPC](https://grpc.io/) for its API for which there is a wide range of client libraries available. You should be able to set up a client in any GRPC supported language with relative ease. Also see `hoarctl <CMD> -h` for full help on each sub-command.\n\nFor more information on the design of Hoard please checkout our [documentation](docs/encryption.md).\n\n## Building\nTo build Hoard you will need to have the following installed:\n- Go (Version >= 1.11) (with $GOPATH/bin in $PATH)\n- GNU make\n- [Protocol Buffers 3](https://github.com/google/protobuf/releases/tag/v3.3.0)\n\nThen, from the project root run:\n\n```shell\n# Install protobuf GRPC plugin, glide, and glide dependencies\nmake protobuf_deps\n# Run checks, tests, and build binaries\nmake build && make install\n```\n\n## Javascript Client\nA Javascript client library can be found here: [hoard-js](https://github.com/monax/hoard/tree/master/hoard-js).\n\nHoard-js is a fairly lightweight wrapper around the Hoard GRPC API. It mainly serves to abstract over the dynamic protobuf library and the static protobuf generation.\n\n### Usage\nFirst we need to have Hoard running. For development purposes this can be accomplished by:\n\n```shell\ngo get github.com/monax/hoard/cmd/hoard \n# Run Hoard with logging\nhoard --logging\n```\n\nHoard will run with an in-memory store by default that will be discarded when it is shutdown, but will expose the same\ninterface as when using remote storage backends.\n\nTo interact with Hoard from Node see [example.js](example.js) for a self-contained example of how to use every method\nof the API. To run use:\n\n```shell\n# Get dependencies\nnpm install\n# Run example\nnode example.js\n```'