b'<a name="slonik"></a>\n# Slonik\n\n[![GitSpo Mentions](https://gitspo.com/badges/mentions/gajus/slonik?style=flat-square)](https://gitspo.com/mentions/gajus/slonik)\n[![Travis build status](http://img.shields.io/travis/gajus/slonik/master.svg?style=flat-square)](https://travis-ci.org/gajus/slonik)\n[![Coveralls](https://img.shields.io/coveralls/gajus/slonik.svg?style=flat-square)](https://coveralls.io/github/gajus/slonik)\n[![NPM version](http://img.shields.io/npm/v/slonik.svg?style=flat-square)](https://www.npmjs.org/package/slonik)\n[![Canonical Code Style](https://img.shields.io/badge/code%20style-canonical-blue.svg?style=flat-square)](https://github.com/gajus/canonical)\n[![Twitter Follow](https://img.shields.io/twitter/follow/kuizinas.svg?style=social&label=Follow)](https://twitter.com/kuizinas)\n\nA [battle-tested](#battle-tested) PostgreSQL client with strict types, detailed logging and assertions.\n\n![Tailing Slonik logs](./.README/slonik-log-tailing.gif)\n\n(The above GIF shows Slonik producing [query logs](https://github.com/gajus/slonik#logging). Slonik produces logs using [Roarr](https://github.com/gajus/roarr). Logs include stack trace of the actual query invocation location and values used to execute the query.)\n\n<a name="slonik-sponsors"></a>\n## Sponsors\n\nIf you value my work and want to see Slonik and [many other of my](https://github.com/gajus/) Open-Source projects to be continuously improved, then please consider becoming a patron:\n\n[![Buy Me A Coffee](https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png)](https://www.buymeacoffee.com/gajus)\n[![Become a Patron](https://c5.patreon.com/external/logo/become_a_patron_button.png)](https://www.patreon.com/gajus)\n\n<a name="slonik-principles"></a>\n## Principles\n\n* Promotes writing raw SQL.\n* Discourages ad-hoc dynamic generation of SQL.\n\nRead: [Stop using Knex.js](https://medium.com/@gajus/bf410349856c)\n\nNote: Using this project does not require TypeScript or Flow. It is a regular ES6 module. Ignore the type definitions used in the documentation if you do not use a type system.\n\n<a name="slonik-features"></a>\n## Features\n\n* [Assertions and type safety](#repeating-code-patterns-and-type-safety)\n* [Safe connection handling](#protecting-against-unsafe-connection-handling).\n* [Safe transaction handling](#protecting-against-unsafe-transaction-handling).\n* [Safe value interpolation](#protecting-against-unsafe-value-interpolation).\n* [Transaction nesting](#transaction-nesting).\n* Detailed [logging](#slonik-debugging).\n* [Asynchronous stack trace resolution](#capture-stack-trace).\n* [Middlewares](#slonik-interceptors).\n* [Mapped errors](#error-handling).\n* [ESLint plugin](https://github.com/gajus/eslint-plugin-sql).\n\n<a name="slonik-contents"></a>\n## Contents\n\n* [Slonik](#slonik)\n    * [Sponsors](#slonik-sponsors)\n    * [Principles](#slonik-principles)\n    * [Features](#slonik-features)\n    * [Contents](#slonik-contents)\n    * [About Slonik](#slonik-about-slonik)\n        * [Battle-Tested](#slonik-about-slonik-battle-tested)\n        * [Origin of the name](#slonik-about-slonik-origin-of-the-name)\n        * [Repeating code patterns and type safety](#slonik-about-slonik-repeating-code-patterns-and-type-safety)\n        * [Protecting against unsafe connection handling](#slonik-about-slonik-protecting-against-unsafe-connection-handling)\n        * [Protecting against unsafe transaction handling](#slonik-about-slonik-protecting-against-unsafe-transaction-handling)\n        * [Protecting against unsafe value interpolation](#slonik-about-slonik-protecting-against-unsafe-value-interpolation)\n    * [Documentation](#slonik-documentation)\n    * [Usage](#slonik-usage)\n        * [Create connection](#slonik-usage-create-connection)\n        * [End connection pool](#slonik-usage-end-connection-pool)\n        * [Describing the current state of the connection pool](#slonik-usage-describing-the-current-state-of-the-connection-pool)\n        * [API](#slonik-usage-api)\n        * [Default configuration](#slonik-usage-default-configuration)\n        * [Using native libpq bindings](#slonik-usage-using-native-libpq-bindings)\n        * [Checking out a client from the connection pool](#slonik-usage-checking-out-a-client-from-the-connection-pool)\n    * [How are they different?](#slonik-how-are-they-different)\n        * [`pg` vs `slonik`](#slonik-how-are-they-different-pg-vs-slonik)\n        * [`pg-promise` vs `slonik`](#slonik-how-are-they-different-pg-promise-vs-slonik)\n    * [Type parsers](#slonik-type-parsers)\n        * [Built-in type parsers](#slonik-type-parsers-built-in-type-parsers)\n    * [Interceptors](#slonik-interceptors)\n        * [Interceptor methods](#slonik-interceptors-interceptor-methods)\n    * [Community interceptors](#slonik-community-interceptors)\n    * [Recipes](#slonik-recipes)\n        * [Inserting large number of rows](#slonik-recipes-inserting-large-number-of-rows)\n        * [Routing queries to different connections](#slonik-recipes-routing-queries-to-different-connections)\n    * [`sql` tag](#slonik-sql-tag)\n    * [Value placeholders](#slonik-value-placeholders)\n        * [Tagged template literals](#slonik-value-placeholders-tagged-template-literals)\n        * [Manually constructing the query](#slonik-value-placeholders-manually-constructing-the-query)\n        * [Nesting `sql`](#slonik-value-placeholders-nesting-sql)\n    * [Query building](#slonik-query-building)\n        * [`sql.array`](#slonik-query-building-sql-array)\n        * [`sql.binary`](#slonik-query-building-sql-binary)\n        * [`sql.identifier`](#slonik-query-building-sql-identifier)\n        * [`sql.json`](#slonik-query-building-sql-json)\n        * [`sql.join`](#slonik-query-building-sql-join)\n        * [`sql.unnest`](#slonik-query-building-sql-unnest)\n    * [Query methods](#slonik-query-methods)\n        * [`any`](#slonik-query-methods-any)\n        * [`anyFirst`](#slonik-query-methods-anyfirst)\n        * [`copyFromBinary`](#slonik-query-methods-copyfrombinary)\n        * [`many`](#slonik-query-methods-many)\n        * [`manyFirst`](#slonik-query-methods-manyfirst)\n        * [`maybeOne`](#slonik-query-methods-maybeone)\n        * [`maybeOneFirst`](#slonik-query-methods-maybeonefirst)\n        * [`one`](#slonik-query-methods-one)\n        * [`oneFirst`](#slonik-query-methods-onefirst)\n        * [`query`](#slonik-query-methods-query)\n        * [`stream`](#slonik-query-methods-stream)\n        * [`transaction`](#slonik-query-methods-transaction)\n    * [Error handling](#slonik-error-handling)\n        * [Original `node-postgres` error](#slonik-error-handling-original-node-postgres-error)\n        * [Handling `BackendTerminatedError`](#slonik-error-handling-handling-backendterminatederror)\n        * [Handling `CheckIntegrityConstraintViolationError`](#slonik-error-handling-handling-checkintegrityconstraintviolationerror)\n        * [Handling `ConnectionError`](#slonik-error-handling-handling-connectionerror)\n        * [Handling `DataIntegrityError`](#slonik-error-handling-handling-dataintegrityerror)\n        * [Handling `ForeignKeyIntegrityConstraintViolationError`](#slonik-error-handling-handling-foreignkeyintegrityconstraintviolationerror)\n        * [Handling `NotFoundError`](#slonik-error-handling-handling-notfounderror)\n        * [Handling `NotNullIntegrityConstraintViolationError`](#slonik-error-handling-handling-notnullintegrityconstraintviolationerror)\n        * [Handling `StatementCancelledError`](#slonik-error-handling-handling-statementcancellederror)\n        * [Handling `StatementTimeoutError`](#slonik-error-handling-handling-statementtimeouterror)\n        * [Handling `UniqueIntegrityConstraintViolationError`](#slonik-error-handling-handling-uniqueintegrityconstraintviolationerror)\n    * [Types](#slonik-types)\n    * [Debugging](#slonik-debugging)\n        * [Logging](#slonik-debugging-logging)\n        * [Capture stack trace](#slonik-debugging-capture-stack-trace)\n    * [Syntax Highlighting](#slonik-syntax-highlighting)\n        * [Atom Syntax Highlighting Plugin](#slonik-syntax-highlighting-atom-syntax-highlighting-plugin)\n        * [VS Code Syntax Highlighting Extension](#slonik-syntax-highlighting-vs-code-syntax-highlighting-extension)\n\n\n<a name="slonik-about-slonik"></a>\n## About Slonik\n\n<a name="slonik-about-slonik-battle-tested"></a>\n### Battle-Tested\n\nSlonik began as a collection of utilities designed for working with [`node-postgres`](https://github.com/brianc/node-postgres). We continue to use `node-postgres` as it provides a robust foundation for interacting with PostgreSQL. However, what once was a collection of utilities has since grown into a framework that abstracts repeating code patterns, protects against unsafe connection handling and value interpolation, and provides rich debugging experience.\n\nSlonik has been [battle-tested](https://medium.com/@gajus/lessons-learned-scaling-postgresql-database-to-1-2bn-records-month-edc5449b3067) with large data volumes and queries ranging from simple CRUD operations to data-warehousing needs.\n\n<a name="slonik-about-slonik-origin-of-the-name"></a>\n### Origin of the name\n\n![Slonik](./.README/postgresql-elephant.png)\n\nThe name of the elephant depicted in the official PostgreSQL logo is Slonik. The name itself is derived from the Russian word for "little elephant".\n\nRead: [The History of Slonik, the PostgreSQL Elephant Logo](https://www.vertabelo.com/blog/notes-from-the-lab/the-history-of-slonik-the-postgresql-elephant-logo)\n\n<a name="slonik-about-slonik-repeating-code-patterns-and-type-safety"></a>\n### Repeating code patterns and type safety\n\nAmong the primary reasons for developing Slonik, was the motivation to reduce the repeating code patterns and add a level of type safety. This is primarily achieved through the methods such as `one`, `many`, etc. But what is the issue? It is best illustrated with an example.\n\nSuppose the requirement is to write a method that retrieves a resource ID given values defining (what we assume to be) a unique constraint. If we did not have the aforementioned convenience methods available, then it would need to be written as:\n\n```js\n// @flow\nimport {\n  sql\n} from \'slonik\';\nimport type {\n  DatabaseConnectionType\n} from \'slonik\';\n\nopaque type DatabaseRecordIdType = number;\n\nconst getFooIdByBar = async (connection: DatabaseConnectionType, bar: string): Promise<DatabaseRecordIdType> => {\n  const fooResult = await connection.query(sql`\n    SELECT id\n    FROM foo\n    WHERE bar = ${bar}\n  `);\n\n  if (fooResult.rowCount === 0) {\n    throw new Error(\'Resource not found.\');\n  }\n\n  if (fooResult.rowCount > 1) {\n    throw new Error(\'Data integrity constraint violation.\');\n  }\n\n  return fooResult[0].id;\n};\n\n```\n\n`oneFirst` method abstracts all of the above logic into:\n\n```js\nconst getFooIdByBar = (connection: DatabaseConnectionType, bar: string): Promise<DatabaseRecordIdType> => {\n  return connection.oneFirst(sql`\n    SELECT id\n    FROM foo\n    WHERE bar = ${bar}\n  `);\n};\n\n```\n\n`oneFirst` throws:\n\n* `NotFoundError` if query returns no rows\n* `DataIntegrityError` if query returns multiple rows\n* `DataIntegrityError` if query returns multiple columns\n\nThis becomes particularly important when writing routines where multiple queries depend on the previous result. Using methods with inbuilt assertions ensures that in case of an error, the error points to the original source of the problem. In contrast, unless assertions for all possible outcomes are typed out as in the previous example, the unexpected result of the query will be fed to the next operation. If you are lucky, the next operation will simply break; if you are unlucky, you are risking data corruption and hard to locate bugs.\n\nFurthermore, using methods that guarantee the shape of the results, allows us to leverage static type checking and catch some of the errors even before they executing the code, e.g.\n\n```js\nconst fooId = await connection.many(sql`\n  SELECT id\n  FROM foo\n  WHERE bar = ${bar}\n`);\n\nawait connection.query(sql`\n  DELETE FROM baz\n  WHERE foo_id = ${fooId}\n`);\n\n```\n\nStatic type check of the above example will produce a warning as the `fooId` is guaranteed to be an array and binding of the last query is expecting a primitive value.\n\n<a name="slonik-about-slonik-protecting-against-unsafe-connection-handling"></a>\n### Protecting against unsafe connection handling\n\nSlonik only allows to check out a connection for the duration of the promise routine supplied to the `pool#connect()` method.\n\nThe primary reason for implementing _only_ this connection pooling method is because the alternative is inherently unsafe, e.g.\n\n```js\n// Note: This example is using unsupported API.\n\nconst main = async () => {\n  const connection = await pool.connect();\n\n  await connection.query(sql`SELECT foo()`);\n\n  await connection.release();\n};\n\n```\n\nIn this example, if `SELECT foo()` produces an error, then connection is never released, i.e. the connection remains to hang.\n\nA fix to the above is to ensure that `connection#release()` is always called, i.e.\n\n```js\n// Note: This example is using unsupported API.\n\nconst main = async () => {\n  const connection = await pool.connect();\n\n  let lastExecutionResult;\n\n  try {\n    lastExecutionResult = await connection.query(sql`SELECT foo()`);\n  } finally {\n    await connection.release();\n  }\n\n  return lastExecutionResult;\n};\n\n```\n\nSlonik abstracts the latter pattern into `pool#connect()` method.\n\n```js\nconst main = () => {\n  return pool.connect((connection) => {\n    return connection.query(sql`SELECT foo()`);\n  });\n};\n\n```\n\nConnection is always released back to the pool after the promise produced by the function supplied to `connect()` method is either resolved or rejected.\n\n<a name="slonik-about-slonik-protecting-against-unsafe-transaction-handling"></a>\n### Protecting against unsafe transaction handling\n\nJust like in the [unsafe connection handling](#protecting-against-unsafe-connection-handling) described above, Slonik only allows to create a transaction for the duration of the promise routine supplied to the `connection#transaction()` method.\n\n```js\nconnection.transaction(async (transactionConnection) => {\n  await transactionConnection.query(sql`INSERT INTO foo (bar) VALUES (\'baz\')`);\n  await transactionConnection.query(sql`INSERT INTO qux (quux) VALUES (\'quuz\')`);\n});\n\n```\n\nThis pattern ensures that the transaction is either committed or aborted the moment the promise is either resolved or rejected.\n\n<a name="slonik-about-slonik-protecting-against-unsafe-value-interpolation"></a>\n### Protecting against unsafe value interpolation\n\n[SQL injections](https://en.wikipedia.org/wiki/SQL_injection) are one of the most well known attack vectors. Some of the [biggest data leaks](https://en.wikipedia.org/wiki/SQL_injection#Examples) were the consequence of improper user-input handling. In general, SQL injections are easily preventable by using parameterization and by restricting database permissions, e.g.\n\n```js\n// Note: This example is using unsupported API.\n\nconnection.query(\'SELECT $1\', [\n  userInput\n]);\n\n```\n\nIn this example, the query text (`SELECT $1`) and parameters (value of the `userInput`) are passed to the PostgreSQL server where the parameters are safely substituted into the query. This is a safe way to execute a query using user-input.\n\nThe vulnerabilities appear when developers cut corners or when they do not know about parameterization, i.e. there is a risk that someone will instead write:\n\n```js\n// Note: This example is using unsupported API.\n\nconnection.query(\'SELECT \\\'\' + userInput + \'\\\'\');\n\n```\n\nAs evident by the history of the data leaks, this happens more often than anyone would like to admit. This is especially a big risk in Node.js community, where predominant number of developers are coming from frontend and have not had training working with RDBMSes. Therefore, one of the key selling points of Slonik is that it adds multiple layers of protection to prevent unsafe handling of user-input.\n\nTo begin with, Slonik does not allow to run plain-text queries.\n\n```js\nconnection.query(\'SELECT 1\');\n\n```\n\nThe above invocation would produce an error:\n\n> TypeError: Query must be constructed using `sql` tagged template literal.\n\nThis means that the only way to run a query is by constructing it using [`sql` tagged template literal](https://github.com/gajus/slonik#slonik-value-placeholders-tagged-template-literals), e.g.\n\n```js\nconnection.query(sql`SELECT 1`);\n\n```\n\nTo add a parameter to the query, user must use [template literal placeholders](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Description), e.g.\n\n```js\nconnection.query(sql`SELECT ${userInput}`);\n\n```\n\nSlonik takes over from here and constructs a query with value bindings, and sends the resulting query text and parameters to the PostgreSQL. As `sql` tagged template literal is the only way to execute the query, it adds a strong layer of protection against accidental unsafe user-input handling due to limited knowledge of the SQL client API.\n\nAs Slonik restricts user\'s ability to generate and execute dynamic SQL, it provides helper functions used to generate fragments of the query and the corresponding value bindings, e.g. [`sql.identifier`](#sqlidentifier), [`sql.join`](#sqljoin) and [`sql.unnest`](#sqlunnest). These methods generate tokens that the query executor interprets to construct a safe query, e.g.\n\n```js\nconnection.query(sql`\n  SELECT ${sql.identifier([\'foo\', \'a\'])}\n  FROM (\n    VALUES\n    (\n      ${sql.join(\n        [\n          sql.join([\'a1\', \'b1\', \'c1\'], sql`, `),\n          sql.join([\'a2\', \'b2\', \'c2\'], sql`, `)\n        ],\n        sql`), (`\n      )}\n    )\n  ) foo(a, b, c)\n  WHERE foo.b IN (${sql.join([\'c1\', \'a2\'], sql`, `)})\n`);\n\n```\n\nThis (contrived) example generates a query equivalent to:\n\n```sql\nSELECT "foo"."a"\nFROM (\n  VALUES\n    ($1, $2, $3),\n    ($4, $5, $6)\n) foo(a, b, c)\nWHERE foo.b IN ($7, $8)\n\n```\n\nThat is executed with the parameters provided by the user.\n\nTo sum up, Slonik is designed to prevent accidental creation of queries vulnerable to SQL injections.\n\n\n<a name="slonik-documentation"></a>\n## Documentation\n\n<a name="slonik-usage"></a>\n## Usage\n\n<a name="slonik-usage-create-connection"></a>\n### Create connection\n\nUse `createPool` to create a connection pool, e.g.\n\n```js\nimport {\n  createPool,\n} from \'slonik\';\n\nconst pool = createPool(\'postgres://\');\n\n```\n\nInstance of Slonik connection pool can be then used to create a new connection, e.g.\n\n```js\npool.connect(async (connection) => {\n  await connection.query(sql`SELECT 1`);\n});\n\n```\n\nThe connection will be kept alive until the promise resolves (the result of the method supplied to `connect()`).\n\nRefer to [query method](#slonik-query-methods) documentation to learn about the connection methods.\n\nIf you do not require having a persistent connection to the same backend, then you can directly use `pool` to run queries, e.g.\n\n```js\npool.query(sql`SELECT 1`);\n\n```\n\nBeware that in the latter example, the connection picked to execute the query is a random connection from the connection pool, i.e. using the latter method (without explicit `connect()`) does not guarantee that multiple queries will refer to the same backend.\n\n<a name="slonik-usage-end-connection-pool"></a>\n### End connection pool\n\nUse `pool.end()` to end idle connections and prevent creation of new connections.\n\nThe result of `pool.end()` is a promise that is resolved when all connections are ended.\n\n```js\nimport {\n  createPool,\n  sql,\n} from \'slonik\';\n\nconst pool = createPool(\'postgres://\');\n\nconst main = async () => {\n  await pool.query(sql`\n    SELECT 1\n  `);\n\n  await pool.end();\n};\n\nmain();\n\n```\n\nNote: `pool.end()` does not terminate active connections/ transactions.\n\n<a name="slonik-usage-describing-the-current-state-of-the-connection-pool"></a>\n### Describing the current state of the connection pool\n\nUse `pool.getPoolState()` to find out if pool is alive and how many connections are active and idle, and how many clients are waiting for a connection.\n\n```js\nimport {\n  createPool,\n  sql,\n} from \'slonik\';\n\nconst pool = createPool(\'postgres://\');\n\nconst main = async () => {\n  pool.getPoolState();\n\n  // {\n  //   activeConnectionCount: 0,\n  //   ended: false,\n  //   idleConnectionCount: 0,\n  //   waitingClientCount: 0,\n  // }\n\n  await pool.connect(() => {\n    pool.getPoolState();\n\n    // {\n    //   activeConnectionCount: 1,\n    //   ended: false,\n    //   idleConnectionCount: 0,\n    //   waitingClientCount: 0,\n    // }\n  });\n\n  pool.getPoolState();\n\n  // {\n  //   activeConnectionCount: 0,\n  //   ended: false,\n  //   idleConnectionCount: 1,\n  //   waitingClientCount: 0,\n  // }\n\n  await pool.end();\n\n  pool.getPoolState();\n\n  // {\n  //   activeConnectionCount: 0,\n  //   ended: true,\n  //   idleConnectionCount: 0,\n  //   waitingClientCount: 0,\n  // }\n};\n\nmain();\n\n```\n\nNote: `pool.end()` does not terminate active connections/ transactions.\n\n<a name="slonik-usage-api"></a>\n### API\n\n```js\n/**\n * @param connectionUri PostgreSQL [Connection URI](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING).\n */\ncreatePool(\n  connectionUri: string,\n  clientConfiguration: ClientConfigurationType\n): DatabasePoolType;\n\n/**\n * @property captureStackTrace Dictates whether to capture stack trace before executing query. Middlewares access stack trace through query execution context. (Default: true)\n * @property connectionRetryLimit Number of times to retry establishing a new connection. (Default: 3)\n * @property connectionTimeout Timeout (in milliseconds) after which an error is raised if cannot cannot be established. (Default: 5000)\n * @property idleTimeout Timeout (in milliseconds) after which idle clients are closed. Use \'DISABLE_TIMEOUT\' constant to disable the timeout. (Default: 5000)\n * @property interceptors An array of [Slonik interceptors](https://github.com/gajus/slonik#slonik-interceptors).\n * @property maximumPoolSize Do not allow more than this many connections. Use \'DISABLE_TIMEOUT\' constant to disable the timeout. (Default: 10)\n * @property preferNativeBindings Uses libpq bindings when `pg-native` module is installed. (Default: true)\n * @property typeParsers An array of [Slonik type parsers](https://github.com/gajus/slonik#slonik-type-parsers).\n */\ntype ClientConfigurationInputType = {|\n  +captureStackTrace?: boolean,\n  +connectionRetryLimit?: number,\n  +connectionTimeout?: number | \'DISABLE_TIMEOUT\',\n  +idleTimeout?: number | \'DISABLE_TIMEOUT\',\n  +interceptors?: $ReadOnlyArray<InterceptorType>,\n  +maximumPoolSize?: number,\n  +preferNativeBindings?: boolean,\n  +typeParsers?: $ReadOnlyArray<TypeParserType>,\n|};\n\n```\n\nExample:\n\n```js\nimport {\n  createPool\n} from \'slonik\';\n\nconst pool = createPool(\'postgres://\');\n\nawait pool.query(sql`SELECT 1`);\n\n```\n\n<a name="slonik-usage-default-configuration"></a>\n### Default configuration\n\n<a name="slonik-usage-default-configuration-default-interceptors"></a>\n#### Default interceptors\n\nNone.\n\nCheck out [`slonik-interceptor-preset`](https://github.com/gajus/slonik-interceptor-preset) for an opinionated collection of interceptors.\n\n<a name="slonik-usage-default-configuration-default-type-parsers"></a>\n#### Default type parsers\n\nThese type parsers are enabled by default:\n\n|Type name|Implemnetation|\n|---|---|\n|`date`|Produces a literal date as a string (format: YYYY-MM-DD).|\n|`int8`|Produces an integer.|\n|`interval`|Produces interval in seconds (integer).|\n|`numeric`|Produces a float.|\n|`timestamp`|Produces a unix timestamp (in milliseconds).|\n|`timestamptz`|Produces a unix timestamp (in milliseconds).|\n\nTo disable the default type parsers, pass an empty array, e.g.\n\n```js\ncreatePool(\'postgres://\', {\n  typeParsers: []\n});\n\n```\n\nYou can create default type parser collection using `createTypeParserPreset`, e.g.\n\n```js\nimport {\n  createTypeParserPreset\n} from \'slonik\';\n\ncreatePool(\'postgres://\', {\n  typeParsers: [\n    ...createTypeParserPreset()\n  ]\n});\n\n```\n\n<a name="slonik-usage-using-native-libpq-bindings"></a>\n### Using native libpq bindings\n\nIn order to use native [libpq](https://www.npmjs.com/package/libpq) PostgreSQL bindings install `pg-native`.\n\n```bash\n$ npm install pg-native\n\n```\n\nBy default, Slonik uses native bindings when `pg-native` is installed. To use JavaScript bindings when `pg-native` is installed, configure `preferNativeBindings: false`.\n\n<a name="slonik-usage-checking-out-a-client-from-the-connection-pool"></a>\n### Checking out a client from the connection pool\n\nSlonik only allows to check out a connection for the duration of the promise routine supplied to the `pool#connect()` method.\n\n```js\nimport {\n  createPool\n} from \'slonik\';\n\nconst pool = createPool(\'postgres://localhost\');\n\nconst result = await pool.connect(async (connection) => {\n  await connection.query(sql`SELECT 1`);\n  await connection.query(sql`SELECT 2`);\n\n  return \'foo\';\n});\n\nresult;\n// \'foo\'\n\n```\n\nConnection is released back to the pool after the promise produced by the function supplied to `connect()` method is either resolved or rejected.\n\nRead: [Protecting against unsafe connection handling](#protecting-against-unsafe-connection-handling)\n\n<a name="slonik-how-are-they-different"></a>\n## How are they different?\n\n<a name="slonik-how-are-they-different-pg-vs-slonik"></a>\n### <code>pg</code> vs <code>slonik</code>\n\n[`pg`](https://github.com/brianc/node-postgres) is built intentionally to provide unopinionated, minimal abstraction and encourages use of other modules to implement convenience methods.\n\nSlonik is built on top of `pg` and it provides convenience methods for [building queries](#value-placeholders) and [querying data](#slonik-query-methods).\n\nWork on `pg` began on [Tue Sep 28 22:09:21 2010](https://github.com/brianc/node-postgres/commit/cf637b08b79ef93d9a8b9dd2d25858aa7e9f9bdc). It is authored by [Brian Carlson](https://github.com/brianc).\n\n<a name="slonik-how-are-they-different-pg-promise-vs-slonik"></a>\n### <code>pg-promise</code> vs <code>slonik</code>\n\nAs the name suggests, [`pg-promise`](https://github.com/vitaly-t/pg-promise) was originally built to enable use of `pg` module with promises (at the time, `pg` only supported Continuation Passing Style (CPS), i.e. callbacks). Since then `pg-promise` added features for connection/ transaction handling, a powerful query-formatting engine and a declarative approach to handling query results.\n\nThe primary difference between Slonik and `pg-promise`:\n\n* Slonik does not allow to execute raw text queries. Slonik queries can only be constructed using [`sql` tagged template literals](#slonik-value-placeholders-tagged-template-literals). This design [protects against unsafe value interpolation](#protecting-against-unsafe-value-interpolation).\n* Slonik implements [interceptor API](#slonik-interceptors) (middleware). Middlewares allow to modify connection handling, override queries and modify the query results. Example Slonik interceptors include [field name transformation](https://github.com/gajus/slonik-interceptor-field-name-transformation), [query normalization](https://github.com/gajus/slonik-interceptor-query-normalisation) and [query benchmarking](https://github.com/gajus/slonik-interceptor-query-benchmarking).\n\nNote: Author of `pg-promise` has [objected to the above claims](https://github.com/gajus/slonik/issues/122). I have removed a difference that was clearly wrong. I maintain that the above two differences remain valid differences: even though `pg-promise` might have substitute functionality for variable interpolation and interceptors, it implements them in a way that does not provide the same benefits that Slonik provides, namely: guaranteed security and support for extending library functionality using multiple plugins.\n\nOther differences are primarily in how the equivalent features are implemented, e.g.\n\n|`pg-promise`|Slonik|\n|---|---|\n|[Custom type formatting](https://github.com/vitaly-t/pg-promise#custom-type-formatting).|Not available in Slonik. The current proposal is to create an interceptor that would have access to the [query fragment constructor](https://github.com/gajus/slonik/issues/21).|\n|[formatting filters](https://github.com/vitaly-t/pg-promise#nested-named-parameters)|Slonik tagged template [value expressions](https://github.com/gajus/slonik#slonik-value-placeholders) to construct query fragments and bind parameter values.|\n|[Query files](https://github.com/vitaly-t/pg-promise#query-files).|Use [`slonik-sql-tag-raw`](https://github.com/gajus/slonik-sql-tag-raw).|\n|[Tasks](https://github.com/vitaly-t/pg-promise#tasks).|Use [`pool.connect`](https://github.com/gajus/slonik#slonik-usage-create-connection).|\n|Configurable transactions.|Not available in Slonik. Track [this issue](https://github.com/gajus/slonik/issues/30).|\n|Events.|Use [interceptors](https://github.com/gajus/slonik#slonik-interceptors).|\n\nWhen weighting which abstraction to use, it would be unfair not to consider that `pg-promise` is a mature project with dozens of contributors. Meanwhile, Slonik is a young project (started in March 2017) that until recently was developed without active community input. However, if you do support the unique features that Slonik adds, the opinionated API design, and are not afraid of adopting a technology in its young days, then I warmly invite you to adopt Slonik and become a contributor to what I intend to make the standard PostgreSQL client in the Node.js community.\n\nWork on `pg-promise` began [Wed Mar 4 02:00:34 2015](https://github.com/vitaly-t/pg-promise/commit/78fb80f638e7f28b301f75576701536d6b638f31). It is authored by [Vitaly Tomilov](https://github.com/vitaly-t).\n\n\n<a name="slonik-type-parsers"></a>\n## Type parsers\n\nType parsers describe how to parse PostgreSQL types.\n\n```js\ntype TypeParserType = {|\n  +name: string,\n  +parse: (value: string) => *\n|};\n\n```\n\nExample:\n\n```js\n{\n  name: \'int8\',\n  parse: (value) => {\n    return parseInt(value, 10);\n  }\n}\n\n```\n\nNote: Unlike [`pg-types`](https://github.com/brianc/node-pg-types) that uses OIDs to identify types, Slonik identifies types using their names.\n\nUse this query to find type names:\n\n```sql\nSELECT\n  typname\nFROM pg_type\nORDER BY typname ASC\n\n```\n\nType parsers are configured using [`typeParsers` client configuration](#slonik-usage-api).\n\nRead: [Default type parsers](#default-type-parsers).\n\n<a name="slonik-type-parsers-built-in-type-parsers"></a>\n### Built-in type parsers\n\n|Type name|Implemnetation|Factory function name|\n|---|---|---|\n|`date`|Produces a literal date as a string (format: YYYY-MM-DD).|`createDateTypeParser`|\n|`int8`|Produces an integer.|`createBigintTypeParser`|\n|`interval`|Produces interval in seconds (integer).|`createIntervalTypeParser`|\n|`numeric`|Produces a float.|`createNumericTypeParser`|\n|`timestamp`|Produces a unix timestamp (in milliseconds).|`createTimestampTypeParser`|\n|`timestamptz`|Produces a unix timestamp (in milliseconds).|`createTimestampWithTimeZoneTypeParser`|\n\nBuilt-in type parsers can be created using the exported factory functions, e.g.\n\n```js\nimport {\n  createTimestampTypeParser\n} from \'slonik\';\n\ncreateTimestampTypeParser();\n\n// {\n//   name: \'timestamp\',\n//   parse: (value) => {\n//     return value === null ? value : Date.parse(value);\n//   }\n// }\n\n```\n\n\n<a name="slonik-interceptors"></a>\n## Interceptors\n\nFunctionality can be added to Slonik client by adding interceptors (middleware).\n\nInterceptors are configured using [client configuration](#api), e.g.\n\n```js\nimport {\n  createPool\n} from \'slonik\';\n\nconst interceptors = [];\n\nconst connection = createPool(\'postgres://\', {\n  interceptors\n});\n\n```\n\nInterceptors are executed in the order they are added.\n\nRead: [Default interceptors](#default-interceptors).\n\n<a name="slonik-interceptors-interceptor-methods"></a>\n### Interceptor methods\n\nInterceptor is an object that implements methods that can change the behaviour of the database client at different stages of the connection life-cycle\n\n```js\ntype InterceptorType = {|\n  +afterPoolConnection?: (\n    connectionContext: ConnectionContextType,\n    connection: DatabasePoolConnectionType\n  ) => MaybePromiseType<null>,\n  +afterQueryExecution?: (\n    queryContext: QueryContextType,\n    query: QueryType,\n    result: QueryResultType<QueryResultRowType>\n  ) => MaybePromiseType<QueryResultType<QueryResultRowType>>,\n  +beforePoolConnection?: (\n    connectionContext: ConnectionContextType\n  ) => MaybePromiseType<?DatabasePoolType>,\n  +beforePoolConnectionRelease?: (\n    connectionContext: ConnectionContextType,\n    connection: DatabasePoolConnectionType\n  ) => MaybePromiseType<null>,\n  +beforeQueryExecution?: (\n    queryContext: QueryContextType,\n    query: QueryType\n  ) => MaybePromiseType<QueryResultType<QueryResultRowType>> | MaybePromiseType<null>,\n  +beforeQueryResult?: (\n    queryContext: QueryContextType,\n    query: QueryType,\n    result: QueryResultType<QueryResultRowType>\n  ) => MaybePromiseType<null>,\n  +beforeTransformQuery?: (\n    queryContext: QueryContextType,\n    query: QueryType\n  ) => Promise<null>,\n  +queryExecutionError?: (\n    queryContext: QueryContextType,\n    query: QueryType,\n    error: SlonikError\n  ) => MaybePromiseType<null>,\n  +transformQuery?: (\n    queryContext: QueryContextType,\n    query: QueryType\n  ) => QueryType,\n  +transformRow?: (\n    queryContext: QueryContextType,\n    query: QueryType,\n    row: QueryResultRowType,\n    fields: $ReadOnlyArray<FieldType>\n  ) => QueryResultRowType\n|};\n\n```\n\n<a name="slonik-interceptors-interceptor-methods-afterpoolconnection"></a>\n#### <code>afterPoolConnection</code>\n\nExecuted after a connection is acquired from the connection pool (or a new connection is created), e.g.\n\n```js\nconst pool = createPool(\'postgres://\');\n\n// Interceptor is executed here. \xe2\x86\x93\npool.connect();\n\n```\n\n<a name="slonik-interceptors-interceptor-methods-afterqueryexecution"></a>\n#### <code>afterQueryExecution</code>\n\nExecuted after query has been executed and before rows were transformed using `transformRow`.\n\nNote: When query is executed using `stream`, then `afterQuery` is called with empty result set.\n\n<a name="slonik-interceptors-interceptor-methods-beforequeryexecution"></a>\n#### <code>beforeQueryExecution</code>\n\nThis function can optionally return a direct result of the query which will cause the actual query never to be executed.\n\n<a name="slonik-interceptors-interceptor-methods-beforequeryresult"></a>\n#### <code>beforeQueryResult</code>\n\nExecuted just before the result is returned to the client.\n\nUse this method to capture the result that will be returned to the client.\n\n<a name="slonik-interceptors-interceptor-methods-beforetransformquery"></a>\n#### <code>beforeTransformQuery</code>\n\nExecuted before `transformQuery`. Use this interceptor to capture the original query (e.g. for logging purposes).\n\n<a name="slonik-interceptors-interceptor-methods-beforepoolconnectionrelease"></a>\n#### <code>beforePoolConnectionRelease</code>\n\nExecuted before connection is released back to the connection pool, e.g.\n\n```js\nconst pool = await createPool(\'postgres://\');\n\npool.connect(async () => {\n  await 1;\n\n  // Interceptor is executed here. \xe2\x86\x93\n});\n\n```\n\n<a name="slonik-interceptors-interceptor-methods-queryexecutionerror"></a>\n#### <code>queryExecutionError</code>\n\nExecuted if query execution produces an error.\n\nUse `queryExecutionError` to log and/ or re-throw another error.\n\n<a name="slonik-interceptors-interceptor-methods-transformquery"></a>\n#### <code>transformQuery</code>\n\nExecuted before `beforeQueryExecution`.\n\nTransforms query.\n\n<a name="slonik-interceptors-interceptor-methods-transformrow"></a>\n#### <code>transformRow</code>\n\nExecuted for each row.\n\nTransforms row.\n\nUse `transformRow` to modify the query result.\n\n<a name="slonik-community-interceptors"></a>\n## Community interceptors\n\n|Name|Description|\n|---|---|\n|[`slonik-interceptor-field-name-transformation`](https://github.com/gajus/slonik-interceptor-field-name-transformation)|Transforms Slonik query result field names.|\n|[`slonik-interceptor-query-benchmarking`](https://github.com/gajus/slonik-interceptor-query-benchmarking)|Benchmarks Slonik queries.|\n|[`slonik-interceptor-query-cache`](https://github.com/gajus/slonik-interceptor-query-cache)|Caches Slonik queries.|\n|[`slonik-interceptor-query-logging`](https://github.com/gajus/slonik-interceptor-query-logging)|Logs Slonik queries.|\n|[`slonik-interceptor-query-normalisation`](https://github.com/gajus/slonik-interceptor-query-normalisation)|Normalises Slonik queries.|\n\nCheck out [`slonik-interceptor-preset`](https://github.com/gajus/slonik-interceptor-preset) for an opinionated collection of interceptors.\n\n\n<a name="slonik-recipes"></a>\n## Recipes\n\n<a name="slonik-recipes-inserting-large-number-of-rows"></a>\n### Inserting large number of rows\n\nUse [`sql.unnest`](#sqlunnest) to create a set of rows using `unnest`. Using the `unnest` approach requires only 1 variable per every column; values for each column are passed as an array, e.g.\n\n```js\nawait connection.query(sql`\n  INSERT INTO (foo, bar, baz)\n  SELECT *\n  FROM ${sql.unnest(\n    [\n      [1, 2, 3],\n      [4, 5, 6]\n    ],\n    [\n      \'int4\',\n      \'int4\',\n      \'int4\'\n    ]\n  )}\n`);\n\n```\n\nProduces:\n\n```js\n{\n  sql: \'INSERT INTO (foo, bar, baz) SELECT * FROM unnest($1::int4[], $2::int4[], $2::int4[])\',\n  values: [\n    [\n      1,\n      4\n    ],\n    [\n      2,\n      5\n    ],\n    [\n      3,\n      6\n    ]\n  ]\n}\n\n```\n\nInserting data this way ensures that the query is stable and reduces the amount of time it takes to parse the query.\n\n<a name="slonik-recipes-routing-queries-to-different-connections"></a>\n### Routing queries to different connections\n\nIf connection is initiated by a query (as opposed to a obtained explicitly using `pool#connect()`), then `beforePoolConnection` interceptor can be used to change the pool that will be used to execute the query, e.g.\n\n```js\nconst slavePool = createPool(\'postgres://slave\');\nconst masterPool = createPool(\'postgres://master\', {\n  interceptors: [\n    {\n      beforePoolConnection: (connectionContext, pool) => {\n        if (connectionContext.query && connectionContext.query.sql.includes(\'SELECT\')) {\n          return slavePool;\n        }\n\n        return pool;\n      }\n    }\n  ]\n});\n\n// This query will use `postgres://slave` connection.\nmasterPool.query(sql`SELECT 1`);\n\n// This query will use `postgres://master` connection.\nmasterPool.query(sql`UPDATE 1`);\n\n```\n\n\n<a name="slonik-sql-tag"></a>\n## <code>sql</code> tag\n\n`sql` tag serves two purposes:\n\n* It is used to construct queries with bound parameter values (see [Value placeholders](#value-placeholders)).\n* It used to generate dynamic query fragments (see [Query building](#query-building)).\n\n`sql` tag can be imported from Slonik package:\n\n```js\nimport {\n  sql\n} from \'slonik\';\n\n```\n\nSometiems it may be desirable to construct a custom instance of `sql` tag. In those cases, you can use the `createSqlTag` factory, e.g.\n\n```js\nimport {\n  createSqlTag\n} from \'slonik\';\n\n/**\n * @typedef SqlTagConfiguration\n */\n\n/**\n * @param {SqlTagConfiguration} configuration\n */\nconst sql = createSqlTag(configuration);\n\n```\n\n\n<a name="slonik-value-placeholders"></a>\n## Value placeholders\n\n<a name="slonik-value-placeholders-tagged-template-literals"></a>\n### Tagged template literals\n\nSlonik query methods can only be executed using `sql` [tagged template literal](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), e.g.\n\n```js\nimport {\n  sql\n} from \'slonik\'\n\nconnection.query(sql`\n  SELECT 1\n  FROM foo\n  WHERE bar = ${\'baz\'}\n`);\n\n```\n\nThe above is equivalent to evaluating:\n\n```sql\nSELECT 1\nFROM foo\nWHERE bar = $1\n\n```\n\nquery with \'baz\' value binding.\n\n<a name="slonik-value-placeholders-manually-constructing-the-query"></a>\n### Manually constructing the query\n\nManually constructing queries is not allowed.\n\nThere is an internal mechanism that checks to see if query was created using `sql` tagged template literal, i.e.\n\n```js\nconst query = {\n  sql: \'SELECT 1 FROM foo WHERE bar = $1\',\n  type: \'SQL\',\n  values: [\n    \'baz\'\n  ]\n};\n\nconnection.query(query);\n\n```\n\nWill result in an error:\n\n> Query must be constructed using `sql` tagged template literal.\n\nThis is a security measure designed to prevent unsafe query execution.\n\nFurthermore, a query object constructed using `sql` tagged template literal is [frozen](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) to prevent further manipulation.\n\n<a name="slonik-value-placeholders-nesting-sql"></a>\n### Nesting <code>sql</code>\n\n`sql` tagged template literals can be nested, e.g.\n\n```js\nconst query0 = sql`SELECT ${\'foo\'} FROM bar`;\nconst query1 = sql`SELECT ${\'baz\'} FROM (${query0})`;\n\n```\n\nProduces:\n\n```js\n{\n  sql: \'SELECT $1 FROM (SELECT $2 FROM bar)\',\n  values: [\n    \'baz\',\n    \'foo\'\n  ]\n}\n\n```\n\n\n<a name="slonik-query-building"></a>\n## Query building\n\nQueries are built using methods of the `sql` tagged template literal.\n\nIf this is your first time using Slonik, read [Dynamically generating SQL queries using Node.js](https://dev.to/gajus/dynamically-generating-sql-queries-using-node-js-2c1g).\n\n<a name="slonik-query-building-sql-array"></a>\n### <code>sql.array</code>\n\n```js\n(\n  values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n  memberType: TypeNameIdentifierType | SqlTokenType\n) => ArraySqlTokenType;\n\n```\n\nCreates an array value binding, e.g.\n\n```js\nawait connection.query(sql`\n  SELECT (${sql.array([1, 2, 3], \'int4\')})\n`);\n\n```\n\nProduces:\n\n```js\n{\n  sql: \'SELECT $1::"int4"[]\',\n  values: [\n    [\n      1,\n      2,\n      3\n    ]\n  ]\n}\n\n```\n\n<a name="slonik-query-building-sql-array-sql-array-membertype"></a>\n#### <code>sql.array</code> <code>memberType</code>\n\nIf `memberType` is a string (`TypeNameIdentifierType`), then it is treated as a type name identifier and will be quoted using double quotes, i.e. `sql.array([1, 2, 3], \'int4\')` is equivalent to `$1::"int4"[]`. The implication is that keywrods that are often used interchangeably with type names are not going to work, e.g. [`int4`](https://github.com/postgres/postgres/blob/69edf4f8802247209e77f69e089799b3d83c13a4/src/include/catalog/pg_type.dat#L74-L78) is a type name identifier and will work. However, [`int`](https://github.com/postgres/postgres/blob/69edf4f8802247209e77f69e089799b3d83c13a4/src/include/parser/kwlist.h#L213) is a keyword and will not work. You can either use type name identifiers or you can construct custom member using `sql` tag, e.g.\n\n```js\nawait connection.query(sql`\n  SELECT (${sql.array([1, 2, 3], sql`int[]`)})\n`);\n\n```\n\nProduces:\n\n```js\n{\n  sql: \'SELECT $1::int[]\',\n  values: [\n    [\n      1,\n      2,\n      3\n    ]\n  ]\n}\n\n```\n\n<a name="slonik-query-building-sql-array-sql-array-vs-sql-join"></a>\n#### <code>sql.array</code> vs <code>sql.join</code>\n\nUnlike `sql.join`, `sql.array` generates a stable query of a predictable length, i.e. regardless of the number of values in the array, the generated query remains the same:\n\n* Having a stable query enables [`pg_stat_statements`](https://www.postgresql.org/docs/current/pgstatstatements.html) to aggregate all query execution statistics.\n* Keeping the query length short reduces query parsing time.\n\nExample:\n\n```js\nsql`SELECT id FROM foo WHERE id IN (${sql.join([1, 2, 3], sql`, `)})`;\nsql`SELECT id FROM foo WHERE id NOT IN (${sql.join([1, 2, 3], sql`, `)})`;\n\n```\n\nIs equivalent to:\n\n```js\nsql`SELECT id FROM foo WHERE id = ANY(${sql.array([1, 2, 3], \'int4\')})`;\nsql`SELECT id FROM foo WHERE id != ALL(${sql.array([1, 2, 3], \'int4\')})`;\n\n```\n\nFurthermore, unlike `sql.join`, `sql.array` can be used with an empty array of values. In short, `sql.array` should be preferred over `sql.join` when possible.\n\n<a name="slonik-query-building-sql-binary"></a>\n### <code>sql.binary</code>\n\n```js\n(\n  data: Buffer\n) => BinarySqlTokenType;\n\n```\n\nBinds binary ([`bytea`](https://www.postgresql.org/docs/current/datatype-binary.html)) data, e.g.\n\n```js\nawait connection.query(sql`\n  SELECT ${sql.binary(Buffer.from(\'foo\'))}\n`);\n\n```\n\nProduces:\n\n```js\n{\n  sql: \'SELECT $1\',\n  values: [\n    Buffer.from(\'foo\')\n  ]\n}\n\n```\n\n<a name="slonik-query-building-sql-identifier"></a>\n### <code>sql.identifier</code>\n\n```js\n(\n  names: $ReadOnlyArray<string>\n) => IdentifierSqlTokenType;\n\n```\n\n[Delimited identifiers](https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) are created by enclosing an arbitrary sequence of characters in double-quotes ("). To create create a delimited identifier, create an `sql` tag function placeholder value using `sql.identifier`, e.g.\n\n```js\nsql`\n  SELECT 1\n  FROM ${sql.identifier([\'bar\', \'baz\'])}\n`;\n\n```\n\nProduces:\n\n```js\n{\n  sql: \'SELECT 1 FROM "bar"."bar"\',\n  values: []\n}\n\n```\n\n<a name="slonik-query-building-sql-json"></a>\n### <code>sql.json</code>\n\n```js\n(\n  value: SerializableValueType\n) => JsonSqlTokenType;\n\n```\n\nSerializes value and binds it as a JSON string literal, e.g.\n\n```js\nawait connection.query(sql`\n  SELECT (${sql.json([1, 2, 3])})\n`);\n\n```\n\nProduces:\n\n```js\n{\n  sql: \'SELECT $1\',\n  values: [\n    \'[1,2,3]\'\n  ]\n}\n\n```\n\n<a name="slonik-query-building-sql-json-difference-from-json-stringify"></a>\n#### Difference from <code>JSON.stringify</code>\n\n|Input|`sql.json`|`JSON.stringify`|\n|---|---|---|\n|`undefined`|Throws `InvalidInputError` error.|`undefined`|\n|`null`|`null`|`"null"` (string literal)|\n\n<a name="slonik-query-building-sql-join"></a>\n### <code>sql.join</code>\n\n```js\n(\n  members: $ReadOnlyArray<SqlTokenType>,\n  glue: SqlTokenType\n) => ListSqlTokenType;\n\n```\n\nConcatenates SQL expressions using `glue` separator, e.g.\n\n```js\nawait connection.query(sql`\n  SELECT ${sql.join([1, 2, 3], sql`, `)}\n`);\n\n```\n\nProduces:\n\n```js\n{\n  sql: \'SELECT $1, $2, $3\',\n  values: [\n    1,\n    2,\n    3\n  ]\n}\n\n```\n\n`sql.join` is the primary building block for most of the SQL, e.g.\n\nBoolean expressions:\n\n```js\nsql`\n  SELECT ${sql.join([1, 2], sql` AND `)}\n`\n\n// SELECT $1 AND $2\n\n```\n\nTuple:\n\n```js\nsql`\n  SELECT (${sql.join([1, 2], sql`, `)})\n`\n\n// SELECT ($1, $2)\n\n```\n\nTuple list:\n\n```js\nsql`\n  SELECT ${sql.join(\n    [\n      sql`(${sql.join([1, 2], sql`, `)})`,\n      sql`(${sql.join([3, 4], sql`, `)})`,\n    ],\n    sql`, `\n  )}\n`\n\n// SELECT ($1, $2), ($3, $4)\n\n```\n\n\n<a name="slonik-query-building-sql-unnest"></a>\n### <code>sql.unnest</code>\n\n```js\n(\n  tuples: $ReadOnlyArray<$ReadOnlyArray<PrimitiveValueExpressionType>>,\n  columnTypes: $ReadOnlyArray<string>\n): UnnestSqlTokenType;\n\n```\n\nCreates an `unnest` expressions, e.g.\n\n```js\nawait connection.query(sql`\n  SELECT bar, baz\n  FROM ${sql.unnest(\n    [\n      [1, \'foo\'],\n      [2, \'bar\']\n    ],\n    [\n      \'int4\',\n      \'text\'\n    ]\n  )} AS foo(bar, baz)\n`);\n\n```\n\nProduces:\n\n```js\n{\n  sql: \'SELECT bar, baz FROM unnest($1::int4[], $2::text[]) AS foo(bar, baz)\',\n  values: [\n    [\n      1,\n      2\n    ],\n    [\n      \'foo\',\n      \'bar\'\n    ]\n  ]\n}\n\n```\n\n\n<a name="slonik-query-methods"></a>\n## Query methods\n\n<a name="slonik-query-methods-any"></a>\n### <code>any</code>\n\nReturns result rows.\n\nExample:\n\n```js\nconst rows = await connection.any(sql`SELECT foo`);\n\n```\n\n`#any` is similar to `#query` except that it returns rows without fields information.\n\n<a name="slonik-query-methods-anyfirst"></a>\n### <code>anyFirst</code>\n\nReturns value of the first column of every row in the result set.\n\n* Throws `DataIntegrityError` if query returns multiple rows.\n\nExample:\n\n```js\nconst fooValues = await connection.anyFirst(sql`SELECT foo`);\n\n```\n\n<a name="slonik-query-methods-copyfrombinary"></a>\n### <code>copyFromBinary</code>\n\n```js\n(\n  streamQuery: TaggedTemplateLiteralInvocationType,\n  tupleList: $ReadOnlyArray<$ReadOnlyArray<any>>,\n  columnTypes: $ReadOnlyArray<TypeNameIdentifierType>\n) => Promise<null>;\n\n```\n\nCopies from a binary stream.\n\nThe binary stream is constructed using user supplied `tupleList` and `columnTypes` values.\n\nExample:\n\n```js\nconst tupleList = [\n  [\n    1,\n    \'baz\'\n  ],\n  [\n    2,\n    \'baz\'\n  ]\n];\n\nconst columnTypes = [\n  \'int4\',\n  \'text\'\n];\n\nawait connection.copyFromBinary(\n  sql`\n    COPY foo\n    (\n      id,\n      baz\n    )\n    FROM STDIN BINARY\n  `,\n  tupleList,\n  columnTypes\n);\n\n```\n\n<a name="slonik-query-methods-copyfrombinary-limitations"></a>\n#### Limitations\n\n* Tuples cannot contain `NULL` values.\n\n<a name="slonik-query-methods-copyfrombinary-implementation-notes"></a>\n#### Implementation notes\n\n`copyFromBinary` implementation is designed to minimize the query execution time at the cost of increased script memory usage and execution time. This is achieved by separating data encoding from feeding data to PostgreSQL, i.e. all data passed to `copyFromBinary` is first encoded and then fed to PostgreSQL (contrast this to using a stream with encoding transformation to feed data to PostgreSQL).\n\n<a name="slonik-query-methods-copyfrombinary-related-documentation"></a>\n#### Related documentation\n\n* [`COPY` documentation](https://www.postgresql.org/docs/current/sql-copy.html)\n\n<a name="slonik-query-methods-many"></a>\n### <code>many</code>\n\nReturns result rows.\n\n* Throws `NotFoundError` if query returns no rows.\n\nExample:\n\n```js\nconst rows = await connection.many(sql`SELECT foo`);\n\n```\n\n<a name="slonik-query-methods-manyfirst"></a>\n### <code>manyFirst</code>\n\nReturns value of the first column of every row in the result set.\n\n* Throws `NotFoundError` if query returns no rows.\n* Throws `DataIntegrityError` if query returns multiple columns.\n\nExample:\n\n```js\nconst fooValues = await connection.many(sql`SELECT foo`);\n\n```\n\n<a name="slonik-query-methods-maybeone"></a>\n### <code>maybeOne</code>\n\nSelects the first row from the result.\n\n* Returns `null` if row is not found.\n* Throws `DataIntegrityError` if query returns multiple rows.\n\nExample:\n\n```js\nconst row = await connection.maybeOne(sql`SELECT foo`);\n\n// row.foo is the result of the `foo` column value of the first row.\n\n```\n\n<a name="slonik-query-methods-maybeonefirst"></a>\n### <code>maybeOneFirst</code>\n\nReturns value of the first column from the first row.\n\n* Returns `null` if row is not found.\n* Throws `DataIntegrityError` if query returns multiple rows.\n* Throws `DataIntegrityError` if query returns multiple columns.\n\nExample:\n\n```js\nconst foo = await connection.maybeOneFirst(sql`SELECT foo`);\n\n// foo is the result of the `foo` column value of the first row.\n\n```\n\n<a name="slonik-query-methods-one"></a>\n### <code>one</code>\n\nSelects the first row from the result.\n\n* Throws `NotFoundError` if query returns no rows.\n* Throws `DataIntegrityError` if query returns multiple rows.\n\nExample:\n\n```js\nconst row = await connection.one(sql`SELECT foo`);\n\n// row.foo is the result of the `foo` column value of the first row.\n\n```\n\n> Note:\n>\n> I\'ve been asked "What makes this different from [knex.js](http://knexjs.org/) `knex(\'foo\').limit(1)`?".\n> `knex(\'foo\').limit(1)` simply generates "SELECT * FROM foo LIMIT 1" query.\n> `knex` is a query builder; it does not assert the value of the result.\n> Slonik `#one` adds assertions about the result of the query.\n\n<a name="slonik-query-methods-onefirst"></a>\n### <code>oneFirst</code>\n\nReturns value of the first column from the first row.\n\n* Throws `NotFoundError` if query returns no rows.\n* Throws `DataIntegrityError` if query returns multiple rows.\n* Throws `DataIntegrityError` if query returns multiple columns.\n\nExample:\n\n```js\nconst foo = await connection.oneFirst(sql`SELECT foo`);\n\n// foo is the result of the `foo` column value of the first row.\n\n```\n\n<a name="slonik-query-methods-query"></a>\n### <code>query</code>\n\nAPI and the result shape are equivalent to [`pg#query`](https://github.com/brianc/node-postgres).\n\nExample:\n\n```js\nawait connection.query(sql`SELECT foo`);\n\n// {\n//   command: \'SELECT\',\n//   fields: [],\n//   notices: [],\n//   rowCount: 1,\n//   rows: [\n//     {\n//       foo: \'bar\'\n//     }\n//   ]\n// }\n\n```\n\n<a name="slonik-query-methods-stream"></a>\n### <code>stream</code>\n\nStreams query results.\n\nExample:\n\n```js\nawait connection.stream(sql`SELECT foo`, (stream) => {\n  stream.on(\'data\', (datum) => {\n    datum;\n    // {\n    //   fields: [\n    //     {\n    //       name: \'foo\',\n    //       dataTypeId: 23,\n    //     }\n    //   ],\n    //   row: {\n    //     foo: \'bar\'\n    //   }\n    // }\n  });\n});\n\n```\n\nNote: Implemneted using [`pg-query-stream`](https://github.com/brianc/node-pg-query-stream).\n\n<a name="slonik-query-methods-transaction"></a>\n### <code>transaction</code>\n\n`transaction` method is used wrap execution of queries in `START TRANSACTION` and `COMMIT` or `ROLLBACK`. `COMMIT` is called if the transaction handler returns a promise that resolves; `ROLLBACK` is called otherwise.\n\n`transaction` method can be used together with `createPool` method. When used to create a transaction from an instance of a pool, a new connection is allocated for the duration of the transaction.\n\n```js\nconst result = await connection.transaction(async (transactionConnection) => {\n  await transactionConnection.query(sql`INSERT INTO foo (bar) VALUES (\'baz\')`);\n  await transactionConnection.query(sql`INSERT INTO qux (quux) VALUES (\'corge\')`);\n\n  return \'FOO\';\n});\n\nresult === \'FOO\';\n\n```\n\n<a name="slonik-query-methods-transaction-transaction-nesting"></a>\n#### Transaction nesting\n\nSlonik uses [`SAVEPOINT`](https://www.postgresql.org/docs/current/sql-savepoint.html) to automatically nest transactions, e.g.\n\n```js\nawait connection.transaction(async (t1) => {\n  await t1.query(sql`INSERT INTO foo (bar) VALUES (\'baz\')`);\n\n  return t1.transaction((t2) => {\n    return t2.query(sql`INSERT INTO qux (quux) VALUES (\'corge\')`);\n  });\n});\n\n```\n\nis equivalent to:\n\n```sql\nSTART TRANSACTION;\nINSERT INTO foo (bar) VALUES (\'baz\');\nSAVEPOINT slonik_savepoint_1;\nINSERT INTO qux (quux) VALUES (\'corge\');\nCOMMIT;\n\n```\n\nSlonik automatically rollsback to the last savepoint if a query belonging to a transaction results in an error, e.g.\n\n```js\nawait connection.transaction(async (t1) => {\n  await t1.query(sql`INSERT INTO foo (bar) VALUES (\'baz\')`);\n\n  try {\n    await t1.transaction(async (t2) => {\n      await t2.query(sql`INSERT INTO qux (quux) VALUES (\'corge\')`);\n\n      return Promise.reject(new Error(\'foo\'));\n    });\n  } catch (error) {\n\n  }\n});\n\n```\n\nis equivalent to:\n\n```sql\nSTART TRANSACTION;\nINSERT INTO foo (bar) VALUES (\'baz\');\nSAVEPOINT slonik_savepoint_1;\nINSERT INTO qux (quux) VALUES (\'corge\');\nROLLBACK TO SAVEPOINT slonik_savepoint_1;\nCOMMIT;\n\n```\n\nIf error is unhandled, then the entire transaction is rolledback, e.g.\n\n```js\nawait connection.transaction(async (t1) => {\n  await t1.query(sql`INSERT INTO foo (bar) VALUES (\'baz\')`);\n\n  await t1.transaction(async (t2) => {\n    await t2.query(sql`INSERT INTO qux (quux) VALUES (\'corge\')`);\n\n    await t1.transaction(async (t3) => {\n      await t3.query(sql`INSERT INTO uier (grault) VALUES (\'garply\')`);\n\n      return Promise.reject(new Error(\'foo\'));\n    });\n  });\n});\n\n```\n\nis equivalent to:\n\n```sql\nSTART TRANSACTION;\nINSERT INTO foo (bar) VALUES (\'baz\');\nSAVEPOINT slonik_savepoint_1;\nINSERT INTO qux (quux) VALUES (\'corge\');\nSAVEPOINT slonik_savepoint_2;\nINSERT INTO uier (grault) VALUES (\'garply\');\nROLLBACK TO SAVEPOINT slonik_savepoint_2;\nROLLBACK TO SAVEPOINT slonik_savepoint_1;\nROLLBACK;\n\n```\n\n\n<a name="slonik-error-handling"></a>\n## Error handling\n\nAll Slonik errors extend from `SlonikError`, i.e. You can catch Slonik specific errors using the following logic.\n\n```js\nimport {\n  SlonikError\n} from \'slonik\';\n\ntry {\n  await query();\n} catch (error) {\n  if (error instanceof SlonikError) {\n    // This error is thrown by Slonik.\n  }\n}\n\n```\n\n<a name="slonik-error-handling-original-node-postgres-error"></a>\n### Original <code>node-postgres</code> error\n\nWhen error originates from `node-postgres`, the original error is available under `originalError` property.\n\nThis propery is exposed for debugging purposes only. Do not use it for conditional checks \xe2\x80\x93\xc2\xa0it can change.\n\nIf you require to extract meta-data about a specific type of error (e.g. contraint violation name), raise a GitHub issue describing your use case.\n\n<a name="slonik-error-handling-handling-backendterminatederror"></a>\n### Handling <code>BackendTerminatedError</code>\n\n`BackendTerminatedError` is thrown when the backend is terminated by the user, i.e. [`pg_terminate_backend`](https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-SIGNAL).\n\n`BackendTerminatedError` must be handled at the connection level, i.e.\n\n```js\nawait pool.connect(async (connection0) => {\n  try {\n    await pool.connect(async (connection1) => {\n      const backendProcessId = await connection1.oneFirst(sql`SELECT pg_backend_pid()`);\n\n      setTimeout(() => {\n        connection0.query(sql`SELECT pg_cancel_backend(${backendProcessId})`)\n      }, 2000);\n\n      try {\n        await connection1.query(sql`SELECT pg_sleep(30)`);\n      } catch (error) {\n        // This code will not be executed.\n      }\n    });\n  } catch (error) {\n    if (error instanceof BackendTerminatedError) {\n      // Handle backend termination.\n    } else {\n      throw error;\n    }\n  }\n});\n\n```\n\n<a name="slonik-error-handling-handling-checkintegrityconstraintviolationerror"></a>\n### Handling <code>CheckIntegrityConstraintViolationError</code>\n\n`CheckIntegrityConstraintViolationError` is thrown when PostgreSQL responds with [`check_violation`](https://www.postgresql.org/docs/9.4/static/errcodes-appendix.html) (`23514`) error.\n\n<a name="slonik-error-handling-handling-connectionerror"></a>\n### Handling <code>ConnectionError</code>\n\n`ConnectionError` is thrown when connection cannot be established to the PostgreSQL server.\n\n<a name="slonik-error-handling-handling-dataintegrityerror"></a>\n### Handling <code>DataIntegrityError</code>\n\nTo handle the case where the data result does not match the expectations, catch `DataIntegrityError` error.\n\n```js\nimport {\n  NotFoundError\n} from \'slonik\';\n\nlet row;\n\ntry {\n  row = await connection.one(sql`SELECT foo`);\n} catch (error) {\n  if (error instanceof DataIntegrityError) {\n    console.error(\'There is more than one row matching the select criteria.\');\n  } else {\n    throw error;\n  }\n}\n\n```\n\n<a name="slonik-error-handling-handling-foreignkeyintegrityconstraintviolationerror"></a>\n### Handling <code>ForeignKeyIntegrityConstraintViolationError</code>\n\n`ForeignKeyIntegrityConstraintViolationError` is thrown when PostgreSQL responds with [`foreign_key_violation`](https://www.postgresql.org/docs/9.4/static/errcodes-appendix.html) (`23503`) error.\n\n<a name="slonik-error-handling-handling-notfounderror"></a>\n### Handling <code>NotFoundError</code>\n\nTo handle the case where query returns less than one row, catch `NotFoundError` error.\n\n```js\nimport {\n  NotFoundError\n} from \'slonik\';\n\nlet row;\n\ntry {\n  row = await connection.one(sql`SELECT foo`);\n} catch (error) {\n  if (!(error instanceof NotFoundError)) {\n    throw error;\n  }\n}\n\nif (row) {\n  // row.foo is the result of the `foo` column value of the first row.\n}\n\n```\n\n<a name="slonik-error-handling-handling-notnullintegrityconstraintviolationerror"></a>\n### Handling <code>NotNullIntegrityConstraintViolationError</code>\n\n`NotNullIntegrityConstraintViolationError` is thrown when PostgreSQL responds with [`not_null_violation`](https://www.postgresql.org/docs/9.4/static/errcodes-appendix.html) (`23502`) error.\n\n<a name="slonik-error-handling-handling-statementcancellederror"></a>\n### Handling <code>StatementCancelledError</code>\n\n`StatementCancelledError` is thrown when a query is cancelled by the user (i.e. [`pg_cancel_backend`](https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-SIGNAL)) or in case of a timeout.\n\nIt should be safe to use the same connection if `StatementCancelledError` is handled, e.g.\n\n```js\nawait pool.connect(async (connection0) => {\n  await pool.connect(async (connection1) => {\n    const backendProcessId = await connection1.oneFirst(sql`SELECT pg_backend_pid()`);\n\n    setTimeout(() => {\n      connection0.query(sql`SELECT pg_cancel_backend(${backendProcessId})`)\n    }, 2000);\n\n    try {\n      await connection1.query(sql`SELECT pg_sleep(30)`);\n    } catch (error) {\n      if (error instanceof StatementCancelledError) {\n        // Safe to continue using the same connection.\n      } else {\n        throw error;\n      }\n    }\n  });\n});\n\n```\n\n<a name="slonik-error-handling-handling-statementtimeouterror"></a>\n### Handling <code>StatementTimeoutError</code>\n\n`StatementTimeoutError` inherits from `StatementCancelledError` and it is called only in case of a timeout.\n\n<a name="slonik-error-handling-handling-uniqueintegrityconstraintviolationerror"></a>\n### Handling <code>UniqueIntegrityConstraintViolationError</code>\n\n`UniqueIntegrityConstraintViolationError` is thrown when PostgreSQL responds with [`unique_violation`](https://www.postgresql.org/docs/9.4/static/errcodes-appendix.html) (`23505`) error.\n\n\n<a name="slonik-types"></a>\n## Types\n\nThis package is using [Flow](https://flow.org/) types.\n\nRefer to [`./src/types.js`](./src/types.js).\n\nThe public interface exports the following types:\n\n* `DatabaseConnectionType`\n* `DatabasePoolConnectionType`\n* `DatabaseSingleConnectionType`\n\nUse these types to annotate `connection` instance in your code base, e.g.\n\n```js\n// @flow\n\nimport type {\n  DatabaseConnectionType\n} from \'slonik\';\n\nexport default async (\n  connection: DatabaseConnectionType,\n  code: string\n): Promise<number> => {\n  const countryId = await connection.oneFirst(sql`\n    SELECT id\n    FROM country\n    WHERE code = ${code}\n  `);\n\n  return countryId;\n};\n\n```\n\n\n<a name="slonik-debugging"></a>\n## Debugging\n\n<a name="slonik-debugging-logging"></a>\n### Logging\n\nSlonik uses [roarr](https://github.com/gajus/roarr) to log queries.\n\nTo enable logging, define `ROARR_LOG=true` environment variable.\n\nBy default, Slonik logs only connection events, e.g. when connection is created, connection is acquired and notices.\n\nQuery-level logging can be added using [`slonik-interceptor-query-logging`](https://github.com/gajus/slonik-interceptor-query-logging) interceptor.\n\n<a name="slonik-debugging-capture-stack-trace"></a>\n### Capture stack trace\n\nNote: Requires [`slonik-interceptor-query-logging`](https://github.com/gajus/slonik-interceptor-query-logging).\n\nEnabling `captureStackTrace` configuration will create a stack trace before invoking the query and include the stack trace in the logs, e.g.\n\n```json\n{"context":{"package":"slonik","namespace":"slonik","logLevel":20,"executionTime":"357 ms","queryId":"01CV2V5S4H57KCYFFBS0BJ8K7E","rowCount":1,"sql":"SELECT schedule_cinema_data_task();","stackTrace":["/Users/gajus/Documents/dev/applaudience/data-management-program/node_modules/slonik/dist:162:28","/Users/gajus/Documents/dev/applaudience/data-management-program/node_modules/slonik/dist:314:12","/Users/gajus/Documents/dev/applaudience/data-management-program/node_modules/slonik/dist:361:20","/Users/gajus/Documents/dev/applaudience/data-management-program/node_modules/slonik/dist/utilities:17:13","/Users/gajus/Documents/dev/applaudience/data-management-program/src/bin/commands/do-cinema-data-tasks.js:59:21","/Users/gajus/Documents/dev/applaudience/data-management-program/src/bin/commands/do-cinema-data-tasks.js:590:45","internal/process/next_tick.js:68:7"],"values":[]},"message":"query","sequence":4,"time":1540915127833,"version":"1.0.0"}\n{"context":{"package":"slonik","namespace":"slonik","logLevel":20,"executionTime":"66 ms","queryId":"01CV2V5SGS0WHJX4GJN09Z3MTB","rowCount":1,"sql":"SELECT cinema_id \\"cinemaId\\", target_data \\"targetData\\" FROM cinema_data_task WHERE id = ?","stackTrace":["/Users/gajus/Documents/dev/applaudience/data-management-program/node_modules/slonik/dist:162:28","/Users/gajus/Documents/dev/applaudience/data-management-program/node_modules/slonik/dist:285:12","/Users/gajus/Documents/dev/applaudience/data-management-program/node_modules/slonik/dist/utilities:17:13","/Users/gajus/Documents/dev/applaudience/data-management-program/src/bin/commands/do-cinema-data-tasks.js:603:26","internal/process/next_tick.js:68:7"],"values":[17953947]},"message":"query","sequence":5,"time":1540915127902,"version":"1.0.0"}\n\n```\n\nUse [`@roarr/cli`](https://github.com/gajus/roarr-cli) to pretty-print the output.\n\n![Log Roarr pretty-print output.](./.README/log-roarr-pretty-print-output.png)\n\n\n<a name="slonik-syntax-highlighting"></a>\n## Syntax Highlighting\n\n<a name="slonik-syntax-highlighting-atom-syntax-highlighting-plugin"></a>\n### Atom Syntax Highlighting Plugin\n\nUsing [Atom](https://atom.io/) IDE you can leverage the [`language-babel`](https://github.com/gandm/language-babel) package in combination with the [`language-sql`](https://github.com/atom/language-sql) to enable highlighting of the SQL strings in the codebase.\n\n![Syntax highlighting in Atom](./.README/atom-syntax-highlighting.png)\n\nTo enable highlighting, you need to:\n\n1. Install `language-babel` and `language-sql` packages.\n1. Configure `language-babel` "JavaScript Tagged Template Literal Grammar Extensions" setting to use `language-sql` to highlight template literals with `sql` tag (configuration value: `sql:source.sql`).\n1. Use [`sql` helper to construct the queries](https://github.com/gajus/slonik#tagged-template-literals).\n\nFor more information, refer to the [JavaScript Tagged Template Literal Grammar Extensions](https://github.com/gandm/language-babel#javascript-tagged-template-literal-grammar-extensions) documentation of `language-babel` package.\n\n<a name="slonik-syntax-highlighting-vs-code-syntax-highlighting-extension"></a>\n### VS Code Syntax Highlighting Extension\n\nThe [`vscode-sql-template-literal` extension](https://marketplace.visualstudio.com/items?itemName=forbeslindesay.vscode-sql-template-literal) provides syntax highlighting for VS Code:\n![Syntax highlighting in VS Code](./.README/vscode-syntax-highlighting.png)'