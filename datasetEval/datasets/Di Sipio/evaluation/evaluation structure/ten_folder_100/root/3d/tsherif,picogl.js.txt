b'PicoGL.js\n=========\n\n[![Build Status](https://img.shields.io/travis/tsherif/picogl.js)](https://travis-ci.org/tsherif/picogl.js) [![Coverage Status](https://img.shields.io/coveralls/github/tsherif/picogl.js)](https://coveralls.io/github/tsherif/picogl.js?branch=master) [![GZIP size](https://badge-size.herokuapp.com/tsherif/picogl.js/master/build/picogl.min.js.svg?compression=gzip)](https://github.com/tsherif/picogl.js/blob/master/build/picogl.min.js) [![Gitter](https://img.shields.io/gitter/room/picogl.js/general.svg)](https://gitter.im/picogl-js/general) [![License](https://img.shields.io/github/license/tsherif/picogl.js.svg)](https://github.com/tsherif/picogl.js/blob/master/LICENSE) [![NPM](https://img.shields.io/npm/v/picogl.svg)](https://www.npmjs.com/package/picogl)\n\n**[API Docs](https://tsherif.github.io/picogl.js/docs/)** | **[Tutorial](https://tsherif.wordpress.com/2017/07/26/webgl-2-development-with-picogl-js/)** | **[Chat](https://gitter.im/picogl-js/general)**\n\nPicoGL.js is a minimal WebGL 2 rendering library. It\'s meant for developers who understand the WebGL 2 rendering pipeline and want to use it, but with a more convenient API. Typical usage of PicoGL.js will involve creating programs, vertex buffers, vertex arrays, uniform buffers, framebuffers, textures, transform feedbacks, and combining them into draw calls.\n\n```JavaScript\n\n    // Create App which manages all GL state\n    let app = PicoGL.createApp(canvas)\n    .clearColor(0.0, 0.0, 0.0, 1.0);\n    \n    // Create Program\n    // Shaders are compiled in parallel if supported by the platform.\n    app.createPrograms([vertexShaderSource, fragmentShaderSource]).then(([program]) => {\n        // Create a buffer of vertex attributes\n        let positions = app.createVertexBuffer(PicoGL.FLOAT, 2, new Float32Array([\n            -0.5, -0.5,\n             0.5, -0.5,\n             0.0,  0.5\n        ]));\n\n        // VertexArray manages attribute buffer state\n        let vertexArray = app.createVertexArray()\n        .vertexAttributeBuffer(0, positions);\n\n        // UniformBuffer allows multiple uniforms to be bound\n        // as a single block of memory.\n        // First part defines layout of the UniformBuffer.\n        // Second part updates values.\n        let uniformBuffer = app.createUniformBuffer([\n            PicoGL.FLOAT_VEC4,\n            PicoGL.FLOAT_VEC4\n        ])\n        .set(0, new Float32Array([1.0, 0.0, 0.0, 0.3]))\n        .set(1, new Float32Array([0.0, 0.0, 1.0, 0.7]))\n        .update();\n\n        // Create DrawCall from Program and VertexArray (both required),\n        // and a UniformBuffer.\n        let drawCall = app.createDrawCall(program, vertexArray)\n        .uniformBlock("ColorUniforms", uniformBuffer);\n\n        // Draw\n        app.clear();\n        drawCall.draw();\n    });\n\n``` \n\nNote that PicoGL.js is **not** a scene graph library. There are no objects, hierarchies, transforms, materials, etc. It has been designed only to make management of GPU state more convenient. Its conceptual model maps fairly directly to the constructs one deals with when writing directly with the WebGL 2 API. The only higher-level construct is the **draw call**, which manages sets of related lower-level constructs.\n\n\n\nUsage\n-----\nPicoGL.js can be used directly by downloading the [built source](https://tsherif.github.io/picogl.js/build/picogl.min.js) and loading it via a script tag:\n\n```HTML\n    <script src="js/picogl.min.js"></script>\n```\n\nor it can be installed via [npm](https://www.npmjs.com/package/picogl):\n\n```bash\n    npm install picogl\n```\n\nand loaded via ES6-style `import`:   \n\n```JavaScript\n    import PicoGL from "picogl";\n```\n\nFeatures\n--------\n\nPicoGL.js simplifies usage of some more complex WebGL 2 features, such as multiple render targets, uniform buffers, transform feedback and instanced drawing.\n\n**Multiple Render Targets**\n\n```JavaScript\n    let app = PicoGL.createApp(canvas)\n    .clearColor(0.0, 0.0, 0.0, 1.0);\n\n\n    // Texture render targets\n    let colorTarget0 = app.createTexture2D(app.width, app.height);\n    let colorTarget1 = app.createTexture2D(app.width, app.height);\n    let depthTarget = app.createTexture2D(app.width, app.height, {\n        internalFormat: PicoGL.DEPTH_COMPONENT16\n    });\n\n\n    // Create framebuffer with color targets at attachments \n    // 0 and 1, and a depth target.\n    let framebuffer = app.createFramebuffer()\n    .colorTarget(0, colorTarget0)\n    .colorTarget(1, colorTarget1)\n    .depthTarget(depthTarget);\n    \n    // ... set up programs and vertex arrays for offscreen and\n    // main draw passes...\n    \n    let offscreenDrawCall = app.createDrawCall(offscreenProgram, offscreenVAO);\n\n    // Bind main program texture samplers to framebuffer targets\n    let mainDrawCall = app.createDrawCall(mainProgram, mainVAO)\n    .texture("texture1", framebuffer.colorAttachments[0])\n    .texture("texture2", framebuffer.colorAttachments[1])\n    .texture("depthTexture", framebuffer.depthAttachment);\n\n    // Offscreen pass\n    app.drawFramebuffer(framebuffer).clear();\n    offscreenDrawCall.draw();\n    \n    // Main draw pass\n    app.defaultDrawFramebuffer().clear()\n    mainDrawCall.draw();\n```\n\n**Uniform Buffers**\n\n```JavaScript\n    let app = PicoGL.createApp(canvas)\n    .clearColor(0.0, 0.0, 0.0, 1.0);\n    \n    // ... set up program and vertex array...\n\n    // Layout is std140\n    let uniformBuffer = app.createUniformBuffer([\n        PicoGL.FLOAT_MAT4,\n        PicoGL.FLOAT_VEC4,\n        PicoGL.INT_VEC4,\n        PicoGL.FLOAT\n    ])\n    .set(0, matrix)\n    .set(1, float32Vector)\n    .set(2, int32Vector)\n    .set(3, scalar)\n    .update();      // Data only sent to GPU when update() is called\n\n    let drawCall = app.createDrawCall(program, vertexArray)\n    .uniformBlock("UniformBlock", uniformBuffer);\n```\n\n**Transform Feedback**\n\n```JavaScript\n    let app = PicoGL.createApp(canvas)\n    .clearColor(0.0, 0.0, 0.0, 1.0);\n\n    // Last argument is transform feedback varyings\n    app.createPrograms([vertexShaderSource, fragmentShaderSource, ["vPosition"]]).then(([program]) => {\n        let positions1 = app.createVertexBuffer(PicoGL.FLOAT, 2, new Float32Array([\n            -0.5, -0.5,\n             0.5, -0.5,\n             0.0,  0.5\n        ]));\n        let vertexArray = app.createVertexArray()\n        .vertexAttributeBuffer(0, positions1);\n\n        // Empty destination buffer of 6 floats\n        let positions2 = app.createVertexBuffer(PicoGL.FLOAT, 2, 6);  \n\n        // Capture transform results into positions2 buffer\n        let transformFeedback = app.createTransformFeedback()\n        .feedbackBuffer(0, positions2);\n\n        let drawCall = app.createDrawCall(program, vertexArray)\n        .transformFeedback(transformFeedback);\n\n        app.clear();\n        drawCall.draw();\n    });\n``` \n\n**Instanced Drawing**\n\n```JavaScript\n    let app = PicoGL.createApp(canvas)\n    .clearColor(0.0, 0.0, 0.0, 1.0);\n\n    // The starting positions of the triangle. Each pair of coordinates\n    // will be passed per-vertex\n    let positions = app.createVertexBuffer(PicoGL.FLOAT, 2, new Float32Array([\n        -0.3, -0.3,\n         0.3, -0.3,\n         0.0,  0.3\n    ]));\n\n    // This is an instance buffer meaning each pair of numbers will be passed\n    // per-instance, rather than per-vertex\n    let offsets = app.createVertexBuffer(PicoGL.FLOAT, 2, new Float32Array([\n        -0.5, 0.0,\n         0.0, 0.2,\n         0.5, 0.0\n    ]));\n\n    // This vertex array is set up to draw 3 instanced triangles \n    // with the offsets given above\n    let vertexArray = app.createVertexArray()\n    .vertexAttributeBuffer(0, positions); // Pass positions per-vertex\n    .instanceAttributeBuffer(1, offset); // Pass offsets per-instance\n```\n'