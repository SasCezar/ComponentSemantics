b'<h2>What is it ?</h2>\n<p>\n    Shaders are the next front-end web developpment big thing, with the ability to create very powerful 3D interactions and animations. A lot of very good javascript libraries already handle WebGL but with most of them it\'s kind of a headache to position your meshes relative to the DOM elements of your web page.\n</p>\n<p>\n    curtains.js was created with just that issue in mind. It is a small vanilla WebGL javascript library that converts HTML elements containing images and videos into 3D WebGL textured planes, allowing you to animate them via shaders.<br />\n    You can define each plane size and position via CSS, which makes it super easy to add WebGL responsive planes all over your pages.\n</p>\n<p style="text-align: center;">\n    <img src="https://github.com/martinlaxenaire/curtainsjs/blob/master/images/promo.gif" alt="curtains.js demo gif" width="300" height="225" />\n</p>\n<h2>Knowledge and technical requirements</h2>\n<p>\n    It is easy to use but you will of course have to possess good basics of HTML, CSS and javascript.\n</p>\n<p>\n    If you\'ve never heard about shaders, you may want to learn a bit more about them on <a href="https://thebookofshaders.com/" title="The Book of Shaders" >The Book of Shaders</a> for example. You will have to understand what are the vertex and fragment shaders, the use of uniforms as well as the GLSL syntax basics.\n</p>\n<h2>Installation</h2>\n<div>\n    In a browser:\n    \n```html\n<script src="curtains.min.js"></script>\n```\n\n</div>\n<div>\n    Using npm:\n\n```\nnpm i curtainsjs\n```\n\n</div>\n<div>\n    Load ES module:\n\n```javascript\nimport {Curtains} from \'curtainsjs\';\n```\n\n</div>\n<h2>Documentation</h2>\n<a href="https://www.martin-laxenaire.fr/libs/curtainsjs/get-started.html" title="Getting started" target="_blank">Getting started</a><br />\n<a href="https://www.martin-laxenaire.fr/libs/curtainsjs/documentation.html" title="API docs" target="_blank">API docs</a><br />\n<p>\n    <a href="https://www.martin-laxenaire.fr/libs/curtainsjs/index.html#examples">Examples</a>\n</p>\n\n<h2>Basic example</h2>\n\n<h3>HTML</h3>\n\n```html\n<body>\n    <!-- div that will hold our WebGL canvas -->\n    <div id="canvas"></div>\n    \n    <!-- div used to create our plane -->\n    <div class="plane">\n    \n        <!-- image that will be used as texture by our plane -->\n        <img src="path/to/my-image.jpg" />\n    </div>\n    \n</body>\n```\n\n<h3>CSS</h3>\n\n```css\nbody {\n    /* make the body fits our viewport */\n    position: relative;\n    width: 100%;\n    height: 100vh;\n    margin: 0;\n    overflow: hidden;\n}\n#canvas {\n    /* make the canvas wrapper fits the document */\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n}\n.plane {\n    /* define the size of your plane */\n    width: 80%;\n    height: 80vh;\n    margin: 10vh auto;\n}\n.plane img {\n    /* hide the img element */\n    display: none;\n}\n```\n\n<h3>Javascript</h3>\n\n```javascript\nwindow.addEventListener("load", function() {\n    // set up our WebGL context and append the canvas to our wrapper\n    var curtains = new Curtains({\n        container: "canvas"\n    });\n    \n    // get our plane element\n    var planeElement = document.getElementsByClassName("plane")[0];\n    \n    // set our initial parameters (basic uniforms)\n    var params = {\n        vertexShaderID: "plane-vs", // our vertex shader ID\n        fragmentShaderID: "plane-fs", // our fragment shader ID\n        uniforms: {\n            time: {\n                name: "uTime", // uniform name that will be passed to our shaders\n                type: "1f", // this means our uniform is a float\n                value: 0,\n            },\n        },\n    };\n    \n    // create our plane\n    var plane = curtains.addPlane(planeElement, params);\n    \n    // if our plane has been successfully created\n    if(plane) {\n        plane.onRender(function() {\n            // use the onRender method of our plane fired at each requestAnimationFrame call\n            plane.uniforms.time.value++; // update our time uniform value\n        });\n    }\n    \n});\n```\n\n<h3>Shaders</h3>\n\n<h4>Vertex shader</h4>\n\n```glsl\n<script id="plane-vs" type="x-shader/x-vertex">\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    // those are the mandatory attributes that the lib sets\n    attribute vec3 aVertexPosition;\n    attribute vec2 aTextureCoord;\n    \n    // those are mandatory uniforms that the lib sets and that contain our model view and projection matrix\n    uniform mat4 uMVMatrix;\n    uniform mat4 uPMatrix;\n    \n    // our texture matrix that will handle image cover\n    uniform mat4 uTextureMatrix0;\n    \n    // pass your vertex and texture coords to the fragment shader\n    varying vec3 vVertexPosition;\n    varying vec2 vTextureCoord;\n    \n    void main() {\n        vec3 vertexPosition = aVertexPosition;\n        \n        gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);\n        \n        // set the varyings\n        // here we use our texture matrix to calculate the accurate texture coords\n        vTextureCoord = (uTextureMatrix0 * vec4(aTextureCoord, 0.0, 1.0)).xy;\n        vVertexPosition = vertexPosition;\n    }\n</script> \n```\n\n<h4>Fragment shader</h4>\n\n```glsl\n<script id="plane-fs" type="x-shader/x-fragment">\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    // get our varyings\n    varying vec3 vVertexPosition;\n    varying vec2 vTextureCoord;\n    \n    // the uniform we declared inside our javascript\n    uniform float uTime;\n    \n    // our texture sampler (default name, to use a different name please refer to the documentation)\n    uniform sampler2D uSampler0;\n    \n    void main() {\n        // get our texture coords from our varying\n        vec2 textureCoord = vTextureCoord;\n        \n        // displace our pixels along the X axis based on our time uniform\n        // textures coords are ranging from 0.0 to 1.0 on both axis\n        textureCoord.x += sin(textureCoord.y * 25.0) * cos(textureCoord.x * 25.0) * (cos(uTime / 50.0)) / 25.0;\n        \n        // map our texture with the texture matrix coords\n        gl_FragColor = texture2D(uSampler0, textureCoord);\n    }\n</script> \n```'