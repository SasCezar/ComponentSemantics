b'# tinyobjloader\n\n[![Join the chat at https://gitter.im/syoyo/tinyobjloader](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/syoyo/tinyobjloader?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n[![Build Status](https://travis-ci.org/syoyo/tinyobjloader.svg)](https://travis-ci.org/syoyo/tinyobjloader)\n\n[![AZ Build Status](https://dev.azure.com/syoyo/lte%20oss/_apis/build/status/syoyo.tinyobjloader?branchName=master)](https://dev.azure.com/syoyo/lte%20oss/_build/latest?definitionId=2&branchName=master)\n\n[![AppVeyor Build status](https://ci.appveyor.com/api/projects/status/tlb421q3t2oyobcn/branch/master?svg=true)](https://ci.appveyor.com/project/syoyo/tinyobjloader/branch/master)\n\n[![Coverage Status](https://coveralls.io/repos/github/syoyo/tinyobjloader/badge.svg?branch=master)](https://coveralls.io/github/syoyo/tinyobjloader?branch=master)\n\n[![Download](https://api.bintray.com/packages/conan/conan-center/tinyobjloader%3A_/images/download.svg)](https://bintray.com/conan/conan-center/tinyobjloader%3A_/_latestVersion)\n\nTiny but powerful single file wavefront obj loader written in C++03. No dependency except for C++ STL. It can parse over 10M polygons with moderate memory and time.\n\n`tinyobjloader` is good for embedding .obj loader to your (global illumination) renderer ;-)\n\nIf you are looking for C89 version, please see https://github.com/syoyo/tinyobjloader-c .\n\nNotice!\n-------\n\nWe have released new version v1.0.0 on 20 Aug, 2016.\nOld version is available as `v0.9.x` branch https://github.com/syoyo/tinyobjloader/tree/v0.9.x\n\n## What\'s new\n\n* 18 May, 2019 : Python binding!(See `python` folder. Also see https://pypi.org/project/tinyobjloader/)\n* 14 Apr, 2019 : Bump version v2.0.0 rc0. New C++ API and python bindings!(1.x API still exists for backward compatibility)\n* 20 Aug, 2016 : Bump version v1.0.0. New data structure and API!\n\n## Requirements\n\n* C++03 compiler\n\n### Old version\n\nPrevious old version is available in `v0.9.x` branch.\n\n## Example\n\n![Rungholt](images/rungholt.jpg)\n\ntinyobjloader can successfully load 6M triangles Rungholt scene.\nhttp://casual-effects.com/data/index.html\n\n![](images/sanmugel.png)\n\n* [examples/viewer/](examples/viewer) OpenGL .obj viewer\n* [examples/callback_api/](examples/callback_api/) Callback API example\n* [examples/voxelize/](examples/voxelize/) Voxelizer example\n\n## Use case\n\nTinyObjLoader is successfully used in ...\n\n### New version(v1.0.x)\n\n* Double precision support through `TINYOBJLOADER_USE_DOUBLE` thanks to noma\n* Loading models in Vulkan Tutorial https://vulkan-tutorial.com/Loading_models\n* .obj viewer with Metal https://github.com/middlefeng/NuoModelViewer/tree/master\n* Vulkan Cookbook https://github.com/PacktPublishing/Vulkan-Cookbook\n* cudabox: CUDA Solid Voxelizer Engine https://github.com/gaspardzoss/cudavox\n* Drake: A planning, control, and analysis toolbox for nonlinear dynamical systems https://github.com/RobotLocomotion/drake\n* VFPR - a Vulkan Forward Plus Renderer : https://github.com/WindyDarian/Vulkan-Forward-Plus-Renderer\n* glslViewer: https://github.com/patriciogonzalezvivo/glslViewer\n* Lighthouse2: https://github.com/jbikker/lighthouse2\n* rayrender(an open source R package for raytracing scenes in created in R): https://github.com/tylermorganwall/rayrender\n* liblava - A modern C++ and easy-to-use framework for the Vulkan API. [MIT]: https://github.com/liblava/liblava\n* Your project here! (Letting us know via github issue is welcome!)\n\n### Old version(v0.9.x)\n\n* bullet3 https://github.com/erwincoumans/bullet3\n* pbrt-v2 https://github.com/mmp/pbrt-v2\n* OpenGL game engine development http://swarminglogic.com/jotting/2013_10_gamedev01\n* mallie https://lighttransport.github.io/mallie\n* IBLBaker (Image Based Lighting Baker). http://www.derkreature.com/iblbaker/\n* Stanford CS148 http://web.stanford.edu/class/cs148/assignments/assignment3.pdf\n* Awesome Bump http://awesomebump.besaba.com/about/\n* sdlgl3-wavefront OpenGL .obj viewer https://github.com/chrisliebert/sdlgl3-wavefront\n* pbrt-v3 https://github.com/mmp/pbrt-v3\n* cocos2d-x https://github.com/cocos2d/cocos2d-x/\n* Android Vulkan demo https://github.com/SaschaWillems/Vulkan\n* voxelizer https://github.com/karimnaaji/voxelizer\n* Probulator https://github.com/kayru/Probulator\n* OptiX Prime baking https://github.com/nvpro-samples/optix_prime_baking\n* FireRays SDK https://github.com/GPUOpen-LibrariesAndSDKs/FireRays_SDK\n* parg, tiny C library of various graphics utilities and GL demos https://github.com/prideout/parg\n* Opengl unit of ChronoEngine https://github.com/projectchrono/chrono-opengl\n* Point Based Global Illumination on modern GPU https://pbgi.wordpress.com/code-source/\n* Fast OBJ file importing and parsing in CUDA http://researchonline.jcu.edu.au/42515/1/2015.CVM.OBJCUDA.pdf\n* Sorted Shading for Uni-Directional Pathtracing by Joshua Bainbridge https://nccastaff.bournemouth.ac.uk/jmacey/MastersProjects/MSc15/02Josh/joshua_bainbridge_thesis.pdf\n* GeeXLab http://www.geeks3d.com/hacklab/20160531/geexlab-0-12-0-0-released-for-windows/\n\n\n## Features\n\n* Group(parse multiple group name)\n* Vertex\n  * Vertex color(as an extension: https://blender.stackexchange.com/questions/31997/how-can-i-get-vertex-painted-obj-files-to-import-into-blender)\n* Texcoord\n* Normal\n* Material\n  * Unknown material attributes are returned as key-value(value is string) map.\n* Crease tag(\'t\'). This is OpenSubdiv specific(not in wavefront .obj specification)\n* PBR material extension for .MTL. Its proposed here: http://exocortex.com/blog/extending_wavefront_mtl_to_support_pbr\n* Callback API for custom loading.\n* Double precision support(for HPC application).\n* Smoothing group\n* Python binding : See `python` folder.\n  * Precompiled binary(manylinux1-x86_64 only) is hosted at pypi https://pypi.org/project/tinyobjloader/)\n\n### Primitives\n\n* [x] face(`f`)\n* [x] lines(`l`)\n* [ ] points(`p`)\n* [ ] curve\n* [ ] 2D curve\n* [ ] surface.\n* [ ] Free form curve/surfaces\n\n\n## TODO\n\n* [ ] Fix obj_sticker example.\n* [ ] More unit test codes.\n* [x] Texture options\n\n## License\n\nTinyObjLoader is licensed under MIT license.\n\n### Third party licenses.\n\n* pybind11 : BSD-style license.\n\n## Usage\n\n### Installation\n\nOne option is to simply copy the header file into your project and to make sure that `TINYOBJLOADER_IMPLEMENTATION` is defined exactly once.\n\nTinyobjlaoder is also available as a [conan package](https://bintray.com/conan/conan-center/tinyobjloader%3A_/_latestVersion). Conan integrates with many build systems and lets you avoid manual dependency installation. Their [documentation](https://docs.conan.io/en/latest/getting_started.html) is a great starting point.\n\n### Data format\n\n`attrib_t` contains single and linear array of vertex data(position, normal and texcoord).\n\n```\nattrib_t::vertices => 3 floats per vertex\n\n       v[0]        v[1]        v[2]        v[3]               v[n-1]\n  +-----------+-----------+-----------+-----------+      +-----------+\n  | x | y | z | x | y | z | x | y | z | x | y | z | .... | x | y | z |\n  +-----------+-----------+-----------+-----------+      +-----------+\n\nattrib_t::normals => 3 floats per vertex\n\n       n[0]        n[1]        n[2]        n[3]               n[n-1]\n  +-----------+-----------+-----------+-----------+      +-----------+\n  | x | y | z | x | y | z | x | y | z | x | y | z | .... | x | y | z |\n  +-----------+-----------+-----------+-----------+      +-----------+\n\nattrib_t::texcoords => 2 floats per vertex\n\n       t[0]        t[1]        t[2]        t[3]               t[n-1]\n  +-----------+-----------+-----------+-----------+      +-----------+\n  |  u  |  v  |  u  |  v  |  u  |  v  |  u  |  v  | .... |  u  |  v  |\n  +-----------+-----------+-----------+-----------+      +-----------+\n\nattrib_t::colors => 3 floats per vertex(vertex color. optional)\n\n       c[0]        c[1]        c[2]        c[3]               c[n-1]\n  +-----------+-----------+-----------+-----------+      +-----------+\n  | x | y | z | x | y | z | x | y | z | x | y | z | .... | x | y | z |\n  +-----------+-----------+-----------+-----------+      +-----------+\n\n```\n\nEach `shape_t::mesh_t` does not contain vertex data but contains array index to `attrib_t`.\nSee `loader_example.cc` for more details.\n\n\n```\n\nmesh_t::indices => array of vertex indices.\n\n  +----+----+----+----+----+----+----+----+----+----+     +--------+\n  | i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7 | i8 | i9 | ... | i(n-1) |\n  +----+----+----+----+----+----+----+----+----+----+     +--------+\n\nEach index has an array index to attrib_t::vertices, attrib_t::normals and attrib_t::texcoords.\n\nmesh_t::num_face_vertices => array of the number of vertices per face(e.g. 3 = triangle, 4 = quad , 5 or more = N-gons).\n\n\n  +---+---+---+        +---+\n  | 3 | 4 | 3 | ...... | 3 |\n  +---+---+---+        +---+\n    |   |   |            |\n    |   |   |            +-----------------------------------------+\n    |   |   |                                                      |\n    |   |   +------------------------------+                       |\n    |   |                                  |                       |\n    |   +------------------+               |                       |\n    |                      |               |                       |\n    |/                     |/              |/                      |/\n\n mesh_t::indices\n\n  |    face[0]   |       face[1]     |    face[2]   |     |      face[n-1]           |\n  +----+----+----+----+----+----+----+----+----+----+     +--------+--------+--------+\n  | i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7 | i8 | i9 | ... | i(n-3) | i(n-2) | i(n-1) |\n  +----+----+----+----+----+----+----+----+----+----+     +--------+--------+--------+\n\n```\n\nNote that when `triangulate` flag is true in `tinyobj::LoadObj()` argument, `num_face_vertices` are all filled with 3(triangle).\n\n### float data type\n\nTinyObjLoader now use `real_t` for floating point data type.\nDefault is `float(32bit)`.\nYou can enable `double(64bit)` precision by using `TINYOBJLOADER_USE_DOUBLE` define.\n\n#### Example code\n\n```c++\n#define TINYOBJLOADER_IMPLEMENTATION // define this in only *one* .cc\n#include "tiny_obj_loader.h"\n\nstd::string inputfile = "cornell_box.obj";\ntinyobj::attrib_t attrib;\nstd::vector<tinyobj::shape_t> shapes;\nstd::vector<tinyobj::material_t> materials;\n\nstd::string warn;\nstd::string err;\n\nbool ret = tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, inputfile.c_str());\n\nif (!warn.empty()) {\n  std::cout << warn << std::endl;\n}\n\nif (!err.empty()) {\n  std::cerr << err << std::endl;\n}\n\nif (!ret) {\n  exit(1);\n}\n\n// Loop over shapes\nfor (size_t s = 0; s < shapes.size(); s++) {\n  // Loop over faces(polygon)\n  size_t index_offset = 0;\n  for (size_t f = 0; f < shapes[s].mesh.num_face_vertices.size(); f++) {\n    int fv = shapes[s].mesh.num_face_vertices[f];\n\n    // Loop over vertices in the face.\n    for (size_t v = 0; v < fv; v++) {\n      // access to vertex\n      tinyobj::index_t idx = shapes[s].mesh.indices[index_offset + v];\n      tinyobj::real_t vx = attrib.vertices[3*idx.vertex_index+0];\n      tinyobj::real_t vy = attrib.vertices[3*idx.vertex_index+1];\n      tinyobj::real_t vz = attrib.vertices[3*idx.vertex_index+2];\n      tinyobj::real_t nx = attrib.normals[3*idx.normal_index+0];\n      tinyobj::real_t ny = attrib.normals[3*idx.normal_index+1];\n      tinyobj::real_t nz = attrib.normals[3*idx.normal_index+2];\n      tinyobj::real_t tx = attrib.texcoords[2*idx.texcoord_index+0];\n      tinyobj::real_t ty = attrib.texcoords[2*idx.texcoord_index+1];\n      // Optional: vertex colors\n      // tinyobj::real_t red = attrib.colors[3*idx.vertex_index+0];\n      // tinyobj::real_t green = attrib.colors[3*idx.vertex_index+1];\n      // tinyobj::real_t blue = attrib.colors[3*idx.vertex_index+2];\n    }\n    index_offset += fv;\n\n    // per-face material\n    shapes[s].mesh.material_ids[f];\n  }\n}\n\n```\n\n## Optimized loader\n\nOptimized multi-threaded .obj loader is available at `experimental/` directory.\nIf you want absolute performance to load .obj data, this optimized loader will fit your purpose.\nNote that the optimized loader uses C++11 thread and it does less error checks but may work most .obj data.\n\nHere is some benchmark result. Time are measured on MacBook 12(Early 2016, Core m5 1.2GHz).\n\n* Rungholt scene(6M triangles)\n  * old version(v0.9.x): 15500 msecs.\n  * baseline(v1.0.x): 6800 msecs(2.3x faster than old version)\n  * optimised: 1500 msecs(10x faster than old version, 4.5x faster than baseline)\n\n\n## Tests\n\nUnit tests are provided in `tests` directory. See `tests/README.md` for details.\n'