b'# ES6 for Humans\n\n<br>\n\n:loudspeaker: The complete guide is now available on [Amazon](https://www.amazon.com/ES6-Humans-Latest-Standard-JavaScript/dp/1484226224)\n\n[![ES6 for humans - Apress book](book-cover.jpg)](https://www.amazon.com/ES6-Humans-Latest-Standard-JavaScript/dp/1484226224)\n\n### Table of Contents\n\n* [`let`, `const` and block scoping](#1-let-const-and-block-scoping)\n* [Arrow Functions](#2-arrow-functions)\n* [Default Function Parameters](#3-default-function-parameters)\n* [Spread/Rest Operator](#4-spread--rest-operator)\n* [Object Literal Extensions](#5-object-literal-extensions)\n* [Octal and Binary Literals](#6-octal-and-binary-literals)\n* [Array and Object Destructuring](#7-array-and-object-destructuring)\n* [super in Objects](#8-super-in-objects)\n* [Template Literal and Delimiters](#9-template-literal-and-delimiters)\n* [for...of vs for...in](#10-forof-vs-forin)\n* [Map and WeakMap](#11-map-and-weakmap)\n* [Set and WeakSet](#12-set-and-weakset)\n* [Classes in ES6](#13-classes-in-es6)\n* [Symbol](#14-symbol)\n* [Iterators](#15-iterators)\n* [Generators](#16-generators)\n* [Promises](#17-promises)\n\n<br>\n\n### Languages\n\n* [Chinese Version (Thanks to barretlee)](http://www.barretlee.com/blog/2016/07/09/a-kickstarter-guide-to-writing-es6/)\n* [Portuguese Version (Thanks to alexmoreno)](https://github.com/alexmoreno/ES6-para-humanos)\n* [Russian Version (Thanks to etnolover)](https://github.com/etnolover/ES6-for-humans-translation)\n* [Korean Version (Thanks to scarfunk)](https://github.com/metagrover/ES6-for-humans/tree/korean-version)\n* [French Version (Thanks to tnga)](https://github.com/metagrover/ES6-for-humans/tree/french-version)\n* [Spanish Version (Thanks to carletex)](https://github.com/metagrover/ES6-for-humans/tree/spanish-version)\n* [Japanese Version (Thanks to isdh)](https://github.com/metagrover/ES6-for-humans/tree/japanese-version)\n\n<br>\n\n### 1. let, const and block scoping\n\n`let` allows you to create declarations which are bound to any block, called block scoping. Instead of using `var`, which provides function scope, it is recommended to use block scoped variables (`let` or `const`) in ES6.\n\n```javascript\nvar a = 2;\n{\n    let a = 3;\n    console.log(a); // 3\n    let a = 5; // TypeError: Identifier \'a\' has already been declared\n}\nconsole.log(a); // 2\n```\n\nAnother form of block-scoped declaration is the `const`, which creates constants. In ES6, a `const` represents a constant reference to a value. In other words, `Object`\'s and `Array`\'s contents may change, only the re-assignment of the variable is prevented. Here\'s a simple example:\n\n```javascript\n{\n    const b = 5;\n    b = 10; // TypeError: Assignment to constant variable\n\n    const arr = [5, 6];\n    arr.push(7);\n    console.log(arr); // [5,6,7]\n    arr = 10; // TypeError: Assignment to constant variable\n    arr[0] = 3; // value is mutable\n    console.log(arr); // [3,6,7]\n}\n```\n\nA few things to keep in mind:\n\n* Hoisting of `let` and `const` vary from the traditional hoisting of variables and functions. Both `let` and `const` are hoisted, but cannot be accessed before their declaration, because of [Temporal Dead Zone](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified)\n* `let` and `const` are scoped to the nearest enclosing block.\n* When using const with fixed strings or values, CAPITAL_CASING might be appropriate (ex: `const PI = 3.14`)\n* `const` has to be defined with its declaration.\n* Always use `const` over `let`, unless you plan on re-assigning the variable.\n\n<br>\n\n### 2. Arrow Functions\n\nArrow functions are a short-hand notation for writing functions in ES6. The arrow function definition consists of a parameter list `( ... )`, followed by the `=>` marker and a function body. For single-argument functions, the parentheses may be omitted.\n\n```javascript\n// Classical Function Expression\nfunction addition(a, b) {\n    return a + b;\n};\n\n// Implementation with arrow function\nconst addition = (a, b) => a + b;\n\n// With single argument, no parentheses required\nconst add5 = a => 5 + a;\n```\n\nNote that in the above example, the `addition` arrow function is implemented with "concise body" which does not need an explicit return statement. Note the omitted `{ }` after the `=>`.\n\nHere is an example with the usual "block body." Including the curly brace wrappers.\n\n```javascript\nconst arr = [\'apple\', \'banana\', \'orange\'];\n\nconst breakfast = arr.map(fruit => {\n    return fruit + \'s\';\n});\n\nconsole.log(breakfast); // [\'apples\', \'bananas\', \'oranges\']\n```\n\n**Behold! There is more...**\n\nArrow functions don\'t just make the code shorter. They are closely related to `this` binding behavior.\n\nArrow functions behavior with `this` keyword varies from that of normal functions. Each function in JavaScript defines its own `this` context but arrow functions capture the `this` value of the nearest enclosing context. Check out the following code:\n\n```javascript\nfunction Person() {\n    // The Person() constructor defines `this` as an instance of itself.\n    this.age = 0;\n\n    setInterval(function growUp() {\n        // In non-strict mode, the growUp() function defines `this`\n        // as the global object, which is different from the `this`\n        // defined by the Person() constructor.\n        this.age++;\n    }, 1000);\n}\nvar p = new Person();\n```\n\nIn ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.\n\n```javascript\nfunction Person() {\n    const self = this;\n    self.age = 0;\n\n    setInterval(function growUp() {\n        // The callback refers to the `self` variable of which\n        // the value is the expected object.\n        self.age++;\n    }, 1000);\n}\n```\n\nAs mentioned above, arrow functions capture the this value of the nearest enclosing context, so the following code works as expected, even with nested arrow functions.\n\n```javascript\nfunction Person() {\n    this.age = 0;\n\n    setInterval(() => {\n        setTimeout(() => {\n            this.age++; // `this` properly refers to the person object\n        }, 1000);\n    }, 1000);\n}\n\nlet p = new Person();\n```\n[Read more about \'Lexical this\' in arrow functions here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this)\n\n<br>\n\n### 3. Default Function Parameters\n\nES6 allows you to set default parameters in function definitions. Here is a simple illustration.\n\n```javascript\nconst getFinalPrice = (price, tax = 0.7) => price + price * tax;\ngetFinalPrice(500); // 850\n```\n\n<br>\n\n### 4. Spread / Rest Operator\n\n`...` operator is referred to as spread or rest operator, depending on how and where it is used.\n\nWhen used with any iterable, it acts as to "spread" it into individual elements:\n\n```javascript\nconst makeToast = (breadType, topping1, topping2) => {\n  return `I had ${breadType} toast with ${topping1} and ${topping2}`;\n};\n```\n\n```javascript\nconst ingredients = [\'wheat\', \'butter\', \'jam\'];\nmakeToast(...ingredients);\n// "I had wheat toast with butter and jam"\n\nmakeToast(...[\'sourdough\', \'avocado\', \'kale\']);\n// "I had sourdough toast with avocado and kale"\n```\n\nSpread is also great for shaping a new object from other object(s):\n\n```javascript\nconst defaults = {avatar: \'placeholder.jpg\', active: false}\nconst userData = {username: \'foo\', avatar: \'bar.jpg\'}\n\nconsole.log({created: \'2017-12-31\', ...defaults, ...userData})\n// {created: "2017-12-31", avatar: "bar.jpg", active: false, username: "foo"}\n```\n\nNew arrays can also be shaped expressively:\n\n```javascript\nconst arr1 = [1, 2, 3];\nconst arr2 = [7, 8, 9];\nconsole.log([...arr1, 4, 5, 6, ...arr2]) // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\nThe other common usage of `...` is gathering all arguments together into an array. This is referred as "rest" operator.\n\n```javascript\nfunction foo(...args) {\n    console.log(args);\n}\nfoo(1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\n```\n\n<br>\n\n### 5. Object Literal Extensions\n\nES6 allows declaring object literals by providing shorthand syntax for initializing properties from variables and defining function methods. It also enables the ability to have computed property keys in an object literal definition.\n\n```javascript\nfunction getCar(make, model, value) {\n    return {\n        // with property value shorthand\n        // syntax, you can omit the property\n        // value if key matches variable\n        // name\n        make,  // same as make: make\n        model, // same as model: model\n        value, // same as value: value\n\n        // computed values now work with\n        // object literals\n        [\'make\' + make]: true,\n\n        // Method definition shorthand syntax\n        // omits `function` keyword & colon\n        depreciate() {\n            this.value -= 2500;\n        }\n    };\n}\n\nlet car = getCar(\'Kia\', \'Sorento\', 40000);\nconsole.log(car);\n// {\n//     make: \'Kia\',\n//     model:\'Sorento\',\n//     value: 40000,\n//     makeKia: true,\n//     depreciate: function()\n// }\n```\n\n<br>\n\n### 6. Octal and Binary Literals\n\nES6 has new support for octal and binary literals.\nPrependending a number with `0o` or `0O` would convert it into octal value. Have a look at the following code:\n\n```javascript\nlet oValue = 0o10;\nconsole.log(oValue); // 8\n\nlet bValue = 0b10; // 0b or 0B for binary\nconsole.log(bValue); // 2\n```\n\n<br>\n\n### 7. Array and Object Destructuring\n\nDestructuring helps in avoiding the need for temp variables when dealing with object and arrays.\n\n```javascript\nfunction foo() {\n    return [1, 2, 3];\n}\nlet arr = foo(); // [1,2,3]\n\nlet [a, b, c] = foo();\nconsole.log(a, b, c); // 1 2 3\n\n```\n\n```javascript\n\nfunction getCar() {\n  return {\n    make: \'Tesla\',\n    model: \'g95\',\n    metadata: {\n      vin: \'123abc\',\n      miles: \'12000\'\n    }\n  };\n}\n\nconst {make, model} = getCar();\nconsole.log(make, model); // Tesla g95\n\nconst {make, metadata: {miles}} = getCar();\nconsole.log(make, miles); // Tesla 12000\n\n\n```\n\n<br>\n\n### 8. super in Objects\n\nES6 allows to use `super` method in (classless) objects with prototypes. Following is a simple example:\n\n```javascript\nconst parent = {\n    foo() {\n        console.log("Hello from the Parent");\n    }\n}\n\nconst child = {\n    foo() {\n        super.foo();\n        console.log("Hello from the Child");\n    }\n}\n\nObject.setPrototypeOf(child, parent);\nchild.foo(); // Hello from the Parent\n             // Hello from the Child\n```\n\n<br>\n\n### 9. Template Literal and Delimiters\n\nES6 introduces an easier way to add interpolations which are evaluated automatically.\n\n* <code>\\`${ ... }\\`</code> is used for rendering the variables.\n* <code>\\`</code> Backtick is used as delimiter.\n\n```javascript\nlet user = \'Kevin\';\nconsole.log(`Hi ${user}!`); // Hi Kevin!\n```\n\n<br>\n\n### 10. for...of vs for...in\n* `for...of` iterates over iterable objects, such as array.\n\n```javascript\nconst nicknames = [\'di\', \'boo\', \'punkeye\'];\nnicknames.size = 3;\nfor (let nickname of nicknames) {\n    console.log(nickname);\n}\n// di\n// boo\n// punkeye\n```\n\n* `for...in` iterates over all enumerable properties of an object.\n\n```javascript\nconst nicknames = [\'di\', \'boo\', \'punkeye\'];\nnicknames.size = 3;\nfor (let nickname in nicknames) {\n    console.log(nickname);\n}\n// 0\n// 1\n// 2\n// size\n```\n\n<br>\n\n### 11. Map and WeakMap\n\nES6 introduces new set of data structures called `Map` and `WeakMap`. Now, we actually use maps in JavaScript all the time. In fact every object can be considered as a `Map`.\n\nAn object is made of keys (always strings) and values, whereas in `Map`, any value (both objects and primitive values) may be used as either a key or a value. Have a look at this piece of code:\n\n```javascript\nconst myMap = new Map();\n\nconst keyString = "a string",\n    keyObj = {},\n    keyFunc = () => {};\n\n// setting the values\nmyMap.set(keyString, "value associated with \'a string\'");\nmyMap.set(keyObj, "value associated with keyObj");\nmyMap.set(keyFunc, "value associated with keyFunc");\n\nmyMap.size; // 3\n\n// getting the values\nmyMap.get(keyString);    // "value associated with \'a string\'"\nmyMap.get(keyObj);       // "value associated with keyObj"\nmyMap.get(keyFunc);      // "value associated with keyFunc"\n```\n\n**WeakMap**\n\nA `WeakMap` is a Map in which the keys are weakly referenced, that doesn\xe2\x80\x99t prevent its keys from being garbage-collected. That means you don\'t have to worry about memory leaks.\n\nAnother thing to note here- in `WeakMap` as opposed to `Map` *every key must be an object*.\n\nA `WeakMap` only has four methods `delete(key)`, `has(key)`, `get(key)` and `set(key, value)`.\n\n```javascript\nconst w = new WeakMap();\nw.set(\'a\', \'b\');\n// Uncaught TypeError: Invalid value used as weak map key\n\nconst o1 = {},\n    o2 = () => {},\n    o3 = window;\n\nw.set(o1, 37);\nw.set(o2, "azerty");\nw.set(o3, undefined);\n\nw.get(o3); // undefined, because that is the set value\n\nw.has(o1); // true\nw.delete(o1);\nw.has(o1); // false\n```\n\n<br>\n\n### 12. Set and WeakSet\n\n*Set* objects are collections of unique values. Duplicate values are ignored, as the collection must have all unique values. The values can be primitive types or object references.\n\n```javascript\nconst mySet = new Set([1, 1, 2, 2, 3, 3]);\nmySet.size; // 3\nmySet.has(1); // true\nmySet.add(\'strings\');\nmySet.add({ a: 1, b:2 });\n```\n\nYou can iterate over a set by insertion order using either the `forEach` method or the `for...of` loop.\n\n```javascript\nmySet.forEach((item) => {\n    console.log(item);\n    // 1\n    // 2\n    // 3\n    // \'strings\'\n    // Object { a: 1, b: 2 }\n});\n\nfor (let value of mySet) {\n    console.log(value);\n    // 1\n    // 2\n    // 3\n    // \'strings\'\n    // Object { a: 1, b: 2 }\n}\n```\nSets also have the `delete()` and `clear()` methods.\n\n**WeakSet**\n\nSimilar to `WeakMap`, the `WeakSet` object lets you store weakly held *objects* in a collection. An object in the `WeakSet` occurs only once; it is unique in the WeakSet\'s collection.\n\n```javascript\nconst ws = new WeakSet();\nconst obj = {};\nconst foo = {};\n\nws.add(window);\nws.add(obj);\n\nws.has(window); // true\nws.has(foo);    // false, foo has not been added to the set\n\nws.delete(window); // removes window from the set\nws.has(window);    // false, window has been removed\n```\n\n<br>\n\n### 13. Classes in ES6\n\nES6 introduces new class syntax. One thing to note here is that ES6 class is not a new object-oriented inheritance model. They just serve as a syntactical sugar over JavaScript\'s existing prototype-based inheritance.\n\nOne way to look at a class in ES6 is just a new syntax to work with prototypes and constructor functions that we\'d use in ES5.\n\nFunctions defined using the `static` keyword implement static/class functions on the class.\n\n```javascript\nclass Task {\n    constructor() {\n        console.log("task instantiated!");\n    }\n\n    showId() {\n        console.log(23);\n    }\n\n    static loadAll() {\n        console.log("Loading all tasks..");\n    }\n}\n\nconsole.log(typeof Task); // function\nconst task = new Task(); // "task instantiated!"\ntask.showId(); // 23\nTask.loadAll(); // "Loading all tasks.."\n```\n\n**extends and super in classes**\n\nConsider the following code:\n\n```javascript\nclass Car {\n    constructor() {\n        console.log("Creating a new car");\n    }\n}\n\nclass Porsche extends Car {\n    constructor() {\n        super();\n        console.log("Creating Porsche");\n    }\n}\n\nlet c = new Porsche();\n// Creating a new car\n// Creating Porsche\n```\n\n`extends` allow child class to inherit from parent class in ES6. It is important to note that the derived constructor must call `super()`.\n\nAlso, you can call parent class\'s method in child class\'s methods using `super.parentMethodName()`\n\n[Read more about classes here](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes)\n\nA few things to keep in mind:\n\n* Class declarations are not hoisted. You first need to declare your class and then access it, otherwise ReferenceError will be thrown.\n* There is no need to use `function` keyword when defining functions inside a class definition.\n\n<br>\n\n### 14. Symbol\n\nA `Symbol` is a unique and immutable data type introduced in ES6. The purpose of a symbol is to generate a unique identifier but you can never get any access to that identifier.\n\nHere\xe2\x80\x99s how you create a symbol:\n\n```javascript\nconst sym = Symbol("some optional description");\nconsole.log(typeof sym); // symbol\n```\n\nNote that you cannot use `new` with `Symbol(\xe2\x80\xa6)`.\n\nIf a symbol is used as a property/key of an object, it\xe2\x80\x99s stored in a special way that the property will not show up in a normal enumeration of the object\xe2\x80\x99s properties.\n\n```javascript\nconst o = {\n    val: 10,\n    [Symbol("random")]: "I\'m a symbol",\n};\n\nconsole.log(Object.getOwnPropertyNames(o)); // val\n```\n\nTo retrieve an object\xe2\x80\x99s symbol properties, use `Object.getOwnPropertySymbols(o)`\n\n\n<br>\n\n### 15. Iterators\n\nAn iterator accesses the items from a collection one at a time, while keeping track of its current position within that sequence. It provides a `next()` method which returns the next item in the sequence. This method returns an object with two properties: done and value.\n\nES6 has `Symbol.iterator` which specifies the default iterator for an object. Whenever an object needs to be iterated (such as at the beginning of a for..of loop), its *@@iterator* method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.\n\nLet\xe2\x80\x99s look at an array, which is an iterable, and the iterator it can produce to consume its values:\n\n```javascript\nconst arr = [11,12,13];\nconst itr = arr[Symbol.iterator]();\n\nitr.next(); // { value: 11, done: false }\nitr.next(); // { value: 12, done: false }\nitr.next(); // { value: 13, done: false }\n\nitr.next(); // { value: undefined, done: true }\n```\n\nNote that you can write custom iterators by defining `obj[Symbol.iterator]()` with the object definition.\n\n<br>\n\n### 16. Generators\n\nGenerator functions are a new feature in ES6 that allow a function to generate many values over time by returning an object which can be iterated over to pull values from the function one value at a time.\n\nA generator function returns an **iterable object** when it\'s called.\nIt is written using the new `*` syntax as well as the new `yield` keyword introduced in ES6.\n\n```javascript\nfunction *infiniteNumbers() {\n    let n = 1;\n    while (true) {\n        yield n++;\n    }\n}\n\nconst numbers = infiniteNumbers(); // returns an iterable object\n\nnumbers.next(); // { value: 1, done: false }\nnumbers.next(); // { value: 2, done: false }\nnumbers.next(); // { value: 3, done: false }\n```\n\nEach time *yield* is called, the yielded value becomes the next value in the sequence.\n\nAlso, note that generators compute their yielded values on demand, which allows them to efficiently represent sequences that are expensive to compute, or even infinite sequences.\n\n<br>\n\n### 17. Promises\n\nES6 has native support for promises. A *promise* is an object that is waiting for an asynchronous operation to complete, and when that operation completes, the promise is either fulfilled(resolved) or rejected.\n\nThe standard way to create a Promise is by using the `new Promise()` constructor which accepts a handler that is given two functions as parameters. The first handler (typically named `resolve`) is a function to call with the future value when it\'s ready; and the second handler (typically named `reject`) is a function to call to reject the Promise if it can\'t resolve the future value.\n\n```javascript\nconst p = new Promise((resolve, reject) => {\n    if (/* condition */) {\n        resolve(/* value */);  // fulfilled successfully\n    } else {\n        reject(/* reason */);  // error, rejected\n    }\n});\n```\n\nEvery Promise has a method named `then` which takes a pair of callbacks. The first callback is called if the promise is resolved, while the second is called if the promise is rejected.\n\n```javascript\np.then((val) => console.log("Promise Resolved", val),\n       (err) => console.log("Promise Rejected", err));\n```\n\nReturning a value from `then` callbacks will pass the value to the next `then` callback.\n\n```javascript\nconst hello = new Promise((resolve, reject) => { resolve("Hello") });\n\nhello.then((str) => `${str} World`)\n     .then((str) => `${str}!`)\n     .then((str) => console.log(str)) // Hello World!\n```\n\nWhen returning a promise, the resolved value of the promise will get passed to the next callback to effectively chain them together.\nThis is a simple technique to avoid "callback hell".\n\n```javascript\nconst p = new Promise((resolve, reject) => { resolve(1) });\n\nconst eventuallyAdd1 = (val) => new Promise((resolve, reject) => { resolve(val + 1) });\n\np.then(eventuallyAdd1)\n .then(eventuallyAdd1)\n .then((val) => console.log(val)); // 3\n```\n'