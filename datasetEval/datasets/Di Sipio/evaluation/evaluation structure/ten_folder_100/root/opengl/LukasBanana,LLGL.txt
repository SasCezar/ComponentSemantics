b'# Low Level Graphics Library (LLGL)\n\n<p align="center"><img src="docu/LLGL_Logo.png"/></p>\n\n\n## License\n\n[3-Clause BSD License](https://github.com/LukasBanana/LLGL/blob/master/LICENSE.txt)\n\n\n## Documentation\n\n- **Version**: 0.03 Beta (see [ChangeLog](docu/ChangeLog))\n- [Getting Started with LLGL](docu/GettingStarted/Getting%20Started%20with%20LLGL.pdf) (PDF)\nwith Introduction, Hello Triangle Tutorial, and Extensibility Example with [GLFW](http://www.glfw.org/)\n- [LLGL Reference Manual](docu/refman.pdf) (PDF)\n- [LLGL Coding Conventions](docu/CodingConventions/Coding%20Conventions%20for%20LLGL.pdf) (PDF)\n- [Examples and Tutorials for C++](examples/Cpp)\n- [Examples for C#](examples/CSharp)\n\n\n## Platform Support\n\n| Platform | CI | D3D12 | D3D11 | Vulkan | OpenGL | Metal |\n|----------|:--:|:------:|:------:|:-----:|:-----:|:-----:|\n| Windows | [![Windows Build](https://ci.appveyor.com/api/projects/status/j09x8n07u3byfky0?svg=true)](https://ci.appveyor.com/project/LukasBanana/llgl) | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | N/A |\n| GNU/Linux | [![GNU/Linux Build Status](http://badges.herokuapp.com/travis/LukasBanana/LLGL?env=BADGE_LINUX&label=build)](https://travis-ci.org/LukasBanana/LLGL) | N/A | N/A | :heavy_check_mark: | :heavy_check_mark: | N/A |\n| macOS | [![macOS Build Status](http://badges.herokuapp.com/travis/LukasBanana/LLGL?env=BADGE_MACOS&label=build)](https://travis-ci.org/LukasBanana/LLGL) | N/A | N/A | N/A | :heavy_check_mark: | :heavy_check_mark: |\n| iOS | [![iOS Build Status](http://badges.herokuapp.com/travis/LukasBanana/LLGL?env=BADGE_IOS&label=build)](https://travis-ci.org/LukasBanana/LLGL) | N/A | N/A | N/A | :heavy_multiplication_x: | :heavy_check_mark: |\n\n\n## Build Notes\n\n### Windows\n\n**Visual Studio 2015** or later is required to build LLGL on Windows.\n\n### macOS\n\n**Xcode 9** or later is required to build LLGL on macOS.\n\n### GNU/Linux\n\nThe following development libraries are required to build LLGL on GNU/Linux:\n- **X11**: `libx11-dev`\n- **xf86vidmode**: `libxxf86vm-dev`\n- **Xrandr**: `libxrandr-dev`\n\n\n## Thin Abstraction Layer\n\n```cpp\n// Unified Interface:\nCommandBuffer::DrawIndexed(std::uint32_t numIndices, std::uint32_t firstIndex);\n\n// OpenGL Implementation:\nvoid GLCommandBuffer::DrawIndexed(std::uint32_t numIndices, std::uint32_t firstIndex) {\n    const GLintptr indices = (renderState_.indexBufferOffset + firstIndex * renderState_.indexBufferStride);\n    glDrawElements(\n        renderState_.drawMode,\n        static_cast<GLsizei>(numIndices),\n        renderState_.indexBufferDataType,\n        reinterpret_cast<const GLvoid*>(indices)\n    );\n}\n\n// Direct3D 11 Implementation\nvoid D3D11CommandBuffer::DrawIndexed(std::uint32_t numIndices, std::uint32_t firstIndex) {\n    context_->DrawIndexed(numIndices, firstIndex, 0);\n}\n\n// Direct3D 12 Implementation\nvoid D3D12CommandBuffer::DrawIndexed(std::uint32_t numIndices, std::uint32_t firstIndex) {\n    commandList_->DrawIndexedInstanced(numIndices, 1, firstIndex, 0, 0);\n}\n\n// Vulkan Implementation\nvoid VKCommandBuffer::DrawIndexed(std::uint32_t numIndices, std::uint32_t firstIndex) {\n    vkCmdDrawIndexed(commandBuffer_, numIndices, 1, firstIndex, 0, 0);\n}\n\n// Metal implementation\nvoid MTCommandBuffer::DrawIndexed(std::uint32_t numIndices, std::uint32_t firstIndex) {\n    if (numPatchControlPoints_ > 0) {\n        [renderEncoder_\n            drawIndexedPatches:             numPatchControlPoints_\n            patchStart:                     static_cast<NSUInteger>(firstIndex) / numPatchControlPoints_\n            patchCount:                     static_cast<NSUInteger>(numIndices) / numPatchControlPoints_\n            patchIndexBuffer:               nil\n            patchIndexBufferOffset:         0\n            controlPointIndexBuffer:        indexBuffer_\n            controlPointIndexBufferOffset:  indexTypeSize_ * (static_cast<NSUInteger>(firstIndex))\n            instanceCount:                  1\n            baseInstance:                   0\n        ];\n    } else {\n        [renderEncoder_\n            drawIndexedPrimitives:  primitiveType_\n            indexCount:             static_cast<NSUInteger>(numIndices)\n            indexType:              indexType_\n            indexBuffer:            indexBuffer_\n            indexBufferOffset:      indexTypeSize_ * static_cast<NSUInteger>(firstIndex)\n        ];\n    }\n}\n```\n\n\n'