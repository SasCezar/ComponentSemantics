b'# Filament\n\n![Android Build Status](https://github.com/google/filament/workflows/Android/badge.svg)\n![iOS Build Status](https://github.com/google/filament/workflows/iOS/badge.svg)\n![Linux Build Status](https://github.com/google/filament/workflows/Linux/badge.svg)\n![macOS Build Status](https://github.com/google/filament/workflows/macOS/badge.svg)\n![Windows Build Status](https://github.com/google/filament/workflows/Windows/badge.svg)\n![Web Build Status](https://github.com/google/filament/workflows/Web/badge.svg)\n\nFilament is a real-time physically based rendering engine for Android, iOS, Linux, macOS, Windows,\nand WebGL. It is designed to be as small as possible and as efficient as possible on Android.\n\nFilament is currently used in the\n[Sceneform](https://developers.google.com/ar/develop/java/sceneform/) library both at runtime on\nAndroid devices and as the renderer inside the Android Studio plugin.\n\n## Download\n\n[Download Filament releases](https://github.com/google/filament/releases) to access stable builds.\n\nMake sure you always use tools from the same release as the runtime library. This is particularly\nimportant for `matc` (material compiler).\n\n## Documentation\n\n- [Filament](https://google.github.io/filament/Filament.html), an in-depth explanation of\n  real-time physically based rendering, the graphics capabilities and implementation of Filament.\n  This document explains the math and reasoning behind most of our decisions. This document is a\n  good introduction to PBR for graphics programmers.\n- [Materials](https://google.github.io/filament/Materials.html), the full reference\n  documentation for our material system. This document explains our different material models, how\n  to use the material compiler `matc` and how to write custom materials.\n- [Material Properties](https://google.github.io/filament/Material%20Properties.pdf), a reference\n  sheet for the standard material model.\n\n## Samples\n\nHere are a few sample materials rendered with Filament:\n\n![Damaged Helmet](docs/images/samples/model_damaged_helmet.jpg)\n![Helmet](docs/images/samples/model_helmet.jpg)\n![Brushed copper](docs/images/samples/brushed_copper_2.jpg)\n![Material 1](docs/images/samples/material_01.jpg)\n![Material 2](docs/images/samples/material_02.jpg)\n![Material 6](docs/images/samples/material_06.jpg)\n![Material 8](docs/images/samples/material_08.jpg)\n\n## Applications\n\nHere are a few screenshots of applications that use Filament in production:\n\n### Google Maps AR Navigation\n\n![Google Maps AR Navigation](docs/images/samples/app_gmm_ar_nav.jpg)\n\n### Google Search 3D/AR Viewer on Android\n\n![Google Search 3D/AR Viewer on Android](docs/images/samples/app_google_3d_viewer.jpg)\n\n## Features\n\n### APIs\n\n- Native C++ API for Android, iOS, Linux, macOS and Windows\n- Java/JNI API for Android, Linux, macOS and Windows\n- JavaScript API\n\n### Backends\n\n- OpenGL 4.1+ for Linux, macOS and Windows\n- OpenGL ES 3.0+ for Android and iOS\n- Metal for macOS and iOS\n- Vulkan 1.0 for Android, Linux, macOS and iOS (with MoltenVk), and Windows\n- WebGL 2.0 for all platforms\n\n### Rendering\n\n- Clustered forward renderer\n- Cook-Torrance microfacet specular BRDF\n- Lambertian diffuse BRDF\n- HDR/linear lighting\n- Metallic workflow\n- Clear coat\n- Anisotropic lighting\n- Approximated translucent (subsurface) materials\n- Cloth shading\n- Normal mapping & ambient occlusion mapping\n- Image-based lighting\n- Physically-based camera (shutter speed, sensitivity and aperture)\n- Physical light units\n- Point light, spot light and directional light\n- SSAO\n- ACES-like tone-mapping\n- Temporal dithering\n- FXAA, MSAA and specular anti-aliasing\n- Dynamic resolution (on Android and iOS)\n\n### Future\n\nMany other features have been either prototyped or planned:\n\n- IES light profiles/cookies\n- Area lights\n- Fog\n- Color grading\n- Bloom\n- TAA\n- etc.\n\n## Directory structure\n\nThis repository not only contains the core Filament engine, but also its supporting libraries\nand tools.\n\n- `android`:               Android libraries and projects\n  - `build`:               Custom Gradle tasks for Android builds\n  - `filamat-android`:     Filament material generation library (AAR) for Android\n  - `filament-android`:    Filament library (AAR) for Android\n  - `samples`:             Android-specific Filament samples\n- `art`:                   Source for various artworks (logos, PDF manuals, etc.)\n- `assets`:                3D assets to use with sample applications\n- `build`:                 CMake build scripts\n- `docs`:                  Documentation\n  - `math`:                Mathematica notebooks used to explore BRDFs, equations, etc.\n- `filament`:              Filament rendering engine (minimal dependencies)\n- `ide`:                   Configuration files for IDEs (CLion, etc.)\n- `ios`:                   Sample projects for iOS\n- `java`:                  Java bindings for Filament libraries\n- `libs`:                  Libraries\n  - `bluegl`:              OpenGL bindings for macOS, Linux and Windows\n  - `bluevk`:              Vulkan bindings for macOS, Linux, Windows and Android\n  - `filabridge`:          Library shared by the Filament engine and host tools\n  - `filaflat`:            Serialization/deserialization library used for materials\n  - `filagui`:             Helper library for [Dear ImGui](https://github.com/ocornut/imgui)\n  - `filamat`:             Material generation library\n  - `filameshio`:          Tiny filamesh parsing library (see also `tools/filamesh`)\n  - `geometry`:            Mesh-related utilities\n  - `gltfio`:              Loader and optional pipeline for glTF 2.0\n  - `ibl`:                 IBL generation tools\n  - `image`:               Image filtering and simple transforms\n  - `imageio`:             Image file reading / writing, only intended for internal use\n  - `matdbg`:              DebugServer for inspecting shaders at run-time (debug builds only)\n  - `math`:                Math library\n  - `rays`:                Simple path tracer used for baking ambient occlusion, etc.\n  - `utils`:               Utility library (threads, memory, data structures, etc.)\n- `samples`:               Sample desktop applications\n- `shaders`:               Shaders used by `filamat` and `matc`\n- `third_party`:           External libraries and assets\n  - `environments`:        Environment maps under CC0 license that can be used with `cmgen`\n  - `models`:              Models under permissive licenses\n  - `textures`:            Textures under CC0 license\n- `tools`:                 Host tools\n  - `cmgen`:               Image-based lighting asset generator\n  - `filamesh`:            Mesh converter\n  - `glslminifier`:        Minifies GLSL source code\n  - `matc`:                Material compiler\n  - `matinfo`              Displays information about materials compiled with `matc`\n  - `mipgen`               Generates a series of miplevels from a source image\n  - `normal-blending`:     Tool to blend normal maps\n  - `resgen`               Aggregates binary blobs into embeddable resources\n  - `roughness-prefilter`: Pre-filters a roughness map from a normal map to reduce aliasing\n  - `skygen`:              Physically-based sky environment texture generator\n  - `specular-color`:      Computes the specular color of conductors based on spectral data\n- `web`:                   JavaScript bindings, documentation, and samples\n\n## Building Filament\n\n### Prerequisites\n\nTo build Filament, you must first install the following tools:\n\n- CMake 3.10 (or more recent)\n- clang 7.0 (or more recent)\n- [ninja 1.8](https://github.com/ninja-build/ninja/wiki/Pre-built-Ninja-packages) (or more recent)\n\nTo build the Java based components of the project you can optionally install (recommended):\n\n- OpenJDK 1.8 (or more recent)\n\nAdditional dependencies may be required for your operating system. Please refer to the appropriate\nsection below.\n\nBuilding the `rays` library (used for light baking) is optional and requires the following packages:\n\n- embree 3.0+\n- libtbb-dev\n\nTo build Filament for Android you must also install the following:\n\n- Android Studio 3.5\n- Android SDK\n- Android NDK "side-by-side" 20 or higher\n\n### Environment variables\n\nMake sure the environment variable `ANDROID_HOME` points to the location of your Android SDK.\n\nBy default our build system will attempt to compile the Java bindings. To do so, the environment\nvariable `JAVA_HOME` should point to the location of your JDK.\n\nWhen building for WebGL, you\'ll also need to set `EMSDK`. See [WebAssembly](#webassembly).\n\n### IDE\n\nWe recommend using CLion to develop for Filament. Simply open the root directory\'s CMakeLists.txt\nin CLion to obtain a usable project.\n\n### Easy build\n\nOnce the required OS specific dependencies listed below are installed, you can use the script\nlocated in `build.sh` to build Filament easily on macOS and Linux.\n\nThis script can be invoked from anywhere and will produce build artifacts in the `out/` directory\ninside the Filament source tree.\n\nTo trigger an incremental debug build:\n\n```\n$ ./build.sh debug\n```\n\nTo trigger an incremental release build:\n\n```\n$ ./build.sh release\n```\n\nTo trigger both incremental debug and release builds:\n\n```\n$ ./build.sh debug release\n```\n\nTo install the libraries and executables in `out/debug/` and `out/release/`, add the `-i` flag.\nYou can force a clean build by adding the `-c` flag. The script offers more features described\nby executing `build.sh -h`.\n\n### Disabling Java builds\n\nBy default our build system will attempt to compile the Java bindings. If you wish to skip this\ncompilation step simply pass the `-j` flag to `build.sh`:\n\n```\n$ ./build.sh -j release\n```\n\nIf you use CMake directly instead of the build script, pass `-DENABLE_JAVA=OFF` to CMake instead.\n\n### Filament-specific CMake Options\n\nThe following CMake options are boolean options specific to Filament:\n\n- `ENABLE_JAVA`:                Compile Java projects: requires a JDK and the JAVA_HOME env var\n- `ENABLE_LTO`:                 Enable link-time optimizations if supported by the compiler\n- `FILAMENT_BUILD_FILAMAT`:     Build filamat and JNI buildings\n- `FILAMENT_SUPPORTS_METAL`:    Include the Metal backend\n- `FILAMENT_SUPPORTS_VULKAN`:   Include the Vulkan backend\n- `GENERATE_JS_DOCS`:           Build WebGL documentation and tutorials\n- `INSTALL_BACKEND_TEST`:       Install the backend test library so it can be consumed on iOS\n- `USE_EXTERNAL_GLES3`:         Experimental: Compile Filament against OpenGL ES 3\n\nTo turn an option on or off:\n\n```\n$ cd <cmake-build-directory>\n$ cmake . -DOPTION=ON       # Relace OPTION with the option name, set to ON / OFF\n```\n\nOptions can also be set with the CMake GUI.\n\n### Linux\n\nMake sure you\'ve installed the following dependencies:\n\n- `clang-7` or higher\n- `libglu1-mesa-dev`\n- `libc++-7-dev` (`libcxx-devel` and `libcxx-static` on Fedora) or higher\n- `libc++abi-7-dev` (`libcxxabi-static` on Fedora) or higher\n- `ninja-build`\n- `libxi-dev`\n\nAfter dependencies have been installed, we highly recommend using the [easy build](#easy-build)\nscript.\n\nIf you\'d like to run `cmake` directly rather than using the build script, it can be invoked as\nfollows, with some caveats that are explained further down.\n\n```\n$ mkdir out/cmake-release\n$ cd out/cmake-release\n$ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../release/filament ../..\n```\n\nYour Linux distribution might default to `gcc` instead of `clang`, if that\'s the case invoke\n`cmake` with the following command:\n\n```\n$ mkdir out/cmake-release\n$ cd out/cmake-release\n# Or use a specific version of clang, for instance /usr/bin/clang-7\n$ CC=/usr/bin/clang CXX=/usr/bin/clang++ CXXFLAGS=-stdlib=libc++ \\\n    cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../release/filament ../..\n```\n\nYou can also export the `CC` and `CXX` environment variables to always point to `clang`. Another\nsolution is to use `update-alternatives` to both change the default compiler, and point to a\nspecific version of clang:\n\n```\n$ update-alternatives --install /usr/bin/clang clang /usr/bin/clang-7 100\n$ update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-7 100\n$ update-alternatives --install /usr/bin/cc cc /usr/bin/clang 100\n$ update-alternatives --install /usr/bin/c++ c++ /usr/bin/clang++ 100\n```\n\nFinally, invoke `ninja`:\n\n```\n$ ninja\n```\n\nThis will build Filament, its tests and samples, and various host tools.\n\n### macOS\n\nTo compile Filament you must have the most recent version of Xcode installed and you need to\nmake sure the command line tools are setup by running:\n\n```\n$ xcode-select --install\n```\n\nAfter installing Java 1.8 you must also ensure that your `JAVA_HOME` environment variable is\nproperly set. If it doesn\'t already point to the appropriate JDK, you can simply add the following\nto your `.profile`:\n\n```\nexport JAVA_HOME="$(/usr/libexec/java_home)"\n```\n\nThen run `cmake` and `ninja` to trigger a build:\n\n```\n$ mkdir out/cmake-release\n$ cd out/cmake-release\n$ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../release/filament ../..\n$ ninja\n```\n\n### iOS\n\nThe easiest way to build Filament for iOS is to use `build.sh` and the\n`-p ios` flag. For instance to build the debug target:\n\n```\n$ ./build.sh -p ios debug\n```\n\nSee [ios/samples/README.md](./ios/samples/README.md) for more information.\n\n### Windows\n\n#### Building on Windows with the Visual Studio 2019 compiler\n\nInstall the following components:\n\n- [Visual Studio 2019](https://www.visualstudio.com/downloads)\n- [Python 3.7](https://www.python.org/ftp/python/3.7.0/python-3.7.0.exe)\n- [CMake 3.14 or later](https://github.com/Kitware/CMake/releases/download/v3.14.7/cmake-3.14.7-win64-x64.msi)\n\nOpen the `x64 Native Tools Command Prompt for VS 2019`.\n\nCreate a working directory, and run cmake in it:\n\n```\n> mkdir out\n> cd out\n> cmake ..\n```\n\nThen, you should be able to load the generated solution file `TNT.sln` in Visual Studio and build the `material_sandbox` project.\n\nRun it from the `out` directory with:\n```\n> samples\\Debug\\material_sandbox.exe ..\\assets\\models\\monkey\\monkey.obj\n```\n\n#### Building on Windows with the Clang compiler\n\nThe following instructions have been tested on a machine running Windows 10. They should take you\nfrom a machine with only the operating system to a machine able to build and run Filament.\n\nGoogle employees require additional steps which can be found here [go/filawin](http://go/filawin).\n\nInstall the following components:\n\n- [Windows 10 SDK](https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk)\n- [Visual Studio 2015 or 2017](https://www.visualstudio.com/downloads)\n- [Clang 7](http://releases.llvm.org/download.html)\n- [Python 3.7](https://www.python.org/ftp/python/3.7.0/python-3.7.0.exe)\n- [Cmake 3.13 or later](https://github.com/Kitware/CMake/releases/download/v3.13.4/cmake-3.13.4-win64-x64.msi)\n\nIf you\'re using Visual Studio 2017, you\'ll also need to install the [LLVM Compiler\nToolchain](https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain)\nextension.\n\nOpen an appropriate Native Tools terminal for the version of Visual Studio you are using:\n- VS 2015: VS2015 x64 Native Tools Command Prompt\n- VS 2017: x64 Native Tools Command Prompt for VS 2017\n\nYou can find these by clicking the start button and typing "x64 native tools".\n\nCreate a working directory:\n```\n> mkdir out/cmake-release\n> cd out/cmake-release\n```\n\nCreate the msBuild project:\n```\n# Visual Studio 2015:\n> cmake -T"LLVM-vs2014" -G "Visual Studio 14 2015 Win64" ../..\n\n# Visual Studio 2017\n> cmake ..\\.. -T"LLVM" -G "Visual Studio 15 2017 Win64" ^\n-DCMAKE_CXX_COMPILER:PATH="C:\\Program Files\\LLVM\\bin\\clang-cl.exe" ^\n-DCMAKE_C_COMPILER:PATH="C:\\Program Files\\LLVM\\bin\\clang-cl.exe" ^\n-DCMAKE_LINKER:PATH="C:\\Program Files\\LLVM\\bin\\lld-link.exe"\n```\n\nCheck out the output and make sure Clang for Windows frontend was found. You should see a line\nshowing the following output. Note that for Visual Studio 2017 this line may list Microsoft\'s\ncompiler, but the build will still in fact use Clang and you can proceed.\n\n```\nClang:C:/Program Files/LLVM/msbuild-bin/cl.exe\n```\n\nYou are now ready to build:\n```\n> msbuild  TNT.sln /t:material_sandbox /m /p:configuration=Release\n```\n\nRun it:\n```\n> samples\\Release\\material_sandbox.exe ..\\..\\assets\\models\\monkey\\monkey.obj\n```\n\n#### Tips\n\n- To troubleshoot an issue, use verbose mode via `/v:d` flag.\n- To build a specific project, use `/t:NAME` flag (e.g: `/t:material_sandbox`).\n- To build using more than one core, use parallel build flag: `/m`.\n- To build a specific profile, use `/p:configuration=` (e.g: `/p:configuration=Debug`,\n  `/p:configuration=Release`, and `/p:configuration=RelWithDebInfo`).\n- The msBuild project is what is used by Visual Studio behind the scene to build. Building from VS\n  or from the command-line is the same thing.\n\n#### Building with Ninja on Windows\n\nAlternatively, you can use [Ninja](https://ninja-build.org/) to build for Windows. An MSVC\ninstallation is still necessary.\n\nFirst, install the dependencies listed under [Windows](#Windows) as well as Ninja. Then open up a\nNative Tools terminal as before. Create a build directory inside Filament and run the\nfollowing CMake command:\n\n```\n> cmake .. -G Ninja ^\n-DCMAKE_CXX_COMPILER:PATH="C:\\Program Files\\LLVM\\bin\\clang-cl.exe" ^\n-DCMAKE_C_COMPILER:PATH="C:\\Program Files\\LLVM\\bin\\clang-cl.exe" ^\n-DCMAKE_LINKER:PATH="C:\\Program Files\\LLVM\\bin\\lld-link.exe" ^\n-DCMAKE_BUILD_TYPE=Release\n```\n\nYou should then be able to build by invoking Ninja:\n\n```\n> ninja\n```\n\n#### Development tips\n\n- Before shipping a binary, make sure you used Release profile and make sure you have no libc/libc++\n  dependencies with [Dependency Walker](http://www.dependencywalker.com).\n- Application Verifier and gflags.exe can be of great help to trackdown heap corruption. Application\n  Verifier is easy to setup with a GUI. For gflags, use: `gflags /p /enable pheap-buggy.exe`.\n\n#### Running a simple test\n\nTo confirm Filament was properly built, run the following command from the build directory:\n\n```\n> samples\\material_sandbox.exe --ibl=..\\..\\samples\\envs\\pillars ..\\..\\assets\\models\\sphere\\sphere.obj\n```\n\n### Android\n\nBefore building Filament for Android, make sure to build Filament for your host. Some of the\nhost tools are required to successfully build for Android.\n\nFilament can be built for the following architectures:\n\n- ARM 64-bit (`arm64-v8a`)\n- ARM 32-bit (`armeabi-v7a`)\n- Intel 64-bit (`x86_64`)\n- Intel 32-bit (`x86`)\n\nNote that the main target is the ARM 64-bit target. Our implementation is optimized first and\nforemost for `arm64-v8a`.\n\nTo build Android on Windows machines, see [android/Windows.md](android/Windows.md).\n\n#### Easy Android build\n\nThe easiest way to build Filament for Android is to use `build.sh` and the\n`-p android` flag. For instance to build the release target:\n\n```\n$ ./build.sh -p android release\n```\n\nRun `build.sh -h` for more information.\n\n#### ARM 64-bit target (arm64-v8a)\n\nThen invoke CMake in a build directory of your choice, inside of filament\'s directory:\n\n```\n$ mkdir out/android-build-release-aarch64\n$ cd out/android-build-release-aarch64\n$ cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=../../build/toolchain-aarch64-linux-android.cmake \\\n        -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../android-release/filament ../..\n```\n\nAnd then invoke `ninja`:\n\n```\n$ ninja install\n```\n\nor\n\n```\n$ ninja install/strip\n```\n\nThis will generate Filament\'s Android binaries in `out/android-release`. This location is important\nto build the Android Studio projects located in `filament/android`. After install, the library\nbinaries should be found in `out/android-release/filament/lib/arm64-v8a`.\n\n#### ARM 32-bit target (armeabi-v7a)\n\nThen invoke CMake in a build directory of your choice, inside of filament\'s directory:\n\n```\n$ mkdir out/android-build-release-arm\n$ cd out/android-build-release-arm\n$ cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=../../build/toolchain-arm7-linux-android.cmake \\\n        -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../android-release/filament ../..\n```\n\nAnd then invoke `ninja`:\n\n```\n$ ninja install\n```\n\nor\n\n```\n$ ninja install/strip\n```\n\nThis will generate Filament\'s Android binaries in `out/android-release`. This location is important\nto build the Android Studio projects located in `filament/android`. After install, the library\nbinaries should be found in `out/android-release/filament/lib/armeabi-v7a`.\n\n#### Intel 64-bit target (x86_64)\n\nThen invoke CMake in a build directory of your choice, sibling of filament\'s directory:\n\n```\n$ mkdir out/android-build-release-x86_64\n$ cd out/android-build-release-x86_64\n$ cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=../../filament/build/toolchain-x86_64-linux-android.cmake \\\n        -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../out/android-release/filament ../..\n```\n\nAnd then invoke `ninja`:\n\n```\n$ ninja install\n```\n\nor\n\n```\n$ ninja install/strip\n```\n\nThis will generate Filament\'s Android binaries in `out/android-release`. This location is important\nto build the Android Studio projects located in `filament/android`. After install, the library\nbinaries should be found in `out/android-release/filament/lib/x86_64`.\n\n#### Intel 32-bit target (x86)\n\nThen invoke CMake in a build directory of your choice, sibling of filament\'s directory:\n\n```\n$ mkdir out/android-build-release-x86\n$ cd out/android-build-release-x86\n$ cmake -G Ninja -DCMAKE_TOOLCHAIN_FILE=../../filament/build/toolchain-x86-linux-android.cmake \\\n        -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../out/android-release/filament ../..\n```\n\nAnd then invoke `ninja`:\n\n```\n$ ninja install\n```\n\nor\n\n```\n$ ninja install/strip\n```\n\nThis will generate Filament\'s Android binaries in `out/android-release`. This location is important\nto build the Android Studio projects located in `filament/android`. After install, the library\nbinaries should be found in `out/android-release/filament/lib/x86`.\n\n### AAR\n\nBefore you attempt to build the AAR, make sure you\'ve compiled and installed the native libraries\nas explained in the sections above. You must have the following ABIs built in\n`out/android-release/filament/lib/`:\n\n- `arm64-v8a`\n- `armeabi-v7a`\n- `x86_64`\n- `x86`\n\nTo build Filament\'s AAR simply open the Android Studio project in `android/filament-android`. The\nAAR is a universal AAR that contains all supported build targets:\n\n- `arm64-v8a`\n- `armeabi-v7a`\n- `x86_64`\n- `x86`\n\nTo filter out unneeded ABIs, rely on the `abiFilters` of the project that links against Filament\'s\nAAR.\n\nAlternatively you can build the AAR from the command line by executing the following the\n`android/filament-android` directory:\n\n```\n$ ./gradlew -Pfilament_dist_dir=../../out/android-release/filament assembleRelease\n```\n\nThe `-Pfilament_dist_dir` can be used to specify a different installation directory (it must match\nthe CMake install prefix used in the previous steps).\n\n### Using Filament\'s AAR\n\nCreate a new module in your project and select _Import .JAR or .AAR Package_ when prompted. Make\nsure to add the newly created module as a dependency to your application.\n\nIf you do not wish to include all supported ABIs, make sure to create the appropriate flavors in\nyour Gradle build file. For example:\n\n```\nflavorDimensions \'cpuArch\'\nproductFlavors {\n    arm8 {\n        dimension \'cpuArch\'\n        ndk {\n            abiFilters \'arm64-v8a\'\n        }\n    }\n    arm7 {\n        dimension \'cpuArch\'\n        ndk {\n            abiFilters \'armeabi-v7a\'\n        }\n    }\n    x86_64 {\n        dimension \'cpuArch\'\n        ndk {\n            abiFilters \'x86_64\'\n        }\n    }\n    x86 {\n        dimension \'cpuArch\'\n        ndk {\n            abiFilters \'x86\'\n        }\n    }\n    universal {\n        dimension \'cpuArch\'\n    }\n}\n```\n\n### WebAssembly\n\nThe core Filament library can be cross-compiled to WebAssembly from either macOS or Linux. To get\nstarted, follow the instructions for building Filament on your platform ([macOS](#macos) or\n[linux](#linux)), which will ensure you have the proper dependencies installed.\n\nNext, you need to install the Emscripten SDK. The following instructions show how to install the\nsame version that our continuous builds use.\n\n```\ncd <your chosen parent folder for the emscripten SDK>\ncurl -L https://github.com/emscripten-core/emsdk/archive/1b1f08f.zip > emsdk.zip\nunzip emsdk.zip ; mv emsdk-* emsdk ; cd emsdk\n./emsdk install lastest\n./emsdk activate lastest\nsource ./emsdk_env.sh\n```\n\nAfter this you can invoke the [easy build](#easy-build) script as follows:\n\n```\nexport EMSDK=<your chosen home for the emscripten SDK>\n./build.sh -p webgl release\n```\n\nThe EMSDK variable is required so that the build script can find the Emscripten SDK. The build\ncreates a `samples` folder that can be used as the root of a simple static web server. Note that you\ncannot open the HTML directly from the filesystem due to CORS. One way to deal with this is to\nuse Python to create a quick localhost server:\n\n```\ncd out/cmake-webgl-release/web/samples\npython3 -m http.server     # Python 3\npython -m SimpleHTTPServer # Python 2.7\n```\n\nYou can then open http://localhost:8000/suzanne.html in your web browser.\n\nAlternatively, if you have node installed you can use the\n[live-server](https://www.npmjs.com/package/live-server) package, which automatically refreshes the\nweb page when it detects a change.\n\nEach sample app has its own handwritten html file. Additionally the server folder contains assets\nsuch as meshes, textures, and materials.\n\n## Running the native samples\n\nThe `samples/` directory contains several examples of how to use Filament with SDL2.\n\nSome of the samples accept FBX/OBJ meshes while others rely on the `filamesh` file format. To\ngenerate a `filamesh ` file from an FBX/OBJ asset, run the `filamesh` tool\n(`./tools/filamesh/filamesh` in your build directory):\n\n```\nfilamesh ./assets/models/monkey/monkey.obj monkey.filamesh\n```\n\nMost samples accept an IBL that must be generated using the `cmgen` tool (`./tools/filamesh/cmgen`\nin your build directory). These sample apps expect a path to a directory containing the \'.rgb32f\'\nfiles for the IBL (which are PNGs containing `R11F_G11F_B10F` data). To generate an IBL simply use\nthis command:\n\n```\ncmgen -x ./ibls/ my_ibl.exr\n```\n\nThe source environment map can be a PNG (8 or 16 bit), a PSD (16 or 32 bit), an HDR or an OpenEXR\nfile. The environment map can be an equirectangular projection, a horizontal cross, a vertical\ncross, or a list of cubemap faces (horizontal or vertical).\n\n`cmgen` will automatically create a directory based on the name of the source environment map. In\nthe example above, the final directory will be `./ibls/my_ibl/`. This directory should contain the\npre-filtered environment map (one file per cubemap face and per mip level), the environment map\ntexture for the skybox and a text file containing the spherical harmonics for indirect diffuse\nlighting.\n\nIf you prefer a blurred background, run `cmgen` with this flag: `--extract-blur=0.1`. The numerical\nvalue is the desired roughness between 0 and 1.\n\n## Rendering with Filament\n\n### Native Linux, macOS and Windows\n\nYou must create an `Engine`, a `Renderer` and a `SwapChain`. The `SwapChain` is created from a\nnative window pointer (an `NSView` on macOS or a `HWND` on Windows for instance):\n\n```c++\nEngine* engine = Engine::create();\nSwapChain* swapChain = engine->createSwapChain(nativeWindow);\nRenderer* renderer = engine->createRenderer();\n```\n\nTo render a frame you must then create a `View`, a `Scene` and a `Camera`:\n\n```c++\nCamera* camera = engine->createCamera();\nView* view = engine->createView();\nScene* scene = engine->createScene();\n\nview->setCamera(camera);\nview->setScene(scene);\n```\n\nRenderables are added to the scene:\n\n```c++\nEntity renderable = EntityManager::get().create();\n// build a quad\nRenderableManager::Builder(1)\n        .boundingBox({{ -1, -1, -1 }, { 1, 1, 1 }})\n        .material(0, materialInstance)\n        .geometry(0, RenderableManager::PrimitiveType::TRIANGLES, vertexBuffer, indexBuffer, 0, 6)\n        .culling(false)\n        .build(*engine, renderable);\nscene->addEntity(renderable);\n```\n\nThe material instance is obtained from a material, itself loaded from a binary blob generated\nby `matc`:\n\n```c++\nMaterial* material = Material::Builder()\n        .package((void*) BAKED_MATERIAL_PACKAGE, sizeof(BAKED_MATERIAL_PACKAGE))\n        .build(*engine);\nMaterialInstance* materialInstance = material->createInstance();\n```\n\nTo learn more about materials and `matc`, please refer to the\n[materials documentation](./docs/Materials.md.html).\n\nTo render, simply pass the `View` to the `Renderer`:\n\n```c++\n// beginFrame() returns false if we need to skip a frame\nif (renderer->beginFrame(swapChain)) {\n    // for each View\n    renderer->render(view);\n    renderer->endFrame();\n}\n```\n\nFor complete examples of Linux, macOS and Windows Filament applications, look at the source files\nin the `samples/` directory. These samples are all based on `samples/app/` which contains the code\nthat creates a native window with SDL2 and initializes the Filament engine, renderer and views.\n\n### Java on Linux, macOS and Windows\n\nAfter building Filament, you can use `filament-java.jar` and its companion `filament-jni` native\nlibrary to use Filament in desktop Java applications.\n\nYou must always first initialize Filament by calling `Filament.init()`.\n\nYou can use Filament either with AWT or Swing, using respectively a `FilamentCanvas` or a\n`FilamentPanel`.\n\nFollowing the steps above (how to use Filament from native code), create an `Engine` and a\n`Renderer`, but instead of calling `beginFrame` and `endFrame` on the renderer itself, call\nthese methods on `FilamentCanvas` or `FilamentPanel`.\n\n### Android\n\nSee `android/samples` for examples of how to use Filament on Android.\n\nYou must always first initialize Filament by calling `Filament.init()`.\n\nRendering with Filament on Android is similar to rendering from native code (the APIs are largely\nthe same across languages). You can render into a `Surface` by passing a `Surface` to the\n`createSwapChain` method. This allows you to render to a `SurfaceTexture`, a `TextureView` or\na `SurfaceView`. To make things easier we provide an Android specific API called `UiHelper` in the\npackage `com.google.android.filament.android`. All you need to do is set a render callback on the\nhelper and attach your `SurfaceView` or `TextureView` to it. You are still responsible for\ncreating the swap chain in the `onNativeWindowChanged()` callback.\n\n### iOS\n\nSee `ios/samples` for examples of using Filament on iOS.\n\nFilament on iOS is largely the same as native rendering with C++. A `CAEAGLLayer` or `CAMetalLayer`\nis passed to the `createSwapChain` method. Filament for iOS supports both OpenGL ES and Vulkan via\nMoltenVK.\n\n## Generating C++ documentation\n\nTo generate the documentation you must first install `doxygen` and `graphviz`, then run the \nfollowing commands:\n\n```\n$ cd filament/filament\n$ doxygen docs/doxygen/filament.doxygen\n```\n\nFinally simply open `docs/html/index.html` in your web browser.\n\n## Assets\n\nTo get started you can use the textures and environment maps found respectively in\n`third_party/textures` and `third_party/environments`. These assets are under CC0 license. Please\nrefer to their respective `URL.txt` files to know more about the original authors.\n\n## Dependencies\n\nOne of our design goals is that Filament itself should have no dependencies or as few dependencies\nas possible. The current external dependencies of the runtime library include:\n\n- STL\n- robin-map (header only library)\n\nWhen building with Vulkan enabled, we have a few additional small dependencies:\n\n- vkmemalloc\n- smol-v\n\nHost tools (such as `matc` or `cmgen`) can use external dependencies freely.\n\n## How to make contributions\n\nPlease read and follow the steps in [CONTRIBUTING.md](/CONTRIBUTING.md). Make sure you are\nfamiliar with the [code style](/CODE_STYLE.md).\n\n## License\n\nPlease see [LICENSE](/LICENSE).\n\n## Disclaimer\n\nThis is not an officially supported Google product.\n'