b'# glium\n\n[![Build Status](https://travis-ci.org/glium/glium.svg?branch=master)](https://travis-ci.org/glium/glium)\n[![Coverage Status](https://coveralls.io/repos/tomaka/glium/badge.svg?branch=master&service=github)](https://coveralls.io/github/tomaka/glium?branch=master)\n\n[![crates.io page](http://meritbadge.herokuapp.com/glium)](https://crates.io/crates/glium)\n\n## Note to current and future Glium users:\n\nGlium is [no longer actively developed by its original\nauthor](https://users.rust-lang.org/t/glium-post-mortem/7063). That said, PRs\nare still welcome and maintenance is continued by the surrounding community.\n\n##\n\nElegant and safe OpenGL wrapper.\n\nGlium is an intermediate layer between OpenGL and your application. You still need to manually handle\nthe graphics pipeline, but without having to use OpenGL\'s old and error-prone API.\n\n```toml\n[dependencies]\nglium = "*"\n```\n\nIts objectives:\n - Be safe to use. Many aspects of OpenGL that can trigger a crash if misused are automatically handled by glium.\n - Provide an API that enforces good practices such as RAII or stateless function calls.\n - Be compatible with all OpenGL versions that support shaders, providing a unified API when things diverge.\n - Avoid all OpenGL errors beforehand.\n - Produce optimized OpenGL function calls, and allow the user to easily use modern OpenGL techniques.\n\n## [Link to the documentation](http://docs.rs/glium)\n\nIf you have some knowledge of OpenGL, the documentation and the examples should get you easily started.\n\n## [Link to a work-in-progress tutorial](https://github.com/glium/glium/tree/master/book)\n\n## Why should I use Glium instead of raw OpenGL calls?\n\nEasy to use:\n\n - Functions are higher level in glium than in OpenGL. Glium\'s API tries to be as Rusty as\n   possible, and shouldn\'t be much different than using any other Rust library. Glium should\n   allow you to do everything that OpenGL allows you to do, just through high-level\n   functions. If something is missing, please open an issue.\n\n - You can directly pass vectors, matrices and images to glium instead of manipulating low-level\n   data.\n\n - Thanks to glutin, glium is very easy to setup compared to raw OpenGL.\n\n - Glium provides easier ways to do common tasks. For example the `VertexBuffer` struct\n   contains information about the vertex bindings, because you usually don\'t use several different\n   bindings with the same vertex buffer. This reduces the overall complexity of OpenGL.\n\n - Glium handles framebuffer objects, samplers, and vertex array objects for you. You no longer\n   need to create them explicitly as they are automatically created when needed and destroyed\n   when their corresponding object is destroyed.\n\n - Glium is stateless. There are no `set_something()` functions in the entire library, and\n   everything is done by parameter passing. The same set of function calls will always produce\n   the same results, which greatly reduces the number of potential problems.\n\nSafety:\n\n - Glium detects what would normally be errors or undefined behaviors in OpenGL, and panics,\n   without calling `glGetError` which would be too slow. Examples include requesting a depth test\n   when you don\'t have a depth buffer available, not binding any value to an attribute or uniform,\n   or binding multiple textures with different dimensions to the same framebuffer.\n\n - If the OpenGL context triggers an error, then you have found a bug in glium. Please open\n   an issue. Just like Rust does everything it can to avoid crashes, glium does everything\n   it can to avoid OpenGL errors.\n\n - The OpenGL context is automatically handled by glium. You don\'t need to worry about thread\n   safety, as it is forbidden to change the thread in which OpenGL objects operate. Glium also\n   allows you to safely replace the current OpenGL context with another one that shares the same\n   lists.\n\n - Glium enforces RAII. Creating a `Texture2d` struct creates a texture, and destroying the struct\n   destroys the texture. It also uses Rust\'s borrow system to ensure that objects are still\n   alive and in the right state when you use them. Glium provides the same guarantees with OpenGL\n   objects that you have with regular objects in Rust.\n\n - High-level functions are much easier to use and thus less error-prone. For example there is\n   no risk of making a mistake while specifying the names and offsets of your vertex attributes,\n   since Glium automatically generates this data for you.\n\n - Robustness is automatically handled. If the OpenGL context is lost (because of a crash in the\n   driver for example) then swapping buffers will return an error.\n\nCompatibility:\n\n - In its default mode, Glium should be compatible with both OpenGL and OpenGL ES. If something\n   doesn\'t work on OpenGL ES, please open an issue.\n\n - During initialization, Glium detects whether the context provides all the required\n   functionality, and returns an `Err` if the device is too old. Glium tries to be as tolerant\n   as possible, and should work with the majority of the OpenGL2-era devices.\n\n - Glium will attempt to use the latest, optimized versions of OpenGL functions. This includes\n   buffer and texture immutable storage and direct state access. It will automatically fall back\n   to older functions if they are not available.\n\n - Glium comes with a set of tests that you can run with `cargo test`. If your project/game\n   doesn\'t work on specific hardware, you can try running Glium\'s tests on it to see what is wrong.\n\nPerformances:\n\n - State changes are optimized. The OpenGL state is only modified if the state actually differs.\n   For example if you call `draw` with the `IfLess` depth test twice in a row, then\n   `glDepthFunc(GL_LESS)` and `glEnable(GL_DEPTH_TEST)` will only be called the first time. If\n   you then call `draw` with `IfGreater`, then only `glDepthFunc(GL_GREATER)` will be called.\n\n - Just like Rust is theoretically slower than C because of additional safety checks, glium is\n   theoretically slower than well-prepared and optimized raw OpenGL calls. However in practice\n   the difference is very low.\n\n - Fully optimized OpenGL code uses advanced techniques such as persistent mapping or bindless\n   textures. These are hard to do and error-prone, but trivially easy to do with glium. You can\n   easily get a huge performance boost just by doing the right function calls.\n\n - Since glium automatically avoids all OpenGL errors, you can safely use the `GL_KHR_no_error`\n   extension when it is available. Using this extension should provide a good performance boost\n   (but it is also very recent and not available anywhere for the moment).\n\nLimitations:\n\n - Robustness isn\'t supported everywhere yet, so you can still get crashes if you do incorrect\n   things in your shaders.\n\n - Glium gives you access to all the tools but doesn\'t prevent you from doing horribly slow\n   things. Some knowledge of modern techniques is required if you want to reach maximum\n   performances.\n\n - Glium pushes the Rust compiler to its limits. Stack overflows (inside the compiler),\n   internal compiler errors, one-hour compile time, etc. happen more often than in smaller\n   libraries.\n\n - Rust plugins are not stable, so you will have to use macros such as\n   `implement_vertex!(MyStruct)` instead of `#[derive(GliumVertex)]`.\n'