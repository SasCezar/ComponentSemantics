b'# routing-controllers\r\n\r\n[![Build Status](https://travis-ci.org/typestack/routing-controllers.svg?branch=master)](https://travis-ci.org/typestack/routing-controllers)\r\n[![codecov](https://codecov.io/gh/typestack/routing-controllers/branch/master/graph/badge.svg)](https://codecov.io/gh/typestack/routing-controllers)\r\n[![npm version](https://badge.fury.io/js/routing-controllers.svg)](https://badge.fury.io/js/routing-controllers)\r\n[![Dependency Status](https://david-dm.org/typestack/routing-controllers.svg)](https://david-dm.org/typestack/routing-controllers)\r\n[![Join the chat at https://gitter.im/typestack/routing-controllers](https://badges.gitter.im/typestack/routing-controllers.svg)](https://gitter.im/typestack/routing-controllers?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nAllows to create controller classes with methods as actions that handle requests.\r\nYou can use routing-controllers with [express.js][1] or [koa.js][2].\r\n\r\n# Table of Contents\r\n\r\n  * [Installation](#installation)\r\n  * [Example of usage](#example-of-usage)\r\n  * [More examples](#more-examples)\r\n      - [Working with json](#working-with-json)\r\n      - [Return promises](#return-promises)\r\n      - [Using Request and Response objects](#using-request-and-response-objects)\r\n      - [Pre-configure express/koa](#pre-configure-expresskoa)\r\n      - [Load all controllers from the given directory](#load-all-controllers-from-the-given-directory)\r\n      - [Prefix all controllers routes](#prefix-all-controllers-routes)\r\n      - [Prefix controller with base route](#prefix-controller-with-base-route)\r\n      - [Inject routing parameters](#inject-routing-parameters)\r\n      - [Inject query parameters](#inject-query-parameters)\r\n      - [Inject request body](#inject-request-body)\r\n      - [Inject request body parameters](#inject-request-body-parameters)\r\n      - [Inject request header parameters](#inject-request-header-parameters)\r\n      - [Inject cookie parameters](#inject-cookie-parameters)\r\n      - [Inject session object](#inject-session-object)\r\n      - [Inject state object](#inject-state-object)\r\n      - [Inject uploaded file](#inject-uploaded-file)\r\n      - [Make parameter required](#make-parameter-required)\r\n      - [Convert parameters to objects](#convert-parameters-to-objects)\r\n      - [Set custom ContentType](#set-custom-contenttype)\r\n      - [Set Location](#set-location)\r\n      - [Set Redirect](#set-redirect)\r\n      - [Set custom HTTP code](#set-custom-http-code)\r\n      - [Controlling empty responses](#controlling-empty-responses)\r\n      - [Set custom headers](#set-custom-headers)\r\n      - [Render templates](#render-templates)\r\n      - [Throw HTTP errors](#throw-http-errors)\r\n      - [Enable CORS](#enable-cors)\r\n      - [Default settings](#default-settings)\r\n  * [Using middlewares](#using-middlewares)\r\n    + [Use exist middleware](#use-exist-middleware)\r\n    + [Creating your own express middleware](#creating-your-own-express-middleware)\r\n    + [Creating your own koa middleware](#creating-your-own-koa-middleware)\r\n    + [Global middlewares](#global-middlewares)\r\n    + [Error handlers](#error-handlers)\r\n    + [Loading middlewares and controllers from directories](#loading-middlewares-and-controllers-from-directories)\r\n  * [Using interceptors](#using-interceptors)\r\n    + [Interceptor function](#interceptor-function)\r\n    + [Interceptor classes](#interceptor-classes)\r\n    + [Global interceptors](#global-interceptors)\r\n  * [Creating instances of classes from action params](#creating-instances-of-classes-from-action-params)\r\n  * [Auto validating action params](#auto-validating-action-params)\r\n  * [Using authorization features](#using-authorization-features)\r\n      - [@Authorized decorator](#authorized-decorator)\r\n      - [@CurrentUser decorator](#currentuser-decorator)\r\n  * [Using DI container](#using-di-container)\r\n  * [Custom parameter decorators](#custom-parameter-decorators)\r\n  * [Decorators Reference](#decorators-reference)\r\n      - [Controller Decorators](#controller-decorators)\r\n      - [Controller Method Decorators](#controller-method-decorators)\r\n      - [Method Parameter Decorators](#method-parameter-decorators)\r\n      - [Middleware Decorators](#middleware-decorators)\r\n      - [Other Decorators](#other-decorators)\r\n  * [Samples](#samples)\r\n  * [Release notes](#release-notes)\r\n\r\n## Installation\r\n\r\n1. Install module:\r\n\r\n    `npm install routing-controllers`\r\n\r\n2. `reflect-metadata` shim is required:\r\n\r\n    `npm install reflect-metadata`\r\n\r\n    and make sure to import it before you use routing-controllers:\r\n\r\n    ```typescript\r\n    import "reflect-metadata";\r\n    ```\r\n\r\n3. Install framework:\r\n\r\n    **a. If you want to use routing-controllers with *express.js*, then install it and all required dependencies:**\r\n\r\n    `npm install express body-parser multer`\r\n\r\n    Optionally you can also install their typings:\r\n\r\n    `npm install -D @types/express @types/body-parser @types/multer`\r\n\r\n    **b. If you want to use routing-controllers with *koa 2*, then install it and all required dependencies:**\r\n\r\n    `npm install koa koa-router koa-bodyparser koa-multer`\r\n\r\n    Optionally you can also install their typings:\r\n\r\n    `npm install -D @types/koa @types/koa-router @types/koa-bodyparser`\r\n\r\n4. Install peer dependencies:\r\n\r\n  `npm install class-transformer class-validator`\r\n\r\n  In prior versions, these were direct dependencies, but now they are peer dependencies so you can choose when to upgrade and accept breaking changes.\r\n\r\n5. Its important to set these options in `tsconfig.json` file of your project:\r\n\r\n    ```json\r\n    {\r\n        "emitDecoratorMetadata": true,\r\n        "experimentalDecorators": true\r\n    }\r\n    ```\r\n\r\n## Example of usage\r\n\r\n1. Create a file `UserController.ts`\r\n\r\n    ```typescript\r\n    import {Controller, Param, Body, Get, Post, Put, Delete} from "routing-controllers";\r\n\r\n    @Controller()\r\n    export class UserController {\r\n\r\n        @Get("/users")\r\n        getAll() {\r\n           return "This action returns all users";\r\n        }\r\n\r\n        @Get("/users/:id")\r\n        getOne(@Param("id") id: number) {\r\n           return "This action returns user #" + id;\r\n        }\r\n\r\n        @Post("/users")\r\n        post(@Body() user: any) {\r\n           return "Saving user...";\r\n        }\r\n\r\n        @Put("/users/:id")\r\n        put(@Param("id") id: number, @Body() user: any) {\r\n           return "Updating a user...";\r\n        }\r\n\r\n        @Delete("/users/:id")\r\n        remove(@Param("id") id: number) {\r\n           return "Removing user...";\r\n        }\r\n\r\n    }\r\n    ```\r\n\r\n    This class will register routes specified in method decorators in your server framework (express.js or koa).\r\n\r\n2. Create a file `app.ts`\r\n\r\n    ```typescript\r\n    import "reflect-metadata"; // this shim is required\r\n    import {createExpressServer} from "routing-controllers";\r\n    import {UserController} from "./UserController";\r\n\r\n    // creates express app, registers all controller routes and returns you express app instance\r\n    const app = createExpressServer({\r\n       controllers: [UserController] // we specify controllers we want to use\r\n    });\r\n\r\n    // run express application on port 3000\r\n    app.listen(3000);\r\n    ```\r\n\r\n    > if you are koa user you just need to use `createKoaServer` instead of `createExpressServer`\r\n\r\n3. Open in browser `http://localhost:3000/users`. You will see `This action returns all users` in your browser.\r\nIf you open `http://localhost:3000/users/1` you will see `This action returns user #1`.\r\n\r\n## More examples\r\n\r\n#### Working with json\r\n\r\nIf you are designing a REST API where your endpoints always receive and return JSON then\r\nyou can use `@JsonController` decorator instead of `@Controller`.\r\nThis will guarantee you that data returned by your controller actions always be transformed to JSON\r\nand `Content-Type` header will be always set to `application/json`.\r\nIt will also guarantee `application/json` header is understood from the requests and the body parsed as JSON:\r\n\r\n```typescript\r\nimport {JsonController, Param, Body, Get, Post, Put, Delete} from "routing-controllers";\r\n\r\n@JsonController()\r\nexport class UserController {\r\n\r\n    @Get("/users")\r\n    getAll() {\r\n       return userRepository.findAll();\r\n    }\r\n\r\n    @Get("/users/:id")\r\n    getOne(@Param("id") id: number) {\r\n       return userRepository.findById(id);\r\n    }\r\n\r\n    @Post("/users")\r\n    post(@Body() user: User) {\r\n       return userRepository.insert(user);\r\n    }\r\n\r\n}\r\n```\r\n#### Return promises\r\n\r\nYou can return a promise in the controller, and it will wait until promise resolved and return promise result in a response body.\r\n\r\n```typescript\r\nimport {JsonController, Param, Body, Get, Post, Put, Delete} from "routing-controllers";\r\n\r\n@JsonController()\r\nexport class UserController {\r\n\r\n    @Get("/users")\r\n    getAll() {\r\n       return userRepository.findAll();\r\n    }\r\n\r\n    @Get("/users/:id")\r\n    getOne(@Param("id") id: number) {\r\n       return userRepository.findById(id);\r\n    }\r\n\r\n    @Post("/users")\r\n    post(@Body() user: User) {\r\n       return userRepository.insert(user);\r\n    }\r\n\r\n    @Put("/users/:id")\r\n    put(@Param("id") id: number, @Body() user: User) {\r\n       return userRepository.updateById(id, user);\r\n    }\r\n\r\n    @Delete("/users/:id")\r\n    remove(@Param("id") id: number) {\r\n       return userRepository.removeById(id);\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### Using Request and Response objects\r\n\r\nYou can use framework\'s request and response objects directly. If you want to handle the response by yourself,\r\njust make sure you return the response object itself from the action.\r\n\r\n```typescript\r\nimport {Controller, Req, Res, Get} from "routing-controllers";\r\n\r\n@Controller()\r\nexport class UserController {\r\n\r\n    @Get("/users")\r\n    getAll(@Req() request: any, @Res() response: any) {\r\n        return response.send("Hello response!");\r\n    }\r\n\r\n}\r\n```\r\n\r\n`@Req()` decorator injects you a `Request` object, and `@Res()` decorator injects you a `Response` object.\r\nIf you have installed typings, you can use their types:\r\n\r\n```typescript\r\nimport {Request, Response} from "express";\r\nimport {Controller, Req, Res, Get} from "routing-controllers";\r\n\r\n@Controller()\r\nexport class UserController {\r\n\r\n    @Get("/users")\r\n    getAll(@Req() request: Request, @Res() response: Response) {\r\n        return response.send("Hello response!");\r\n    }\r\n\r\n}\r\n```\r\n\r\n> note: koa users can also use `@Ctx() context` to inject koa\'s Context object.\r\n\r\n#### Pre-configure express/koa\r\n\r\nIf you have, or if you want to create and configure express app separately,\r\nyou can use `useExpressServer` instead of `createExpressServer` function:\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {useExpressServer} from "routing-controllers";\r\n\r\nlet express = require("express"); // or you can import it if you have installed typings\r\nlet app = express(); // your created express server\r\n// app.use() // you can configure it the way you want\r\nuseExpressServer(app, { // register created express server in routing-controllers\r\n    controllers: [UserController] // and configure it the way you need (controllers, validation, etc.)\r\n});\r\napp.listen(3000); // run your express server\r\n```\r\n\r\n> koa users must use `useKoaServer` instead of `useExpressServer`\r\n\r\n#### Load all controllers from the given directory\r\n\r\nYou can load all controllers from directories, by specifying array of directories in options of\r\n`createExpressServer` or `useExpressServer`:\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer} from "routing-controllers";\r\n\r\ncreateExpressServer({\r\n    controllers: [__dirname + "/controllers/*.js"]\r\n}).listen(3000); // register controllers routes in our express application\r\n```\r\n\r\n> koa users must use `createKoaServer` instead of `createExpressServer`\r\n\r\n#### Prefix all controllers routes\r\n\r\nIf you want to prefix all your routes, e.g. `/api` you can use  `routePrefix` option:\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer} from "routing-controllers";\r\nimport {UserController} from "./controller/UserController";\r\n\r\ncreateExpressServer({\r\n    routePrefix: "/api",\r\n    controllers: [UserController]\r\n}).listen(3000);\r\n```\r\n\r\n> koa users must use `createKoaServer` instead of `createExpressServer`\r\n\r\n#### Prefix controller with base route\r\n\r\nYou can prefix all specific controller\'s actions with base route:\r\n\r\n```typescript\r\n@Controller("/users")\r\nexport class UserController {\r\n    // ...\r\n}\r\n```\r\n\r\n#### Inject routing parameters\r\n\r\nYou can use `@Param` decorator to inject parameters in your controller actions:\r\n\r\n```typescript\r\n@Get("/users/:id")\r\ngetOne(@Param("id") id: number) { // id will be automatically casted to "number" because it has type number\r\n}\r\n```\r\n\r\nIf you want to inject all parameters use `@Params()` decorator.\r\n\r\n#### Inject query parameters\r\n\r\nTo inject query parameters, use `@QueryParam` decorator:\r\n\r\n```typescript\r\n@Get("/users")\r\ngetUsers(@QueryParam("limit") limit: number) {\r\n}\r\n```\r\n\r\nIf you want to inject all query parameters use `@QueryParams()` decorator.\r\nThe bigest benefit of this approach is that you can perform validation of the params.\r\n\r\n```typescript\r\nenum Roles {\r\n    Admin = "admin",\r\n    User = "user",\r\n    Guest = "guest",\r\n}\r\n\r\nclass GetUsersQuery {\r\n\r\n    @IsPositive()\r\n    limit: number;\r\n\r\n    @IsAlpha()\r\n    city: string;\r\n\r\n    @IsEnum(Roles)\r\n    role: Roles;\r\n\r\n    @IsBoolean()\r\n    isActive: boolean;\r\n\r\n}\r\n\r\n@Get("/users")\r\ngetUsers(@QueryParams() query: GetUsersQuery) {\r\n    // here you can access query.role, query.limit\r\n    // and others valid query parameters\r\n}\r\n```\r\n\r\n#### Inject request body\r\n\r\nTo inject request body, use `@Body` decorator:\r\n\r\n```typescript\r\n@Post("/users")\r\nsaveUser(@Body() user: User) {\r\n}\r\n```\r\n\r\nIf you specify a class type to parameter that is decorated with `@Body()`,\r\nrouting-controllers will use [class-transformer][4] to create instance of the given class type from the data received in request body.\r\nTo disable this behaviour you need to specify a `{ classTransformer: false }` in RoutingControllerOptions when creating a server.\r\n\r\n#### Inject request body parameters\r\n\r\nTo inject request body parameter, use `@BodyParam` decorator:\r\n\r\n```typescript\r\n@Post("/users")\r\nsaveUser(@BodyParam("name") userName: string) {\r\n}\r\n```\r\n\r\n#### Inject request header parameters\r\n\r\nTo inject request header parameter, use `@HeaderParam` decorator:\r\n\r\n```typescript\r\n@Post("/users")\r\nsaveUser(@HeaderParam("authorization") token: string) {\r\n}\r\n```\r\n\r\nIf you want to inject all header parameters use `@HeaderParams()` decorator.\r\n\r\n#### Inject cookie parameters\r\n\r\nTo get a cookie parameter, use `@CookieParam` decorator:\r\n\r\n```typescript\r\n@Get("/users")\r\ngetUsers(@CookieParam("username") username: string) {\r\n}\r\n```\r\n\r\nIf you want to inject all header parameters use `@CookieParams()` decorator.\r\n\r\n#### Inject session object\r\n\r\nTo inject a session value, use `@SessionParam` decorator:\r\n\r\n```typescript\r\n@Get("/login")\r\nsavePost(@SessionParam("user") user: User, @Body() post: Post) {}\r\n```\r\nIf you want to inject the main session object, use `@Session()` without any parameters.\r\n```typescript\r\n@Get("/login")\r\nsavePost(@Session() session: any, @Body() post: Post) {}\r\n```\r\nThe parameter marked with `@Session` decorator is required by default. If your action param is optional, you have to mark it as not required:\r\n```ts\r\naction(@Session("user", { required: false }) user: User) {}\r\n```\r\n\r\nExpress uses [express-session][5] / Koa uses [koa-session][6] or [koa-generic-session][7] to handle session, so firstly you have to install it manually to use `@Session` decorator.\r\n\r\n#### Inject state object\r\n\r\nTo inject a state parameter use `@State` decorator:\r\n\r\n```typescript\r\n@Get("/login/")\r\nsavePost(@State("user") user: User, @Body() post: Post) {\r\n}\r\n```\r\n\r\nIf you want to inject the whole state object use `@State()` without any parameters.\r\nThis feature is only supported by Koa.\r\n\r\n#### Inject uploaded file\r\n\r\nTo inject uploaded file, use `@UploadedFile` decorator:\r\n\r\n```typescript\r\n@Post("/files")\r\nsaveFile(@UploadedFile("fileName") file: any) {\r\n}\r\n```\r\n\r\nYou can also specify uploading options to multer this way:\r\n\r\n```typescript\r\n// to keep code clean better to extract this function into separate file\r\nexport const fileUploadOptions = () => {\r\n    storage: multer.diskStorage({\r\n        destination: (req: any, file: any, cb: any) => { ...\r\n        },\r\n        filename: (req: any, file: any, cb: any) => { ...\r\n        }\r\n    }),\r\n    fileFilter: (req: any, file: any, cb: any) => { ...\r\n    },\r\n    limits: {\r\n        fieldNameSize: 255,\r\n        fileSize: 1024 * 1024 * 2\r\n    }\r\n};\r\n\r\n// use options this way:\r\n@Post("/files")\r\nsaveFile(@UploadedFile("fileName", { options: fileUploadOptions }) file: any) {\r\n}\r\n```\r\n\r\nTo inject all uploaded files use `@UploadedFiles` decorator instead.\r\nRouting-controllers uses [multer][3] to handle file uploads.\r\nYou can install multer\'s file definitions via typings, and use `files: File[]` type instead of `any[]`.\r\n\r\n#### Make parameter required\r\n\r\nTo make any parameter required, simply pass a `required: true` flag in its options:\r\n\r\n```typescript\r\n@Post("/users")\r\nsave(@Body({ required: true }) user: any) {\r\n    // your method will not be executed if user is not sent in a request\r\n}\r\n```\r\n\r\nSame you can do with all other parameters `@QueryParam`, `@BodyParam` and others.\r\nIf user request does not contain required parameter routing-controller will throw an error.\r\n\r\n#### Convert parameters to objects\r\n\r\nIf you specify a class type to parameter that is decorated with parameter decorator,\r\nrouting-controllers will use [class-transformer][4] to create instance of that class type.\r\nMore info about this feature is available [here](#creating-instances-of-classes-from-action-params).\r\n\r\n#### Set custom ContentType\r\n\r\nYou can specify a custom ContentType header:\r\n\r\n```typescript\r\n@Get("/users")\r\n@ContentType("text/cvs")\r\ngetUsers() {\r\n    // ...\r\n}\r\n```\r\n#### Set Location\r\n\r\nYou can set a Location header for any action:\r\n\r\n```typescript\r\n@Get("/users")\r\n@Location("http://github.com")\r\ngetUsers() {\r\n    // ...\r\n}\r\n```\r\n\r\n#### Set Redirect\r\n\r\nYou can set a Redirect header for any action:\r\n\r\n```typescript\r\n@Get("/users")\r\n@Redirect("http://github.com")\r\ngetUsers() {\r\n    // ...\r\n}\r\n```\r\n\r\nYou can override the Redirect header by returning a string value:\r\n\r\n```ts\r\n@Get("/users")\r\n@Redirect("http://github.com")\r\ngetUsers() {\r\n    return "https://www.google.com";\r\n}\r\n```\r\n\r\nYou can use template to generate the Redirect header:\r\n\r\n```ts\r\n@Get("/users")\r\n@Redirect("http://github.com/:owner/:repo")\r\ngetUsers() {\r\n    return {\r\n        owner: "pleerock",\r\n        repo: "routing-controllers"\r\n    };\r\n}\r\n```\r\n\r\n#### Set custom HTTP code\r\n\r\nYou can explicitly set a returned HTTP code for any action:\r\n\r\n```typescript\r\n@HttpCode(201)\r\n@Post("/users")\r\nsaveUser(@Body() user: User) {\r\n    // ...\r\n}\r\n```\r\n\r\n#### Controlling empty responses\r\n\r\nIf your controller returns `void` or `Promise<void>` or `undefined` it will throw you 404 error.\r\nTo prevent this if you need to specify what status code you want to return using `@OnUndefined` decorator.\r\n\r\n```typescript\r\n@Delete("/users/:id")\r\n@OnUndefined(204)\r\nasync remove(@Param("id") id: number): Promise<void> {\r\n    return userRepository.removeById(id);\r\n}\r\n```\r\n\r\n`@OnUndefined` is also useful when you return some object which can or cannot be undefined.\r\nIn this example `findOneById` returns undefined in the case if user with given id was not found.\r\nThis action will return 404 in the case if user was not found, and regular 200 in the case if it was found.\r\n\r\n```typescript\r\n@Get("/users/:id")\r\n@OnUndefined(404)\r\ngetOne(@Param("id") id: number) {\r\n    return userRepository.findOneById(id);\r\n}\r\n```\r\n\r\nYou can also specify error class you want to use if it returned undefined:\r\n\r\n```typescript\r\nimport {HttpError} from "routing-controllers";\r\n\r\nexport class UserNotFoundError extends HttpError {\r\n    constructor() {\r\n        super(404, "User not found!");\r\n    }\r\n}\r\n```\r\n\r\n```typescript\r\n@Get("/users/:id")\r\n@OnUndefined(UserNotFoundError)\r\nsaveUser(@Param("id") id: number) {\r\n    return userRepository.findOneById(id);\r\n}\r\n```\r\n\r\nIf controller action returns `null` you can use `@OnNull` decorator instead.\r\n\r\n#### Set custom headers\r\n\r\nYou can set any custom header in a response:\r\n\r\n```typescript\r\n@Get("/users/:id")\r\n@Header("Cache-Control", "none")\r\ngetOne(@Param("id") id: number) {\r\n    // ...\r\n}\r\n```\r\n\r\n#### Render templates\r\n\r\nIf you are using server-side rendering you can render any template:\r\n\r\n```typescript\r\n@Get("/users/:id")\r\n@Render("index.html")\r\ngetOne() {\r\n    return {\r\n        param1: "these params are used",\r\n        param2: "in templating engine"\r\n    };\r\n}\r\n```\r\n\r\nTo use rendering ability make sure to configure express / koa properly.\r\nTo use rendering ability with Koa you will need to use a rendering 3rd party such as [koa-views](https://github.com/queckezz/koa-views/),\r\nkoa-views is the only render middleware that has been tested.\r\n\r\n#### Throw HTTP errors\r\n\r\nIf you want to return errors with specific error codes, there is an easy way:\r\n\r\n```typescript\r\n@Get("/users/:id")\r\ngetOne(@Param("id") id: number) {\r\n\r\n    const user = this.userRepository.findOneById(id);\r\n    if (!user)\r\n        throw new NotFoundError(`User was not found.`); // message is optional\r\n\r\n    return user;\r\n}\r\n```\r\n\r\nNow, when user won\'t be found with requested id, response will be with http status code 404 and following content:\r\n\r\n```json\r\n{\r\n  "name": "NotFoundError",\r\n  "message": "User was not found."\r\n}\r\n```\r\n\r\nThere are set of prepared errors you can use:\r\n\r\n* HttpError\r\n* BadRequestError\r\n* ForbiddenError\r\n* InternalServerError\r\n* MethodNotAllowedError\r\n* NotAcceptableError\r\n* NotFoundError\r\n* UnauthorizedError\r\n\r\n\r\nYou can also create and use your own errors by extending `HttpError` class.  \r\nTo define the data returned to the client, you could define a toJSON method in your error.\r\n\r\n```typescript\r\nclass DbError extends HttpError {\r\n    public operationName: string;\r\n    public args: any[];\r\n\r\n    constructor(operationName: string, args: any[] = []) {\r\n        super(500);\r\n        Object.setPrototypeOf(this, DbError.prototype);\r\n        this.operationName = operationName;\r\n        this.args = args; // can be used for internal logging\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            status: this.httpCode,\r\n            failedOperation: this.operationName\r\n        }\r\n    }\r\n}\r\n``` \r\n\r\n#### Enable CORS\r\n\r\nSince CORS is a future that is used almost in any web-api application,\r\nyou can enable it in routing-controllers options.\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer} from "routing-controllers";\r\nimport {UserController} from "./UserController";\r\n\r\nconst app = createExpressServer({\r\n    cors: true,\r\n    controllers: [UserController]\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\nTo use cors you need to install its module.\r\nFor express its `npm i cors`, for koa its `npm i kcors`.\r\nYou can pass cors options as well:\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer} from "routing-controllers";\r\nimport {UserController} from "./UserController";\r\n\r\nconst app = createExpressServer({\r\n    cors: {\r\n        // options from cors documentation\r\n    },\r\n    controllers: [UserController]\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n#### Default settings\r\n\r\nYou can override default status code in routing-controllers options. \r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer} from "routing-controllers";\r\nimport {UserController} from "./UserController";\r\n\r\nconst app = createExpressServer({\r\n    defaults: {\r\n\r\n        //with this option, null will return 404 by default\r\n        nullResultCode: 404,\r\n\r\n        //with this option, void or Promise<void> will return 204 by default \r\n        undefinedResultCode: 204,\r\n        \r\n        paramOptions: {\r\n            //with this option, argument will be required by default\r\n            required: true\r\n        }\r\n    }\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n## Using middlewares\r\n\r\nYou can use any existing express / koa middleware, or create your own.\r\nTo create your middlewares there is a `@Middleware` decorator,\r\nand to use already exist middlewares there are `@UseBefore` and `@UseAfter` decorators.\r\n\r\n### Use existing middleware\r\n\r\nThere are multiple ways to use middleware.\r\nFor example, lets try to use [compression](https://github.com/expressjs/compression) middleware:\r\n\r\n1. Install compression middleware: `npm install compression`\r\n2. To use middleware per-action:\r\n\r\n    ```typescript\r\n    import {Controller, Get, UseBefore} from "routing-controllers";\r\n    let compression = require("compression");\r\n\r\n    // ...\r\n\r\n    @Get("/users/:id")\r\n    @UseBefore(compression())\r\n    getOne(@Param("id") id: number) {\r\n        // ...\r\n    }\r\n    ```\r\n\r\n    This way compression middleware will be applied only for `getOne` controller action,\r\n    and will be executed *before* action execution.\r\n    To execute middleware *after* action use `@UseAfter` decorator instead.\r\n\r\n3. To use middleware per-controller:\r\n\r\n    ```typescript\r\n    import {Controller, UseBefore} from "routing-controllers";\r\n    let compression = require("compression");\r\n\r\n    @Controller()\r\n    @UseBefore(compression())\r\n    export class UserController {\r\n\r\n    }\r\n    ```\r\n\r\n    This way compression middleware will be applied for all actions of the `UserController` controller,\r\n    and will be executed *before* its action execution. Same way you can use `@UseAfter` decorator here.\r\n\r\n4. If you want to use compression module globally for all controllers you can simply register it during bootstrap:\r\n\r\n    ```typescript\r\n    import "reflect-metadata";\r\n    import {createExpressServer} from "routing-controllers";\r\n    import {UserController} from "./UserController";  // we need to "load" our controller before call createExpressServer. this is required\r\n    let compression = require("compression");\r\n    let app = createExpressServer({\r\n       controllers: [UserController]\r\n    }); // creates express app, registers all controller routes and returns you express app instance\r\n    app.use(compression());\r\n    app.listen(3000); // run express application\r\n    ```\r\n\r\n    Alternatively, you can create a custom [global middleware](#global-middlewares) and simply delegate its execution to the compression module.\r\n\r\n### Creating your own express middleware\r\n\r\nHere is example of creating middleware for express.js:\r\n\r\n1. There are two ways of creating middleware:\r\n\r\n    First, you can create a simple middleware function:\r\n\r\n    ```typescript\r\n    export function loggingMiddleware(request: any, response: any, next?: (err?: any) => any): any {\r\n        console.log("do something...");\r\n        next();\r\n    }\r\n    ```\r\n\r\n    Second you can create a class:\r\n\r\n    ```typescript\r\n    import {ExpressMiddlewareInterface} from "routing-controllers";\r\n\r\n    export class MyMiddleware implements ExpressMiddlewareInterface { // interface implementation is optional\r\n\r\n        use(request: any, response: any, next?: (err?: any) => any): any {\r\n            console.log("do something...");\r\n            next();\r\n        }\r\n\r\n    }\r\n    ```\r\n\r\n    Then you can use them this way:\r\n\r\n    ```typescript\r\n    import {Controller, UseBefore} from "routing-controllers";\r\n    import {MyMiddleware} from "./MyMiddleware";\r\n    import {loggingMiddleware} from "./loggingMiddleware";\r\n\r\n    @Controller()\r\n    @UseBefore(MyMiddleware)\r\n    @UseAfter(loggingMiddleware)\r\n    export class UserController {\r\n\r\n    }\r\n    ```\r\n\r\n    or per-action:\r\n\r\n    ```typescript\r\n    @Get("/users/:id")\r\n    @UseBefore(MyMiddleware)\r\n    @UseAfter(loggingMiddleware)\r\n    getOne(@Param("id") id: number) {\r\n        // ...\r\n    }\r\n    ```\r\n\r\n    `@UseBefore` executes middleware before controller action.\r\n    `@UseAfter` executes middleware after each controller action.\r\n\r\n### Creating your own koa middleware\r\n\r\nHere is example of creating middleware for koa.js:\r\n\r\n1. There are two ways of creating middleware:\r\n\r\n    First, you can create a simple middleware function:\r\n\r\n    ```typescript\r\n    export function use(context: any, next: (err?: any) => Promise<any>): Promise<any> {\r\n            console.log("do something before execution...");\r\n            return next().then(() => {\r\n                console.log("do something after execution");\r\n            }).catch(error => {\r\n                console.log("error handling is also here");\r\n            });\r\n        }\r\n    ```\r\n\r\n    Second you can create a class:\r\n\r\n    ```typescript\r\n    import {KoaMiddlewareInterface} from "routing-controllers";\r\n\r\n    export class MyMiddleware implements KoaMiddlewareInterface { // interface implementation is optional\r\n\r\n        use(context: any, next: (err?: any) => Promise<any>): Promise<any> {\r\n            console.log("do something before execution...");\r\n            return next().then(() => {\r\n                console.log("do something after execution");\r\n            }).catch(error => {\r\n                console.log("error handling is also here");\r\n            });\r\n        }\r\n\r\n    }\r\n    ```\r\n\r\n    Then you can them this way:\r\n\r\n    ```typescript\r\n    import {Controller, UseBefore} from "routing-controllers";\r\n    import {MyMiddleware} from "./MyMiddleware";\r\n    import {loggingMiddleware} from "./loggingMiddleware";\r\n\r\n    @Controller()\r\n    @UseBefore(MyMiddleware)\r\n    @UseAfter(loggingMiddleware)\r\n    export class UserController {\r\n\r\n    }\r\n    ```\r\n\r\n    or per-action:\r\n\r\n    ```typescript\r\n    @Get("/users/:id")\r\n    @UseBefore(MyMiddleware)\r\n    @UseAfter(loggingMiddleware)\r\n    getOne(@Param("id") id: number) {\r\n        // ...\r\n    }\r\n    ```\r\n\r\n    `@UseBefore` executes middleware before controller action.\r\n    `@UseAfter` executes middleware after each controller action.\r\n\r\n### Global middlewares\r\n\r\nGlobal middlewares run before each request, always.\r\nTo make your middleware global mark it with `@Middleware` decorator and specify if it runs after or before controllers actions.\r\n\r\n```typescript\r\nimport {Middleware, ExpressMiddlewareInterface} from "routing-controllers";\r\n\r\n@Middleware({ type: "before" })\r\nexport class LoggingMiddleware implements ExpressMiddlewareInterface {\r\n\r\n    use(request: any, response: any, next: (err: any) => any): void {\r\n        console.log("do something...");\r\n        next();\r\n    }\r\n\r\n}\r\n```\r\n\r\nTo enable this middleware, specify it during routing-controllers initialization:\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer} from "routing-controllers";\r\nimport {UserController} from "./UserController";\r\nimport {LoggingMiddleware} from "./LoggingMiddleware";\r\n\r\ncreateExpressServer({\r\n   controllers: [UserController],\r\n   middlewares: [LoggingMiddleware],\r\n}).listen(3000);\r\n```\r\n\r\n### Error handlers\r\n\r\nError handlers are specific only to express.\r\nError handlers work same way as middlewares, but implement `ExpressErrorMiddlewareInterface`:\r\n\r\n1. Create a class that implements the `ErrorMiddlewareInterface` interface:\r\n\r\n    ```typescript\r\n    import {Middleware, ExpressErrorMiddlewareInterface} from "routing-controllers";\r\n\r\n    @Middleware({ type: "after" })\r\n    export class CustomErrorHandler implements ExpressErrorMiddlewareInterface {\r\n\r\n        error(error: any, request: any, response: any, next: (err: any) => any) {\r\n            console.log("do something...");\r\n            next();\r\n        }\r\n\r\n    }\r\n    ```\r\n\r\nCustom error handlers are invoked after the default error handler, so you won\'t be able to change response code or headers.\r\nTo prevent this, you have to disable default error handler by specifying `defaultErrorHandler` option in createExpressServer or useExpressServer:\r\n\r\n```typescript\r\ncreateExpressServer({\r\n    defaultErrorHandler: false // disable default error handler, only if you have your own error handler\r\n}).listen(3000);\r\n```\r\n\r\n### Loading middlewares, interceptors and controllers from directories\r\n\r\nAlso you can load middlewares from directories. Also you can use glob patterns:\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer} from "routing-controllers";\r\ncreateExpressServer({\r\n    controllers: [__dirname + "/controllers/**/*.js"],\r\n    middlewares: [__dirname + "/middlewares/**/*.js"]\r\n    interceptors: [__dirname + "/interceptors/**/*.js"]\r\n}).listen(3000);\r\n```\r\n\r\n## Using interceptors\r\n\r\nInterceptors are used to change or replace the data returned to the client.\r\nYou can create your own interceptor class or function and use to all or specific controller or controller action.\r\nIt works pretty much the same as middlewares.\r\n\r\n### Interceptor function\r\n\r\nThe easiest way is to use functions directly passed to `@UseInterceptor` of the action.\r\n\r\n```typescript\r\nimport {Get, Param, UseInterceptor} from "routing-controllers";\r\n\r\n// ...\r\n\r\n@Get("/users")\r\n@UseInterceptor(function(action: Action, content: any) {\r\n    // here you have content returned by this action. you can replace something\r\n    // in it and return a replaced result. replaced result will be returned to the user\r\n    return content.replace(/Mike/gi, "Michael");\r\n})\r\ngetOne(@Param("id") id: number) {\r\n    return "Hello, I am Mike!"; // client will get a "Hello, I am Michael!" response.\r\n}\r\n```\r\n\r\nYou can use `@UseInterceptor` per-action, on per-controller.\r\nIf its used per-controller then interceptor will apply to all controller actions.\r\n\r\n### Interceptor classes\r\n\r\nYou can also create a class and use it with `@UseInterceptor` decorator:\r\n\r\n```typescript\r\nimport {Interceptor, InterceptorInterface, Action} from "routing-controllers";\r\n\r\nexport class NameCorrectionInterceptor implements InterceptorInterface {\r\n\r\n    intercept(action: Action, content: any) {\r\n        return content.replace(/Mike/gi, "Michael");\r\n    }\r\n\r\n}\r\n```\r\n\r\nAnd use it in your controllers this way:\r\n\r\n```typescript\r\nimport {Get, Param, UseInterceptor} from "routing-controllers";\r\nimport {NameCorrectionInterceptor} from "./NameCorrectionInterceptor";\r\n\r\n// ...\r\n\r\n@Get("/users")\r\n@UseInterceptor(NameCorrectionInterceptor)\r\ngetOne(@Param("id") id: number) {\r\n    return "Hello, I am Mike!"; // client will get a "Hello, I am Michael!" response.\r\n}\r\n```\r\n\r\n### Global interceptors\r\n\r\nYou can create interceptors that will affect all controllers in your project by creating interceptor class\r\nand mark it with `@Interceptor` decorator:\r\n\r\n```typescript\r\nimport {Interceptor, InterceptorInterface, Action} from "routing-controllers";\r\n\r\n@Interceptor()\r\nexport class NameCorrectionInterceptor implements InterceptorInterface {\r\n\r\n    intercept(action: Action, content: any) {\r\n        return content.replace(/Mike/gi, "Michael");\r\n    }\r\n\r\n}\r\n```\r\n\r\n## Creating instances of classes from action params\r\n\r\nWhen user sends a json object and you are parsing it, sometimes you want to parse it into object of some class, instead of parsing it into simple literal object.\r\nYou have ability to do this using [class-transformer][4].\r\nTo use it simply specify a `classTransformer: true` option on application bootstrap:\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer} from "routing-controllers";\r\n\r\ncreateExpressServer({\r\n    classTransformer: true\r\n}).listen(3000);\r\n```\r\n\r\nNow, when you parse your action params, if you have specified a class, routing-controllers will create you a class\r\nof that instance with the data sent by a user:\r\n\r\n```typescript\r\nexport class User {\r\n    firstName: string;\r\n    lastName: string;\r\n\r\n    getName(): string {\r\n        return this.lastName + " " + this.firstName;\r\n    }\r\n}\r\n\r\n@Controller()\r\nexport class UserController {\r\n\r\n    post(@Body() user: User) {\r\n        console.log("saving user " + user.getName());\r\n    }\r\n\r\n}\r\n```\r\n\r\nIf `User` is an interface - then simple literal object will be created.\r\nIf its a class - then instance of this class will be created.\r\n\r\nThis technique works with `@Body`, `@Param`, `@QueryParam`, `@BodyParam`, and other decorators.\r\nLearn more about class-transformer and how to handle more complex object constructions [here][4].\r\nThis behaviour is enabled by default.\r\nIf you want to disable it simply pass `classTransformer: false` to createExpressServer method.\r\n\r\n## Auto validating action params\r\n\r\nSometimes parsing a json object into instance of some class is not enough.\r\nE.g. `class-transformer` doesn\'t check whether the property\'s types are correct, so you can get runtime error if you rely on TypeScript type safe. Also you may want to validate the object to check e.g. whether the password string is long enough or entered e-mail is correct.\r\n\r\nIt can be done easily thanks to integration with [class-validator][9]. This behaviour is **enabled** by default. If you want to disable it, you need to do it explicitly e.g. by passing `validation: false` option on application bootstrap:\r\n```typescript\r\nimport "reflect-metadata";\r\nimport { createExpressServer } from "routing-controllers";\r\n\r\ncreateExpressServer({\r\n    validation: false\r\n}).listen(3000);\r\n```\r\n\r\nIf you want to turn on the validation only for some params, not globally for every parameter, you can do this locally by setting `validate: true` option in parameter decorator options object:\r\n\r\n```typescript\r\n@Post("/login/")\r\nlogin(@Body({ validate: true }) user: User) {\r\n```\r\n\r\nNow you need to define the class which type will be used as type of controller\'s method param.\r\nDecorate the properties with appropriate validation decorators.\r\n```typescript\r\nexport class User {\r\n\r\n    @IsEmail()\r\n    email: string;\r\n\r\n    @MinLength(6)\r\n    password: string;\r\n\r\n}\r\n```\r\nIf you haven\'t used class-validator yet, you can learn how to use the decorators and handle more complex object validation [here][9].\r\n\r\nNow, if you have specified a class type, your action params will be not only an instance of that class (with the data sent by a user) but they will be validated too, so you don\'t have to worry about eg. incorrect e-mail or too short password and manual checks every property in controller method body.\r\n\r\n```typescript\r\n@Controller()\r\nexport class UserController {\r\n\r\n    @Post("/login/")\r\n    login(@Body() user: User) {\r\n        console.log(`${user.email} is for 100% sure a valid e-mail adress!`);\r\n        console.log(`${user.password.length} is for 100% sure 6 chars or more!`);\r\n    }\r\n\r\n}\r\n```\r\nIf the param doesn\'t satisfy the requirements defined by class-validator decorators,\r\nan error will be thrown and captured by routing-controller, so the client will receive 400 Bad Request and JSON with nice detailed [Validation errors](https://github.com/pleerock/class-validator#validation-errors) array.\r\n\r\nIf you need special options for validation (groups, skipping missing properties, etc.) or transforming (groups, excluding prefixes, versions, etc.), you can pass them as global config as `validation ` in createExpressServer method or as a local `validate` setting for method parameter - `@Body({ validate: localOptions })`.\r\n\r\nThis technique works not only with `@Body` but also with `@Param`, `@QueryParam`, `@BodyParam` and other decorators.\r\n\r\n## Using authorization features\r\n\r\nRouting-controllers comes with two decorators helping you to organize authorization in your application.\r\n\r\n#### `@Authorized` decorator\r\n\r\nTo make `@Authorized` decorator to work you need to setup special routing controllers options:\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer, Action} from "routing-controllers";\r\n\r\ncreateExpressServer({\r\n    authorizationChecker: async (action: Action, roles: string[]) => {\r\n        // here you can use request/response objects from action\r\n        // also if decorator defines roles it needs to access the action\r\n        // you can use them to provide granular access check\r\n        // checker must return either boolean (true or false)\r\n        // either promise that resolves a boolean value\r\n        // demo code:\r\n        const token = action.request.headers["authorization"];\r\n\r\n        const user = await getEntityManager().findOneByToken(User, token);\r\n        if (user && !roles.length)\r\n            return true;\r\n        if (user && roles.find(role => user.roles.indexOf(role) !== -1))\r\n            return true;\r\n\r\n        return false;\r\n    }\r\n}).listen(3000);\r\n```\r\n\r\nYou can use `@Authorized` on controller actions:\r\n\r\n```typescript\r\n@JsonController()\r\nexport class SomeController {\r\n\r\n    @Authorized()\r\n    @Post("/questions")\r\n    save(@Body() question: Question) {\r\n    }\r\n\r\n    @Authorized("POST_MODERATOR") // you can specify roles or array of roles\r\n    @Post("/posts")\r\n    save(@Body() post: Post) {\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### `@CurrentUser` decorator\r\n\r\nTo make `@CurrentUser` decorator to work you need to setup special routing controllers options:\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer, Action} from "routing-controllers";\r\n\r\ncreateExpressServer({\r\n    currentUserChecker: async (action: Action) => {\r\n        // here you can use request/response objects from action\r\n        // you need to provide a user object that will be injected in controller actions\r\n        // demo code:\r\n        const token = action.request.headers["authorization"];\r\n        return getEntityManager().findOneByToken(User, token);\r\n    }\r\n}).listen(3000);\r\n```\r\n\r\nYou can use `@CurrentUser` on controller actions:\r\n\r\n```typescript\r\n@JsonController()\r\nexport class QuestionController {\r\n\r\n    @Get("/questions")\r\n    all(@CurrentUser() user?: User, @Body() question: Question) {\r\n    }\r\n\r\n    @Post("/questions")\r\n    save(@CurrentUser({ required: true }) user: User, @Body() post: Post) {\r\n    }\r\n\r\n}\r\n```\r\n\r\nIf you mark `@CurrentUser` as `required` and currentUserChecker logic will return empty result,\r\n then routing-controllers will throw authorization required error.\r\n\r\n## Using DI container\r\n\r\n`routing-controllers` supports a DI container out of the box. You can inject your services into your controllers,\r\nmiddlewares and error handlers. Container must be setup during application bootstrap.\r\nHere is example how to integrate routing-controllers with [typedi](https://github.com/pleerock/typedi):\r\n\r\n```typescript\r\nimport "reflect-metadata";\r\nimport {createExpressServer, useContainer} from "routing-controllers";\r\nimport {Container} from "typedi";\r\n\r\n// its important to set container before any operation you do with routing-controllers,\r\n// including importing controllers\r\nuseContainer(Container);\r\n\r\n// create and run server\r\ncreateExpressServer({\r\n    controllers: [__dirname + "/controllers/*.js"],\r\n    middlewares: [__dirname + "/middlewares/*.js"],\r\n    interceptors: [__dirname + "/interceptors/*.js"],\r\n}).listen(3000);\r\n```\r\n\r\nThat\'s it, now you can inject your services into your controllers:\r\n\r\n```typescript\r\n@Controller()\r\nexport class UsersController {\r\n\r\n    constructor(private userRepository: UserRepository) {\r\n    }\r\n\r\n    // ... controller actions\r\n\r\n}\r\n```\r\n\r\n## Custom parameter decorators\r\n\r\nYou can create your own parameter decorators.\r\nHere is simple example how "session user" can be implemented using custom decorators:\r\n\r\n```typescript\r\nimport {createParamDecorator} from "routing-controllers";\r\n\r\nexport function UserFromSession(options?: { required?: boolean }) {\r\n    return createParamDecorator({\r\n        required: options && options.required ? true : false,\r\n        value: action => {\r\n            const token = action.request.headers["authorization"];\r\n            return database.findUserByToken(token);\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nAnd use it in your controller:\r\n\r\n```typescript\r\n@JsonController()\r\nexport class QuestionController {\r\n\r\n    @Post()\r\n    save(@Body() question: Question, @UserFromSession({ required: true }) user: User) {\r\n        // here you\'ll have user authorized and you can safely save your question\r\n        // in the case if user returned your undefined from the database and "required"\r\n        // parameter was set, routing-controllers will throw you ParameterRequired error\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n## Decorators Reference\r\n\r\n#### Controller Decorators\r\n\r\n| Signature                            | Example                                              | Description                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n|--------------------------------------|------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| `@Controller(baseRoute: string)`     | `@Controller("/users") class SomeController`         | Class that is marked with this decorator is registered as controller and its annotated methods are registered as actions. Base route is used to concatenate it to all controller action routes.                                                                                                                                                                                                                                                      |\r\n| `@JsonController(baseRoute: string)` | `@JsonController("/users") class SomeJsonController` | Class that is marked with this decorator is registered as controller and its annotated methods are registered as actions. Difference between @JsonController and @Controller is that @JsonController automatically converts results returned by controller to json objects (using JSON.parse) and response being sent to a client is sent with application/json content-type. Base route is used to concatenate it to all controller action routes.  |\r\n\r\n#### Controller Action Decorators\r\n\r\n| Signature                                                      | Example                                | Description                                                                                                                                                                                                       | express.js analogue                  |\r\n|----------------------------------------------------------------|----------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|\r\n| `@Get(route: string\\|RegExp)`                                  | `@Get("/users") all()`                 | Methods marked with this decorator will register a request made with GET HTTP Method to a given route. In action options you can specify if action should response json or regular text response.                 | `app.get("/users", all)`             |\r\n| `@Post(route: string\\|RegExp)`                                 | `@Post("/users") save()`               | Methods marked with this decorator will register a request made with POST HTTP Method to a given route. In action options you can specify if action should response json or regular text response.                | `app.post("/users", save)`           |\r\n| `@Put(route: string\\|RegExp)`                                  | `@Put("/users/:id") update()`          | Methods marked with this decorator will register a request made with PUT HTTP Method to a given route. In action options you can specify if action should response json or regular text response.                 | `app.put("/users", update)`          |\r\n| `@Patch(route: string\\|RegExp)`                                | `@Patch("/users/:id") patch()`         | Methods marked with this decorator will register a request made with PATCH HTTP Method to a given route. In action options you can specify if action should response json or regular text response.               | `app.patch("/users/:id", patch)`     |\r\n| `@Delete(route: string\\|RegExp)`                               | `@Delete("/users/:id") delete()`       | Methods marked with this decorator will register a request made with DELETE HTTP Method to a given route. In action options you can specify if action should response json or regular text response.              | `app.delete("/users/:id", delete)`   |\r\n| `@Head(route: string\\|RegExp)`                                 | `@Head("/users/:id") head()`           | Methods marked with this decorator will register a request made with HEAD HTTP Method to a given route. In action options you can specify if action should response json or regular text response.                | `app.head("/users/:id", head)`       |\r\n| `@Method(methodName: string, route: string\\|RegExp)`            | `@Method("move", "/users/:id") move()` | Methods marked with this decorator will register a request made with given `methodName` HTTP Method to a given route. In action options you can specify if action should response json or regular text response.  | `app.move("/users/:id", move)`       |\r\n\r\n#### Method Parameter Decorators\r\n\r\n| Signature                                                          | Example                                          | Description                                                                                                                             | express.js analogue                       |\r\n|--------------------------------------------------------------------|--------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------|\r\n| `@Req()`                                                           | `getAll(@Req() request: Request)`                | Injects a Request object.                                                                                                               | `function (request, response)`            |\r\n| `@Res()`                                                           | `getAll(@Res() response: Response)`              | Injects a Response object.                                                                                                              | `function (request, response)`            |\r\n| `@Ctx()`                                                           | `getAll(@Ctx() context: Context)`                | Injects a Context object (koa-specific)                                                                                                 | `function (ctx)` (koa-analogue)           |\r\n| `@Param(name: string, options?: ParamOptions)`                     | `get(@Param("id") id: number)`                   | Injects a router parameter.                                                                                                             | `request.params.id`                       |\r\n| `@Params()`                                                        | `get(@Params() params: any)`                     | Injects all router parameters.                                                                                                          | `request.params`                          |\r\n| `@QueryParam(name: string, options?: ParamOptions)`                | `get(@QueryParam("id") id: number)`              | Injects a query string parameter.                                                                                                       | `request.query.id`                        |\r\n| `@QueryParams()`                                                   | `get(@QueryParams() params: any)`                | Injects all query parameters.                                                                                                           | `request.query`                           |\r\n| `@HeaderParam(name: string, options?: ParamOptions)`               | `get(@HeaderParam("token") token: string)`       | Injects a specific request headers.                                                                                                     | `request.headers.token`                   |\r\n| `@HeaderParams()`                                                  | `get(@HeaderParams() params: any)`               | Injects all request headers.                                                                                                            | `request.headers`                         |\r\n| `@CookieParam(name: string, options?: ParamOptions)`               | `get(@CookieParam("username") username: string)` | Injects a cookie parameter.                                                                                                             | `request.cookie("username")`              |\r\n| `@CookieParams()`                                                  | `get(@CookieParams() params: any)`               | Injects all cookies.                                                                                                                    | `request.cookies`                         |\r\n| `@Session()`                                                       | `get(@Session() session: any)`                   | Injects the whole session object.                                                                                                       | `request.session`                         |\r\n| `@SessionParam(name: string)`                                      | `get(@SessionParam("user") user: User)`          | Injects an object from session property.                                                                                                | `request.session.user`                    |\r\n| `@State(name?: string)`                                            | `get(@State() session: StateType)`               | Injects an object from the state (or the whole state).                                                                                  | `ctx.state` (koa-analogue)                |\r\n| `@Body(options?: BodyOptions)`                                     | `post(@Body() body: any)`                        | Injects a body. In parameter options you can specify body parser middleware options.                                                    | `request.body`                            |\r\n| `@BodyParam(name: string, options?: ParamOptions)`                 | `post(@BodyParam("name") name: string)`          | Injects a body parameter.                                                                                                               | `request.body.name`                       |\r\n| `@UploadedFile(name: string, options?: UploadOptions)`             | `post(@UploadedFile("filename") file: any)`      | Injects uploaded file from the response. In parameter options you can specify underlying uploader middleware options.                   | `request.file.file` (using multer)        |\r\n| `@UploadedFiles(name: string, options?: UploadOptions)`            | `post(@UploadedFiles("filename") files: any[])`  | Injects all uploaded files from the response. In parameter options you can specify underlying uploader middleware options.              | `request.files` (using multer)            |\r\n\r\n#### Middleware and Interceptor Decorators\r\n\r\n| Signature                                                          | Example                                                | Description                                                                                                     |\r\n|--------------------------------------------------------------------|--------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|\r\n| `@Middleware({ type: "before"\\|"after" })`                         | `@Middleware({ type: "before" }) class SomeMiddleware` | Registers a global middleware.                                                                                  |\r\n| `@UseBefore()`                                                     | `@UseBefore(CompressionMiddleware)`                    | Uses given middleware before action is being executed.                                                          |\r\n| `@UseAfter()`                                                      | `@UseAfter(CompressionMiddleware)`                     | Uses given middleware after action is being executed.                                                           |\r\n| `@Interceptor()`                                                   | `@Interceptor() class SomeInterceptor`                 | Registers a global interceptor.                                                                                 |\r\n| `@UseInterceptor()`                                                | `@UseInterceptor(BadWordsInterceptor)`                 | Intercepts result of the given controller/action and replaces some values of it.                                |\r\n\r\n#### Other Decorators\r\n\r\n| Signature                                                          | Example                                                   | Description                                                                                                                                    |\r\n|--------------------------------------------------------------------|-----------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| `@Authorized(roles?: string\\|string[])`                            | `@Authorized("SUPER_ADMIN")` get()                        | Checks if user is authorized and has given roles on a given route. `currentUserChecker` should be defined in routing-controllers options.      |                                                              |\r\n| `@CurrentUser(options?: { required?: boolean })`                   | get(@CurrentUser({ required: true }) user: User)          | Injects currently authorized user. `currentUserChecker` should be defined in routing-controllers options.                                      |\r\n| `@Header(contentType: string)`                                     | `@Header("Cache-Control", "private")` get()               | Allows to explicitly set any HTTP header returned in the response.                                                                             |\r\n| `@ContentType(contentType: string)`                                | `@ContentType("text/csv")` get()                          | Allows to explicitly set HTTP Content-Type returned in the response.                                                                           |\r\n| `@Location(url: string)`                                           | `@Location("http://github.com")` get()                    | Allows to explicitly set HTTP Location header returned in the response.                                                                        |\r\n| `@Redirect(url: string)`                                           | `@Redirect("http://github.com")` get()                    | Allows to explicitly set HTTP Redirect header returned in the response.                                                                        |\r\n| `@HttpCode(code: number)`                                          | `@HttpCode(201)` post()                                   | Allows to explicitly set HTTP code to be returned in the response.                                                                             |\r\n| `@OnNull(codeOrError: number\\|Error)`                              | `@OnNull(201)` post()                                     | Sets a given HTTP code when controller action returned null.                                                                                   |\r\n| `@OnUndefined(codeOrError: number\\|Error)`                         | `@OnUndefined(201)` post()                                | Sets a given HTTP code when controller action returned undefined.                                                                              |\r\n| `@ResponseClassTransformOptions(options: ClassTransformOptions)`   | `@ResponseClassTransformOptions({/*...*/})` get()         | Sets options to be passed to class-transformer when it used for classToPlain a response result.                                                |\r\n| `@Render(template: string)`                                        | `@Render("user-list.html")` get()                         | Renders a given html template. Data returned by a controller serve as template variables.                                                      |\r\n\r\n## Samples\r\n\r\n* Take a look on [routing-controllers with express](https://github.com/pleerock/routing-controllers-express-demo) which is using routing-controllers.\r\n* Take a look on [routing-controllers with koa](https://github.com/pleerock/routing-controllers-koa-demo) which is using routing-controllers.\r\n* Take a look on [routing-controllers with angular 2](https://github.com/pleerock/routing-controllers-angular2-demo) which is using routing-controllers.\r\n* Take a look on [node-microservice-demo](https://github.com/swimlane/node-microservice-demo) which is using routing-controllers.\r\n* Take a look on samples in [./sample](https://github.com/pleerock/routing-controllers/tree/master/sample) for more examples\r\nof usage.\r\n\r\n## Release notes\r\n\r\nSee information about breaking changes and release notes [here](CHANGELOG.md).\r\n\r\n[1]: http://expressjs.com/\r\n[2]: http://koajs.com/\r\n[3]: https://github.com/expressjs/multer\r\n[4]: https://github.com/pleerock/class-transformer\r\n[5]: https://www.npmjs.com/package/express-session\r\n[6]: https://www.npmjs.com/package/koa-session\r\n[7]: https://www.npmjs.com/package/koa-generic-session\r\n[8]: http://koajs.com/#ctx-state\r\n[9]: https://github.com/pleerock/class-validator\r\n'