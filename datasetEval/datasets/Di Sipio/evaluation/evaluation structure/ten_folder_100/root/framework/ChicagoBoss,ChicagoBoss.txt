b'Chicago Boss: Start small, dream big\n====================================\n[![Build Status](https://travis-ci.org/ChicagoBoss/ChicagoBoss.svg?branch=master)](https://travis-ci.org/ChicagoBoss/ChicagoBoss)\n\nAttention! This is a master branch supporting Erlang 18. For older Erlang versions use legacy branch.\n\nChicago Boss is a server framework inspired by Rails and written in Erlang. It\noffers all the conveniences of modern web development, including Comet. What sets\nChicago Boss apart from other non-Erlang frameworks is that it can handle large\namounts of traffic without any drop in performance. What sets Chicago Boss apart\nfrom other Erlang frameworks is that it is easy to set up and use.\n\nWARNING: Chicago Boss does not work with Erlang R16B03 due to an error in erl_syntax\n\n60-second Quickstart\n--------------------\n\nAfter downloading and extracting, type\n\n```console\nmake\nmake app PROJECT=mynewproject\ncd ../mynewproject\n./init-dev.sh\n```\n\nFor Windows, type\n\n```console\nwindows-make.bat\nwindows-make.bat app PROJECT=mynewproject\ncd ..\\mynewproject\nstart-server.bat\n```\n\nThen visit http://localhost:8001/ in your browser. Congratulations, you have\na web server. There will be a lot of PROGRESS REPORTs on your console but\neverything should be running smoothly.\n\nThe project name should be a legal Erlang atom, i.e. start with a lowercase\nletter and contain only letters, digits, and underscores (for easy compatibility is recommended name the project dir and app name the same).\n\n\nDependencies\n------------\n\n* Erlang 19.0 or later -\n\n    <http://www.erlang.org/download.html>\n\n  * Check with `erlang:system_info(otp_release)`.\n\n\n* On Windows Vista or Windows 7 -\n\n  * Erlang bin directory must be in PATH.\n\n\nAdmin Interface\n---------------\n\nYou probably want to install the CB admin interface. Download it from\n\n    <https://github.com/ChicagoBoss/cb_admin>\n\n\nUpgrades\n--------\n\nUprading used to be a pain but now it is easy. See README_UPGRADE\n\n\nDatabase Setup\n--------------\n\nBy default CB uses an in-memory database that needs no configuration. To start\nworking with an actual database, See README_DATABASE\n\n\nPhilosophy and Features\n-----------------------\n\nWhy another web framework? Because Rails apps are slow and Node apps are messy.\nChicago Boss takes advantage of functional programming and under-the-hood\ncompiler magic to provide clean, understandable controller logic, Django-style\ntemplates, and an ORM based on Erlang\'s parameterized modules. The best part is\nthat the network I/O is 100% asynchronous so you can seamlessly integrate Comet\nendpoints into your app, and you never have to worry about a slow database\nquery dragging down unrelated requests.\n\nCB ships with all the tools you need to build a feature-ful website, including\nsessions, URL routing, filtering requests and post-processing responses,\nframeworks for sending and receiving email, JSON generation, Comet via\nlong-poll and message queues, and internationalization (i18n). Read on for\ndetails.\n\n*Databases*. Chicago Boss currently supports MySQL, PostgreSQL, Tokyo Tyrant,\nMnesia, MongoDB, and Riak. In CB 0.5.4 and later, you can mix and match\ndatabases by configuring Boss to use vertical shards. For SQL databases, the\nconventions are similar to Rails (plural nouns for the table names, object_id\nfor foreign keys, etc.).\n\n*BossRecords*. Boss\'s take on ActiveRecord is called a BossRecord, which is\nan Erlang parameterized module on steroids. You instantiate a BossRecord like\na regular parameterized module:\n\n```erlang\nArticle = article:new(\'id\', "This is a title", "This is a body")\n```\n\nBut then CB generates functions and attaches them to BossRecords, so you can\nwrite code like\n\n```erlang\n{ok, SavedArticle} = Article:save()\n```\n\nBefore saving to the database, the save() function will call a function called\nvalidation_tests(), where you can perform custom validation logic.\n\nCB also generates getter functions which can be invoked directly in templates,\nso in your template you can write things like\n\n```erlang\n{{ article.title }}\n```\n\nSpeaking of which...\n\n*Templates*. Chicago Boss uses ErlyDTL, an Erlang implentation of Django template\nlanguage. In fact, Chicago Boss originated with a rewrite of ErlyDTL, and the same\nperson maintains both projects so you always get the latest ErlyDTL features. Templates\ncan access and loop over values stored in proplists, dictionaries, and BossRecords,\nso you can move data from the database to your templates with a minimum of massaging.\n\nIn addition, templates are tightly integrated with Boss\'s i18n machinery. The admin\ninterface automatically parses templates for translatable strings, and Boss can\nchoose which language to serve based on the request\'s Accept-Languages header and\nthe calculated translation coverage for a particular page. Multi-language websites\nare easy to develop with Chicago Boss.\n\n*Controllers*. Erlang\'s pattern-matching is a perfect fit for writing\ncontroller logic. Your controllers are passed the URL method (GET, POST) and a list\nof URL tokens, and just need to return a tuple telling Boss what to do, for example:\n\n* `{ok, Variables}` - render the default template with Variables\n* `{render_other, Variables}` - render another template\n* `{redirect, URL}` - redirect the request\n* `{json, Proplist}` - encode the Proplist as JSON and send to the client\n* `{output, Data}` - send Data to the client\n\nIf you come from Rails, you\'ll instantly notice the benefit of Erlang\'s\nlanguage design: you don\'t need an ugly `case request.method` statement inside\nevery action, you never have atrocities like `render and return`, and you can\nalways see every variable that is in scope. In CB apps, controller logic is\nalways concise and usually a pleasure to read.\n\n*Sessions*. You can configure sessions to be stored in memory (ETS) or in an\nMnesia database.  The `boss_session` and `boss_flash` modules provide functions\nfor storing and retrieving session information.\n\n*Routes*. By default, Chicago Boss uses the same routing conventions as Ruby on\nRails (`/controller/action/id`). You can customize the routes and provide\na base URL in the priv/application.routes file. Of course, most routing occurs\nwith the pattern-matching controller logic, e.g.\n```erlang\nposts(\'GET\', ["category", Category]) ->\n```\n\nYou can then generate URLs to match controller patterns in your templates like\nso:\n\n    {% url action="posts" category="some category" %}\n\n*Email*. Chicago Boss ships with a miniature MVC for sending multipart emails.\nEmails can be templated with ErlyDTL, and it is easy to provide plain-text and\nHTML versions of the same email. In testing environments, email can be sent\ndirectly to the recipient, or in production can be relayed to an SMTP server.\n\nA Chicago Boss server can also receive email over SMTP. Each email address maps\nto a function in your incoming mail controller, so it is easy to write\nwell-organized email applications. Your email controller has access to the\nexact same resources as your web controllers, including database requests,\nBossRecord instantiation, and the message queue; web and email are fully\nintegrated.\n\n*Comet*. It\'s simple to write a Comet endpoint in Chicago Boss. Unlike any\nother language, Erlang gives you the benefits of asynchronous network\ncommuncation without using callbacks. Here is a trivial example of a long-poll\ncontroller:\n\n```erlang\nlongpoll(\'GET\', [Channel]) ->\n    {ok, Timestamp, Messages} = boss_mq:pull(Channel, last),\n    {json, [{timestamp, Timestamp}, {messages, Messages}]}.\n```\n\nThe call to `pull` blocks until a message is received. Because processes are\ncheap in Erlang, the overhead of keeping alive a blocking request is very small\n(just a few kilobytes of memory, compared to megabytes in Rails). You can\nthus keep alive thousands of Comet request with just a few megabytes of memory.\nAlso notice that the controller logic remains nice and clean (no callbacks). We\ncan perform an arbitrary sequence of asynchronous network requests without\nincreasing the scope level.\n\n*Events*. An interesting feature of Chicago Boss is the events API called\nBossNews. With it, you can watch a record or a set of records for changes,\nthen execute a callback when a change is witnessed. Combined with long-polling,\nyou can provide a real-time view of your database on your website. Events can\nalso be used to provide a clean separation of business logic and notification\nlogic.\n\n*Tests*. Chicago Boss has a kick-ass testing framework. Once you try it you\nwon\'t go back. That\'s all I\'ll say for now.\n\n\nFuture Work\n-----------\n\nMost of Chicago Boss\'s planned features have been implemented at this point. It\nhasn\'t really been tested in a distributed environment, but it\'s already\nrunning on a few public-facing websites, and many more internal websites (or so\nI am told). It would be nice to add more databases (such as CouchDB and Oracle)\nand support horizontal sharding. The last main feature before 1.0 will be\nthe ability to distribute apps written in Chicago Boss as standalone OTP\napplications.\n\n\nFurther Reading\n---------------\n\nSee the FAQ and API files located at\n\n<http://www.chicagoboss.org/>\n\nIf you need help getting started, check the new pdf tutorial:\n\n<http://www.chicagoboss.org/tutorial.pdf>\n\nBe sure to also check the wiki\n\n<https://github.com/ChicagoBoss/ChicagoBoss/wiki>\n\nThere\'s also the mailing list:\n\n<http://groups.google.com/group/chicagoboss>\n\nIf you want to contribute to CB\n\n[CODING_STANDARDS.md](https://github.com/ChicagoBoss/ChicagoBoss/blob/master/CODING_STANDARDS.md)\n\nView the CHANGELOG.md\n\n[CHANGELOG.md](https://github.com/ChicagoBoss/ChicagoBoss/blob/master/CHANGELOG.md)\n'