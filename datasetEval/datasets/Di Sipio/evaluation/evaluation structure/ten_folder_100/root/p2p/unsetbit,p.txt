b'# <a href="http://unsetbit.com/p">P</a> is for peer-to-peer networking with browsers\n\nP is a small framework used to create browser-to-browser networks (as opposed to just a connection). With P, you can:\n\n* Connect to other browsers using [a simple WebSocket server](https://github.com/unsetbit/onramp).\n* Connect to other browsers using your established connections to other browsers. This is what makes P unique: it allows for transitive connections across peers, allowing easy creation of mesh networks.\n\nAfter a connection is established the middleman is no longer necessary \xe2\x80\x93 no proxies are involved.\n\nThis is made possible by an unstable and young technology -- [WebRTC](http://www.webrtc.org/).\nCurrently, only Chrome and Firefox support this technology.\n\n[onramp](https://github.com/unsetbit/onramp), a simple WebSocket server, is used as the signaling channel\nto establish initial connections.\n\n## API\n```javascript\n// Initializing\nvar rootNode = P.create(); // create the root node\n\n// Connection management\nvar webSocketNode = rootNode.connect(address); // connect to an onramp WebSocket server\nvar webRtcNode = webSocketNode.connect(address); // connect to a peer using an onramp connection\nvar webRtcNode = webRtcNode.connect(address); // connect to a peer using an existing peer connection\nanyNode.close(); // close the connection\nanyNode.isOpen(); // return true if the connection is open\nvar nodeArray = anyNode.getPeers(); // returns an array of all peer connections\n\n// Firewalling connections\nvar protectedNode = P.create({\n  firewall: function(offerData){\n    // Only accept RTC connection offers which send \'secret\' as the offer data\n    // this firewall rule will apply to any child nodes as well\n    return offerData === \'secret\';\n  }\n});\n\n\n// Send offerData with a connection request\nanyNode.connect({address: address, offerData: \'secret\'});\n\n\n// Sending and receiving messages\nwebRtcNode.send(message); // send a message to a peer; can be json, string, or arraybuffer\nwebRtcNode.on(\'message\', function(message){}); // listens for messages from a peer\nwebRtcNode.on(\'array buffer\', function(arrayBuffer){}); // listens for array buffers from a peer\n\n// Events\nanyNode.on(\'connection\', function(peerNode){}); // emitted when a connection is made via this peer\nanyNode.on(\'open\', function(){}); // emitted when this connection is open and ready\nanyNode.on(\'close\', function(){}); // emitted when this connection is closed\nanyNode.on(\'error\', function(err){}); // listens for errors for this connection\nanyNode.removeListener(eventName, optionalCallback); // stops listening to an event\n```\n\n\n## Documentation\n* [Example with walkthrough](http://unsetbit.com/p/#walkthrough)\n* [API](http://unsetbit.com/p/#use)\n* [Cookbook](http://unsetbit.com/p/#cookbook)\n* [Contribute](http://unsetbit.com/p/#contribute)\n\n## Release Notes\n* 0.3.3 - Fixed an issue in FF which caused disconnections shorting after successful connections due to a GC miscommunication which seems to clean up DataChannels which are still in use (thereby closing them).\n* 0.3.2 - Updated the library to align it with the latest WebRTC standards -- mainly changes in configuration objects.\n* 0.3.1 - Added \'firewall\' option to firewall RTC requests.\n* 0.3 - Major refactor of internals and simplification of API, Firefox support, and respectable unit test coverage.\n* 0.2 - Public release\n'