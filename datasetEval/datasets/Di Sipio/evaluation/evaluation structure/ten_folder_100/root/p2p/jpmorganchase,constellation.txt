b'# Constellation\n\nConstellation is a self-managing, peer-to-peer system in which each\nnode:\n\n  - Hosts a number of NaCl (Curve25519) public/private key pairs.\n\n  - Automatically discovers other nodes on the network after\n    synchronizing with as little as one other host.\n\n  - Synchronizes a directory of public keys mapped to recipient hosts\n    with other nodes on the network.\n\n  - Exposes a public API which allows other nodes to send encrypted\n    bytestrings to your node, and to synchronize, retrieving\n    information about the nodes that your node knows about.\n\n  - Exposes a private API which:\n\n      - Allows you to send a bytestring to one or more public keys,\n        returning a content-addressable identifier. This bytestring is\n        encrypted transparently and efficiently (at symmetric\n        encryption speeds) before being transmitted over the wire to\n        the correct recipient nodes (and only those nodes.) The\n        identifier is a hash digest of the encrypted payload that\n        every recipient node receives. Each recipient node also\n        receives a small blob encrypted for their public key which\n        contains the Master Key for the encrypted payload.\n\n      - Allows you to receive a decrypted bytestring\n        based on an identifier. Payloads which your node has sent or\n        received can be decrypted and retrieved in this way.\n\n      - Exposes methods for deletion, resynchronization, and other\n        management functions.\n\n  - Supports a number of storage backends including LevelDB,\n    BerkeleyDB, SQLite, and Directory/Maildir-style file storage\n    suitable for use with any FUSE adapter, e.g. for AWS S3.\n\n  - Uses mutually-authenticated TLS with modern settings and various trust\n    models including hybrid CA/tofu (default), tofu (think OpenSSH), and\n    whitelist (only some set of public keys can connect.)\n\n  - Supports access controls like an IP whitelist.\n\nConceptually, one can think of Constellation as an amalgamation of a\ndistributed key server, PGP encryption (using modern cryptography,)\nand Mail Transfer Agents (MTAs.)\n\nConstellation\'s current primary application is to implement the\n"privacy engine" of Quorum, a fork of Ethereum with support for\nprivate transactions that function exactly as described in this\nREADME. Private transactions in Quorum contain only a flag indicating\nthat they\'re private and the content-addressable identifier described\nhere.\n\nConstellation can be run stand-alone as a daemon via\n`constellation-node`, or imported as a Haskell library, which allows\nyou to implement custom storage and encryption logic.\n\n## Installation\n\n### Prerequisites\n\n  1. Install supporting libraries:\n    - Ubuntu: `apt-get install libdb-dev libleveldb-dev libsodium-dev zlib1g-dev libtinfo-dev`\n    - Red Hat: `dnf install libdb-devel leveldb-devel libsodium-devel zlib-devel ncurses-devel`\n    - MacOS: `brew install berkeley-db leveldb libsodium`\n\n### Downloading precompiled binaries\n\nConstellation binaries for most major platforms can be downloaded [here](https://github.com/jpmorganchase/constellation/releases).\n\n### Installation from source\n\n  1. First time only: Install Stack:\n    - Linux: `curl -sSL https://get.haskellstack.org/ | sh`\n    - MacOS: `brew install haskell-stack`\n\n  2. First time only: run `stack setup` to install GHC, the Glasgow\n     Haskell Compiler\n\n  3. Run `stack install`\n\n## Generating keys\n\n  1. To generate a key pair "node", run `constellation-node --generatekeys=node`\n\n  If you choose to lock the keys with a password, they will be encrypted using\n  a master key derived from the password using Argon2id. This is designed to be\n  a very expensive operation to deter password cracking efforts. When\n  constellation encounters a locked key, it will prompt for a password after\n  which the decrypted key will live in memory until the process ends.\n\n## Running\n\n  1. Run `constellation-node <path to config file>` or specify configuration\n     variables as command-line options (see `constellation-node --help`)\n\nFor now, please refer to the [Constellation client Go library](https://github.com/jpmorganchase/quorum/blob/master/private/constellation/node.go)\nfor an example of how to use Constellation. More detailed documentation coming soon!\n\n## Configuration File Format\n\nSee [sample.conf](sample.conf).\n\n## How It Works\n\nEach Constellation node hosts some number of key pairs, and advertises\na publicly accessible FQDN/port for other hosts to connect to.\n\nNodes can be started with a reference to existing nodes on the network\n(with the `othernodes` configuration variable,) or without, in which\ncase some other node must later be pointed to this node to achieve\nsynchronization.\n\nWhen a node starts up, it will reach out to each node in `othernodes`,\nand learn about the public keys they host, as well as other nodes in\nthe network. In short order, the node\'s public key directory will be\nthe same as that of all other nodes, and you can start addressing\nmessages to any of the known public keys.\n\nThis is what happens when you use the `send` function of the Private\nAPI to send the bytestring `foo` to the public key\n`ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=`:\n\n  1. You send a POST API request to the Private API socket like:\n     `{"payload": "foo", "from": "mypublickey", to: "ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc="}`\n\n  2. The local node generates using `/dev/urandom` (or similar):\n       - A random Master Key (MK) and nonce\n       - A random recipient nonce\n\n  3. The local node encrypts the payload using NaCl `secretbox` using\n     the random MK and nonce.\n\n  4. The local node generates an MK container for each recipient\n     public key; in this case, simply one container for `ROAZ...`,\n     using NaCl `box` and the recipient nonce.\n\n     NaCl `box` works by deriving a shared key based\n     on your private key and the recipient\'s public key. This is known\n     as elliptic curve key agreement.\n\n     Note that the sender public key and recipient public key we\n     specified above aren\'t enough to perform the\n     encryption. Therefore, the node will check to see that it is\n     actually hosting the private key that corresponds to the given\n     public key before generating an MK container for each recipient\n     based on SharedKey(yourprivatekey, recipientpublickey) and the\n     recipient nonce.\n\n     We now have:\n\n       - An encrypted payload which is `foo` encrypted with the random\n         MK and a random nonce. This is the same for all recipients.\n\n       - A random recipient nonce that also is the same for all\n         recipients.\n\n       - For each recipient, the MK encrypted with the\n         shared key of your private key and their public key. This\n         MK container is unique per recipient, and is only transmitted to\n         that recipient.\n\n  5. For each recipient, the local node looks up the recipient host,\n     and transmits to it:\n\n       - The sender\'s (your) public key\n\n       - The encrypted payload and nonce\n\n       - The MK container for that recipient and the recipient nonce\n\n  6. The recipient node returns a SHA3-512 hash digest of the\n     encrypted payload, which represents its storage address.\n\n     (Note that it is not possible for the sender to dictate the\n     storage address. Every node generates it independently by hashing\n     the encrypted payload.)\n\n  7. The local node stores the payload locally, generating the same\n     hash digest.\n\n  8. The API call returns successfully once all nodes have confirmed\n     receipt and storage of the payload, and returned a hash digest.\n\nNow, through some other mechanism, you\'ll inform the recipient that\nthey have a payload waiting for them with the identifier `owqkrokwr`,\nand they will make a call to the `receive` method of their Private\nAPI:\n\n  1. Make a call to the Private API socket `receive` method:\n     `{"key": "qrqwrqwr"}`\n\n  2. The local node will look in its storage for the key `qrqwrqwr`,\n     and abort if it isn\'t found.\n\n  3. When found, the node will use the information about the sender as\n     well as its private key to derive SharedKey(senderpublickey,\n     yourprivatekey) and decrypt the MK container using NaCl `box`\n     with the recipient nonce.\n\n  4. Using the decrypted MK, the local node will decrypt the encrypted\n     payload using NaCl `secretbox` using the main nonce.\n\n  5. The API call returns the decrypted data.\n\n# Getting Help\n\nStuck at some step? Have no fear, the help is here <a href="https://clh7rniov2.execute-api.us-east-1.amazonaws.com/Express/" target="_blank" rel="noopener"><img title="Quorum Slack" src="https://clh7rniov2.execute-api.us-east-1.amazonaws.com/Express/badge.svg" alt="Quorum Slack" /></a>\n'