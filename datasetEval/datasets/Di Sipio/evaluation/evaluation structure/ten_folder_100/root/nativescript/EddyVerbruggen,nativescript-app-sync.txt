b'# NativeScript AppSync plugin\n\n[![Build Status][build-status]][build-url]\n[![NPM version][npm-image]][npm-url]\n[![Downloads][downloads-image]][npm-url]\n[![Twitter Follow][twitter-image]][twitter-url]\n\n[build-status]:https://travis-ci.org/EddyVerbruggen/nativescript-app-sync.svg?branch=master\n[build-url]:https://travis-ci.org/EddyVerbruggen/nativescript-app-sync\n[npm-image]:http://img.shields.io/npm/v/nativescript-app-sync.svg\n[npm-url]:https://npmjs.org/package/nativescript-app-sync\n[downloads-image]:http://img.shields.io/npm/dm/nativescript-app-sync.svg\n[twitter-image]:https://img.shields.io/twitter/follow/eddyverbruggen.svg?style=social&label=Follow%20me\n[twitter-url]:https://twitter.com/eddyverbruggen\n\nA live-update service for your NativeScript apps!\n\n> \xf0\x9f\x93\xa3 **NOTE:** NativeScript AppSync is currently in beta and is *not supported* by the core NativeScript team. AppSync is based on [Microsoft CodePush](https://github.com/microsoft/code-push) and we owe them thanks because this solution builds upon their work. \xe2\x9d\xa4\xef\xb8\x8f\n\n<details>\n <summary>Optional reading: what this is, and how it works</summary>\n\nA NativeScript app is composed of XML/HTML, CSS and JavaScript files and any accompanying images, which are bundled together by the NativeScript CLI and distributed as part of a platform-specific binary (i.e. an .ipa or .apk file). Once the app is released, updating either the code (e.g. making bug fixes, adding new features) or image assets, requires you to recompile and redistribute the entire binary, which of course, includes any review time associated with the store(s) you are publishing to.\n\nThe AppSync plugin helps get product improvements in front of your end users instantly, by keeping your code and images synchronized with updates you release to the AppSync server. This way, your app gets the benefits of an offline mobile experience, as well as the "web-like" agility of side-loading updates as soon as they are available. It\'s a win-win!\n\nIn order to ensure that your end users always have a functioning version of your app, the AppSync plugin maintains a copy of the previous update, so that in the event that you accidentally push an update which includes a crash, it can automatically roll back. This way, you can rest assured that your newfound release agility won\'t result in users becoming blocked before you have a chance to roll back on the server. It\'s a win-win-win!\n\n<img src="https://github.com/EddyVerbruggen/nativescript-app-sync/raw/master/media/NativeScript%20AppSync%20landscape%20v2.png" width="570px" height="508px">\n\n_Architectural overview of the solution - you don\'t need to worry about all of this_\n\n</details>\n\n### What can (and will) be AppSync\'ed?\n- Anything inside your `/app` folder (but not the `App_Resources` folder).\n- Anything inside your `/node_modules` folder.\n\n> \xf0\x9f\x92\x81\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f Note that we don\'t actually use those folders, but the `app` folder in `platforms/ios/<appname>/app` and `platforms/android/app/src/main/assets/app`, the benefit of which is we don\'t "care" if you use Webpack or Uglify or whatever tools you use to minify or scramble your app\'s assets.\n\n### What can\'t (and won\'t):\n- NativeScript platform updates. Example: bumping `tns-android` from version 2.5.1 to 2.5.2.\n- Plugins updates that also require a different version of a native library it depends on.\n- Contents of the `App_Resources` folder, because those are part of the native binary as well.\n\nSo as long as you don\'t change versions of dependencies and tns platforms in your `package.json` you\ncan push happily. And if you do bump a version of a dependency make sure there are no changed platform libraries.\n\n## Getting Started\n\n#### Globally install the NativeScript AppSync CLI\n\n```shell\nnpm i -g nativescript-app-sync-cli\n```\n\n> \xf0\x9f\x92\x81\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f This will also add the global `nativescript-app-sync` command to your machine. You can check the currently installed version with `nativescript-app-sync -v`.\n\n#### Login or register with the service\n\nCheck if you\'re already logged in, and with which email address:\n\n```shell\nnativescript-app-sync whoami\n```\n\nLog in if you already have an account:\n\n```shell\nnativescript-app-sync login\n```\n\nRegister if you don\'t have an account yet:\n\n```shell\nnativescript-app-sync register\n```\n\nThis will open a browser where you can provide your credentials, after which you can create an access key that\nyou can paste in the console.\n\nYou should now have a `.nativescript-app-sync.config` file in your home folder which will automatically\nauthenticate you with the server on this machine from now on.\n\n> Note that you _could_ use a that web interface for managing you apps, but the CLI is much more sophisticated, so it\'s recommended to use the command line interface.\n\nTo log out, you can run `nativescript-app-sync logout` which will also remove the config file.\n\nTo perform a headless login (without opening a browser), you can do: `nativescript-app-sync login --accessKey <access key>`.\n\n#### Register your app with the service\nCreate an app *for each platform you target*. That way you can roll out release seperately for iOS and Android.\n\n> \xe2\x9a\xa0\xef\xb8\x8f The `appname` must be unique, and should not contain dashes (`-`).\n\n```shell\nnativescript-app-sync app add <appname> <platform>\n\n# examples:\nnativescript-app-sync app add MyAppIOS ios\nnativescript-app-sync app add MyAppAndroid android\n```\n\n> \xf0\x9f\x92\x81\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f This will show you your deployment keys you\'ll need when connecting to the AppSync server. If you want to list those keys at any later time, use `nativescript-app-sync deployment ls <appName> --displayKeys`.\n\n> \xf0\x9f\x92\x81\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f All new apps automatically come with two deployments (`Staging` and `Production`) so that you can begin distributing updates to multiple channels. If you need more channels/deployments, simply run: `nativescript-app-sync deployment add <appName> <deploymentName>`.\n\n> \xf0\x9f\x92\x81\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f Want to rename your app? At any time, use the command: `nativescript-app-sync app rename <oldName> <newName>`\n\n> \xf0\x9f\x92\x81\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f Want to delete an app? At any time, use the command: `nativescript-app-sync app remove <appName>` - this means any apps that have been configured to use it will obviously stop receiving updates.\n\n#### List your registered apps\n\n```shell\nnativescript-app-sync app ls\n```\n\n#### Add this plugin to your app\n\n```shell\ntns plugin add nativescript-app-sync\n```\n\n> \xe2\x9a\xa0\xef\xb8\x8f If you\'re restricting access to the internet from within your app, make sure you whitelist our AppSync server (`https://appsync-server.nativescript.org`) and File server (`https://s3.eu-west-1.amazonaws.com`).\n\n## Checking for updates\nWith the AppSync plugin installed and configured, the only thing left is to add the necessary code to your app to control when it checks for updates.\n\nIf an update is available, it will be silently downloaded, and installed.\n \nThen based on the provided `InstallMode` the plugin either waits until the next cold start (`InstallMode.ON_NEXT_RESTART`),\nwarm restart (`InstallMode.ON_NEXT_RESUME`), or a positive response to a user prompt (`InstallMode.IMMEDIATE`).\n\nNote that Apple doesn\'t want you to prompt the user to restart your app, so use `InstallMode.IMMEDIATE` on iOS only for Enterprise-distributed apps (or when testing your app through TestFlight for instance).\n\n> \xf0\x9f\x92\x81\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f Check out the [demo](/demo) for a solid example.\n\n```typescript\n// import the main plugin classes\nimport { AppSync } from "nativescript-app-sync";\n\n// and at some point in your app:\nAppSync.sync({\n  deploymentKey: "your-deployment-key" // note that this key depends on the platform you\'re running on (see the example below)\n});\n```\n\nThere\'s a few things you can configure - this TypeScript example has all the possible options:\n\n```typescript\nimport { AppSync, InstallMode, SyncStatus } from "nativescript-app-sync";\nimport { isIOS } from "tns-core-modules/platform";\n\nAppSync.sync({\n    enabledWhenUsingHmr: false, // this is optional and by default false so AppSync and HMR don\'t fight over app updates\n    deploymentKey: isIOS ? "your-ios-deployment-key" : "your-android-deployment-key",\n    installMode: InstallMode.ON_NEXT_RESTART, // this is the default install mode; the app updates upon the next cold boot (unless the --mandatory flag was specified while pushing the update) \n    mandatoryInstallMode: isIOS ? InstallMode.ON_NEXT_RESUME : InstallMode.IMMEDIATE, // the default is InstallMode.ON_NEXT_RESUME which doesn\'t bother the user as long as the app is in the foreground. InstallMode.IMMEDIATE shows an installation prompt. Don\'t use that for iOS AppStore distributions because Apple doesn\'t want you to, but if you have an Enterprise-distributed app, go right ahead!\n    updateDialog: { // only used for InstallMode.IMMEDIATE\n      updateTitle: "Please restart the app", // an optional title shown in the update dialog \n      optionalUpdateMessage: "Optional update msg",   // a message shown for non-"--mandatory" releases \n      mandatoryUpdateMessage: "Mandatory update msg", // a message shown for "--mandatory" releases\n      optionalIgnoreButtonLabel: "Later", // if a user wants to continue their session, the update will be installed on next resume\n      mandatoryContinueButtonLabel: isIOS ? "Exit now" : "Restart now", // On Android we can kill and restart the app, but on iOS that\'s not possible so the user has to manually restart it. That\'s why we provide a different label in this example.\n      appendReleaseDescription: true // appends the description you (optionally) provided when releasing a new version to AppSync\n    }\n  }, (syncStatus: SyncStatus, updateLabel?: string): void => {\n    console.log("AppSync syncStatus: " + syncStatus);\n    if (syncStatus === SyncStatus.UP_TO_DATE) {\n      console.log(`AppSync: no pending updates; you\'re running the latest version, which is ${updateLabel}`);\n    } else if (syncStatus === SyncStatus.UPDATE_INSTALLED) {\n      console.log(`AppSync: update installed (${updateLabel}) - it will be activated upon next cold boot`);\n    }\n});\n```\n\n<details>\n <summary>Click here to see a JavaScript example</summary>\n\n```js\nvar AppSync = require("nativescript-app-sync").AppSync;\nvar InstallMode = require("nativescript-app-sync").InstallMode;\nvar SyncStatus = require("nativescript-app-sync").SyncStatus;\nvar platform = require("tns-core-modules/platform");\n\nAppSync.sync({\n    enabledWhenUsingHmr: false, // this is optional and by default false so AppSync and HMR don\'t fight over app updates\n    deploymentKey: platform.isIOS ? "your-ios-deployment-key" : "your-android-deployment-key",\n    installMode: InstallMode.ON_NEXT_RESTART,\n    mandatoryInstallMode: platform.isIOS ? InstallMode.ON_NEXT_RESUME : InstallMode.IMMEDIATE,\n    updateDialog: {\n      optionalUpdateMessage: "Optional update msg",\n      updateTitle: "Please restart the app",\n      mandatoryUpdateMessage: "Mandatory update msg",\n      optionalIgnoreButtonLabel: "Later",\n      mandatoryContinueButtonLabel: platform.isIOS ? "Exit now" : "Restart now",\n      appendReleaseDescription: true // appends the description you (optionally) provided when releasing a new version to AppSync\n    }\n}, function (syncStatus, updateLabel) {\n    if (syncStatus === SyncStatus.UP_TO_DATE) {\n      console.log("AppSync: no pending updates; you\'re running the latest version, which is: " + updateLabel);\n    } else if (syncStatus === SyncStatus.UPDATE_INSTALLED) {\n      console.log("AppSync: update (" + updateLabel + ") installed - it will be activated upon next cold boot");\n    }\n});\n```\n\n</details>\n\n#### When should this check run?\nIt\'s recommended to check for updates more than once in a cold boot cycle,\nso it may be easiest to tie this check to the `resume` event (which usually also runs on app startup):\n\n```typescript\nimport * as application from "tns-core-modules/application";\nimport { AppSync } from "nativescript-app-sync";\n\n// add this in some central place that\'s executed once in a lifecycle\napplication.on(application.resumeEvent, () => {\n  AppSync.sync(...);\n});\n```\n\n<details>\n  <summary>Click here to see a JavaScript example</summary>\n  \n```js\nvar application = require("tns-core-modules/application");\n\napplication.on(application.resumeEvent, function () {\n  // call the sync function\n});\n```\n\n</details>\n\n## Releasing an update\nOnce your app has been configured and distributed to your users, and you\'ve made some code and/or asset changes,\nit\'s time to instantly unleash those changes onto your users!\n\n> \xe2\x9a\xa0\xef\xb8\x8f Make sure to create a *release build* first, so use the same command that you\'d use for app store distribution, just don\'t send it to the AppStore. You can even Webpack and Uglify your app, it\'s all transparent to this plugin.\n\n> \xf0\x9f\x92\x81\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f When releasing updates to AppSync, you do not need to bump your app\'s version since you aren\'t modifying the app store version at all. AppSync will automatically generate a "label" for each release you make (e.g. `v3`) in order to help identify it within your release history.\n\nThe easiest way to do this is to use the `release` command in our AppSync CLI. Its (most relevant) options are:\n\n|param|alias|default|description\n|---|---|---|---\n|deploymentName|d|"Staging"|Deploy to either "Staging" or "Production".\n|description|des|not set|Description of the changes made to the app with this release.\n|targetBinaryVersion|t|`App_Resources`|Semver expression that specifies the binary app version(s) this release is targeting (e.g. 1.1.0, ~1.2.3). The default is the exact version in `App_Resources/iOS/Info.plist` or `App_Resources/Android/AndroidManifest.xml`. \n|mandatory|m|not set|This specifies whether or not the update should be considered "urgent" (e.g. it includes a critical security fix). This attribute is simply round tripped to the client, who can then decide if and how they would like to enforce it. If this flag is not set, the update is considered "not urgent" so you may choose to wait for the next cold boot of the app. It does not mean users get to \'opt out\' from an update; all AppSync updates will eventually be installed on the client.\n\nHave a few examples for both platforms:\n\n#### iOS\n\n```shell\nnativescript-app-sync release <c-ios-appname> ios # deploy to Staging\nnativescript-app-sync release <AppSync-ios-appname> ios --d Production # deploy to Production (default: Staging)\nnativescript-app-sync release <AppSync-ios-appname> ios --targetBinaryVersion ~1.0.0 # release to users running any 1.x version (default: the exact version in Info.plist)\nnativescript-app-sync release <AppSync-ios-appname> ios --mandatory --description "My mandatory iOS version" # a release for iOS that needs to be applied ASAP.\n```\n\n#### Android\n\n```shell\nnativescript-app-sync release <AppSync-android-appname> android # deploy to Staging\nnativescript-app-sync release <AppSync-android-appname> android --d Production # deploy to Production (default: Staging)\nnativescript-app-sync release <AppSync-android-appname> android --targetBinaryVersion ~1.0.0 # release to users running any 1.x version (default: the exact version in AndroidManifest.xml)\n```\n\n<details>\n  <summary>Click here to learn more about the --targetBinaryVersion param</summary>\nThe `targetBinaryVersion` specifies the store/binary version of the application you are releasing the update for, so that only users running that version will receive the update, while users running an older and/or newer version of the app binary will not. This is useful for the following reasons:\n\n1. If a user is running an older binary version, it\'s possible that there are breaking changes in the AppSync update that wouldn\'t be compatible with what they\'re running.\n\n2. If a user is running a newer binary version, then it\'s presumed that what they are running is newer (and potentially incompatible) with the AppSync update.\n\nIf you ever want an update to target multiple versions of the app store binary, we also allow you to specify the parameter as a [semver range expression](https://github.com/npm/node-semver#advanced-range-syntax). That way, any client device running a version of the binary that satisfies the range expression (i.e. `semver.satisfies(version, range)` returns `true`) will get the update. Examples of valid semver range expressions are as follows:\n\n| Range Expression | Who gets the update                                                                    |\n|------------------|----------------------------------------------------------------------------------------|\n| `1.2.3`          | Only devices running the specific binary app store version `1.2.3` of your app         |\n| `*`              | Any device configured to consume updates from your AppSync app                        |\n| `1.2.x`          | Devices running major version 1, minor version 2 and any patch version of your app     |\n| `1.2.3 - 1.2.7`  | Devices running any binary version between `1.2.3` (inclusive) and `1.2.7` (inclusive) |\n| `>=1.2.3 <1.2.7` | Devices running any binary version between `1.2.3` (inclusive) and `1.2.7` (exclusive) |\n| `1.2`            | Equivalent to `>=1.2.0 <1.3.0`                                                         |\n| `~1.2.3`         | Equivalent to `>=1.2.3 <1.3.0`                                                         |\n| `^1.2.3`         | Equivalent to `>=1.2.3 <2.0.0`                                                         |\n\n*NOTE: If your semver expression starts with a special shell character or operator such as `>`, `^`, or **\n*, the command may not execute correctly if you do not wrap the value in quotes as the shell will not supply the right values to our CLI process. Therefore, it is best to wrap your `targetBinaryVersion` parameter in double quotes when calling the `release` command, e.g. `app-sync release MyApp-iOS updateContents ">1.2.3"`.*\n\n*NOTE: As defined in the semver spec, ranges only work for non pre-release versions: https://github.com/npm/node-semver#prerelease-tags. If you want to update a version with pre-release tags, then you need to write the exact version you want to update (`1.2.3-beta` for example).*\n\nThe following table outlines the version value that AppSync expects your update\'s semver range to satisfy for each respective app type:\n\n| Platform               | Source of app store version                                                           |\n|------------------------|---------------------------------------------------------------------------------------|\n| NativeScript (iOS)     | The `CFBundleShortVersionString` key in the `App_Resources/iOS/Info.plist` file       |\n| NativeScript (Android) | The `android:versionName` key in the `App_Resources/Android/AndroidManifest.xml` file |\n\n*NOTE: If the app store version in the metadata files are missing a patch version, e.g. `2.0`, it will be treated as having a patch version of `0`, i.e. `2.0 -> 2.0.0`. The same is true for app store version equal to plain integer number, `1` will be treated as `1.0.0` in this case.*\n\n</details>\n\n## Gaining insight in past releases\nHere are a few AppSync CLI commands you may find useful:\n\n### Which releases did I create and what are the install metrics?\nUsing a command like this will tell you how many apps have the update installed:\n\n```shell\nnativescript-app-sync deployment history <appsync-appname> Staging\n```\n\nWhich produces something like this:\n\n|Label|Release Time|App Version|Mandatory|Description|Install Metrics\n|---|---|---|---|---|---\n|v2|an hour ago|1.0.0|Yes|Mandatory iOS version!|Active: 11% (2 of 19)\n||||||Total: 2|\n|v1|2 hours ago|1.0.0|No|Awesome iOS version!|Active: 26% (5 of 19)\n||||||Total: 5|\n\n### Give me the details of the current release!\nThis dumps the details of the most recent release for both the Staging and Production environments of your app:\n\n```shell\nnativescript-app-sync deployment ls <appsync-appname>\n```\n\nAnd if you want to dump your deployment keys as well, use:\n\n```shell\nnativescript-app-sync deployment ls <appsync-appname> --displayKeys\n```\n\nWhich produces something like this:\n\n|Name|Deployment Key|Update Metadata|Install Metrics\n|---|---|---|---\n|Production|r1DVaLfKjc0Y5d6BzqX4..|No updates released|No installs recorded\n|Staging|YTmVMy0GLCknVu3GVIyn..|Label: v5|Active: 11% (2 of 19)\n| | |App Version: 1.0.0|Total: 2\n| | |Mandatory: Yes|\n| | |Release Time: an hour ago|\n| | |Released By: eddyverbruggen@gmail.com|\n| | |Description: Mandatory iOS version!|\n\n### Clearing the release history\nThis won\'t roll back any releases, but it cleans up the history metadata (of the `Staging` app, in this case):\n\n```shell\nnativescript-app-sync deployment clear <appsync-appname> Staging\n```\n\n## Advanced topics\n\n### Testing AppSync packages during development\nYou may want to play with AppSync before using it in production (smart move!).\nPerform these steps once you\'ve pushed an update and added the `sync` command to your app:\n\n- `$ tns run <platform>`. On an iOS *device* add the `--release` flag so LiveSync doesn\'t interfere.\n- kill and restart the app after the update is installed\n\n### Running the demo app\nYou may also play with AppSync by using its demo app. Here are the steps you need to perform in order to observe an app update:\n- register with the service (`nativescript-app-sync register`) and add the demo app to your account (`nativescript-app-sync app add <appname> <platform> nativescript`)\n- once the app is registered you will see its deployment keys in the console, use them to update the ones in the [demo](https://github.com/EddyVerbruggen/nativescript-app-sync/blob/master/demo/demoapp/main-view-model.ts)\n- go to src and run `npm run preparedemo` - this will build the plugin and add a reference to the demo app\n- prepare an app that will be used as an "update version" (for example, uncomment one of the APPSYNC labels and comment the APPSTORE label), then run `tns build <platform>`\n- release the update (`nativescript-app-sync release <appname> <platform>`)\n- you can ensure it appears in the list with updates (`nativescript-app-sync deployment history <appname> Staging`)\n- prepare an app that will be used as an "official release version" (for example, comment the APPSYNC label and uncomment the APPSTORE label), then run `tns run <platform>`\n- when the app is deployed on the device, you should see the "official release version" along with information about an installed update\n- close the app (and remove it from device\'s recent apps to ensure its next start will be a cold start) and run it again - you should now see the "update version" of the app\n\n### Patching Update Metadata\nAfter releasing an update, there may be scenarios where you need to modify one or more of the metadata attributes associated with it\n(e.g. you forgot to mark a critical bug fix as mandatory.\n \n<details>\n  <summary>Read all about patching metadata by clicking here.</summary>\n\nYou can update metadata by running the following command:\n\n```shell\nnativescript-app-sync patch <appName> <deploymentName>\n[--label <releaseLabel>]\n[--mandatory <isMandatory>]\n[--description <description>]\n[--targetBinaryVersion <targetBinaryVersion>]\n```\n\n> \xe2\x9a\xa0\xef\xb8\x8f This command doesn\'t allow modifying the actual update contents of a release. If you need to respond to a release that has been identified as being broken, you should use the rollback command to immediately roll it back, and then if necessary, release a new update with the approrpriate fix when it is available.\n\nAside from the `appName` and `deploymentName`, all parameters are optional, and therefore, you can use this command to update just a single attribute or all of them at once. \nCalling the `patch` command without specifying any attribute flag will result in a no-op.\n\n```shell\n# Mark the latest production release as mandatory\nnativescript-app-sync patch MyAppiOS Production -m\n\n# Add a "mina and max binary version" to an existing release\nnativescript-app-sync patch MyAppiOS Staging -t "1.0.0 - 1.0.5"\n```\n\n</details>\n\n### Promoting Updates\n<details>\n  <summary>Read this if you want to easily promote releases from Staging to Production</summary>\n\nOnce you\'ve tested an update against a specific deployment (e.g. `Staging`),\nand you want to promote it (e.g. dev->staging, staging->production),\nyou can simply use the following command to copy the release from one deployment to another:\n\n```shell\nnativescript-app-sync promote <appName> <sourceDeploymentName> <destDeploymentName>\n[--description <description>]\n[--label <label>]\n[--mandatory]\n[--targetBinaryVersion <targetBinaryVersion]\n\n# example\nnativescript-app-sync promote AppSyncDemoIOS Staging Production --description \'Promoted from Staging to Production\'\n```\n\nThe `promote` command will create a new release for the destination deployment, which includes the **exact code and metadata** (description, mandatory and target binary version) from the latest release of the source deployment.\nWhile you could use the `release` command to "manually" migrate an update from one environment to another, the `promote` command has the following benefits:\n\n1. It\'s quicker, since you don\'t need to reassemble the release assets you want to publish or remember the description/app store version that are associated with the source deployment\'s release.\n\n2. It\'s less error-prone, since the promote operation ensures that the exact thing that you already tested in the source deployment (e.g. `Staging`) will become active in the destination deployment (e.g. `Production`).\n\n> \xf0\x9f\x92\x81\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f Unless you need to make changes to your code, the recommended workflow is taking advantage of the automatically created `Staging` and `Production` environments, and do all releases directly to `Staging`, and then perform a `promote` from `Staging` to `Production` after performing the appropriate testing.\n\n</details>\n\n### Rolling Back Updates\n\n<details>\n  <summary>Read this if you want to learn all about rollbacks</summary>\n\nA deployment\'s release history is immutable, so you cannot delete or remove individual updates once they have been released without deleting all of the deployment\'s release history.\nHowever, if you release an update that is broken or contains unintended features,\nit is easy to roll it back using the `rollback` command:\n\n```shell\nnativescript-app-sync rollback <appName> <deploymentName>\n\n#example\nnativescript-app-sync rollback MyAppiOS Production\n```\n\nThis has the effect of creating a new release for the deployment that includes the **exact same code and metadata** as the version prior to the latest one.\nFor example, imagine that you released the following updates to your app:\n\n| Release | Description       | Mandatory |\n|---------|-------------------|-----------|\n| v1      | Initial release!  | Yes       |\n| v2      | Added new feature | No        |\n| v3      | Bug fixes         | Yes       |\n\nIf you ran the `rollback` command on that deployment, a new release (`v4`) would be created that included the contents of the `v2` release.\n\n| Release                     | Description       | Mandatory |\n|-----------------------------|-------------------|-----------|\n| v1                          | Initial release!  | Yes       |\n| v2                          | Added new feature | No        |\n| v3                          | Bug fixes         | Yes       |\n| v4 (Rollback from v3 to v2) | Added new feature | No        |\n\nEnd-users that had already acquired `v3` would now be "moved back" to `v2` when the app performs an update check.\nAdditionally, any users that were still running `v2`, and therefore, had never acquired `v3`, wouldn\'t receive an update since they are already running the latest release\n(this is why our update check uses the package hash in addition to the release label).\n\nIf you would like to rollback a deployment to a release other than the previous (e.g. `v3` -> `v2`), you can specify the optional `--targetRelease` parameter:\n\n```shell\nnativescript-app-sync rollback MyAppiOS Production --targetRelease v34\n```\n\n> \xe2\x9a\xa0\xef\xb8\x8f This rolls back the release to the previous AppSync version, NOT the AppStore version (if there was one in between).\n\n> \xf0\x9f\x92\x81\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f The release produced by a rollback will be annotated in the output of the `deployment history` command to help identify them more easily.\n\n</details>\n\n### App Collaboration\n<details>\n  <summary>Working on one app with multiple developers? Click here!</summary>\n\nIf you will be working with other developers on the same AppSync app, you can add them as collaborators using the following command:\n\n```shell\nnativescript-app-sync collaborator add <appName> <collaboratorEmail>\n```\n\n*NOTE: This expects the developer to have already registered with AppSync using the specified e-mail address, so ensure that they have done that before attempting to share the app with them.*\n\nOnce added, all collaborators will immediately have the following permissions with regards to the newly shared app:\n\n1. View the app, its collaborators, deployments and release history.\n1. Release updates to any of the app\'s deployments.\n1. Rollback any of the app\'s deployments\n\nInversely, that means that an app collaborator cannot do any of the following:\n\n1. Rename or delete the app\n1. Create, rename or delete new deployments within the app\n1. Clear a deployment\'s release history\n1. Add or remove collaborators from the app (although a developer can remove themself as a collaborator from an app that was shared with them).\n\nOver time, if someone is no longer working on an app with you, you can remove them as a collaborator using the following command:\n\n```shell\nnativescript-app-sync collaborator rm <appName> <collaboratorEmail>\n```\n\nIf at any time you want to list all collaborators that have been added to an app, you can simply run the following command:\n\n```shell\nnativescript-app-sync collaborator ls <appName>\n```\n\n</details>\n\n## Using AppSync behind a proxy\n<details>\n  <summary>Click here to read all about Proxy Support</summary>\nBy default, the `login` command will automatically look for a system-wide proxy, specified via an `HTTPS_PROXY` or `HTTP_PROXY` environment variable, and use that to connect to the server.\nIf you\'d like to disable this behavior, and have the CLI establish a direct connection, simply specify the `--noProxy` parameter when logging in:\n\n```shell\nnativescript-app-sync login --noProxy\n```\n\nI\'d you like to explicitly specify a proxy server that the CLI should use, without relying on system-wide settings,\nyou can instead pass the `--proxy` parameter when logging in:\n\n```shell\nnativescript-app-sync login --proxy https://foo.com:3454\n```\n\nOnce you\'ve logged in, any inferred and/or specified proxy settings are persisted along with your user session.\nThis allows you to continue using the CLI without needing to re-authenticate or re-specify your preferred proxy.\nIf at any time you want to start or stop using a proxy, simply logout, and then log back in with the newly desired settings.\n\n</details>\n\n## Troubleshooting\n- Got build errors related to the __nativescript-zip__ plugin? Please check out [the solution in this issue](https://github.com/EddyVerbruggen/nativescript-app-sync/issues/34#issuecomment-526860302).\n'