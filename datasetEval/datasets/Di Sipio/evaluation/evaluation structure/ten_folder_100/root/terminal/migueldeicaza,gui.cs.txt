b'[![Build Status](https://travis-ci.org/migueldeicaza/gui.cs.svg?branch=master)](https://travis-ci.org/migueldeicaza/gui.cs)\n[![Version](https://img.shields.io/nuget/v/Terminal.Gui.svg)](https://www.nuget.org/packages/Terminal.Gui)\n[![Downloads](https://img.shields.io/nuget/dt/Terminal.Gui)](https://www.nuget.org/packages/Terminal.Gui)\n[![License](https://img.shields.io/github/license/migueldeicaza/gui.cs.svg)](LICENSE)\n\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/mono/mono?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) - This is the Mono Channel room\n\n# Gui.cs - Terminal UI toolkit for .NET\n\nThis is a simple UI toolkit for .NET, .NET Core and Mono and works on\nboth Windows and Linux/Unix.\n\n![Sample app](https://raw.githubusercontent.com/migueldeicaza/gui.cs/master/docfx/sample.png)\n\nA presentation of this was part of the [Retro.NET](https://channel9.msdn.com/Events/dotnetConf/2018/S313) talk at .NET Conf 2018 [Slides](https://tirania.org/Retro.pdf)\n\nThe toolkit contains various controls for building text user interfaces:\n\n* [Buttons](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.Button.html) \n* [Labels](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.Label.html)\n* [Text entry](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.TextField.html)\n* [Text view](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.TextView.html)\n* [Time editing field](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.TimeField.html)\n* [Radio buttons](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.RadioGroup.html)\n* [Checkboxes](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.CheckBox.html)\n* [Dialog boxes](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.Dialog.html)\n  * [Message boxes](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.MessageBox.html)\n* [Windows](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.Window.html)\n* [Menus](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.MenuBar.html)\n* [ListViews](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.ListView.html)\n* [Frames](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.FrameView.html)\n* [ProgressBars](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.ProgressBar.html)\n* [Scroll views](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.ScrollView.html) and [Scrollbars](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.ScrollBarView.html)\n* Hexadecimal viewer/editor (HexView)\n\nAll visible UI elements are subclasses of the\n[View](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.View.html),\nand these in turn can contain an arbitrary number of subviews.   \n\nIt comes with a\n[mainloop](https://migueldeicaza.github.io/gui.cs/api/Mono.Terminal/Mono.Terminal.MainLoop.html)\nto process events, process idle handlers, timers and monitoring file\ndescriptors.\n\nIt is designed to work on Curses and the [Windows Console](https://github.com/migueldeicaza/gui.cs/issues/27), \nworks well on both color and monochrome terminals and has mouse support on\nterminal emulators that support it.\n\n# Documentation\n\n* [API documentation](https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui.html) for details.\n\n* [Overview](https://migueldeicaza.github.io/gui.cs/articles/overview.html) contains the conceptual\n  documentation and a walkthrough of the core concepts of `gui.cs`\n\n# Sample Usage\n\n```csharp\nusing Terminal.Gui;\n\nclass Demo {\n    static void Main ()\n    {\n        Application.Init ();\n        var top = Application.Top;\n\n\t// Creates the top-level window to show\n        var win = new Window ("MyApp") {\n\t    X = 0,\n\t    Y = 1, // Leave one row for the toplevel menu\n\n\t    // By using Dim.Fill(), it will automatically resize without manual intervention\n\t    Width = Dim.Fill (),\n\t    Height = Dim.Fill ()\n\t};\n        top.Add (win);\n\n\t// Creates a menubar, the item "New" has a help menu.\n        var menu = new MenuBar (new MenuBarItem [] {\n            new MenuBarItem ("_File", new MenuItem [] {\n                new MenuItem ("_New", "Creates new file", NewFile),\n                new MenuItem ("_Close", "", () => Close ()),\n                new MenuItem ("_Quit", "", () => { if (Quit ()) top.Running = false; })\n            }),\n            new MenuBarItem ("_Edit", new MenuItem [] {\n                new MenuItem ("_Copy", "", null),\n                new MenuItem ("C_ut", "", null),\n                new MenuItem ("_Paste", "", null)\n            })\n        });\n        top.Add (menu);\n\n\tvar login = new Label ("Login: ") { X = 3, Y = 2 };\n\tvar password = new Label ("Password: ") {\n\t    \tX = Pos.Left (login),\n\t\tY = Pos.Top (login) + 1\n        };\n\tvar loginText = new TextField ("") {\n                X = Pos.Right (password),\n                Y = Pos.Top (login),\n                Width = 40\n        };\n        var passText = new TextField ("") {\n                Secret = true,\n                X = Pos.Left (loginText),\n                Y = Pos.Top (password),\n                Width = Dim.Width (loginText)\n        };\n\t\n\t// Add some controls, \n\twin.Add (\n\t    // The ones with my favorite layout system\n  \t    login, password, loginText, passText,\n\n\t    // The ones laid out like an australopithecus, with absolute positions:\n            new CheckBox (3, 6, "Remember me"),\n            new RadioGroup (3, 8, new [] { "_Personal", "_Company" }),\n            new Button (3, 14, "Ok"),\n            new Button (10, 14, "Cancel"),\n            new Label (3, 18, "Press F9 or ESC plus 9 to activate the menubar"));\n\n        Application.Run ();\n    }\n}\n```\n\nAlternatively, you can encapsulate the app behavior in a new `Window`-derived class, \nsay `App.cs` containing the code above, and simplify your `Main` method to:\n\n```csharp\nusing Terminal.Gui;\n\nclass Demo {\n    static void Main ()\n    {\n        Application.Run<App> ();\n    }\n}\n```\n\nThe example above shows how to add views, two styles are used, a very\nnice layout system that I have no name for, but that [is\ndocumented](https://migueldeicaza.github.io/gui.cs/articles/overview.html#layout),\nand the absolute positioning.\n\n# Installing it\n\nIf you want to try Gui.cs, use NuGet to install the `Terminal.Gui` NuGet package:\n\nhttps://www.nuget.org/packages/Terminal.Gui\n\n# Running and Building\n\nYou can find a trivial .NET core sample application in the\n"StandaloneExample" directory.   You can execute it by running\n`dotnet run` in that directory.\n\nThat sample relies on the distributed NuGet package, if you want to\nto use the code on GitHub, you can open the Example program which \nreferences the library built out of this tree.\n\n# Input Handling\n\nThe input handling of gui.cs is similar in some ways to Emacs and the\nMidnight Commander, so you can expect some of the special key\ncombinations to be active.\n\nThe key `ESC` can act as an Alt modifier (or Meta in Emacs parlance), to\nallow input on terminals that do not have an alt key.  So to produce\nthe sequence `Alt-F`, you can press either `Alt-F`, or `ESC` followed by the key `F`.\n\nTo enter the key `ESC`, you can either press `ESC` and wait 100\nmilliseconds, or you can press `ESC` twice.\n\n`ESC-0`, and `ESC-1` through `ESC-9` have a special meaning, they map to\n`F10`, and `F1` to `F9` respectively.\n\n# Driver model\n\nCurrently gui.cs has support for ncurses, `System.Console` and a full\nWin32 console front-end.\n\nncurses is used on Unix with color support based on what your library\nis compiled with;   The windows driver supports full color and mouse, and\nan easy-to-debug `System.Console` can be used on Windows and Unix, but\nlacks mouse support.\n\nYou can force the use of `System.Console` on Unix as\nwell, see `Core.cs`.   \n\n# Tasks\n\nThere are some tasks in the github issues, and some others are being\ntracked in the TODO.md file.\n\n# History\n\nThis is an updated version of\n[gui.cs](http://tirania.org/blog/archive/2007/Apr-16.html) that\nI wrote for [mono-curses](https://github.com/mono/mono-curses) in 2007.\n\nThe original gui.cs was a UI toolkit in a single file and tied to\ncurses.  This version tries to be console-agnostic and instead of\nhaving a container/widget model, only uses Views (which can contain\nsubviews) and changes the rendering model to rely on damage regions\ninstead of burderning each view with the details.\n\n# Releases\n\nRecently, I setup VSTS to do the releases, for now, this requires a\nbranch to be pushed with the name release/XXX, do this after the NuGet\npackage version has been updated on the\nTerminal.Gui/Terminal.Gui.csproj, and push.\n\nThen once the package is built, VSTS will request an approval.\n'