b'# tui-rs\n\n[![Build Status](https://github.com/fdehau/tui-rs/workflows/CI/badge.svg)](https://github.com/fdehau/tui-rs/actions?query=workflow%3ACI+)\n[![Crate Status](https://img.shields.io/crates/v/tui.svg)](https://crates.io/crates/tui)\n[![Docs Status](https://docs.rs/tui/badge.svg)](https://docs.rs/crate/tui/)\n\n<img src="./assets/demo.gif" alt="Demo cast under Linux Termite with Inconsolata font 12pt">\n\n`tui-rs` is a [Rust](https://www.rust-lang.org) library to build rich terminal\nuser interfaces and dashboards. It is heavily inspired by the `Javascript`\nlibrary [blessed-contrib](https://github.com/yaronn/blessed-contrib) and the\n`Go` library [termui](https://github.com/gizak/termui).\n\nThe library itself supports four different backends to draw to the terminal. You\ncan either choose from:\n\n  - [termion](https://github.com/ticki/termion)\n  - [rustbox](https://github.com/gchp/rustbox)\n  - [crossterm](https://github.com/TimonPost/crossterm)\n  - [pancurses](https://github.com/ihalila/pancurses)\n\nHowever, some features may only be available in one of the four.\n\nThe library is based on the principle of immediate rendering with intermediate\nbuffers. This means that at each new frame you should build all widgets that are\nsupposed to be part of the UI. While providing a great flexibility for rich and\ninteractive UI, this may introduce overhead for highly dynamic content. So, the\nimplementation try to minimize the number of ansi escapes sequences generated to\ndraw the updated UI. In practice, given the speed of `Rust` the overhead rather\ncomes from the terminal emulator than the library itself.\n\nMoreover, the library does not provide any input handling nor any event system and\nyou may rely on the previously cited libraries to achieve such features.\n\n### [Documentation](https://docs.rs/tui)\n\n### Demo\n\nThe demo shown in the gif can be run with all available backends\n(`exmples/*_demo.rs` files). For example to see the `termion` version one could\nrun:\n\n```\ncargo run --example termion_demo --release -- --tick-rate 200\n```\n\nThe UI code is in [examples/demo/ui.rs](examples/demo/ui.rs) while the\napplication state is in [examples/demo/app.rs](examples/demo/app.rs).\n\n### Widgets\n\nThe library comes with the following list of widgets:\n\n  * [Block](examples/block.rs)\n  * [Gauge](examples/gauge.rs)\n  * [Sparkline](examples/sparkline.rs)\n  * [Chart](examples/chart.rs)\n  * [BarChart](examples/barchart.rs)\n  * [List](examples/list.rs)\n  * [Table](examples/table.rs)\n  * [Paragraph](examples/paragraph.rs)\n  * [Canvas (with line, point cloud, map)](examples/canvas.rs)\n  * [Tabs](examples/tabs.rs)\n\nClick on each item to see the source of the example. Run the examples with with \ncargo (e.g. to run the demo `cargo run --example demo`), and quit by pressing `q`.\n\nYou can run all examples by running `make run-examples`.\n\n### Third-party widgets\n\n* [tui-logger](https://github.com/gin66/tui-logger)\n\n### Alternatives\n\nYou might want to checkout [Cursive](https://github.com/gyscos/Cursive) for an\nalternative solution to build text user interfaces in Rust.\n\n## License\n\n[MIT](LICENSE)\n'