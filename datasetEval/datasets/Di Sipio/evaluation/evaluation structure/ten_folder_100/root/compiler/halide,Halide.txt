b'# Halide\n\nHalide is a programming language designed to make it easier to write\nhigh-performance image and array processing code on modern machines. Halide\ncurrently targets:\n  * CPU architectures: X86, ARM, MIPS, Hexagon, PowerPC\n  * Operating systems: Linux, Windows, Mac OS X, Android, iOS, Qualcomm QuRT\n  * GPU Compute APIs: CUDA, OpenCL, OpenGL, OpenGL Compute Shaders, Apple Metal, Microsoft Direct X 12\n\nRather than being a standalone programming language, Halide is\nembedded in C++. This means you write C++ code that builds an\nin-memory representation of a Halide pipeline using Halide\'s C++\nAPI. You can then compile this representation to an object file, or\nJIT-compile it and run it in the same process. Halide also provides a Python binding that provides full support for writing Halide embedded in Python without C++.\n\nFor more detail about what Halide is, see http://halide-lang.org.\n\nFor API documentation see http://halide-lang.org/docs\n\nTo see some example code, look in the tutorials directory.\n\nIf you\'ve acquired a full source distribution and want to build\nHalide, see the notes below.\n\nBuild Status\n============\n\n| Linux                        |\n|------------------------------|\n| [![linux build status][1]][2]|\n\n[1]: https://travis-ci.org/halide/Halide.svg?branch=master\n[2]: https://travis-ci.org/halide/Halide\n\nBuilding Halide\n===============\n\n#### TL;DR\n\nHave llvm-8.0 (or greater) installed and run `make` in the root\ndirectory of the repository (where this README is).\n\n#### Acquiring LLVM\n\nBuilding Halide requires at least LLVM 8.0, along with the matching\nversion of Clang; we recommend using the most recent stable version of LLVM for\nmost users (LLVM 9.0 at the time of this writing). `llvm-config` and `clang`\nmust be somewhere in the path. If your OS does not have packages for llvm-8.0\n(or newer), you can find binaries for it at http://llvm.org/releases/download.html.\nDownload an appropriate package and then either install it, or at least put the\n`bin` subdirectory in your path. (This works well on OS X and Ubuntu.)\n\nIf you want to build it yourself, first check it out from GitHub:\n\n    % git clone https://github.com/llvm/llvm-project.git\n    % git checkout release/9.x  # to build LLVM 9.x\n\n(If you want to build LLVM 9.x, use `git checkout release/9.x`; for LLVM 8.0, use `release 8.x`; for current trunk, use `git checkout master`)\n\nThen build it like so:\n\n    % cd llvm-project\n    % mkdir build\n    % cd build\n    % cmake -DLLVM_ENABLE_PROJECTS="clang;lld" -DLLVM_ENABLE_RTTI=ON -DLLVM_ENABLE_TERMINFO=OFF -DLLVM_TARGETS_TO_BUILD="X86;ARM;NVPTX;AArch64;Mips;PowerPC" -DLLVM_ENABLE_ASSERTIONS=ON -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_32_BITS=OFF ../llvm\n    % make -j\n\nthen to point Halide to it:\n\n    export LLVM_CONFIG=<path to llvm>/build/bin/llvm-config\n\n(Note that you *must* add `clang` to `LLVM_ENABLE_PROJECTS`; adding `lld` to `LLVM_ENABLE_PROJECTS` is only required when using WebAssembly, but we recommend enabling it in all cases, to simplify builds.)\n\n#### Building Halide with make\n\nWith `LLVM_CONFIG` set (or `llvm-config` in your path), you should be\nable to just run `make` in the root directory of the Halide source tree.\n`make run_tests` will run the JIT test suite, and `make test_apps` will\nmake sure all the apps compile and run (but won\'t check their output).\n\nThere is no `make install` yet. If you want to make an install\npackage, run `make distrib`.\n\n#### Building Halide out-of-tree with make\n\nIf you wish to build Halide in a separate directory, you can do that\nlike so:\n\n    % cd ..\n    % mkdir halide_build\n    % cd halide_build\n    % make -f ../Halide/Makefile\n\n#### Building Halide with cmake\n\nIf you wish to use cmake to build Halide, the build procedure is:\n\n    % mkdir cmake_build\n    % cd cmake_build\n    % cmake -DLLVM_DIR=/path-to-llvm-build/lib/cmake/llvm -DCMAKE_BUILD_TYPE=Release /path/to/halide\n    % make -j\n\n`LLVM_DIR` should be the folder in the LLVM installation or build tree that contains `LLVMConfig.cmake`.\n\n#### Building Halide and LLVM on Windows\n\nAcquire MSVC 2015 Update 3 or newer. Earlier versions may work but are\nnot part of our tests. MSBuild and cmake should also be in your\npath. The instructions below assume Halide is checked out under\n`C:\\Code\\Halide`, and LLVM and Clang are checked out under\n`C:\\Code\\llvm`.\n\n    % mkdir C:\\Code\\llvm-build\n    % cd C:\\Code\\llvm-build\n    % cmake -DCMAKE_INSTALL_PREFIX=../llvm-install -DLLVM_ENABLE_TERMINFO=OFF -DLLVM_TARGETS_TO_BUILD=X86;ARM;NVPTX;AArch64;Mips;Hexagon -DLLVM_ENABLE_ASSERTIONS=ON -DLLVM_BUILD_32_BITS=OFF -DCMAKE_BUILD_TYPE=Release ../llvm/llvm -G "Visual Studio 14 Win64"\n\nFor a 32-bit build use:\n\n    % cmake -DCMAKE_INSTALL_PREFIX=../llvm-install -DLLVM_ENABLE_TERMINFO=OFF -DLLVM_TARGETS_TO_BUILD=X86;ARM;NVPTX;AArch64;Mips;Hexagon -DLLVM_ENABLE_ASSERTIONS=ON -DLLVM_BUILD_32_BITS=ON -DCMAKE_BUILD_TYPE=Release ../llvm/llvm -G "Visual Studio 14"\n\nThen build it like so:\n\n    % MSBuild.exe /m /t:Build /p:Configuration=Release .\\INSTALL.vcxproj\n\nYou can substitute `Debug` for `Release` in both commands if you want a debug build.\n\nTo configure and build Halide:\n\n    % mkdir C:\\Code\\halide-build\n    % cd C:\\Code\\halide-build\n    % cmake -DLLVM_DIR=../llvm-install/lib/cmake/llvm -DCMAKE_BUILD_TYPE=Release -G "Visual Studio 14 Win64" ../halide\n    % MSBuild.exe /m /t:Build /p:Configuration=Release .\\ALL_BUILD.vcxproj\n\n#### Building Halide and LLVM on Windows using mingw\n\nThe makefile method above should work from inside a "mingw64" shell\n(not the default shell) in an msys2 installation.\n\n#### If all else fails...\n\nDo what the build-bots do: https://buildbot.halide-lang.org/master/#/builders\n\nIf the column that best matches your system is red, then maybe things\naren\'t just broken for you. If it\'s green, then you can click the\n"stdio" links in the latest build to see what commands the build bots\nrun, and what the output was.\n\nSome useful environment variables\n=================================\n\n`HL_TARGET=...` will set Halide\'s AOT compilation target.\n\n`HL_JIT_TARGET=...` will set Halide\'s JIT compilation target.\n\n`HL_DEBUG_CODEGEN=1` will print out pseudocode for what Halide is\ncompiling. Higher numbers will print more detail.\n\n`HL_NUM_THREADS=...` specifies the number of threads to create for the\nthread pool. When the async scheduling directive is used, more threads\nthan this number may be required and thus allocated. A maximum of 256\nthreads is allowed. (By default, the number of cores on the host is\nused.)\n\n`HL_TRACE_FILE=...` specifies a binary target file to dump tracing data\ninto (ignored unless at least one `trace_` feature is enabled in `HL_TARGET` or\n`HL_JIT_TARGET`). The output can be parsed programmatically by starting from the\ncode in `utils/HalideTraceViz.cpp`.\n\n\nUsing Halide on OSX\n===================\n\nPrecompiled Halide distributions are built using XCode\'s command-line\ntools with Apple clang 500.2.76. This means that we link against\nlibc++ instead of libstdc++. You may need to adjust compiler options\naccordingly if you\'re using an older XCode which does not default to\nlibc++.\n\n\nHalide OpenGL/GLSL backend\n==========================\n\nHalide\'s OpenGL backend offloads image processing operations to the GPU by\ngenerating GLSL-based fragment shaders.\n\nCompared to other GPU-based processing options such as CUDA and OpenCL, OpenGL\nhas two main advantages: it is available on basically every desktop computer\nand mobile device, and it is generally well supported across different\nhardware vendors.\n\nThe main disadvantage of OpenGL as an image processing framework is that the\ncomputational capabilities of fragment shaders are quite restricted. In\ngeneral, the processing model provided by OpenGL is most suitable for filters\nwhere each output pixel can be expressed as a simple function of the input\npixels. This covers a wide range of interesting operations like point-wise\nfilters and convolutions; but a few common image processing operations such as\nhistograms or recursive filters are notoriously hard to express in GLSL.\n\n\n#### Writing OpenGL-Based Filters\n\nTo enable code generation for OpenGL, include `opengl` in the target specifier\npassed to Halide. Since OpenGL shaders are limited in their computational\npower, you must also specify a CPU target for those parts of the filter that\ncannot or should not be computed on the GPU. Examples of valid target\nspecifiers are\n\n    host-opengl\n    x86-opengl-debug\n\nAdding `debug`, as in the second example, adds additional logging output and\nis highly recommended during development.\n\nBy default, filters compiled for OpenGL targets run completely on the CPU.\nExecution on the GPU must be enabled for individual Funcs by appropriate\nscheduling calls.\n\nGLSL fragment shaders implicitly iterate over two spatial dimensions x,y and\nthe color channel. Due to the way color channels handled in GLSL, only filters\nfor which the color index is a compile-time constant can be scheduled.  The\nmain consequence is that the range of color variables must be explicitly\nspecified for both input and output buffers before scheduling:\n\n    ImageParam input;\n    Func f;\n    Var x, y, c;\n    f(x, y, c) = ...;\n\n    input.set_bounds(2, 0, 3);   // specify color range for input\n    f.bound(c, 0, 3);            // and output\n    f.glsl(x, y, c);\n\n\n#### JIT Compilation\n\nFor JIT compilation Halide attempts to load the system libraries for opengl\nand creates a new context to use for each module. Windows is not yet supported.\n\nExamples for JIT execution of OpenGL-based filters can be found in test/opengl.\n\n\n#### AOT Compilation\n\nWhen AOT (ahead-of-time) compilation is used, Halide generates OpenGL-enabled\nobject files that can be linked to and called from a host application. In\ngeneral, this is fairly straightforward, but a few things must be taken care\nof.\n\nOn Linux, OS X, and Android, Halide creates its own OpenGL context unless the\ncurrent thread already has an active context.  On other platforms you have to\nlink implementations of the following two functions with your Halide code:\n\n    extern "C" int halide_opengl_create_context(void *) {\n        return 0;  // if successful\n    }\n\n    extern "C" void *halide_opengl_get_proc_addr(void *, const char *name) {\n        ...\n    }\n\nHalide allocates and deletes textures as necessary.  Applications may manage\nthe textures by hand by setting the `buffer_t::dev` field; this is most useful\nfor reusing image data that is already stored in textures. Some rudimentary\nchecks are performed to ensure that externally allocated textures have the\ncorrect format, but in general that\'s the responsibility of the application.\n\nIt is possible to let render directly to the current framebuffer; to do this,\nset the `dev` field of the output buffer to the value returned by\n`halide_opengl_output_client_bound`.  The example in apps/HelloAndroidGL\ndemonstrates this technique.\n\nSome operating systems can delete the OpenGL context of suspended\napplications. If this happens, Halide needs to re-initialize itself with the\nnew context after the application resumes. Call `halide_opengl_context_lost`\nto reset Halide\'s OpenGL state after this has happened.\n\n\n#### Limitations\n\nThe current implementation of the OpenGL backend targets the common subset of\nOpenGL 2.0 and OpenGL ES 2.0 which is widely available on both mobile devices\nand traditional computers.  As a consequence, only a subset of the Halide\nlanguage can be scheduled to run using OpenGL. Some important limitations are:\n\n  * Reductions cannot be implemented in GLSL and must be run on the CPU.\n\n  * OpenGL ES 2.0 only supports uint8 buffers.\n\n    Support for floating point texture is available, but requires OpenGL (ES)\n    3.0 or the texture_float extension, which may not work on all mobile\n    devices.\n\n  * OpenGL ES 2.0 has very limited support for integer arithmetic. For maximum\n    compatibility, consider doing all computations using floating point, even\n    when using integer textures.\n\n  * Only 2D images with 3 or 4 color channels can be scheduled. Images with\n    one or two channels require OpenGL (ES) 3.0 or the texture_rg extension.\n\n  * Not all builtin functions provided by Halide are currently supported, for\n    example `fast_log`, `fast_exp`, `fast_pow`, `reinterpret`, bit operations,\n    `random_float`, `random_int` cannot be used in GLSL code.\n\nThe maximum texture size in OpenGL is `GL_MAX_TEXTURE_SIZE`, which is often\nsmaller than the image of interest; on mobile devices, for example,\n`GL_MAX_TEXTURE_SIZE` is commonly 2048. Tiling must be used to process larger\nimages.\n\nPlanned features:\n\n  * Support for half-float textures and arithmetic\n\n  * Support for integer textures and arithmetic\n\n(Note that OpenGL Compute Shaders are supported with a separate\nOpenGLCompute backend.)\n\nHalide for Hexagon HVX\n======================\nHalide supports offloading work to Qualcomm Hexagon DSP on Qualcomm Snapdragon 820\ndevices or newer. The Hexagon DSP provides a set of 64 and 128 byte vector\ninstructions - the Hexagon Vector eXtensions (HVX). HVX is well suited to image\nprocessing, and Halide for Hexagon HVX will generate the appropriate HVX vector\ninstructions from a program authored in Halide.\n\nHalide can be used to compile Hexagon object files directly, by using a target such\nas `hexagon-32-qurt-hvx_64` or `hexagon-32-qurt-hvx_128`.\n\nHalide can also be used to offload parts of a pipeline to Hexagon using the `hexagon`\nscheduling directive. To enable the `hexagon` scheduling directive, include the\n`hvx_64` or `hvx_128` target features in your target. The currently supported\ncombination of targets is to use the HVX target features with an x86 linux\nhost (to use the simulator) or with an ARM android target (to use Hexagon DSP hardware).\nFor examples of using the `hexagon` scheduling directive on both the simulator and a\nHexagon DSP, see the blur example app.\n\nTo build and run an example app using the Hexagon target,\n  1. Obtain and build trunk LLVM and Clang. (Earlier versions of LLVM may work but are not actively tested and thus not recommended.)\n  2. Download and install the Hexagon SDK and version 8.0 Hexagon Tools\n  3. Build and run an example for Hexagon HVX\n\n#### 1. Obtain and build trunk LLVM and Clang\n\n(Instructions given previous, just be sure to check out the `master` branch.)\n\n#### 2. Download and install the Hexagon SDK and version 8.0 Hexagon Tools\nGo to https://developer.qualcomm.com/software/hexagon-dsp-sdk/tools\n  1. Select the Hexagon Series 600 Software and download the 3.0 version for Linux.\n  2. untar the installer\n  3. Run the extracted installer to install the Hexagon SDK and Hexagon Tools, selecting\n  Installation of Hexagon SDK into `/location/of/SDK/Hexagon_SDK/3.0` and the Hexagon tools into `/location/of/SDK/Hexagon_Tools/8.0`\n  4. Set an environment variable to point to the SDK installation location\n\n    export SDK_LOC=/location/of/SDK\n\n#### 3. Build and run an example for Hexagon HVX\nIn addition to running Hexagon code on device, Halide also supports running Hexagon\ncode on the simulator from the Hexagon tools.\n\nTo build and run the blur example in Halide/apps/blur on the simulator:\n\n    cd apps/blur\n    export HL_HEXAGON_SIM_REMOTE=../../src/runtime/hexagon_remote/bin/v60/hexagon_sim_remote\n    export HL_HEXAGON_TOOLS=$SDK_LOC/Hexagon_Tools/8.0/Tools/\n    LD_LIBRARY_PATH=../../src/runtime/hexagon_remote/bin/host/:$HL_HEXAGON_TOOLS/lib/iss/:. HL_TARGET=host-hvx_128 make test\n\n#### To build and run the blur example in Halide/apps/blur on Android:\n\nTo build the example for Android, first ensure that you have a standalone toolchain\ncreated from the NDK using the make-standalone-toolchain.sh script:\n\n    export ANDROID_NDK_HOME=$SDK_LOC/Hexagon_SDK/3.0/tools/android-ndk-r10d/\n    export ANDROID_ARM64_TOOLCHAIN=<path to put new arm64 toolchain>\n    $ANDROID_NDK_HOME/build/tools/make-standalone-toolchain.sh --arch=arm64 --platform=android-21 --install-dir=$ANDROID_ARM64_TOOLCHAIN\n\nNow build and run the blur example using the script to run it on device:\n\n    export HL_HEXAGON_TOOLS=$SDK_LOC/HEXAGON_Tools/8.0/Tools/\n    HL_TARGET=arm-64-android-hvx_128 ./adb_run_on_device.sh\n'