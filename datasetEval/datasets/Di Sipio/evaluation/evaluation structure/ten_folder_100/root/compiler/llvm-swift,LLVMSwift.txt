b'# LLVMSwift\n[![Build Status](https://travis-ci.org/llvm-swift/LLVMSwift.svg?branch=master)](https://travis-ci.org/llvm-swift/LLVMSwift) [![Documentation](https://cdn.rawgit.com/llvm-swift/LLVMSwift/master/docs/badge.svg)](https://llvm-swift.github.io/LLVMSwift) [![Slack Invite](https://llvmswift-slack.herokuapp.com/badge.svg)](https://llvmswift-slack.herokuapp.com)\n\nLLVMSwift is a pure Swift interface to the [LLVM](http://llvm.org) API and its associated libraries. It provides native, easy-to-use components to make compiler development fun.\n\n## Introduction\n\n### LLVM IR\n\nThe root unit of organization of an LLVM IR program is a `Module`\n\n```swift\nlet module = Module(name: "main")\n```\n\nLLVM IR construction is handled by `IRBuilder` objects.  An `IRBuilder` is a cursor pointed inside a context, and as such has ways of extending that context and moving around inside of it.\n\nDefining a function and moving the cursor to a point where we can begin inserting instructions is done like so:\n\n```swift\nlet builder = IRBuilder(module: module)\n\nlet main = builder.addFunction("main",\n                               type: FunctionType([], IntType.int64))\nlet entry = main.appendBasicBlock(named: "entry")\nbuilder.positionAtEnd(of: entry)\n```\n\nInserting instructions creates native `IRValue` placeholder objects that allow us to structure LLVM IR programs just like Swift programs:\n\n```swift\nlet constant = IntType.int64.constant(21)\nlet sum = builder.buildAdd(constant, constant)\nbuilder.buildRet(sum)\n```\n\nThis simple program generates the following IR:\n\n```llvm\n// module.dump()\n\ndefine i64 @main() {\nentry:\n  ret i64 42\n}\n```\n\n### Types\n\nLLVM IR is a strong, statically typed language.  As such, values and functions\nare tagged with their types, and conversions between them must be explicit (see\n[Conversion Operators](http://llvm.org/docs/LangRef.html#conversion-operations)).\nLLVMSwift represents this with values conforming to the `IRType` protocol and defines\nthe following types:\n\n|**Type** | **Represents** |\n|:---:|:---:|\n| VoidType | Nothing; Has no size |\n| IntType | Integer and Boolean values (`i1`) |\n| FloatType | Floating-point values |\n| FunctionType | Function values |\n| LabelType | Code labels |\n| TokenType | Values paired with instructions |\n| MetadataType | Embedded metadata |\n| X86MMXType | X86 MMX values |\n| PointerType | Pointer values |\n| VectorType | SIMD data |\n| ArrayType | Homogeneous values |\n| Structure Type | Heterogeneous values |\n\n\n### Control Flow\n\nControl flow is changed through the unconditional and conditional `br` instruction.\n\nLLVM is also famous for a control-flow specific IR construct called a [PHI node](http://llvm.org/docs/LangRef.html#phi-instruction).  Because all instructions in LLVM IR are in SSA (Single Static Assignment) form, a PHI node is necessary when the value of a variable assignment depends on the path the flow of control takes through the program.  For example, let\'s try to build the following Swift program in IR:\n\n```swift\nfunc calculateFibs(_ backward : Bool) -> Double {\n  let retVal : Double\n  if !backward {\n    // the fibonacci series (sort of)\n    retVal = 1/89\n  } else {\n    // the fibonacci series (sort of) backwards\n    retVal = 1/109\n  }\n  return retVal\n}\n```\n\nNotice that the value of `retVal` depends on the path the flow of control takes through this program, so we must emit a PHI node to properly initialize it:\n\n```swift\nlet function = builder.addFunction("calculateFibs", \n                                   type: FunctionType([IntType.int1], \n                                                      FloatType.double))\nlet entryBB = function.appendBasicBlock(named: "entry")\nbuilder.positionAtEnd(of: entryBB)\n\n// allocate space for a local value\t\t\nlet local = builder.buildAlloca(type: FloatType.double, name: "local")\n\n// Compare to the condition\nlet test = builder.buildICmp(function.parameters[0], IntType.int1.zero(), .equal)\n\n// Create basic blocks for "then", "else", and "merge"\nlet thenBB = function.appendBasicBlock(named: "then")\nlet elseBB = function.appendBasicBlock(named: "else")\nlet mergeBB = function.appendBasicBlock(named: "merge")\n\nbuilder.buildCondBr(condition: test, then: thenBB, else: elseBB)\n\n// MARK: Then Block\nbuilder.positionAtEnd(of: thenBB)\n// local = 1/89, the fibonacci series (sort of)\nlet thenVal = FloatType.double.constant(1/89)\n// Branch to the merge block\nbuilder.buildBr(mergeBB)\n\n// MARK: Else Block\nbuilder.positionAtEnd(of: elseBB)\n// local = 1/109, the fibonacci series (sort of) backwards\nlet elseVal = FloatType.double.constant(1/109)\n// Branch to the merge block\nbuilder.buildBr(mergeBB)\n\n// MARK: Merge Block\nbuilder.positionAtEnd(of: mergeBB)\nlet phi = builder.buildPhi(FloatType.double, name: "phi_example")\nphi.addIncoming([\n  (thenVal, thenBB),\n  (elseVal, elseBB),\n])\nbuilder.buildStore(phi, to: local)\nlet ret = builder.buildLoad(local, type: FloatType.double, name: "ret")\nbuilder.buildRet(ret)\n```\n\nThis program generates the following IR:\n\n```llvm\ndefine double @calculateFibs(i1) {\nentry:\n  %local = alloca double\n  %1 = icmp ne i1 %0, false\n  br i1 %1, label %then, label %else\n\nthen:                                             ; preds = %entry\n  br label %merge\n\nelse:                                             ; preds = %entry\n  br label %merge\n\nmerge:                                            ; preds = %else, %then\n  %phi_example = phi double [ 0x3F8702E05C0B8170, %then ], [ 0x3F82C9FB4D812CA0, %else ]\n  store double %phi_example, double* %local\n  %ret = load double, double* %local\n  ret double %ret\n}\n```\n\n### JIT\n\nLLVMSwift provides a JIT abstraction to make executing code in LLVM modules quick and easy.  Let\'s execute the PHI node example from before:\n\n```swift\n// Setup the JIT\nlet jit = try JIT(machine: TargetMachine())\ntypealias FnPtr = @convention(c) (Bool) -> Double\n_ = try jit.addEagerlyCompiledIR(module) { (name) -> JIT.TargetAddress in\n  return JIT.TargetAddress()\n}\n// Retrieve a handle to the function we\'re going to invoke\nlet addr = try jit.address(of: "calculateFibs")\nlet fn = unsafeBitCast(addr, to: FnPtr.self)\n// Call the function!\nprint(fn(true)) // 0.00917431192660551...\nprint(fn(false)) // 0.0112359550561798...\n```\n\n## Installation\n\nThere are a couple annoying steps you need to accomplish before building\nLLVMSwift:\n\n- Install LLVM 8.0+ using your favorite package manager. For example:\n  - `brew install llvm`\n- Ensure `llvm-config` is in your `PATH`\n  - That will reside in the `/bin` folder wherever your package manager\n    installed LLVM.\n- Create a pkg-config file for your specific LLVM installation.\n  - We have a utility for this: `swift utils/make-pkgconfig.swift`\n\nOnce you do that, you can add LLVMSwift as a dependency for your own Swift\ncompiler projects!\n\n### Installation with Swift Package Manager\n\n```swift\n.package(url: "https://github.com/llvm-swift/LLVMSwift.git", from: "0.4.0")\n```\n\n### Installation without Swift Package Manager\n\nWe really recommend using SwiftPM with LLVMSwift, but if your project is\nstructured in such a way that makes using SwiftPM impractical or impossible,\nuse the following instructions: \n\n- Xcode:\n  - Add this repository as a git submodule\n  - Add the files in `Sources/` to your Xcode project.\n  - Under `Library Search Paths` add the output of `llvm-config --libdir`\n  - Under `Header Search Paths` add the output of `llvm-config --includedir`\n  - Under `Link Target with Libraries` drag in\n    `/path/to/your/llvm/lib/libLLVM.dylib`\n\nThis project is used by [Trill](https://github.com/harlanhaskins/trill) for\nall its code generation.\n\n## Authors\n\n- Harlan Haskins ([@harlanhaskins](https://github.com/harlanhaskins))\n- Robert Widmann ([@CodaFi](https://github.com/CodaFi))\n\n## License\n\nThis project is released under the MIT license, a copy of which is available\nin this repo.\n\n'