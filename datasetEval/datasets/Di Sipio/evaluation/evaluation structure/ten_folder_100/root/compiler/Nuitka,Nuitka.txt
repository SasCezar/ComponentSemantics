b'Nuitka User Manual\n~~~~~~~~~~~~~~~~~~\n\n.. image:: doc/images/Nuitka-Logo-Symbol.png\n\n.. contents::\n\n.. raw:: pdf\n\n   PageBreak oneColumn\n   SetPageCounter 1\n\nOverview\n========\n\nThis document is the recommended first read if you are interested in using\nNuitka, understand its use cases, check what you can expect, license,\nrequirements, credits, etc.\n\nNuitka is **the** Python compiler. It is written in Python. It is a seamless\nreplacement or extension to the Python interpreter and compiles **every**\nconstruct that CPython 2.6, 2.7, 3.3, 3.4, 3.5, 3.6, and 3.7 have, when itself\nrun with that Python version.\n\nIt then executes uncompiled code and compiled code together in an extremely\ncompatible manner.\n\nYou can use all Python library modules and all extension modules freely.\n\nIt translates the Python into a C level program that then uses ``libpython``\nand a few C files of its own to execute in the same way as CPython does. All\noptimization is aimed at avoiding overhead, where it\'s unnecessary. None is\naimed at removing compatibility, although slight improvements will occasionally\nbe done, where not every bug of standard Python is emulated, e.g. more complete\nerror messages are given, but there is a full compatibility mode to disable\neven that.\n\nUsage\n=====\n\nRequirements\n------------\n\n- C Compiler: You need a compiler with support for C11 or alternatively\n  for C++03 [#]_\n\n  Currently this means, you need to use one of these compilers:\n\n  * The ``gcc`` compiler of at least version 5.1, or the ``g++`` compiler of\n    at least version 4.4 as an alternative.\n\n  * The ``clang`` compiler on macOS X or FreeBSD.\n\n  * The MinGW64 [#]_ C11 compiler on Windows, ideally the one based on gcc\n    6 or higher. The Anaconda compilers [#]_ are suitable too, even if you\n    use CPython, they are the easiest installation method.\n\n  * Visual Studio 2017 or higher on Windows [#]_, older versions may work\n    but are not officially supported. Configure to use the English language\n    pack for best results (Nuitka filters away garbage outputs, but only\n    for that language).\n\n  * On Windows the ``clang-cl`` compiler on Windows can be used if provided if\n    you use the ``CC`` environment variable to point to it, *and* you also have\n    MSVC installed.\n\n\n- Python: Version 2.6, 2.7 or 3.3, 3.4, 3.5, 3.6, 3.7\n\n  .. admonition:: Python3, but for 3.3, and 3.4 and *only* those versions,\n     we need other Python versions as a *compile time* dependency\n\n     Nuitka itself is fully compatible with all mentioned versions, Scons as\n     as an internally used tool is not.\n\n     For these versions, you *need* a Python2 or Python 3.5 or higher installed\n     as well, but only during the compile time only. That is for use with Scons\n     (which orchestrates the C compilation), which does not support the same\n     Python versions as Nuitka.\n\n  .. admonition:: Moving binaries to other machines\n\n     The created binaries can be made executable independent of the Python\n     installation, with ``--standalone`` option.\n\n  .. admonition:: Binary filename suffix\n\n     The created binaries have an ``.exe`` suffix on Windows. On other platforms\n     they have no suffix for standalone mode, or ``.bin`` suffix, that you are\n     free to remove or change, or specify with the ``-o`` option.\n\n     The suffix for acceleration mode is added just to be sure that the original\n     script name and the binary name do not ever collide, so we can safely do\n     an overwrite without destroying the original source file.\n\n  .. admonition:: It **has to** be CPython, Anaconda or Miniconda Python.\n\n     You need the standard Python implementation, called "CPython", to execute\n     Nuitka, because it is closely tied to implementation details of it.\n\n     On Windows, for Python not installed system-wide and acceleration mode, you\n     need to copy the ``PythonXX.DLL`` alongside it, something Nuitka does\n     automatically.\n\n  .. admonition:: It **has to** be CPython, AnaConda or MiniConda Python.\n\n     It is known that macOS "pyenv" does **not** work.\n\n- Operating System: Linux, FreeBSD, NetBSD, macOS X, and Windows (32/64 bits).\n\n  Others may work as well. The portability is expected to be generally good,\n  but the e.g. Scons usage may have to be adapted. Make sure to match Windows\n  Python and C compiler architecture, or else you will get cryptic error\n  messages.\n\n- Architectures: x86, x86_64 (amd64), and arm, likely many more\n\n  Other architectures are expected to also work, out of the box, as Nuitka is\n  generally not using any hardware specifics. These are just the ones tested\n  and known to be good. Feedback is welcome. Generally, the architectures that\n  Debian supports can be considered good and tested too.\n\n.. [#] Support for this C11 is a given with gcc 5 or higher or any clang\n       version. The MSVC compiler doesn\'t do it yet. But as a workaround,\n       as the C++03 language standard is very overlapping with C11, it is then\n       used instead where the C compiler is too old. Nuitka used to require a\n       C++ compiler in the past, but it changed.\n\n.. [#] Download MinGW64 from here http://mingw-w64.org/ and choose 64 or 32\n       bits matching your Python.\n\n       Use both MinGW64 and 64 bits Python if you have the choice of which\n       Python to use. Install it to ``C:\\MinGW64`` or ``\\MinGW64`` (same disk\n       root as Nuitka running) to find it automatically. Also, when prompted,\n       use ``posix`` for threads and ```dwarf`` for exception model, although\n       these currently do not matter at all.\n\n.. [#] Installation of matching MinGW64 is easiest if you have an Anaconda or\n       Miniconda installation.\n\n       Execute ``<path_to_Anaconda>\\Scripts\\conda install m2w64-gcc libpython``\n       and then before you run Nuitka do ``setenv\n       CC=<path_to_Anaconda>\\Library\\mingw-w64\\bin\\gcc.exe`` and then its use\n       will be forced. Nuitka also uses it automatically, if you run it like\n       this ``<path_to_Anaconda>\\python -m nuitka ...``.\n\n.. [#] Download for free from\n       http://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx\n       (the Express editions work just fine).\n\n       The latest version is recommended if not required. There is no need to\n       use older versions, they might in fact not work.\n\n\nCommand Line\n------------\n\nThe recommended way of executing Nuitka is ``<the_right_python> -m nuitka`` to\nbe absolutely certain which Python interpreter you are using, so it is easier\nto match with what Nuitka has.\n\nThe next best way of executing Nuitka bare that is from a source checkout or\narchive, with no environment variable changes, most noteworthy, you do not\nhave to mess with ``PYTHONPATH`` at all for Nuitka. You just execute the\n``nuitka`` and ``nuitka-run`` scripts directly without any changes to the\nenvironment. You may want to add the ``bin`` directory to your ``PATH`` for\nyour convenience, but that step is optional.\n\nMoreover, if you want to execute with the right interpreter, in that case, be\nsure to execute ``<the_right_python> bin/nuitka`` and be good.\n\n  .. admonition:: Pick the right Interpreter\n\n     If you encounter a ``SyntaxError`` you absolutely most certainly have\n     picked the wrong interpreter for the program you are compiling.\n\nNuitka has a ``--help`` option to output what it can do:\n\n.. code-block:: bash\n\n    nuitka --help\n\nThe ``nuitka-run`` command is the same as ``nuitka``, but with a different\ndefault. It tries to compile *and* directly execute a Python script:\n\n.. code-block:: bash\n\n    nuitka-run --help\n\nThis option that is different is ``--run``, and passing on arguments after the\nfirst non-option to the created binary, so it is somewhat more similar to what\nplain ``python`` will do.\n\nInstallation\n------------\n\nFor most systems, there will be packages on the `download page\n<http://www.nuitka.net/pages/download.html>`__ of Nuitka. But you can also\ninstall it from source code as described above, but also like any other Python\nprogram it can be installed via the normal ``python setup.py install`` routine.\n\nLicense\n-------\n\nNuitka is licensed under the Apache License, Version 2.0; you may not use\nit except in compliance with the License.\n\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed\nunder the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR\nCONDITIONS OF ANY KIND, either express or implied.  See the License for the\nspecific language governing permissions and limitations under the License.\n\n\nTutorial Setup and build on Windows\n===================================\n\nThis is basic steps if you have nothing installed, of course\nif you have any of the parts, just skip it.\n\nSetup\n-----\n\nInstall the C compiler\n++++++++++++++++++++++\n\n - Download and install mingw64 from\n   `https://sourceforge.net/projects/mingw-w64/ <https://sourceforge.net/projects/mingw-w64/>`_\n\n- in Architecture: choose "i686" if you want use 32bit or "x86_64" if you want\n  64 bit version Python\n\n - Select destination folder to **c:\\\\MinGW64**\n\n - verify using command  **gcc.exe --version**\n\n - Set a environment variable pointing to **gcc.exe**\n\n   **CC=C:\\\\MinGW64\\\\mingw64\\\\bin\\\\gcc.exe** if 64 bit version\n\n   **CC=C:\\\\MinGW64\\\\mingw32\\\\bin\\\\gcc.exe** if 32 bit version\n\nInstall Python 3.7 (64 Bits)\n++++++++++++++++++++++++++++\n\n - Download and install from\n   `https://www.python.org/downloads/windows <https://www.python.org/downloads/windows>`_\n\n - Select Windows x86-64 web-based installer **or**\n\n - Select Windows x86-64 executable installer\n\n - Verify using command **python --version**\n\nInstall Nuitka\n++++++++++++++\n\n - **pip install nuitka**\n - if you use anaconda:\n - **conda install -c conda-forge nuitka**\n - verify using command **nuitka --version**\n\nWrite some code and test\n------------------------\n\nCreate a folder for the Python code\n+++++++++++++++++++++++++++++++++++\n\n - mkdir HelloWorld\n - make a python file named **hello.py**\n\n .. code-block:: python\n\n      def talk(message):\n          return "Talk " + message\n\n      def main():\n          print( talk("Hello World"))\n\n      if __name__ == "__main__":\n          main()\n\nTest it using **python hello.py**\n+++++++++++++++++++++++++++++++++\n\nBuild it using\n++++++++++++++\n\n  **python -m nuitka --standalone --mingw64 hello.py**\n\nIf you like to have full output add **--show-progress** **--show-scons**\n\nRun it\n++++++\n\nExecute the **hello.exe** in the folder **hello.dist**\n\nDistribute\n++++++++++\n\nTo distribute copy the **hello.dist** folder\n\n\nUse Cases\n=========\n\nUse Case 1 - Program compilation with all modules embedded\n----------------------------------------------------------\n\nIf you want to compile a whole program recursively, and not only the single\nfile that is the main program, do it like this:\n\n.. code-block:: bash\n\n    python -m nuitka --follow-imports program.py\n\n.. note::\n\n   There are more fine grained controls than ``--follow-imports`` available.\n   Consider the output of ``nuitka --help``.\n\nIn case you have a plugin directory, i.e. one which cannot be found by\nrecursing after normal import statements via the ``PYTHONPATH`` (which would be\nthe recommended way), you can always require that a given directory shall also\nbe included in the executable:\n\n.. code-block:: bash\n\n    python -m nuitka --follow-imports --include-plugin-directory=plugin_dir program.py\n\n.. note::\n\n   If you don\'t do any dynamic imports, simply setting your ``PYTHONPATH`` at\n   compilation time will be sufficient for all your needs normally.\n\n   Use ``--include-plugin-directory`` only if you make ``__import__()`` calls\n   that Nuitka cannot predict, because they e.g. depend on command line\n   parameters. Nuitka also warns about these, and point to the option.\n\n.. note::\n\n   The resulting filename will be ``program.exe`` on Windows, ``program.bin``\n   on other platforms.\n\n.. note::\n\n   The resulting binary still depends on CPython and used C extension modules\n   being installed.\n\n   If you want to be able to copy it to another machine, use ``--standalone``\n   and copy the created ``program.dist`` directory and execute the\n   ``program.exe`` (Windows) or ``program`` (other platforms) put inside.\n\n\nUse Case 2 - Extension Module compilation\n-----------------------------------------\n\nIf you want to compile a single extension module, all you have to do is this:\n\n.. code-block:: bash\n\n    python -m nuitka --module some_module.py\n\nThe resulting file ``some_module.so`` can then be used instead of\n``some_module.py``.\n\n.. note::\n\n   It\'s left as an exercise to the reader, to find out what happens if both are present.\n\n.. note::\n\n   The option ``--follow-imports`` and other variants work as well, but the\n   included modules will only become importable *after* you imported the\n   ``some_module`` name.\n\nUse Case 3 - Package compilation\n--------------------------------\n\nIf you need to compile a whole package and embed all modules, that is also\nfeasible, use Nuitka like this:\n\n.. code-block:: bash\n\n    python -m nuitka --module some_package --include-package=some_package\n\n.. note::\n\n   The recursion into the package directory needs to be provided manually,\n   otherwise, the package is empty. Data files located inside the package will\n   not be embedded yet.\n\nTypical Problems\n================\n\nDynamic ``sys.path``\n--------------------\n\nIf your script modifies ``sys.path`` to e.g. insert directories with source\ncode relative to it, Nuitka will currently not be able to see those. However,\nif you set the ``PYTHONPATH`` to the resulting value, you will be able to\ncompile it\n\nTips\n====\n\nPython command line flags\n-------------------------\n\nFor passing things like ``-O`` or `-S`` to your program, there is a command\nline option name `--python-flag=` which makes Nuitka emulate these options.\n\nThe most important ones are supported, more can certainly be added.\n\nCaching\n-------\n\nThe C compiler, when invoked with the same input files, will take a long time\nand much CPU to compile. Make sure you are having ``ccache`` installed and\nconfigured on non-Windows. It will make repeated compilations much faster,\neven if things are not yet not perfect, i.e. changes to the program can\ncause many C files to change, requiring a new compilation instead of using\nthe cached result.\n\nOn Windows, Nuitka supports using ``ccache.exe`` which is not easy to come\nby though for the non-MSVC compilers, and ``clcache.exe`` which is just one\n``pip install clcache`` command away. To make Nuitka use those, set either\n``NUITKA_CCACHE_BINARY`` to the full path of ``ccache.exe`` or\n``NUITKA_CLCACHE_BINARY`` to the full path of ``clcache.exe``, which will be\nin the scripts folder of the Python, you installed it into.\n\nRunners\n-------\n\nAvoid running the ``nuitka`` binary, doing ``python -m nuitka`` will make a\n100% sure you are using what you think you are.\n\nFastest C Compilers\n-------------------\n\nThe fastest binaries of ``pystone.exe`` on Windows with 64 bits Python proved\nto be significantly faster with MinGW64, roughly 20% better score. So it is\nrecommended for use over MSVC. Using ``clang-cl.exe`` of Clang7 was faster\nthan MSVC, but still significantly slower than MinGW64, and it will be harder\nto use, so it is not recommended.\n\nOn Linux for ``pystone.bin`` the binary produced by ``clang6`` was faster\nthan ``gcc-6.3``, but not by a significant margin. Since gcc is more often\nalready installed, that is recommended to use for now.\n\nDifferences in C compilation times have not yet been examined.\n\nUnexpected Slowdowns\n--------------------\n\nUsing the Python DLL, like standard CPython does can lead to unexpected\nslowdowns, e.g. in uncompiled code that works with Unicode strings. This is\nbecause calling to the DLL rather than residing in the DLL causes overhead,\nand this even happens to the DLL with itself, being slower, than a Python\nall contained in one binary.\n\nSo if feasible, aim at static linking, which is currently only possible with\nAnaconda Python on non-Windows.\n\nWindows Standalone executables and dependencies\n-----------------------------------------------\n\nThe process of making standalone executables for Windows traditionally involves\nusing an external dependency walker in order to copy necessary libraries along\nwith the compiled executables to the distribution folder.\n\nUsing the external dependency walker is quite a time consuming, and may copy\nsome unnecessary libraries along the way (better have too much than missing).\n\nSince Nuitka 0.6.2, there\'s an experimental alternative internal dependency\nwalker that relies on pefile which analyses PE imports of\nexecutables/libraries.\n\nThis implementation shall create smaller Standalone distributions since it\nwon\'t include Windows\' equivalent of the standard library, and will speed-up\nfirst Nuitka compilations by an order of magnitude.\n\nIn order to use it, you may enable the internal dependency walker by using the\nfollowing switch:\n\n.. code-block:: bash\n\n    python -m nuitka --standalone --experimental=use_pefile myprogram.py\n\n\n.. note::\n\n    The pefile dependency walker will test all dependencies of the distribution folder.\n\n    Optionally, it is also possible to check all recursive dependencies of included libraries\n    using the following switch along with the above one:\n\n.. code-block:: bash\n\n    python -m nuitka --standalone --experimental=use_pefile --experimental=use_pefile_recurse myprogram.py\n\n\n.. note::\n\n    Some modules may have hidden dependencies outside of their directory. In order for\n    the pefile dependency walker to find them, you may also scan the whole site-packages\n    directory for missing dependencies using the following switch along with the two above:\n\n.. code-block:: bash\n\n    python -m nuitka --standalone --experimental=use_pefile --experimental=use_pefile_recurse --experimental=use_pefile_fullrecurse myprogram.py\n\n.. note::\n\n    Be aware that using this switch will increase compilation time a lot.\n\n\nWhere to go next\n================\n\nRemember, this project is not completed yet. Although the CPython test suite\nworks near perfect, there is still more work needed, esp. to make it do more\noptimization. Try it out.\n\nSubscribe to its mailing lists\n------------------------------\n\nPlease visit the `mailing list page\n<http://www.nuitka.net/pages/mailinglist.html>`__ in order to subscribe the\nrelatively low volume mailing list. All Nuitka issues can be discussed there.\nAlso, this is the place to stay informed of what\'s coming.\n\nFollow me on Twitter\n--------------------\n\nNuitka announcements and interesting stuff is pointed to on the Twitter account,\nbut obviously with no details. `@KayHayen <https://twitter.com/KayHayen>`_.\n\nI will not answer Nuitka issues via Twitter though, rather make occasional\npolls, and give important announcements, as well as low-level posts about\ndevelopment ongoing.\n\nReport issues or bugs\n---------------------\n\nShould you encounter any issues, bugs, or ideas, please visit the `Nuitka bug\ntracker <https://github.com/kayhayen/Nuitka/issues>`__ and report them.\n\nBest practices for reporting bugs:\n\n- Please always include the following information in your report, for the\n  underlying Python version. You can easily copy&paste this into your\n  report.\n\n  .. code-block:: sh\n\n      python -m nuitka --version\n\n- Try to make your example minimal. That is, try to remove code that does\n  not contribute to the issue as much as possible. Ideally come up with\n  a small reproducing program that illustrates the issue, using ``print``\n  with different results when that programs runs compiled or native.\n\n- If the problem occurs spuriously (i.e. not each time), try to set the\n  environment variable ``PYTHONHASHSEED`` to ``0``, disabling hash\n  randomization. If that makes the problem go away, try increasing in\n  steps of 1 to a hash seed value that makes it happen every time, include\n  it in your report.\n\n- Do not include the created code in your report. Given proper input,\n  it\'s redundant, and it\'s not likely that I will look at it without\n  the ability to change the Python or Nuitka source and re-run it.\n\n- Do not send screenshots of text, that is bad and lazy. Instead, capture\n  text outputs from the console.\n\nWord of Warning\n---------------\n\nConsider using this software with caution. Even though many tests are applied\nbefore releases, things are potentially breaking. Your feedback and patches to\nNuitka are very welcome.\n\n\nJoin Nuitka\n===========\n\nYou are more than welcome to join Nuitka development and help to complete the\nproject in all minor and major ways.\n\nThe development of Nuitka occurs in git. We currently have these 3 branches:\n\n- `master\n  <http://nuitka.net/gitweb/?p=Nuitka.git;a=shortlog;h=refs/heads/master>`__:\n\n  This branch contains the stable release to which only hotfixes for bugs will\n  be done. It is supposed to work at all times and is supported.\n\n- `develop\n  <http://nuitka.net/gitweb/?p=Nuitka.git;a=shortlog;h=refs/heads/develop>`__:\n\n  This branch contains the ongoing development. It may at times contain little\n  regressions, but also new features. On this branch, the integration work is\n  done, whereas new features might be developed on feature branches.\n\n- `factory\n  <http://nuitka.net/gitweb/?p=Nuitka.git;a=shortlog;h=refs/heads/factory>`__:\n\n  This branch contains unfinished and incomplete work. It is very frequently\n  subject to ``git rebase`` and the public staging ground, where my work\n  for develop branch lives first. It is intended for testing only and\n  recommended to base any of your own development on. When updating it,\n  you very often will get merge conflicts. Simply resolve those by doing\n  ``git reset --hard origin/factory`` and switch to the latest version.\n\n.. note::\n\n   I accept requests on the social code platforms, also patch files, if they\n   are good.\n\n.. note::\n\n   The `Developer Manual <http://nuitka.net/doc/developer-manual.html>`__\n   explains the coding rules, branching model used, with feature branches and\n   hotfix releases, the Nuitka design and much more. Consider reading it to\n   become a contributor. This document is intended for Nuitka users.\n\nDonations\n=========\n\nShould you feel that you cannot help Nuitka directly, but still want to\nsupport, please consider `making a donation\n<http://nuitka.net/pages/donations.html>`__ and help this way.\n\nUnsupported functionality\n=========================\n\nThe ``co_code`` attribute of code objects\n-----------------------------------------\n\nThe code objects are empty for native compiled functions. There is no\nbytecode with Nuitka\'s compiled function objects, so there is no way to provide\nit.\n\nPDB\n---\n\nThere is no tracing of compiled functions to attach a debugger to.\n\nOptimization\n============\n\nConstant Folding\n----------------\n\nThe most important form of optimization is the constant folding. This is when\nan operation can be fully predicted at compile time. Currently, Nuitka does\nthese for some built-ins (but not all yet, somebody to look at this more\nclosely will be very welcome!), and it does it e.g. for binary/unary operations\nand comparisons.\n\nConstants currently recognized:\n\n.. code-block:: python\n\n    5 + 6     # binary operations\n    not 7     # unary operations\n    5 < 6     # comparisons\n    range(3)  # built-ins\n\nLiterals are the one obvious source of constants, but also most likely other\noptimization steps like constant propagation or function inlining will be. So\nthis one should not be underestimated and a very important step of successful\noptimizations. Every option to produce a constant may impact the generated code\nquality a lot.\n\n.. admonition:: Status\n\n   The folding of constants is considered implemented, but it might be incomplete\n   in that not all possible cases are caught. Please report it as a\n   bug when you find an operation in Nuitka that has only constants as input and\n   is not folded.\n\nConstant Propagation\n--------------------\n\nAt the core of optimizations, there is an attempt to determine the values of\nvariables at run time and predictions of assignments. It determines if their\ninputs are constants or of similar values. An expression, e.g. a module\nvariable access, an expensive operation, may be constant across the module of\nthe function scope and then there needs to be none or no repeated module\nvariable look-up.\n\nConsider e.g. the module attribute ``__name__`` which likely is only ever read,\nso its value could be predicted to a constant string known at compile time.\nThis can then be used as input to the constant folding.\n\n.. code-block:: python\n\n   if __name__ == "__main__":\n      # Your test code might be here\n      use_something_not_use_by_program()\n\n.. admonition:: Status\n\n   From modules attributes, only ``__name__`` is currently actually optimized.\n   Also possible would be at least ``__doc__``. In the future, this may improve\n   as SSA is expanded to module variables.\n\nBuilt-in Name Lookups\n---------------------\n\nAlso, built-in exception name references are optimized if they are used as a\nmodule level read-only variables:\n\n.. code-block:: python\n\n   try:\n      something()\n   except ValueError: # The ValueError is a slow global name lookup normally.\n      pass\n\n.. admonition:: Status\n\n   This works for all built-in names. When an assignment is done to such a\n   name, or it\'s even local, then, of course, it is not done.\n\nBuilt-in Call Prediction\n------------------------\n\nFor built-in calls like ``type``, ``len``, or ``range`` it is often possible to\npredict the result at compile time, esp. for constant inputs the resulting\nvalue often can be precomputed by Nuitka. It can simply determine the result or\nthe raised exception and replace the built-in call with that value, allowing\nfor more constant folding or code path reduction.\n\n.. code-block:: python\n\n   type("string") # predictable result, builtin type str.\n   len([1, 2])    # predictable result\n   range(3, 9, 2) # predictable result\n   range(3, 9, 0) # predictable exception, range raises due to 0.\n\n.. admonition:: Status\n\n   The built-in call prediction is considered implemented. We can simply during\n   compile time emulate the call and use its result or raised exception. But we\n   may not cover all the built-ins there are yet.\n\nSometimes the result of a built-in should not be predicted when the result is\nbig. A ``range()`` call e.g. may give too big values to include the result in\nthe binary. Then it is not done.\n\n.. code-block:: python\n\n   range( 100000 ) # We do not want this one to be expanded\n\n.. admonition:: Status\n\n   This is considered mostly implemented. Please file bugs for built-ins that\n   are pre-computed, but should not be computed by Nuitka at compile time with\n   specific values.\n\nConditional Statement Prediction\n--------------------------------\n\nFor conditional statements, some branches may not ever be taken, because of the\nconditions being possible to predict. In these cases, the branch not taken and\nthe condition check is removed.\n\nThis can typically predict code like this:\n\n.. code-block:: python\n\n   if __name__ == "__main__":\n      # Your test code might be here\n      use_something_not_use_by_program()\n\nor\n\n.. code-block:: python\n\n   if False:\n      # Your deactivated code might be here\n\n\nIt will also benefit from constant propagations, or enable them because once\nsome branches have been removed, other things may become more predictable, so\nthis can trigger other optimization to become possible.\n\nEvery branch removed makes optimization more likely. With some code branches\nremoved, access patterns may be more friendly. Imagine e.g. that a function is\nonly called in a removed branch. It may be possible to remove it entirely, and\nthat may have other consequences too.\n\n.. admonition:: Status\n\n   This is considered implemented, but for the maximum benefit, more constants\n   need to be determined at compile time.\n\nException Propagation\n---------------------\n\nFor exceptions that are determined at compile time, there is an expression that\nwill simply do raise the exception. These can be propagated upwards, collecting\npotentially "side effects", i.e. parts of expressions that were executed before\nit occurred, and still have to be executed.\n\nConsider the following code:\n\n.. code-block:: python\n\n   print side_effect_having() + (1 / 0)\n   print something_else()\n\nThe ``(1 / 0)`` can be predicted to raise a ``ZeroDivisionError`` exception,\nwhich will be propagated through the ``+`` operation. That part is just\nConstant Propagation as normal.\n\nThe call `side_effect_having()`` will have to be retained though, but the\n``print`` statement does not and can be turned into an explicit raise. The\nstatement sequence can then be aborted and as such the ``something_else`` call\nneeds no code generation or consideration anymore.\n\nTo that end, Nuitka works with a special node that raises an exception and is\nwrapped with a so-called "side_effects" expression, but yet can be used in the\ncode as an expression having a value.\n\n.. admonition:: Status\n\n   The propagation of exceptions is mostly implemented but needs handling in\n   every kind of operations, and not all of them might do it already. As work\n   progresses or examples arise, the coverage will be extended. Feel free to\n   generate bug reports with non-working examples.\n\nException Scope Reduction\n-------------------------\n\nConsider the following code:\n\n.. code-block:: python\n\n    try:\n        b = 8\n        print range(3, b, 0)\n        print "Will not be executed"\n    except ValueError, e:\n        print e\n\nThe ``try`` block is bigger than it needs to be. The statement ``b = 8`` cannot\ncause a ``ValueError`` to be raised. As such it can be moved to outside the try\nwithout any risk.\n\n.. code-block:: python\n\n    b = 8\n    try:\n        print range(3, b, 0)\n        print "Will not be executed"\n    except ValueError as e:\n        print e\n\n.. admonition:: Status\n\n   This is considered done. For every kind of operation, we trace if it may\n   raise an exception. We do however *not* track properly yet, what can do\n   a ``ValueError`` and what cannot.\n\n\nException Block Inlining\n------------------------\n\nWith the exception propagation, it then becomes possible to transform this\ncode:\n\n.. code-block:: python\n\n    try:\n        b = 8\n        print range(3, b, 0)\n        print "Will not be executed"\n    except ValueError, e:\n        print e\n\n.. code-block:: python\n\n    try:\n        raise ValueError, "range() step argument must not be zero"\n    except ValueError, e:\n        print e\n\nWhich then can be lowered in complexity by avoiding the raise and catch\nof the exception, making it:\n\n.. code-block:: python\n\n   e = ValueError( "range() step argument must not be zero" )\n   print e\n\n.. admonition:: Status\n\n   This is not implemented yet.\n\nEmpty Branch Removal\n--------------------\n\nFor loops and conditional statements that contain only code without effect, it\nshould be possible to remove the whole construct:\n\n.. code-block:: python\n\n   for i in range(1000):\n       pass\n\nThe loop could be removed, at maximum, it should be considered an assignment of\nvariable ``i`` to ``999`` and no more.\n\n.. admonition:: Status\n\n   This is not implemented yet, as it requires us to track iterators, and their\n   side effects, as well as loop values, and exit conditions. Too much yet, but\n   we will get there.\n\nAnother example:\n\n.. code-block:: python\n\n   if side_effect_free:\n      pass\n\nThe condition check should be removed in this case, as its evaluation is not\nneeded. It may be difficult to predict that ``side_effect_free`` has no side\neffects, but many times this might be possible.\n\n.. admonition:: Status\n\n   This is considered implemented. The conditional statement nature is removed\n   if both branches are empty, only the condition is evaluated and checked for\n   truth (in cases that could raise an exception).\n\nUnpacking Prediction\n--------------------\n\nWhen the length of the right-hand side of an assignment to a sequence can be\npredicted, the unpacking can be replaced with multiple assignments.\n\n.. code-block:: python\n\n   a, b, c = 1, side_effect_free(), 3\n\n.. code-block:: python\n\n   a = 1\n   b = side_effect_free()\n   c = 3\n\nThis is of course only really safe if the left-hand side cannot raise an\nexception while building the assignment targets.\n\nWe do this now, but only for constants, because we currently have no ability to\npredict if an expression can raise an exception or not.\n\n.. admonition:: Status\n\n   Not implemented yet. Will need us to see through the unpacking of what is\n   an iteration over a tuple, we created ourselves. We are not there yet, but we\n   will get there.\n\nBuilt-in Type Inference\n-----------------------\n\nWhen a construct like ``in xrange()`` or ``in range()`` is used, it is possible\nto know what the iteration does and represent that so that iterator users can\nuse that instead.\n\nI consider that:\n\n.. code-block:: python\n\n    for i in xrange(1000):\n        something(i)\n\ncould translate ``xrange(1000)`` into an object of a special class that does\nthe integer looping more efficiently. In case ``i`` is only assigned from\nthere, this could be a nice case for a dedicated class.\n\n.. admonition:: Status\n\n   Future work, not even started.\n\nQuicker Function Calls\n----------------------\n\nFunctions are structured so that their parameter parsing and ``tp_call``\ninterface is separate from the actual function code. This way the call can be\noptimized away. One problem is that the evaluation order can differ.\n\n.. code-block:: python\n\n   def f(a, b, c):\n       return a, b, c\n\n   f(c = get1(), b = get2(), a = get3())\n\nThis will have to evaluate first ``get1()``, then ``get2()`` and only then\n``get3()`` and then make the function call with these values.\n\nTherefore it will be necessary to have a staging of the parameters before\nmaking the actual call, to avoid a re-ordering of the calls to ``get1()``,\n``get2()``, and ``get3()``.\n\n.. admonition:: Status\n\n   Not even started. A re-formulation that avoids the dictionary to call the\n   function, and instead uses temporary variables appears to be relatively\n   straight forward once we do that kind of parameter analysis.\n\nLowering of iterated Container Types\n------------------------------------\n\nIn some cases, accesses to ``list`` constants can become ``tuple`` constants\ninstead.\n\nConsider that:\n\n.. code-block:: python\n\n   for x in [a, b, c]:\n       something(x)\n\nCan be optimized into this:\n\n.. code-block:: python\n\n   for x in (a, b, c):\n        something(x)\n\nThis allows for simpler, faster code to be generated, and fewer checks needed,\nbecause e.g. the ``tuple`` is clearly immutable, whereas the ``list`` needs a\ncheck to assert that. This is also possible for sets.\n\n.. admonition:: Status\n\n   Implemented, even works for non-constants. Needs other optimization to\n   become generally useful, and will itself help other optimization to become\n   possible. This allows us to e.g. only treat iteration over tuples, and not\n   care about sets.\n\nIn theory, something similar is also possible for ``dict``. For the later, it\nwill be non-trivial though to maintain the order of execution without temporary\nvalues introduced. The same thing is done for pure constants of these types,\nthey change to ``tuple`` values when iterated.\n\nCredits\n=======\n\nContributors to Nuitka\n----------------------\n\nThanks go to these individuals for their much-valued contributions to\nNuitka. Contributors have the license to use Nuitka for their own code even if\nClosed Source.\n\nThe order is sorted by time.\n\n- Li Xuan Ji: Contributed patches for general portability issue and\n  enhancements to the environment variable settings.\n\n- Nicolas Dumazet: Found and fixed reference counting issues, ``import``\n  packages work, improved some of the English and generally made good code\n  contributions all over the place, solved code generation TODOs, did tree\n  building cleanups, core stuff.\n\n- Khalid Abu Bakr: Submitted patches for his work to support MinGW and Windows,\n  debugged the issues, and helped me to get cross compile with MinGW from Linux\n  to Windows. This was quite difficult stuff.\n\n- Liu Zhenhai: Submitted patches for Windows support, making the inline Scons\n  copy actually work on Windows as well. Also reported import related bugs, and\n  generally helped me make the Windows port more usable through his testing and\n  information.\n\n- Christopher Tott: Submitted patches for Windows, and general as well as\n  structural cleanups.\n\n- Pete Hunt: Submitted patches for macOS X support.\n\n- "ownssh": Submitted patches for built-ins module guarding, and made massive\n  efforts to make high-quality bug reports. Also the initial "standalone" mode\n  implementation was created by him.\n\n- Juan Carlos Paco: Submitted cleanup patches, creator of the `Nuitka GUI\n  <https://github.com/juancarlospaco/nuitka-gui>`__, creator of the `Ninja IDE\n  plugin <https://github.com/juancarlospaco/nuitka-ninja>`__ for Nuitka.\n\n- "Dr. Equivalent": Submitted the Nuitka Logo.\n\n- Johan Holmberg: Submitted patch for Python3 support on macOS X.\n\n- Umbra: Submitted patches to make the Windows port more usable, adding user\n  provided application icons, as well as MSVC support for large constants and\n  console applications.\n\n- David Cortesi: Submitted patches and test cases to make macOS port more\n  usable, specifically for the Python3 standalone support of Qt.\n\n- Andrew Leech: Submitted github pull request to allow using "-m nuitka" to\n  call the compiler. Also pull request to improve "bist_nuitka" and to do\n  the registration.\n\n- Pawe\xc5\x82 K: Submitted github pull request to remove glibc from standalone\n  distribution, saving size and improving robustness considering the\n  various distributions.\n\n- Orsiris de Jong: Submitted github pull request to implement the dependency\n  walking with `pefile` under Windows.\n\n- Jorj X. McKie: Submitted github pull requests with NumPy plugin to retain\n  its accelerating libraries, and Tkinter to include the TCL distribution\n  on Windows.\n\nProjects used by Nuitka\n-----------------------\n\n* The `CPython project <http://www.python.org>`__\n\n  Thanks for giving us CPython, which is the base of Nuitka. We are nothing\n  without it.\n\n* The `GCC project <http://gcc.gnu.org>`__\n\n  Thanks for not only the best compiler suite but also thanks for making it\n  easy supporting to get Nuitka off the ground. Your compiler was the first\n  usable for Nuitka and with very little effort.\n\n* The `Scons project <http://www.scons.org>`__\n\n  Thanks for tackling the difficult points and providing a Python environment\n  to make the build results. This is such a perfect fit to Nuitka and a\n  dependency that will likely remain.\n\n* The `valgrind project <http://valgrind.org>`__\n\n  Luckily we can use Valgrind to determine if something is an actual\n  improvement without the noise. And it\'s also helpful to determine what\'s\n  actually happening when comparing.\n\n* The `NeuroDebian project <http://neuro.debian.net>`__\n\n  Thanks for hosting the build infrastructure that the Debian and sponsor\n  Yaroslav Halchenko uses to provide packages for all Ubuntu versions.\n\n* The `openSUSE Buildservice <http://openbuildservice.org>`__\n\n  Thanks for hosting this excellent service that allows us to provide RPMs for\n  a large variety of platforms and make them available immediately nearly at\n  release time.\n\n* The `MinGW64 project <http://mingw-w64.org>`__\n\n  Thanks for porting the gcc to Windows. This allowed portability of Nuitka\n  with relatively little effort.\n\n* The `Buildbot project <http://buildbot.net>`__\n\n  Thanks for creating an easy to deploy and use continuous integration\n  framework that also runs on Windows and is written and configured in Python\n  code. This allows running the Nuitka tests long before release time.\n\n* The `isort project <http://timothycrosley.github.io/isort/>`__\n\n  Thanks for making nice import ordering so easy. This makes it so easy to let\n  your IDE do it and clean up afterward.\n\n* The `black project <https://github.com/ambv/black>`__\n\n  Thanks for making a fast and reliable way for automatically formatting\n  the Nuitka source code.\n\nUpdates for this Manual\n=======================\n\nThis document is written in REST. That is an ASCII format which is readable as\nASCII, but used to generate PDF or HTML documents.\n\nYou will find the current source under:\nhttp://nuitka.net/gitweb/?p=Nuitka.git;a=blob_plain;f=README.rst\n\nAnd the current PDF under:\nhttp://nuitka.net/doc/README.pdf\n'