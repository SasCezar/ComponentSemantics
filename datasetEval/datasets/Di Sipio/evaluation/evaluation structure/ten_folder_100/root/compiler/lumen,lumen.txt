b'# Lumen - A new compiler and runtime for BEAM languages\n\n[![Build Status](https://api.cirrus-ci.com/github/lumen/lumen.svg)](https://cirrus-ci.com/github/lumen/lumen)\n\n* [Contributing](#contributing)\n  * [Tools](#contrib-tools)\n  * [Project Structure](#contrib-project)\n  * [Making Changes](#contrib-changes)\n* [About Lumen](#about)\n* [Goals](#goals)\n* [Non-Goals](#non-goals)\n* [Architecture](#architecture)\n\n<a name="contributing"/>\n\n## Contributing\n\nIn order to build Lumen, or make changes to it, you\'ll need the following installed:\n\n<a name="contrib-tools"/>\n\n### Tools\n\nFirst, you will need to install [rustup](https://rustup.rs/). Follow the instructions at that link.\n\nOnce you have installed `rustup`, you will need to install the nightly version of Rust, this is\ncurrently required due to our dependency on `wasm-bindgen` when targeting WebAssembly:\n\n    rustup default nightly # install nightly toolchain\n\nYou may also want to install the following tools for editor support (`rustfmt` will be required on\nall pull requests!):\n\n    rustup component add rustfmt clippy\n\nNext, you will need to install the `wasm32` targets for the toolchain:\n\n    rustup target add wasm32-unknown-unknown --toolchain nightly\n\nYou will also need to install the `wasm-bindgen** command-line tools:\n\n    cargo +nightly install wasm-bindgen-cli\n\nFinally we will need `wasm-pack`. It is needed to build the examples and get up and running. Follow their installation instructions from [the wasm-pack repository](https://github.com/rustwasm/wasm-pack).\n\n#### LLVM\n\nNow that Rust is setup and ready to go, you will also need LLVM for building the compiler.\n\nLLVM requires Cmake, a C/C++ compiler (i.e. GCC/Clang), and Python. It is also\nhighly recommended that you also install [Ninja](https://ninja-build.org/) and\n[CCache](https://ccache.dev) to make the build significantly faster. You can\nfind all of these dependencies in your system package manager, including\nHomebrew on macOS.\n\nTo install LLVM:\n\n    git clone https://github.com/lumen/llvm-project\n    cd llvm-project\n    make llvm\n\nThis will install LLVM to ~/.local/share/llvm/lumen, and assumes that Ninja and\nCCache are installed, you can customize the `llvm` target in the `Makefile` to\nuse `make` instead by removing `-G Ninja` from the invocation of `cmake`,\nlikewise you can change the setting to use CCache by removing that option as well.\n\n**NOTE:** Building LLVM the first time will take a long time, so grab a coffee, smoke \'em if you got \'em, etc.\n\nOnce LLVM is built, you can run `make build` from the root to fetch all dependencies and build the project.\n\n<a name="contrib-project"/>\n\n### Project Structure\n\nLumen is currently divided into a few major components:\n\n* Compiler\n  * EIR\n  * liblumen_compiler\n  * liblumen_codegen\n  * lumen\n* Interpreter\n  * liblumen_eir_interpreter\n* Runtime\n  * liblumen_core\n  * liblumen_alloc\n  * lumen_runtime\n  * lumen_web\n\nEIR is short for _Erlang Intermediate Representation_, it is managed in a\nseparate project which can be found [here](https://github.com/eirproject/eir).\nLumen\'s frontend parsers and IR are found there.\n\nAt the moment, the compiler backend pieces are being worked on in another branch, and so\nshould be ignored for now. These pieces will be merged soon, and this README\nwill be updated at that point.\n\nThe interpreter is currently how we are testing and executing Erlang code, and\nit builds on top of the same compiler frontend/IR that the compiler backend will\nuse.\n\nThe runtime is built as a static library, which is ultimately linked into compiled Erlang programs,\nthis runtime contains the machinery necessary to interact with the underlying system, as well as\nprovide concurrency, garbage collection, and other necessities which are not part of the compiler\ntransformation.\n\n<a name="contrib-changes"/>\n\n### Making Changes\n\nBefore making any major changes, please open an issue tagged "RFC" with the problem you need to\nsolve, your proposed solution, and any outstanding questions you have in terms of implementation.\nThe core team (and you) will use that issue to talk through the changes and either green light the\nproposal, or request changes. In some cases, a proposal may request changes that are either\nincompatible with the project\'s goals, or impose too high of a maintenance or complexity burden, and\nwill be turned down. The importance of having the RFC discussion first is that it prevents someone\nfrom doing a bunch of work that will ultimately not be upstreamed, and allows the core team or the\ncommunity to provide feedback that may make the work simpler, or better in the end.\n\nFor smaller changes/bug fixes, feel free to open an issue first if you are new to the project and\nwant some guidance on working through the fix. Otherwise, it is acceptable to just open a PR\ndirectly with your fix, and let the review happen there.\n\nAlways feel free to open issues for bugs, and even perceived issues or questions, as they can be a\nuseful resource for others; but please do make sure to use the search function to avoid\nduplication!\n\nIf you plan to participate in discussions, or contribute to the project, be aware that this project\nwill not tolerate abuse of any kind against other members of the community; if you feel that someone\nis being abusive or inappropriate, please contact one of the core team members directly (or all of\nus). We want to foster an environment where people both new and experienced feel welcomed, can have\ntheir questions answered, and hopefully work together to make this project better!\n\n<a name="about"/>\n\n## About Lumen\n\nLumen is not only a compiler, but a runtime as well. It consists of two parts:\n\n* A compiler for Erlang to native code for a given target (x86, ARM, WebAssembly)\n* An Erlang runtime, implemented in Rust, which provides the core functionality\n  needed to implement OTP\n\nThe primary motivator for Lumen\'s development was the ability to compile Elixir\napplications that could target WebAssembly, enabling use of Elixir as a language\nfor frontend development. It is also possible to use Lumen to target other\nplatforms as well, by producing self-contained executables on platforms such as x86.\n\nLumen is different than BEAM in the following ways:\n\n* It is an ahead-of-time compiler, rather than a virtual machine that operates\n  on bytecode\n* It has some additional restrictions to allow more powerful optimizations to\n  take place, in particular hot code reloading is not supported\n* The runtime library provided by Lumen is written in Rust, and while very\n  similar, differs in mostly transparent ways. One of the goals is to provide a\n  better foundation for learning how the runtime is implemented, and to take\n  advantage of Rust\'s more powerful static analysis to catch bugs early.\n* It has support for targeting WebAssembly\n\nThe result of compiling a BEAM application via Lumen is a static executable. This differs\nsignificantly from how deployment on the BEAM works today (i.e. via OTP releases). While we\nsacrifice the ability to perform hot upgrades/downgrades, we make huge gains in cross-platform\ncompatibility, and ease of use. Simply drop the executable on a compatible platform, and run it, no\ntools required, or special considerations during builds. This works the same way that building Rust\nor Go applications works today.\n\n<a name="goals"/>\n\n## Goals\n\n- Support WebAssembly as a build target\n- Produce easy-to-deploy static executables as build artifacts\n- Integrate with tooling provided by BEAM languages\n- More efficient execution by removing the need for an interpreter at runtime\n- Feature parity with mainline OTP (with exception of the non-goals listed below)\n\n<a name="non-goals"/>\n\n## Non-Goals\n\n- Support for hot upgrades/downgrades\n- Support for dynamic code loading\n\nLumen _is_ an alternative implementation of Erlang/OTP, so as a result it is not as battle tested, or necessarily\nas performant as the BEAM itself. Until we have a chance to run some benchmarks, it is hard to know\nwhat the difference between the two in terms of performance actually is.\n\nLumen is _not_ intended to replace BEAM at this point in time. At a minimum, the stated non-goals\nof this project mean that for at least some percentage of projects, some required functionality would\nbe missing. However, it is meant to be a drop-in replacement for applications which are better served\nby its feature set.\n\n<a name="architecture"/>\n\n## Architecture\n\n### Compiler\n\nThe compiler frontend accepts Erlang source files. This is parsed into an\nabstract syntax tree, lowered into EIR (Erlang Intermediate Representation),\nthen finally lowered to LLVM IR where codegen is performed.\n\nInternally, the compiler represents Erlang/Elixir code in a form very similar to\ncontinuation-passing style. Continuations are a powerful construct that enable\nstraightforward implementations of non-local returns/exceptions, green\nthreading, and more. Optimizations are primarily performed on this\nrepresentation, prior to lowering to LLVM IR. See\n[eirproject/eir](https://github.com/eirproject/eir) for more information on the\ncompiler frontend and EIR itself.\n\nThe compiler produces object files, and handles linking objects\ntogether into an executable.\n\n### Runtime\n\nThe runtime design is mostly the same as OTP, but we are not running an interpreter, instead the\ncode is ahead-of-time compiled:\n\n- The entry point sets up the environment, and starts the scheduler\n- The scheduler is composed of one scheduler per thread\n- Each scheduler can steal work from other schedulers if it is short on work\n- Processes are spawned on the same scheduler as the process they are spawned from,\n  but a scheduler is able to steal them away to load balance\n- I/O is asynchronous, with dedicated threads and an event loop for dispatch\n\nThe initial version will be quite spartan, but this is so we can focus on getting the runtime\nbehavior rock solid before we circle back to add in more capabilities.\n\n### NIFs\n\nNIFs will be able to be defined in any language with C FFI, and will need to be compiled to object\nfiles and then passed via linker flags to the compiler. The compiler will then ensure that the NIFs\nare linked into the executable.\n\nThe design of the FFI is still up in the air - we will likely have a compatibility layer which will\nmimic the existing `erl_nif.h` interface, but since the runtime is different, there may be\nopportunities to provide more direct hooks to parts of the system.\n\n## License\n\nApache 2.0\n'