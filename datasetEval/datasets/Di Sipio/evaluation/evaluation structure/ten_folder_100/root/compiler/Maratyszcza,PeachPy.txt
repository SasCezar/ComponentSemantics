b'.. image:: https://github.com/Maratyszcza/PeachPy/blob/master/logo/peachpy.png\n  :alt: PeachPy logo\n  :align: center\n\n===========================================================================\nPortable Efficient Assembly Code-generator in Higher-level Python (PeachPy)\n===========================================================================\n\n.. image:: https://img.shields.io/badge/License-BSD%202--Clause%20%22Simplified%22%20License-blue.svg\n  :alt: PeachPy License: Simplified BSD\n  :target: https://github.com/Maratyszcza/PeachPy/blob/master/LICENSE.rst\n\n.. image:: https://travis-ci.org/Maratyszcza/PeachPy.svg?branch=master\n  :alt: Travis-CI Build Status\n  :target: https://travis-ci.org/Maratyszcza/PeachPy/\n\n.. image:: https://ci.appveyor.com/api/projects/status/p64ew9in189bu2pl?svg=true\n  :alt: AppVeyor Build Status\n  :target: https://ci.appveyor.com/project/MaratDukhan/peachpy\n\nPeachPy is a Python framework for writing high-performance assembly kernels.\n\nPeachPy aims to simplify writing optimized assembly kernels while preserving all optimization opportunities of traditional assembly. Some PeachPy features:\n\n- Universal assembly syntax for Windows, Unix, and Golang assembly.\n\n  * PeachPy can directly generate ELF, MS COFF and Mach-O object files and assembly listings for Golang toolchain\n\n- Automatic adaption of function to different calling conventions and ABIs.\n  \n  * Functions for different platforms can be generated from the same assembly source\n  * Supports Microsoft x64 ABI, System V x86-64 ABI (Linux and OS X), Linux x32 ABI, Native Client x86-64 SFI ABI, Golang AMD64 ABI, Golang AMD64p32 ABI\n      \n- Automatic register allocation.\n  \n  * PeachPy is flexible and lets mix auto-allocated and hardcoded registers in the same code.\n\n- Automation of routine tasks in assembly programming:\n\n  * Function prolog and epilog and generated by PeachPy\n  * De-duplication of data constants (e.g. `Constant.float32x4(1.0)`)\n  * Analysis of ISA extensions used in a function\n\n- Supports x86-64 instructions up to AVX-512 and SHA\n  \n  * Including 3dnow!+, XOP, FMA3, FMA4, TBM and BMI2.\n  * Excluding x87 FPU and most system instructions.\n  * Rigorously tested with `auto-generated tests <https://github.com/Maratyszcza/PeachPy/tree/master/test/x86_64/encoding>`_ to produce the same opcodes as binutils.\n\n- Auto-generation of metadata files\n\n  * Makefile with module dependencies (`-MMD` and `-MF` options)\n  * C header for the generated functions\n  * Function metadata in JSON format\n\n- Python-based metaprogramming and code-generation.\n- Multiplexing of multiple instruction streams (helpful for software pipelining).\n- Compatible with Python 2 and Python 3, CPython and PyPy.\n\nOnline Demo\n-----------\n\nYou can try online demo on `PeachPy.IO <http://www.peachpy.io>`_\n\nInstallation\n------------\n\nPeachPy is actively developed, and thus there are presently no stable releases of 0.2 branch. We recommend that you use the `master` version:\n\n.. code-block:: bash\n\n  pip install --upgrade git+https://github.com/Maratyszcza/PeachPy\n\nInstallation for development\n****************************\n\nIf you plan to modify PeachPy, we recommend the following installation procedure:\n\n.. code-block:: bash\n\n  git clone https://github.com/Maratyszcza/PeachPy.git\n  cd PeachPy\n  python setup.py develop\n\n\nUsing PeachPy as a command-line tool\n------------------------------------\n\n.. code-block:: python\n  \n  # These two lines are not needed for PeachPy, but will help you get autocompletion in good code editors\n  from peachpy import *\n  from peachpy.x86_64 import *\n\n  # Lets write a function float DotProduct(const float* x, const float* y)\n  \n  # If you want maximum cross-platform compatibility, arguments must have names\n  x = Argument(ptr(const_float_), name="x")\n  # If name is not specified, it is auto-detected\n  y = Argument(ptr(const_float_))\n\n  # Everything inside the `with` statement is function body\n  with Function("DotProduct", (x, y), float_,\n    # Enable instructions up to SSE4.2\n    # PeachPy will report error if you accidentially use a newer instruction\n    target=uarch.default + isa.sse4_2):\n  \n    # Request two 64-bit general-purpose registers. No need to specify exact names.\n    reg_x, reg_y = GeneralPurposeRegister64(), GeneralPurposeRegister64()\n\n    # This is a cross-platform way to load arguments. PeachPy will map it to something proper later.\n    LOAD.ARGUMENT(reg_x, x)\n    LOAD.ARGUMENT(reg_y, y)\n\n    # Also request a virtual 128-bit SIMD register...\n    xmm_x = XMMRegister()\n    # ...and fill it with data\n    MOVAPS(xmm_x, [reg_x])\n    # It is fine to mix virtual and physical (xmm0-xmm15) registers in the same code\n    MOVAPS(xmm2, [reg_y])\n\n    # Execute dot product instruction, put result into xmm_x\n    DPPS(xmm_x, xmm2, 0xF1)\n\n    # This is a cross-platform way to return results. PeachPy will take care of ABI specifics.\n    RETURN(xmm_x)\n\nNow you can compile this code into a binary object file that you can link into a program...\n\n.. code-block:: bash\n\n  # Use MS-COFF format with Microsoft ABI for Windows\n  python -m peachpy.x86_64 -mabi=ms -mimage-format=ms-coff -o example.obj example.py\n  # Use Mach-O format with SysV ABI for OS X\n  python -m peachpy.x86_64 -mabi=sysv -mimage-format=mach-o -o example.o example.py\n  # Use ELF format with SysV ABI for Linux x86-64\n  python -m peachpy.x86_64 -mabi=sysv -mimage-format=elf -o example.o example.py\n  # Use ELF format with x32 ABI for Linux x32 (x86-64 with 32-bit pointer)\n  python -m peachpy.x86_64 -mabi=x32 -mimage-format=elf -o example.o example.py\n  # Use ELF format with Native Client x86-64 ABI for Chromium x86-64\n  python -m peachpy.x86_64 -mabi=nacl -mimage-format=elf -o example.o example.py\n\nWhat else? You can convert the program to Plan 9 assembly for use with Go programming language:\n\n.. code-block:: bash\n\n  # Use Go ABI (asm version) with -S flag to generate assembly for Go x86-64 targets\n  python -m peachpy.x86_64 -mabi=goasm -S -o example_amd64.s example.py\n  # Use Go-p32 ABI (asm version) with -S flag to generate assembly for Go x86-64 targets with 32-bit pointers\n  python -m peachpy.x86_64 -mabi=goasm-p32 -S -o example_amd64p32.s example.py\n\nIf Plan 9 assembly is too restrictive for your use-case, generate ``.syso`` objects `which can be linked into Go programs <https://github.com/golang/go/wiki/GcToolchainTricks#use-syso-file-to-embed-arbitrary-self-contained-c-code>`_:\n\n.. code-block:: bash\n\n  # Use Go ABI (syso version) to generate .syso objects for Go x86-64 targets\n  # Image format can be any (ELF/Mach-O/MS-COFF)\n  python -m peachpy.x86_64 -mabi=gosyso -mimage-format=elf -o example_amd64.syso example.py\n  # Use Go-p32 ABI (syso version) to generate .syso objects for Go x86-64 targets with 32-bit pointers\n  # Image format can be any (ELF/Mach-O/MS-COFF)\n  python -m peachpy.x86_64 -mabi=gosyso-p32 -mimage-format=elf -o example_amd64p32.syso example.py\n\nSee `examples <https://github.com/Maratyszcza/PeachPy/tree/master/examples>`_ for real-world scenarios of using PeachPy with ``make``, ``nmake`` and ``go generate`` tools.\n\nUsing PeachPy as a Python module\n--------------------------------\n\nWhen command-line tool does not provide sufficient flexibility, Python scripts can import PeachPy objects from ``peachpy`` and ``peachpy.x86_64`` modules and do arbitrary manipulations on output images, program structure, instructions, and bytecodes.\n\nPeachPy as Inline Assembler for Python\n**************************************\n\nPeachPy links assembly and Python: it represents assembly instructions and syntax as Python classes, functions, and objects.\nBut it also works the other way around: PeachPy can represent your assembly functions as callable Python functions!\n\n.. code-block:: python\n\n  from peachpy import *\n  from peachpy.x86_64 import *\n\n  x = Argument(int32_t)\n  y = Argument(int32_t)\n\n  with Function("Add", (x, y), int32_t) as asm_function:\n      reg_x = GeneralPurposeRegister32()\n      reg_y = GeneralPurposeRegister32()\n\n      LOAD.ARGUMENT(reg_x, x)\n      LOAD.ARGUMENT(reg_y, y)\n\n      ADD(reg_x, reg_y)\n\n      RETURN(reg_x)\n\n  python_function = asm_function.finalize(abi.detect()).encode().load()\n\n  print(python_function(2, 2)) # -> prints "4"\n\nPeachPy as Instruction Encoder\n******************************\n\nPeachPy can be used to explore instruction length, opcodes, and alternative encodings:\n\n.. code-block:: python\n\n  from peachpy.x86_64 import *\n\n  ADD(eax, 5).encode() # -> bytearray(b\'\\x83\\xc0\\x05\')\n\n  MOVAPS(xmm0, xmm1).encode_options() # -> [bytearray(b\'\\x0f(\\xc1\'), bytearray(b\'\\x0f)\\xc8\')]\n  \n  VPSLLVD(ymm0, ymm1, [rsi + 8]).encode_length_options() # -> {6: bytearray(b\'\\xc4\\xe2uGF\\x08\'),\n                                                         #     7: bytearray(b\'\\xc4\\xe2uGD&\\x08\'),\n                                                         #     9: bytearray(b\'\\xc4\\xe2uG\\x86\\x08\\x00\\x00\\x00\')}\n\nTutorials\n---------\n\n- `Writing Go assembly functions with PeachPy <https://blog.gopheracademy.com/advent-2016/peachpy/>`_ by `Damian Gryski <https://github.com/dgryski>`_\n\n- `Adventures in JIT compilation (Part 4) <http://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-4-in-python/>`_ by `Eli Bendersky <https://github.com/eliben>`_\n\nUsers\n-----\n\n- `NNPACK <https://github.com/Maratyszcza/NNPACK>`_ -- an acceleration layer for convolutional networks on multi-core CPUs.\n\n- `ChaCha20 <https://git.schwanenlied.me/yawning/chacha20>`_ -- Go implementation of ChaCha20 cryptographic cipher.\n\n- `AEZ <https://git.schwanenlied.me/yawning/aez>`_ -- Go implemenetation of AEZ authenticated-encryption scheme.\n\n- `bp128 <https://github.com/robskie/bp128>`_ -- Go implementation of SIMD-BP128 integer encoding and decoding.\n\n- `go-marvin32 <https://github.com/dgryski/go-marvin32>`_ -- Go implementation of Microsoft\'s Marvin32 hash function.\n\n- `go-highway <https://github.com/dgryski/go-highway>`_ -- Go implementation of Google\'s Highway hash function.\n\n- `go-metro <https://github.com/dgryski/go-metro>`_ -- Go implementation of MetroHash function.\n\n- `go-stadtx <https://github.com/dgryski/go-stadtx>`_ -- Go implementation of Stadtx hash function.\n\n- `go-sip13 <https://github.com/dgryski/go-sip13>`_ -- Go implementation of SipHash 1-3 function.\n\n- `go-chaskey <https://github.com/dgryski/go-chaskey>`_ -- Go implementation of Chaskey MAC.\n\n- `go-speck <https://github.com/dgryski/go-speck>`_ -- Go implementation of SPECK cipher.\n\n- `go-bloomindex <https://github.com/dgryski/go-bloomindex>`_ - Go implementation of Bloom-filter based search index.\n\n- `go-groupvariant <https://github.com/dgryski/go-groupvarint>`_ - SSE-optimized group varint integer encoding in Go.\n\n- `Yeppp! <http://www.yeppp.info>`_ performance library. All optimized kernels in Yeppp! are implemented in PeachPy (uses old version of PeachPy with deprecated syntax).\n\nPeer-Reviewed Publications\n--------------------------\n\n- Marat Dukhan "PeachPy: A Python Framework for Developing High-Performance Assembly Kernels", Python for High-Performance Computing (PyHPC) 2013 (`slides <http://www.yeppp.info/resources/peachpy-slides.pdf>`_, `paper <http://www.yeppp.info/resources/peachpy-paper.pdf>`_, code uses deprecated syntax)\n\n- Marat Dukhan "PeachPy meets Opcodes: Direct Machine Code Generation from Python", Python for High-Performance Computing (PyHPC) 2015 (`slides <http://www.peachpy.io/slides/pyhpc2015>`_, `paper on ACM Digital Library <https://dl.acm.org/citation.cfm?id=2835860>`_).\n\nOther Presentations\n-------------------\n\n- Marat Dukhan "Developing Low-Level Assembly Kernels in PeachPy", presentation on `The First BLIS Retreat Workshop <https://www.cs.utexas.edu/users/flame/BLISRetreat/>`_, 2013 (`slides <https://www.cs.utexas.edu/users/flame/BLISRetreat/BLISRetreatTalks/PeachPy.pdf>`_, code uses deprecated syntax)\n\n- Marat Dukhan "Porting BLIS micro-kernels to PeachPy", presentation on `The Third BLIS Retreat Workshop <https://www.cs.utexas.edu/users/flame/BLISRetreat2015/>`_, 2015 (`slides <http://www.peachpy.io/slides/blis-retreat-2015/>`_)\n\n- Marat Dukhan "Accelerating Data Processing in Go with SIMD Instructions", presentation on `Atlanta Go Meetup <http://www.meetup.com/Go-Users-Group-Atlanta>`_, September 16, 2015 (`slides <https://docs.google.com/presentation/d/1MYg8PyhEf0oIvZ9YU2panNkVXsKt5UQBl_vGEaCeB1k/edit?usp=sharing>`_)\n\nDependencies\n------------\n\n- Nearly all instruction classes in PeachPy are generated from `Opcodes Database <https://github.com/Maratyszcza/Opcodes>`_\n\n- Instruction encodings in PeachPy are validated against `binutils <https://www.gnu.org/software/binutils/>`_ using auto-generated tests\n\n- PeachPy uses `six <https://pythonhosted.org/six/>`_ and `enum34 <https://pypi.python.org/pypi/enum34>`_ packages as a compatibility layer between Python 2 and Python 3\n\nAcknowledgements\n----------------\n\n.. image:: https://github.com/Maratyszcza/PeachPy/blob/master/logo/hpcgarage.png\n  :alt: HPC Garage logo\n  :target: http://hpcgarage.org/\n\n.. image:: https://github.com/Maratyszcza/PeachPy/blob/master/logo/college-of-computing.gif\n  :alt: Georgia Tech College of Computing logo\n  :target: http://www.cse.gatech.edu/\n\nThis work is a research project at the HPC Garage lab in the Georgia Institute of Technology, College of Computing, School of Computational Science and Engineering.\n\nThe work was supported in part by grants to Prof. Richard Vuduc\'s research lab, `The HPC Garage <www.hpcgarage.org>`_, from the National Science Foundation (NSF) under NSF CAREER award number 0953100; and a grant from the Defense Advanced Research Projects Agency (DARPA) Computer Science Study Group program\n\nAny opinions, conclusions or recommendations expressed in this software and documentation are those of the authors and not necessarily reflect those of NSF or DARPA.\n'