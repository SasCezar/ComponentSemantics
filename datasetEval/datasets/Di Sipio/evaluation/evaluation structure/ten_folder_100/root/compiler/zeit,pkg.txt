b'![](http://res.cloudinary.com/zeit-inc/image/upload/v1509936789/repositories/pkg/pkg-repo-banner-new.png)\n\n[![Build Status](https://travis-ci.org/zeit/pkg.svg?branch=master)](https://travis-ci.org/zeit/pkg)\n[![Coverage Status](https://coveralls.io/repos/github/zeit/pkg/badge.svg?branch=master)](https://coveralls.io/github/zeit/pkg?branch=master)\n[![Dependency Status](https://david-dm.org/zeit/pkg/status.svg)](https://david-dm.org/zeit/pkg)\n[![devDependency Status](https://david-dm.org/zeit/pkg/dev-status.svg)](https://david-dm.org/zeit/pkg?type=dev)\n[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/zeit)\n\nThis command line interface enables you to package your Node.js project into an executable that can be run even on devices without Node.js installed.\n\n## Use Cases\n\n* Make a commercial version of your application without sources\n* Make a demo/evaluation/trial version of your app without sources\n* Instantly make executables for other platforms (cross-compilation)\n* Make some kind of self-extracting archive or installer\n* No need to install Node.js and npm to run the packaged application\n* No need to download hundreds of files via `npm install` to deploy\nyour application. Deploy it as a single file\n* Put your assets inside the executable to make it even more portable\n* Test your app against new Node.js version without installing it\n\n## Usage\n\n```sh\nnpm install -g pkg\n```\n\nAfter installing it, run `pkg --help` without arguments to see list of options.\n\nThe entrypoint of your project is a mandatory CLI argument. It may be:\n\n* Path to entry file. Suppose it is `/path/app.js`, then\npackaged app will work the same way as `node /path/app.js`\n* Path to `package.json`. `Pkg` will follow `bin` property of\nthe specified `package.json` and use it as entry file.\n* Path to directory. `Pkg` will look for `package.json` in\nthe specified directory. See above.\n\n### Targets\n\n`pkg` can generate executables for several target machines at a\ntime. You can specify a comma-separated list of targets via `--targets`\noption. A canonical target consists of 3 elements, separated by\ndashes, for example `node6-macos-x64` or `node4-linux-armv6`:\n\n* **nodeRange** node${n} or latest\n* **platform** freebsd, linux, alpine, macos, win\n* **arch** x64, x86, armv6, armv7\n\nYou may omit any element (and specify just `node6` for example).\nThe omitted elements will be taken from current platform or\nsystem-wide Node.js installation (its version and arch).\nThere is also an alias `host`, that means that all 3 elements\nare taken from current platform/Node.js. By default targets are\n`linux,macos,win` for current Node.js version and arch.\n\n### Config\n\nDuring packaging process `pkg` parses your sources, detects\ncalls to `require`, traverses the dependencies of your project\nand includes them into executable. In most cases you\ndon\'t need to specify anything manually. However your code\nmay have `require(variable)` calls (so called non-literal\nargument to `require`) or use non-javascript files (for\nexample views, css, images etc).\n```js\n  require(\'./build/\' + cmd + \'.js\')\n  path.join(__dirname, \'views/\' + viewName)\n```\nSuch cases are not handled by `pkg`. So you must specify the\nfiles - scripts and assets - manually in `pkg` property of\nyour `package.json` file.\n```json\n  "pkg": {\n    "scripts": "build/**/*.js",\n    "assets": "views/**/*"\n  }\n```\nYou may also specify arrays of globs:\n```\n    "assets": [ "assets/**/*", "images/**/*" ]\n```\nJust be sure to call `pkg package.json` or `pkg .` to make use\nof `scripts` and `assets` entries.\n\n### Scripts\n\n`scripts` is a [glob](https://github.com/sindresorhus/globby)\nor list of globs. Files specified as `scripts` will be compiled\nusing `v8::ScriptCompiler` and placed into executable without\nsources. They must conform JS standards of those Node.js versions\nyou target (see [Targets](#targets)), i.e. be already transpiled.\n\n### Assets\n\n`assets` is a [glob](https://github.com/sindresorhus/globby)\nor list of globs. Files specified as `assets` will be packaged\ninto executable as raw content without modifications. Javascript\nfiles may be specified as `assets` as well. Their sources will\nnot be stripped. It improves performance of execution of those\nfiles and simplifies debugging.\n\nSee also\n[Detecting assets in source code](#detecting-assets-in-source-code) and\n[Snapshot filesystem](#snapshot-filesystem).\n\n### Options\n\nNode.js application can be called with runtime options\n(belonging to Node.js or V8). To list them type `node --help` or\n`node --v8-options`. You can "bake" these runtime options into\npackaged application. The app will always run with the options\nturned on. Just remove `--` from option name.\n```sh\npkg app.js --options expose-gc\npkg app.js --options max_old_space_size=4096\n```\n\n### Output\n\nYou may specify `--output` if you create only one executable\nor `--out-path` to place executables for multiple targets.\n\n### Debug\n\nPass `--debug` to `pkg` to get a log of packaging process.\nIf you have issues with some particular file (seems not packaged\ninto executable), it may be useful to look through the log.\n\n### Build\n\n`pkg` has so called "base binaries" - they are actually same\n`node` executables but with some patches applied. They are\nused as a base for every executable `pkg` creates. `pkg`\ndownloads precompiled base binaries before packaging your\napplication. If you prefer to compile base binaries from\nsource instead of downloading them, you may pass `--build`\noption to `pkg`. First ensure your computer meets the\nrequirements to compile original Node.js:\n[BUILDING.md](https://github.com/nodejs/node/blob/master/BUILDING.md)\n\n## Usage of packaged app\n\nCommand line call to packaged app `./app a b` is equivalent\nto `node app.js a b`\n\n## Snapshot filesystem\n\nDuring packaging process `pkg` collects project files and places\nthem into executable. It is called a snapshot. At run time the\npackaged application has access to snapshot filesystem where all\nthat files reside.\n\nPackaged files have `/snapshot/` prefix in their paths (or\n`C:\\snapshot\\` in Windows). If you used `pkg /path/app.js` command line,\nthen `__filename` value will be likely `/snapshot/path/app.js`\nat run time. `__dirname` will be `/snapshot/path` as well. Here is\nthe comparison table of path-related values:\n\nvalue                          | with `node`         | packaged                   | comments\n-------------------------------|---------------------|----------------------------|-----------\n__filename                     | /project/app.js     | /snapshot/project/app.js   |\n__dirname                      | /project            | /snapshot/project          |\nprocess.cwd()                  | /project            | /deploy                    | suppose the app is called ...\nprocess.execPath               | /usr/bin/nodejs     | /deploy/app-x64            | `app-x64` and run in `/deploy`\nprocess.argv[0]                | /usr/bin/nodejs     | /deploy/app-x64            |\nprocess.argv[1]                | /project/app.js     | /snapshot/project/app.js   |\nprocess.pkg.entrypoint         | undefined           | /snapshot/project/app.js   |\nprocess.pkg.defaultEntrypoint  | undefined           | /snapshot/project/app.js   |\nrequire.main.filename          | /project/app.js     | /snapshot/project/app.js   |\n\nHence, in order to make use of a file collected at packaging\ntime (`require` a javascript file or serve an asset) you should\ntake `__filename`, `__dirname`, `process.pkg.defaultEntrypoint`\nor `require.main.filename` as a base for your path calculations.\nFor javascript files you can just `require` or `require.resolve`\nbecause they use current `__dirname` by default. For assets use\n`path.join(__dirname, \'../path/to/asset\')`. Learn more about\n`path.join` in\n[Detecting assets in source code](#detecting-assets-in-source-code).\n\nOn the other hand, in order to access real file system at run time\n(pick up a user\'s external javascript plugin, json configuration or\neven get a list of user\'s directory) you should take `process.cwd()`\nor `path.dirname(process.execPath)`.\n\n## Detecting assets in source code\n\nWhen `pkg` encounters `path.join(__dirname, \'../path/to/asset\')`,\nit automatically packages the file specified as an asset. See\n[Assets](#assets). Pay attention that `path.join` must have two\narguments and the last one must be a string literal.\n\nThis way you may even avoid creating `pkg` config for your project.\n\n## Native addons\n\nNative addons (`.node` files) use is supported, but packaging\n`.node` files inside the executable is not resolved yet. You have\nto deploy native addons used by your project to the same directory\nas the executable.\n\nWhen a package, that contains a native module, is being installed,\nthe native module is compiled against current system-wide Node.js\nversion. Then, when you compile your project with `pkg`, pay attention\nto `--target` option. You should specify the same Node.js version\nas your system-wide Node.js to make compiled executable compatible\nwith `.node` files.\n\n## API\n\n`const { exec } = require(\'pkg\')`\n\n`exec(args)` takes an array of command line arguments and returns\na promise. For example:\n\n```js\nawait exec([ \'app.js\', \'--target\', \'host\', \'--output\', \'app.exe\' ])\n// do something with app.exe, run, test, upload, deploy, etc\n```\n\n## Troubleshooting\n\n### Error: ENOENT: no such file or directory, uv_chdir\n\nThis error can be caused by deleting the directory the application is\nrun from. Or, generally, deleting `process.cwd()` directory when the\napplication is running.\n'