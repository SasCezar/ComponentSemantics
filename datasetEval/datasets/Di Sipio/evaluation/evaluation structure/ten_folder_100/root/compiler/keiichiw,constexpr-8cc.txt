b'# constexpr-8cc: Compile-time C Compiler [![Build Status](https://travis-ci.org/kw-udon/constexpr-8cc.svg?branch=master)](https://travis-ci.org/kw-udon/constexpr-8cc)\n\n[constexpr-8cc](https://github.com/kw-udon/constexpr-8cc) is a compile-time C compiler implemented as C++14 constant expressions.\nThis enables you to **compile while you compile!**\nThis project is a port of [8cc](https://github.com/rui314/8cc) built on [ELVM Infrastructure](https://github.com/shinh/elvm).\n\n[Constant expressions in C++](http://en.cppreference.com/w/cpp/language/constant_expression) are expressions that can be evaluated at compile-time.\nIn C++14, [by relaxing constrains](https://isocpp.org/files/papers/N3652.html), constant expressions became so **powerful** that **a C compiler can be implemented in**!\n\nIn constexpr-8cc, the main routine for compilations of C programs is implemented in a C++14 `constexpr` function.\nTherefore, if you compile `8cc.cpp` to a binary file by g++, compilation of a C program will be performed as a compile-time computation and the result of this C compilation will be embedded into the generated binary.\nIn this sense, constexpr-8cc is a **compile-time C compiler**.\n\nThe following is the `main` function in [8cc.cpp](https://github.com/kw-udon/constexpr-8cc/blob/master/8cc.cpp).\n```c++\nint main() {\n  // Compile-time\n  constexpr buffer buf = eight_cc(); // Compile C code into ELVM IR\n  constexpr unsigned int output_size = buf.size;\n\n  static_assert(0 <= output_size && output_size < EIGHT_CC_OUTPUT_LIMIT, "8cc: Error");\n\n  // Run-time\n  for(int i = 0; i < output_size; ++i) {\n    putchar(buf.b[i]);\n  }\n}\n```\nIn this program, the return value of `eight_cc` is stored into the variable `buf` with a `constexpr` specifier.\nThus, you will find that the compilation of a C program is done in compile-time.\n\n## Usage\n\n`constexpr-8cc` works on Linux and OS X and requires [**g++ 6.2**](https://gcc.gnu.org/gcc-6/).\n(The version of g++ is **important!**)\n\n### Compilation by `run_8cc.py`\nIn order to try constexpr-8cc easily, use `run_8cc.py`.\n```shell\n$ ./run_8cc.py x86 ./test/hello.c -o ./hello.exe # It takes about 3 minutes on my laptop\n$ chmod +x ./hello.exe                           # \'hello.exe\' is i386-linux binary\n$ ./hello.exe\nHello, world!\n```\nYou can change the target language of compilations like the following:\n```shell\n$ ./run_8cc.py py ./test/hello.c -o ./hello.py # target language is Python\n$ python ./hello.py\nHello, world!\n```\nFor more information about this script, type `$ ./run_8cc.py -h`.\n\n### Compilation by hand\nIf you want to compile `8cc.cpp` manually, please look at `config.hpp`.\nIn this file, the variable `EIGHT_CC_INPUT_FILE` is defined.\n`EIGHT_CC_INPUT_FILE` should be a name of a file that contains a source C program as a C++ string literal.\nThis string will be embedded in 8cc.cpp at pre-processing-time and used as an input of the compile-time computation.\n\nSo, before compiling `8cc.cpp` manually, you have to convert a raw program to a string literal like the following:\n```shell\n$ sed \'1s/^/R"(/\' ./test/hello.c | sed \'$s/$/\\n)"/\' > ./test/hello.c.txt # Convert C to string literal\n$ g++-6 ./8cc.cpp -o eir_gen.out\n$ ./eir_gen.out > ./test/hello.eir       # eir_gen.out outputs ELVM IR\n$ sed -i \'1s/^/R"(x86/\' ./test/hello.eir # Convert IR to string literal\n$ sed -i \'$s/$/\\n)"/\' ./test/hello.eir\n$ g++-6 ./elc.cpp -o exe_gen.out\n$ ./exe_gen.out > ./hello.exe            # exe_gen.out outputs i386-linux binary\n$ chmod +x ./hello.exe\n$ ./hello.exe\nHello, world!\n```\n## How was constexpr-8cc generated?\nWhen you see [`8cc.hpp`](https://github.com/kw-udon/constexpr-8cc/blob/master/8cc.hpp), you will know this program was not written by hand.\nActually, I used [ELVM Compiler Infrastructure](https://github.com/shinh/elvm) to generate it.\nI just implemented a translator from ELVM IR to C++14 constexpr [here](https://github.com/shinh/elvm/pull/15).\n\n## Author\n**Keiichi Watanabe** (udon.watanabe [at] gmail.com)\n\n## Links\n* [8cc](https://github.com/rui314/8cc) ([@rui314](https://github.com/rui314))\n  - A very cool C compiler. constexpr-8cc is a C++14\'s constexpr port of 8cc.\n* [ELVM](https://github.com/shinh/elvm) ([@shinh](https://github.com/shinh))\n  - ELVM(EsoLang Virtual Machine) is a parody project of LLVM, but dedicated to Esoteric Languages. constexpr-8cc is built on ELVM infrastructure.\n* [8cc.vim](https://github.com/rhysd/8cc.vim) ([@rhysd](https://github.com/rhysd)), [8cc.tex](https://github.com/hak7a3/8cc.tex) ([@hak7a3](https://github.com/hak7a3))\n  - constexpr-8cc is influenced by these projects.\n* [Compile-time Brainf\\*ck compiler](https://github.com/bolero-MURAKAMI/Sprout/blob/master/example/brainfuck/x86_compile.cpp) ([@bolero-MURAKAMI](https://github.com/bolero-MURAKAMI))\n  - I got several ideas from this program.\n\n* [TMP-8cc](https://github.com/kw-udon/TMP-8cc): Another Compile-time C Compiler\n  - Another compile-time C compiler I created, which is implemented in **C++ Template Metaprogramming**\n  - This is generated by [ELVM\'s C++ Template Metaprogramming backend](https://github.com/shinh/elvm/pull/39).\n  - Since `TMP` neads huge amount of memories, `TMP-8cc` unfortunately **does not work** on real machines.\n* [My blog post (Japanese)](http://kw-udon.hatenablog.com/entry/2016/12/03/201722)\n'