b'Also see the Khronos landing page for glslang as a reference front end:\n\nhttps://www.khronos.org/opengles/sdk/tools/Reference-Compiler/\n\nThe above page includes where to get binaries, and is kept up to date\nregarding the feature level of glslang.\n\nglslang\n=======\n\n[![Build Status](https://travis-ci.org/KhronosGroup/glslang.svg?branch=master)](https://travis-ci.org/KhronosGroup/glslang)\n[![Build status](https://ci.appveyor.com/api/projects/status/q6fi9cb0qnhkla68/branch/master?svg=true)](https://ci.appveyor.com/project/Khronoswebmaster/glslang/branch/master)\n\nAn OpenGL and OpenGL ES shader front end and validator.\n\nThere are several components:\n\n1. A GLSL/ESSL front-end for reference validation and translation of GLSL/ESSL into an AST.\n\n2. An HLSL front-end for translation of a broad generic HLL into the AST. See [issue 362](https://github.com/KhronosGroup/glslang/issues/362) and [issue 701](https://github.com/KhronosGroup/glslang/issues/701) for current status.\n\n3. A SPIR-V back end for translating the AST to SPIR-V.\n\n4. A standalone wrapper, `glslangValidator`, that can be used as a command-line tool for the above.\n\nHow to add a feature protected by a version/extension/stage/profile:  See the\ncomment in `glslang/MachineIndependent/Versions.cpp`.\n\nTasks waiting to be done are documented as GitHub issues.\n\nDeprecations\n------------\n\n1. GLSLang, when installed through CMake, will install a `SPIRV` folder into\n`${CMAKE_INSTALL_INCLUDEDIR}`. This `SPIRV` folder is being moved to\n`glslang/SPIRV`. During the transition the `SPIRV` folder will be installed into\nboth locations. The old install of `SPIRV/` will be removed as a CMake install\ntarget no sooner then May 1, 2020. See issue #1964.\n\nExecution of Standalone Wrapper\n-------------------------------\n\nTo use the standalone binary form, execute `glslangValidator`, and it will print\na usage statement.  Basic operation is to give it a file containing a shader,\nand it will print out warnings/errors and optionally an AST.\n\nThe applied stage-specific rules are based on the file extension:\n* `.vert` for a vertex shader\n* `.tesc` for a tessellation control shader\n* `.tese` for a tessellation evaluation shader\n* `.geom` for a geometry shader\n* `.frag` for a fragment shader\n* `.comp` for a compute shader\n\nThere is also a non-shader extension\n* `.conf` for a configuration file of limits, see usage statement for example\n\nBuilding\n--------\n\nInstead of building manually, you can also download the binaries for your\nplatform directly from the [master-tot release][master-tot-release] on GitHub.\nThose binaries are automatically uploaded by the buildbots after successful\ntesting and they always reflect the current top of the tree of the master\nbranch.\n\n### Dependencies\n\n* A C++11 compiler.\n  (For MSVS: 2015 is recommended, 2013 is fully supported/tested, and 2010 support is attempted, but not tested.)\n* [CMake][cmake]: for generating compilation targets.\n* make: _Linux_, ninja is an alternative, if configured.\n* [Python 3.x][python]: for executing SPIRV-Tools scripts. (Optional if not using SPIRV-Tools and the \'External\' subdirectory does not exist.)\n* [bison][bison]: _optional_, but needed when changing the grammar (glslang.y).\n* [googletest][googletest]: _optional_, but should use if making any changes to glslang.\n\n### Build steps\n\nThe following steps assume a Bash shell. On Windows, that could be the Git Bash\nshell or some other shell of your choosing.\n\n#### 1) Check-Out this project \n\n```bash\ncd <parent of where you want glslang to be>\ngit clone https://github.com/KhronosGroup/glslang.git\n```\n\n#### 2) Check-Out External Projects\n\n```bash\ncd <the directory glslang was cloned to, "External" will be a subdirectory>\ngit clone https://github.com/google/googletest.git External/googletest\n```\n\nIf you want to use googletest with Visual Studio 2013, you also need to check out an older version:\n\n```bash\n# to use googletest with Visual Studio 2013\ncd External/googletest\ngit checkout 440527a61e1c91188195f7de212c63c77e8f0a45\ncd ../..\n```\n\nIf you wish to assure that SPIR-V generated from HLSL is legal for Vulkan,\nor wish to invoke -Os to reduce SPIR-V size from HLSL or GLSL, install\nspirv-tools with this:\n\n```bash\n./update_glslang_sources.py\n```\n\n#### 3) Configure\n\nAssume the source directory is `$SOURCE_DIR` and the build directory is\n`$BUILD_DIR`. First ensure the build directory exists, then navigate to it:\n\n```bash\nmkdir -p $BUILD_DIR\ncd $BUILD_DIR\n```\n\nFor building on Linux:\n\n```bash\ncmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="$(pwd)/install" $SOURCE_DIR\n# "Release" (for CMAKE_BUILD_TYPE) could also be "Debug" or "RelWithDebInfo"\n```\n\nFor building on Windows:\n\n```bash\ncmake $SOURCE_DIR -DCMAKE_INSTALL_PREFIX="$(pwd)/install"\n# The CMAKE_INSTALL_PREFIX part is for testing (explained later).\n```\n\nThe CMake GUI also works for Windows (version 3.4.1 tested).\n\nAlso, consider using `git config --global core.fileMode false` (or with `--local`) on Windows\nto prevent the addition of execution permission on files.\n\n#### 4) Build and Install\n\n```bash\n# for Linux:\nmake -j4 install\n\n# for Windows:\ncmake --build . --config Release --target install\n# "Release" (for --config) could also be "Debug", "MinSizeRel", or "RelWithDebInfo"\n```\n\nIf using MSVC, after running CMake to configure, use the\nConfiguration Manager to check the `INSTALL` project.\n\n### If you need to change the GLSL grammar\n\nThe grammar in `glslang/MachineIndependent/glslang.y` has to be recompiled with\nbison if it changes, the output files are committed to the repo to avoid every\ndeveloper needing to have bison configured to compile the project when grammar\nchanges are quite infrequent. For windows you can get binaries from\n[GnuWin32][bison-gnu-win32].\n\nThe command to rebuild is:\n\n```bash\nm4 -P MachineIndependent/glslang.m4 > MachineIndependent/glslang.y\nbison --defines=MachineIndependent/glslang_tab.cpp.h\n      -t MachineIndependent/glslang.y\n      -o MachineIndependent/glslang_tab.cpp\n```\n\nThe above commands are also available in the bash script in `updateGrammar`,\nwhen executed from the glslang subdirectory of the glslang repository.\nWith no arguments it builds the full grammar, and with a "web" argument,\nthe web grammar subset (see more about the web subset in the next section).\n\n### Building to WASM for the Web and Node\n\nUse the steps in [Build Steps](#build-steps), with the following notes/exceptions:\n* For building the web subset of core glslang:\n  + execute `updateGrammar web` from the glslang subdirectory\n    (or if using your own scripts, `m4` needs a `-DGLSLANG_WEB` argument)\n  + set `-DENABLE_HLSL=OFF -DBUILD_TESTING=OFF -DENABLE_OPT=OFF -DINSTALL_GTEST=OFF`\n  + turn on `-DENABLE_GLSLANG_WEB=ON`\n  + optionally, for GLSL compilation error messages, turn on `-DENABLE_GLSLANG_WEB_DEVEL=ON`\n* `emsdk` needs to be present in your executable search path, *PATH* for\n  Bash-like enivironments\n  + [Instructions located\n    here](https://emscripten.org/docs/getting_started/downloads.html#sdk-download-and-install)\n* Wrap cmake call: `emcmake cmake`\n* To get a fully minimized build, make sure to use `brotli` to compress the .js\n  and .wasm files\n\nExample:\n\n```sh\nemcmake cmake -DCMAKE_BUILD_TYPE=Release -DENABLE_GLSLANG_WEB=ON \\\n    -DENABLE_HLSL=OFF -DBUILD_TESTING=OFF -DENABLE_OPT=OFF -DINSTALL_GTEST=OFF ..\n```\n\nTesting\n-------\n\nRight now, there are two test harnesses existing in glslang: one is [Google\nTest](gtests/), one is the [`runtests` script](Test/runtests). The former\nruns unit tests and single-shader single-threaded integration tests, while\nthe latter runs multiple-shader linking tests and multi-threaded tests.\n\n### Running tests\n\nThe [`runtests` script](Test/runtests) requires compiled binaries to be\ninstalled into `$BUILD_DIR/install`. Please make sure you have supplied the\ncorrect configuration to CMake (using `-DCMAKE_INSTALL_PREFIX`) when building;\notherwise, you may want to modify the path in the `runtests` script.\n\nRunning Google Test-backed tests:\n\n```bash\ncd $BUILD_DIR\n\n# for Linux:\nctest\n\n# for Windows:\nctest -C {Debug|Release|RelWithDebInfo|MinSizeRel}\n\n# or, run the test binary directly\n# (which gives more fine-grained control like filtering):\n<dir-to-glslangtests-in-build-dir>/glslangtests\n```\n\nRunning `runtests` script-backed tests:\n\n```bash\ncd $SOURCE_DIR/Test && ./runtests\n```\n\n### Contributing tests\n\nTest results should always be included with a pull request that modifies\nfunctionality.\n\nIf you are writing unit tests, please use the Google Test framework and\nplace the tests under the `gtests/` directory.\n\nIntegration tests are placed in the `Test/` directory. It contains test input\nand a subdirectory `baseResults/` that contains the expected results of the\ntests.  Both the tests and `baseResults/` are under source-code control.\n\nGoogle Test runs those integration tests by reading the test input, compiling\nthem, and then compare against the expected results in `baseResults/`. The\nintegration tests to run via Google Test is registered in various\n`gtests/*.FromFile.cpp` source files. `glslangtests` provides a command-line\noption `--update-mode`, which, if supplied, will overwrite the golden files\nunder the `baseResults/` directory with real output from that invocation.\nFor more information, please check `gtests/` directory\'s\n[README](gtests/README.md).\n\nFor the `runtests` script, it will generate current results in the\n`localResults/` directory and `diff` them against the `baseResults/`.\nWhen you want to update the tracked test results, they need to be\ncopied from `localResults/` to `baseResults/`.  This can be done by\nthe `bump` shell script.\n\nYou can add your own private list of tests, not tracked publicly, by using\n`localtestlist` to list non-tracked tests.  This is automatically read\nby `runtests` and included in the `diff` and `bump` process.\n\nProgrammatic Interfaces\n-----------------------\n\nAnother piece of software can programmatically translate shaders to an AST\nusing one of two different interfaces:\n* A new C++ class-oriented interface, or\n* The original C functional interface\n\nThe `main()` in `StandAlone/StandAlone.cpp` shows examples using both styles.\n\n### C++ Class Interface (new, preferred)\n\nThis interface is in roughly the last 1/3 of `ShaderLang.h`.  It is in the\nglslang namespace and contains the following, here with suggested calls\nfor generating SPIR-V:\n\n```cxx\nconst char* GetEsslVersionString();\nconst char* GetGlslVersionString();\nbool InitializeProcess();\nvoid FinalizeProcess();\n\nclass TShader\n    setStrings(...);\n    setEnvInput(EShSourceHlsl or EShSourceGlsl, stage,  EShClientVulkan or EShClientOpenGL, 100);\n    setEnvClient(EShClientVulkan or EShClientOpenGL, EShTargetVulkan_1_0 or EShTargetVulkan_1_1 or EShTargetOpenGL_450);\n    setEnvTarget(EShTargetSpv, EShTargetSpv_1_0 or EShTargetSpv_1_3);\n    bool parse(...);\n    const char* getInfoLog();\n\nclass TProgram\n    void addShader(...);\n    bool link(...);\n    const char* getInfoLog();\n    Reflection queries\n```\n\nFor just validating (not generating code), subsitute these calls:\n\n```cxx\n    setEnvInput(EShSourceHlsl or EShSourceGlsl, stage,  EShClientNone, 0);\n    setEnvClient(EShClientNone, 0);\n    setEnvTarget(EShTargetNone, 0);\n```\n\nSee `ShaderLang.h` and the usage of it in `StandAlone/StandAlone.cpp` for more\ndetails. There is a block comment giving more detail above the calls for\n`setEnvInput, setEnvClient, and setEnvTarget`.\n\n### C Functional Interface (original)\n\nThis interface is in roughly the first 2/3 of `ShaderLang.h`, and referred to\nas the `Sh*()` interface, as all the entry points start `Sh`.\n\nThe `Sh*()` interface takes a "compiler" call-back object, which it calls after\nbuilding call back that is passed the AST and can then execute a backend on it.\n\nThe following is a simplified resulting run-time call stack:\n\n```c\nShCompile(shader, compiler) -> compiler(AST) -> <back end>\n```\n\nIn practice, `ShCompile()` takes shader strings, default version, and\nwarning/error and other options for controlling compilation.\n\nBasic Internal Operation\n------------------------\n\n* Initial lexical analysis is done by the preprocessor in\n  `MachineIndependent/Preprocessor`, and then refined by a GLSL scanner\n  in `MachineIndependent/Scan.cpp`.  There is currently no use of flex.\n\n* Code is parsed using bison on `MachineIndependent/glslang.y` with the\n  aid of a symbol table and an AST.  The symbol table is not passed on to\n  the back-end; the intermediate representation stands on its own.\n  The tree is built by the grammar productions, many of which are\n  offloaded into `ParseHelper.cpp`, and by `Intermediate.cpp`.\n\n* The intermediate representation is very high-level, and represented\n  as an in-memory tree.   This serves to lose no information from the\n  original program, and to have efficient transfer of the result from\n  parsing to the back-end.  In the AST, constants are propogated and\n  folded, and a very small amount of dead code is eliminated.\n\n  To aid linking and reflection, the last top-level branch in the AST\n  lists all global symbols.\n\n* The primary algorithm of the back-end compiler is to traverse the\n  tree (high-level intermediate representation), and create an internal\n  object code representation.  There is an example of how to do this\n  in `MachineIndependent/intermOut.cpp`.\n\n* Reduction of the tree to a linear byte-code style low-level intermediate\n  representation is likely a good way to generate fully optimized code.\n\n* There is currently some dead old-style linker-type code still lying around.\n\n* Memory pool: parsing uses types derived from C++ `std` types, using a\n  custom allocator that puts them in a memory pool.  This makes allocation\n  of individual container/contents just few cycles and deallocation free.\n  This pool is popped after the AST is made and processed.\n\n  The use is simple: if you are going to call `new`, there are three cases:\n\n  - the object comes from the pool (its base class has the macro\n    `POOL_ALLOCATOR_NEW_DELETE` in it) and you do not have to call `delete`\n\n  - it is a `TString`, in which case call `NewPoolTString()`, which gets\n    it from the pool, and there is no corresponding `delete`\n\n  - the object does not come from the pool, and you have to do normal\n    C++ memory management of what you `new`\n\n\n[cmake]: https://cmake.org/\n[python]: https://www.python.org/\n[bison]: https://www.gnu.org/software/bison/\n[googletest]: https://github.com/google/googletest\n[bison-gnu-win32]: http://gnuwin32.sourceforge.net/packages/bison.htm\n[master-tot-release]: https://github.com/KhronosGroup/glslang/releases/tag/master-tot\n'