b"[![Build Status](https://travis-ci.org/rspeele/Rezoom.SQL.svg?branch=master)](https://travis-ci.org/rspeele/Rezoom.SQL)\n\n[Tutorial & full documentation](https://rspeele.gitbooks.io/rezoom-sql/doc/Tutorial/)\n\n[Query playground -- try out the SQL dialect live!](http://rzsql.net/#52632EC5A298CFFFD652D53C03DD1318A9DACA3C)\n\n# Statically typed SQL for F# #\n\nRezoom.SQL is an F# ORM for SQL databases.\n\nIt integrates with the F# compiler via a generative type provider to statically\ntypecheck its own dialect of SQL. It knows how to translate this SQL dialect to\nvarious backends. Currently it supports SQLite, SQL Server, and PostgreSQL.\n\nThe type provider makes it fast and easy to write SQL statements, run them, and\nconsume their results from your F# code with full type safety. You don't need to\ninstall any editor extensions or custom tooling, just add a NuGet package and\nyou're off and running writing code like this:\n\n![animated example usage to write queries](doc/ReadmeResources/Queries.gif)\n\n## Database schema inferred from migration scripts\n\nIn order to typecheck your queries, Rezoom.SQL has to know your database schema\n(so it can know, for example, that the `Id` column in the `Users` table is an\nint). It learns the schema by reading your migration scripts and observing what\ntables and views are created, columns added, and so on.\n\nWhen developing the first iteration of your application (or a new feature with\nits own migration script), it's easy to sketch out a model then go back and\nchange it as you code, without having to touch a real database until you're\nready to run.\n\nHere's an example. You might want to refresh the page to start the GIF from the\nbeginning.\n\n![animated example usage to write queries](doc/ReadmeResources/ModelChange.gif)\n\nBecause this is a generative type provider, it makes plain old .NET types you\ncan use from other languages. That is, you can write an F# project that uses\nRezoom.SQL and defines your migrations and queries, then reference that from C#\nor VB.NET projects and use the generated query types with no problem in those\nlangages. There is even an option to represent nullable types with C#-style\n`System.Nullable<T>` instead of `FSharpOption<T>` to make this scenario work\nextra smoothly.\n\nCheck out the [query\nplayground](http://rzsql.net/#52632EC5A298CFFFD652D53C03DD1318A9DACA3C) to see\nwhat kinds of SQL you can write.\n\n## The productivity of static typing\n\nWhen you make schema changes -- for example, replacing `FirstName` and\n`LastName` fields with a single `FullName` field -- it's comforting to know the\ncompiler will point out the queries you need to update.\n\nThe typechecker also tightens up the feedback loop, so you don't waste your time\ntracking down typos and trivial SQL mistakes you'd normally only encounter at runtime.\n\nHere are just a handful of possible errors you'll be informed of at compile time\nand can fix in seconds. There are currently over 45 different error types that\ncan be detected at compile time.\n\n### Mistyped table names\n\n![example error on mistyped table name](doc/ReadmeResources/NoTableError.png)\n\n### Incompatible data types\n\n![example error on comparing string to int](doc/ReadmeResources/TypeMismatch.png)\n\n### Selecting columns not included in a `GROUP BY` clause\n\n![example error on selecting column not found in group by clause](doc/ReadmeResources/GroupByError.png)\n\n## Flexible migration order for working in teams\n\nSince Rezoom.SQL understands the language, it knows that some migrations like\n`alter table X add column Y` and `alter table X add column Z` can be run in any\norder and produce the same effects.\n\nWhen you're working with a team, you can take advantage of this to add the\ntables and columns you need for the feature you're coding, while your other team\nmembers do the same for their features -- _without_ having to decide the **One\nTrue Migration Order** when you merge.\n\nSee details [here](https://rspeele.gitbooks.io/rezoom-sql/doc/Configuration/MigrationTrees.html).\n\n# Integration with Rezoom\n\nYou can use Rezoom.SQL by itself, as in the example code above.\n\nBut as the name implies, it's designed to work with\n[Rezoom](https://github.com/rspeele/Rezoom). When you use it with Rezoom, you can\ntake advantage of automatic caching and combine units of business logic to share round trips\nto the database.\n\n## Automatic batching\n\nWith Rezoom, you build up a `Plan` to represent a transaction, which may involve\nmultiple SQL commands (or web API calls, or other high-latency data manipulation).\n\nIf you have one `Plan` called `threeTrip` that makes 3 queries, and another\ncalled `twoTrip` that makes 2 queries, you can choose whether to combine them\nsequentially for 5 round trips to the database...\n\n```fsharp\nlet sequential =\n    plan {\n        let! x = threeTrip\n        let! y = twoTrip\n        return (x, y)\n    }\n```\n\n![sequential execution diagram](doc/ReadmeResources/SequentialExecution.gv.png)\n\nOr concurrently, for 3 round trips to the database. The first two query batches\nsent to the database will include pending queries from *both* `threePlan` and\n`twoTrip`:\n\n```fsharp\nlet concurrent =\n    plan {\n        let! x, y = threeTrip, twoTrip\n        return (x, y)\n    }\n```\n\n![sequential execution diagram](doc/ReadmeResources/ConcurrentExecution.gv.png)\n\n## Automatic caching\n\nEach statically typed query comes with some useful info for caching:\n\n* A compiler-generated ID\n* A boolean indicating whether it could make sense to cache (has no side effects, does not use rand(), newid(), etc)\n* A bitmask of the tables it reads from\n* A bitmask of the tables it writes to\n\nRezoom uses this cache info to avoid unnecessarily re-querying for the same data\nduring the execution of a `Plan` (i.e. within a transaction).\n\nThis means if you have 30 different functions that call\n`LoadUserPermissions(currentUserId)`, only 1 query for permissions will actually\nbe run when you use those functions together in a transaction. Unless, of\ncourse, you edit the permissions table during the course of the transaction, in\nwhich case the cached result will automatically be invalidated and the\npermissions re-queried next time they are requested.\n\nThis lets you safely check all the invariants you need for each method in your\ndomain layer, without fear of causing mountains of redundant queries, and\nwithout any of the effort of writing your own caching layer.\n\n## Get started\n\nTo get started using RZSQL, read the\n[tutorial](https://rspeele.gitbooks.io/rezoom-sql/doc/Tutorial/). It'll get you\nup and running in 5 minutes or your money back.\n\n"