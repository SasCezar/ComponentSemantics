b"\n![Yarr](https://raw.github.com/brownplt/pyret-lang/master/img/pyret-banner.png)\n\n[![Build Status](https://travis-ci.org/brownplt/pyret-lang.svg)](https://travis-ci.org/brownplt/pyret-lang)\n\nA scripting language.\n\nTo learn about the language, visit [pyret.org](http://pyret.org).\n\nTo read an introduction of the language, visit [the tour](http://www.pyret.org/docs/latest/A_Tour_of_Pyret.html).\n\nTo read the documentation, visit [pyret.org/docs/](http://pyret.org/docs/).\n\nThere are two main ways to use Pyret:\n\n1.  If all you want to do is program in Pyret, there is a web-based environment\nat [code.pyret.org](https://code.pyret.org) that lets you run and save programs\nthat should be all you need.  If you're a student using Pyret, this is probably\nwhere you will do your assignments, for example.\n\n2.  If you want to develop Pyret, or install it for use at the command line,\nthe README starting below is for you.\n\nThe use of vocabulary from\nhttp://reservationsbvi.com/thisoldpirate/glossary.html is recommended when\ncommenting and reporting issues.\n\n\nInstalling\n----------\n\nFirst, make sure you've installed [Node >= 6](http://nodejs.org).  Then run:\n\n    $ npm install\n    $ make\n    $ make test\n\nIt'll build the Pyret compiler and run the tests.\n\nRunning Pyret\n-------------\n\nIf you just want to run Pyret, visit [the online\nenvironment](https://code.pyret.org) and work from there.  If you're interested\nin Pyret development, read on:\n\nThe easiest way to *run* a Pyret program from the command-line is:\n\n    $ ./src/scripts/phaseX <path-to-pyret-program-here> [command-line-args...]\n\nWhere `X` is `0`, `A`, `B`, or `C`, indicating a phase (described below). For\nexample:\n\n    $ ./src/scripts/phaseA src/scripts/show-compilation.arr examples/ahoy-world.arr\n\nAlternatively, you can compile and run a standalone JavaScript file via:\n\n    $ node build/phaseX/pyret.jarr \\\n        --build-runnable <path-to-pyret-program-here> \\\n        --outfile <path-for-standalone-js> \\\n        --builtin-js-dir src/js/trove/ \\\n        --builtin-arr-dir src/arr/trove \\\n        --require-config src/scripts/standalone-configA.json\n    $ node <path-for-standalone-js>\n\nPhases\n------\n\nPyret is a self-hosted compiler, which means that building requires some\nthought.  If you're going to get into the guts of the compiler, a brief\noverview is worth reading.  The `build` directory is separated into four\ndistinct *phases*.\n\n1.  Phase 0 is a standalone JavaScript file that contains an entire compiled\nPyret compiler and runtime.  This large blob gets committed into version\ncontrol whenever we add a nontrivial feature to the language.  It is large and\nsomewhat slow to load, but whatever is in build/phase0/pyret.jarr is currently\nthe canonical new-world implementation of Pyret.\n\n2.  Phase A is set up to be populated with built versions of all the files for\nthe compiler, built by the phase 0 compiler.  Phase A is what most of the\ntesting scripts run against, since it is the easiest to create, and after it is\nbuilt it is your development snapshot of the compiler you're working on.\nHowever, just building phase1 is not enough to fully re-boostrap the compiler,\nbecause it contains a mix of old-compiler output and any new changes that were\nmade to runtime files.\n\n3.  Phase B is set up to be populated with built versions of all the files for\nthe compiler, built by the phase A compiler.  This version does represent a\nfully-bootstrapped compiler.  If you run `make phaseB`, you get a new\nstandalone compiler in the same format as `build/phase0/pyret.js`.\n\n4.  Phase C builds from phase B.  One major use of phase C is to check the\nbootstrapped compiler from phase B.  Before committing a new standalone in\nphase 0, build both phaseB and phaseC, and check:\n    \n        $ diff build/phaseB/pyret.jarr build/phaseC/pyret.jarr\n\n    And it should be empty, which indicates that the bootstrapped compiler is\nat\n    least correct enough to recompile itself without error.\n\n    To rebuild the compiler and get a new `phase0`, run\n\n        $ make new-bootstrap\n\n    which will build the phaseB and phaseC standalones, check the diff, and\n    copy to phase0 if the diff is empty.\n\n"