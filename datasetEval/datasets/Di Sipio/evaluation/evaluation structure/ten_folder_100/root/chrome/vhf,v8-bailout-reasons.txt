b'# V8 bailout reasons\n\nA list of Crankshaft bailout reasons with examples, explanations and advices.\n\nUnless otherwise specified, the following are Crankshaft bailouts.\n\n### Warning!\n\nStarting from Chrome 59 and [Node.js 8.3.0](https://medium.com/the-node-js-collection/node-js-8-3-0-is-now-available-shipping-with-the-ignition-turbofan-execution-pipeline-aa5875ad3367), **Crankshaft is not used anymore**. It uses [TurboFan](https://github.com/v8/v8/wiki/TurboFan) instead.\n\n**The content of this repository only applies to Crankshaft**. If the JavaScript engine you are targeting does not use Crankshaft as its optimizing compiler, you should not care about this repository and the advices present in there. This repository will stay here for historical reasons, it still has documentation value.\n\n### What this is about\n\nIn order to keep this section short and allow people to get to the primary content of this repo faster, here is what it\'s all about and why you (probably) should care if you are using Crankshaft: [Chromium, Chrome, Node.js, V8, Crankshaft and bailout reasons](https://draft.li/blog/2016/01/22/chromium-chrome-v8-crankshaft-bailout-reasons/).\n\n## Index\n### [Bailout reasons](#bailout-reasons-1)\n\n* [Assignment to parameter in arguments object](#assignment-to-parameter-in-arguments-object)\n* [Bad value context for arguments value](#bad-value-context-for-arguments-value)\n* [ForInStatement with non-local each variable](#forinstatement-with-non-local-each-variable)\n* [Inlining bailed out](#inlining-bailed-out)\n* [Object literal with complex property](#object-literal-with-complex-property)\n* [Optimized too many times](#optimized-too-many-times)\n* [Reference to a variable which requires dynamic lookup](#reference-to-a-variable-which-requires-dynamic-lookup)\n* [Rest parameters](#rest-parameters)\n* [Smi addition overflow](#smi-addition-overflow)\n* [Smi subtraction overflow](#smi-subtraction-overflow)\n* [Too many parameters](#too-many-parameters)\n* [TryCatchStatement](#trycatchstatement)\n* [TryFinallyStatement](#tryfinallystatement)\n* [Unsupported phi use of arguments](#unsupported-phi-use-of-arguments)\n* [Unsupported phi use of const or let variable](#unsupported-phi-use-of-const-or-let-variable)\n* [Yield](#yield)\n\n### [References](#references-1)\n\n* [Resources](#resources)\n* [All bailout reasons](#all-bailout-reasons)\n\n\n## Bailout reasons\n### Assignment to parameter in arguments object\n\nOnly happens if you reassign to a parameter while also mentioning `arguments` in the function. [More info](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#31-reassigning-a-defined-parameter-while-also-mentioning-arguments-in-the-body-in-sloppy-mode-only-typical-example).\n\n* Simple reproduction(s)\n\n```js\n// sloppy mode only\nfunction test(a) {\n  if (arguments.length < 2) {\n    a = 0;\n  }\n}\n```\n\n* Why\n  * In sloppy mode V8 needs to preserve bindings between `arguments[0]` and `a` so that when any `a` was passed, and you reassign it to `10`, and later try to read `arguments[0]`, it has to return `10`, too. This is non-trivial for the engine, so it chooses to bail out. Strict mode removes this requirement, and `arguments` and `a` behave as regular independent JavaScript variables, so deoptimization does not occur.\n\n* Advices\n  * In the above example, you could assign `a` to a new variable.\n  * You should use strict mode anyway.\n  * It seems this will be optimized by TurboFan [#1][1].\n\n* External examples\n\n\n### Bad value context for arguments value\n\n* Simple reproduction(s)\n\n```js\n// strict & sloppy modes\nfunction test1() {\n  arguments[0] = 0;\n}\n\n// strict & sloppy modes\nfunction test2() {\n  arguments.length = 0;\n}\n\n// strict & sloppy modes\nfunction test3() {\n  return arguments;\n}\n\n// strict & sloppy modes\nfunction test4() {\n  var args = [].slice.call(arguments);\n}\n\n// strict & sloppy modes\nfunction test5() {\n  var a = arguments;\n  return function() {\n    return a;\n  };\n}\n```\n\n* Why\n  * It requires rematerialization of the `arguments` array.\n\n* Advices\n  * Read this: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n  * You could loop over `arguments` to build a new array, but it\'s not recommended. See [Unsupported phi use of arguments](#unsupported-phi-use-of-arguments)\n  * Usages of `arguments` as shown above are very rarely legitimate.\n  * [More about this bailout reason][7]\n  * It seems this will be optimized by TurboFan [#1][1].\n\n* External examples\n  * https://github.com/bevry/taskgroup/issues/12\n  * https://github.com/babel/babel/pull/3249\n\n\n### ForInStatement with non-local each variable\n\n* Simple reproduction(s)\n\n```js\n// strict & sloppy modes\nfunction test1() {\n  var obj = {};\n  for(key in obj);\n}\n\n// strict & sloppy modes\nfunction key() {\n  return \'a\';\n}\nfunction test2() {\n  var obj = {};\n  for(key in obj);\n}\n```\n\n* Why\n\n* Advices\n  * Only use pure (i.e. non-computed) local variable in a for...in.\n  * https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#5-for-in\n\n* External examples\n  * https://github.com/mbostock/d3/pull/2686\n\n\n### Inlining bailed out\n\n* Simple reproduction(s)\n\n[Courtesy of @kangax](https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-32784608)\n\n```js\n// strict & sloppy modes\nvar obj = { prop1: ... };\n\nfunction test(param) {\n  param.prop2 = ...; // Inlining bailed out\n}\ntest(obj);\n\n// strict & sloppy modes\nvar obj = { prop1: ... };\n\nfunction someMethodThatAssignsSomeOtherProp(param) {\n  param.someOtherProp = ...; // Inlining bailed out\n}\n\nfunction test(param) {\n  someMethodThatAssignsSomeOtherProp(param);\n}\n\nf(obj);\n```\n\n* Why\n  * Crankshaft predicts that `param` will have the same hidden class as `obj`, allowing optimization by doing inline caching. At the annotated lines above, Crankshaft notices that `obj`\'s hidden class is not suitable for `param` and bails out (it cannot patch the inline cache code with the hidden class information). [More about inline caching and hidden classes][8]\n\n* Advices\n  * When creating an object initialize all the properties you are going to use, instead of adding new properties to an existing object.\n\n* External examples\n\n\n### Object literal with complex property\n\n* Simple reproduction(s)\n\n```js\n// strict & sloppy modes\nfunction test() {\n  return {\n    __proto__: 3\n  };\n}\n```\n\n* Why\n\n* Advices\n\n* External examples\n\n\n### Optimized too many times\n\n* Simple reproduction(s)\n\n```js\n// strict & sloppy modes\n// No known canonical reproduction\n```\n\n* Why\n  * Optimization failed so many times that Crankshaft gave up.\n  * "In reality this very often actually means a bug in V8 - there is some optimization which is too optimistic so the generated code deopts all the time." - @mraleph [#5][5]\n  * [More about this bailout reason][6]\n\n* Advices\n  * "Just use IRHydra and look at the deoptimization reasons - the picture should become clear immediately." - @mraleph [#5][5]\n\n* External examples\n\n\n### Reference to a variable which requires dynamic lookup\n\n* Simple reproduction(s)\n\n```js\n// sloppy mode only\nfunction test() {\n  with ({x:1}) {\n    return x;\n  }\n}\n```\n\n* Why\n  * "Variable lookup fails at compile time, Crankshaft needs to resort to dynamic lookup at runtime." - Yang Guo [#3][3]\n\n* Advices\n  * "Refactor to remove the dependency on runtime-information to resolve the lookup." - Paul Irish [#4][4]\n  * **No bailout with TurboFan.**\n\n* External examples\n\n\n### Rest parameters\n\n* Simple reproduction(s)\n\n```js\n// strict & sloppy modes\nfunction test(...rest) {\n  return rest[0];\n}\n```\n\n* Why\n  * Probably because it requires materializing the `arguments` array.\n\n* Advices\n  * Avoid rest parameters or use Babel\'s [transform-es2015-parameters](http://babeljs.io/docs/plugins/transform-es2015-parameters/) until TurboFan is able to optimize them [#1][1], [#2][2].\n\n* External examples\n\n### Smi addition overflow\n* Simple reproduction(s)\nSmi - A Smi is a 32-bit signed int on 64-bit architectures and a 31-bit signed int on 32-bit architectures.\n\nSmi addition overflow\n```js\nfunction add(a, b) {\n  return a + b;\n}\n\nadd(1, 2);\nadd(1, 2);\n%OptimizeFunctionOnNextCall(add);\nadd(2 ** 31 - 2, 20);\n```\n\n* Why\n    * Once addition is performed, the return value cannot be represented as a Smi and thus is casted to [HeapNumber](https://github.com/v8/v8/blob/master/src/objects.h#L1838)\n* Advices\n    * You could have 2 separate functions - one for Smis and one for HeapNumbers.\n* External examples\n\n### Smi subtraction overflow\n* Simple reproduction(s)\nSame case as with Smi addition overflow\nSmi addition overflow\n```js\nfunction subtract(a, b) {\n  return a - b;\n}\n\nsubtract(1, 2);\nsubtract(1, 2);\n%OptimizeFunctionOnNextCall(subtract);\nsubtract(-3, 2 ** 31 - 1);\n```\n\n* Why\n    * Once subtraction is performed, the return value cannot be represented as a Smi and thus is casted to [HeapNumber](https://github.com/v8/v8/blob/master/src/objects.h#L1838)\n* Advices\n    * You could have 2 separate functions - one for Smis and one for HeapNumbers.\n* External examples\n\n### Too many parameters\n\n* Simple reproduction(s)\n\n```js\n// strict & sloppy modes\nfunction test(p1, p2, p3, ..., p512) {\n}\n```\n\n* Why\n  * Setting limits.\n\n* Advices\n  * If you write functions with 512 parameters or more, you probably don\'t worry about optimizing your code for V8 anyway.\n\n* External examples\n  * Obviously nobody ever did that. Hopefully nobody will ever do that. Zero google result on this bailout reason.\n  * [V8 code source](https://chromium.googlesource.com/v8/v8/+/fe0fe20e8f094d5688256583abc5695243c6759d%5E%21/#F2)\n\n\n### TryCatchStatement\n\n* Simple reproduction(s)\n\n```js\n// strict & sloppy modes\nfunction test() {\n  return 3;\n  try {} catch(e) {}\n}\n```\n\n* Why\n  * Try/catch makes the control flow jump virtually anywhere. It\'s hardly optimizable because the caught exception is potentially only known at runtime.\n\n* Advices\n  * Don\'t put try/catch inside computationally intensive functions.\n  * You could `try { test() } catch`\n\n* External examples\n\n\n### TryFinallyStatement\n\n* Simple reproduction(s)\n\n```js\n// strict & sloppy modes\nfunction test() {\n  return 3;\n  try {} finally {}\n}\n```\n\n* Why\n  * See [TryCatchStatement](#trycatchstatement)\n\n* Advices\n  * See [TryCatchStatement](#trycatchstatement)\n\n* External example\n\n\n### Unsupported phi use of arguments\n\n* Simple reproduction(s)\n\n```js\n// strict & sloppy modes\nfunction test1() {\n  var _arguments = arguments;\n  if (0 === 0) { // anything evaluating to true, except a number or `true`\n    _arguments = [0]; // Unsupported phi use of arguments\n  }\n}\n\n// strict & sloppy modes\nfunction test2() {\n  var _arguments = arguments;\n  for (var i = 0; i < 1; i++) {\n    _arguments = [0]; // Unsupported phi use of arguments\n  }\n}\n\n// strict & sloppy modes\nfunction test3() {\n  var _arguments = arguments;\n  var again = true;\n  while (again) {\n    _arguments = [0]; // Unsupported phi use of arguments\n    again = false;\n  }\n}\n```\n\n* Why\n  * Crankshaft is unable to guess whether `_arguments` should be an object or an array. It cannot dematerialize `_arguments` and gives up.\n  * [In-depth explaination](http://mrale.ph/blog/2015/11/02/crankshaft-vs-arguments-object.html)\n\n* Advices\n  * There is no good workaround except splitting your function into smaller ones that don\'t manipulate a copy of `arguments`.\n  * Don\'t try to fool V8 by looping over `arguments` to create a new array out of it: "Allocating array (and hope it will get handled by some optimization pass in the V8) is a bad idea." - [@mraleph](https://github.com/mraleph) ([source](https://draft.li/blog/2015/11/02/javascript-performance-with-babel-and-node-js/))\n  * It seems this will be optimized by TurboFan [#1][1].\n\n* External examples\n\n\n### Unsupported phi use of const or let variable\n\n* Simple reproduction(s)\n\n```js\nfunction test() {\n  for (let i = 0; i < 0; i++) {\n    const x = __lookupGetter__; // `__lookupGetter__` and\n  }\n  const self = this; // `this` should both be present for this to happen\n}\n```\n\n* Why\n  * Crankshaft sees a hole (marker for Temporary Dead Zone of `let`/`const`) and aborts compilation.\n\n* Advices\n\n* External examples\n\n\n### Yield\n\n* Simple reproduction(s)\n\n```js\n// strict & sloppy modes\nfunction* test() {\n  yield 0;\n}\n```\n\n* Why\n\n* Advices\n\n* External examples\n\n---\n\n[1]: https://chromium.googlesource.com/v8/v8/+/d3f074b23195a2426d14298dca30c4cf9183f203%5E%21/src/bailout-reason.h\n[2]: https://codereview.chromium.org/1272673003\n[3]: https://groups.google.com/forum/#!msg/google-chrome-developer-tools/Y0J2XQ9iiqU/H60qqZNlQa8J\n[4]: https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-37269998\n[5]: https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-140030617\n[6]: https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-145192013\n[7]: https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-147569505\n[8]: https://developers.google.com/v8/design\n\n\n## References\n### Resources\n\n* [All bailout reasons in Chromium codebase](https://code.google.com/p/chromium/codesearch#chromium/src/v8/src/bailout-reason.h)\n* [Bad value context for arguments value](https://gist.github.com/Hypercubed/89808f3051101a1a97f3)\n* [I-want-to-optimize-my-JS-application-on-V8 checklist](http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html)\n* [JavaScript: Performance loss on incorrect arguments using](http://techblog.dorogin.com/2015/05/performance-loss-on-incorrect-arguments-using.html)\n* [Optimization killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers)\n* [OptimizationKillers](https://github.com/zhangchiqing/OptimizationKillers)\n* [Performance Tips for JavaScript in V8](http://www.html5rocks.com/en/tutorials/speed/v8/)\n* [thlorenz/v8-perf](https://github.com/thlorenz/v8-perf/blob/master/compiler.md)\n* [A high-level tutorial about tracing deopts points](https://www.netguru.co/blog/tracing-patterns-hinder-performance)\n\n### All bailout reasons\n\n* 32 bit value in register is not zero-extended\n* Alignment marker expected\n* Allocation is not double aligned\n* API call returned invalid object\n* Arguments object value in a test context\n* Array boilerplate creation failed\n* Array index constant value too big\n* Assignment to arguments\n* Assignment to let variable before initialization\n* Assignment to LOOKUP variable\n* ~~Assignment to parameter in arguments object~~\n* Assignment to parameter, function uses arguments object\n* Bad value context for arguments object value\n* ~~Bad value context for arguments value~~\n* Bailed out due to dependency change\n* Bailout was not prepared\n* Both registers were smis in SelectNonSmi\n* Call to a JavaScript runtime function\n* Class literal\n* Code generation failed\n* Code object not properly patched\n* Compound assignment to lookup slot\n* Computed property name\n* Context-allocated arguments\n* Copy buffers overlap\n* Could not generate +0.0\n* Could not generate -0.0\n* DebuggerStatement\n* Declaration in catch context\n* Declaration in with context\n* Default NaN mode not set\n* Delete with global variable\n* Delete with non-global variable\n* Destination of copy not aligned\n* Do expression encountered\n* DontDelete cells can\'t contain the hole\n* DoPushArgument not implemented for double type\n* Eliminated bounds check failed\n* EmitLoadRegister: Unsupported double immediate\n* eval\n* Expected +0.0\n* Expected alignment marker\n* Expected allocation site\n* Expected function object in register\n* Expected HeapNumber\n* Expected native context\n* Expected new space object\n* Expected non-identical objects\n* Expected non-null context\n* Expected undefined or cell in register\n* Expecting alignment for CopyBytes\n* Export declaration\n* External string expected, but not found\n* ForInStatement optimization is disabled\n* ~~ForInStatement with non-local each variable~~\n* ForOfStatement\n* Frame is expected to be aligned\n* Function calls eval\n* Function is being debugged\n* Function with illegal redeclaration\n* Generated code is too large\n* Generator\n* Generator failed to resume\n* Global functions must have initial map\n* HeapNumberMap register clobbered\n* Import declaration\n* Index is negative\n* Index is too large\n* Inlined runtime function: FastOneByteArrayJoin\n* ~~Inlining bailed out~~\n* Input GPR is expected to have upper32 cleared\n* Input string too long\n* Integer32ToSmiField writing to non-smi location\n* Invalid capture referenced\n* Invalid ElementsKind for InternalArray or InternalPackedArray\n* invalid full-codegen state\n* Invalid HandleScope level\n* Invalid left-hand side in assignment\n* Invalid lhs in compound assignment\n* Invalid lhs in count operation\n* Invalid min_length\n* JSGlobalObject::native_context should be a native context\n* JSGlobalProxy::context() should not be null\n* JSObject with fast elements map has slow elements\n* Let binding re-initialization\n* Live Bytes Count overflow chunk size\n* LiveEdit\n* Lookup variable in count operation\n* Map became deprecated\n* Map became unstable\n* Native function literal\n* Need a Smi literal here\n* No cases left\n* No empty arrays here in EmitFastOneByteArrayJoin\n* Non-initializer assignment to const\n* Non-object value\n* Non-smi index\n* Non-smi key in array literal\n* Non-smi value\n* Not enough spill slots for OSR\n* Not enough virtual registers (regalloc)\n* Not enough virtual registers for values\n* Object found in smi-only array\n* ~~Object literal with complex property~~\n* Offset out of range\n* Operand is a smi\n* Operand is a smi and not a bound function\n* Operand is a smi and not a function\n* Operand is a smi and not a name\n* Operand is a smi and not a string\n* Operand is not a bound function\n* Operand is not a date\n* Operand is not a function\n* Operand is not a name\n* Operand is not a number\n* Operand is not a smi\n* Operand is not a string\n* Operand is not smi\n* Operand not a number\n* Optimization disabled by filter\n* Optimization is disabled\n* ~~Optimized too many times~~\n* Out of virtual registers while trying to allocate temp register\n* Parse/scope error\n* Possible direct call to eval\n* Received invalid return address\n* ~~Reference to a variable which requires dynamic lookup~~\n* Reference to global lexical variable\n* Reference to uninitialized variable\n* Register did not match expected root\n* Register was clobbered\n* Remembered set pointer is in new space\n* ~~Rest parameters~~\n* Return address not found in frame\n* Should not directly enter OSR-compiled function\n* Sloppy function expects JSReceiver as receiver.\n* ~~Smi addition overflow~~\n* ~~Smi subtraction overflow~~\n* Spread in array literal\n* Stack access below stack pointer\n* Stack frame types must match\n* Super reference\n* The current stack pointer is below csp\n* The function_data field should be a BytecodeArray on interpreter entry\n* The object is not tagged\n* The object is tagged\n* The source and destination are the same\n* The stack pointer is not the expected value\n* The stack was corrupted by MacroAssembler::Call()\n* ~~Too many parameters~~\n* Too many parameters/locals\n* Too many spill slots needed for OSR\n* ToOperand IsDoubleRegister unimplemented\n* ToOperand Unsupported double immediate\n* ToOperand32 unsupported immediate.\n* ~~TryCatchStatement~~\n* ~~TryFinallyStatement~~\n* Unaligned allocation in new space\n* Unaligned cell in write barrier\n* Unexpected allocation top\n* Unexpected color bit pattern found\n* Unexpected ElementsKind in array constructor\n* Unexpected fall-through from string comparison\n* Unexpected fallthrough from CharCodeAt slow case\n* Unexpected fallthrough from CharFromCode slow case\n* Unexpected fallthrough to CharCodeAt slow case\n* Unexpected fallthrough to CharFromCode slow case\n* Unexpected FPCR mode.\n* Unexpected FPU stack depth after instruction\n* Unexpected initial map for Array function\n* Unexpected initial map for Array function (1)\n* Unexpected initial map for Array function (2)\n* Unexpected initial map for InternalArray function\n* Unexpected level after return from api call\n* Unexpected negative value\n* Unexpected number of pre-allocated property fields\n* Unexpected smi value\n* Unexpected string type\n* Unexpected type for RegExp data, FixedArray expected\n* Unexpected value\n* Unexpectedly returned from a throw\n* ~~Unsupported const compound assignment~~\n* Unsupported count operation with const\n* Unsupported double immediate\n* Unsupported let compound assignment\n* Unsupported lookup slot in declaration\n* Unsupported non-primitive compare\n* ~~Unsupported phi use of arguments~~\n* ~~Unsupported phi use of const or let variable~~\n* Unsupported switch statement\n* Unsupported tagged immediate\n* Variable resolved to with context\n* We should not have an empty lexical context\n* WithStatement\n* Wrong address or value passed to RecordWrite\n* Wrong context passed to function\n* ~~Yield~~\n'