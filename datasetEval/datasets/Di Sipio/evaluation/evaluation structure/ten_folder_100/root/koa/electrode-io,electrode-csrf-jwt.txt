b'# Electrode Stateless CSRF\n\n[![NPM version][npm-image]][npm-url] [![Build Status][travis-image]][travis-url] [![Dependency Status][daviddm-image]][daviddm-url]\n\nAn electrode plugin that enables stateless [CSRF] protection using [JWT](https://github.com/auth0/node-jsonwebtoken) in Electrode, Express, Hapi, or Koa 2 applications.\n\n## Why do we need this module?\n\n[CSRF] protection is an important security feature, but in systems which don\'t have backend session persistence, validation is tricky. Stateless CSRF support addresses this need.\n\nPlease see the [demo](./demo) for a sample of using this in a web application with Hapi NodeJS server.\n\n## How do we validate requests?\n\nCSRF attacks can be bad when a malicious script can make a request that can perform harmful operations through the user (victim)\'s browser, attaching user specific and sensitive data in the cookies.\n\nTo prevent it, the technique used by this module is similar to the CSRF [double submit cookie prevention technique], and relies on these two restrictions by the browsers:\n\n1.  cross site scripts can\'t read/modify cookies.\n2.  cross site scripts can\'t set headers.\n\nThe [double submit cookie prevention technique] rely on the fact that a unique token in cookie must match a token attached in a hidden form submit field. Since XSS cannot change cookies, the check prevents CSRF attacks.\n\n> Note that the first restriction has some loopholes and thus the double submit cookie technique is not completely secured. See https://www.owasp.org/images/3/32/David_Johansson-Double_Defeat_of_Double-Submit_Cookie.pdf\n\n### Double JWT CSRF tokens\n\nFor use with [XMLHttpRequest] and [fetch], we extend the technique by using two JWT tokens for validation. One token in the cookies and the other in the HTTP headers. Since XSS cannot set HTTP headers also, it strengthens the security further.\n\nSo two JWT CSRF tokens are generated on the server side with the same payload but different types (see below), one for the HTTP header and one for the cookie. This makes two different tokens but uniquely paired with each other by the UUID.\n\n```js\nheaderPayload = { type: "header", UUID: "12345" };\ncookiePayload = { type: "cookie", UUID: "12345" };\n```\n\nWhen a client makes a request, the JWT tokens must be sent in the cookie and headers, both are channels that cross site scripts have no control over.\n\nFurther, we set the cookie to be [HTTP Only] so any browser that supports it would prevent **any** scripts from accessing it at all.\n\nOn the server side, the tokens are decoded and validated to pair with each other to identify legitimate requests.\n\nIf a malicious script somehow manages to alter one of the tokens passed through the cookie or HTTP header, then they will not match. In order to forge a request on the victim\'s behalf, both restrictions must be circumvented.\n\n### Issues\n\nThere are some issues with our technique.\n\n1.  We rely on client making all request through AJAX because of the requirement to set HTTP header.\n\n2.  First call has to be a GET to prime the header token. Since the code that use [XMLHttpRequest] or [fetch] need to first acquire valid tokens through a non-mutable request like HTTP GET to populate its internal state, so if your first call has to be POST, then it\'s tricky.\n\n3.  Similar to the cause in #2 above, multiple browser tabs could run into token mismatches, since cookies are shared across tabs but each tab\'s code keeps its own internal token for the HTTP header.\n\nIssue 1 is the essential of how the technique works so that\'s just its limitation.\n\nIssue 2 and 3 are tricky, but there are some solutions. See [demo](./demo/README.md) for reference.\n\n## Install\n\n```bash\n$ npm install --save electrode-csrf-jwt\n```\n\n# Usage and Integration\n\n## Browser Integration\n\nTo protect your AJAX requests from the browser, your JavaScript code need to first make a GET call to acquire an initial pair of CSRF tokens. The [HTTP only] cookie token is dropped automatically. Your code has to extract the header token and save it to an internal variable.\n\nIn subsequent requests (GET or POST), you have to attach the header token acquired in the HTTP header `x-csrf-jwt`.\n\nIf you receive an error, then you should take the token from the error response and retry one more time.\n\n### Full Demo\n\nYou can reference a sample [demo](./demo/README.md) to use this for your webapp.\n\n## Serverside Integration\n\nThis module includes a plugin for [Hapi] (v16 or lower) and middleware for [express] and [koa]. They can be used with the following:\n\n* [electrode-server](#electrode-server)\n* [Express](#express)\n* [Hapi](#hapi)\n* [Koa 2](#koa-2)\n\n### Options\n\nFirst the options. Regardless of which server framework you use, the options remains the same when you pass it to the plugin or middleware.\n\n#### Required Fields\n\n* `secret`: A string or buffer containing either the secret for HMAC algorithms, or the PEM encoded private key for RSA and ECDSA.\n\n#### Optional Fields\n\n* `cookieName`: A string to use as name for setting the cookie token. Default: `x-csrf-jwt`\n* `headerName`: A string to use as name for setting the header token. Default: **cookieName**\n* `cookieConfig`: An object with extra configs for setting the JWT cookie token. Values set to `undefined` or `null` will delete the field from the default cookie config. See the respective server framework for info on what their cookie config should be.\n  * `path`: Cookie path\n  * `isSecure`: Whether cookie is pass secure of not\n  * `httpOnly`: HTTP only.\n* `tokenEngine`: **Experimental** A string that specifies the token engine. Either the default [`"jwt"`](./lib/jwt-token-engine.js) or [`"hash"`](./lib/hash-token-engine.js).\n\n#### Optional `uuidGen` Field\n\nThis module by default uses the [uuid] module. However, it uses [crypto.randomBytes](https://nodejs.org/docs/latest-v8.x/api/crypto.html#crypto_crypto_randombytes_size_callback), which "uses libuv\'s threadpool, which can have surprising and negative performance implications for some applications".\n\nIf that\'s an issue, then you can set the `uuidGen` option as follows to select another UUID generator:\n\n* `"simple"` - select a [simple](./lib/simple-id-generator.js) one from this module\n* `"uuid"` - the default: uses [uuid]\n* **function** - your own function that returns the ID, which should be a URL safe string\n\n#### Optional Skip Callbacks\n\nThe following should be functions that take the `request` (or `context` for Koa) object and return `true` to skip their respective step for the given `request`:\n\n* `shouldSkip`: Completely skip the CSRF middleware/plugin\n* `skipCreate`: Skip creating the tokens for the response\n* `skipVerify`: Skip verifying the incoming tokens\n\n#### JWT specific optional fields\n\nOthers are optional and follow the [same usage as jsonwebtoken](https://github.com/auth0/node-jsonwebtoken/blob/master/README.md#usage) if the `tokenEngine` is `jwt`.\n\n* `algorithm`\n* `expiresIn`\n* `notBefore`\n* `audience`\n* `subject`\n* `issuer`\n* `jwtid`\n* `subject`\n* `noTimestamp`\n* `headers`\n\n\n### Electrode Server\n\n[electrode-server] is a top level wrapper for [Hapi]. You can use the hapi-plugin in [electrode-server] by setting your configuration.\n\n#### Example `config/default.js` configuration\n\n```js\n{\n  "plugins": {\n    "electrode-csrf-jwt": {\n      "options": {\n        "secret": "shhhhh",\n        "expiresIn": 60,\n        shouldSkip: request => {\n          // return true to skip CSRF JWT for given request\n          return false;\n        },\n        skipCreate: request => {\n          // return true to skip creating CSRF JWT Token for given request\n          return false;\n        },\n        skipVerify: request => {\n          // return true to skip verifying CSRF JWT Token for given request\n          return false;\n        }\n      }\n    }\n  }\n}\n```\n\n### Express\n\n#### Example `app.js` configuration\n\n```js\nconst csrfMiddleware = require("electrode-csrf-jwt").expressMiddleware;\nconst express = require("express");\n\nconst app = express();\n\nconst options = {\n  secret: "shhhhh",\n  expiresIn: 60,\n  shouldSkip: request => {\n    // return true to skip CSRF JWT for given request\n    return false;\n  },\n  skipCreate: request => {\n    // return true to skip creating CSRF JWT Token for given request\n    return false;\n  },\n  skipVerify: request => {\n    // return true to skip verifying CSRF JWT Token for given request\n    return false;\n  }\n};\n\napp.use(csrfMiddleware(options));\n```\n\n### Hapi\n\n#### Example `server/index.js` configuration\n\n```js\nconst csrfPlugin = require("electrode-csrf-jwt").register;\nconst Hapi = require("hapi");\n\nconst server = new Hapi.Server();\nconst options = {\n  secret: "shhhhh",\n  expiresIn: 60,\n  shouldSkip: request => {\n    // return true to skip CSRF JWT for given request\n    return false;\n  },\n  skipCreate: request => {\n    // return true to skip creating CSRF JWT Token for given request\n    return false;\n  },\n  skipVerify: request => {\n    // return true to skip verifying CSRF JWT Token for given request\n    return false;\n  }\n};\n\nserver.register({ register: csrfPlugin, options }, err => {\n  if (err) {\n    throw err;\n  }\n});\n```\n\n### Koa 2\n\n#### Example `app.js` configuration\n\n```js\nconst csrfMiddleware = require("electrode-csrf-jwt").koaMiddleware;\nconst Koa = require("koa");\n\nconst app = new Koa();\n\nconst options = {\n  secret: "shhhhh",\n  expiresIn: 60,\n  shouldSkip: context => {\n    // return true to skip CSRF JWT for given context\n    return false;\n  },\n  skipCreate: context => {\n    // return true to skip creating CSRF JWT Token for given context\n    return false;\n  },\n  skipVerify: context => {\n    // return true to skip verifying CSRF JWT Token for given context\n    return false;\n  }\n};\n\napp.use(csrfMiddleware(options));\n```\n\n### HTTPS and cookies\n\nWhen running in HTTPS, you will need to specify the cookie with `secure=true`.  Use the `cookieConfig` option\n```js\n{\n   "cookieConfig": {\n     "isSecure": true\n   }\n}\n```\n\n### Client-side fetch\n\nWhen doing client-side fetch to the server, it is preferable to use [electrode-fetch](https://gecgithub01.walmart.com/electrode/electrode-fetch).  \nElectrode-fetch will look for the `x-csrf-jwt` header from responses and use it as the new JWT token on subsequent fetches.  \nIf you use your own fetch function, you will have to handle this yourself.\n\n\n\n\nBuilt with :heart: by [Team Electrode](https://github.com/orgs/electrode-io/people) @WalmartLabs.\n\n[npm-image]: https://badge.fury.io/js/electrode-csrf-jwt.svg\n[npm-url]: https://npmjs.org/package/electrode-csrf-jwt\n[travis-image]: https://travis-ci.org/electrode-io/electrode-csrf-jwt.svg?branch=master\n[travis-url]: https://travis-ci.org/electrode-io/electrode-csrf-jwt\n[daviddm-image]: https://david-dm.org/electrode-io/electrode-csrf-jwt.svg?theme=shields.io\n[daviddm-url]: https://david-dm.org/electrode-io/electrode-csrf-jwt\n[uuid]: https://www.npmjs.com/package/uuid\n[double submit cookie prevention technique]: https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Double_Submit_Cookie\n[xmlhttprequest]: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n[csrf]: https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet\n[hapi]: https://www.npmjs.com/package/hapi\n[express]: https://www.npmjs.com/package/express\n[koa]: https://www.npmjs.com/package/koa\n[electrode-server]: https://www.npmjs.com/package/electrode-server\n[http only]: https://www.owasp.org/index.php/HttpOnly\n'