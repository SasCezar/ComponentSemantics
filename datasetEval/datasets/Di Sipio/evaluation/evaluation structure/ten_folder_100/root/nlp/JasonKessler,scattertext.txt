b'[![Build Status](https://travis-ci.org/JasonKessler/scattertext.svg?branch=master)](https://travis-ci.org/JasonKessler/scattertext)\n[![PyPI](https://img.shields.io/pypi/v/scattertext.svg)]()\n[![Conda Install](https://anaconda.org/ioam/holoviews/badges/installer/conda.svg)](https://anaconda.org/conda-forge/scattertext)\n[![Gitter Chat](https://img.shields.io/badge/GITTER-join%20chat-green.svg)](https://gitter.im/scattertext/Lobby)\n[![Twitter Follow](https://img.shields.io/twitter/follow/espadrine.svg?style=social&label=Follow)](https://twitter.com/jasonkessler)\n\n# Scattertext 0.0.2.55\n\n**Table of Contents**\n\n- [Installation](#installation)\n- [Citation](#citation)\n- [Overview](#overview)\n- [Tutorial](#tutorial)\n    - [Help! I don\'t know Python but I still want to use Scattertext](#help-i-dont-know-python-but-i-still-want-to-use-scattertext)\n    - [Using Scattertext as a text analysis library: finding characteristic terms and their associations](#using-scattertext-as-a-text-analysis-library-finding-characteristic-terms-and-their-associations)\n    - [Visualizing term associations](#visualizing-term-associations)\n    - [Visualizing Empath topics and categories](#visualizing-empath-topics-and-categories)\n    - [Ordering Terms by Corpus Characteristicness](#ordering-terms-by-corpus-characteristicness)\n    - [Document-Based Scatterplots](#document-based-scatterplots) \n    - [Using Cohen\'s d or Hedge\'s r to visualize effect size](#using-cohens-d-or-hedges-r-to-visualize-effect-size)\n- [Understanding Scaled F-Score](#understanding-scaled-f-score)\n- [Alternative term scoring methods](#alternative-term-scoring-methods)\n- [Advanced Uses](#advanced-uses)\n    - [Visualizing differences based on only term frequencies](#visualizing-differences-based-on-only-term-frequencies)\n    - [Visualizing query-based categorical differences](#visualizing-query-based-categorical-differences)\n    - [Visualizing any kind of term score](#visualizing-any-kind-of-term-score)\n    - [Custom term positions](#custom-term-positions)\n    - [Emoji analysis](#emoji-analysis)\n    - [Visualizing scikit-learn text classification weights](#visualizing-scikit-learn-text-classification-weights)\n    - [Creating lexicalized semiotic squares](#creating-lexicalized-semiotic-squares)\n    - [Visualizing topic models](#visualizing-topic-models)\n    - [Creating T-SNE-style word embedding projection plots](#creating-T-SNE-style-word-embedding-projection-plots)\n    - [Using SVD to visualize any kind of word embeddings](#using-svd-to-visualize-any-kind-of-word-embeddings)\n- [Examples](#examples)\n- [A note on chart layout](#a-note-on-chart-layout)\n- [What\'s new](#whats-new)\n- [Sources](#sources)\n\nA tool for finding distinguishing terms in small-to-medium-sized\ncorpora, and presenting them in a sexy, interactive scatter plot with \nnon-overlapping term labels.  Exploratory data analysis just \ngot more fun.\n\nFeel free to use the Gitter community [gitter.im/scattertext](https://gitter.im/scattertext/Lobby) for help or to discuss the project.   \n\n[![Conventions-Visualization.html](https://jasonkessler.github.io/2012conventions0.0.2.2.png)](https://jasonkessler.github.io/Conventions-Visualization.html)\n\n## Citation\nJason S. Kessler. Scattertext: a Browser-Based Tool for Visualizing how Corpora Differ. ACL System Demonstrations. 2017.\n\nLink to preprint: [arxiv.org/abs/1703.00565](https://arxiv.org/abs/1703.00565)\n\n## Installation \nInstall Python 3.4 or higher and run:\n\n`$ pip install scattertext`\n\nIf you cannot (or don\'t want to) install spaCy, substitute `nlp = spacy.en.English()` lines with\n`nlp = scattertext.WhitespaceNLP.whitespace_nlp`.  Note, this is not compatible \nwith `word_similarity_explorer`, and the tokenization and sentence boundary detection \ncapabilities will be low-performance regular expressions. See `demo_without_spacy.py`\nfor an example. \n\nIt is recommended you install `jieba`, `spacy`, `empath`, `astropy`, `gensim` and `umap-learn` in order to \ntake full advantage of Scattertext. \n\nScattertext should mostly work with Python 2.7.   \n\nThe HTML outputs look best in Chrome and Safari.\n\n```\n@article{kessler2017scattertext,\n  author    = {Kessler, Jason S.},\n  title     = {Scattertext: a Browser-Based Tool for Visualizing how Corpora Differ},\n  booktitle = {Proceedings of ACL-2017 System Demonstrations},\n  year      = {2017},\n  address   = {Vancouver, Canada},\n  publisher = {Association for Computational Linguistics},\n}\n```\n\n\n## What\'s new\nIn 0.0.2.44:\n* Added the following classes to support rank-based feature-selection: `AssociationCompactorByRank`, \n`TermCategoryRanker`.\n\nIn 0.0.2.43:\n* Made the term pop-up box on the category pairplot only the category name \n* Fixed optimal projection search function \n* Merged PR from @millengustavo to fix when a FutureWarning is issued every time the get_background_frequency_df \nis called.\n\nIn 0.0.2.42:\n* Fixed clickablity of terms, coloring in certain plots\n* Added initial number of terms to show in pairplot, using the `terms_to_show` parameter\n\nIn 0.0.2.41:\n* Enabled changing protocol in pair plot\n* Fixed semiotic square creator\n* Added `use_categories_as_metadata_and_replace_terms` to `TermDocMatrix`.\n* Added `get_metadata_doc_count_df` and `get_metadata_count_mat` to TermDocMatrix\n\nIn 0.0.2.40:\n* Added categories to terms in  pair plot halo, made them clickable \n\nIn 0.0.2.39:\n* Fixing failing test case\n* Adding halo to pair plot\n\nIn 0.0.2.38:\n* Fixed term preview/clickability in semiotic square plots \n* Fixed search box\n* Added preliminary `produce_pairplot`\n\nIn 0.0.2.37:\n* Javascript changes to support multiple plots on a single page.\n* Added `ScatterChart.hide_terms(terms: iter[str])` which enables selected terms to be hidden from the chart.  \n* Added `ScatterChartData.score_transform` to specify the function which can change an original score into a value \nbetween 0 and 1 used for term coloring. \n\nIn 0.0.2.36:\n* Added `alternative_term_func` to `produce_scattertext_explorer` which allows you to inject a function that activates\nwhen a term is clicked.\n* Fixed Cohen\'s d calculation, and added `HedgesR`, and unbiased version of Cohen\'s d which is a subclass of `CohensD`. \n* Added the `frequency_transform` parameter to `produce_frequency_explorer`.  This defaults to a log transform, but \nallows you to use any way your heart desires to order terms along the x-axis. \n\nIn 0.0.2.35:\n* Added `show_category_headings=True` to `produce_scattertext_explorer`. Setting this to False suppresses the list of categories\nwhich will be displayed in the term context area. \n* Added `div_name` argument to `produce_scattertext_explorer` and name-spaced important divs and classes by `div_name`\nin HTML templates and Javascript. \n* Added `show_cross_axes=True` to `produce_scattertext_explorer`. Setting this to `False` prevents the cross axes \nfrom being displayed if `show_axes` is `True`.\n* Changed default scorer to RankDifference.\n* Made sure that term contexts were properly shown in all configurations.\n\nIn 0.0.2.34:\n* `TermDocMatrix.get_metadata_freq_df` now accepts the `label_append` argument which by default adds `\' freq\'` to the\nend of each column.\n* `TermDocMatrix.get_num_cateogires` returns the number of categories in a term-document matrix.\n\nIn 0.0.2.33:\nAdded the following methods:\n* `TermDocMatrixWithoutCategories.get_num_metadata`\n* `TermDocMatrix.use_metadata_as_categories`\n* `unified_context` argument in `produce_scattertext_explorer` lists all contexts in a single column. This let\'s\nyou see snippets organized by multiple categories in a single column.  See `demo_unified_context.py` for an example.  \nhelps category-free or multi-category analyses.  \n\nIn 0.0.2.32 we added a series of objects to handle uncategorized corpora. Added section on \n [Document-Based Scatterplots](#document-based-scatterplots), and the add_doc_names_as_metadata function.\n`CategoryColorAssigner` was also added to assign colors to a qualitative categories. \n\n## Style Guide\nThe name of this project is Scattertext.  "Scattertext" is written as a single word\nand should be capitalized.  When used in Python, the package `scattertext` should be defined\nto the name `st`, i.e., `import scattertext as st`.\n\n## Overview\n \nThis is a tool that\'s intended for visualizing what words and phrases\n are more characteristic of a category than others.  \n \nConsider the example at the top of the page.\n\nLooking at this seem overwhelming.  In fact, it\'s a relatively simple visualization of word use \nduring the 2012 political convention.  Each dot corresponds to a word or phrase mentioned by Republicans or Democrats\nduring their conventions.  The closer a dot is to the top of the plot, the more frequently it was used by \nDemocrats.  The further right a  dot, the more that word or phrase was used by Republicans.  Words frequently\nused by both parties, like "of" and "the" and even "Mitt" tend to occur in the upper-right-hand corner. Although very low \nfrequency words have been hidden to preserve computing resources, a word that neither party used, like "giraffe" \n would be in the bottom-left-hand corner.  \n \nThe interesting things happen close to the upper-left and lower-right corners.  In the upper-left corner, \nwords like "auto" (as in auto bailout) and "millionaires" are frequently used by Democrats but infrequently or never used \nby Republicans.  Likewise, terms frequently used by Republicans and infrequently by Democrats occupy the\n bottom-right corner.  These include "big government" and "olympics", referring to the Salt Lake City Olympics in which \n Gov. Romney was involved.\n \nTerms are colored by their association.  Those that are more associated with Democrats are blue, and those \nmore associated with Republicans red.  \n\nTerms (only unigrams for now) that are most characteristic of the both sets of documents are displayed\n on the far-right of the visualization.\n   \nThe inspiration for this visualization came from Dataclysm (Rudder, 2014).\n  \nScattertext is designed to help you build these graphs and efficiently label points on them. \n\nThe documentation (including this readme) is a work in \nprogress.  Please see the tutorial below as well as the [PyData 2017 Tutorial](https://github.com/JasonKessler/Scattertext-PyData).\n\nPoking around the code and tests should give you a good idea of how things work. \n\nThe library covers some novel and effective term-importance formulas, including **Scaled F-Score**.\n\n## Tutorial\n\n### Help! I don\'t know Python but I still want to use Scattertext.\nWhile you should learn Python fully use Scattertext, I\'ve put some of the basic \nfunctionality in a commandline tool.  The tool is installed when you follow the procedure layed out\nabove.\n\nRun `$ scattertext --help` from the commandline to see the full usage information.  Here\'s a quick example of\nhow to use vanilla Scattertext on a CSV file.  The file needs to have at least two columns,\none containing the text to be analyzed, and another containing the category.  In the example CSV below,\nthe columns are text and party, respectively.\n\nThe example below processes the CSV file, and the resulting HTML visualization into cli_demo.html.\n\nNote, the parameter `--minimum_term_frequency=8` omit terms that occur less than 8 \ntimes, and `--regex_parser` indicates a simple regular expression parser should \n be used in place of spaCy. The flag `--one_use_per_doc` indicates that term frequency\n  should be calculated by only counting no more than one occurrence of a term in a document. \n  \nIf you\'d like to parse non-English text, you can use the `--spacy_language_model` argument to configure which\nspaCy language model the tool will use.  The default is \'en\' and you can see the others available at \n[https://spacy.io/docs/api/language-models](https://spacy.io/docs/api/language-models).\n\n```bash\n$ curl -s https://cdn.rawgit.com/JasonKessler/scattertext/master/scattertext/data/political_data.csv | head -2\nparty,speaker,text\ndemocrat,BARACK OBAMA,"Thank you. Thank you. Thank you. Thank you so much.Thank you.Thank you so much. Thank you. Thank you very much, everybody. Thank you.\n$\n$ scattertext --datafile=https://cdn.rawgit.com/JasonKessler/scattertext/master/scattertext/data/political_data.csv \\\n> --text_column=text --category_column=party --metadata_column=speaker --positive_category=democrat \\\n> --category_display_name=Democratic --not_category_display_name=Republican --minimum_term_frequency=8 \\\n> --one_use_per_doc --regex_parser --outputfile=cli_demo.html\n```\n\n\n### Using Scattertext as a text analysis library: finding characteristic terms and their associations\n\nThe following code creates a stand-alone HTML file that analyzes words \nused by Democrats and Republicans in the 2012 party conventions, and outputs some notable\n term associations.\n \nFirst, import Scattertext and spaCy.\n\n```pydocstring\n>>> import scattertext as st\n>>> import spacy\n>>> from pprint import pprint\n```\n\nNext, assemble the data you want to analyze into a Pandas data frame. It should have\nat least two columns, the text you\'d like to analyze, and the category you\'d like to \nstudy. Here, the `text` column contains convention speeches while the `party` column\n contains the party of the speaker.  We\'ll eventually use the `speaker` column\n to label snippets in the visualization.\n\n```pydocstring\n>>> convention_df = st.SampleCorpora.ConventionData2012.get_data()  \n>>> convention_df.iloc[0]\nparty                                               democrat\nspeaker                                         BARACK OBAMA\ntext       Thank you. Thank you. Thank you. Thank you so ...\nName: 0, dtype: object\n```\n\nTurn the data frame into a Scattertext Corpus to begin analyzing it.  To look for differences \nin parties, set the `category_col` parameter to `\'party\'`, and use the speeches, \npresent in the `text` column, as the texts to analyze by setting the `text` col \nparameter.  Finally, pass a spaCy model in to the `nlp` argument and call `build()` to construct the corpus.\n \n```pydocstring\n# Turn it into a Scattertext Corpus \n>>> nlp = spacy.load(\'en\')\n>>> corpus = st.CorpusFromPandas(convention_df, \n...                              category_col=\'party\', \n...                              text_col=\'text\',\n...                              nlp=nlp).build()\n```\n\nLet\'s see characteristic terms in the corpus, and terms that are most associated Democrats and \nRepublicans.  See slides \n[52](http://www.slideshare.net/JasonKessler/turning-unstructured-content-into-kernels-of-ideas/52) to [59](http://www.slideshare.net/JasonKessler/turning-unstructured-content-into-kernels-of-ideas/59) of the [Turning Unstructured Content ot Kernels of Ideas](http://www.slideshare.net/JasonKessler/turning-unstructured-content-into-kernels-of-ideas/) talk for more details on these approaches. \n\nHere are the terms that differentiate the corpus from a general English corpus. \n```pydocstring\n>>> print(list(corpus.get_scaled_f_scores_vs_background().index[:10]))\n[\'obama\',\n \'romney\',\n \'barack\',\n \'mitt\',\n \'obamacare\',\n \'biden\',\n \'romneys\',\n \'hardworking\',\n \'bailouts\',\n \'autoworkers\']\n```\n\nHere are the terms that are most associated with Democrats: \n\n```pydocstring\n>>> term_freq_df = corpus.get_term_freq_df()\n>>> term_freq_df[\'Democratic Score\'] = corpus.get_scaled_f_scores(\'democrat\')\n>>> pprint(list(term_freq_df.sort_values(by=\'Democratic Score\', ascending=False).index[:10]))\n[\'auto\',\n \'america forward\',\n \'auto industry\',\n \'insurance companies\',\n \'pell\',\n \'last week\',\n \'pell grants\',\n "women \'s",\n \'platform\',\n \'millionaires\']\n```\n\nAnd Republicans:\n```pydocstring\n>>> term_freq_df[\'Republican Score\'] = corpus.get_scaled_f_scores(\'republican\')\n>>> pprint(list(term_freq_df.sort_values(by=\'Republican Score\', ascending=False).index[:10]))\n[\'big government\',\n "n\'t build",\n \'mitt was\',\n \'the constitution\',\n \'he wanted\',\n \'hands that\',\n \'of mitt\',\n \'16 trillion\',\n \'turned around\',\n \'in florida\']\n```\n\n### Visualizing term associations\n\nNow, let\'s write the scatter plot a stand-alone HTML file.  We\'ll make the y-axis category  "democrat", and name\nthe category "Democrat" with a capital "D" for presentation \npurposes.  We\'ll name the other category "Republican" with a capital "R".  All documents in the corpus without \nthe category "democrat" will be considered Republican. We set the width of the visualization in pixels, and label \neach excerpt with the speaker using the `metadata` parameter.  Finally, we write the visualization to an HTML file.\n \n```pydocstring\n>>> html = st.produce_scattertext_explorer(corpus,\n...          category=\'democrat\',\n...          category_name=\'Democratic\',\n...          not_category_name=\'Republican\',\n...          width_in_pixels=1000,\n...          metadata=convention_df[\'speaker\'])\n>>> open("Convention-Visualization.html", \'wb\').write(html.encode(\'utf-8\'))\n```\nBelow is what the webpage looks like.  Click it and wait a few minutes for the interactive version.\n[![Conventions-Visualization.html](https://jasonkessler.github.io/2012conventions0.0.2.2.png)](https://jasonkessler.github.io/Conventions-Visualization.html)\n\n### Visualizing Empath topics and categories\n\nIn order to visualize Empath (Fast 2016) topics and categories instead of terms, we\'ll need to \ncreate a `Corpus` of extracted topics and categories rather than unigrams and \nbigrams. To do so, use the `FeatsOnlyFromEmpath` feature extractor.  See the source code for \nexamples of how to make your own.\n\nWhen creating the visualization, pass the `use_non_text_features=True` argument into\n `produce_scattertext_explorer`.  This will instruct it to use the labeled Empath \n topics and categories instead of looking for terms.  Since the documents returned\n when a topic or category label is clicked will be in order of the document-level\n category-association strength, setting `use_full_doc=True` makes sense, unless you have\n enormous documents.  Otherwise, the first 300 characters will be shown.\n \n(New in 0.0.26). Ensure you include `topic_model_term_lists=feat_builder.get_top_model_term_lists()`\nin `produce_scattertext_explorer` to ensure it bolds passages of snippets that match the \ntopic model.\n \n```pydocstring\n>>> feat_builder = st.FeatsFromOnlyEmpath()\n>>> empath_corpus = st.CorpusFromParsedDocuments(convention_df,\n...                                              category_col=\'party\',\n...                                              feats_from_spacy_doc=feat_builder,\n...                                              parsed_col=\'text\').build()\n>>> html = st.produce_scattertext_explorer(empath_corpus,\n...                                        category=\'democrat\',\n...                                        category_name=\'Democratic\',\n...                                        not_category_name=\'Republican\',\n...                                        width_in_pixels=1000,\n...                                        metadata=convention_df[\'speaker\'],\n...                                        use_non_text_features=True,\n...                                        use_full_doc=True,\n...                                        topic_model_term_lists=feat_builder.get_top_model_term_lists())\n>>> open("Convention-Visualization-Empath.html", \'wb\').write(html.encode(\'utf-8\'))\n``` \n\n[![Convention-Visualization-Empath.html](https://jasonkessler.github.io/Convention-Visualization-Empath.png)](https://jasonkessler.github.io/Convention-Visualization-Empath.html)\n\n### Visualizing General Inquirer Tag Categories and Document Categories\n\nScattertext also includes a feature builder to explore the relationship between General Inquirer Tag Categoires \nand Document Categories. We\'ll use a slightly different approach, looking at relationship of GI Tag Categories to political parties by using the\nZ-Scores of the Log-Odds-Ratio with Uninformative Dirichlet Priors (Monroe 2008). We\'ll use the `produce_frequency_explorer` plot \nvariation to visualize this relationship, setting the x-axis as the number of times a word in the tag category occurs, \nand the y-axis as the z-score.  \n\nFor more information on the General Inquirer, please see the [General Inquirer Home Page](http://www.wjh.harvard.edu/~inquirer/).\n\nWe\'ll use the same data set as before, except we\'ll use the `FeatsFromGeneralInquirer` feature builder.\n\n```pydocstring\n>>> general_inquirer_feature_builder = st.FeatsFromGeneralInquirer()\n>>> corpus = st.CorpusFromPandas(convention_df,\n...                              category_col=\'party\',\n...                              text_col=\'text\',\n...                              nlp=st.whitespace_nlp_with_sentences,\n...                              feats_from_spacy_doc=general_inquirer_feature_builder).build()\n```\n\nNext, we\'ll call `produce_frequency_explorer` in a similar way we called `produce_scattertext_explorer` in the previous section.\nThere are a few differences, however. First, we specify the `LogOddsRatioUninformativeDirichletPrior` term scorer, which\nscores the relationships between the categories.  The `grey_threshold` indicates the points scoring between [-1.96, 1.96]\n(i.e., p > 0.05) should be colored gray. The argument `metadata_descriptions=general_inquirer_feature_builder.get_definitions()`\nindicates that a dictionary mapping the tag name to a string definition is passed. When a tag is clicked, the definition\nin the dictionary will be shown below the plot, as shown in the image following the snippet. \n```pydocstring\n>>> html = st.produce_frequency_explorer(corpus,\n...                                      category=\'democrat\',\n...                                      category_name=\'Democratic\',\n...                                      not_category_name=\'Republican\',\n...                                      metadata=convention_df[\'speaker\'],\n...                                      use_non_text_features=True,\n...                                      use_full_doc=True,\n...                                      term_scorer=st.LogOddsRatioUninformativeDirichletPrior(),\n...                                      grey_threshold=1.96,\n...                                      width_in_pixels=1000,\n...                                      topic_model_term_lists=general_inquirer_feature_builder.get_top_model_term_lists(),\n...                                      metadata_descriptions=general_inquirer_feature_builder.get_definitions())\n```\nHere\'s the resulting chart.  \n[![demo_general_inquirer_frequency_plot.html](https://jasonkessler.github.io/general_inquirer.png)](https://jasonkessler.github.io/demo_general_inquirer_frequency_plot.html)\n   \n[![demo_general_inquirer_frequency_plot.html](https://jasonkessler.github.io/general_inquirer2.png)](https://jasonkessler.github.io/demo_general_inquirer_frequency_plot.html)\n\n\n### Ordering Terms by Corpus Characteristicness\nOften the terms of most interest are ones that are characteristic to the corpus as a whole.  These are terms which occur \nfrequently in all sets of documents being studied, but relatively infrequent compared to general term frequencies.\n\nWe can produce a plot with a characteristic score on the x-axis and class-association scores on the y-axis using the \nfunction `produce_characteristic_explorer`.  \n\nCorpus characteristicness is the difference in dense term ranks between the words in all of the documents in the study \nand a general English-language frequency list.  See this [Talk on Term-Class Association Scores](http://nbviewer.jupyter.org/github/JasonKessler/PuPPyTalk/blob/master/notebooks/Class-Association-Scores.ipynb)\nfor a more thorough explanation. \n\n```python\nimport scattertext as st\n\ncorpus = (st.CorpusFromPandas(st.SampleCorpora.ConventionData2012.get_data(),\n                              category_col=\'party\',\n                              text_col=\'text\',\n                              nlp=st.whitespace_nlp_with_sentences)\n          .build()\n          .get_unigram_corpus()\n          .compact(st.ClassPercentageCompactor(term_count=2,\n                                               term_ranker=st.OncePerDocFrequencyRanker)))\nhtml = st.produce_characteristic_explorer(\n\tcorpus,\n\tcategory=\'democrat\',\n\tcategory_name=\'Democratic\',\n\tnot_category_name=\'Republican\',\n\tmetadata=corpus.get_df()[\'speaker\']\n)\nopen(\'demo_characteristic_chart.html\', \'wb\').write(html.encode(\'utf-8\'))\n```\n\n[![demo_characteristic_chart.html](https://jasonkessler.github.io/demo_characteristic_chart.png)](https://jasonkessler.github.io/demo_characteristic_chart.html)\n\n### Document-Based Scatterplots\n\nIn addition to words, phases and topics, we can make each point correspond to a document.  Let\'s first create\na corpus object for the 2012 Conventions data set.  This explanation follows `demo_pca_documents.py`\n\n```python\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfTransformer\nimport scattertext as st\nfrom scipy.sparse.linalg import svds\n\nconvention_df = st.SampleCorpora.ConventionData2012.get_data()\nconvention_df[\'parse\'] = convention_df[\'text\'].apply(st.whitespace_nlp_with_sentences)\ncorpus = (st.CorpusFromParsedDocuments(convention_df,\n                                       category_col=\'party\',\n                                       parsed_col=\'parse\')\n          .build()\n          .get_stoplisted_unigram_corpus())\n```\n\nNext, let\'s add the document names as meta data in the corpus object. The `add_doc_names_as_metadata` function\ntakes an array of document names, and populates a new corpus\' meta data with those names. If two documents have the\nsame name, it appends a number (starting with 1) to the name.   \n\n```python\ncorpus = corpus.add_doc_names_as_metadata(corpus.get_df()[\'speaker\'])\n```\n\nNext, we find tf.idf scores for the corpus\' term-document matrix, run sparse SVD, and add them to a projection \ndata frame, making the x and y-axes the first two singular values, and indexing it on the corpus\' meta data, which\ncorresponds to the document names. \n\n```python\nembeddings = TfidfTransformer().fit_transform(corpus.get_term_doc_mat())\nu, s, vt = svds(embeddings, k=3, maxiter=20000, which=\'LM\')\nprojection = pd.DataFrame({\'term\': corpus.get_metadata(), \'x\': u.T[0], \'y\': u.T[1]}).set_index(\'term\')\n```\n\nFinally, set scores as 1 for Democrats and 0 for Republicans, rendering Republican documents as red points and\nDemocratic documents as blue.  For more on the `produce_pca_explorer` function, \nsee [Using SVD to visualize any kind of word embeddings](#using-svd-to-visualize-any-kind-of-word-embeddings).\n\n```python\ncategory = \'democrat\'\nscores = (corpus.get_category_ids() == corpus.get_categories().index(category)).astype(int)\nhtml = st.produce_pca_explorer(corpus,\n                               category=category,\n                               category_name=\'Democratic\',\n                               not_category_name=\'Republican\',\n                               metadata=convention_df[\'speaker\'],\n                               width_in_pixels=1000,\n                               show_axes=False,\n                               use_non_text_features=True,\n                               use_full_doc=True,\n                               projection=projection,\n                               scores=scores,\n                               show_top_terms=False)\n```\nClick for an interactive version\n[![demo_pca_documents.html](https://jasonkessler.github.io/doc_pca.png)](https://jasonkessler.github.io/demo_pca_documents.html)\n\n### Using Cohen\'s d or Hedge\'s r to visualize effect size.\n\nCohen\'s d is a popular metric used to measure effect size.  The definitions of Cohen\'s d and Hedge\'s r \nfrom (Shinichi and Cuthill 2017) are implemented in Scattertext. \n\n```python\n>>> convention_df = st.SampleCorpora.ConventionData2012.get_data()\n>>> corpus = (st.CorpusFromPandas(convention_df,\n...                               category_col=\'party\',\n...                               text_col=\'text\',\n...                               nlp=st.whitespace_nlp_with_sentences)\n...           .build()\n...           .get_unigram_corpus())\n```\nWe can create a term scorer object to examine the effect sizes and other metrics. \n```python\n>>> term_scorer = st.CohensD(corpus).set_categories(\'democrat\', [\'republican\'])\n>>> term_scorer.get_score_df().sort_values(by=\'cohens_d\', ascending=False).head()\n           cohens_d  cohens_d_se  cohens_d_z     cohens_d_p  hedges_r  hedges_r_se  hedges_r_z  hedges_r_p        m1        m2\nobama      1.187378     0.024588   48.290444   0.000000e+00  1.187322     0.018419   64.461363         0.0  0.007778  0.002795\nclass      0.855859     0.020848   41.052045   0.000000e+00  0.855818     0.017227   49.677688         0.0  0.002222  0.000375\nmiddle     0.826895     0.020553   40.232746   0.000000e+00  0.826857     0.017138   48.245626         0.0  0.002316  0.000400\npresident  0.820825     0.020492   40.056541   0.000000e+00  0.820786     0.017120   47.942661         0.0  0.010231  0.005369\nbarack     0.730624     0.019616   37.245725  6.213052e-304  0.730589     0.016862   43.327800         0.0  0.002547  0.000725\n```\nOur calculation of Cohen\'s d is not directly based on term counts. Rather, we divide each document\'s term counts by the total number\nof terms in the document before calculating the statistics.  `m1` and `m2` are, respectively the mean portions of words\nin speeches made by Democrats and Republicans that were the term in question.  The effect size (`cohens_d`) is the \ndifference between these means divided by the pooled standard standard deviation.  `cohens_d_se` is the standard error\nof the statistic, while `cohens_d_z` and `cohens_d_p` are the Z-scores and p-values indicating the statistical\n significance of the effect.  Corresponding columns are present for Hedge\'s r, and unbiased version of Cohen\'s d.\n \n```python\n>>> st.produce_frequency_explorer(\n    corpus,\n    category=\'democrat\',\n    category_name=\'Democratic\',\n    not_category_name=\'Republican\',\n    term_scorer=st.CohensD(corpus),\n    metadata=convention_df[\'speaker\'],\n    grey_threshold=0\n)\n```  \nClick for an interactive version. \n[![demo_cohens_d.html](https://jasonkessler.github.io/cohen_d.png)](https://jasonkessler.github.io/demo_cohens_d.html)\n \n\n### Understanding Scaled F-Score\n\nLet\'s now turn our attention to a novel term scoring metric, Scaled F-Score.  We\'ll examine this on a unigram \nversion of the Rotten Tomatoes corpus (Pang et al. 2002). It contains excerpts of \npositive and negative movie reviews. \n\nPlease see [Scaled F Score Explanation](http://nbviewer.jupyter.org/github/JasonKessler/GlobalAI2018/blob/master/notebook/Scaled-F-Score-Explanation.ipynb) \nfor a notebook version of this analysis. \n\n\n![Scaled F-Score Explanation 1](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/scaledfscoreimgs/sfs1.png)\n\n```python\nfrom scipy.stats import hmean \n\nterm_freq_df = corpus.get_unigram_corpus().get_term_freq_df()[[\'Positive freq\', \'Negative freq\']]\nterm_freq_df = term_freq_df[term_freq_df.sum(axis=1) > 0]\n\nterm_freq_df[\'pos_precision\'] = (term_freq_df[\'Positive freq\'] * 1./\n                                 (term_freq_df[\'Positive freq\'] + term_freq_df[\'Negative freq\']))\n\nterm_freq_df[\'pos_freq_pct\'] = (term_freq_df[\'Positive freq\'] * 1.\n                                /term_freq_df[\'Positive freq\'].sum())\n\nterm_freq_df[\'pos_hmean\'] = (term_freq_df\n                             .apply(lambda x: (hmean([x[\'pos_precision\'], x[\'pos_freq_pct\']])\n                                               if x[\'pos_precision\'] > 0 and x[\'pos_freq_pct\'] > 0 \n                                               else 0), axis=1))\nterm_freq_df.sort_values(by=\'pos_hmean\', ascending=False).iloc[:10]\n```\n![SFS2](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/scaledfscoreimgs/sfs2.png)\n\nIf we plot term frequency on the x-axis and the percentage of a term\'s occurrences \nwhich are in positive documents (i.e., its precision) on the y-axis, we can see \nthat low-frequency terms have a much higher variation in the precision. Given these terms have \nlow frequencies, the harmonic means are low.  Thus, the only terms which have a high harmonic mean \nare extremely frequent words which tend to all have near average precisions.\n\n\n```python\nfreq = term_freq_df.pos_freq_pct.values\nprec = term_freq_df.pos_precision.values\nhtml = st.produce_scattertext_explorer(\n    corpus.remove_terms(set(corpus.get_terms()) - set(term_freq_df.index)),\n    category=\'Positive\',\n    not_category_name=\'Negative\',\n    not_categories=[\'Negative\'],\n    \n    x_label = \'Portion of words used in positive reviews\',\n    original_x = freq,\n    x_coords = (freq - freq.min())/freq.max(),\n    x_axis_values = [int(freq.min()*1000)/1000., \n                     int(freq.max() * 1000)/1000.],\n    \n    y_label = \'Portion of documents containing word that are positive\',    \n    original_y = prec,\n    y_coords = (prec - prec.min())/prec.max(),\n    y_axis_values = [int(prec.min() * 1000)/1000., \n                     int((prec.max()/2.)*1000)/1000., \n                     int(prec.max() * 1000)/1000.],\n    scores = term_freq_df.pos_hmean.values,\n    \n    sort_by_dist=False,\n    show_characteristic=False\n)\nfile_name = \'not_normed_freq_prec.html\'\nopen(file_name, \'wb\').write(html.encode(\'utf-8\'))\nIFrame(src=file_name, width = 1300, height=700)\n```\n\n![SFS3](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/scaledfscoreimgs/sfs3.png)\n\n![SFS4](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/scaledfscoreimgs/sfs4.png)\n\n```python\nfrom scipy.stats import norm\n\ndef normcdf(x):\n    return norm.cdf(x, x.mean(), x.std ())\n\nterm_freq_df[\'pos_precision_normcdf\'] = normcdf(term_freq_df.pos_precision)\n\nterm_freq_df[\'pos_freq_pct_normcdf\'] = normcdf(term_freq_df.pos_freq_pct.values)\n\nterm_freq_df[\'pos_scaled_f_score\'] = hmean([term_freq_df[\'pos_precision_normcdf\'], term_freq_df[\'pos_freq_pct_normcdf\']])\n\nterm_freq_df.sort_values(by=\'pos_scaled_f_score\', ascending=False).iloc[:10]\n```\n\n![SFS5](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/scaledfscoreimgs/sfs5.png)\n\n```python\nfreq = term_freq_df.pos_freq_pct_normcdf.values\nprec = term_freq_df.pos_precision_normcdf.values\nhtml = st.produce_scattertext_explorer(\n    corpus.remove_terms(set(corpus.get_terms()) - set(term_freq_df.index)),\n    category=\'Positive\',\n    not_category_name=\'Negative\',\n    not_categories=[\'Negative\'],\n    \n    x_label = \'Portion of words used in positive reviews (norm-cdf)\',\n    original_x = freq,\n    x_coords = (freq - freq.min())/freq.max(),\n    x_axis_values = [int(freq.min()*1000)/1000., \n                     int(freq.max() * 1000)/1000.],\n    \n    y_label = \'documents containing word that are positive (norm-cdf)\',    \n    original_y = prec,\n    y_coords = (prec - prec.min())/prec.max(),\n    y_axis_values = [int(prec.min() * 1000)/1000., \n                     int((prec.max()/2.)*1000)/1000., \n                     int(prec.max() * 1000)/1000.],\n    scores = term_freq_df.pos_scaled_f_score.values,\n    \n    sort_by_dist=False,\n    show_characteristic=False\n)\n```\n![SFS6](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/scaledfscoreimgs/sfs6.png)\n\n![SFS7](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/scaledfscoreimgs/sfs7.png)\n```python\nterm_freq_df[\'neg_precision_normcdf\'] = normcdf((term_freq_df[\'Negative freq\'] * 1./\n                                 (term_freq_df[\'Negative freq\'] + term_freq_df[\'Positive freq\'])))\n\nterm_freq_df[\'neg_freq_pct_normcdf\'] = normcdf((term_freq_df[\'Negative freq\'] * 1.\n                                /term_freq_df[\'Negative freq\'].sum()))\n\nterm_freq_df[\'neg_scaled_f_score\'] = hmean([term_freq_df[\'neg_precision_normcdf\'],  term_freq_df[\'neg_freq_pct_normcdf\']])\n\nterm_freq_df[\'scaled_f_score\'] = 0\nterm_freq_df.loc[term_freq_df[\'pos_scaled_f_score\'] > term_freq_df[\'neg_scaled_f_score\'], \n                 \'scaled_f_score\'] = term_freq_df[\'pos_scaled_f_score\']\nterm_freq_df.loc[term_freq_df[\'pos_scaled_f_score\'] < term_freq_df[\'neg_scaled_f_score\'], \n                 \'scaled_f_score\'] = 1-term_freq_df[\'neg_scaled_f_score\']\nterm_freq_df[\'scaled_f_score\'] = 2 * (term_freq_df[\'scaled_f_score\'] - 0.5)\nterm_freq_df.sort_values(by=\'scaled_f_score\', ascending=True).iloc[:10]\n```\n![SFS8](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/scaledfscoreimgs/sfs8.png)\n```python\nis_pos = term_freq_df.pos_scaled_f_score > term_freq_df.neg_scaled_f_score\nfreq = term_freq_df.pos_freq_pct_normcdf*is_pos - term_freq_df.neg_freq_pct_normcdf*~is_pos\nprec = term_freq_df.pos_precision_normcdf*is_pos - term_freq_df.neg_precision_normcdf*~is_pos\ndef scale(ar): \n    return (ar - ar.min())/(ar.max() - ar.min())\ndef close_gap(ar): \n    ar[ar > 0] -= ar[ar > 0].min()\n    ar[ar < 0] -= ar[ar < 0].max()\n    return ar\n\nhtml = st.produce_scattertext_explorer(\n    corpus.remove_terms(set(corpus.get_terms()) - set(term_freq_df.index)),\n    category=\'Positive\',\n    not_category_name=\'Negative\',\n    not_categories=[\'Negative\'],\n    \n    x_label = \'Frequency\',\n    original_x = freq,\n    x_coords = scale(close_gap(freq)),\n    x_axis_labels = [\'Frequent in Neg\', \n                     \'Not Frequent\', \n                     \'Frequent in Pos\'],\n    \n    y_label = \'Precision\',    \n    original_y = prec,\n    y_coords = scale(close_gap(prec)),\n    y_axis_labels = [\'Neg Precise\', \n                     \'Imprecise\', \n                     \'Pos Precise\'],\n    \n    \n    scores = (term_freq_df.scaled_f_score.values + 1)/2,\n    sort_by_dist=False,\n    show_characteristic=False\n)\n```\n![SFS9](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/scaledfscoreimgs/sfs9.png)\n\nWe can use `st.ScaledFScorePresets` as a term scorer to display terms\' Scaled F-Score on the y-axis and \nterm frequencies on the x-axis.  \n\n```python\nhtml = st.produce_frequency_explorer(\n    corpus.remove_terms(set(corpus.get_terms()) - set(term_freq_df.index)),\n    category=\'Positive\',\n    not_category_name=\'Negative\',\n    not_categories=[\'Negative\'],\n    term_scorer=st.ScaledFScorePresets(beta=1, one_to_neg_one=True),\n    metadata = rdf[\'movie_name\'],\n    grey_threshold=0\n)\n```\n![SFS10](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/scaledfscoreimgs/sfs10.png)\n\n\n### Alternative term scoring methods\n\nScaled F-Score is not the only scoring method included in Scattertext.  Please click on one of the links below to \nview a notebook which describes how other class association scores work and can be visualized through Scattertext. \n\n* [Google Colab Notebook](https://colab.research.google.com/drive/1snxAP8X6EIDi42FugJ_h5U-fBGDCqtyS) (recommend).\n* [Jupyter Notebook via NBViewer](https://colab.research.google.com/drive/1snxAP8X6EIDi42FugJ_h5U-fBGDCqtyS).\n\n## Advanced uses\n\n### Visualizing differences based on only term frequencies\nOccasionally, only term frequency statistics are available. This may happen in the case of very large, \nlost, or proprietary data sets. `TermCategoryFrequencies` is a corpus representation,that can accept this \nsort of data, along with any categorized documents that happen to be available.\n\nLet use the [Corpus of Contemporary American English](https://corpus.byu.edu/coca/) as an example.  \nWe\'ll construct a visualization\nto analyze the difference between spoken American English and English that occurs in fiction.\n\n```python\ndf = (pd.read_excel(\'https://www.wordfrequency.info/files/genres_sample.xls\')\n\t      .dropna()\n\t      .set_index(\'lemma\')[[\'SPOKEN\', \'FICTION\']]\n\t      .iloc[:1000])\ndf.head()\t      \n\'\'\'\n       SPOKEN    FICTION\nlemma\nthe    3859682.0  4092394.0\nI      1346545.0  1382716.0\nthey   609735.0   352405.0\nshe    212920.0   798208.0\nwould  233766.0   229865.0\n\'\'\'\n```\n\nTransforming this into a visualization is extremely easy. Just pass a dataframe indexed on \nterms with columns indicating category-counts into the the `TermCategoryFrequencies` constructor.\n\n```python\nterm_cat_freq = st.TermCategoryFrequencies(df)\n``` \n\nAnd call `produce_scattertext_explorer` normally:\n\n```python\nhtml = st.produce_scattertext_explorer(\n\tterm_cat_freq,\n\tcategory=\'SPOKEN\',\n\tcategory_name=\'Spoken\',\n\tnot_category_name=\'Fiction\',\n)\n```\n\n\n[![demo_category_frequencies.html](https://jasonkessler.github.io/demo_category_frequencies.png)](https://jasonkessler.github.io/demo_category_frequencies.html)\n\nIf you\'d like to incorporate some documents into the visualization, you can add them into to the\n`TermCategoyFrequencies` object.\n\nFirst, let\'s extract some example Fiction and Spoken documents from the sample COCA corpus.\n\n```python\nimport requests, zipfile, io\ncoca_sample_url = \'http://corpus.byu.edu/cocatext/samples/text.zip\'\nzip_file = zipfile.ZipFile(io.BytesIO(requests.get(coca_sample_url).content))\n\ndocument_df = pd.DataFrame(\n\t[{\'text\': zip_file.open(fn).read().decode(\'utf-8\'),\n\t  \'category\': \'SPOKEN\'}\n\t for fn in zip_file.filelist if fn.filename.startswith(\'w_spok\')][:2]\n\t+ [{\'text\': zip_file.open(fn).read().decode(\'utf-8\'),\n\t    \'category\': \'FICTION\'}\n\t   for fn in zip_file.filelist if fn.filename.startswith(\'w_fic\')][:2])\n```   \n\nAnd we\'ll pass the `documents_df` dataframe into `TermCategoryFrequencies` via the `document_category_df` \nparameter.  Ensure the dataframe has two columns, \'text\' and \'category\'.  Afterward, we can\ncall `produce_scattertext_explorer` (or your visualization function of choice) normally.\n\n```python\ndoc_term_cat_freq = st.TermCategoryFrequencies(df, document_category_df=document_df)\n\nhtml = st.produce_scattertext_explorer(\n\tdoc_term_cat_freq,\n\tcategory=\'SPOKEN\',\n\tcategory_name=\'Spoken\',\n\tnot_category_name=\'Fiction\',\n)\n```\n\n### Visualizing query-based categorical differences  \nWord representations have recently become a hot topic in NLP.  While lots of work has been done visualizing \nhow terms relate to one another given their scores \n(e.g., [http://projector.tensorflow.org/](http://projector.tensorflow.org/)),\nnone to my knowledge has been done visualizing how we can use these to examine how \ndocument categories differ. \n\nIn this example given a query term, "jobs", we can see how Republicans and \nDemocrats talk about it differently.\n\nIn this configuration of Scattertext, words are colored by their similarity to a query phrase.  \nThis is done using [spaCy](https://spacy.io/)-provided GloVe word vectors (trained on \nthe Common Crawl corpus). The cosine distance between vectors is used, \nwith mean vectors used for phrases.\n\nThe calculation of the most similar terms associated with each category is a simple heuristic.  First, \nsets of terms closely associated with a category are found. Second, these terms are ranked \nbased on their similarity to the query, and the top rank terms are displayed to the right of the \nscatterplot.  \n\nA term is considered associated if its p-value is less than 0.05.  P-values are \ndetermined using Monroe et al. (2008)\'s difference in the weighted log-odds-ratios with an \nuninformative Dirichlet prior.  This is the only model-based method discussed in Monroe et al. \nthat does not rely on a large, in-domain background corpus. Since we are scoring \nbigrams in addition to the unigrams scored by Monroe, the size of the corpus would have to be larger \nto have high enough bigram counts for proper penalization. This function \nrelies the Dirichlet distribution\'s parameter alpha, a vector, which is uniformly set to 0.01.\n\nHere is the code  to produce such a visualization. \n \n```pydocstring\n>>> from scattertext import word_similarity_explorer\n>>> html = word_similarity_explorer(corpus,\n...                                 category=\'democrat\',\n...                                 category_name=\'Democratic\',\n...                                 not_category_name=\'Republican\',\n...                                 target_term=\'jobs\',\n...                                 minimum_term_frequency=5,\n...                                 pmi_threshold_coefficient=4,\n...                                 width_in_pixels=1000,\n...                                 metadata=convention_df[\'speaker\'],\n...                                 alpha=0.01,\n...                                 max_p_val=0.05,\n...                                 save_svg_button=True)\n>>> open("Convention-Visualization-Jobs.html", \'wb\').write(html.encode(\'utf-8\'))\n``` \n[![Convention-Visualization-Jobs.html](https://jasonkessler.github.io/Convention-Visualization-Jobs.png)](https://jasonkessler.github.io/Convention-Visualization-Jobs.html)\n\n\n#### Developing and using bespoke word representations \n\nScattertext can interface with Gensim Word2Vec models.  For example, here\'s a snippet from `demo_gensim_similarity.py`\nwhich illustrates how to train and use a word2vec model on a corpus.  Note the similarities produced \nreflect quirks of the corpus, e.g., "8" tends to refer to the 8% unemployment rate at the time of the\nconvention.\n\n```python\nimport spacy\nfrom gensim.models import word2vec\nfrom scattertext import SampleCorpora, word_similarity_explorer_gensim, Word2VecFromParsedCorpus\nfrom scattertext.CorpusFromParsedDocuments import CorpusFromParsedDocuments\nnlp = spacy.en.English()\nconvention_df = SampleCorpora.ConventionData2012.get_data()\nconvention_df[\'parsed\'] = convention_df.text.apply(nlp)\ncorpus = CorpusFromParsedDocuments(convention_df, category_col=\'party\', parsed_col=\'parsed\').build()\nmodel = word2vec.Word2Vec(size=300,\n                          alpha=0.025,\n                          window=5,\n                          min_count=5,\n                          max_vocab_size=None,\n                          sample=0,\n                          seed=1,\n                          workers=1,\n                          min_alpha=0.0001,\n                          sg=1,\n                          hs=1,\n                          negative=0,\n                          cbow_mean=0,\n                          iter=1,\n                          null_word=0,\n                          trim_rule=None,\n                          sorted_vocab=1)\nhtml = word_similarity_explorer_gensim(corpus,\n                                       category=\'democrat\',\n                                       category_name=\'Democratic\',\n                                       not_category_name=\'Republican\',\n                                       target_term=\'jobs\',\n                                       minimum_term_frequency=5,\n                                       pmi_threshold_coefficient=4,\n                                       width_in_pixels=1000,\n                                       metadata=convention_df[\'speaker\'],\n                                       word2vec=Word2VecFromParsedCorpus(corpus, model).train(),\n                                       max_p_val=0.05,\n                                       save_svg_button=True)\nopen(\'./demo_gensim_similarity.html\', \'wb\').write(html.encode(\'utf-8\'))\n```\nHow Democrats and Republicans talked differently about "jobs" in their 2012 convention speeches. \n[![Convention-Visualization-Jobs.html](https://jasonkessler.github.io/demo_gensim_similarity.png)](https://jasonkessler.github.io/demo_gensim_similarity.html)\n\n\n### Visualizing any kind of term score\n\nWe can use Scattertext to visualize alternative types of word scores, and ensure that 0 scores are greyed out.  Use the `sparse_explroer` function to acomplish this, and see its source code for more details.     \n\n```pydocstring\n>>> from sklearn.linear_model import Lasso\n>>> from scattertext import sparse_explorer\n>>> html = sparse_explorer(corpus,\n...                        category=\'democrat\',\n...                        category_name=\'Democratic\',\n...                        not_category_name=\'Republican\',\n...                        scores = corpus.get_regression_coefs(\'democrat\', Lasso(max_iter=10000)),\n...                        minimum_term_frequency=5,\n...                        pmi_threshold_coefficient=4,\n...                        width_in_pixels=1000,\n...                        metadata=convention_df[\'speaker\'])\n>>> open(\'./Convention-Visualization-Sparse.html\', \'wb\').write(html.encode(\'utf-8\'))\n```\n\n[![Convention-Visualization-Sparse.html](https://jasonkessler.github.io/Convention-Visualization-Sparse.png)](https://jasonkessler.github.io/Convention-Visualization-Sparse.html)\n\n### Custom term positions\n\nYou can also use custom term positions and axis labels.  For example, you can base terms\' y-axis \npositions on a regression coefficient and their x-axis on term frequency and label the axes\n accordingly.  The one catch is that axis positions must be scaled between 0 and 1.\n\nFirst, let\'s define two scaling functions: `scale` to project positive values to \\[0,1\\], and \n`zero_centered_scale` project real values to \\[0,1\\], with negative values always \\<0.5, and\npositive values always \\>0.5.\n\n```pydocstring\n>>> def scale(ar):\n...     return (ar - ar.min()) / (ar.max() - ar.min())\n...\n>>> def zero_centered_scale(ar):\n...     ar[ar > 0] = scale(ar[ar > 0])\n...     ar[ar < 0] = -scale(-ar[ar < 0])\n...     return (ar + 1) / 2.\n```\n\nNext, let\'s compute and scale term frequencies and L2-penalized regression coefficients. We\'ll\nhang on to the original coefficients and allow users to view them by mousing over terms.  \n\n```pydocstring\n>>> from sklearn.linear_model import LogisticRegression\n>>> import numpy as np\n>>>\n>>> frequencies_scaled = scale(np.log(term_freq_df.sum(axis=1).values))\n>>> scores = corpus.get_logreg_coefs(\'democrat\',\n...                                  LogisticRegression(penalty=\'l2\', C=10, max_iter=10000, n_jobs=-1))\n>>> scores_scaled = zero_centered_scale(scores)\n```\n\nFinally, we can write the visualization. Note the use of the `x_coords` and `y_coords` \nparameters to store the respective coordinates, the `scores` and `sort_by_dist` arguments\n to register the original coefficients and use them to rank the terms in the right-hand\n list, and the `x_label` and `y_label` arguments to label axes.\n \n```pydocstring\n>>> html = produce_scattertext_explorer(corpus,\n...                                     category=\'democrat\',\n...                                     category_name=\'Democratic\',\n...                                     not_category_name=\'Republican\',\n...                                     minimum_term_frequency=5,\n...                                     pmi_threshold_coefficient=4,\n...                                     width_in_pixels=1000,\n...                                     x_coords=frequencies_scaled,\n...                                     y_coords=scores_scaled,\n...                                     scores=scores,\n...                                     sort_by_dist=False,\n...                                     metadata=convention_df[\'speaker\'],\n...                                     x_label=\'Log frequency\',\n...                                     y_label=\'L2-penalized logistic regression coef\')\n>>> open(\'demo_custom_coordinates.html\', \'wb\').write(html.encode(\'utf-8\'))\n```\n[![demo_custom_coordinates.html](https://jasonkessler.github.io/demo_custom_coordinates.png)](https://jasonkessler.github.io/demo_custom_coordinates.html)\n\n\n### Emoji analysis\nThe Emoji analysis capability displays a chart of the category-specific distribution\nof Emoji. Let\'s look at a new corpus, a set of tweets.  We\'ll build a visualization\nshowing how men and women use emoji differently.\n\nNote: the following example is implemented in `demo_emoji.py`.\n\nFirst, we\'ll load the dataset and parse it using NLTK\'s tweet tokenizer.  Note, install NLTK\nbefore running this example.  It will take some time for the dataset to download.\n```python\nimport nltk, urllib.request, io, agefromname, zipfile\nimport scattertext as st\nimport pandas as pd\n\n\nwith zipfile.ZipFile(io.BytesIO(urllib.request.urlopen(\n    \'http://followthehashtag.com/content/uploads/USA-Geolocated-tweets-free-dataset-Followthehashtag.zip\'\n).read())) as zf:\n    df = pd.read_excel(zf.open(\'dashboard_x_usa_x_filter_nativeretweets.xlsx\'))\n\nnlp = st.tweet_tokenzier_factory(nltk.tokenize.TweetTokenizer())\ndf[\'parse\'] = df[\'Tweet content\'].apply(nlp)\n\ndf.iloc[0]\n\'\'\'\nTweet Id                                                     721318437075685382\nDate                                                                 2016-04-16\nHour                                                                      12:44\nUser Name                                                        Bill Schulhoff\nNickname                                                          BillSchulhoff\nBio                           Husband,Dad,GrandDad,Ordained Minister, Umpire...\nTweet content                 Wind 3.2 mph NNE. Barometer 30.20 in, Rising s...\nFavs                                                                        NaN\nRTs                                                                         NaN\nLatitude                                                                40.7603\nLongitude                                                              -72.9547\nCountry                                                                      US\nPlace (as appears on Bio)                                    East Patchogue, NY\nProfile picture               http://pbs.twimg.com/profile_images/3788000007...\nFollowers                                                                   386\nFollowing                                                                   705\nListed                                                                       24\nTweet language (ISO 639-1)                                                   en\nTweet Url                     http://www.twitter.com/BillSchulhoff/status/72...\nparse                         Wind 3.2 mph NNE. Barometer 30.20 in, Rising s...\nName: 0, dtype: object\n\'\'\'\n```\n\nNext, we\'ll use the [AgeFromName](https://github.com/JasonKessler/agefromname) package to find the probabilities of the gender of \neach user given their first name.  First, we\'ll find a dataframe indexed on first names \nthat contains the probability that each someone with that first name is male (`male_prob`).\n \n```python\nmale_prob = agefromname.AgeFromName().get_all_name_male_prob()\nmale_prob.iloc[0]\n\'\'\'\nhi      1.00000\nlo      0.95741\nprob    1.00000\nName: aaban, dtype: float64\n\'\'\'\n```\n\nNext, we\'ll extract the first names of each user, and use the `male_prob` data frame \nto find users whose names indicate there is at least a 90% chance they are either male or female,\nlabel those users, and create new data frame `df_mf` with only those users.\n\n```python\ndf[\'first_name\'] = df[\'User Name\'].apply(lambda x: x.split()[0].lower() if type(x) == str and len(x.split()) > 0 else x)\ndf_aug = pd.merge(df, male_prob, left_on=\'first_name\', right_index=True)\ndf_aug[\'gender\'] = df_aug[\'prob\'].apply(lambda x: \'m\' if x > 0.9 else \'f\' if x < 0.1 else \'?\')\ndf_mf = df_aug[df_aug[\'gender\'].isin([\'m\', \'f\'])]\n```\n\nThe key to this analysis is to construct a corpus using only the emoji \nextractor `st.FeatsFromSpacyDocOnlyEmoji` which builds a corpus only from\n emoji and not from anything else.\n \n```python\ncorpus = st.CorpusFromParsedDocuments(\n\tdf_mf,\n\tparsed_col=\'parse\',\n\tcategory_col=\'gender\',\n\tfeats_from_spacy_doc=st.FeatsFromSpacyDocOnlyEmoji()\n).build()\n```\n\nNext, we\'ll run this through a standard `produce_scattertext_explorer` visualization\ngeneration.\n```python\nhtml = st.produce_scattertext_explorer(\n\tcorpus,\n\tcategory=\'f\',\n\tcategory_name=\'Female\',\n\tnot_category_name=\'Male\',\n\tuse_full_doc=True,\n\tterm_ranker=OncePerDocFrequencyRanker,\n\tsort_by_dist=False,\n\tmetadata=(df_mf[\'User Name\']\n\t          + \' (@\' + df_mf[\'Nickname\'] + \') \'\n\t          + df_mf[\'Date\'].astype(str)),\n\twidth_in_pixels=1000\n)\nopen("EmojiGender.html", \'wb\').write(html.encode(\'utf-8\'))\n```\n\n[![EmojiGender.html](https://jasonkessler.github.io/EmojiGender.png)](https://jasonkessler.github.io/EmojiGender.html)\n\n\n### Visualizing scikit-learn text classification weights\n\nSuppose you\'d like to audit or better understand \nweights or importances given to bag-of-words features \nby a classifier.\n \nIt\'s easy to use Scattertext to do, if you use a Scikit-learn-style classifier.\n\nFor example the [Lighting](http://contrib.scikit-learn.org/lightning/) package makes available\nhigh-performance linear classifiers which are have Scikit-compatible interfaces.\n\nFirst, let\'s import `sklearn`\'s text feature extraction classes, the 20 Newsgroup\ncorpus, Lightning\'s Primal Coordinate Descent classifier, and Scattertext. We\'ll also\nfetch the training portion of the Newsgroup corpus.\n\n```python\nfrom lightning.classification import CDClassifier\nfrom sklearn.datasets import fetch_20newsgroups\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer\n\nimport scattertext as st\n\nnewsgroups_train = fetch_20newsgroups(\n\tsubset=\'train\',\n\tremove=(\'headers\', \'footers\', \'quotes\')\n)\n```\n\nNext, we\'ll tokenize our corpus twice.  Once into tfidf features \nwhich will be used to train the classifier, an another time into\nngram counts that will be used by Scattertext.  It\'s important that\nboth vectorizers share the same vocabulary, since we\'ll need to apply the \nweight vector from the model onto our Scattertext Corpus.\n\n```python\nvectorizer = TfidfVectorizer()\ntfidf_X = vectorizer.fit_transform(newsgroups_train.data)\ncount_vectorizer = CountVectorizer(vocabulary=vectorizer.vocabulary_)\n```\n\nNext, we use the `CorpusFromScikit` factory to build a Scattertext Corpus object.\nEnsure the `X` parameter is a document-by-feature matrix. The argument to the \n`y` parameter is an array of class labels.  Each label is an integer representing\na different news group.  We the `feature_vocabulary` is the vocabulary used by the \nvectorizers.  The `category_names` are a list of the 20 newsgroup names which\nas a class-label list.  The `raw_texts` is a list of the text of newsgroup texts.\n  \n```python\ncorpus = st.CorpusFromScikit(\n\tX=count_vectorizer.fit_transform(newsgroups_train.data),\n\ty=newsgroups_train.target,\n\tfeature_vocabulary=vectorizer.vocabulary_,\n\tcategory_names=newsgroups_train.target_names,\n\traw_texts=newsgroups_train.data\n).build()\n```\n\nNow, we can train the model on `tfidf_X` and the categoricla response variable,\nand capture feature weights for category 0 ("alt.atheism").\n```python\nclf = CDClassifier(penalty="l1/l2",\n                   loss="squared_hinge",\n                   multiclass=True,\n                   max_iter=20,\n                   alpha=1e-4,\n                   C=1.0 / tfidf_X.shape[0],\n                   tol=1e-3)\nclf.fit(tfidf_X, newsgroups_train.target)\nterm_scores = clf.coef_[0]\n```\n\nFinally, we can create a Scattertext plot.  We\'ll use the Monroe-style visualization, and automatically\nselect around 4000 terms that encompass the set of frequent terms, terms with high absolute scores,\nand terms that are characteristic of the corpus.  \n\n```python\nhtml = st.produce_frequency_explorer(\n\tcorpus,\n\t\'alt.atheism\',\n\tscores=term_scores,\n\tuse_term_significance=False,\n\tterms_to_include=st.AutoTermSelector.get_selected_terms(corpus, term_scores, 4000),\n\tmetadata = [\'/\'.join(fn.split(\'/\')[-2:]) for fn in newsgroups_train.filenames]\n)\n```\n[![demo_sklearn.html](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/demo_sklearn.png)](https://jasonkessler.github.io/demo_sklearn.html)\n\n\nLet\'s take a look at the performance of the classifier:\n\n```python\nnewsgroups_test = fetch_20newsgroups(subset=\'test\',\n                                     remove=(\'headers\', \'footers\', \'quotes\'))\nX_test = vectorizer.transform(newsgroups_test.data)\npred = clf.predict(X_test)\nf1 = f1_score(pred, newsgroups_test.target, average=\'micro\')\nprint("Microaveraged F1 score", f1)\n```\nMicroaveraged F1 score 0.662108337759.  Not bad over a ~0.05 baseline.\n\n### Creating lexicalized semiotic squares\n\nPlease see [Signo](http://www.signosemio.com/greimas/semiotic-square.asp) for an \nintroduction to semiotic squares.\n\nSome variants of the semiotic square-creator are can be seen in this notebook, which studies\nwords and phrases in headlines that had low or high Facebook engagement and were published by\neither BuzzFeed or the New York Times: [http://nbviewer.jupyter.org/github/JasonKessler/PuPPyTalk/blob/master/notebooks/Explore-Headlines.ipynb]\n\nThe idea behind the semiotic square is to express the relationship between two opposing \nconcepts and concepts things within a larger domain of a discourse. \nExamples of opposed concepts life or death, male or female, or, in our example, positive or negative sentiment. \nSemiotics squares are comprised of four "corners": the upper two corners are the opposing concepts,\nwhile the bottom corners are the negation of the concepts.  \n\nCircumscribing the negation of a concept involves finding everything in the \ndomain of discourse that isn\'t associated with the concept.  For example, in the \nlife-death opposition, one can consider the universe of discourse to be all\nanimate beings, real and hypothetical. The not-alive category will cover dead things,\nbut also hypothetical entities like fictional characters or sentient AIs.\n\nIn building lexicalized semiotic squares, we consider concepts to be documents labeled\nin a corpus.  Documents, in this setting, can belong to one of three categories: two labels corresponding\nto the opposing concepts, a neutral category, indicating a document is in the same domain as\nthe opposition, but cannot fall into one of opposing categories. \n\nIn the example below positive and negative movie reviews are treated as the opposing categories,\nwhile plot descriptions of the same movies are treated as the neutral category.\n\nTerms associated with one of the two opposing categories (relative only to the other) are\nlisted as being associated with that category.  Terms associated with a netural category \n(e.g., not positive) are terms which are associated with the disjunction of the opposite \ncategory and the neutral category. For example, not-positive terms are those most associated \nwith the set of negative reviews and plot descriptions vs. positive reviews.\n\nCommon terms among adjacent corners of the square are also listed.\n\nAn HTML-rendered square is accompanied by a scatter plot.  Points on the plot are terms.\nThe x-axis is the Z-score of the association to one of the opposed concepts. The y-axis\nis the Z-score how associated a term is with the neutral set of documents relative to the\nopposed set.  A point\'s red-blue color indicate the term\'s opposed-association, while\nthe more desaturated a term is, the more it is associated with the neutral set of documents.       \n\n\n\n```python\nimport scattertext as st\nmovie_df = st.SampleCorpora.RottenTomatoes.get_data()\nmovie_df.category = movie_df.category.apply\\\n\t(lambda x: {\'rotten\': \'Negative\', \'fresh\': \'Positive\', \'plot\': \'Plot\'}[x])\ncorpus = st.CorpusFromPandas(\n\tmovie_df,\n\tcategory_col=\'category\',\n\ttext_col=\'text\',\n\tnlp=st.whitespace_nlp_with_sentences\n).build().get_unigram_corpus()\n\nsemiotic_square = st.SemioticSquare(\n\tcorpus,\n\tcategory_a=\'Positive\',\n\tcategory_b=\'Negative\',\n\tneutral_categories=[\'Plot\'],\n\tscorer=st.RankDifference(),\n\tlabels={\'not_a_and_not_b\': \'Plot Descriptions\', \'a_and_b\': \'Reviews\'}\n)\n\nhtml = st.produce_semiotic_square_explorer(semiotic_square,\n                                           category_name=\'Positive\',\n                                           not_category_name=\'Negative\',\n                                           x_label=\'Fresh-Rotten\',\n                                           y_label=\'Plot-Review\',\n                                           neutral_category_name=\'Plot Description\',\n                                           metadata=movie_df[\'movie_name\'])\n```\n\n[![semiotic square](https://jasonkessler.github.io/semiotic_square_plot.png)](https://jasonkessler.github.io/demo_semiotic.html)\n\nThere are a number of other types of semiotic square construction functions.  \n\n### Visualizing Topic Models\nA frequently requested feature of Scattertext has been the ability to visualize topic \nmodels. While this capability has existed in some forms (e.g., the Empath visualization),\nI\'ve finally gotten around to implementing a concise API for such a visualization. \nThere are three main ways to visualize topic models using Scattertext.\nThe first is the simplest: manually entering topic models and visualizing them.\nThe second uses a Scikit-Learn pipeline to produce the topic models for visualization.\nThe third is a novel topic modeling technique, based on finding terms similar to a\ncustom set of seed terms.  \n\n#### Manually entered topic models\n\nIf you have already created a topic model, simply structure it as a dictionary. \nThis dictionary is keyed on string which serve as topic titles and are displayed\nin the main scatterplot.  The values are lists of words that belong to that topic. The words\nthat are in each topic list are bolded when they appear in a snippet. \n\nNote that currently, there is no support for keyword scores.\n\nFor example, one might manually the following topic models to explore in the Convention\ncorpus: \n\n```python\ntopic_model = {\n  \'money\': [\'money\',\'bank\',\'banks\',\'finances\',\'financial\',\'loan\',\'dollars\',\'income\'],\n  \'jobs\':[\'jobs\',\'workers\',\'labor\',\'employment\',\'worker\',\'employee\',\'job\'],\n  \'patriotic\':[\'america\',\'country\',\'flag\',\'americans\',\'patriotism\',\'patriotic\'],\n  \'family\':[\'mother\',\'father\',\'mom\',\'dad\',\'sister\',\'brother\',\'grandfather\',\'grandmother\',\'son\',\'daughter\']\n}\n```\n\nWe can use the `FeatsFromTopicModel` class to transform this topic model into one which\ncan be visualized using Scattertext. This is used just like any other feature builder,\nand we pass the topic model object into `produce_scattertext_explorer`.\n\n```\nimport scattertext as st\n\ntopic_feature_builder = st.FeatsFromTopicModel(topic_model)\n\ntopic_corpus = st.CorpusFromParsedDocuments(\n\tconvention_df,\n\tcategory_col=\'party\',\n\tparsed_col=\'parse\',\n\tfeats_from_spacy_doc=topic_feature_builder\n).build()\n\nhtml = st.produce_scattertext_explorer(\n\ttopic_corpus,\n\tcategory=\'democrat\',\n\tcategory_name=\'Democratic\',\n\tnot_category_name=\'Republican\',\n\twidth_in_pixels=1000,\n\tmetadata=convention_df[\'speaker\'],\n\tuse_non_text_features=True,\n\tuse_full_doc=True,\n\tpmi_threshold_coefficient=0,\n\ttopic_model_term_lists=topic_feature_builder.get_top_model_term_lists()\n)\n```\n\n[![demo_custom_topic_model.html](https://raw.githubusercontent.com/JasonKessler/jasonkessler.github.io/master/demo_custom_topic_model.png)](https://jasonkessler.github.io/demo_custom_topic_model.html)\n\n#### Using Scikit-Learn for Topic Modeling\n\nSince topic modeling using document-level coocurence generally produces poor results,\nI\'ve added a `SentencesForTopicModeling` class which allows clusterting by coocurence\nat the sentence-level.  It requires a `ParsedCorpus` object to be passed to its constructor,\nand creates a term-sentence matrix internally.\n\nNext, you can create a topic model dictionary like the one above by passing in a Scikit-Learn\nclustering or dimensionality reduction pipeline. The only constraint is the last transformer\nin the pipeline must populate a `components_` attribute.\n\nThe `num_topics_per_term` attribute specifies how many terms should be added to a list.\n\nIn the following example, we\'ll use NMF to cluster a stoplisted, unigram corpus of documents,\nand use the topic model dictionary to create a `FeatsFromTopicModel`, just like before.\n\nNote that in `produce_scattertext_explorer`, we make the `topic_model_preview_size` 20 in order to show\na preview of the first 20 terms in the topic in the snippet view as opposed to the default 10. \n\n```python\nfrom sklearn.decomposition import NMF\nfrom sklearn.feature_extraction.text import TfidfTransformer\nfrom sklearn.pipeline import Pipeline\n\nconvention_df = st.SampleCorpora.ConventionData2012.get_data()\nconvention_df[\'parse\'] = convention_df[\'text\'].apply(st.whitespace_nlp_with_sentences)\n\nunigram_corpus = (st.CorpusFromParsedDocuments(convention_df,\n                                               category_col=\'party\',\n                                               parsed_col=\'parse\')\n                  .build().get_stoplisted_unigram_corpus())\ntopic_model = st.SentencesForTopicModeling(unigram_corpus).get_topics_from_model(\n\tPipeline([\n\t\t(\'tfidf\', TfidfTransformer(sublinear_tf=True)),\n\t\t(\'nmf\', (NMF(n_components=100, alpha=.1, l1_ratio=.5, random_state=0)))\n\t]),\n\tnum_terms_per_topic=20\n)\n  \ntopic_feature_builder = st.FeatsFromTopicModel(topic_model)\n\n\ntopic_corpus = st.CorpusFromParsedDocuments(\n\tconvention_df,\n\tcategory_col=\'party\',\n\tparsed_col=\'parse\',\n\tfeats_from_spacy_doc=topic_feature_builder\n).build()\n\nhtml = st.produce_scattertext_explorer(\n\ttopic_corpus,\n\tcategory=\'democrat\',\n\tcategory_name=\'Democratic\',\n\tnot_category_name=\'Republican\',\n\twidth_in_pixels=1000,\n\tmetadata=convention_df[\'speaker\'],\n\tuse_non_text_features=True,\n\tuse_full_doc=True,\n\tpmi_threshold_coefficient=0,\n\ttopic_model_term_lists=topic_feature_builder.get_top_model_term_lists(),\n\ttopic_model_preview_size=20\n)\n```\n[![demo_nmf_topic_model.html](https://jasonkessler.github.io/demo_nmf_topic_model.png)](https://jasonkessler.github.io/demo_nmf_topic_model.html)\n\n#### Using a Word List to Generate a Series of Topics\n\nA surprisingly easy way to generate good topic models is to use a term scoring formula\nto find words that are associated with sentences where a seed word occurs vs. where\none doesn\'t occur.  \n\nGiven a custom term list, the `SentencesForTopicModeling.get_topics_from_terms` will\ngenerate a series of topics.  Note that the dense rank difference (`RankDifference`) works \nparticularly well for this task, and is the default parameter.\n\n```python\nterm_list = [\'obama\', \'romney\', \'democrats\', \'republicans\', \'health\', \'military\', \'taxes\',\n \'education\', \'olympics\', \'auto\', \'iraq\', \'iran\', \'israel\']\n\nunigram_corpus = (st.CorpusFromParsedDocuments(convention_df,\n                                               category_col=\'party\',\n                                               parsed_col=\'parse\')\n                  .build().get_stoplisted_unigram_corpus())\n\ntopic_model = (st.SentencesForTopicModeling(unigram_corpus)\n               .get_topics_from_terms(term_list,\n                                      scorer=st.RankDifference(), \n                                      num_terms_per_topic=20))\n\ntopic_feature_builder = st.FeatsFromTopicModel(topic_model)\n# The remaining code is identical to two examples above. See demo_word_list_topic_model.py\n# for the complete example.\n```\n\n[![demo_word_list_topic_model.html](https://jasonkessler.github.io/demo_word_list_topic_model.png)](https://jasonkessler.github.io/demo_word_list_topic_model.html)\n\n\n\n### Creating T-SNE-style word embedding projection plots\n\nScattertext makes it easy to create word-similarity plots using projections of word embeddings as the x and y-axes. \nIn the example below, we create a stop-listed Corpus with only unigram terms.  The `produce_projection_explorer` function\nby uses Gensim to create word embeddings and then projects them to two dimentions using Uniform Manifold Approximation and Projection (UMAP).\n\nUMAP is chosen over T-SNE because it can employ the cosine similarity between two word vectors instead of just the euclidean distance.    \n\n```python\nconvention_df = st.SampleCorpora.ConventionData2012.get_data()\nconvention_df[\'parse\'] = convention_df[\'text\'].apply(st.whitespace_nlp_with_sentences)\n\ncorpus = (st.CorpusFromParsedDocuments(convention_df, category_col=\'party\', parsed_col=\'parse\')\n          .build().get_stoplisted_unigram_corpus())\n\nhtml = st.produce_projection_explorer(corpus, category=\'democrat\', category_name=\'Democratic\',\n  not_category_name=\'Republican\', metadata=convention_df.speaker)\n```\n\nIn order to use custom word embedding functions or projection functions, pass models into the `word2vec_model`\nand `projection_model` parameters.  In order to use T-SNE, for example, use \n`projection_model=sklearn.manifold.TSNE()`. \n\n```python\nimport umap\nfrom gensim.models.word2vec import Word2Vec\n\nhtml = st.produce_projection_explorer(corpus,\n                                      word2vec_model=Word2Vec(size=100, window=5, min_count=10, workers=4),\n                                      projection_model=umap.UMAP(min_dist=0.5, metric=\'cosine\'),\n                                      category=\'democrat\',\n                                      category_name=\'Democratic\',\n                                      not_category_name=\'Republican\',\n                                      metadata=convention_df.speaker)                                                                            \n```\n\n[![t-sne style plot](https://jasonkessler.github.io/demo_tsne_style.png)](https://jasonkessler.github.io/demo_tsne_style.html)\n\n### Using SVD to visualize any kind of word embeddings\n\nTerm positions can also be determined by the positions of terms according to the output of principal component analysis, \nand `produce_projection_explorer` also supports this functionality. We\'ll look at how axes transformations ("scalers" \nin Scattertext terminology) can make it easier to inspect the output of PCA. \n\nWe\'ll use the 2012 Conventions corpus for these visualizations.  Only unigrams occurring in at least three documents \nwill be considered. \n\n```pydocstring\n>>> convention_df = st.SampleCorpora.ConventionData2012.get_data()\n>>> convention_df[\'parse\'] = convention_df[\'text\'].apply(st.whitespace_nlp_with_sentences)\n>>> corpus = (st.CorpusFromParsedDocuments(convention_df,\n...                                        category_col=\'party\',\n...                                        parsed_col=\'parse\')\n...           .build()\n...           .get_stoplisted_unigram_corpus()\n...           .remove_infrequent_words(minimum_term_count=3, term_ranker=st.OncePerDocFrequencyRanker))\n```\n\nNext, we use scikit-learn\'s tf-idf transformer to find very simple, sparse embeddings for all of these words. Since, \nwe input a #docs x #terms matrix to the transformer, we can transpose it to get a proper term-embeddings matrix, where each row\ncorresponds to a term, and the columns correspond to document-specific tf-idf scores.      \n```pydocstring\n>>> from sklearn.feature_extraction.text import TfidfTransformer\n>>> embeddings = TfidfTransformer().fit_transform(corpus.get_term_doc_mat())\n>>> embeddings.shape\n(189, 2159)\n>>> corpus.get_num_docs(), corpus.get_num_terms()\n(189, 2159) \n>>> embeddings = embeddings.T\n>>> embeddings.shape\n(2159, 189)\n```\n\nGiven these spare embeddings, we can apply sparse singular value decomposition to extract three factors. SVD outputs \nfactorizes the term embeddings matrix into three matrices, U, \xce\xa3, and VT. Importantly, the matrix U provides the singular values \nfor each term, and VT provides them for each document, and \xce\xa3 is a vector of the singular values.   \n```pydocstring\n>>> from scipy.sparse.linalg import svds\n>>> U, S, VT = svds(embeddings, k = 3, maxiter=20000, which=\'LM\')\n>>> U.shape\n(2159, 3)\n>>> S.shape\n(3,)\n>>> VT.shape\n(3, 189)\n```\n\nWe\'ll look at the first two singular values, plotting each term such that the x-axis position is the first singular\nvalue, and the y-axis term is the second.  To do this, we make a "projection" data frame, where the `x` and `y` \ncolumns store the first two singular values, and key the data frame on each term.  This controls the term positions\non the chart. \n```pydocstring\n>>> x_dim = 0; y_dim = 1;\n>>> projection = pd.DataFrame({\'term\':corpus.get_terms(),\n...                            \'x\':U.T[x_dim],\n...                            \'y\':U.T[y_dim]}).set_index(\'term\')\n```\n\n\nWe\'ll use the `produce_pca_explorer` function to visualize these.  Note we include the projection object, and specify \nwhich singular values were used for x and y (`x_dim` and `y_dim`) so we they can be labeled in the interactive\nvisualization. \n\n```pydocstring\nhtml = st.produce_pca_explorer(corpus,\n                               category=\'democrat\',\n                               category_name=\'Democratic\',\n                               not_category_name=\'Republican\',\n                               projection=projection,\n                               metadata=convention_df[\'speaker\'],\n                               width_in_pixels=1000,\n                               x_dim=x_dim,\n                               y_dim=y_dim)\n```\n\nClick for an interactive visualization.  \n[![pca](https://jasonkessler.github.io/svd1.png)](https://jasonkessler.github.io/demo_embeddings_svd_0_1.html)\n\nWe can easily re-scale the plot in order to make more efficient use of space.  For example, passing in \n`scaler=scale_neg_1_to_1_with_zero_mean` will make all four quadrants take equal area.\n\n```pydocstring\nhtml = st.produce_pca_explorer(corpus,\n                               category=\'democrat\',\n                               category_name=\'Democratic\',\n                               not_category_name=\'Republican\',\n                               projection=projection,\n                               metadata=convention_df[\'speaker\'],\n                               width_in_pixels=1000,\n                               scaler=st.scale_neg_1_to_1_with_zero_mean,\n                               x_dim=x_dim,\n                               y_dim=y_dim)\n```\n\nClick for an interactive visualization.  \n[![pca](https://jasonkessler.github.io/svd2.png)](https://jasonkessler.github.io/demo_embeddings_svd_0_1_scale_neg_1_to_1_with_zero_mean.html)\n\n## Examples \n\nPlease see the examples in the [PyData 2017 Tutorial](https://github.com/JasonKessler/Scattertext-PyData) on Scattertext.\n\n## A note on chart layout\n\n[Cozy: The Collection Synthesizer](https://github.com/uwplse/cozy) (Loncaric 2016) was used to help determine \nwhich terms could be labeled without overlapping a circle or another label.  It automatically built a data structure to efficiently store and query the locations of each circle and labeled term.\n\nThe script to build `rectangle-holder.js` was\n```\nfields ax1 : long, ay1 : long, ax2 : long, ay2 : long\nassume ax1 < ax2 and ay1 < ay2\nquery findMatchingRectangles(bx1 : long, by1 : long, bx2 : long, by2 : long)\n    assume bx1 < bx2 and by1 < by2\n    ax1 < bx2 and ax2 > bx1 and ay1 < by2 and ay2 > by1\n```\n\nAnd it was called using\n```\n$ python2.7 src/main.py <script file name> --enable-volume-trees \\\n  --js-class RectangleHolder --enable-hamt --enable-arrays --js rectangle_holder.js\n```\n\n## What\'s new\n\n## 0.0.28-31\n\nA number of new term scoring approaches including `RelativeEntropy` (a direct implementation of Frankhauser et al. (2014)), and\n`ZScores` and implementation of the Z-Score model used in Frankhauser et al.\n\n`TermDocMatrix.get_metadata_freq_df()` returns a metadata-doc corpus.\n\n`CorpusBasedTermScorer.set_ranker` allows you to use a different term ranker when finding corpus-based scores.  This not only\nlets these scorers with metadata, but also allows you to integrate once-per-document counts.\n\nFixed `produce_projection_explorer` such that it can work with a predefined set of term embeddings.  This can allow, \nfor example, the easy exploration of one hot-encoded term embeddings in addition to \narbitrary lower-dimensional embeddings.  \n\nAdded `add_metadata` to `TermDocMatrix` in order to inject meta data after a TermDocMatrix object\nhas been created.  \n\nMade sure tooltip never started above the top of the web page.\n\n\n### 0.0.2.28\n\nAdded `DomainCompactor`.\n\n### 0.0.2.26-27.1\nFixed bug [#31](https://github.com/JasonKessler/scattertext/issues/31), enabling context to show when metadata value is\nclicked.\n\nEnabled display of terms in topic models in explorer, along with the the display of\ncustomized topic models.  Please see [Visualizing topic models](#visualizing-topic-models) for an\noverview of the additions.\n\nRemoved pkg_resources from Phrasemachine, corrected demo_phrase_machine.py\n\nNow compatible with Gensim 3.4.0.\n\nAdded characteristic explorer, `produce_characteristic_explorer`, to plot terms with their characteristic scores on\nthe x-axis and their class-association scores on the y-axis. See [Ordering Terms by Corpus Characteristicness](#ordering-terms-by-corpus-characteristicness) for more details.\n\n\n### 0.0.2.24-25\nAdded `TermCategoryFrequencies` in response to Issue 23.  Please see [Visualizing differences based on only term frequencies](#visualizing-differences-based-on-only-term-frequencies) \nfor more details. \n\nAdded `x_axis_labels` and `y_axis_labels` parameters to `produce_scattertext_explorer`. \nThese let you include evenly-spaced string axis labels on the chart, as opposed to just\n"Low", "Medium" and "High". These rely on d3\'s ticks function, which can behave \nunpredictable. Caveat usor.\n\n\n### 0.0.2.16-23.1\nSemiotic Squares now look better, and have customizable labels. \n\nIncorporated the [General Inquirer](http://www.wjh.harvard.edu/~inquirer/homecat.htm) \nlexicon. For non-commercial use only. The lexicon is downloaded from their homepage at the start of each \nuse. See `demo_general_inquierer.py`.\n\nIncorporated Phrasemachine from [AbeHandler](https://github.com/AbeHandler) (Handler et al. 2016). For the license, \nplease see `PhraseMachineLicense.txt`.  For an example, please see `demo_phrase_machine.py`.\n\nAdded `CompactTerms` for removing redundant and infrequent terms from term document matrices.\nThese occur if a word or phrase is always part of a larger phrase; the shorter phrase is \nconsidered redundant and removed from the corpus. See `demo_phrase_machine.py` for an example.   \n\nAdded `FourSquare`, a pattern that allows for the creation of a semiotic square with\nseparate categories for each corner.  Please see `demo_four_square.py` for an early example. \n\nFinally, added a way to easily perform T-SNE-style visualizations on a categorized corpus. This uses, by default,\nthe [umap-learn](https://github.com/lmcinnes/umap) package. Please see demo_tsne_style.py.\n  \nFixed to `ScaledFScorePresets(one_to_neg_one=True)`, added `UnigramsFromSpacyDoc`.\n\nNow, when using `CorpusFromPandas`, a `CorpusDF` object is returned, instead of a `Corpus` object. This new type of object \nkeeps a reference to the source data frame, and returns it via the `CorpusDF.get_df()` method.\n\nThe factory `CorpusFromFeatureDict` was added. It allows you to directly specify term counts and\nmetadata item counts within the dataframe.  Please see `test_corpusFromFeatureDict.py` for an example.\n\n\n### 0.0.2.15-16\nAdded a very semiotic square creator.\n\nThe idea to build a semiotic square that contrasts two categories in a Term Document Matrix\nwhile using other categories as neutral categories.   \n\nSee [Creating semiotic squares](#creating-semiotic-squares) for an overview on how to \nuse this functionality and semiotic squares.\n\nAdded a parameter to disable the display of the top-terms sidebar, e.g.,\n`produce_scattertext_explorer(..., show_top_terms=False, ...)`.\n\nAn interface to part of the subjectivity/sentiment dataset from \nBo Pang and Lillian Lee. ``A Sentimental Education: Sentiment Analysis Using Subjectivity Summarization \nBased on Minimum Cuts\'\'. ACL. 2004. See `SampleCorpora.RottenTomatoes`.\n\nFixed bug that caused tooltip placement to be off after scrolling.   \n\nMade `category_name` and `not_category_name` optional in `produce_scattertext_explorer` etc.\n\nCreated the ability to customize tooltips via the `get_tooltip_content` argument to\n `produce_scattertext_explorer` etc., control axes labels via `x_axis_values` \n and `y_axis_values`.  The `color_func` parameter is a Javascript function to control color of a point.  Function takes a parameter\n which is a dictionary entry produced by `ScatterChartExplorer.to_dict` and returns a string.\n\n\n### 0.0.2.14\nIntegration with Scikit-Learn\'s text-analysis pipeline led the creation of the\n`CorpusFromScikit` and `TermDocMatrixFromScikit` classes.\n\nThe `AutoTermSelector` class to automatically suggest terms to appear in the visualization.  \nThis can make it easier to show large data sets, and remove fiddling with the various \nminimum term frequency parameters. \n\nFor an example of how to use `CorpusFromScikit` and `AutoTermSelector`, please see `demo_sklearn.py`\n\nAlso, I updated the library and examples to be compatible with spaCy 2.\n\nFixed bug when processing single-word documents, and set the default beta to 2. \n\n\n### 0.0.2.11-13\nAdded `produce_frequency_explorer` function, and adding the PEP 369-compliant \n`__version__` attribute as mentioned in [#19](https://github.com/JasonKessler/scattertext/issues/19).\nFixed bug when creating visualizations with more than two possible categories.  Now, by default, \ncategory names will not be title-cased in the visualization, but will retain their original case.  \nIf you\'d still like to do this this, use `ScatterChart (or a descendant).to_dict(..., title_case_names=True)`.\nFixed `DocsAndLabelsFromCorpus` for Py 2 compatibility. \n\n\n### 0.0.2.10\nFixed bugs in `chinese_nlp` when jieba has already been imported and in p-value\ncomputation when performing log-odds-ratio w/ prior scoring.  \n\nAdded demo for performing a Monroe et. al (2008) style visualization of \nlog-odds-ratio scores in `demo_log_odds_ratio_prior.py`.   \n\n\n### 0.0.2.9.*\nBreaking change: `pmi_filter_thresold` has been replaced with `pmi_threshold_coefficient`.\n\nAdded Emoji and Tweet analysis. See [Emoji analysis](#emoji-analysis).\n\nCharacteristic terms falls back ot "Most frequent" if no terms used in the chart are present\nin the background corpus.\n \nFixed top-term calculation for custom scores.\n \nSet scaled f-score\'s default beta to 0.5.\n\nAdded `--spacy_language_model` argument to the CLI. \n\nAdded the `alternative_text_field` option in `produce_scattertext_explorer` to show an \nalternative text field when showing contexts in the interactive HTML visualization.   \n\nUpdated `ParsedCorpus.get_unigram_corpus` to allow for continued \n`alternative_text_field` functionality. \n\n\n### 0.0.2.8.6\nAdded ability to for Scattertext to use noun chunks instead of unigrams and bigrams through the\n`FeatsFromSpacyDocOnlyNounChunks` class. In order to use it, run your favorite `Corpus` or \n`TermDocMatrix` factory, and pass in an instance of the class as a parameter: \n```\nst.CorpusFromParsedDocuments(..., feats_from_spacy_doc=st.FeatsFromSpacyDocOnlyNounChunks())\n```\n\nFixed a bug in corpus construction that occurs when the last document has no features.\n\n### 0.0.2.8.5\nNow you don\'t have to install tinysegmenter to use Scattertext.  But you need to\ninstall it if you want to parse Japanese.  This caused a problem when Scattertext\nwas being installed on Windows.\n\n### 0.0.2.8.1-4\nAdded `TermDocMatrix.get_corner_score`, giving an improved version of the \nRudder Score.  Exposing `whitespace_nlp_with_sentences`.  It\'s a lightweight\n bad regex sentence splitter built a top a bad regex tokenizer that somewhat\n apes spaCy\'s API. Use it if you don\'t have spaCy and the English model \n downloaded or if you care more about memory footprint and speed than accuracy.\n \nIt\'s not compatible with `word_similarity_explorer` but is compatible with \n `word_similarity_explorer_gensim\'.\n \nTweaked scaled f-score normalization.\n\nFixed Javascript bug when clicking on \'$\'. \n\n### 0.0.2.8.0\nFixed bug in Scaled F-Score computations, and changed computation to better score words that are inversely correlated to category.\n\nAdded `Word2VecFromParsedCorpus` to automate training Gensim word vectors from a corpus, and  \n`word_similarity_explorer_gensim` to produce the visualization.  \n\nSee `demo_gensim_similarity.py` for an example. \n\n\n### 0.0.2.7.1\nAdded the `d3_url` and `d3_scale_chromatic_url` parameters to \n`produce_scattertext_explorer`.  This provides a way to manually specify the paths to "d3.js" \n(i.e., the file from "https://cdnjs.cloudflare.com/ajax/libs/d3/4.6.0/d3.min.js") and\n"d3-scale-chromatic.v1.js" (i.e., the file from "https://d3js.org/d3-scale-chromatic.v1.min.js").\n\nThis is important if you\'re getting the error:\n\n```\nJavascript error adding output!\nTypeError: d3.scaleLinear is not a function\nSee your browser Javascript console for more details.\n``` \n\nIt also lets you use Scattertext if you\'re serving in an environment with no (or a restricted) \nexternal Internet connection. \n\nFor example, if "d3.min.js" and "d3-scale-chromatic.v1.min.js" were present in the current\nworking directory, calling the following code would reference them locally instead of \nthe remote Javascript files. See [Visualizing term associations](#visualizing-term-associations) \nfor code context. \n\n```pydocstring\n>>> html = st.produce_scattertext_explorer(corpus,\n...          category=\'democrat\',\n...          category_name=\'Democratic\',\n...          not_category_name=\'Republican\',\n...          width_in_pixels=1000,\n...          metadata=convention_df[\'speaker\'],\n...          d3_url=\'d3.min.js\',\n...          d3_scale_chromatic_url=\'d3-scale-chromatic.v1.min.js\')\n```\n\n### 0.0.2.7.0\nFixed a bug in 0.0.2.6.0 that transposed default axis labels.\n\nAdded a Japanese mode to Scattertext.  See `demo_japanese.py` for an example of\n how to use Japanese.  Please run `pip install tinysegmenter` to parse Japanese.\n\nAlso, the `chiense_mode` boolean parameter in \n`produce_scattertext_explorer` has been renamed to `asian_mode`.\n\nFor example, the output of `demo_japanese.py` is:\n[![demo_japanese.html](https://jasonkessler.github.io/demo_japanese.png)](https://jasonkessler.github.io/demo_japanese.html)\n\n\n### 0.0.2.6.0\nCustom term positions and axis labels.  Although not recommended, you can \nvisualize different metrics on each axis in visualizations similar to Monroe et al. (2008).\nPlease see [Custom term positions](#custom-term-positions) for more info.\n\n \n### 0.0.2.5.0\nEnhanced the visualization of query-based categorical differences, a.k.a the `word_similarity_explorer`\nfunction. When run, a plot is produced that contains category associated terms \ncolored in either red or blue hues, and terms not associated with either class\ncolored in greyscale and slightly smaller. The intensity of each color indicates \n association with the query term.  For example:\n \n[![Convention-Visualization-Jobs.html](https://jasonkessler.github.io/Conventions-Viz-Explanation.png)](https://jasonkessler.github.io/Convention-Visualization-Jobs.html)\n\n### 0.0.2.4.6\nSome minor bug fixes, and added a `minimum_not_category_term_frequency` parameter.  This fixes a problem with \nvisualizing imbalanced datasets.  It sets a minimum number of times a word that does not appear in the target \ncategory must appear before it is displayed.\n\nAdded `TermDocMatrix.remove_entity_tags` method to remove entity type tags \nfrom the analysis. \n\n### 0.0.2.4.5\nFixed matched snippet not displaying issue [#9](/../../issues/9), and fixed a Python 2 issue \nin created a visualization using a `ParsedCorpus` prepared via `CorpusFromParsedDocuments`, mentioned\nin the latter part of the issue [#8](/../../issues/8) discussion.\n\nAgain, Python 2 is supported in experimental mode only.\n\n### 0.0.2.4.4\nCorrected example links on this Readme.\n   \nFixed a bug in Issue 8 where the HTML visualization produced by `produce_scattertext_html` would fail.\n\n### 0.0.2.4.2\nFixed a couple issues that rendered Scattertext broken in Python 2. Chinese processing still does not work.\n\nNote: Use Python 3.4+ if you can.\n\n### 0.0.2.4.1\nFixed links in Readme, and made regex NLP available in CLI.\n\n### 0.0.2.4\nAdded the command line tool, and fixed a bug related to Empath visualizations.\n\n### 0.0.2.3\nAbility to see how a particular term is discussed differently between categories\nthrough the `word_similarity_explorer` function. \n\nSpecialized mode to view sparse term scores.\n\nFixed a bug that was caused by repeated values in background unigram counts.\n\nAdded true alphabetical term sorting in visualizations.\n  \nAdded an optional save-as-SVG button.\n\n### 0.0.2.2\n\nAddition option of showing characteristic terms (from the full set of documents) being considered.\nThe option (`show_characteristic` in `produce_scattertext_explorer`) is on by default, \nbut currently unavailable for Chinese.  If you know of a good Chinese wordcount list,\nplease let me know.  The algorithm used to produce these is F-Score.  \nSee [this and the following slide](http://www.slideshare.net/JasonKessler/turning-unstructured-content-into-kernels-of-ideas/58) for more details\n\n### 0.0.2.1.5\n\nAdded document and word count statistics to main visualization. \n\n### 0.0.2.1.4\n\nAdded preliminary support for visualizing [Empath](https://github.com/Ejhfast/empath-client) (Fast 2016) topics categories instead of emotions.  See the tutorial for more information. \n\n### 0.0.2.1.3\n\nImproved term-labeling.\n\n### 0.0.2.1.1\n\nAddition of `strip_final_period` param to `FeatsFromSpacyDoc` to deal with spaCy \n tokenization of all-caps documents that can leave periods at the end of terms.\n\n### 0.0.2.1.0\n\nI\'ve added support for Chinese, including the ChineseNLP class, which uses a RegExp-based \nsentence splitter and [Jieba](https://github.com/fxsjy/jieba) for word \nsegmentation. To use it, see the `demo_chinese.py` file.  Note that `CorpusFromPandas`\ncurrently does not support ChineseNLP.\n\nIn order for the visualization to work, set the `asian_mode` flag to `True` in\n`produce_scattertext_explorer`.\n\n## Sources\n* 2012 Convention Data: scraped from [The New York Times.](http://www.nytimes.com/interactive/2012/09/06/us/politics/convention-word-counts.html?_r=0)\n* count_1w: Peter Norvig assembled this file (downloaded from [norvig.com](http://norvig.com/ngrams/count_1w.txt)). See http://norvig.com/ngrams/ for an explanation of how it was gathered from a very large corpus.\n* hamlet.txt: William Shakespeare. From [shapespeare.mit.edu](http://shakespeare.mit.edu/hamlet/full.html)\n* Inspiration for text scatter plots: Rudder, Christian. Dataclysm: Who We Are (When We Think No One\'s Looking). Random House Incorporated, 2014.\n* Loncaric, Calvin. "Cozy: synthesizing collection data structures." Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering. ACM, 2016.\n* Fast, Ethan, Binbin Chen, and Michael S. Bernstein. "Empath: Understanding topic signals in large-scale text." Proceedings of the 2016 CHI Conference on Human Factors in Computing Systems. ACM, 2016.\n* Burt L. Monroe, Michael P. Colaresi, and Kevin M. Quinn. 2008. Fightin\xe2\x80\x99 words: Lexical feature selection and evaluation for identifying the content of political conflict. Political Analysis.\n* Bo Pang and Lillian Lee. A Sentimental Education: Sentiment Analysis Using Subjectivity Summarization Based on Minimum Cuts, Proceedings of the ACL, 2004.\n* Abram Handler, Matt Denny, Hanna Wallach, and Brendan O\'Connor. Bag of what? Simple noun phrase extraction for corpus analysis.  NLP+CSS Workshop at EMNLP 2016.\n* Peter Fankhauser, J\xc3\xb6rg Knappen, Elke Teich. Exploring and visualizing variation in language resources. LREC 2014.\n* Shinichi Nakagawa and Innes C. Cuthill. Effect size, confidence interval and statistical significance: a practical guide for biologists. 2007. In Biological Reviews 82.'