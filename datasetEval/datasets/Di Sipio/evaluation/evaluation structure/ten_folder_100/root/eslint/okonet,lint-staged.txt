b'# \xf0\x9f\x9a\xab\xf0\x9f\x92\xa9 lint-staged [![Build Status for Linux](https://travis-ci.org/okonet/lint-staged.svg?branch=master)](https://travis-ci.org/okonet/lint-staged) [![Build Status for Windows](https://ci.appveyor.com/api/projects/status/github/okonet/lint-staged?branch=master&svg=true)](https://ci.appveyor.com/project/okonet/lint-staged) [![npm version](https://badge.fury.io/js/lint-staged.svg)](https://badge.fury.io/js/lint-staged) [![Codecov](https://codecov.io/gh/okonet/lint-staged/branch/master/graph/badge.svg)](https://codecov.io/gh/okonet/lint-staged)\n\nRun linters against staged git files and don\'t let :poop: slip into your code base!\n\n---\n\n## \xf0\x9f\x9a\xa7 Help test `lint-staged@beta`!\n\nVersion 10 of `lint-staged` is coming with changes that help it run faster on large git repositories and prevent loss of data during errors. Please help test the `beta` version and report any inconsistencies in our [GitHub Issues](https://github.com/okonet/lint-staged/issues):\n\n**Using npm**\n\n    npm install --save-dev lint-staged@beta\n\n**Using yarn**\n\n    yarn add -D lint-staged@beta\n\n### Notable changes\n\n- A git stash is created before running any tasks, so in case of errors any lost changes can be restored easily (and automatically unless lint-staged itself crashes)\n- Instead of write-tree/read-tree, `lint-staged@beta` uses git stashes to hide unstaged changes while running tasks against staged files\n  - This results in a performance increase of up to 45x on very large repositories\n- The behaviour of committing modifications during tasks (eg. `prettier --write && git add`) is different. The current version creates a diff of these modifications, and applies it against the original state, silently ignoring any errors. The `beta` version leaves modifications of staged files as-is, and then restores all hidden unstaged changes as patch. If applying the patch fails due to a merge conflict (because tasks have modified the same lines), a 3-way merge will be retried. If this also fails, the entire commit will fail and the original state will be restored.\n  - **TL;DR** the `beta` version will never skip committing any changes by tasks (due to a merge conflict), but might fail in very complex situations where unstaged changes cannot be restored cleanly. If this happens to you, we are very interested in a repeatable test scenario.\n\n---\n\n[![asciicast](https://asciinema.org/a/199934.svg)](https://asciinema.org/a/199934)\n\n## Why\n\nLinting makes more sense when run before committing your code. By doing so you can ensure no errors go into the repository and enforce code style. But running a lint process on a whole project is slow and linting results can be irrelevant. Ultimately you only want to lint files that will be committed.\n\nThis project contains a script that will run arbitrary shell tasks with a list of staged files as an argument, filtered by a specified glob pattern.\n\n## Related blogs posts and talks\n\n- [Make Linting Great Again](https://medium.com/@okonetchnikov/make-linting-great-again-f3890e1ad6b8#.8qepn2b5l)\n- [Running Jest Tests Before Each Git Commit](https://benmccormick.org/2017/02/26/running-jest-tests-before-each-git-commit/)\n- [AgentConf: Make Linting Great Again](https://www.youtube.com/watch?v=-mhY7e-EsC4)\n- [SurviveJS Interview](https://survivejs.com/blog/lint-staged-interview/)\n\n> If you\'ve written one, please submit a PR with the link to it!\n\n## Installation and setup\n\nThe fastest way to start using lint-staged is to run following command in your terminal:\n\n```bash\nnpx mrm lint-staged\n```\n\nIt will install and configure [husky](https://github.com/typicode/husky) and lint-staged depending on code quality tools from `package.json` dependencies so please make sure you install (`npm install --save-dev`) and configure all code quality tools like [Prettier](https://prettier.io), [ESlint](https://eslint.org) prior that.\n\nDon\'t forget to commit changes to `package.json` to share this setup with your team!\n\nNow change a few files, `git add` or `git add --patch` some of them to your commit and try to `git commit` them.\n\nSee [examples](#examples) and [configuration](#configuration) for more information.\n\n## Changelog\n\nSee [Releases](https://github.com/okonet/lint-staged/releases)\n\n## Command line flags\n\n```bash\n$ npx lint-staged --help\nUsage: lint-staged [options]\n\nOptions:\n  -V, --version                     output the version number\n  -c, --config [path]               Path to configuration file\n  -r, --relative                    Pass relative filepaths to tasks\n  -x, --shell                       Skip parsing of tasks for better shell support\n  -q, --quiet                       Disable lint-staged\xe2\x80\x99s own console output\n  -d, --debug                       Enable debug mode\n  -p, --concurrent [parallel tasks] The number of tasks to run concurrently, or false to run tasks sequentially\n  -h, --help                        output usage information\n```\n\n- **`--config [path]`**: This can be used to manually specify the `lint-staged` config file location. However, if the specified file cannot be found, it will error out instead of performing the usual search. You may pass a npm package name for configuration also.\n- **`--relative`**: By default filepaths will be passed to the linter tasks as _absolute_. This flag makes them relative to `process.cwd()` (where `lint-staged` runs).\n- **`--shell`**: By default linter commands will be parsed for speed and security. This has the side-effect that regular shell scripts might not work as expected. You can skip parsing of commands with this option.\n- **`--quiet`**: By default `lint-staged` will print progress status to console while running linters. Use this flag to supress all output, except for linter scripts.\n- **`--debug`**: Enabling the debug mode does the following:\n  - `lint-staged` uses the [debug](https://github.com/visionmedia/debug) module internally to log information about staged files, commands being executed, location of binaries, etc. Debug logs, which are automatically enabled by passing the flag, can also be enabled by setting the environment variable `$DEBUG` to `lint-staged*`.\n  - Use the [`verbose` renderer](https://github.com/SamVerschueren/listr-verbose-renderer) for `listr`.\n- **`--concurrent [number | (true/false)]`**: Controls the concurrency of tasks being run by lint-staged. **NOTE**: This does NOT affect the concurrency of subtasks (they will always be run sequentially). Possible values are:\n  - `false`: Run all tasks serially\n  - `true` (default) : _Infinite_ concurrency. Runs as many tasks in parallel as possible.\n  - `{number}`: Run the specified number of tasks in parallel, where `1` is equivalent to `false`.\n\n## Configuration\n\nStarting with v3.1 you can now use different ways of configuring it:\n\n- `lint-staged` object in your `package.json`\n- `.lintstagedrc` file in JSON or YML format\n- `lint-staged.config.js` file in JS format\n- Pass a configuration file using the `--config` or `-c` flag\n\nSee [cosmiconfig](https://github.com/davidtheclark/cosmiconfig) for more details on what formats are supported.\n\nConfiguration should be an object where each value is a command to run and its key is a glob pattern to use for this command. This package uses [micromatch](https://github.com/micromatch/micromatch) for glob patterns.\n\n#### `package.json` example:\n\n```json\n{\n  "lint-staged": {\n    "*": "your-cmd"\n  }\n}\n```\n\n#### `.lintstagedrc` example\n\n```json\n{\n  "*": "your-cmd"\n}\n```\n\nThis config will execute `your-cmd` with the list of currently staged files passed as arguments.\n\nSo, considering you did `git add file1.ext file2.ext`, lint-staged will run the following command:\n\n`your-cmd file1.ext file2.ext`\n\n## Filtering files\n\nLinter commands work on a subset of all staged files, defined by a _glob pattern_. `lint-staged\xc2\xb4 uses [micromatch](https://github.com/micromatch/micromatch) for matching files with the following rules:\n\n- If the glob pattern contains no slashes (`/`), micromatch\'s `matchBase` option will enabled, so globs match a file\'s basename regardless of directory:\n  - **`"*.js"`** will match all JS files, like `/test.js` and `/foo/bar/test.js`\n  - **`"!(*test).js"`**. will match all JS files, except those ending in `test.js`, so `foo.js` but not `foo.test.js`\n- If the glob pattern does contain a slash (`/`), it will match for paths as well:\n  - **`"./*.js"`** will match all JS files in the git repo root, so `/test.js` but not `/foo/bar/test.js`\n  - **`"foo/**/\\*.js"`** will match all JS files inside the`/foo`directory, so`/foo/bar/test.js`but not`/test.js`\n\nWhen matching, `lint-staged` will do the following\n\n- Resolve the git root automatically, no configuration needed.\n- Pick the staged files which are present inside the project directory.\n- Filter them using the specified glob patterns.\n- Pass absolute paths to the linters as arguments.\n\n**NOTE:** `lint-staged` will pass _absolute_ paths to the linters to avoid any confusion in case they\'re executed in a different working directory (i.e. when your `.git` directory isn\'t the same as your `package.json` directory).\n\nAlso see [How to use `lint-staged` in a multi package monorepo?](#how-to-use-lint-staged-in-a-multi-package-monorepo)\n\n### Ignoring files\n\nThe concept of `lint-staged` is to run configured linter (or other) tasks on files that are staged in git. `lint-staged` will always pass a list of all staged files to the task, and ignoring any files should be configured in the task itself.\n\nConsider a project that uses [`prettier`](https://prettier.io/) to keep code format consistent across all files. The project also stores minified 3rd-party vendor libraries in the `vendor/` directory. To keep `prettier` from throwing errors on these files, the vendor directory should be added to prettier\'s ignore configuration, the `.prettierignore` file. Running `npx prettier .` will ignore the entire vendor directory, throwing no errors. When `lint-staged` is added to the project and configured to run prettier, all modified and staged files in the vendor directory will be ignored by prettier, even though it receives them as input.\n\nIn advanced scenarios, where it is impossible to configure the linter task itself to ignore files, but some staged files should still be ignored by `lint-staged`, it is possible to filter filepaths before passing them to tasks by using the function syntax. See [Example: Ignore files from match](#example-ignore-files-from-match).\n\n## What commands are supported?\n\nSupported are any executables installed locally or globally via `npm` as well as any executable from your \\$PATH.\n\n> Using globally installed scripts is discouraged, since lint-staged may not work for someone who doesn\xe2\x80\x99t have it installed.\n\n`lint-staged` uses [execa](https://github.com/sindresorhus/execa#preferlocal) to locate locally installed scripts. So in your `.lintstagedrc` you can write:\n\n```json\n{\n  "*.js": "eslint --fix"\n}\n```\n\nPass arguments to your commands separated by space as you would do in the shell. See [examples](#examples) below.\n\nStarting from [v2.0.0](https://github.com/okonet/lint-staged/releases/tag/2.0.0) sequences of commands are supported. Pass an array of commands instead of a single one and they will run sequentially. This is useful for running autoformatting tools like `eslint --fix` or `stylefmt` but can be used for any arbitrary sequences.\n\n## Using JS functions to customize linter commands\n\nWhen supplying configuration in JS format it is possible to define the linter command as a function which receives an array of staged filenames/paths and returns the complete linter command as a string. It is also possible to return an array of complete command strings, for example when the linter command supports only a single file input.\n\n```ts\ntype LinterFn = (filenames: string[]) => string | string[]\n```\n\n### Example: Wrap filenames in single quotes and run once per file\n\n```js\n// .lintstagedrc.js\nmodule.exports = {\n  \'**/*.js?(x)\': filenames => filenames.map(filename => `prettier --write \'${filename}\'`)\n}\n```\n\n### Example: Run `tsc` on changes to TypeScript files, but do not pass any filename arguments\n\n```js\n// lint-staged.config.js\nmodule.exports = {\n  \'**/*.ts?(x)\': () => \'tsc -p tsconfig.json --noEmit\'\n}\n```\n\n### Example: Run eslint on entire repo if more than 10 staged files\n\n```js\n// .lintstagedrc.js\nmodule.exports = {\n  \'**/*.js?(x)\': filenames => (filenames.length > 10 ? \'eslint .\' : `eslint ${filenames.join(\' \')}`)\n}\n```\n\n### Example: Use your own globs\n\n```js\n// lint-staged.config.js\nconst micromatch = require(\'micromatch\')\nmodule.exports = {\n  \'*\': allFiles => {\n    const match = micromatch(allFiles, [\'*.js\', \'*.ts\'])\n    return match.map(file => `eslint ${file}`)\n  }\n}\n```\n\n### Example: Ignore files from match\n\nIf for some reason you want to ignore files from the glob match, you can use `micromatch.not()`:\n\n```js\n// lint-staged.config.js\nconst micromatch = require(\'micromatch\')\nmodule.exports = {\n  \'*.js\': files => {\n    // from `files` filter those _NOT_ matching `*test.js`\n    const match = micromatch.not(files, \'*test.js\')\n    return match.map(file => `eslint ${file}`)\n  }\n}\n```\n\nPlease note that for most cases, globs can achieve the same effect. For the above example, a matching glob would be `!(*test).js`.\n\n### Example: Use relative paths for commands\n\n```js\nconst path = require(\'path\')\nmodule.exports = {\n  \'*.ts\': absolutePaths => {\n    const cwd = process.cwd()\n    const relativePaths = absolutePaths.map(file => path.relative(cwd, file))\n    return `ng lint myProjectName --files ${relativePaths.join(\' \')}`\n  }\n}\n```\n\n## Reformatting the code\n\nTools like [Prettier](https://prettier.io), ESLint/TSLint, or stylelint can reformat your code according to an appropriate config by running `prettier --write`/`eslint --fix`/`tslint --fix`/`stylelint --fix`. After the code is reformatted, we want it to be added to the same commit. This can be done using following config:\n\n```json\n{\n  "*.js": ["prettier --write", "git add"]\n}\n```\n\nStarting from v8, lint-staged will stash your remaining changes (not added to the index) and restore them from stash afterwards if there are partially staged files detected. This allows you to create partial commits with hunks using `git add --patch`. See the [blog post](https://medium.com/@okonetchnikov/announcing-lint-staged-with-support-for-partially-staged-files-abc24a40d3ff)\n\n## Examples\n\nAll examples assuming you\xe2\x80\x99ve already set up lint-staged and husky in the `package.json`.\n\n```json\n{\n  "name": "My project",\n  "version": "0.1.0",\n  "scripts": {\n    "my-custom-script": "linter --arg1 --arg2"\n  },\n  "husky": {\n    "hooks": {\n      "pre-commit": "lint-staged"\n    }\n  },\n  "lint-staged": {}\n}\n```\n\n_Note we don\xe2\x80\x99t pass a path as an argument for the runners. This is important since lint-staged will do this for you._\n\n### ESLint with default parameters for `*.js` and `*.jsx` running as a pre-commit hook\n\n```json\n{\n  "*.{js,jsx}": "eslint"\n}\n```\n\n### Automatically fix code style with `--fix` and add to commit\n\n```json\n{\n  "*.js": ["eslint --fix", "git add"]\n}\n```\n\nThis will run `eslint --fix` and automatically add changes to the commit.\n\n### Reuse npm script\n\nIf you wish to reuse a npm script defined in your package.json:\n\n```json\n{\n  "*.js": ["npm run my-custom-script --", "git add"]\n}\n```\n\nThe following is equivalent:\n\n```json\n{\n  "*.js": ["linter --arg1 --arg2", "git add"]\n}\n```\n\n### Use environment variables with linting commands\n\nLinting commands _do not_ support the shell convention of expanding environment variables. To enable the convention yourself, use a tool like [`cross-env`](https://github.com/kentcdodds/cross-env).\n\nFor example, here is `jest` running on all `.js` files with the `NODE_ENV` variable being set to `"test"`:\n\n```json\n{\n  "*.js": ["cross-env NODE_ENV=test jest --bail --findRelatedTests"]\n}\n```\n\n### Automatically fix code style with `prettier` for javascript + flow, typescript, markdown or html\n\n```json\n{\n  "*.{js,jsx}": ["prettier --write", "git add"]\n}\n```\n\n```json\n{\n  "*.{ts,tsx}": ["prettier --write", "git add"]\n}\n```\n\n```json\n{\n  "*.{md,html}": ["prettier --write", "git add"]\n}\n```\n\n### Stylelint for CSS with defaults and for SCSS with SCSS syntax\n\n```json\n{\n  "*.css": "stylelint",\n  "*.scss": "stylelint --syntax=scss"\n}\n```\n\n### Run PostCSS sorting, add files to commit and run Stylelint to check\n\n```json\n{\n  "*.scss": ["postcss --config path/to/your/config --replace", "stylelint", "git add"]\n}\n```\n\n### Minify the images and add files to commit\n\n```json\n{\n  "*.{png,jpeg,jpg,gif,svg}": ["imagemin-lint-staged", "git add"]\n}\n```\n\n<details>\n  <summary>More about <code>imagemin-lint-staged</code></summary>\n\n[imagemin-lint-staged](https://github.com/tomchentw/imagemin-lint-staged) is a CLI tool designed for lint-staged usage with sensible defaults.\n\nSee more on [this blog post](https://medium.com/@tomchentw/imagemin-lint-staged-in-place-minify-the-images-before-adding-to-the-git-repo-5acda0b4c57e) for benefits of this approach.\n\n</details>\n\n### Typecheck your staged files with flow\n\n```json\n{\n  "*.{js,jsx}": ["flow focus-check", "git add"]\n}\n```\n\n## Frequently Asked Questions\n\n### Can I use `lint-staged` via node?\n\nYes!\n\n```js\nconst lintStaged = require(\'lint-staged\')\n\ntry {\n  const success = await lintStaged()\n  console.log(success ? \'Linting was successful!\' : \'Linting failed!\')\n} catch (e) {\n  // Failed to load configuration\n  console.error(e)\n}\n```\n\nParameters to `lintStaged` are equivalent to their CLI counterparts:\n\n```js\nconst success = await lintStaged({\n  configPath: \'./path/to/configuration/file\',\n  shell: false,\n  quiet: false,\n  debug: false\n})\n```\n\nYou can also pass config directly with `config` option:\n\n```js\nconst success = await lintStaged({\n  config: {\n    \'*.js\': \'eslint --fix\'\n  },\n  shell: false,\n  quiet: false,\n  debug: false\n})\n```\n\n### Using with JetBrains IDEs _(WebStorm, PyCharm, IntelliJ IDEA, RubyMine, etc.)_\n\n_**Update**_: The latest version of JetBrains IDEs now support running hooks as you would expect.\n\nWhen using the IDE\'s GUI to commit changes with the `precommit` hook, you might see inconsistencies in the IDE and command line. This is [known issue](https://youtrack.jetbrains.com/issue/IDEA-135454) at JetBrains so if you want this fixed, please vote for it on YouTrack.\n\nUntil the issue is resolved in the IDE, you can use the following config to work around it:\n\nhusky v1.x\n\n```json\n{\n  "husky": {\n    "hooks": {\n      "pre-commit": "lint-staged",\n      "post-commit": "git update-index --again"\n    }\n  }\n}\n```\n\nhusky v0.x\n\n```json\n{\n  "scripts": {\n    "precommit": "lint-staged",\n    "postcommit": "git update-index --again"\n  }\n}\n```\n\n_Thanks to [this comment](https://youtrack.jetbrains.com/issue/IDEA-135454#comment=27-2710654) for the fix!_\n\n### How to use `lint-staged` in a multi package monorepo?\n\nStarting with v5.0, `lint-staged` automatically resolves the git root **without any** additional configuration. You configure `lint-staged` as you normally would if your project root and git root were the same directory.\n\nIf you wish to use `lint-staged` in a multi package monorepo, it is recommended to install [`husky`](https://github.com/typicode/husky) in the root package.json.\n[`lerna`](https://github.com/lerna/lerna) can be used to execute the `precommit` script in all sub-packages.\n\nExample repo: [sudo-suhas/lint-staged-multi-pkg](https://github.com/sudo-suhas/lint-staged-multi-pkg).\n\n### Can I lint files outside of the current project folder?\n\ntl;dr: Yes, but the pattern should start with `../`.\n\nBy default, `lint-staged` executes linters only on the files present inside the project folder(where `lint-staged` is installed and run from).\nSo this question is relevant _only_ when the project folder is a child folder inside the git repo.\nIn certain project setups, it might be desirable to bypass this restriction. See [#425](https://github.com/okonet/lint-staged/issues/425), [#487](https://github.com/okonet/lint-staged/issues/487) for more context.\n\n`lint-staged` provides an escape hatch for the same(`>= v7.3.0`). For patterns that start with `../`, all the staged files are allowed to match against the pattern.\nNote that patterns like `*.js`, `**/*.js` will still only match the project files and not any of the files in parent or sibling directories.\n\nExample repo: [sudo-suhas/lint-staged-django-react-demo](https://github.com/sudo-suhas/lint-staged-django-react-demo).\n'