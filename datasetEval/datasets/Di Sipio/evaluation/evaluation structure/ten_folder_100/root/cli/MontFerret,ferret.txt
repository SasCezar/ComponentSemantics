b'# Ferret\n<p align="center">\n\t<a href="https://goreportcard.com/report/github.com/MontFerret/ferret">\n\t\t<img alt="Go Report Status" src="https://goreportcard.com/badge/github.com/MontFerret/ferret">\n\t</a>\n\t<a href="https://travis-ci.com/MontFerret/ferret">\n\t\t<img alt="Build Status" src="https://travis-ci.com/MontFerret/ferret.svg?branch=master">\n\t</a>\n\t<a href="https://codecov.io/gh/MontFerret/ferret">\n\t\t<img src="https://codecov.io/gh/MontFerret/ferret/branch/master/graph/badge.svg" />\n\t</a>\n\t<a href="https://discord.gg/kzet32U">\n\t\t<img alt="Discord Chat" src="https://img.shields.io/discord/501533080880676864.svg">\n\t</a>\n\t<a href="https://github.com/MontFerret/ferret/releases">\n\t\t<img alt="Ferret release" src="https://img.shields.io/github/release/MontFerret/ferret.svg">\n\t</a>\n\t<a href="http://opensource.org/licenses/MIT">\n\t\t<img alt="MIT License" src="http://img.shields.io/badge/license-MIT-brightgreen.svg">\n\t</a>\n</p>\n\n![ferret](https://raw.githubusercontent.com/MontFerret/ferret/master/assets/intro.jpg)\n\n## What is it?\n```ferret``` is a web scraping system. It aims to simplify data extraction from the web for UI testing, machine learning, analytics and more.    \n```ferret``` allows users to focus on the data. It abstracts away the technical details and complexity of underlying technologies using its own declarative language. \nIt is extremely portable, extensible and fast.\n\n[Read the introductory blog post about Ferret here!](https://medium.com/@ziflex/say-hello-to-ferret-a-modern-web-scraping-tool-5c9cc85ba183)\n\n## Show me some code\nThe following example demonstrates the use of dynamic pages.    \nWe load the main Google Search page, type search criteria into an input box and then click a search button.   \nThe click action triggers a redirect, so we wait until its end.   \nOnce the page gets loaded, we iterate over all elements in search results and assign the output to a variable.   \nThe final for loop filters out empty elements that might be because of inaccurate use of selectors.      \n\n```aql\nLET google = DOCUMENT("https://www.google.com/", {\n    driver: "cdp",\n    userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36"\n})\n\nINPUT(google, \'input[name="q"]\', "ferret")\nCLICK(google, \'input[name="btnK"]\')\n\nWAIT_NAVIGATION(google)\n\nFOR result IN ELEMENTS(google, \'.g\')\n    // filter out extra elements like videos and \'People also ask\'\n    FILTER TRIM(result.attributes.class) == \'g\'\n    RETURN {\n        title: INNER_TEXT(result, \'h3\'),\n        description: INNER_TEXT(result, \'.st\'),\n        url: INNER_TEXT(result, \'cite\')\n    }\n```\n\nMore examples you can find [here](./examples)\n\n## Features\n\n* Declarative language\n* Support of both static and dynamic web pages\n* Embeddable\n* Extensible\n\n## Motivation\nNowadays data is everything and who owns data - owns the world.    \nI have worked on multiple data-driven projects where data was an essential part of a system and I realized how cumbersome writing tons of scrapers is.    \nAfter some time looking for a tool that would let me to not write a code, but just express what data I need, decided to come up with my own solution.    \n```ferret``` project is an ambitious initiative trying to bring the universal platform for writing scrapers without any hassle.    \n\n## Inspiration\nFQL (Ferret Query Language) is heavily inspired by [AQL](https://www.arangodb.com/) (ArangoDB Query Language).    \nBut due to the domain specifics, there are some differences in how things work.     \n\n## WIP\nBe aware, that the project is under heavy development. There is no documentation and some things may change in the final release.    \nFor query syntax, you may go to [ArangoDB web site](https://docs.arangodb.com/3.3/AQL/index.html) and use AQL docs as docs for FQL - since they are identical.    \n\n\n## Installation\n\n### Binary\nYou can download latest binaries from [here](https://github.com/MontFerret/ferret/releases).\n\n### Source code\n#### Production\n* Go >=1.11\n* Chrome or Docker\n\n#### Development\n* GNU Make\n* ANTLR4 >=4.7.1\n\n\n```sh\ngo get github.com/MontFerret/ferret\n```\n\n## Environment\n\nIn order to use all Ferret features, you will need to have Chrome either installed locally or running in Docker.\nFor ease of use we recommend to run Chrome inside a Docker container:\n\n```sh\ndocker pull alpeware/chrome-headless-stable\ndocker run -d -p=0.0.0.0:9222:9222 --name=chrome-headless -v /tmp/chromedata/:/data alpeware/chrome-headless-stable\n```\n\nBut if you want to see what\'s happening during query execution, just start your Chrome with remote debugging port:\n\n```sh\nchrome.exe --remote-debugging-port=9222\n```\n\n## Quick start\n\n### Browserless mode\n\nIf you want to play with ```fql``` and check its syntax, you can run CLI with the following commands:\n```\nferret\n```\n\n```ferret``` will run in REPL mode.\n\n```shell\nWelcome to Ferret REPL\nPlease use `Ctrl-D` to exit this program.\n>%\n>LET doc = DOCUMENT(\'https://news.ycombinator.com/\')\n>FOR post IN ELEMENTS(doc, \'.storylink\')\n>RETURN post.attributes.href\n>%\n\n```\n\n**Note:** symbol ```%``` is used to start and end multi-line queries. You also can use the heredoc format.\n\nIf you want to execute a query stored in a file, just pass a file name:\n\n```\nferret ./docs/examples/static-page.fql\n```\n\n```\ncat ./docs/examples/static-page.fql | ferret\n```\n\n```\nferret < ./docs/examples/static-page.fql\n```\n\n\n### Browser mode\n\nBy default, ``ferret`` loads HTML pages via HTTP protocol, because it\'s faster.    \nBut nowadays, there are more and more websites rendered with JavaScript, and therefore, this \'old school\' approach does not really work.    \nFor such cases, you may fetch documents using Chrome or Chromium via Chrome DevTools protocol (aka CDP).    \nFirst, you need to make sure that you launched Chrome with ```remote-debugging-port=9222``` flag.    \nSecond, you need to pass the address to ```ferret``` CLI.    \n\n```\nferret --cdp http://127.0.0.1:9222\n```\n\n**NOTE:** By default, ```ferret``` will try to use this local address as a default one, so it makes sense to explicitly pass the parameter only in case of either different port number or remote address.    \n\nAlternatively, you can tell CLI to launch Chrome for you.\n\n```shell\nferret --cdp-launch\n```\n\n**NOTE:** Launch command is currently broken on MacOS.\n\nOnce ```ferret``` knows how to communicate with Chrome, you can use a function ```DOCUMENT(url, isDynamic)``` with ```true``` boolean value for dynamic pages:\n\n```shell\nWelcome to Ferret REPL\nPlease use `exit` or `Ctrl-D` to exit this program.\n>%\n>LET doc = DOCUMENT(\'https://soundcloud.com/charts/top\', { driver: "cdp" })\n>WAIT_ELEMENT(doc, \'.chartTrack__details\', 5000)\n>LET tracks = ELEMENTS(doc, \'.chartTrack__details\')\n>FOR track IN tracks\n>    LET username = ELEMENT(track, \'.chartTrack__username\')\n>    LET title = ELEMENT(track, \'.chartTrack__title\')\n>    RETURN {\n>       artist: username.innerText,\n>        track: title.innerText\n>    }\n>%\n```\n\n```shell\nWelcome to Ferret REPL\nPlease use `exit` or `Ctrl-D` to exit this program.\n>%\n>LET doc = DOCUMENT("https://github.com/", { driver: "cdp" })\n>LET btn = ELEMENT(doc, ".HeaderMenu a")\n\n>CLICK(btn)\n>WAIT_NAVIGATION(doc)\n>WAIT_ELEMENT(doc, \'.IconNav\')\n\n>FOR el IN ELEMENTS(doc, \'.IconNav a\')\n>    RETURN TRIM(el.innerText)\n>%\n```\n\n### Embedded mode\n\n```ferret``` is a very modular system and therefore, can be easily be embedded into your Go application.\n\n```go\npackage main\n\nimport (\n\t"context"\n\t"encoding/json"\n\t"fmt"\n\t"os"\n\n\t"github.com/MontFerret/ferret/pkg/compiler"\n\t"github.com/MontFerret/ferret/pkg/drivers"\n\t"github.com/MontFerret/ferret/pkg/drivers/cdp"\n\t"github.com/MontFerret/ferret/pkg/drivers/http"\n)\n\ntype Topic struct {\n\tName        string `json:"name"`\n\tDescription string `json:"description"`\n\tURL         string `json:"url"`\n}\n\nfunc main() {\n\ttopics, err := getTopTenTrendingTopics()\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tfor _, topic := range topics {\n\t\tfmt.Println(fmt.Sprintf("%s: %s %s", topic.Name, topic.Description, topic.URL))\n\t}\n}\n\nfunc getTopTenTrendingTopics() ([]*Topic, error) {\n\tquery := `\n\t\tLET doc = DOCUMENT("https://github.com/topics")\n\n\t\tFOR el IN ELEMENTS(doc, ".py-4.border-bottom")\n\t\t\tLIMIT 10\n\t\t\tLET url = ELEMENT(el, "a")\n\t\t\tLET name = ELEMENT(el, ".f3")\n\t\t\tLET desc = ELEMENT(el, ".f5")\n\n\t\t\tRETURN {\n\t\t\t\tname: TRIM(name.innerText),\n\t\t\t\tdescription: TRIM(desc.innerText),\n\t\t\t\turl: "https://github.com" + url.attributes.href\n\t\t\t}\n\t`\n\n\tcomp := compiler.New()\n\n\tprogram, err := comp.Compile(query)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// create a root context\n\tctx := context.Background()\n\n\t// enable HTML drivers\n\t// by default, Ferret Runtime does not know about any HTML drivers\n\t// all HTML manipulations are done via functions from standard library\n\t// that assume that at least one driver is available\n\tctx = drivers.WithContext(ctx, cdp.NewDriver())\n\tctx = drivers.WithContext(ctx, http.NewDriver(), drivers.AsDefault())\n\n\tout, err := program.Run(ctx)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres := make([]*Topic, 0, 10)\n\n\terr = json.Unmarshal(out, &res)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n\n```\n\n## Extensibility\n\nThat said, ```ferret``` is a very modular system which also allows not only embed it, but extend its standard library.\n\n```go\npackage main\n\nimport (\n\t"context"\n\t"encoding/json"\n\t"fmt"\n\t"os"\n\t"strings"\n\n\t"github.com/MontFerret/ferret/pkg/compiler"\n\t"github.com/MontFerret/ferret/pkg/runtime/core"\n\t"github.com/MontFerret/ferret/pkg/runtime/values"\n)\n\nfunc main() {\n\tstrs, err := getStrings()\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tfor _, str := range strs {\n\t\tfmt.Println(str)\n\t}\n}\n\nfunc getStrings() ([]string, error) {\n\t// function implements is a type of a function that ferret supports as a runtime function\n\ttransform := func(ctx context.Context, args ...core.Value) (core.Value, error) {\n\t\t// it\'s just a helper function which helps to validate a number of passed args\n\t\terr := core.ValidateArgs(args, 1, 1)\n\n\t\tif err != nil {\n\t\t\t// it\'s recommended to return built-in None type, instead of nil\n\t\t\treturn values.None, err\n\t\t}\n\n\t\t// this is another helper functions allowing to do type validation\n\t\terr = core.ValidateType(args[0], core.StringType)\n\n\t\tif err != nil {\n\t\t\treturn values.None, err\n\t\t}\n\n\t\t// cast to built-in string type\n\t\tstr := args[0].(values.String)\n\n\t\treturn values.NewString(strings.ToUpper(str.String() + "_ferret")), nil\n\t}\n\n\tquery := `\n\t\tFOR el IN ["foo", "bar", "qaz"]\n\t\t\t// conventionally all functions are registered in upper case\n\t\t\tRETURN TRANSFORM(el)\n\t`\n\n\tcomp := compiler.New()\n\n\tif err := comp.RegisterFunction("transform", transform); err != nil {\n\t\treturn nil, err\n\t}\n\n\tprogram, err := comp.Compile(query)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout, err := program.Run(context.Background())\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres := make([]string, 0, 3)\n\n\terr = json.Unmarshal(out, &res)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n```\n\nOn top of that, you can completely turn off the standard library, bypassing the following option:\n\n```go\ncomp := compiler.New(compiler.WithoutStdlib())\n```\n\nAnd after that, you can easily provide your own implementation of functions from standard library.    \n\nIf you don\'t need a particular set of functions from standard library, you can turn off the entire ```stdlib``` and register separate packages from that:    \n\n```go\npackage main\n\nimport (\n    "github.com/MontFerret/ferret/pkg/compiler"\n    "github.com/MontFerret/ferret/pkg/stdlib/strings"\n)\n\nfunc main() {\n    comp := compiler.New(compiler.WithoutStdlib())\n\n    comp.RegisterFunctions(strings.NewLib())\n}\n```\n\n## Proxy\n\nBy default, Ferret does not use any proxies. Partially, due to inability to force Chrome/Chromium (or any other Chrome Devtools Protocol compatible browser) to use a prticular proxy. It should be done during a browser launch.\n\nBut you can pass an address of a proxy server you want to use for static pages.\n\n#### CLI\n\n```sh\nferret --proxy=http://localhost:8888 my-query.fql\n```\n\n#### Code\n\n```go\npackage main\n\nimport (\n    "context"\n    "encoding/json"\n    "fmt"\n    "os"\n\t\n    "github.com/MontFerret/ferret/pkg/compiler"\n    "github.com/MontFerret/ferret/pkg/drivers"\n    "github.com/MontFerret/ferret/pkg/drivers/http"\n)\n\nfunc run(q string) ([]byte, error) {\n    proxy := "http://localhost:8888"\n    comp := compiler.New()\n    program := comp.MustCompile(q)\n\n    // create a root context\n    ctx := context.Background()\n\n    // we inform the driver what proxy to use\n    ctx = drivers.WithContext(ctx, http.NewDriver(http.WithProxy(proxy)), drivers.AsDefault())\n\n    return program.Run(ctx)\n}\n\n```\n\n## Cookies\n\n### Non-incognito mode\n\nBy default, ``CDP`` driver execute each query in an incognito mode in order to avoid any collisions related to some persisted cookies from previous queries.   \nHowever, sometimes it might not be a desirable behavior and a query needs to be executed within a Chrome tab with earlier persisted cookies.   \nIn order to do that, we need to inform the driver to execute all queries in regular tabs. Here is how to do that:\n\n#### CLI\n\n```sh\nferret --cdp-keep-cookies my-query.fql\n```\n\n#### Code\n\n```go\npackage main\n\nimport (\n\t"context"\n\t"encoding/json"\n\t"fmt"\n\t"os"\n\n\t"github.com/MontFerret/ferret/pkg/compiler"\n\t"github.com/MontFerret/ferret/pkg/drivers"\n\t"github.com/MontFerret/ferret/pkg/drivers/cdp"\n)\n\nfunc run(q string) ([]byte, error) {\n\tcomp := compiler.New()\n\tprogram := comp.MustCompile(q)\n\n\t// create a root context\n\tctx := context.Background()\n\n\t// we inform the driver to keep cookies between queries\n\tctx = drivers.WithContext(\n\t\tctx,\n\t\tcdp.NewDriver(cdp.WithKeepCookies()),\n\t\tdrivers.AsDefault(),\n\t)\n\n\treturn program.Run(ctx)\n}\n```\n\n#### Query\n```\nLET doc = DOCUMENT("https://www.google.com", {\n    driver: "cdp",\n    keepCookies: true\n})\n```\n\n### Cookies manipulation\nFor more precise work, you can set/get/delete cookies manually during and after page load:\n\n```\nLET doc = DOCUMENT("https://www.google.com", {\n    driver: "cdp",\n    cookies: [\n         {\n             name: "foo",\n             value: "bar"\n         }\n    ]\n})\n\nCOOKIE_SET(doc, { name: "baz", value: "qaz"}, { name: "daz", value: "gag" })\nCOOKIE_DEL(doc, "foo")\n\nLET c = COOKIE_GET(doc, "baz")\n\nFOR cookie IN doc.cookies\n    RETURN cookie.name\n\t\n```\n\n## Sponsors\n\nSupport this project by becoming a sponsor. Your logo will show up here with a link to your website.    \n\n<p>\n    <a href="https://opencollective.com/ferret/sponsor/0/website" target="_blank"><img src="https://opencollective.com/ferret/sponsor/0/avatar.svg"></a>\n</p>\n\n<p align="center">\n    <a href="https://opencollective.com/ferret/donate" target="_blank">\n        <img src="https://opencollective.com/ferret/donate/button@2x.png?color=blue" width="300" />\n    </a>\n</p>\n'