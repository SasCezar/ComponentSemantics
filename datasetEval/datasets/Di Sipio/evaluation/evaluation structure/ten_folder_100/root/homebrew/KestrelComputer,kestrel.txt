b'[![Build Status](https://travis-ci.org/KestrelComputer/kestrel.svg?branch=master)](https://travis-ci.org/KestrelComputer/kestrel)\n\n# Kestrel\n\nWith each passing day, technically capable consumers of computing technology\nincreasingly lose their rights with computer hardware.  The successful\ndeployment of UEFI in the market, with Microsoft controlling which operating\nsystems receive a key that permits it to be booted, poses a potential threat to\nOS development freedom.  While some look to prominent Linux suppliers as an\nescape from the Intel/Microsoft monopoly, I have taken a different route -- I\ndecided to build my own computer completely from scratch.  My computer\narchitecture is fully open; anyone can review the source, learn from, and hack\nit to suit their needs.\n\n## Introduction and Background\n\nThe Kestrel project is all about freedom of computing and self-education using\nall-homebrew design, right down to having openly documented hardware and\nsoftware at all levels, from schematics and register-transfer logic all the way\nup to OS API and user tutorials.  Its design is informed from a variety of\nsources based on my experience:\n\n* Excellence in Hardware Engineering\n    * **Atari 800**, for demonstrating how small modules that do one job exceptionally well can interact to comprise a hardware system of exceptional capability for minimum cost.\n    * **Atari ST**, for demonstrating how commodity hardware can be assembled to form a long-lived, fan-supported environment that transitioned from a primarily closed-source to open-source community.\n    * **Commodore Amiga**, for the same reasons as the Atari 800, except adjusted for newer capabilities afforded by faster bus architectures and wider data paths.  (This comes as no surprise to anyone familiar with Atari hardware, for the Amiga OCS chipset was designed by the same engineers as the Atari 800 chipset, and shares much in the way of architecture.)\n* Excellence in Accessible and Usable Documentation\n    * **Commodore 64/128**, for having a single volume that provided all levels of knowledge, hardware (including schematics and data sheets) to OS-level system calls.\n    * **Commodore Amiga**, for having exceptionally well-written programmers reference manuals that were easy to follow, contained numerous tutorial material, and never sacrificed its value as a reference.\n* Excellence in System Software Design\n    * **CP/M**, for being the simplest possible thing that could possibly work.\n    * **Commodore 64/128**, for pre-dating many concepts later independently rediscovered by the authors of Plan 9 from Bell Labs.  ("Everything is a GPIB device", versus, "Everything is a file," and the use of command channels instead of dedicated system calls like `ioctl()`.)\n    * **Commodore Amiga**, for demonstrating the effectiveness of preemptive multitasking in a consumer product, without requiring many megabytes of memory.\n    * **Jupiter ACE**, for demonstrating what\'s really possible with only 2KiB of system RAM, of which half is dedicated to video memory.\n* Excellence in User Experience\n    * **Commodore Amiga**, for demonstrating real-time GUI concepts that set the bar for UX that wasn\'t matched for more than a decade thereafter.\n    * **Jupiter ACE**, for demonstrating that Forth _can_ in fact be packaged for consumer use.\n    * **Tripos**, for providing an excellent user experience at the shell.\n\n## Installing and Testing\n\nt.b.d.\n\n## Contributing\n\n### Branching\n\nThe "master" branch must always be a valid build, and as such, always represents the current release.\nChanges queued for the next release will be placed on a branch named "working".\nFeature branches, therefore, must be derived off of the working branch.\n\nTo create a feature branch:\n\n    git checkout working\n    git pull\n    git checkout -b featureBranch\n    git checkout -b featureBranch-wip\n\nPerform all your edits in the WIP branch.\nCommit as often as you feel comfortable.\nYou may even open pull requests on the WIP branch;\nhowever, no PR opened from a WIP branch will ever be merged.\n\nTo merge code, squash all your commits into the non-wip branch, like so:\n\n    git checkout featureBranch\n    git merge --squash featureBranch-wip\n    git commit -a\n    git push -u origin featureBranch\n\nYou may now open a pull request from your featureBranch into the working branch.  Pull requests into master will be categorically closed.\n\nThe "git commit -a" step will open a text editor allowing you to enter a commit log.\nThis log should answer the following questions, where appropriate:\n\n1. What is the problem?\n1. Why is it a problem for you?\n1. What is your solution?\n1. How does your solution work?  (Recommended for non-trivial changes.)\n1. Why should we use your solution over someone elses?  (Recommended especially if multiple solutions are proposed.)\n\nRemember that monster-sized pull requests are a bear to code review, so having helpful commit logs are an absolute must to review changes as quickly and easily as possible.\n\nFinally, if you break the build or environment, you\'re ultimately responsible for fixing it.\n\n### Source Representation\n\nThe age of 80-column punch cards are over; I think most people have monitors capable of showing at least 132 columns of text these days.  Use them.\nHowever, remember that the longer the line, especially those exceeding 132 characters, the more likely splitting a line might make some sense.\nUse best judgement here; I regularly break long lines, but I also regularly exceed the 80-character limit too.\n\n### Unit and Integration Tests\n\nPull requests that lack adequate tests will be called out, or even rejected.  Make sure your code is tested.  Where applicable, try to write your tests _first_, following [test-driven development](http://en.wikipedia.org/wiki/Test-driven_development) practices.\n\n'