b'[![GoDoc](https://godoc.org/github.com/bitfield/script?status.png)](http://godoc.org/github.com/bitfield/script)[![Go Report Card](https://goreportcard.com/badge/github.com/bitfield/script)](https://goreportcard.com/report/github.com/bitfield/script)[![Mentioned in Awesome Go](https://awesome.re/mentioned-badge-flat.svg)](https://github.com/avelino/awesome-go)[![CircleCI](https://circleci.com/gh/bitfield/script.svg?style=svg)](https://circleci.com/gh/bitfield/script)\n\n# What is `script`?\n\n`script` is a Go library for doing the kind of tasks that shell scripts are good at: reading files, executing subprocesses, counting lines, matching strings, and so on.\n\nWhy shouldn\'t it be as easy to write system administration programs in Go as it is in a typical shell? `script` aims to make it just that easy.\n\nShell scripts often compose a sequence of operations on a stream of data (a _pipeline_). This is how `script` works, too.\n\n# How do I import it?\n\n```go\nimport github.com/bitfield/script\n```\n\n# What can I do with it?\n\nLet\'s see a simple example. Suppose you want to read the contents of a file as a string:\n\n```go\ncontents, err := script.File("test.txt").String()\n```\n\nThat looks straightforward enough, but suppose you now want to count the lines in that file.\n\n```go\nnumLines, err := script.File("test.txt").CountLines()\n```\n\nFor something a bit more challenging, let\'s try counting the number of lines in the file which match the string "Error":\n\n```go\nnumErrors, err := script.File("test.txt").Match("Error").CountLines()\n```\n\nBut what if, instead of reading a specific file, we want to simply pipe input into this program, and have it output only matching lines (like `grep`)?\n\n```go\nscript.Stdin().Match("Error").Stdout()\n```\n\nThat was almost too easy! So let\'s pass in a list of files on the command line, and have our program read them all in sequence and output the matching lines:\n\n```go\nscript.Args().Concat().Match("Error").Stdout()\n```\n\nMaybe we\'re only interested in the first 10 matches. No problem:\n\n```go\nscript.Args().Concat().Match("Error").First(10).Stdout()\n```\n\nWhat\'s that? You want to append that output to a file instead of printing it to the terminal? _You\'ve got some attitude, mister_.\n\n```go\nscript.Args().Concat().Match("Error").First(10).AppendFile("/var/log/errors.txt")\n```\n\n# Table of contents<!-- omit in toc -->\n- [What is `script`?](#what-is-script)\n- [How do I import it?](#how-do-i-import-it)\n- [What can I do with it?](#what-can-i-do-with-it)\n- [How does it work?](#how-does-it-work)\n- [Everything is a pipe](#everything-is-a-pipe)\n- [What use is a pipe?](#what-use-is-a-pipe)\n- [Handling errors](#handling-errors)\n- [Getting output](#getting-output)\n- [Errors](#errors)\n- [Closing pipes](#closing-pipes)\n- [Why not just use shell?](#why-not-just-use-shell)\n- [A real-world example](#a-real-world-example)\n- [Quick start: Unix equivalents](#quick-start-unix-equivalents)\n- [Sources, filters, and sinks](#sources-filters-and-sinks)\n- [Sources](#sources)\n\t- [Args](#args)\n\t- [Echo](#echo)\n\t- [Exec](#exec)\n\t\t- [Exit status](#exit-status)\n\t\t- [Error output](#error-output)\n\t- [File](#file)\n\t- [IfExists](#ifexists)\n\t- [ListFiles](#listfiles)\n\t- [Slice](#slice)\n\t- [Stdin](#stdin)\n- [Filters](#filters)\n\t- [Basename](#basename)\n\t- [Column](#column)\n\t- [Concat](#concat)\n\t- [Dirname](#dirname)\n\t- [EachLine](#eachline)\n\t- [Exec](#exec-1)\n\t- [First](#first)\n\t- [Freq](#freq)\n\t- [Join](#join)\n\t- [Last](#last)\n\t- [Match](#match)\n\t- [MatchRegexp](#matchregexp)\n\t- [Reject](#reject)\n\t- [RejectRegexp](#rejectregexp)\n\t- [Replace](#replace)\n\t- [ReplaceRegexp](#replaceregexp)\n- [Sinks](#sinks)\n\t- [AppendFile](#appendfile)\n\t- [Bytes](#bytes)\n\t- [CountLines](#countlines)\n\t- [Read](#read)\n\t- [Stdout](#stdout)\n\t- [String](#string)\n\t- [WriteFile](#writefile)\n- [Examples](#examples)\n- [How can I contribute?](#how-can-i-contribute)\n\n# How does it work?\n\nThose chained function calls look a bit weird. What\'s going on there?\n\nOne of the neat things about the Unix shell, and its many imitators, is the way you can compose operations into a _pipeline_:\n\n```sh\ncat test.txt | grep Error | wc -l\n```\n\nThe output from each stage of the pipeline feeds into the next, and you can think of each stage as a _filter_ which passes on only certain parts of its input to its output.\n\nBy comparison, writing shell-like scripts in raw Go is much less convenient, because everything you do returns a different data type, and you must (or at least should) check errors following every operation.\n\nIn scripts for system administration we often want to compose different operations like this in a quick and convenient way. If an error occurs somewhere along the pipeline, we would like to check this just once at the end, rather than after every operation.\n\n# Everything is a pipe\n\nThe `script` library allows us to do this because everything is a pipe (specifically, a `script.Pipe`). To create a pipe, start with a _source_ like `File()`:\n\n```go\nvar p script.Pipe\np = script.File("test.txt")\n```\n\nYou might expect `File()` to return an error if there is a problem opening the file, but it doesn\'t. We will want to call a chain of methods on the result of `File()`, and it\'s inconvenient to do that if it also returns an error.\n\nInstead, you can check the error status of the pipe at any time by calling its `Error()` method:\n\n```go\np = script.File("test.txt")\nif p.Error() != nil {\n    log.Fatalf("oh no: %v", p.Error())\n}\n```\n\n# What use is a pipe?\n\nNow, what can you do with this pipe? You can call a method on it:\n\n```go\nvar q script.Pipe\nq = p.Match("Error")\n```\n\nNote that the result of calling a method on a pipe is another pipe. You can do this in one step, for convenience:\n\n```go\nvar q script.Pipe\nq = script.File("test.txt").Match("Error")\n```\n\n# Handling errors\n\nWoah, woah! Just a minute! What if there was an error opening the file in the first place? Won\'t `Match` blow up if it tries to read from a non-existent file?\n\nNo, it won\'t. As soon as an error status is set on a pipe, all operations on the pipe become no-ops. Any operation which would normally return a new pipe just returns the old pipe unchanged. So you can run as long a pipeline as you want to, and if an error occurs at any stage, nothing will crash, and you can check the error status of the pipe at the end.\n\n(Seasoned Gophers will recognise this as the `errWriter` pattern described by Rob Pike in the blog post [Errors are values](https://blog.golang.org/errors-are-values).)\n\n# Getting output\n\nA pipe is useless if we can\'t get some output from it. To do this, you can use a _sink_, such as `String()`:\n\n```go\nresult, err := q.String()\nif err != nil {\n    log.Fatalf("oh no: %v", err)\n}\nfmt.Println(result)\n```\n\n# Errors\n\nNote that sinks return an error value in addition to the data. This is the same value you would get by calling `p.Error()`. If the pipe had an error in any operation along the pipeline, the pipe\'s error status will be set, and a sink operation which gets output will return the zero value, plus the error.\n\n```go\nnumLines, err := script.File("doesnt_exist.txt").CountLines()\nfmt.Println(numLines)\n// Output: 0\nif err != nil {\n\t    log.Fatal(err)\n}\n// Output: open doesnt_exist.txt: no such file or directory\n```\n\n`CountLines()` is another useful sink, which simply returns the number of lines read from the pipe.\n\n# Closing pipes\n\nIf you\'ve dealt with files in Go before, you\'ll know that you need to _close_ the file once you\'ve finished with it. Otherwise, the program will retain what\'s called a _file handle_ (the kernel data structure which represents an open file). There is a limit to the total number of open file handles for a given program, and for the system as a whole, so a program which leaks file handles will eventually crash, and will waste resources in the meantime.\n\nFiles aren\'t the only things which need to be closed after reading: so do network connections, HTTP response bodies, and so on.\n\nHow does `script` handle this? Simple. The data source associated with a pipe will be automatically closed once it is read completely. Therefore, calling any sink method which reads the pipe to completion (such as `String()`) will close its data source. The only case in which you need to call `Close()` on a pipe is when you don\'t read from it, or you don\'t read it to completion.\n\nIf the pipe was created from something that doesn\'t need to be closed, such as a string, then calling `Close()` simply does nothing.\n\nThis is implemented using a type called `ReadAutoCloser`, which takes an `io.Reader` and wraps it so that:\n\n1. it is always safe to close (if it\'s not a closable resource, it will be wrapped in an `ioutil.NopCloser` to make it one), and\n2. it is closed automatically once read to completion (specifically, once the `Read()` call on it returns `io.EOF`).\n\n_It is your responsibility to close a pipe if you do not read it to completion_.\n\n# Why not just use shell?\n\nIt\'s a fair question. Shell scripts and one-liners are perfectly adequate for building one-off tasks, initialization scripts, and the kind of \'glue code\' that holds the internet together. I speak as someone who\'s spent at least thirty years doing this for a living. But in many ways they\'re not ideal for important, non-trivial programs:\n\n* Trying to build portable shell scripts is a nightmare. The exact syntax and options of Unix commands varies from one distribution to another. Although in theory POSIX is a workable common subset of functionality, in practice it\'s usually precisely the non-POSIX behaviour that you need.\n\n* Shell scripts are hard to test (though test frameworks have been written, and if you\'re seriously putting mission-critical shell scripts into production, you should be using them, or reconsidering your technology choices).\n\n* Shell scripts don\'t scale. Because there are very limited facilities for logic and abstraction, and because any successful program tends to grow remorselessly over time, shell scripts can become an unreadable mess of special cases and spaghetti code. We\'ve all seen it, if not, indeed, done it.\n\n* Shell syntax is awkward: quoting, whitespace, and brackets can require a lot of fiddling to get right, and so many characters are magic to the shell (`*`, `?`, `>` and so on) that this can lead to subtle bugs. Scripts can work fine for years until you suddenly encounter a file whose name contains whitespace, and then everything breaks horribly.\n\n* Deploying shell scripts obviously requires at least a (sizable) shell binary in addition to the source code, but it usually also requires an unknown and variable number of extra userland programs (`cut`, `grep`, `head`, and friends). If you\'re building container images, for example, you effectively need to include a whole Unix distribution with your program, which runs to hundreds of megabytes, and is not at all in the spirit of containers.\n\nTo be fair to the shell, this kind of thing is not what it was ever intended for. Shell is an interactive job control tool for launching programs, connecting programs together, and to a limited extent, manipulating text. It\'s not for building portable, scalable, reliable, and elegant programs. That\'s what Go is for.\n\nGo has a superb testing framework built right into the standard library. It has a superb standard library, and thousands of high-quality third-party packages for just about any functionality you can imagine. It is compiled, so it\'s fast, and statically typed, so it\'s reliable. It\'s efficient and memory-safe. Go programs can be distributed as a single binary. Go scales to enormous projects (Kubernetes, for example).\n\nThe `script` library is implemented entirely in Go, and does not require any userland programs (or any other dependencies) to be present. Thus you can build your `script` program as a container image containing a single (very small) binary, which is quick to build, quick to upload, quick to deploy, quick to run, and economical with resources.\n\nIf you\'ve ever struggled to get a shell script containing a simple `if` statement to work (and who hasn\'t?), then the `script` library is dedicated to you.\n\n# A real-world example\n\nLet\'s use `script` to write a program which system administrators might actually need. One thing I often find myself doing is counting the most frequent visitors to a website over a given period of time. Given an Apache log in the Common Log Format like this:\n\n```\n212.205.21.11 - - [30/Jun/2019:17:06:15 +0000] "GET / HTTP/1.1" 200 2028 "https://example.com/ "Mozilla/5.0 (Linux; Android 8.0.0; FIG-LX1 Build/HUAWEIFIG-LX1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.156 Mobile Safari/537.36"\n```\n\nwe would like to extract the visitor\'s IP address (the first column in the logfile), and count the number of times this IP address occurs in the file. Finally, we might like to list the top 10 visitors by frequency. In a shell script we might do something like:\n\n```sh\ncut -d\' \' -f 1 access.log |sort |uniq -c |sort -rn |head\n```\n\nThere\'s a lot going on there, and it\'s pleasing to find that the equivalent `script` program is quite brief:\n\n```go\npackage main\n\nimport (\n\t"github.com/bitfield/script"\n)\n\nfunc main() {\n\tscript.Stdin().Column(1).Freq().First(10).Stdout()\n}\n```\n\n(Thanks to [Lucas Bremgartner](https://github.com/breml) for suggesting this example. You can find the complete [program](examples/visitors/main.go), along with a sample [logfile](examples/visitors/access.log), in the [`examples/visitors/`](examples/visitors) directory.)\n\n# Quick start: Unix equivalents\n\nIf you\'re already familiar with shell scripting and the Unix toolset, here is a rough guide to the equivalent `script` operation for each listed Unix command.\n\n| Unix / shell       | `script` equivalent                                           |\n| ------------------ | ------------------------------------------------------------- |\n| (any program name) | [`Exec()`](#exec)                                             |\n| `[ -f FILE ]`      | [`IfExists()`](#ifexists)                                     |\n| `>`                | [`WriteFile()`](#writefile)                                   |\n| `>>`               | [`AppendFile()`](#appendfile)                                 |\n| `$*`               | [`Args()`](#args)                                             |\n| `basename`         | [`Basename()`](#basename)                                     |\n| `cat`              | [`File()`](#file) / [`Concat()`](#concat)                     |\n| `cut`              | [`Column()`](#column)                                         |\n| `dirname`          | [`Dirname()`](#dirname)                                       |\n| `echo`             | [`Echo()`](#echo)                                             |\n| `grep`             | [`Match()`](#match) / [`MatchRegexp()`](#matchregexp)         |\n| `grep -v`          | [`Reject()`](#reject) / [`RejectRegexp()`](#rejectregexp)     |\n| `head`             | [`First()`](#first)                                           |\n| `ls`               | [`ListFiles()`](#listfiles)                                   |\n| `sed`              | [`Replace()`](#replace) / [`ReplaceRegexp()`](#replaceregexp) |\n| `tail`             | [`Last()`](#last)                                             |\n| `uniq -c`          | [`Freq()`](#freq)                                             |\n| `wc -l`            | [`CountLines()`](#countlines)                                 |\n\n# Sources, filters, and sinks\n\n`script` provides three types of pipe operations: sources, filters, and sinks.\n\n1. _Sources_ create pipes from input in some way (for example, `File()` opens a file).\n2. _Filters_ read from a pipe and filter the data in some way (for example `Match()` passes on only lines which contain a given string).\n3. _Sinks_ get the output from a pipeline in some useful form (for example `String()` returns the contents of the pipe as a string), along with any error status.\n\nLet\'s look at the source, filter, and sink options that `script` provides.\n\n# Sources\n\nThese are operations which create a pipe.\n\n## Args\n\n`Args()` creates a pipe containing the program\'s command-line arguments, one per line.\n\n```go\np := script.Args()\noutput, err := p.String()\nfmt.Println(output)\n// Output: command-line arguments\n```\n\n## Echo\n\n`Echo()` creates a pipe containing a given string:\n\n```go\np := script.Echo("Hello, world!")\noutput, err := p.String()\nfmt.Println(output)\n// Output: Hello, world!\n```\n\n## Exec\n\n`Exec()` runs a given command and creates a pipe containing its combined output (`stdout` and `stderr`). If there was an error running the command, the pipe\'s error status will be set.\n\n```go\np := script.Exec("echo hello")\noutput, err := p.String()\nfmt.Println(output)\n// Output: hello\n```\n\nNote that `Exec()` can also be used as a filter, in which case the given command will read from the pipe as its standard input.\n\n### Exit status\n\nIf the command returns a non-zero exit status, the pipe\'s error status will be set to the string "exit status X", where X is the integer exit status.\n\n```go\np := script.Exec("ls doesntexist")\noutput, err := p.String()\nfmt.Println(err)\n// Output: exit status 1\n```\n\nFor convenience, you can get this value directly as an integer by calling `ExitStatus()` on the pipe:\n\n```go\n\np := script.Exec("ls doesntexist")\nvar exit int = p.ExitStatus()\nfmt.Println(exit)\n// Output: 1\n```\n\nThe value of `ExitStatus()` will be zero unless the pipe\'s error status matches the string "exit status X", where X is a non-zero integer.\n\n### Error output\n\nEven in the event of a non-zero exit status, the command\'s output will still be available in the pipe. This is often helpful for debugging. However, because `String()` is a no-op if the pipe\'s error status is set, if you want output you will need to reset the error status before calling `String()`:\n\n```go\np := Exec("man bogus")\np.SetError(nil)\noutput, err := p.String()\nfmt.Println(output)\n// Output: No manual entry for bogus\n```\n\n## File\n\n`File()` creates a pipe that reads from a file.\n\n```go\np = script.File("test.txt")\noutput, err := p.String()\nfmt.Println(output)\n// Output: contents of file\n```\n\n## IfExists\n\n`IfExists()` tests whether the specified file exists. If so, the returned pipe will have no error status. If it doesn\'t exist, the returned pipe will have an appropriate error set.\n\n```go\np = script.IfExists("doesntexist.txt")\noutput, err := p.String()\nfmt.Println(err)\n// Output: stat doesntexist.txt: no such file or directory\n```\n\nThis can be used to create pipes which take some action only if a certain file exists:\n\n```go\nscript.IfExists("/foo/bar").Exec("/usr/bin/yada")\n```\n\n## ListFiles\n\n`ListFiles()` lists files, like Unix [`ls`](examples/ls/main.go). It creates a pipe containing all files and directories matching the supplied path specification, one per line. This can be the name of a directory (`/path/to/dir`), the name of a file (`/path/to/file`), or a _glob_ (wildcard expression) conforming to the syntax accepted by [filepath.Match()](https://golang.org/pkg/path/filepath/#Match) (`/path/to/*`).\n\n```go\np := script.ListFiles("/tmp/*.php")\nfiles, err := p.String()\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Println("found suspicious PHP files in /tmp:")\nfmt.Println(files)\n```\n\n## Slice\n\n`Slice()` creates a pipe from a slice of strings, one per line.\n\n```go\np := Slice([]string{"1", "2", "3"})\noutput, err := p.String()\nfmt.Println(output)\n// Output:\n1\n2\n3\n```\n\n## Stdin\n\n`Stdin()` creates a pipe which reads from the program\'s standard input.\n\n```go\np := script.Stdin()\noutput, err := p.String()\nfmt.Println(output)\n// Output: [contents of standard input]\n```\n\n# Filters\n\nFilters are operations on an existing pipe that also return a pipe, allowing you to chain filters indefinitely.\n\n## Basename\n\n`Basename()` reads a list of filepaths from the pipe, one per line, and removes any leading directory components from each line (so, for example, `/usr/local/bin/foo` would become just `foo`). This is the complement of [Dirname](#dirname).\n\nIf a line is empty, `Basename()` will produce a single dot: `.`. Trailing slashes are removed.\n\nExamples:\n\n| Input              | `Basename` output |\n| ------------------ | ----------------- |\n|                    | `.`               |\n| `/`                | `.`               |\n| `/root`            | `root`            |\n| `/tmp/example.php` | `example.php`     |\n| `/var/tmp/`        | `tmp`             |\n| `./src/filters`    | `filters`         |\n| `C:/Program Files` | `Program Files`   |\n\n## Column\n\n`Column()` reads input tabulated by whitespace, and outputs only the Nth column of each input line (like Unix `cut`). Lines containing less than N columns will be ignored.\n\nFor example, given this input:\n\n```\n  PID   TT  STAT      TIME COMMAND\n    1   ??  Ss   873:17.62 /sbin/launchd\n   50   ??  Ss    13:18.13 /usr/libexec/UserEventAgent (System)\n   51   ??  Ss    22:56.75 /usr/sbin/syslogd\n```\n\nand this program:\n\n```go\nscript.Stdin().Column(1).Stdout()\n```\n\nthis will be the output:\n\n```\nPID\n1\n50\n51\n```\n\n## Concat\n\n`Concat()` reads a list of filenames from the pipe, one per line, and creates a pipe which concatenates the contents of those files. For example, if you have files `a`, `b`, and `c`:\n\n```go\noutput, err := Echo("a\\nb\\nc\\n").Concat().String()\nfmt.Println(output)\n// Output: contents of a, followed by contents of b, followed\n// by contents of c\n```\n\nThis makes it convenient to write programs which take a list of input files on the command line, for example:\n\n```go\nfunc main() {\n\tscript.Args().Concat().Stdout()\n}\n```\n\nThe list of files could also come from a file:\n\n```go\n// Read all files in filelist.txt\np := File("filelist.txt").Concat()\n```\n\n...or from the output of a command:\n\n```go\n// Print all config files to the terminal.\np := Exec("ls /var/app/config/").Concat().Stdout()\n```\n\nEach input file will be closed once it has been fully read.\n\n## Dirname\n\n`Dirname()` reads a list of pathnames from the pipe, one per line, and returns a pipe which contains only the parent directories of each pathname (so, for example, `/usr/local/bin/foo` would become just `/usr/local/bin`). This is the complement of [Basename](#basename).\n\nIf a line is empty, `Dirname()` will convert it to a single dot: `.` (this is the behaviour of Unix `dirname` and the Go standard library\'s `filepath.Dir`).\n\nTrailing slashes are removed, unless `Dirname()` returns the root folder.\n\nExamples:\n\n| Input              | `Dirname` output |\n| ------------------ | ---------------- |\n|                    | `.`              |\n| `/`                | `/`              |\n| `/root`            | `/`              |\n| `/tmp/example.php` | `/tmp`           |\n| `/var/tmp/`        | `/var`           |\n| `./src/filters`    | `./src`          |\n| `C:/Program Files` | `C:`             |\n\n## EachLine\n\n`EachLine()` lets you create custom filters. You provide a function, and it will be called once for each line of input. If you want to produce output, your function can write to a supplied `strings.Builder`. The return value from EachLine is a pipe containing your output.\n\n```go\np := script.File("test.txt")\nq := p.EachLine(func(line string, out *strings.Builder) {\n\tout.WriteString("> " + line + "\\n")\n})\noutput, err := q.String()\nfmt.Println(output)\n```\n\n## Exec\n\n`Exec()` runs a given command, which will read from the pipe as its standard input, and returns a pipe containing the command\'s combined output (`stdout` and `stderr`). If there was an error running the command, the pipe\'s error status will be set.\n\nApart from connecting the pipe to the command\'s standard input, the behaviour of an `Exec()` filter is the same as that of an `Exec()` source.\n\n```go\n// `cat` copies its standard input to its standard output.\np := script.Echo("hello world").Exec("cat")\noutput, err := p.String()\nfmt.Println(output)\n// Output: hello world\n```\n\n## First\n\n`First()` reads its input and passes on the first N lines of it (like Unix [`head`](examples/head/main.go)):\n\n```go\nscript.Stdin().First(10).Stdout()\n```\n\n## Freq\n\n`Freq()` counts the frequencies of input lines, and outputs only the unique lines in the input, each prefixed with a count of its frequency, in descending order of frequency (that is, most frequent lines first). Lines with the same frequency will be sorted alphabetically. For example, given this input:\n\n```\nbanana\napple\norange\napple\nbanana\n```\n\nand a program like:\n\n```go\nscript.Stdin().Freq().Stdout()\n```\n\nthe output will be:\n\n```\n2 apple\n2 banana\n1 orange\n```\n\nThis is a common pattern in shell scripts to find the most frequently-occurring lines in a file:\n\n```sh\nsort testdata/freq.input.txt |uniq -c |sort -rn\n```\n\n`Freq()`\'s behaviour is like the combination of Unix `sort`, `uniq -c`, and `sort -rn` used here. You can use `Freq()` in combination with `First()` to get, for example, the ten most common lines in a file:\n\n```go\nscript.Stdin().Freq().First(10).Stdout()\n```\n\nLike `uniq -c`, `Freq()` left-pads its count values if necessary to make them easier to read:\n\n```\n10 apple\n 4 banana\n 2 orange\n 1 kumquat\n```\n\n## Join\n\n`Join()` reads its input and replaces newlines with spaces, preserving a terminating newline if there is one.\n\n```go\np := script.Echo("hello\\nworld\\n").Join()\noutput, err := p.String()\nfmt.Println(output)\n// Output: hello world\\n\n```\n\n## Last\n\n`Last()` reads its input and passes on the last N lines of it (like Unix [`tail`](examples/tail/main.go)):\n\n```go\nscript.Stdin().Last(10).Stdout()\n```\n\n## Match\n\n`Match()` returns a pipe containing only the input lines which match the supplied string:\n\n```go\np := script.File("test.txt").Match("Error")\n```\n\n## MatchRegexp\n\n`MatchRegexp()` is like `Match()`, but takes a compiled regular expression instead of a string.\n\n```go\np := script.File("test.txt").MatchRegexp(regexp.MustCompile(`E.*r`))\n```\n\n## Reject\n\n`Reject()` is the inverse of `Match()`. Its pipe produces only lines which _don\'t_ contain the given string:\n\n```go\np := script.File("test.txt").Match("Error").Reject("false alarm")\n```\n\n## RejectRegexp\n\n`RejectRegexp()` is like `Reject()`, but takes a compiled regular expression instead of a string.\n\n```go\np := script.File("test.txt").Match("Error").RejectRegexp(regexp.MustCompile(`false|bogus`))\n```\n\n## Replace\n\n`Replace()` returns a pipe which filters its input by replacing all occurrences of one string with another, like Unix `sed`:\n\n```go\np := script.File("test.txt").Replace("old", "new")\n```\n\n## ReplaceRegexp\n\n`ReplaceRegexp()` returns a pipe which filters its input by replacing all matches of a compiled regular expression with a supplied replacement string, like Unix `sed`:\n\n```go\np := script.File("test.txt").ReplaceRegexp(regexp.MustCompile("Gol[a-z]{1}ng"), "Go")\n```\n\n# Sinks\n\nSinks are operations which return some data from a pipe, ending the pipeline.\n\n## AppendFile\n\n`AppendFile()` is like `WriteFile()`, but appends to the destination file instead of overwriting it. It returns the number of bytes written, or an error:\n\n```go\nvar wrote int\nwrote, err := script.Echo("Got this far!").AppendFile("logfile.txt")\n```\n\n## Bytes\n\n`Bytes()` returns the contents of the pipe as a slice of byte, plus an error:\n\n```go\nvar data []byte\ndata, err := script.File("test.bin").Bytes()\n```\n\n## CountLines\n\n`CountLines()`, as the name suggests, counts lines in its input, and returns the number of lines as an integer, plus an error:\n\n```go\nvar numLines int\nnumLines, err := script.File("test.txt").CountLines()\n```\n\n## Read\n\n`Read()` behaves just like the standard `Read()` method on any `io.Reader`:\n\n```go\nbuf := make([]byte, 256)\nn, err := r.Read(buf)\n```\n\nBecause a Pipe is an `io.Reader`, you can use it anywhere you would use a file, network connection, and so on. You can pass it to `ioutil.ReadAll`, `io.Copy`, `json.NewDecoder`, and anything else which takes an `io.Reader`.\n\nUnlike most sinks, `Read()` does not read the whole contents of the pipe (unless the supplied buffer is big enough to hold them).\n\n## Stdout\n\n`Stdout()` writes the contents of the pipe to the program\'s standard output. It returns the number of bytes written, or an error:\n\n```go\np := Echo("hello world")\nwrote, err := p.Stdout()\n```\n\nIn conjunction with `Stdin()`, `Stdout()` is useful for writing programs which filter input. For example, here is a program which simply copies its input to its output, like `cat`:\n\n```go\nfunc main() {\n\tscript.Stdin().Stdout()\n}\n```\n\nTo filter only lines matching a string:\n\n```go\nfunc main() {\n\tscript.Stdin().Match("hello").Stdout()\n}\n```\n\n## String\n\n`String()` returns the contents of the pipe as a string, plus an error:\n\n```go\ncontents, err := script.File("test.txt").String()\n```\n\nNote that `String()`, like all sinks, consumes the complete output of the pipe, which closes the input reader automatically. Therefore, calling `String()` (or any other sink method) again on the same pipe will return an error:\n\n```go\np := script.File("test.txt")\n_, _ = p.String()\n_, err := p.String()\nfmt.Println(err)\n// Output: read test.txt: file already closed\n```\n\n## WriteFile\n\n`WriteFile()` writes the contents of the pipe to a named file. It returns the number of bytes written, or an error:\n\n```go\nvar wrote int\nwrote, err := script.File("source.txt").WriteFile("destination.txt")\n```\n\n# Examples\n\nSince `script` is designed to help you write system administration programs, a few simple examples of such programs are included in the [examples](examples/) directory:\n\n* [cat](examples/cat/main.go) (copies stdin to stdout)\n* [cat 2](examples/cat2/main.go) (takes a list of files on the command line and concatenates their contents to stdout)\n* [grep](examples/grep/main.go)\n* [head](examples/head/main.go)\n* [echo](examples/echo/main.go)\n* [tail](examples/tail/main.go)\n* [least_freq](examples/least_freq/main.go)\n* [visitors](examples/visitors/main.go)\n* [ls](examples/ls/main.go)\n\n[More examples would be welcome!](https://github.com/bitfield/script/pulls)\n\nIf you use `script` for real work (or, for that matter, real play), I\'m always very interested to hear about it. Drop me a line to john@bitfieldconsulting.com and tell me how you\'re using `script` and what you think of it!\n\n# How can I contribute?\n\nSee the [contributor\'s guide](CONTRIBUTING.md) for some helpful tips.\n'