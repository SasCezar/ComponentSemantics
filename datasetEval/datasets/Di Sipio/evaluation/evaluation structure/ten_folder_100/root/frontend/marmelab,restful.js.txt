b'<table>\n        <tr>\n            <td><img width="20" src="https://cdnjs.cloudflare.com/ajax/libs/octicons/8.5.0/svg/archive.svg" alt="archived" /></td>\n            <td><strong>Archived Repository</strong><br />\n            This code is no longer maintained. Feel free to fork it, but use it at your own risks.\n        </td>\n        </tr>\n</table>\n\n# restful.js [![Build Status](https://travis-ci.org/marmelab/restful.js.svg?branch=master)](https://travis-ci.org/marmelab/restful.js)\n\nA pure JS client for interacting with server-side RESTful resources. Think Restangular without Angular.\n\n*Note*: All examples written in this README use the ES6 specification.\n\n## Installation\n\nIt is available with bower or npm:\n\n```\nbower install restful.js\nnpm install restful.js\n```\n\nThe `dist` folder contains two built versions which you can use to include either restful.js or a standalone version.\nStandalone version already embeds `fetch`.\n\nAlternately, you can use a module loader like [webpack](http://webpack.github.io/).\n\n```js\nimport restful from \'restful.js\';\n```\n\n## Usage\n\n### Create a resource targeting your API\n\nRestful.js needs an HTTP backend in order to perform queries. Two http backend are currently available:\n* [fetch](https://github.com/github/fetch): For using restful.js in a browser.\n* [request](https://github.com/request/request): For using restful.js in Node.js.\nThere are defined as optional dependencies and therefore you must install them either with `npm` or `bower` depending your package manager.\n\nStart by defining the base endpoint for an API, for instance `http://api.example.com` with the good http backend.\n\nFor a browser build :\n```js\nimport whatwg-fetch;\nimport restful, { fetchBackend } from \'restful.js\';\n\nconst api = restful(\'http://api.example.com\', fetchBackend(fetch));\n```\n\nFor a node build :\n```js\nimport request from \'request\';\nimport restful, { requestBackend } from \'restful.js\';\n\nconst api = restful(\'http://api.example.com\', requestBackend(request));\n```\n\nFor those who prefers a ready-to-go version, pre built version of restful.js with fetch are available into the `dist` folder.\n\n### Collections and Members endpoints\n\nA *collection* is an API endpoint for a list of entities, for instance `http://api.example.com/articles`. Create it using the `all(name)` syntax:\n\n```js\nconst articlesCollection = api.all(\'articles\');  // http://api.example.com/articles\n```\n\n`articlesCollection` is just the description of the collection, the API wasn\'t fetched yet.\n\nA *member* is an API endpoint for a single entity, for instance `http://api.example.com/articles/1`. Create it using the `one(name, id)` syntax:\n\n```js\nconst articleMember = api.one(\'articles\', 1);  // http://api.example.com/articles/1\n```\n\nJust like above, `articleMember` is a description, not an entity.\n\nYou can chain `one()` and `all()` to target the required collection or member:\n\n```js\nconst articleMember = api.one(\'articles\', 1);  // http://api.example.com/articles/1\nconst commentsCollection = articleMember.all(\'comments\');  // http://api.example.com/articles/1/comments\n```\n\n#### Custom endpoint URL\n\nIn case you need to set a custom endpoint URL, you can use `custom` methods.\n\n```js\nconst articleCustom = api.custom(\'articles/beta\');  // http://api.example.com/articles/beta\n\n// you can add an absolute url\nconst articleCustom = api.custom(\'http://custom.url/articles/beta\', false);  // http://custom.url/articles/beta\n```\n\nA custom endpoint acts like a member, and therefore you can use `one` and `all` to chain other endpoint with it.\n\n#### Entities\n\nOnce you have collections and members endpoints, fetch them to get *entities*. Restful.js exposes `get()` and `getAll()` methods for fetching endpoints. Since these methods are asynchronous, they return a native Promise for response.\n\nIf your application does not support native Promise, you can use a [polyfill](https://github.com/jakearchibald/es6-promise).\n\n```js\nconst articleMember = api.one(\'articles\', 1);  // http://api.example.com/articles/1\narticleMember.get().then((response) => {\n    const articleEntity = response.body();\n\n    const article = articleEntity.data();\n    console.log(article.title); // hello, world!\n});\n\nconst commentsCollection = articleMember.all(\'comments\');  // http://api.example.com/articles/1/comments\ncommentsCollection.getAll().then((response) => {\n    const commentEntities = response.body();\n\n    commentEntities.forEach((commentEntity) => {\n        const comment = commentEntity.data();\n        console.log(comment.body);\n    })\n});\n```\n\n*Tip*: You can describe a member based on a collection *and* trigger the API fetch at the same time by calling `get(id)`:\n\n```js\n// fetch http://api.example.com/articles/1/comments/4\nconst articleMember = api.one(\'articles\', 1);\nconst commentMember = articleMember.one(\'comments\', 4);\ncommentMember.get().then((response) => {\n    //\n});\n// equivalent to\nconst commentsCollection = articleMember.all(\'comments\');\ncommentsCollection.get(4).then((response) => {\n    //\n});\n```\n\n### Response\nA response is made from the HTTP response fetched from the endpoint. It exposes `statusCode()`, `headers()`, and `body()` methods. For a `GET` request, the `body` method will return one or an array of entities. Therefore you can disable this hydration by calling `body(false)`.\n\n#### Headers \n\nFor most of cases, `headers` in a response will be a plain object with headers data, but for some browsers, that don\'t support iteration over [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) object, it will simply be returned as a [Headers object](https://developer.mozilla.org/en-US/docs/Web/API/Headers), so you can use `get` method from it to get required headers.\n    \n### Entity Data\n\nAn entity is made from the HTTP response data fetched from the endpoint. It exposes a `data()` method:\n\n```js\nconst articleCollection = api.all(\'articles\');  // http://api.example.com/articles\n\n// http://api.example.com/articles/1\napi.one(\'articles\', 1).get().then((response) => {\n    const articleEntity = response.body();\n\n    // if the server response was { id: 1, title: \'test\', body: \'hello\' }\n    const article = articleEntity.data();\n    article.title; // returns `test`\n    article.body; // returns `hello`\n    // You can also edit it\n    article.title = \'test2\';\n    // Finally you can easily update it or delete it\n    articleEntity.save(); // will perform a PUT request\n    articleEntity.delete(); // will perform a DELETE request\n}, (response) => {\n    // The reponse code is not >= 200 and < 400\n    throw new Error(\'Invalid response\');\n});\n```\n\nYou can also use the entity to continue exploring the API. Entities expose several other methods to chain calls:\n\n* `entity.one ( name, id )`: Query a member child of the entity.\n* `entity.all ( name )`: Query a collection child of the entity.\n* `entity.url ()`: Get the entity url.\n* `entity.save ( [, data [, params [, headers ]]] )`: Save the entity modifications by performing a POST request.\n* `entity.delete ( [, data [, params [, headers ]]] )`: Remove the entity by performing a DELETE request.\n* `entity.id ()`: Get the id of the entity.\n\n```js\nconst articleMember = api.one(\'articles\', 1);  // http://api.example.com/articles/1\nconst commentMember = articleMember.one(\'comments\', 3);  // http://api.example.com/articles/1/comments/3\ncommentMember.get()\n    .then((response) => {\n        const commentEntity = response.body();\n\n        // You can also call `all` and `one` on an entity\n        return comment.all(\'authors\').getAll(); // http://api.example.com/articles/1/comments/3/authors\n    }).then((response) => {\n        const authorEntities = response.body();\n\n        authorEntities.forEach((authorEntity) => {\n            const author = authorEntity.data();\n            console.log(author.name);\n        });\n    });\n```\n\n`entity.id()` will get the id from its data regarding of the `identifier` of its endpoint. If you are using another name than `id` you can modify it by calling `identifier()` on the endpoint.\n\n```js\nconst articleCollection = api.all(\'articles\');  // http://api.example.com/articles\narticleCollection.identifier(\'_id\'); // We use _id as id field\n\nconst articleMember = api.one(\'articles\', 1);  // http://api.example.com/articles/1\narticleMember.identifier(\'_id\'); // We use _id as id field\n```\n\nRestful.js uses an inheritance pattern when collections or members are chained. That means that when you configure a collection or a member, it will configure all the collection on members chained afterwards.\n\n```js\n// configure the api\napi.header(\'AuthToken\', \'test\');\napi.identifier(\'_id\');\n\nconst articlesCollection = api.all(\'articles\');\narticlesCollection.get(1); // will send the `AuthToken` header\n// You can configure articlesCollection, too\narticlesCollection.header(\'foo\', \'bar\');\narticlesCollection.one(\'comments\', 1).get(); // will send both the AuthToken and foo headers\n```\n\n## API Reference\n\nRestful.js exposes similar methods on collections, members and entities. The name are consistent, and the arguments depend on the context.\n\n### Collection methods\n\n* `addErrorInterceptor ( interceptor )`: Add an error interceptor. You can alter the whole error.\n* `addRequestInterceptor ( interceptor )`: Add a request interceptor. You can alter the whole request.\n* `addResponseInterceptor ( interceptor )`: Add a response interceptor. You can alter the whole response.\n* `custom ( name [, isRelative = true ] )`: Target a child member with a custom url.\n* `delete ( id [, data [, params [, headers ]]] )`: Delete a member in a collection. Returns a promise with the response.\n* `getAll ( [ params [, headers ]] )`: Get a full collection. Returns a promise with an array of entities.\n* `get ( id [, params [, headers ]] )`: Get a member in a collection. Returns a promise with an entity.\n* `head ( id [, params [, headers ]] )`: Perform a HEAD request on a member in a collection. Returns a promise with the response.\n* `header ( name, value )`: Add a header.\n* `headers ()`: Get all headers added to the collection.\n* `on ( event, listener )`: Add an event listener on the collection.\n* `once ( event, listener )`: Add an event listener on the collection which will be triggered only once.\n* `patch ( id [, data [, params [, headers ]]] )`: Patch a member in a collection. Returns a promise with the response.\n* `post ( [ data [, params [, headers ]]] )`: Create a member in a collection. Returns a promise with the response.\n* `put ( id [, data [, params [, headers ]]] )`: Update a member in a collection. Returns a promise with the response.\n* `url ()`: Get the collection url.\n\n```js\n// http://api.example.com/articles/1/comments/2/authors\nconst authorsCollection = api.one(\'articles\', 1).one(\'comments\', 2).all(\'authors\');\nauthorsCollection.getAll().then((authorEntities) => { /*  */ });\nauthorsCollection.get(1).then((authorEntity) => { /*  */ });\n```\n\n### Member methods\n\n* `addErrorInterceptor ( interceptor )`: Add an error interceptor. You can alter the whole error.\n* `addRequestInterceptor ( interceptor )`: Add a request interceptor. You can alter the whole request.\n* `addResponseInterceptor ( interceptor )`: Add a response interceptor. You can alter the whole response.\n* `all ( name )`: Target a child collection `name`.\n* `custom ( name [, isRelative = true ] )`: Target a child member with a custom url.\n* `delete ( [ data [, params [, headers ]]] )`: Delete a member. Returns a promise with the response.\n* `get ( [ params [, headers ]] )`: Get a member. Returns a promise with an entity.\n* `head ( [ params [, headers ]] )`: Perform a HEAD request on a member. Returns a promise with the response.\n* `header ( name, value )`: Add a header.\n* `headers ()`: Get all headers added to the member.\n* `on ( event, listener )`: Add an event listener on the member.\n* `once ( event, listener )`: Add an event listener on the member which will be triggered only once.\n* `one ( name, id )`: Target a child member in a collection `name`.\n* `patch ( [ data [, params [, headers ]]] )`: Patch a member. Returns a promise with the response.\n* `post ( [ data [, params [, headers ]]] )`: Create a member. Returns a promise with the response.\n* `put ( [ data [, params [, headers ]]] )`: Update a member. Returns a promise with the response.\n* `url ()`: Get the member url.\n\n```js\n// http://api.example.com/articles/1/comments/2\nconst commentMember = api.one(\'articles\', 1).one(\'comments\', 2);\ncommentMember.get().then((commentEntity) => { /*  */ });\ncommentMember.delete().then((data) => { /* */ });\n```\n\n### Interceptors\n\nAn error, response or request interceptor is a callback which looks like this:\n\n```js\nresource.addRequestInterceptor((config) => {\n    const { data, headers, method, params, url } = config;\n    // all args had been modified\n    return {\n        data,\n        params,\n        headers,\n        method,\n        url,\n    };\n\n    // just return modified arguments\n    return {\n        data,\n        headers,\n    };\n});\n\nresource.addResponseInterceptor((response, config) => {\n    const { data, headers, statusCode } = response;\n    // all args had been modified\n    return {\n        data,\n        headers,\n        statusCode\n    };\n\n    // just return modified arguments\n    return {\n        data,\n        headers,\n    };\n});\n\nresource.addErrorInterceptor((error, config) => {\n    const { message, response } = error;\n    // all args had been modified\n    return {\n        message,\n        response,\n    };\n\n    // just return modified arguments\n    return {\n        message,\n    };\n});\n```\n\n### Response methods\n\n* `body ()`: Get the HTTP body of the response. If it is a `GET` request, it will hydrate some entities. To get the raw body call it with `false` as argument.\n* `headers ()`: Get the HTTP headers of the response.\n* `statusCode ()`: Get the HTTP status code of the response.\n\n### Entity methods\n\n* `all ( name )`: Query a collection child of the entity.\n* `custom ( name [, isRelative = true ] )`: Target a child member with a custom url.\n* `data ()` : Get the JS object unserialized from the response body (which must be in JSON)\n* `id ()`: Get the id of the entity.\n* `one ( name, id )`: Query a member child of the entity.\n* `delete ( [, data [, params [, headers ]]] )`: Delete the member link to the entity. Returns a promise with the response.\n* `save ( [, data [, params [, headers ]]] )`: Update the member link to the entity. Returns a promise with the response.\n* `url ()`: Get the entity url.\n\n```js\n// http://api.example.com/articles/1/comments/2\nconst commentMember = api.one(\'articles\', 1).one(\'comments\', 2);\ncommentMember.get().then((commentEntity) => {\n    commentEntity.save();\n    commentEntity.remove();\n});\n```\n\n### Error Handling\n\nTo deal with errors, you can either use error interceptors, error callbacks on promise or error events.\n\n```js\nconst commentMember = resource.one(\'articles\', 1).one(\'comments\', 2);\ncommentMember\n    .get()\n    .then((commentEntity) => { /*  */ })\n    .catch((err) => {\n        // deal with the error\n    });\n\ncommentMember.on(\'error\', (error, config) => {\n    // deal with the error\n});\n```\n\n### Events\n\nAny endpoint (collection or member) is an event emitter. It emits `request`, `response` and `error` events. When it emits an event, it is propagated to all its parents. This way you can listen to all errors, requests and response on your restful instance by listening on your root endpoint.\n\n```js\napi.on(\'error\', (error, config) => {\n    // deal with the error\n});\n\napi.on(\'request\', (config) => {\n    // deal with the request\n});\n\napi.on(\'response\', (config) => {\n    // deal with the response\n});\n```\n\nWhen you use interceptors, endpoints will also emit `request:interceptor:pre`, `request:interceptor:post`, `response:interceptor:pre`, `response:interceptor:post`, `error:interceptor:pre` and `error:interceptor:post`:\n\n```js\napi.on(\'error:interceptor:pre\', (error, config, interceptorName) => {\n    // deal with the error\n});\n\napi.on(\'error:interceptor:post\', (error, config, interceptorName) => {\n    // deal with the error\n});\n\napi.on(\'request:interceptor:pre\', (config, interceptorName) => {\n    // deal with the request\n});\n\napi.on(\'request:interceptor:post\', (config, interceptorName) => {\n    // deal with the request\n});\n\napi.on(\'response:interceptor:pre\', (response, config, interceptorName) => {\n    // deal with the response\n});\n\napi.on(\'response:interceptor:post\', (response, config, interceptorName) => {\n    // deal with the response\n});\n```\n\nYou can also use `once` method to add a one shot event listener.\n\n## Development\n\nInstall dependencies:\n\n```sh\nmake install\n```\n\n### Development Build\n\nTo rebuild the JavaScript you must run: `make build-dev`.\n\nDuring development you can run `make watch` to trigger a build at each change.\n\n### Production build\n\nTo build for production (minified files) you must run: `make build`.\n\n### ES5 build\n\nTo build the ES5 files you must run: `make es5`.\n\n### Tests\n\n```sh\nmake test\n```\n\n## Contributing\n\nAll contributions are welcome and must pass the tests. If you add a new feature, please write tests for it.\n\n## License\n\nThis application is available under the [MIT License](https://github.com/marmelab/restful.js/blob/master/LICENSE), courtesy of [marmelab](http://marmelab.com).\n'