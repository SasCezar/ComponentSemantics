b'## Contents\n\n* [Stateless function](#stateless-function)\n* [JSX spread attributes](#jsx-spread-attributes)\n* [Destructuring arguments](#destructuring-arguments)\n* [Conditional rendering](#conditional-rendering)\n* [Children types](#children-types)\n* [Array as children](#array-as-children)\n* [Function as children](#function-as-children)\n* [Render callback](#render-callback)\n* [Children pass-through](#children-pass-through)\n* [Proxy component](#proxy-component)\n* [Style component](#style-component)\n* [Event switch](#event-switch)\n* [Layout component](#layout-component)\n* [Container component](#container-component)\n* [Higher-order component](#higher-order-component)\n* [State hoisting](#state-hoisting)\n* [Controlled input](#controlled-input)\n\n## Stateless function\n\n[Stateless functions](https://facebook.github.io/react/docs/components-and-props.html) are a brilliant way to define highly reusable components. They don\'t hold `state`; they\'re just functions.\n\n```js\nconst Greeting = () => <div>Hi there!</div>\n```\n\nThey get passed `props` and `context`.\n\n```js\nconst Greeting = (props, context) =>\n  <div style={{color: context.color}}>Hi {props.name}!</div>\n```\n\nThey can define local variables, where a function block is used.\n\n```js\nconst Greeting = (props, context) => {\n  const style = {\n    fontWeight: "bold",\n    color: context.color,\n  }\n\n  return <div style={style}>{props.name}</div>\n}\n```\n\nBut you could get the same result by using other functions.\n\n```js\nconst getStyle = context => ({\n  fontWeight: "bold",\n  color: context.color,\n})\n\nconst Greeting = (props, context) =>\n  <div style={getStyle(context)}>{props.name}</div>\n```\n\nThey can have defined `defaultProps`, `propTypes` and `contextTypes`.\n\n```js\nGreeting.propTypes = {\n  name: PropTypes.string.isRequired\n}\nGreeting.defaultProps = {\n  name: "Guest"\n}\nGreeting.contextTypes = {\n  color: PropTypes.string\n}\n```\n\n\n## JSX spread attributes\n\nSpread Attributes is a JSX feature. It\'s syntactic sugar for passing all of an object\'s properties as JSX attributes.\n\nThese two examples are equivalent.\n```js\n// props written as attributes\n<main className="main" role="main">{children}</main>\n\n// props "spread" from object\n<main {...{className: "main", role: "main", children}} />\n```\n\nUse this to forward `props` to underlying components.\n\n```js\nconst FancyDiv = props =>\n  <div className="fancy" {...props} />\n```\n\nNow, I can expect `FancyDiv` to add the attributes it\'s concerned with as well as those it\'s not.\n\n```js\n<FancyDiv data-id="my-fancy-div">So Fancy</FancyDiv>\n\n// output: <div className="fancy" data-id="my-fancy-div">So Fancy</div>\n```\n\nKeep in mind that order matters. If `props.className` is defined, it\'ll clobber the `className` defined by `FancyDiv`\n\n```js\n<FancyDiv className="my-fancy-div" />\n\n// output: <div className="my-fancy-div"></div>\n```\n\nWe can make `FancyDiv`s className always "win" by placing it after the spread props `({...props})`.\n\n```js\n// my `className` clobbers your `className`\nconst FancyDiv = props =>\n  <div {...props} className="fancy" />\n```\n\nYou should handle these types of props gracefully. In this case, I\'ll merge the author\'s `props.className` with the `className` needed to style my component.\n\n```js\nconst FancyDiv = ({ className, ...props }) =>\n  <div\n    className={["fancy", className].join(\' \')}\n    {...props}\n  />\n```\n\n\n## destructuring arguments\n\n[Destructuring assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) is an ES2015 feature. It pairs nicely with `props` in Stateless Functions.\n\nThese examples are equivalent.\n```js\nconst Greeting = props => <div>Hi {props.name}!</div>\n\nconst Greeting = ({ name }) => <div>Hi {name}!</div>\n```\n\nThe [rest parameter syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`...`) allows you to collect all the remaining properties in a new object.\n\n```js\nconst Greeting = ({ name, ...props }) =>\n  <div>Hi {name}!</div>\n```\n\nIn turn, this object can use [JSX Spread Attributes](#jsx-spread-attributes) to forward `props` to the composed component.\n\n```js\nconst Greeting = ({ name, ...props }) =>\n  <div {...props}>Hi {name}!</div>\n```\n\nAvoid forwarding non-DOM `props` to composed components. Destructuring makes this very easy because you can create a new `props` object **without** component-specific `props`.\n\n\n## conditional rendering\n\nYou can\'t use regular if/else conditions inside a component definition. [The conditional (ternary) operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator) is your friend.\n\n`if`\n\n```js\n{condition && <span>Rendered when `truthy`</span> }\n```\n\n`unless`\n\n```js\n{condition || <span>Rendered when `falsey`</span> }\n```\n\n`if-else` (tidy one-liners)\n\n```js\n{condition\n  ? <span>Rendered when `truthy`</span>\n  : <span>Rendered when `falsey`</span>\n}\n```\n\n`if-else` (big blocks)\n\n```js\n{condition ? (\n  <span>\n    Rendered when `truthy`\n  </span>\n) : (\n  <span>\n    Rendered when `falsey`\n  </span>\n)}\n```\n\n\n## Children types\n\nReact can render `children` of many types. In most cases it\'s either an `array` or a `string`.\n\n`string`\n\n```js\n<div>\n  Hello World!\n</div>\n```\n\n`array`\n\n```js\n<div>\n  {["Hello ", <span>World</span>, "!"]}\n</div>\n```\n\nFunctions may be used as children. However, it requires [coordination with the parent component](#render-callback) to be useful.\n\n`function`\n\n```js\n<div>\n  {(() => { return "hello world!"})()}\n</div>\n```\n\n\n## Array as children\n\nProviding an array as `children` is a very common. It\'s how lists are drawn in React.\n\nWe use `map()` to create an array of React Elements for every value in the array.\n\n```js\n<ul>\n  {["first", "second"].map((item) => (\n    <li>{item}</li>\n  ))}\n</ul>\n```\n\nThat\'s equivalent to providing a literal `array`.\n\n```js\n<ul>\n  {[\n    <li>first</li>,\n    <li>second</li>,\n  ]}\n</ul>\n```\n\nThis pattern can be combined with destructuring, JSX Spread Attributes, and other components, for some serious terseness.\n\n```js\n<ul>\n  {arrayOfMessageObjects.map(({ id, ...message }) =>\n    <Message key={id} {...message} />\n  )}\n</ul>\n```\n\n\n## Function as children\n\nUsing a function as `children` isn\'t inherently useful.\n\n```js\n<div>{() => { return "hello world!"}()}</div>\n```\n\nHowever, it can be used in component authoring for some serious power. This technique is commonly referred to as `render callbacks`.\n\nThis is a powerful technique used by libraries like [ReactMotion](https://github.com/chenglou/react-motion). When applied, rendering logic can be kept in the owner component, instead of being delegated.\n\nSee [Render callbacks](#render-callback), for more details.\n\n## Render callback\n\nHere\'s a component that uses a Render callback. It\'s not useful, but it\'s an easy illustration to start with.\n\n```js\nconst Width = ({ children }) => children(500)\n```\n\nThe component calls `children` as a function, with some number of arguments. Here, it\'s the number `500`.\n\nTo use this component, we give it a [function as `children`](#function-as-children).\n\n```js\n<Width>\n  {width => <div>window is {width}</div>}\n</Width>\n```\n\nWe get this output.\n\n```js\n<div>window is 500</div>\n```\n\nWith this setup, we can use this `width` to make rendering decisions.\n\n```js\n<Width>\n  {width =>\n    width > 600\n      ? <div>min-width requirement met!</div>\n      : null\n  }\n</Width>\n```\n\nIf we plan to use this condition a lot, we can define another components to encapsulate the reused logic.\n\n```js\nconst MinWidth = ({ width: minWidth, children }) =>\n  <Width>\n    {width =>\n      width > minWidth\n        ? children\n        : null\n    }\n  </Width>\n```\n\n\nObviously a static `Width` component isn\'t useful but one that watches the browser window is. Here\'s a sample implementation.\n\n```js\nclass WindowWidth extends React.Component {\n  constructor() {\n    super()\n    this.state = { width: 0 }\n  }\n\n  componentDidMount() {\n    this.setState(\n      {width: window.innerWidth},\n      window.addEventListener(\n        "resize",\n        ({ target }) =>\n          this.setState({width: target.innerWidth})\n      )\n    )\n  }\n\n  render() {\n    return this.props.children(this.state.width)\n  }\n}\n```\n\nMany developers favor [Higher Order Components](#higher-order-component) for this type of functionality. It\'s a matter of preference.\n\n\n## Children pass-through\n\nYou might create a component designed to apply `context` and render its `children`.\n\n```js\nclass SomeContextProvider extends React.Component {\n  getChildContext() {\n    return {some: "context"}\n  }\n\n  render() {\n    // how best do we return `children`?\n  }\n}\n```\n\nYou\'re faced with a decision. Wrap `children` in an extraneous `<div />` or return `children` directly. The first options gives you extra markup (which can break some stylesheets). The second will result in unhelpful errors.\n\n```js\n// option 1: extra div\nreturn <div>{children}</div>\n\n// option 2: unhelpful errors\nreturn children\n```\n\nIt\'s best to treat `children` as an opaque data type. React provides `React.Children` for dealing with `children` appropriately.\n\n```js\nreturn React.Children.only(this.props.children)\n```\n\n## Proxy component\n\n*(I\'m not sure if this name makes sense)*\n\nButtons are everywhere in web apps. And every one of them must have the `type` attribute set to "button".\n\n```js\n<button type="button">\n```\n\nWriting this attribute hundreds of times is error prone. We can write a higher level component to proxy `props` to a lower-level `button` component.\n\n```js\nconst Button = props =>\n  <button type="button" {...props}>\n```\n\nWe can use `Button` in place of `button` and ensure that the `type` attribute is consistently applied everywhere.\n\n```js\n<Button />\n// <button type="button"><button>\n\n<Button className="CTA">Send Money</Button>\n// <button type="button" class="CTA">Send Money</button>\n```\n\n## Style component\n\nThis is a [Proxy component](#proxy-component) applied to the practices of style.\n\nSay we have a button. It uses classes to be styled as a "primary" button.\n\n```js\n<button type="button" className="btn btn-primary">\n```\n\nWe can generate this output using a couple single-purpose components.\n\n```js\nimport classnames from \'classnames\'\n\nconst PrimaryBtn = props =>\n  <Btn {...props} primary />\n\nconst Btn = ({ className, primary, ...props }) =>\n  <button\n    type="button"\n    className={classnames(\n      "btn",\n      primary && "btn-primary",\n      className\n    )}\n    {...props}\n  />\n```\n\nIt can help to visualize this.\n\n```js\nPrimaryBtn()\n  \xe2\x86\xb3 Btn({primary: true})\n    \xe2\x86\xb3 Button({className: "btn btn-primary"}, type: "button"})\n      \xe2\x86\xb3 \'<button type="button" class="btn btn-primary"></button>\'\n```\n\nUsing these components, all of these result in the same output.\n```js\n<PrimaryBtn />\n<Btn primary />\n<button type="button" className="btn btn-primary" />\n```\n\nThis can be a huge boon to style maintenance. It isolates all concerns of style to a single component.\n\n## Event switch\n\n\nWhen writing event handlers it\'s common to adopt the `handle{eventName}` naming convention.\n\n```js\nhandleClick(e) { /* do something */ }\n```\n\nFor components that handle several event types, these function names can be repetitive. The names themselves might not provide much value, as they simply proxy to other actions/functions.\n\n```js\nhandleClick() { require("./actions/doStuff")(/* action stuff */) }\nhandleMouseEnter() { this.setState({ hovered: true }) }\nhandleMouseLeave() { this.setState({ hovered: false }) }\n```\n\nConsider writing a single event handler for your component and switching on `event.type`.\n\n```js\nhandleEvent({type}) {\n  switch(type) {\n    case "click":\n      return require("./actions/doStuff")(/* action dates */)\n    case "mouseenter":\n      return this.setState({ hovered: true })\n    case "mouseleave":\n      return this.setState({ hovered: false })\n    default:\n      return console.warn(`No case for event type "${type}"`)\n  }\n}\n```\n\nAlternatively, for simple components, you can call imported actions/functions directly from components, using arrow functions.\n\n```js\n<div onClick={() => someImportedAction({ action: "DO_STUFF" })}\n```\n\nDon\'t fret about performance optimizations until you have problems. Seriously don\'t.\n\n\n## Layout component\n\n\nLayout components result in some form of static DOM element. It might not need to update frequently, if ever.\n\nConsider a component that renders two `children` side-by-side.\n\n```js\n<HorizontalSplit\n  leftSide={<SomeSmartComponent />}\n  rightSide={<AnotherSmartComponent />}\n/>\n```\n\nWe can aggressively optimize this component.\n\nWhile `HorizontalSplit` will be `parent` to both components, it will never be their `owner`. We can tell it to update never, without interrupting the lifecycle of the components inside.\n\n```js\nclass HorizontalSplit extends React.Component {\n  shouldComponentUpdate() {\n    return false\n  }\n\n  render() {\n    <FlexContainer>\n      <div>{this.props.leftSide}</div>\n      <div>{this.props.rightSide}</div>\n    </FlexContainer>\n  }\n}\n```\n\n\n## Container component\n\n"A container does data fetching and then renders its corresponding sub-component. That\xe2\x80\x99s it."&mdash;[Jason Bonta](https://twitter.com/jasonbonta)\n\nGiven this reusable `CommentList` component.\n\n```js\nconst CommentList = ({ comments }) =>\n  <ul>\n    {comments.map(comment =>\n      <li>{comment.body}-{comment.author}</li>\n    )}\n  </ul>\n```\n\nWe can create a new component responsible for fetching data and rendering the stateless `CommentList` component.\n\n```js\nclass CommentListContainer extends React.Component {\n  constructor() {\n    super()\n    this.state = { comments: [] }\n  }\n\n  componentDidMount() {\n    $.ajax({\n      url: "/my-comments.json",\n      dataType: \'json\',\n      success: comments =>\n        this.setState({comments: comments});\n    })\n  }\n\n  render() {\n    return <CommentList comments={this.state.comments} />\n  }\n}\n```\n\nWe can write different containers for different application contexts.\n\n\n## Higher-order component\n\nA [higher-order function](https://en.wikipedia.org/wiki/Higher-order_function) is a function that takes and/or returns a function. It\'s not more complicated than that. So, what\'s a higher-order component?\n\nIf you\'re already using [container components](#container-component), these are just generic containers, wrapped up in a function.\n\nLet\'s start with our stateless `Greeting` component.\n\n```js\nconst Greeting = ({ name }) => {\n  if (!name) { return <div>Connecting...</div> }\n\n  return <div>Hi {name}!</div>\n}\n```\n\nIf it gets `props.name`, it\'s gonna render that data. Otherwise it\'ll say that it\'s "Connecting...". Now for the the higher-order bit.\n\n```js\nconst Connect = ComposedComponent =>\n  class extends React.Component {\n    constructor() {\n      super()\n      this.state = { name: "" }\n    }\n\n    componentDidMount() {\n      // this would fetch or connect to a store\n      this.setState({ name: "Michael" })\n    }\n\n    render() {\n      return (\n        <ComposedComponent\n          {...this.props}\n          name={this.state.name}\n        />\n      )\n    }\n  }\n```\n\nThis is just a function that returns component that renders the component we passed as an argument.\n\nLast step, we need to wrap our our `Greeting` component in `Connect`.\n\n```js\nconst ConnectedMyComponent = Connect(Greeting)\n```\n\nThis is a powerful pattern for providing fetching and providing data to any number of [stateless function components](#stateless-function).\n\n## State hoisting\n[Stateless functions](#stateless-function) don\'t hold state (as the name implies).\n\nEvents are changes in state.\nTheir data needs to be passed to stateful [container components](#container-component) parents.\n\nThis is called "state hoisting".\nIt\'s accomplished by passing a callback from a container component to a child component.\n\n```js\nclass NameContainer extends React.Component {\n  render() {\n    return <Name onChange={newName => alert(newName)} />\n  }\n}\n\nconst Name = ({ onChange }) =>\n  <input onChange={e => onChange(e.target.value)} />\n```\n\n`Name` receives an `onChange` callback from `NameContainer` and calls on events.\n\nThe `alert` above makes for a terse demo but it\'s not changing state.\nLet\'s change the internal state of `NameContainer`.\n\n```js\nclass NameContainer extends React.Component {\n  constructor() {\n    super()\n    this.state = {name: ""}\n  }\n\n  render() {\n    return <Name onChange={newName => this.setState({name: newName})} />\n  }\n}\n```\n\nThe state is _hoisted_ to the container, by the provided callback, where it\'s used to update local state.\nThis sets a nice clear boundary and maximizes the re-usability of stateless function.\n\nThis pattern isn\'t limited to stateless functions.\nBecause stateless function don\'t have lifecycle events,\nyou\'ll use this pattern with component classes as well.\n\n*[Controlled input](#controlled-input) is an important pattern to know for use with state hoisting*\n\n*(It\'s best to process the event object on the stateful component)*\n\n\n## Controlled input\nIt\'s hard to talk about controlled inputs in the abstract.\nLet\'s start with an uncontrolled (normal) input and go from there.\n\n```js\n<input type="text" />\n```\n\nWhen you fiddle with this input in the browser, you see your changes.\nThis is normal.\n\nA controlled input disallows the DOM mutations that make this possible.\nYou set the `value` of the input in component-land and it doesn\'t change in DOM-land.\n\n```js\n<input type="text" value="This won\'t change. Try it." />\n```\n\nObviously static inputs aren\'t very useful to your users.\nSo, we derive a `value` from state.\n\n```js\nclass ControlledNameInput extends React.Component {\n  constructor() {\n    super()\n    this.state = {name: ""}\n  }\n\n  render() {\n    return <input type="text" value={this.state.name} />\n  }\n}\n```\n\nThen, changing the input is a matter of changing component state.\n\n```js\n    return (\n      <input\n        value={this.state.name}\n        onChange={e => this.setState({ name: e.target.value })}\n      />\n    )\n```\n\nThis is a controlled input.\nIt only updates the DOM when state has changed in our component.\nThis is invaluable when creating consistent UIs.\n\n*If you\'re using [stateless functions](#stateless-function) for form elements,\nread about using [state hoisting](#state-hoisting) to move new state up the component tree.*\n'