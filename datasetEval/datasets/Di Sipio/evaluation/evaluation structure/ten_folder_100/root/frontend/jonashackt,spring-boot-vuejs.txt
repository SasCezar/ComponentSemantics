b'# spring-boot-vuejs\n\n[![Build Status](https://travis-ci.org/jonashackt/spring-boot-vuejs.svg?branch=master)](https://travis-ci.org/jonashackt/spring-boot-vuejs)\n[![Coverage Status](https://coveralls.io/repos/github/jonashackt/spring-boot-vuejs/badge.svg?branch=master)](https://coveralls.io/github/jonashackt/spring-boot-vuejs?branch=master)\n[![License](http://img.shields.io/:license-mit-blue.svg)](https://github.com/jonashackt/spring-boot-vuejs/blob/master/LICENSE)\n[![renovateenabled](https://img.shields.io/badge/renovate-enabled-yellow)](https://renovatebot.com)\n[![versionspringboot](https://img.shields.io/badge/dynamic/xml?color=brightgreen&url=https://raw.githubusercontent.com/jonashackt/spring-boot-vuejs/master/pom.xml&query=%2F%2A%5Blocal-name%28%29%3D%27project%27%5D%2F%2A%5Blocal-name%28%29%3D%27parent%27%5D%2F%2A%5Blocal-name%28%29%3D%27version%27%5D&label=springboot)](https://github.com/spring-projects/spring-boot)\n[![versionjava](https://img.shields.io/badge/jdk-8,_9,_11-brightgreen.svg?logo=java)](https://github.com/spring-projects/spring-boot)\n[![versionvuejs](https://img.shields.io/badge/dynamic/json?color=brightgreen&url=https://raw.githubusercontent.com/jonashackt/spring-boot-vuejs/master/frontend/package.json&query=$.dependencies.vue&label=vue&logo=vue.js)](https://vuejs.org/)\n[![versionnodejs](https://img.shields.io/badge/dynamic/xml?color=brightgreen&url=https://raw.githubusercontent.com/jonashackt/spring-boot-vuejs/master/frontend/pom.xml&query=%2F%2A%5Blocal-name%28%29%3D%27project%27%5D%2F%2A%5Blocal-name%28%29%3D%27build%27%5D%2F%2A%5Blocal-name%28%29%3D%27plugins%27%5D%2F%2A%5Blocal-name%28%29%3D%27plugin%27%5D%2F%2A%5Blocal-name%28%29%3D%27executions%27%5D%2F%2A%5Blocal-name%28%29%3D%27execution%27%5D%2F%2A%5Blocal-name%28%29%3D%27configuration%27%5D%2F%2A%5Blocal-name%28%29%3D%27nodeVersion%27%5D&label=nodejs&logo=node.js)](https://nodejs.org/en/)\n[![versionwebpack](https://img.shields.io/badge/dynamic/json?color=brightgreen&url=https://raw.githubusercontent.com/jonashackt/spring-boot-vuejs/master/frontend/package-lock.json&query=$.dependencies.webpack.version&label=webpack&logo=webpack)](https://webpack.js.org/)\n[![versionaxios](https://img.shields.io/badge/dynamic/json?color=brightgreen&url=https://raw.githubusercontent.com/jonashackt/spring-boot-vuejs/master/frontend/package.json&query=$.dependencies.axios&label=axios)](https://github.com/axios/axios)\n[![versionjest](https://img.shields.io/badge/dynamic/json?color=brightgreen&url=https://raw.githubusercontent.com/jonashackt/spring-boot-vuejs/master/frontend/package-lock.json&query=$.dependencies.jest.version&label=jest&logo=jest)](https://jestjs.io/)\n[![versionnightwatch](https://img.shields.io/badge/dynamic/json?color=brightgreen&url=https://raw.githubusercontent.com/jonashackt/spring-boot-vuejs/master/frontend/package-lock.json&query=$.dependencies.nightwatch.version&label=nightwatch)](http://nightwatchjs.org/)\n[![Deployed on Heroku](https://img.shields.io/badge/heroku-deployed-blueviolet.svg?logo=heroku)](https://spring-boot-vuejs.herokuapp.com/)\n[![Pushed to Docker Hub](https://img.shields.io/badge/docker_hub-released-blue.svg?logo=docker)](https://hub.docker.com/r/jonashackt/spring-boot-vuejs)\n    \n> **If you\xc2\xb4re a JavaMagazin / blog.codecentric.de / Softwerker reader**, consider switching to [vue-cli-v2-webpack-v3](https://github.com/jonashackt/spring-boot-vuejs/tree/vue-cli-v2-webpack-v3)\n\n![localhost-first-run](screenshots/localhost-first-run.png)\n\nA live deployment is available on Heroku: https://spring-boot-vuejs.herokuapp.com\n\nThis project is used as example in a variety of articles & as eBook:\n\n[![java-magazin-8.2018](screenshots/java-magazin-8.2018.png)](https://jaxenter.de/ausgaben/java-magazin-8-18)\n[![entwickler-press-092018](screenshots/entwickler-press-092018.jpg)](https://www.amazon.com/Vue-js-f%C3%BCr-alle-Wissenswertes-Einsteiger-ebook/dp/B07HQF9VX4/ref=sr_1_1?ie=UTF8&qid=1538484852&sr=8-1&keywords=Vue-js-f%C3%BCr-alle-Wissenswertes-Einsteiger-ebook)\n[![softwerker-vol12](screenshots/softwerker-vol12.png)](https://info.codecentric.de/softwerker-vol-12)\n\n[blog.codecentric.de/en/2018/04/spring-boot-vuejs](https://blog.codecentric.de/en/2018/04/spring-boot-vuejs) | [JavaMagazin 8.2018](https://jaxenter.de/ausgaben/java-magazin-8-18) | [entwickler.press shortcuts 229](https://www.amazon.com/Vue-js-f%C3%BCr-alle-Wissenswertes-Einsteiger-ebook/dp/B07HQF9VX4/ref=sr_1_1?ie=UTF8&qid=1538484852&sr=8-1&keywords=Vue-js-f%C3%BCr-alle-Wissenswertes-Einsteiger-ebook) | [softwerker Vol.12](https://info.codecentric.de/softwerker-vol-12)\n\n## Table of Contents  \n* [In Search of a new Web Frontend-Framework after 2 Years of absence...](#in-search-of-a-new-web-frontend-framework-after-2-years-of-absence)\n* [Setup Vue.js & Spring Boot](#setup-vuejs--spring-boot)\n* [Project setup](#project-setup)\n* [Backend](#backend)\n* [Frontend](#frontend)\n  * [Use frontend-maven-plugin to handle NPM, Node, Bower, Grunt, Gulp, Webpack and so on :)](#use-frontend-maven-plugin-to-handle-npm-node-bower-grunt-gulp-webpack-and-so-on-)\n* [First App run](first-app-run)\n* [Faster feedback with webpack-dev-server](#faster-feedback-with-webpack-dev-server)\n* [Browser developer tools extension](#browser-developer-tools-extension)\n* [HTTP calls from Vue.js to (Spring Boot) REST backend](#http-calls-from-vuejs-to-spring-boot-rest-backend)\n  * [The problem with SOP](#the-problem-with-sop)\n  * [Enabling Axios CORS support](#enabling-axios-cors-support)\n  * [Enabling Spring Boot CORS support](#enabling-spring-boot-cors-support)\n  * [But STOP! Webpack & Vue have something much smarter for us to help us with SOP!](#but-stop-webpack--vue-have-something-much-smarter-for-us-to-help-us-with-sop)\n* [Using history mode for nicer URLs](#using-history-mode-for-nicer-urls)\n* [Bootstrap & Vue.js](#bootstrap--vuejs)\n* [Heroku Deployment](#heroku-deployment)\n  * [Using Heroku\'s Postgres as Database for Spring Boot backend and Vue.js frontend](#using-herokus-postgres-as-database-for-spring-boot-backend-and-vuejs-frontend)\n* [Testing](#testing)\n* [Jest](#jest)\n  * [Jest Configuration](#jest-configuration)\n  * [Integration in Maven build (via frontend-maven-plugin)](#integration-in-maven-build-via-frontend-maven-plugin)\n  * [Run Jest tests inside IntelliJ](#run-jest-tests-inside-intellij)\n* [End-2-End (E2E) tests with Nightwatch](#end-2-end-e2e-tests-with-nightwatch)\n  * [Write Nightwatch tests](#write-nightwatch-tests)\n* [NPM Security](#npm-security)\n* [Shift from templates to plugin-based architecture in Vue Cli 3](#shift-from-templates-to-plugin-based-architecture-in-vue-cli-3)\n  * [OMG! My package.json is so small - Vue CLI 3 Plugins](#omg-my-packagejson-is-so-small---vue-cli-3-plugins)\n  * [The vue.config.js file](#the-vueconfigjs-file)\n* [Build and run with Docker](#build-and-run-with-docker)\n  * [Autorelease to Docker Hub on hub.docker.com](#autorelease-to-docker-hub-on-hubdockercom)\n* [Run with JDK 8, 9 or 11ff](#run-with-jdk-8-9-or-11-ff)\n* [Secure Spring Boot backend and protect Vue.js frontend](#secure-spring-boot-backend-and-protect-vuejs-frontend)\n  * [Secure the backend API with Spring Security](#secure-the-backend-api-with-spring-security)\n  * [Configure Spring Security](#configure-spring-security)\n  * [Be aware of CSRF!](#be-aware-of-csrf)\n  * [Testing the secured Backend](#testing-the-secured-backend)\n  * [Configure credentials inside application.properties and environment variables](#configure-credentials-inside-applicationproperties-and-environment-variables)\n  * [Protect parts of Vue.js frontend](#protect-parts-of-vuejs-frontend)\n  * [Create a new Vue Login component](#create-a-new-vue-login-component)\n  * [Protect multiple Vue.js components](#protect-multiple-vuejs-components)\n  * [Store login information with vuex](#store-login-information-with-vuex)\n  * [Define the vuex state](#define-the-vuex-state)\n  * [Define a vuex action login() and the mutations login_success & login_error](#define-a-vuex-action-login-and-the-mutations-login_success--login_error)\n  * [Last but not least: define getters for the vuex state](#last-but-not-least-define-getters-for-the-vuex-state)\n  * [Use vuex Store inside the Login component and forward to Protected.vue, if Login succeeded](#use-vuex-store-inside-the-login-component-and-forward-to-protectedvue-if-login-succeeded)\n  * [Redirect user from Protected.vue to Login.vue, if not authenticated before](#redirect-user-from-protectedvue-to-loginvue-if-not-authenticated-before)\n  * [Check auth state at secured backend endpoints](#check-auth-state-at-secured-backend-endpoints)\n\n\n\n## In Search of a new Web Frontend-Framework after 2 Years of absence...\n\nWell, I\xe2\x80\x99m not a Frontend developer. I\xe2\x80\x99m more like playing around with Spring Boot, Web- & Microservices & Docker, automating things with Ansible and Docker, Scaling things with Spring Cloud, Docker Compose, and Traefik... And the only GUIs I\xe2\x80\x99m building are the "new JS framework in town"-app every two years... :) So the last one was Angular 1 - and it felt, as it was a good choice! I loved the coding experience and after a day of training, I felt able to write awesome Frontends...\n\nBut now we\xe2\x80\x99re 2 years later and I heard from afar, that there was a complete rewrite of Angular (2), a new kid in town from Facebook (React) and lots of ES201x stuff and dependency managers like bower and Co. So I\xe2\x80\x99m now in the new 2-year-cycle of trying to cope up again - and so glad I found this article: https://medium.com/reverdev/why-we-moved-from-angular-2-to-vue-js-and-why-we-didnt-choose-react-ef807d9f4163\n\nKey points are:\n* Angular 2 isn\xe2\x80\x99t the way to go if you know version 1 (complete re-write, only with Typescript, loss of many of 1\xe2\x80\x99s advantages, Angular 4 is coming)\n* React  (facebookish problems (licence), need to choose btw. Redux & MObX, harder learning curve, slower coding speed)\n\n![comparison-angular-react-vuejs](screenshots/comparison-angular-react-vuejs.png)\n\nAnd the [introduction phrase](https://vuejs.org/v2/guide/index.html) sounds really great:\n\n> Vue (pronounced /vju\xcb\x90/, like view) is a progressive framework for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only and is very easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with modern tooling and supporting libraries.\n\nSo I think, it could be a good idea to invest a day or so into Vue.js. Let\xe2\x80\x99s have a look here!\n\n\n\n## Setup Vue.js & Spring Boot\n\n### Prerequisites\n\n#### MacOSX\n\n```\nbrew install node\nnpm install -g @vue/cli\n```\n\n#### Linux\n\n```\nsudo apt update\nsudo apt install node\nnpm install -g @vue/cli\n```\n\n#### Windows\n\n```\nchoco install npm\nnpm install -g @vue/cli\n```\n\n## Project setup\n\n```\nspring-boot-vuejs\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\xac backend     \xe2\x86\x92 backend module with Spring Boot code\n\xe2\x94\x82 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 src\n\xe2\x94\x82 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 pom.xml\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\xac frontend    \xe2\x86\x92 frontend module with Vue.js code\n\xe2\x94\x82 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 src\n\xe2\x94\x82 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 pom.xml\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 pom.xml     \xe2\x86\x92 Maven parent pom managing both modules\n```\n\n## Backend\n\nGo to https://start.spring.io/ and initialize a Spring Boot app with `Web` and `Actuator`. Place the zip\xe2\x80\x99s contents in the backend folder.\n\nCustomize pom to copy content from Frontend for serving it later with the embedded Tomcat:\n\n```xml\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-maven-plugin</artifactId>\n    </plugin>\n    <plugin>\n      <artifactId>maven-resources-plugin</artifactId>\n      <executions>\n        <execution>\n          <id>copy Vue.js frontend content</id>\n          <phase>generate-resources</phase>\n          <goals>\n            <goal>copy-resources</goal>\n          </goals>\n          <configuration>\n            <outputDirectory>src/main/resources/public</outputDirectory>\n            <overwrite>true</overwrite>\n            <resources>\n              <resource>\n                <directory>${project.parent.basedir}/frontend/target/dist</directory>\n                <includes>\n                  <include>static/</include>\n                  <include>index.html</include>\n                  <include>favicon.ico</include>\n                </includes>\n              </resource>\n            </resources>\n          </configuration>\n        </execution>\n      </executions>\n    </plugin>\n  </plugins>\n</build>\n```\n\n\n## Frontend\n\nCreating our `frontend` project is done by the slightly changed (we use `--no-git` here, because our parent project is already a git repository and otherwise vue CLI 3 would initialize an new one):\n\n```\nvue create frontend --no-git\n```\n\nsee https://cli.vuejs.org/guide/\n\nThis will initialize a project skeleton for Vue.js in /frontend directory - it, therefore, asks some questions in the cli:\n\n![vuejs-cli3-create](screenshots/vuejs-cli3-create.png)\n\n__Do not__ choose the default preset with `default (babel, eslint)`, because we need some more plugins for our project here (choose the Plugins with the __space bar__):\n\n![vuejs-cli3-select-plugins](screenshots/vuejs-cli3-select-plugins.png)\n\nYou can now also use the new `vue ui` command/feature to configure your project:\n\n![vue-ui](screenshots/vue-ui.png)\n\nIf you want to learn more about installing Vue.js, head over to the docs: https://vuejs.org/v2/guide/installation.html\n\n\n### Use frontend-maven-plugin to handle NPM, Node, Bower, Grunt, Gulp, Webpack and so on :)\n\nIf you\xe2\x80\x99re a backend dev like me, this Maven plugin here https://github.com/eirslett/frontend-maven-plugin is a great help for you - because, if you know Maven, that\xe2\x80\x99s everything you need! Just add this plugin to the frontend\xe2\x80\x99s `pom.xml`:\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>com.github.eirslett</groupId>\n            <artifactId>frontend-maven-plugin</artifactId>\n            <version>${frontend-maven-plugin.version}</version>\n            <executions>\n                <!-- Install our node and npm version to run npm/node scripts-->\n                <execution>\n                    <id>install node and npm</id>\n                    <goals>\n                        <goal>install-node-and-npm</goal>\n                    </goals>\n                    <configuration>\n                        <nodeVersion>v10.10.0</nodeVersion>\n                    </configuration>\n                </execution>\n                <!-- Install all project dependencies -->\n                <execution>\n                    <id>npm install</id>\n                    <goals>\n                        <goal>npm</goal>\n                    </goals>\n                    <!-- optional: default phase is "generate-resources" -->\n                    <phase>generate-resources</phase>\n                    <!-- Optional configuration which provides for running any npm command -->\n                    <configuration>\n                        <arguments>install</arguments>\n                    </configuration>\n                </execution>\n                <!-- Build and minify static files -->\n                <execution>\n                    <id>npm run build</id>\n                    <goals>\n                        <goal>npm</goal>\n                    </goals>\n                    <configuration>\n                        <arguments>run build</arguments>\n        </configuration>\n                </execution>\n            </executions>\n        </plugin>\n    </plugins>\n</build>\n```\n\n### Tell Webpack to output the dist/ contents to target/\n\nCommonly, node projects will create a dist/ directory for builds which contains the minified source code of the web app - but we want it all in `/target`. Therefore we need to create the optional [vue.config.js](https://cli.vuejs.org/config/#vue-config-js) and configure the `outputDir` and `assetsDir` correctly: \n\n```javascript\nmodule.exports = {\n  ...\n  // Change build paths to make them Maven compatible\n  // see https://cli.vuejs.org/config/\n  outputDir;: \'target/dist\',\n  assetsDir;: \'static\';\n}\n```\n\n\n## First App run\n\nInside the root directory, do a: \n\n```\nmvn clean install\n```\n\nRun our complete Spring Boot App:\n\n```\nmvn --projects backend spring-boot:run\n```\n\nNow go to http://localhost:8088/ and have a look at your first Vue.js Spring Boot App.\n\n\n\n## Faster feedback with webpack-dev-server\n\nThe webpack-dev-server, which will update and build every change through all the parts of the JavaScript build-chain, is pre-configured in Vue.js out-of-the-box! So the only thing needed to get fast feedback development-cycle is to cd into `frontend` and run:\n\n```\nnpm run serve\n```\n\nThat\xe2\x80\x99s it! \n\n\n## Browser developer tools extension\n\nInstall vue-devtools Browser extension https://github.com/vuejs/vue-devtools and get better feedback, e.g. in Chrome:\n\n![vue-devtools-chrome](screenshots/vue-devtools-chrome.png)\n\n\n## IntelliJ integration\n\nThere\'s a blog post: https://blog.jetbrains.com/webstorm/2018/01/working-with-vue-js-in-webstorm/\n\nEspecially the `New... Vue Component` looks quite cool :)\n\n\n\n## HTTP calls from Vue.js to (Spring Boot) REST backend\n\nPrior to Vue 2.0, there was a build in solution (vue-resource). But from 2.0 on, 3rd party libraries are necessary. One of them is [Axios](https://github.com/mzabriskie/axios) - also see blog post https://alligator.io/vuejs/rest-api-axios/\n\n```\nnpm install axios --save\n```\n\nCalling a REST service with Axios is simple. Go into the script area of your component, e.g. Hello.vue and add:\n\n```js\nimport axios from \'axios\'\n\ndata ();{\n  return {\n    response: [],\n    errors: []\n  }\n},\n\ncallRestService ();{\n  axios.get(`api/hello`)\n    .then(response => {\n      // JSON responses are automatically parsed.\n      this.response = response.data\n    })\n    .catch(e => {\n      this.errors.push(e)\n    })\n}\n}\n```\n\nIn your template area you can now request a service call via calling `callRestService()` method and access `response` data:\n\n```html\n<button class=\xe2\x80\x9dSearch__button\xe2\x80\x9d @click="callRestService()">CALL Spring Boot REST backend service</button>\n\n<h3>{{ response }}</h3>\n```\n\n### The problem with SOP\n\nSingle-Origin Policy (SOP) could be a problem if we want to develop our app. Because the webpack-dev-server runs on http://localhost:8080 and our Spring Boot REST backend on http://localhost:8088.\n\nWe need to use Cross-Origin Resource Sharing Protocol (CORS) to handle that (read more background info about CORS here https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)\n\n\n#### Enabling Axios CORS support\n\nCreate a central Axios configuration file called `http-commons.js`:\n\n```js\nimport axios from \'axios\'\n\nexport const AXIOS = axios.create({\n  baseURL: `http://localhost:8088`,\n  headers: {\n    \'Access-Control-Allow-Origin\': \'http://localhost:8080\'\n  }\n})\n```\n\nHere we allow requests to the base URL of our Spring Boot App on port 8088 to be accessible from 8080.\n\nNow we could use this configuration inside our Components, e.g. in `Hello.vue`:\n```js\nimport {AXIOS} from \'./http-common\'\n\nexport default {\n  name: \'hello\',\n\n  data () {\n    return {\n      posts: [],\n      errors: []\n    }\n  },\n  methods: {\n    // Fetches posts when the component is created.\n    callRestService () {\n      AXIOS.get(`hello`)\n        .then(response => {\n          // JSON responses are automatically parsed.\n          this.posts = response.data\n        })\n        .catch(e => {\n          this.errors.push(e)\n        })\n    }\n  }\n```\n\n#### Enabling Spring Boot CORS support\n\nAdditionally, we need to configure our Spring Boot backend to answer with the appropriate CORS HTTP Headers in its responses (there\'s a good tutorial here: https://spring.io/guides/gs/rest-service-cors/). Therefore we add the annotation `@CrossOrigin` to our BackendController:\n\n```java\n@CrossOrigin(origins = "http://localhost:8080")\n@RequestMapping(path = "/hello")\npublic @ResponseBody String sayHello() {\n    LOG.info("GET called on /hello resource");\n    return HELLO_TEXT;\n}\n```\n\nNow our Backend will respond CORS-enabled and will accept requests from 8080. But as this only enables CORS on one method, we have to repeatedly add this annotation to all of our REST endpoints, which isn\xe2\x80\x99t a nice style. We should use a global solution to allow access with CORS enabled to all of our REST resources. This could be done in the `SpringBootVuejsApplication.class`:\n\n```java\n// Enable CORS globally\n@Bean\npublic WebMvcConfigurer corsConfigurer() {\n  return new WebMvcConfigurerAdapter() {\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n      registry.addMapping("/api/*").allowedOrigins("http://localhost:8080");\n    }\n  };\n}\n```\n\nNow all calls to resources behind `api/` will return the correct CORS headers. \n\n\n#### But STOP! Webpack & Vue have something much smarter for us to help us with SOP!\n\nThanks to my colleague [Daniel](https://www.codecentric.de/team/dre/) who pointed me to the nice proxying feature of Webpack dev-server, we don\'t need to configure all the complex CORS stuff anymore!\n\nAccording to the [Vue CLI 3 docs](https://cli.vuejs.org/config) the only thing we need to [configure is a devserver-proxy](https://cli.vuejs.org/config/#devserver-proxy) for our webpack devserver requests. This could be done easily in the optional [vue.config.js](https://cli.vuejs.org/config/#vue-config-js) inside `devServer.proxy`: \n\n```js\nmodule.exports = {\n  // proxy all webpack dev-server requests starting with /api\n  // to our Spring Boot backend (localhost:8088) using http-proxy-middleware\n  // see https://cli.vuejs.org/config/#devserver-proxy\n  devServer: {\n    proxy: {\n      \'/api\': {\n        target: \'http://localhost:8088\',\n        ws: true,\n        changeOrigin: true\n      }\n    }\n  },\n  ...\n}\n```\n\nWith this configuration in place, the webpack dev-server uses the [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware), which is a really handy component, to proxy all frontend-requests from http://localhost:8080 --> http://localhost:8088 - incl. Changing the Origin accordingly.\n\nThis is used in the webpack build process to configure the proxyMiddleware (you don\'t need to change something here!):\n\n```js\n// proxy api requests\nObject.keys(proxyTable).forEach(function (context) {\n  var options = proxyTable[context];\n  if (typeof options === \'string\') {\n    options = { target: options }\n  }\n  app.use(proxyMiddleware(options.filter || context, options))\n})\n```\n\n## Using history mode for nicer URLs\n\nIf we use the default configuration of the generated Vue.js template, we see URLs with a `#` inside them - like this:\n\n```\nhttp://localhost:8098/#/bootstrap\n\nor\n\nhttp://localhost:8098/#/user\n```\n\nWith the usage of __[HTML5 history mode](https://router.vuejs.org/guide/essentials/history-mode.html#html5-history-mode)__, we can achieve much nicer URLs without the `#` in them. Only thing to do in the Vue.js frontend is to configure our router accordingly inside the [router.js](frontend/src/router.js):\n\n```\n...\n\nVue.use(Router);\n\nconst router = new Router({\n    mode: \'history\', // uris without hashes #, see https://router.vuejs.org/guide/essentials/history-mode.html#html5-history-mode\n    routes: [\n        { path: \'/\', component: Hello },\n        { path: \'/callservice\', component: Service },\n        ...\n```\n\nThat\'s nearly everything. BUT only nearly! If one clicks on a link inside our frontend, the user is correctly send to the wished component. \n\nBut if the user enters the URL directly into the Browser, we get a `Whitelabel Error Page` because our Spring Boot backend gives us a __HTTP 404__ - since this URL isn\'t present in the backend:\n\n![html5-history-mode-whitelabel-error-page-404](screenshots/html5-history-mode-whitelabel-error-page-404.gif)\n\nThe solution is to redirect or better forward the user to the frontend (router) again. The [Vue.js docs don\'t provide an example configuration for Spring Boot](https://router.vuejs.org/guide/essentials/history-mode.html#example-server-configurations), but luckily [there are other resources](https://www.baeldung.com/spring-redirect-and-forward). In essence we have to implement a forwarding controller in our [BackendController](backend/src/main/java/de/jonashackt/springbootvuejs/controller/BackendController.java):\n\n```\n    // Forwards all routes to FrontEnd except: \'/\', \'/index.html\', \'/api\', \'/api/**\'\n    // Required because of \'mode: history\' usage in frontend routing, see README for further details\n    @RequestMapping(value = "{_:^(?!index\\\\.html|api).$}")\n    public String redirectApi() {\n        LOG.info("URL entered directly into the Browser, so we need to redirect...");\n        return "forward:/";\n    }\n```\n\nThis controller will forward every request other then `\'/\', \'/index.html\', \'/api\', \'/api/**\'` to our Vue.js frontend.\n\n\n## Bootstrap & Vue.js\n\nThere\xe2\x80\x99s a nice integration of Bootstrap in Vue.js: https://bootstrap-vue.js.org/\n\n```\nnpm install bootstrap-vue\n```\n\nNow you can use all the pretty Bootstrap stuff with ease like:\n\n```\n<b-btn @click="callRestService()">CALL Spring Boot REST backend service</b-btn>\n```\n\ninstead of\n\n```\n<button type="button" class=\xe2\x80\x9dbtn\xe2\x80\x9d @click="callRestService()">CALL Spring Boot REST backend service</button>\n```\n\nThe docs contain all the possible components: https://bootstrap-vue.js.org/docs/components/alert/\n\nSee some elements, when you go to http://localhost:8080/#/bootstrap/ - this should look like this:\n\n![bootstrap-styled-vuejs](screenshots/bootstrap-styled-vuejs.png)\n\nA good discussion about various UI component frameworks: http://vuetips.com/bootstrap\n\n\n## Heroku Deployment\n\nAs you may already read, the app is automatically deployed to Heroku on https://spring-boot-vuejs.herokuapp.com/.\n\nThe project makes use of the nice Heroku Pipelines feature, where we do get a full Continuous Delivery pipeline with nearly no effort:\n\n![heroku-pipeline](screenshots/heroku-pipeline.png)\n\nAnd with the help of super cool `Automatic deploys`, we have our TravisCI build our app after every push to master - and with the checkbox set to `Wait for CI to pass before deploy` - the app gets also automatically deployed to Heroku - but only, if the TravisCI (and Coveralls...) build succeeded:\n\n![heroku-automatic-deploys](screenshots/heroku-automatic-deploys.png)\n\nYou only have to connect your Heroku app to GitHub, activate Automatic deploys and set the named checkbox. That\'s everything!\n\n\n#### Accessing Spring Boot REST backend on Heroku from Vue.js frontend\n\nFrontend needs to know the Port of our Spring Boot backend API, which is [automatically set by Heroku every time, we (re-)start our App](https://stackoverflow.com/a/12023039/4964553).\n\n> You can [try out your Heroku app locally](https://devcenter.heroku.com/articles/heroku-local)! Just create a .env-File with all your Environment variables and run `heroku local`! \n\nTo access the Heroku set port, we need to use relative paths inside our Vue.js application instead of hard-coded hosts and ports! \n\nAll we need to do is to configure Axios in such a way inside our [frontend/src/components/http-common.js](https://github.com/jonashackt/spring-boot-vuejs/blob/master/frontend/src/components/http-common.js):\n\n```\nexport const AXIOS = axios.create({\n  baseURL: `/api`\n})\n```\n\n#### Using Heroku\'s Postgres as Database for Spring Boot backend and Vue.js frontend\n\nFirst, add [Heroku Postgres database](https://elements.heroku.com/addons/heroku-postgresql) for your Heroku app. \n\nThen follow these instructions on Stackoverflow to configure all needed Environment variables in Heroku: https://stackoverflow.com/a/49978310/4964553\n\nMind the addition to the backend\'s [pom.xml](backend/pom.xml) described here: https://stackoverflow.com/a/49970142/4964553\n\nNow you\'re able to use Spring Data\'s magic - all you need is an Interface like [UserRepository.java](backend/src/main/java/de/jonashackt/springbootvuejs/repository/UserRepository.java):\n\n```java\npackage de.jonashackt.springbootvuejs.repository;\n\nimport de.jonashackt.springbootvuejs.domain.User;\nimport org.springframework.data.repository.CrudRepository;\nimport org.springframework.data.repository.query.Param;\n\nimport java.util.List;\n\npublic interface UserRepository extends CrudRepository<User, Long> {\n\n    List<User> findByLastName(@Param("lastname") String lastname);\n\n    List<User> findByFirstName(@Param("firstname") String firstname);\n\n}\n\n```\n\nNow write your Testcases accordingly like [UserRepositoryTest.java](backend/src/test/java/de/jonashackt/springbootvuejs/repository/UserRepositoryTest.java):\n\n```java\npackage de.jonashackt.springbootvuejs.repository;\n\nimport de.jonashackt.springbootvuejs.domain.User;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\nimport org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport java.util.List;\n\nimport static org.hamcrest.Matchers.contains;\nimport static org.junit.Assert.*;\n\n@RunWith(SpringRunner.class)\n@DataJpaTest\npublic class UserRepositoryTest {\n\n    @Autowired\n    private TestEntityManager entityManager;\n\n    @Autowired\n    private UserRepository users;\n\n    private User norbertSiegmund = new User("Norbert", "Siegmund");\n    private User jonasHecht = new User("Jonas", "Hecht");\n\n    @Before\n    public void fillSomeDataIntoOurDb() {\n        // Add new Users to Database\n        entityManager.persist(norbertSiegmund);\n        entityManager.persist(jonasHecht);\n    }\n\n    @Test\n    public void testFindByLastName() throws Exception {\n        // Search for specific User in Database according to lastname\n        List<User> usersWithLastNameSiegmund = users.findByLastName("Siegmund");\n\n        assertThat(usersWithLastNameSiegmund, contains(norbertSiegmund));\n    }\n\n\n    @Test\n    public void testFindByFirstName() throws Exception {\n        // Search for specific User in Database according to firstname\n        List<User> usersWithFirstNameJonas = users.findByFirstName("Jonas");\n\n        assertThat(usersWithFirstNameJonas, contains(jonasHecht));\n    }\n\n}\n```\n\nThen include this functionality in your REST-API - see [BackendController.java](backend/src/main/java/de/jonashackt/springbootvuejs/controller/BackendController.java):\n\n```java\n    @RequestMapping(path = "/user", method = RequestMethod.POST)\n    @ResponseStatus(HttpStatus.CREATED)\n    public @ResponseBody long addNewUser (@RequestParam String firstName, @RequestParam String lastName) {\n        User user = new User(firstName, lastName);\n        userRepository.save(user);\n\n        LOG.info(user.toString() + " successfully saved into DB");\n\n        return user.getId();\n    }\n```\n \nand use it from the Vue.js frontend, see [User.vue](frontend/src/components/User.vue):\n\n```html\n<template>\n<div class="user">\n <h1>Create User</h1>\n\n <h3>Just some database interaction...</h3>\n\n <input type="text" v-model="user.firstName" placeholder="first name">\n <input type="text" v-model="user.lastName" placeholder="last name">\n\n <button @click="createUser()">Create User</button>\n\n <div v-if="showResponse"><h6>User created with Id: {{ response }}</h6></div>\n\n <button v-if="showResponse" @click="retrieveUser()">Retrieve user {{user.id}} data from database</button>\n\n <h4 v-if="showRetrievedUser">Retrieved User {{retrievedUser.firstName}} {{retrievedUser.lastName}}</h4>\n\n</div>\n</template>\n\n<script>\n// import axios from \'axios\'\nimport {AXIOS} from \'./http-common\'\n\nexport default {\n name: \'user\',\n\n data () {\n   return {\n     response: [],\n     errors: [],\n     user: {\n       lastName: \'\',\n       firstName: \'\',\n       id: 0\n     },\n     showResponse: false,\n     retrievedUser: {},\n     showRetrievedUser: false\n   }\n },\n methods: {\n   // Fetches posts when the component is created.\n   createUser () {\n     var params = new URLSearchParams();\n     params.append(\'firstName\', this.user.firstName);\n     params.append(\'lastName\', this.user.lastName);\n\n     AXIOS.post(`/user`, params)\n       .then(response => {\n         // JSON responses are automatically parsed.\n         this.response = response.data;\n         this.user.id = response.data;\n         console.log(response.data);\n         this.showResponse = true\n       })\n       .catch(e => {\n         this.errors.push(e)\n       })\n   },\n   retrieveUser () {\n     AXIOS.get(`/user/` + this.user.id)\n       .then(response => {\n         // JSON responses are automatically parsed.\n         this.retrievedUser = response.data;\n         console.log(response.data);\n         this.showRetrievedUser = true\n       })\n       .catch(e => {\n         this.errors.push(e)\n       })\n   }\n }\n}\n\n</script>\n```\n\n\n## Testing \n\n### Install vue-test-utils\n\nhttps://github.com/vuejs/vue-test-utils\n\n`npm install --save-dev @vue/test-utils`\n\n### Jest\n\nJest is a new shooting star in the sky of JavaScript testing frameworks: https://facebook.github.io/jest/\n\nIntro-Blogpost: https://blog.codecentric.de/2017/06/javascript-unit-tests-sind-schwer-aufzusetzen-keep-calm-use-jest/\n\nExamples: https://github.com/vuejs/vue-test-utils-jest-example\n\nVue.js Jest Docs: https://vue-test-utils.vuejs.org/guides/#testing-single-file-components-with-jest\n\nA Jest Unittest looks like [Hello.spec.js](frontend/test/components/Hello.spec.js):\n\n```js\nimport { shallowMount } from \'@vue/test-utils\';\nimport Hello from \'@/components/Hello\'\n\ndescribe(\'Hello.vue\', () => {\n  it(\'should render correct hello message\', () => {\n    // Given\n    const hellowrapped = shallowMount(Hello, {\n      propsData: { hellomsg: \'Welcome to your Jest powered Vue.js App\' },\n      stubs: [\'router-link\', \'router-view\']\n    });\n\n    // When\n    const contentH1 = hellowrapped.find(\'h1\');\n\n    // Then\n    expect(contentH1.text()).toEqual(\'Welcome to your Jest powered Vue.js App\');\n  })\n})\n```\n\nTo pass Component props while using Vue.js Router, see https://stackoverflow.com/a/37940045/4964553.\n\nHow to test components with `router-view` or `router-link` https://vue-test-utils.vuejs.org/guides/using-with-vue-router.html#testing-components-that-use-router-link-or-router-view.\n\nThe test files itself could be named `xyz.spec.js` or `xyz.test.js` - and could reside nearly everywhere in the project.\n\n##### Jest Configuration  \n\nThe Jest run-configuration is done inside the [package.json](frontend/package.json):\n\n```js\n"scripts";: {\n    ...\n    "test:unit";: "vue-cli-service test:unit --coverage",;\n    ....\n  },\n```\n\nJest can be configured via `jest.config.js` in your project root, or the `jest` field in [package.json](frontend/package.json). In our case we especially need to configure `coverageDirectory`:\n\n```json\n  ],\n  "jest": {\n    ...\n    "coverageDirectory": "<rootDir>/tests/unit/coverage",\n    "collectCoverageFrom": [\n      "src/**/*.{js,vue}",\n      "!src/main.js",\n      "!src/router/index.js",\n      "!**/node_modules/**"\n    ]\n  }\n}\n```\n\nJest needs to know the right output directory `/tests/unit/coverage` to show a correct output when `npm run test:unit` is run (or the corresponding Maven build). If you run the Jest Unit tests now with:\n\n`npm run test:unit`\n\n- you\xc2\xb4ll recognize the table of test covered files:\n\n![unittestrun-jest](screenshots/unittestrun-jest.png)\n\n\n##### Integration in Maven build (via frontend-maven-plugin)\n\nInside the [pom.xml](pom.xml) we always automatically run the Jest Unittests with the following configuration:\n\n```xml\n<!-- Run Unit tests -->\n  <execution>\n    <id>npm run test:unit</id>\n    <goals>\n      <goal>npm</goal>\n    </goals>\n    <!-- optional: default phase is "generate-resources" -->\n    <phase>test</phase>\n    <!-- Optional configuration which provides for running any npm command -->\n    <configuration>\n      <arguments>run test:unit</arguments>\n    </configuration>\n  </execution>\n```\n\nThis will integrate the Jest Unittests right after the npm run build command, just you are used to in Java-style projects:\n\n![maven-integration-jest-unittests](screenshots/maven-integration-jest-unittests.png)\n\nAnd don\'t mind the depiction with `ERROR` - this is just a known bug: https://github.com/eirslett/frontend-maven-plugin/issues/584\n\n\n##### Run Jest tests inside IntelliJ\n\nFirst, we need to install the NodeJS IntelliJ plugin (https://www.jetbrains.com/help/idea/developing-node-js-applications.html), which isn\'t bundled with IntelliJ by default:\n\n![nodejs-intellij-plugin](screenshots/nodejs-intellij-plugin.png)\n\nIntelliJ Jest integration docs: https://www.jetbrains.com/help/idea/running-unit-tests-on-jest.html\n\nThe automatic search inside the [package.json](frontend/package.json) for the Jest configuration file [jest.conf.js](frontend/test/unit/jest.conf.js) doesn\'t seem to work right now, so we have to manually configure the `scripts` part of:\n\n```\n"unit": "jest --config test/unit/jest.conf.js --coverage",\n```\n\ninside the Run Configuration under `Jest` and `All Tests`:\n\n![configure-jest-inside-intellij](screenshots/configure-jest-inside-intellij.png)\n\nNow, when running `All Tests`, this should look like you\'re already used to Unittest IntelliJ-Integration:\n\n![run-jest-inside-intellij](screenshots/run-jest-inside-intellij.png)\n\n \n\n## End-2-End (E2E) tests with Nightwatch\n\nGreat tooling: http://nightwatchjs.org/ - Nightwatch controls WebDriver / Selenium standalone Server in own child process and abstracts from those, providing a handy DSL for Acceptance tests:\n\nDocs: http://nightwatchjs.org/gettingstarted/#browser-drivers-setup\n\n![http://nightwatchjs.org/img/operation.png](http://nightwatchjs.org/img/operation.png)\n\nNightwatch is configured through the [nightwatch.conf.js](/frontend/test/e2e/nightwatch.conf.js). Watch out for breaking changes in 1.x: https://github.com/nightwatchjs/nightwatch/wiki/Migrating-to-Nightwatch-1.0\n\nMore options could be found in the docs: http://nightwatchjs.org/gettingstarted/#settings-file\n\n\n#### Write Nightwatch tests\n\nAn example Nightwatch test is provided in [HelloAcceptance.test.js](/frontend/test/e2e/specs/HelloAcceptance.test.js):\n\n```js\nmodule.exports = {\n    \'default e2e tests\': browser => {\n        browser\n            .url(process.env.VUE_DEV_SERVER_URL)\n            .waitForElementVisible(\'#app\', 5000)\n            .assert.elementPresent(\'.hello\')\n            .assert.containsText(\'h1\', \'Welcome to your Vue.js powered Spring Boot App\')\n            .assert.elementCount(\'img\', 1)\n            .end()\n    }\n}\n```\n\n##### Run E2E Tests\n\n`npm run test:e2e`\n\n\n## Run all tests\n\n `npm test`\n\n\n\n## NPM Security\n\nnpm Security - npm@6\n\nhttps://medium.com/npm-inc/announcing-npm-6-5d0b1799a905\n\n`npm audit`\n\nhttps://blog.npmjs.org/post/173719309445/npm-audit-identify-and-fix-insecure\n\nRun `npm audit fix` to update the vulnerable packages. Only in situations, where nothing else helps, try `npm audit fix --force` (this will also install braking changes)\n\nhttps://nodejs.org/en/blog/vulnerability/june-2018-security-releases/\n\n---> __Update NPM regularly__\n\nhttps://docs.npmjs.com/troubleshooting/try-the-latest-stable-version-of-npm\n\n`npm install -g npm@latest`\n\n---> __Update Packages regularly__\n\nhttps://docs.npmjs.com/getting-started/updating-local-packages\n\n`npm outdated`\n\n`npm update`\n\n\n\n\n## Shift from templates to plugin-based architecture in Vue Cli 3\n\nIn the long run, templates like the main [webpack](https://github.com/vuejs-templates/webpack) are deprecated in the Vue.js universe:\n\nhttps://vuejsdevelopers.com/2018/03/26/vue-cli-3/\n\nPlugins bring the following benefits compared to templates:\n\n* No lock in, as plugins can be added at any point in the development lifecycle\n* Zero config plugins allow you to spend time developing rather than configuring\n* Easy to upgrade, as configuration can be customized without \xe2\x80\x9cejecting\xe2\x80\x9d\n* Allows developers to make their own plugins and presets\n\nStarting point: https://cli.vuejs.org/\n\n\n#### OMG! My package.json is so small - Vue CLI 3 Plugins\n\nFrom https://cli.vuejs.org/guide/plugins-and-presets.html:\n\n> Vue CLI uses a plugin-based architecture. If you inspect a newly created project\'s package.json, you will find dependencies that start with `@vue/cli-plugin-`. Plugins can modify the internal webpack configuration and inject commands to `vue-cli-service`. Most of the features listed during the project creation process are implemented as plugins.\n\nWith plugings, extensions to an existing project could also be made via: `vue add pluginName`. E.g. if you want to add Nightwatch E2E tests to your project, just run `vue add @vue/e2e-nightwatch`. All scoped packages are available here: https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue\n\nThese new Vue CLI 3 plugin architecture cleans our big `package.json` to a really neat compact thing. This was the old big dependency block:\n\n````json\n  "devDependencies": {\n    "@vue/test-utils": "^1.0.0-beta.25",\n    "autoprefixer": "^7.1.2",\n    "babel-core": "^6.26.3",\n    "babel-helper-vue-jsx-merge-props": "^2.0.3",\n    "babel-jest": "^21.0.2",\n    "babel-loader": "^7.1.5",\n    "babel-plugin-dynamic-import-node": "^1.2.0",\n    "babel-plugin-syntax-jsx": "^6.18.0",\n    "babel-plugin-transform-es2015-modules-commonjs": "^6.26.0",\n    "babel-plugin-transform-runtime": "^6.22.0",\n    "babel-plugin-transform-vue-jsx": "^3.5.0",\n    "babel-preset-env": "^1.7.0",\n    "babel-preset-stage-2": "^6.22.0",\n    "babel-register": "^6.22.0",\n    "chalk": "^2.4.1",\n    "chromedriver": "^2.41.0",\n    "copy-webpack-plugin": "^4.5.2",\n    "cross-spawn": "^5.0.1",\n    "css-loader": "^0.28.0",\n    "extract-text-webpack-plugin": "^3.0.0",\n    "file-loader": "^1.1.4",\n    "friendly-errors-webpack-plugin": "^1.6.1",\n    "html-webpack-plugin": "^2.30.1",\n    "jest": "^22.0.4",\n    "jest-serializer-vue": "^0.3.0",\n    "nightwatch": "^1.0.11",\n    "node-notifier": "^5.1.2",\n    "optimize-css-assets-webpack-plugin": "^3.2.0",\n    "ora": "^1.2.0",\n    "portfinder": "^1.0.17",\n    "postcss-import": "^11.0.0",\n    "postcss-loader": "^2.1.6",\n    "postcss-url": "^7.2.1",\n    "rimraf": "^2.6.0",\n    "selenium-server": "^3.14.0",\n    "semver": "^5.5.1",\n    "shelljs": "^0.7.6",\n    "uglifyjs-webpack-plugin": "^1.3.0",\n    "url-loader": "^1.1.1",\n    "vue-jest": "^1.0.2",\n    "vue-loader": "^13.7.3",\n    "vue-style-loader": "^3.0.1",\n    "vue-template-compiler": "^2.5.17",\n    "webpack": "^3.6.0",\n    "webpack-bundle-analyzer": "^2.13.1",\n    "webpack-dev-server": "^2.11.3",\n    "webpack-merge": "^4.1.4"\n  },\n````\n\nAs you can see, we\xc2\xb4re not only maintaining our high-level libraries of choice like nightwatch, jest and so on. We\xc2\xb4re also maintaining libraries that they use itself. Now this is over with Vue CLI 3. Let\xc2\xb4s have a look at the super clean dependency block now:\n\n```json\n"devDependencies": {\n    "@vue/cli-plugin-babel": "^3.0.3",\n    "@vue/cli-plugin-e2e-nightwatch": "^3.0.3",\n    "@vue/cli-plugin-unit-jest": "^3.0.3",\n    "@vue/cli-service": "^3.0.3",\n    "@vue/test-utils": "^1.0.0-beta.20",\n    "babel-core": "7.0.0-bridge.0",\n    "babel-jest": "^23.0.1",\n    "node-sass": "^4.9.0",\n    "sass-loader": "^7.0.1",\n    "vue-template-compiler": "^2.5.17"\n  },\n``` \n\nAs you dig into the directories like `node_modules/@vue/cli-plugin-e2e-nightwatch`, you\xc2\xb4ll find where the used libraries of nightwatch are configured - in the respective `package.json` there:\n\n```json\n  "dependencies": {\n    "@vue/cli-shared-utils": "^3.0.2",\n    "chromedriver": "^2.40.0",\n    "deepmerge": "^2.1.1",\n    "execa": "^0.10.0",\n    "nightwatch": "^0.9.21",\n    "selenium-server": "^3.13.0"\n  },\n```\n\nThis is really cool, I have to admit!\n\n\n#### The vue.config.js file\n\nVue CLI 3 removes the need for explicit configuration files - and thus you wont find any `build` or `config` directories in your projects root any more. This now implements a "convention over configuration" approach, which makes it much easier to kick-start a Vue.js project, as it provides widly used defaults to webpack etc. It also eases the upgradeability of Vue.js projects - or even makes it possible. \n\n__But__: How do we configure webpack etc. for CORS handling, the build directories and so on? This could be done with the optional [vue.config.js](https://cli.vuejs.org/config/#vue-config-js):\n\n```javascript\nmodule.exports = {\n  // proxy all webpack dev-server requests starting with /api\n  // to our Spring Boot backend (localhost:8088) using http-proxy-middleware\n  // see https://cli.vuejs.org/config/#devserver-proxy\n  devServer: {\n    proxy: {\n      \'/api\': {\n        target: \'http://localhost:8088\',\n        ws: true,\n        changeOrigin: true\n      }\n    }\n  },\n  // Change build paths to make them Maven compatible\n  // see https://cli.vuejs.org/config/\n  outputDir: \'target/dist\'\n}\n```\n\n#### Updating Vue in an existing project\n\nUpdate your local `@vue/cli` to the latest version:\n\n```\nnpm install -g @vue/cli\n```\n\nThen update Vue.js and all your other JS dependencies with:\n\n```\ncd frontend\nnpm update\n```\n\n\n## Build and run with Docker\n\nIn the issue [jonashackt/spring-boot-vuejs/issues/25](https://github.com/jonashackt/spring-boot-vuejs/issues/25) the question on how to build and run our spring-boot-vuejs app with Docker. \n\nAs already stated in the issue there are multiple ways of doing this. One I want to outline here is a more in-depth variant, where you\'ll know exacltly what\'s going on behind the scenes.\n\nFirst we\'ll make use of [Docker\'s multi-stage build feature](https://docs.docker.com/develop/develop-images/multistage-build/) - in __the first stage__ we\'ll build our Spring Boot Vue.js app using our established Maven build process. Let\'s have a look into our [Dockerfile](Dockerfile):\n\n```dockerfile\n# Docker multi-stage build\n\n# 1. Building the App with Maven\nFROM maven:3-jdk-11\n\nADD . /springbootvuejs\nWORKDIR /springbootvuejs\n\n# Just echo so we can see, if everything is there :)\nRUN ls -l\n\n# Run Maven build\nRUN mvn clean install\n```\n\nA crucial part here is to add all necessary files into our Docker build context - but leaving out the underlying OS specific node libraries! As not leaving them out would lead [to errors like](https://stackoverflow.com/questions/37986800/node-sass-could-not-find-a-binding-for-your-current-environment?page=1&tab=active#tab-top):\n\n```\nNode Sass could not find a binding for your current environment: Linux 64-bit with Node.js 11.x\n```\n\nTherefore we create a [.dockerignore](.dockerignore) file and leave out the directories `frontend/node_modules` & `frontend/node` completely using the `frontend/node*` configuration:\n\n```\n# exclude underlying OS specific node modules\nfrontend/node*\n\n# also leave out pre-build output folders\nfrontend/target\nbackend/target\n```\n\nWe also ignore the pre-build output directories.\n\nIn __the second stage__ of our [Dockerfile](Dockerfile) we use the build output of the first stage and prepare everything to run our Spring Boot powered Vue.js app later:\n\n```dockerfile\n# Just using the build artifact and then removing the build-container\nFROM openjdk:11-jdk\n\nMAINTAINER Jonas Hecht\n\nVOLUME /tmp\n\n# Add Spring Boot app.jar to Container\nCOPY --from=0 "/springbootvuejs/backend/target/backend-0.0.1-SNAPSHOT.jar" app.jar\n\nENV JAVA_OPTS=""\n\n# Fire up our Spring Boot app by default\nENTRYPOINT [ "sh", "-c", "java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar" ]\n```\n\nNow we should everything prepared to run our Docker build:\n\n```\ndocker build . --tag spring-boot-vuejs:latest\n```\n\nThis build can take a while, since all Maven and NPM dependencies need to be downloaded for the build.\n\nWhen the build is finished, simply start a Docker container based on the newly build image and prepare the correct port to be bound to the Docker host for easier access later:\n\n```\ndocker run -d -p 8088:8088 --name myspringvuejs spring-boot-vuejs\n```\n\nHave a look into your running Docker containers with `docker ps` and you should see the new container:\n\n```\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\n745e854d7781        spring-boot-vuejs   "sh -c \'java $JAVA_O\xe2\x80\xa6"   12 seconds ago      Up 11 seconds       0.0.0.0:8088->8088/tcp   myspringvuejs\n```\n\nIf you want to see the typical Spring Boot startup logs, just use `docker logs 745e854d7781 --follow`:\n\n```\n$ docker logs 745e854d7781 --follow\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.1.2.RELEASE)\n\n2019-01-29 09:42:07.621  INFO 8 --- [           main] d.j.s.SpringBootVuejsApplication         : Starting SpringBootVuejsApplication v0.0.1-SNAPSHOT on 745e854d7781 with PID 8 (/app.jar started by root in /)\n2019-01-29 09:42:07.627  INFO 8 --- [           main] d.j.s.SpringBootVuejsApplication         : No active profile set, falling back to default profiles: default\n2019-01-29 09:42:09.001  INFO 8 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data repositories in DEFAULT mode.\n2019-01-29 09:42:09.103  INFO 8 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 90ms. Found 1 repository interfaces.\n2019-01-29 09:42:09.899  INFO 8 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean \'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration\' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$bb072d94] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)\n2019-01-29 09:42:10.715  INFO 8 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8088 (http)\n2019-01-29 09:42:10.765  INFO 8 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2019-01-29 09:42:10.765  INFO 8 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.14]\n2019-01-29 09:42:10.783  INFO 8 --- [           main] o.a.catalina.core.AprLifecycleListener   : The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/usr/java/packages/lib:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib]\n2019-01-29 09:42:10.920  INFO 8 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2019-01-29 09:42:10.921  INFO 8 --- [           main] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 3209 ms\n2019-01-29 09:42:11.822  INFO 8 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2019-01-29 09:42:12.177  INFO 8 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n2019-01-29 09:42:12.350  INFO 8 --- [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [\n\tname: default\n\t...]\n2019-01-29 09:42:12.520  INFO 8 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate Core {5.3.7.Final}\n2019-01-29 09:42:12.522  INFO 8 --- [           main] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found\n2019-01-29 09:42:12.984  INFO 8 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.4.Final}\n2019-01-29 09:42:13.894  INFO 8 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect\n2019-01-29 09:42:15.644  INFO 8 --- [           main] o.h.t.schema.internal.SchemaCreatorImpl  : HHH000476: Executing import script \'org.hibernate.tool.schema.internal.exec.ScriptSourceInputNonExistentImpl@64524dd\'\n2019-01-29 09:42:15.649  INFO 8 --- [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit \'default\'\n2019-01-29 09:42:16.810  INFO 8 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService \'applicationTaskExecutor\'\n2019-01-29 09:42:16.903  WARN 8 --- [           main] aWebConfiguration$JpaWebMvcConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning\n2019-01-29 09:42:17.116  INFO 8 --- [           main] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page: class path resource [public/index.html]\n2019-01-29 09:42:17.604  INFO 8 --- [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 2 endpoint(s) beneath base path \'/actuator\'\n2019-01-29 09:42:17.740  INFO 8 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8088 (http) with context path \'\'\n2019-01-29 09:42:17.745  INFO 8 --- [           main] d.j.s.SpringBootVuejsApplication         : Started SpringBootVuejsApplication in 10.823 seconds (JVM running for 11.485)\n```\n\nNow access your Dockerized Spring Boot powererd Vue.js app inside your Browser at [http://localhost:8088](http://localhost:8088). \n\nIf you have played enough with your Dockerized app, don\'t forget to stop (`docker stop 745e854d7781`) and remove (`docker rm 745e854d7781`) it in the end.\n\n\n#### Autorelease to Docker Hub on hub.docker.com\n\nWe also want to have the current version of our code build and released to https://hub.docker.com/. Therefore head to the repositories tab in Docker Hub and click `Create Repository`:\n\n![docker-hub-create-repo](screenshots/docker-hub-create-repo.png)\n\nAs the docs state, there are some config options to [setup automated builds](https://docs.docker.com/docker-hub/builds/).\n\nFinally, we should see our Docker images released on https://hub.docker.com/r/jonashackt/spring-boot-vuejs and could run this app simply by executing:\n\n```\ndocker run -p 8098:8098 jonashackt/spring-boot-vuejs:latest\n```\n\nThis pulls the latest `jonashackt/spring-boot-vuejs` image and runs our app locally:\n\n```\ndocker run -p 8098:8098 jonashackt/spring-boot-vuejs:latest\nUnable to find image \'jonashackt/spring-boot-vuejs:latest\' locally\nlatest: Pulling from jonashackt/spring-boot-vuejs\n9a0b0ce99936: Pull complete\ndb3b6004c61a: Pull complete\nf8f075920295: Pull complete\n6ef14aff1139: Pull complete\n962785d3b7f9: Pull complete\ne275e7110d81: Pull complete\n0ce121b6a2ff: Pull complete\n71607a6adeb3: Pull complete\nDigest: sha256:4037576ba5f6c58ed067eeef3ab2870a9de8dd1966a5906cb3d36d0ad98fa541\nStatus: Downloaded newer image for jonashackt/spring-boot-vuejs:latest\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.2.0.RELEASE)\n\n2019-11-02 16:15:37.967  INFO 7 --- [           main] d.j.s.SpringBootVuejsApplication         : Starting SpringBootVuejsApplication v0.0.1-SNAPSHOT on aa490bc6ddf4 with PID 7 (/app.jar started by root in /)\n2019-11-02 16:15:37.973  INFO 7 --- [           main] d.j.s.SpringBootVuejsApplication         : No active profile set, falling back to default profiles: default\n2019-11-02 16:15:39.166  INFO 7 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data repositories in DEFAULT mode.\n2019-11-02 16:15:39.285  INFO 7 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 99ms. Found 1 repository interfaces.\n2019-11-02 16:15:39.932  INFO 7 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean \'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration\' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)\n2019-11-02 16:15:40.400  INFO 7 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8098 (http)\n2019-11-02 16:15:40.418  INFO 7 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n...\n2019-11-02 16:15:54.048  INFO 7 --- [nio-8098-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet \'dispatcherServlet\'\n2019-11-02 16:15:54.081  INFO 7 --- [nio-8098-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 32 ms\n```\n\n\nNow head over to [http://localhost:8098/](http://localhost:8098/) and see the app live :)\n\n\n# Run with JDK 8, 9 or 11 ff\n\nAs with Spring Boot, we can define the desired Java version simply by editing our backend\'s [pom.xml](backend/pom.xml): \n\n```\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t</properties>\n```\n\nIf you want to have `JDK9`, place a `<java.version>9</java.version>` or other versions just as you like to (see [this stackoverflow answer](https://stackoverflow.com/questions/54467287/how-to-specify-java-11-version-in-spring-spring-boot-pom-xml)).\n\nSpring Boot handles the needed `maven.compiler.release`, which tell\'s Java from version 9 on to build for a specific target.\n\nWe just set `1.8` as the baseline here, since if we set a newer version as the standard, builds on older versions then 8 will fail (see [this build log for example](https://travis-ci.org/jonashackt/spring-boot-vuejs/builds/547227298).\n\nAdditionally, we use TravisCI to run the Maven build on some mayor Java versions - have a look into the [.travis.yml](.travis.yml):\n\n```\nlanguage: java\njdk:\n  - oraclejdk8\n  - oraclejdk9\n  - oraclejdk11\n```\n\n\n# Secure Spring Boot backend and protect Vue.js frontend\n\nSecuring parts of our application must consist of two parts: securing the Spring Boot backend - and reacting on that secured backend in the Vue.js frontend.\n\nhttps://spring.io/guides/tutorials/spring-security-and-angular-js/\n\nhttps://developer.okta.com/blog/2018/11/20/build-crud-spring-and-vue\n\nhttps://auth0.com/blog/vuejs2-authentication-tutorial/\n\nhttps://medium.com/@zitko/structuring-a-vue-project-authentication-87032e5bfe16\n\n\n\n\n\n## Secure the backend API with Spring Security\n\nhttps://spring.io/guides/tutorials/spring-boot-oauth2\n\nhttps://spring.io/guides/gs/securing-web/\n\nhttps://www.baeldung.com/rest-assured-authentication\n\nNow let\'s focus on securing our Spring Boot backend first! Therefore we introduce a new RESTful resource, that we want to secure specifically:\n\n\n                   +---+                  +---+                  +---+\n                   |   | /api/hello       |   | /api/user        |   | /api/secured\n                   +---+                  +---+                  +---+\n                     |                      |                      |\n        +-----------------------------------------------------------------------+\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |  Spring Boot backend                                                  |\n        |                                                                       |\n        +-----------------------------------------------------------------------+\n\n\n#### Configure Spring Security\n\nFirst we add a new REST resource `/secured` inside our `BackendController we want to secure - and use in a separate frontend later:\n\n```\n    @GetMapping(path="/secured")\n    public @ResponseBody String getSecured() {\n        LOG.info("GET successfully called on /secured resource");\n        return SECURED_TEXT;\n    }\n```\n\nWith Spring it is relatively easy to secure our API. Let\'s add `spring-boot-starter-security` to our [pom.xml](backend/pom.xml):\n\n```xml\n\t\t<!-- Secure backend API -->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-security</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.security</groupId>\n\t\t\t<artifactId>spring-security-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n```\n\nAlso create a new @Configuration annotated class called [WebSecurityConfiguration.class](backend/src/main/java/de/jonashackt/springbootvuejs/configuration/WebSecurityConfiguration.java):\n\n```java\npackage de.jonashackt.springbootvuejs.configuration;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n\n        http\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // No session will be created or used by spring security\n        .and()\n            .httpBasic()\n        .and()\n            .authorizeRequests()\n                .antMatchers("/api/hello").permitAll()\n                .antMatchers("/api/user/**").permitAll() // allow every URI, that begins with \'/api/user/\'\n                .antMatchers("/api/secured").authenticated()\n                .anyRequest().authenticated() // protect all other requests\n        .and()\n            .csrf().disable(); // disable cross site request forgery, as we don\'t use cookies - otherwise ALL PUT, POST, DELETE will get HTTP 403!\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.inMemoryAuthentication()\n                .withUser("foo").password("{noop}bar").roles("USER");\n    }\n}\n\n```\n\nUsing a simple `http.httpBasic()` we configure to provide a Basic Authentication for our secured resources.\n\nTo deep dive into the Matcher configurations, have a look into https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#jc-authorize-requests\n\n#### Be aware of CSRF!\n\n__BUT:__ Be aware of the CSRF (cross site request forgery) part! The defaults will render a [HTTP 403 FORBIDDEN for any HTTP verb that modifies state (PATCH, POST, PUT, DELETE)](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf-configure):\n\n> by default Spring Security\xe2\x80\x99s CSRF protection will produce an HTTP 403 access denied.\n\nFor now we can disable the default behavior with `http.csrf().disable()`\n\n\n#### Testing the secured Backend\n\nSee https://www.baeldung.com/rest-assured-authentication\n\nInside our [BackendControllerTest](backend/src/test/java/de/jonashackt/springbootvuejs/controller/BackendControllerTest.java) we should check, whether our API reacts with correct HTTP 401 UNAUTHORIZED, when called without our User credentials:\n\n```\n\t@Test\n\tpublic void secured_api_should_react_with_unauthorized_per_default() {\n\n\t\tgiven()\n\t\t.when()\n\t\t\t.get("/api/secured")\n\t\t.then()\n\t\t\t.statusCode(HttpStatus.SC_UNAUTHORIZED);\n\t}\n```\n\nUsing `rest-assured` we can also test, if one could access the API correctly with the credentials included:\n\n```\n\t@Test\n\tpublic void secured_api_should_give_http_200_when_authorized() {\n\n\t\tgiven()\n\t\t\t.auth().basic("foo", "bar")\n\t\t.when()\n\t\t\t.get("/api/secured")\n\t\t.then()\n\t\t\t.statusCode(HttpStatus.SC_OK)\n\t\t\t.assertThat()\n\t\t\t\t.body(is(equalTo(BackendController.SECURED_TEXT)));\n\t}\n```\n\nThe crucial point here is to use the `given().auth().basic("foo", "bar")` configuration to inject the correct credentials properly.\n\n\n\n#### Configure credentials inside application.properties and environment variables\n\nDefining the users (and passwords) inside code (like our [WebSecurityConfiguration.class](backend/src/main/java/de/jonashackt/springbootvuejs/configuration/WebSecurityConfiguration.java)) that should be given access to our application is a test-only practice!\n\nFor our super simple example application, we could have a solution quite similar - but much more safe: If we would be able to extract this code into configuration and later use Spring\'s powerful mechanism of overriding these configuration with environment variables, we could then store them safely inside our deployment pipelines settings, that are again secured by another login - e.g. as Heroku Config Vars.\n\nTherefore the first step would be to delete the following code:\n\n```\n@Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.inMemoryAuthentication()\n                .withUser("foo").password("{noop}bar").roles("USER");\n    }\n```\n\nand add the following configuration to our [application.properties](backend/src/main/resources/application.properties):\n\n```\nspring.security.user.name=sina\nspring.security.user.password=miller\n```\n\nRunning our tests using the old credentials should fail now. Providing the newer one, the test should go green again.\n\nNow introducing environment variables to the game could also be done locally inside our IDE for example. First change the test `secured_api_should_give_http_200_when_authorized` again and choose some new credentials like user `maik` with pw `meyer`.\n\nDon\'t change the `application.properties` right now - use your IDE\'s run configuration and insert two environment variables:\n\n```\nSPRING_SECURITY_USER_NAME=maik\nSPRING_SECURITY_USER_PASSWORD=meyer\n```\n\nNow the test should run green again with this new values.\n\n\n## Protect parts of Vue.js frontend\n\nNow that we have secured a specific part of our backend API, let\'s also secure a part of our Vue.js frontend:\n\n        +-----------------------------------------------------------------------+\n        |  Vue.js frontend                                                      |\n        |                                                                       |\n        |   +-----------------+    +-----------------+    +-----------------+   |\n        |   |                 |    |                 |    |                 |   |\n        |   |                 |    |                 |    |  Protected      |   |\n        |   |                 |    |                 |    |                 |   |\n        |   |                 |    |                 |    |  Vue.js View    |   |\n        |   |                 |    |                 |    |                 |   |\n        |   +-----------------+    +-----------------+    +-----------------+   |\n        |                                                                       |\n        +-----------------------------------------------------------------------+\n\n                   +---+                  +---+                  +---+\n                   |   | /api/hello       |   | /api/user        |   | /api/secured\n                   +---+                  +---+                  +---+\n                     |                      |                      |\n        +-----------------------------------------------------------------------+\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |  Spring Boot backend                                                  |\n        +-----------------------------------------------------------------------+\n\n\n#### Create a new Vue Login component\n\nAs there is already a secured Backend API, we also want to have a secured frontend part. \n\nEvery solution you find on the net seems to be quite overengineered for the "super-small-we-have-to-ship-today-app". Why should we bother with a frontend auth store like vuex at the beginning? Why start with OAuth right up front? These could be easily added later on!\n\nThe simplest solution one could think about how to secure our frontend, would be to create a simple Login.vue component, that simply accesses the `/api/secured` resource every time the login is used.\n\nTherefore we use [Vue.js conditionals](https://vuejs.org/v2/guide/conditional.html) to show something on our new [Login.vue](frontend/src/components/Login.vue):\n\n```\n<template>\n  <div class="protected" v-if="loginSuccess">\n    <h1><b-badge variant="success">Access to protected site granted!</b-badge></h1>\n    <h5>If you\'re able to read this, you\'ve successfully logged in.</h5>\n  </div>\n  <div class="unprotected" v-else-if="loginError">\n    <h1><b-badge variant="danger">You don\'t have rights here, mate :D</b-badge></h1>\n    <h5>Seams that you don\'t have access rights... </h5>\n  </div>\n  <div class="unprotected" v-else>\n    <h1><b-badge variant="info">Please login to get access!</b-badge></h1>\n    <h5>You\'re not logged in - so you don\'t see much here. Try to log in:</h5>\n\n    <form @submit.prevent="callLogin()">\n      <input type="text" placeholder="username" v-model="user">\n      <input type="password" placeholder="password" v-model="password">\n      <b-btn variant="success" type="submit">Login</b-btn>\n      <p v-if="error" class="error">Bad login information</p>\n    </form>\n  </div>\n\n</template>\n\n<script>\nimport api from \'./backend-api\'\n\nexport default {\n  name: \'login\',\n\n  data () {\n    return {\n      loginSuccess: false,\n      loginError: false,\n      user: \'\',\n      password: \'\',\n      error: false\n    }\n  }\n}\n\n</script>\n``` \n\nFor now the conditional is only handled by two boolean values: `loginSuccess` and `loginError`.\n\nTo bring those to life, we implement the `callLogin()` method:\n\n```\n,\n  methods: {\n    callLogin() {\n      api.getSecured(this.user, this.password).then(response => {\n        console.log("Response: \'" + response.data + "\' with Statuscode " + response.status)\n        if(response.status == 200) {\n          this.loginSuccess = true\n        }\n      }).catch(error => {\n        console.log("Error: " + error)\n        this.loginError = true\n      })\n    }\n  }\n```\n\nWith this simple implementation, the Login component asks the Spring Boot backend, if a user is allowed to access the `/api/secured` resource. The [backend-api.js](frontend/src/components/backend-api.js) provides an method, which uses axios\' Basic Auth feature:\n\n```\n    getSecured(user, password) {\n        return AXIOS.get(`/secured/`,{\n            auth: {\n                username: user,\n                password: password\n            }});\n    }\n``` \n\nNow the Login component works for the first time:\n\n![secure-spring-vue-simple-login](screenshots/secure-spring-vue-simple-login.gif)\n\n\n\n\n#### Protect multiple Vue.js components\n\nNow we have a working Login component. Now let\'s create a new `Protected.vue` component, since we want to have something that\'s only accessible, if somebody has logged in correctly:\n\n```\n<template>\n  <div class="protected" v-if="loginSuccess">\n    <h1><b-badge variant="success">Access to protected site granted!</b-badge></h1>\n    <h5>If you\'re able to read this, you\'ve successfully logged in.</h5>\n  </div>\n  <div class="unprotected" v-else>\n    <h1><b-badge variant="info">Please login to get access!</b-badge></h1>\n    <h5>You\'re not logged in - so you don\'t see much here. Try to log in:</h5>\n    <router-link :to="{ name: \'Login\' }" exact target="_blank">Login</router-link>\n  </div>\n\n</template>\n\n<script>\nimport api from \'./backend-api\'\n\nexport default {\n  name: \'protected\',\n\n  data () {\n    return {\n      loginSuccess: false,\n      error: false\n    }\n  },\n  methods: {\n    //\n  }\n}\n\n</script>\n```\n\nThis component should only be visible, if the appropriate access was granted at the Login. Therefore we need to solve 2 problems:\n\n* __Store the login state__\n* __Redirect user from Protected.vue to Login.vue, if not authenticated before__\n\n\n\n#### Store login information with vuex\n\nThe super dooper simple solution would be to simply use `LocalStorage`. But with [vuex](https://github.com/vuejs/vuex) there is a centralized state management in Vue.js, which is pretty popular. So we should invest some time to get familiar with it. There\'s a full guide available: https://vuex.vuejs.org/guide/ and a great introductory blog post here: https://pusher.com/tutorials/authentication-vue-vuex\n\nYou could also initialize a new Vue.js project with Vue CLI and mark the `vuex` checkbox. But we try to extend the current project here.\n\nFirst we add [the vuex dependency](https://www.npmjs.com/package/vuex) into our [package.json](frontend/package.json):\n\n```\n...\n    "vue": "^2.6.10",\n    "vue-router": "^3.0.6",\n    "vuex": "^3.1.1"\n  },\n```\n\n> There are four things that go into a Vuex module: the initial [state](https://vuex.vuejs.org/guide/state.html), [getters](https://vuex.vuejs.org/guide/getters.html), [mutations](https://vuex.vuejs.org/guide/mutations.html) and [actions](https://vuex.vuejs.org/guide/actions.html)\n\n#### Define the vuex state\n\nTo implement them, we create a new [store.js](frontend/src/store.js) file:\n\n```\nimport Vue from \'vue\'\nimport Vuex from \'vuex\'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    state: {\n        loginSuccess: false,\n        loginError: false,\n        userName: null\n    },\n  mutations: {\n\n  },\n  actions: {\n\n  },\n  getters: {\n  \n  }\n})\n\n``` \n\nWe only have an initial state here, which is that a login could be successful or not - and there should be a `userName`.\n\n\n#### Define a vuex action login() and the mutations login_success & login_error\n\nThen we have a look onto __vuex actions: They provide a way to commit mutations to the vuex store.__ \n\nAs our app here is super simple, we only have one action to implement here: `login`. We omit the `logout` and `register` actions, because we only define one admin user in the Spring Boot backend right now and don\'t need an implemented logout right now. Both could be implemented later!\n\nWe just shift our logic on how to login a user from the `Login.vue` to our vuex action method:\n\n```\n    mutations: {\n        login_success(state, name){\n            state.loginSuccess = true\n            state.userName = name\n\n        },\n        login_error(state){\n            state.loginError = true\n            state.userName = name\n        }\n    },\n    actions: {\n        async login({commit}, user, password) {\n            api.getSecured(user, password)\n                .then(response => {\n                    console.log("Response: \'" + response.data + "\' with Statuscode " + response.status);\n                    if(response.status == 200) {\n                        // place the loginSuccess state into our vuex store\n                        return commit(\'login_success\', name);\n                    }\n                }).catch(error => {\n                    console.log("Error: " + error);\n                    // place the loginError state into our vuex store\n                    commit(\'login_error\', name);\n                    return Promise.reject("Invald credentials!")\n                })\n        }\n    },\n```\n\nInstead of directly setting a boolean to a variable, we `commit` a mutation to our store if the authentication request was successful or unsuccessful. We therefore implement two simple mutations: `login_success` & `login_error`\n\n\n#### Last but not least: define getters for the vuex state\n\nTo be able to access vuex state from within other components, we need to implement getters inside our vuex store. As we only want some simple info, we need the following getters:\n\n```\n    getters: {\n        isLoggedIn: state => state.loginSuccess,\n        hasLoginErrored: state => state.loginError\n    }\n```\n\n#### Use vuex Store inside the Login component and forward to Protected.vue, if Login succeeded\n\nInstead of directly calling the auth endpoint via axios inside our Login component, we now want to use our vuex store and its actions instead. Therefore we don\'t even need to import the [store.js](frontend/src/store.js) inside our `Login.vue`, we can simply access it through `$store`. Thy is that? Because we already did that inside our [main.js](frontend/src/main.js):\n\n```\nimport store from \'./store\'\n\n...\n\nnew Vue({\n    router,\n    store,\n    render: h => h(App)\n}).$mount(\'#app\')\n```\n\nWith that configuration `store` and `router` are accessible from within every Vue component with the `$` prefixed :) \n\nIf we have a look into our `Login.vue` we see that in action:\n\n```\ncallLogin() {\n      this.$store.dispatch(\'login\', { user: this.user, password: this.password})\n        .then(() => this.$router.push(\'/Protected\'))\n        .catch(error => {\n          this.error.push(error)\n        })\n    }\n```\n\nHere we access our vuex store action `login` and issue a login request to our Spring Boot backend. If this succeeds, we use the Vue `$router` to forward the user to our `Protected.vue` component.\n\n\n#### Redirect user from Protected.vue to Login.vue, if not authenticated before\n\nNow let\'s enhance our [router.js](frontend/src/router.js) slightly. We use the Vue.js routers\' [meta field](https://router.vuejs.org/guide/advanced/meta.html) feature to check, whether a user is loggin in already and therefore should be able to access our Protected component with the URI `/protected` :\n\n```\n    {\n        path: \'/protected\',\n        component: Protected,\n        meta: { \n            requiresAuth: true \n        }\n    },\n``` \n\nWe also add a new behavior to our router, that checks if it requires authentication every time a route is accessed. If so, it will redirect to our Login component:\n\n```\nrouter.beforeEach((to, from, next) => {\n    if (to.matched.some(record => record.meta.requiresAuth)) {\n        // this route requires auth, check if logged in\n        // if not, redirect to login page.\n        if (!store.getters.isLoggedIn) {\n            next({\n                path: \'/login\'\n            })\n        } else {\n            next();\n        }\n    } else {\n        next(); // make sure to always call next()!\n    }\n});\n```\n\nNow if one clicks onto `Protected` and didn\'t login prior, our application redirects to `Login` automatically:\n\n![secure-spring-redirect-to-login](screenshots/secure-spring-redirect-to-login.gif)\n\nWith this redirect, we also don\'t need the part with `<div class="protected" v-if="loginSuccess">` inside our Login.vue, since in case of a successful login, the user is directly redirected to the Protected.vue.\n\n\n## Check auth state at secured backend endpoints\n\nWe\'re now already where we wanted to be at the first place: Our Spring Boot backend has a secured API endpoint, which works with simple user/password authentication. And our Vue.js frontend uses this endpoint to do a Login and protect the `Protected` component, if the user didn\'t log in before. The login state is held in the frontend, using the `vuex` store.\n\nNow if we want to go a step ahead and call a secured API endpoint in the backend from within our `Protected` frontend component, we need to fully store the credentials inside our `vuex` store, so we could access our secured resource\n\n\n        +-----------------------------------------------------------------------+\n        |  Vue.js frontend                                                      |\n        |                          +----------------------------------------+   |\n        |                          |                vuex store              |   |\n        |                          +----------------------------------------+   |\n        |                                   |                      |            |\n        |   +-----------------+    +-----------------+    +-----------------+   |\n        |   |                 |    |                 |    |                 |   |\n        |   |                 |    |    Login.vue    |    |    Protected    |   |\n        |   |                 |    |                 |    |                 |   |\n        |   +-----------------+    +-----------------+    +-----------------+   |\n        |                                           |               |           |\n        +-------------------------------------------|---------------|-----------+\n                                                    |-------------| |  \n                   +---+                  +---+                  +---+\n                   |   | /api/hello       |   | /api/user        |   | /api/secured\n                   +---+                  +---+                  +---+\n                     |                      |                      |\n        +-----------------------------------------------------------------------+\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |                                                                       |\n        |  Spring Boot backend                                                  |\n        +-----------------------------------------------------------------------+\n\nTherefore we enhance our [store.js](frontend/src/store.js):\n\n```\nexport default new Vuex.Store({\n    state: {\n        loginSuccess: false,\n        loginError: false,\n        userName: null,\n        userPass: null,\n        response: []\n    },\n    mutations: {\n        login_success(state, payload){\n            state.loginSuccess = true;\n            state.userName = payload.userName;\n            state.userPass = payload.userPass;\n        },\n    ...\n    },\n    actions: {\n        login({commit}, {user, password}) {\n            ...\n                            // place the loginSuccess state into our vuex store\n                            commit(\'login_success\', {\n                                userName: user,\n                                userPass: password\n                            });\n            ...\n    getters: {\n        isLoggedIn: state => state.loginSuccess,\n        hasLoginErrored: state => state.loginError,\n        getUserName: state => state.userName,\n        getUserPass: state => state.userPass\n    }\n```\n\n> Be sure to use the current way to define and [interact with vuex mutations](https://vuex.vuejs.org/guide/mutations.html). Lot\'s of blog posts are using an old way of committing multiple parameters like `commit(\'auth_success\', token, user)`. This DOES NOT work anymore. Only the first parameter will be set, the others are lost! \n\nNow inside our [Protected.vue](frontend/src/components/Protected.vue), we can use the stored credentials to access our `/secured` endpoint:\n\n```\n<script>\n  import api from \'./backend-api\'\n  import store from \'./../store\'\n\nexport default {\n  name: \'protected\',\n\n  data () {\n    return {\n      backendResponse: \'\',\n      securedApiCallSuccess: false,\n      errors: null\n    }\n  },\n  methods: {\n    getSecuredTextFromBackend() {\n      api.getSecured(store.getters.getUserName, store.getters.getUserPass)\n              .then(response => {\n                console.log("Response: \'" + response.data + "\' with Statuscode " + response.status);\n                this.securedApiCallSuccess = true;\n                this.backendResponse = response.data;\n              })\n              .catch(error => {\n                console.log("Error: " + error);\n                this.errors = error;\n              })\n    }\n  }\n}\n```\n\nFeel free to create a nice GUI based on `securedApiCallSuccess`, `backendResponse` and `errors` :)\n\n\n\n# Links\n\nNice introductory video: https://www.youtube.com/watch?v=z6hQqgvGI4Y\n\nExamples: https://vuejs.org/v2/examples/\n\nEasy to use web-based Editor: https://vuejs.org/v2/examples/\n\nhttp://vuetips.com/\n'