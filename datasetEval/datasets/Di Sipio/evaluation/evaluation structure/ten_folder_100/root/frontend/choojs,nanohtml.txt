b'# nanohtml\n[![npm version][2]][3] [![build status][4]][5]\n[![downloads][8]][9] [![js-standard-style][10]][11]\n\nHTML template strings for the Browser with support for Server Side\nRendering in Node.\n\n## Installation\n```sh\n$ npm install nanohtml\n```\n\n## Usage\n### Browser\n```js\nvar html = require(\'nanohtml\')\n\nvar el = html`\n  <body>\n    <h1>Hello planet</h1>\n  </body>\n`\n\ndocument.body.appendChild(el)\n```\n\n### Node\nNode doesn\'t have a DOM available. So in order to render HTML we use string\nconcatenation instead. This has the fun benefit of being quite efficient, which\nin turn means it\'s great for server rendering!\n\n```js\nvar html = require(\'nanohtml\')\n\nvar el = html`\n  <body>\n    <h1>Hello planet</h1>\n  </body>\n`\n\nconsole.log(el.toString())\n```\n\n### Node with custom DOM\nModules like [`jsdom`](https://github.com/jsdom/jdsom) implement (parts of)\nthe DOM in pure JavaScript. If you don\'t really need the performance of\nstring concatenation, or use nanohtml components that modify the raw DOM, use\n`nanohtml/dom` to give nanohtml a custom Document.\n\n```js\nvar JSDOM = require(\'jsdom\').JSDOM\nvar nanohtml = require(\'nanohtml/dom\')\nvar jsdom = new JSDOM()\n\nvar html = nanohtml(jsdom.window.document)\nvar el = html`\n  <body>\n    <h1>Hello planet</h1>\n  </body>\n`\nel.appendChild(html`<p>A paragraph</p>`)\n\nel.outerHTML === \'<body><h1>Hello planet</h1><p>A paragraph</p></body>\'\n```\n\n### Interpolating unescaped HTML\nBy default all content inside template strings is escaped. This is great for\nstrings, but not ideal if you want to insert HTML that\'s been returned from\nanother function (for example: a markdown renderer). Use `nanohtml/raw` for\nto interpolate HTML directly.\n\n```js\nvar raw = require(\'nanohtml/raw\')\nvar html = require(\'nanohtml\')\n\nvar string = \'<h1>This a regular string.</h1>\'\nvar el = html`\n  <body>\n    ${raw(string)}\n  </body>\n`\n\ndocument.body.appendChild(el)\n```\n\n### Attaching event listeners\n```js\nvar html = require(\'nanohtml\')\n\nvar el = html`\n  <body>\n    <button onclick=${onclick}>\n      Click Me\n    </button>\n  </body>\n`\n\ndocument.body.appendChild(el)\n\nfunction onclick (e) {\n  console.log(`${e.target} was clicked`)\n}\n```\n\n### Multiple root elements\n\nIf you have more than one root element they will be combined with a [DocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment).\n\n```js\nvar html = require(\'nanohtml\')\n\nvar el = html`\n  <li>Chashu</li>\n  <li>Nori</li>\n`\n\ndocument.querySelector(\'ul\').appendChild(el)\n```\n\n## Static optimizations\nParsing HTML has significant overhead. Being able to parse HTML statically,\nahead of time can speed up rendering to be about twice as fast.\n\n### Browserify\n\n#### From the command line\n```sh\n$ browserify -t nanohtml index.js > bundle.js\n```\n\n#### Programmatically\n```js\nvar browserify = require(\'browserify\')\nvar nanohtml = require(\'nanohtml\')\nvar path = require(\'path\')\n\nvar b = browserify(path.join(__dirname, \'index.js\'))\n  .transform(nanohtml)\n\nb.bundle().pipe(process.stdout)\n```\n\n#### In package.json\n```json\n{\n  "name": "my-app",\n  "private": true,\n  "browserify": {\n    "transform": [\n      "nanohtml"\n    ]\n  },\n  "dependencies": {\n    "nanohtml": "^1.0.0"\n  }\n}\n```\n\n### Webpack\nAt the time of writing there\'s no Webpack loader yet. We\'d love a contribution!\n\n### Babel / Parcel\n\nAdd nanohtml to your `.babelrc` config.\n\nWithout options:\n\n```js\n{\n  "plugins": [\n    "nanohtml"\n  ]\n}\n```\n\nWith options:\n\n```js\n{\n  "plugins": [\n    ["nanohtml", {\n      "useImport": true\n    }]\n  ]\n}\n```\n\n#### Options\n\n - `useImport` - Set to true to use `import` statements for injected modules.\n    By default, `require` is used. Enable this if you\'re using Rollup.\n - `appendChildModule` - Import path to a module that contains an `appendChild`\n    function. Defaults to `"nanohtml/lib/append-child"`.\n\n## Attributions\nShout out to [Shama](https://github.com/shama) and\n[Shuhei](https://github.com/shuhei) for their contributions to\n[Bel](https://github.com/shama/bel),\n[yo-yoify](https://github.com/shama/yo-yoify) and\n[pelo](https://github.com/shuhei/pelo). This module is based on their work, and\nwouldn\'t have been possible otherwise!\n\n## See Also\n- [choojs/nanomorph](https://github.com/choojs/nanomorph)\n\n## License\n[MIT](./LICENSE)\n\n[0]: https://img.shields.io/badge/stability-experimental-orange.svg?style=flat-square\n[1]: https://nodejs.org/api/documentation.html#documentation_stability_index\n[2]: https://img.shields.io/npm/v/nanohtml.svg?style=flat-square\n[3]: https://npmjs.org/package/nanohtml\n[4]: https://img.shields.io/travis/choojs/nanohtml/master.svg?style=flat-square\n[5]: https://travis-ci.org/choojs/nanohtml\n[6]: https://img.shields.io/codecov/c/github/choojs/nanohtml/master.svg?style=flat-square\n[7]: https://codecov.io/github/choojs/nanohtml\n[8]: http://img.shields.io/npm/dt/nanohtml.svg?style=flat-square\n[9]: https://npmjs.org/package/nanohtml\n[10]: https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat-square\n[11]: https://github.com/feross/standard\n'