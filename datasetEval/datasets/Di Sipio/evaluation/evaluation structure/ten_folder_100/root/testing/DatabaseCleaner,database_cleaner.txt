b'# Database Cleaner\n\n[![Build Status](https://travis-ci.org/DatabaseCleaner/database_cleaner.svg?branch=master)](https://travis-ci.org/DatabaseCleaner/database_cleaner)\n[![Code Climate](https://codeclimate.com/github/DatabaseCleaner/database_cleaner/badges/gpa.svg)](https://codeclimate.com/github/DatabaseCleaner/database_cleaner)\n\nDatabase Cleaner is a set of gems containing strategies for cleaning your database in Ruby.\n\nThe original use case was to ensure a clean state during tests.\nEach strategy is a small amount of code but is code that is usually needed in any ruby app that is testing with a database.\n\n**NB** Please note that this README is for the unreleased development version of Database Cleaner. With it, you may\nfind inconsistencies compared to the latest released development version, [v1.7.0](https://github.com/DatabaseCleaner/database_cleaner/blob/v1.7.0/README.markdown)\n\n## Gem Setup\n\nInstead of using the `database_cleaner` gem directly, each ORM has its own gem. Most projects will only need the `database_cleaner-active_record` gem:\n\n```ruby\n# Gemfile\ngroup :test do\n  gem \'database_cleaner-active_record\'\nend\n```\n\nIf you are using multiple ORMs, just load multiple gems:\n\n\n```ruby\n# Gemfile\ngroup :test do\n  gem \'database_cleaner-active_record\'\n  gem \'database_cleaner-redis\'\nend\n```\n\n## List of adapters\n\nHere is an overview of the databases and ORMs supported by each adapter:\n\nMySQL, PostgreSQL, SQLite, etc\n* [database_cleaner-active_record](adapters/database_cleaner-active_record)\n* [database_cleaner-sequel](adapters/database_cleaner-sequel)\n* [database_cleaner-data_mapper](adapters/database_cleaner-data_mapper)\n\nCouchDB\n* [database_cleaner-couch_potato](adapters/database_cleaner-couch_potato)\n\nMongoDB\n * [database_cleaner-mongoid](adapters/database_cleaner-mongoid)\n * [database_cleaner-mongo_mapper](adapters/database_cleaner-mongo_mapper)\n * [database_cleaner-moped](adapters/database_cleaner-moped)\n * [database_cleaner-mongo](adapters/database_cleaner-mongo)\n\nRedis\n * [database_cleaner-redis](adapters/database_cleaner-redis)\n * [database_cleaner-ohm](adapters/database_cleaner-ohm)\n\nNeo4j\n * [database_cleaner-neo4j](adapters/database_cleaner-neo4j)\n\nMore details on available configuration options can be found in the README for the specific adapter gem that you\'re using.\n\nFor support or to discuss development please use the [Google Group](http://groups.google.com/group/database_cleaner).\n\n## How to use\n\n```ruby\nrequire \'database_cleaner/active_record\'\n\nDatabaseCleaner.strategy = :truncation\n\n# then, whenever you need to clean the DB\nDatabaseCleaner.clean\n```\n\nWith the `:truncation` strategy you can also pass in options, for example:\n\n```ruby\nDatabaseCleaner.strategy = :truncation, {:only => %w[widgets dogs some_other_table]}\n```\n\n```ruby\nDatabaseCleaner.strategy = :truncation, {:except => %w[widgets]}\n```\n\n(I should point out the truncation strategy will never truncate your schema_migrations table.)\n\nSome strategies need to be started before tests are run (for example the `:transaction` strategy needs to know to open up a transaction). This can be accomplished by calling `DatabaseCleaner.start` at the beginning of the run, or by running the tests inside a block to `DatabaseCleaner.cleaning`. So you would have:\n\n```ruby\nrequire \'database_cleaner/active_record\'\n\nDatabaseCleaner.strategy = :transaction\n\nDatabaseCleaner.start # usually this is called in setup of a test\n\ndirty_the_db\n\nDatabaseCleaner.clean # cleanup of the test\n\n# OR\n\nDatabaseCleaner.cleaning do\n  dirty_the_db\nend\n```\n\nAt times you may want to do a single clean with one strategy.\n\nFor example, you may want to start the process by truncating all the tables, but then use the faster transaction strategy the remaining time. To accomplish this you can say:\n\n```ruby\nrequire \'database_cleaner/active_record\'\n\nDatabaseCleaner.clean_with :truncation\n\nDatabaseCleaner.strategy = :transaction\n\n# then make the DatabaseCleaner.start and DatabaseCleaner.clean calls appropriately\n```\n\n## What strategy is fastest?\n\nFor the SQL libraries the fastest option will be to use `:transaction` as transactions are simply rolled back. If you can use this strategy you should. However, if you wind up needing to use multiple database connections in your tests (i.e. your tests run in a different process than your application) then using this strategy becomes a bit more difficult. You can get around the problem a number of ways.\n\nOne common approach is to force all processes to use the same database connection ([common ActiveRecord hack](http://blog.plataformatec.com.br/2011/12/three-tips-to-improve-the-performance-of-your-test-suite/)) however this approach has been reported to result in non-deterministic failures.\n\nAnother approach is to have the transactions rolled back in the application\'s process and relax the isolation level of the database (so the tests can read the uncommitted transactions).\n\nAn easier, but slower, solution is to use the `:truncation` or `:deletion` strategy.\n\nSo what is fastest out of `:deletion` and `:truncation`? Well, it depends on your table structure and what percentage of tables you populate in an average test. The reasoning is out of the scope of this README but here is a [good SO answer on this topic for Postgres](http://stackoverflow.com/questions/11419536/postgresql-truncation-speed/11423886#11423886).\n\nSome people report much faster speeds with `:deletion` while others say `:truncation` is faster for them. The best approach therefore is it try all options on your test suite and see what is faster.\n\nIf you are using ActiveRecord then take a look at the [additional options](#additional-activerecord-options-for-truncation) available for `:truncation`.\n\nDatabase Cleaner also includes a `null` strategy (that does no cleaning at all) which can be used with any ORM library.\nYou can also explicitly use it by setting your strategy to `nil`.\n\n## Test Framework Examples\n\n### RSpec Example\n\n```ruby\nRSpec.configure do |config|\n\n  config.before(:suite) do\n    DatabaseCleaner.strategy = :transaction\n    DatabaseCleaner.clean_with(:truncation)\n  end\n\n  config.around(:each) do |example|\n    DatabaseCleaner.cleaning do\n      example.run\n    end\n  end\n\nend\n```\n\n### RSpec with Capybara Example\n\nYou\'ll typically discover a feature spec is incorrectly using transaction\ninstead of truncation strategy when the data created in the spec is not\nvisible in the app-under-test.\n\nA frequently occurring example of this is when, after creating a user in a\nspec, the spec mysteriously fails to login with the user. This happens because\nthe user is created inside of an uncommitted transaction on one database\nconnection, while the login attempt is made using a separate database\nconnection. This separate database connection cannot access the\nuncommitted user data created over the first database connection due to\ntransaction isolation.\n\nFor feature specs using a Capybara driver for an external\nJavaScript-capable browser (in practice this is all drivers except\n`:rack_test`), the Rack app under test and the specs do not share a\ndatabase connection.\n\nWhen a spec and app-under-test do not share a database connection,\nyou\'ll likely need to use the truncation strategy instead of the\ntransaction strategy.\n\nSee the suggested config below to temporarily enable truncation strategy\nfor affected feature specs only. This config continues to use transaction\nstrategy for all other specs.\n\nIt\'s also recommended to use `append_after` to ensure `DatabaseCleaner.clean`\nruns *after* the after-test cleanup `capybara/rspec` installs.\n\n```ruby\nrequire \'capybara/rspec\'\n\n#...\n\nRSpec.configure do |config|\n\n  config.use_transactional_fixtures = false\n\n  config.before(:suite) do\n    if config.use_transactional_fixtures?\n      raise(<<-MSG)\n        Delete line `config.use_transactional_fixtures = true` from rails_helper.rb\n        (or set it to false) to prevent uncommitted transactions being used in\n        JavaScript-dependent specs.\n\n        During testing, the app-under-test that the browser driver connects to\n        uses a different database connection to the database connection used by\n        the spec. The app\'s database connection would not be able to access\n        uncommitted transaction data setup over the spec\'s database connection.\n      MSG\n    end\n    DatabaseCleaner.clean_with(:truncation)\n  end\n\n  config.before(:each) do\n    DatabaseCleaner.strategy = :transaction\n  end\n\n  config.before(:each, type: :feature) do\n    # :rack_test driver\'s Rack app under test shares database connection\n    # with the specs, so continue to use transaction strategy for speed.\n    driver_shares_db_connection_with_specs = Capybara.current_driver == :rack_test\n\n    unless driver_shares_db_connection_with_specs\n      # Driver is probably for an external browser with an app\n      # under test that does *not* share a database connection with the\n      # specs, so use truncation strategy.\n      DatabaseCleaner.strategy = :truncation\n    end\n  end\n\n  config.before(:each) do\n    DatabaseCleaner.start\n  end\n\n  config.append_after(:each) do\n    DatabaseCleaner.clean\n  end\n\nend\n```\n\n\n### Minitest Example\n\n```ruby\nDatabaseCleaner.strategy = :transaction\n\nclass Minitest::Spec\n  before :each do\n    DatabaseCleaner.start\n  end\n\n  after :each do\n    DatabaseCleaner.clean\n  end\nend\n\n# with the minitest-around gem, this may be used instead:\nclass Minitest::Spec\n  around do |tests|\n    DatabaseCleaner.cleaning(&tests)\n  end\nend\n```\n\n### Cucumber Example\n\nIf you\'re using Cucumber with Rails, just use the generator that ships with cucumber-rails, and that will create all the code you need to integrate DatabaseCleaner into your Rails project.\n\nOtherwise, to add DatabaseCleaner to your project by hand, create a file `features/support/database_cleaner.rb` that looks like this:\n\n```ruby\nrequire \'database_cleaner/active_record\'\n\nDatabaseCleaner.strategy = :truncation\n\nAround do |scenario, block|\n  DatabaseCleaner.cleaning(&block)\nend\n```\n\nThis should cover the basics of tear down between scenarios and keeping your database clean.\n\nFor more examples see the section ["Why?"](#why).\n\n## How to use with multiple ORMs\n\nSometimes you need to use multiple ORMs in your application.\n\nYou can use DatabaseCleaner to clean multiple ORMs, and multiple connections for those ORMs.\n\n```ruby\nrequire \'database_cleaner/active_record\'\nrequire \'database_cleaner/mongo_mapper\'\n\n# How to specify particular orms\nDatabaseCleaner[:active_record].strategy = :transaction\nDatabaseCleaner[:mongo_mapper].strategy = :truncation\n\n# How to specify particular connections\nDatabaseCleaner[:active_record, { :connection => :two }]\n\n# You may also pass in the model directly:\nDatabaseCleaner[:active_record, { :model => ModelWithDifferentConnection }]\n```\n\nUsage beyond that remains the same with `DatabaseCleaner.start` calling any setup on the different configured connections, and `DatabaseCleaner.clean` executing afterwards.\n\n## Why?\n\nOne of my motivations for writing this library was to have an easy way to turn on what Rails calls "transactional_fixtures" in my non-rails ActiveRecord projects.\n\nAfter copying and pasting code to do this several times I decided to package it up as a gem and save everyone a bit of time.\n\n## Common Errors\n\n#### DatabaseCleaner is trying to use the wrong ORM\n\nDatabaseCleaner has a deprecated autodetect mechanism where if you do not explicitly define your ORM it will use the first ORM it can detect that is loaded.\n\nSince ActiveRecord is the most common ORM used that is the first one checked for.\n\nSometimes other libraries (e.g. ActiveAdmin) will load other ORMs (e.g. ActiveRecord) even though you are using a different ORM.  This will result in DatabaseCleaner trying to use the wrong ORM (e.g. ActiveRecord) unless you explicitly require the correct adapter gem:\n\n```ruby\n# Gemfile\ngem "database_cleaner-mongoid"\n```\n\n### STDERR is being flooded when using Postgres\n\nIf you are using Postgres and have foreign key constraints, the truncation strategy will cause a lot of extra noise to appear on STDERR (in the form of "NOTICE truncate cascades" messages).\n\nTo silence these warnings set the following log level in your `postgresql.conf` file:\n\n```ruby\nclient_min_messages = warning\n```\n\nFor ActiveRecord, you add the following parameter in your database.yml file:\n\n<pre>\ntest:\n  adapter: postgresql\n  # ...\n  min_messages: WARNING\n</pre>\n\n## Safeguards\n\nDatabaseCleaner comes with safeguards against:\n\n* Running in production (checking for `ENV`, `RACK_ENV`, and `RAILS_ENV`)\n* Running against a remote database (checking for a `DATABASE_URL` that does not include `localhost`, `.local` or `127.0.0.1`)\n\nBoth safeguards can be disabled separately as follows.\n\nUsing environment variables:\n\n```\nexport DATABASE_CLEANER_ALLOW_PRODUCTION=true\nexport DATABASE_CLEANER_ALLOW_REMOTE_DATABASE_URL=true\n```\n\nIn Ruby:\n\n```ruby\nDatabaseCleaner.allow_production = true\nDatabaseCleaner.allow_remote_database_url = true\n```\n\nIn Ruby, a URL whitelist can be specified. When specified, DatabaseCleaner will only allow `DATABASE_URL` to be equal\nto one of the values specified in the url whitelist like so:\n\n```ruby\nDatabaseCleaner.url_whitelist = [\'postgres://postgres@localhost\', \'postgres://foo@bar\']\n```\n\n## COPYRIGHT\n\nSee [LICENSE] for details.\n'