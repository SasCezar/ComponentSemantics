b'# Toxiproxy\n[![GitHub release](https://img.shields.io/github/release/Shopify/toxiproxy.svg)](https://github.com/Shopify/toxiproxy/releases/latest)\n[![Build Status](https://travis-ci.org/Shopify/toxiproxy.svg?branch=master)](https://travis-ci.org/Shopify/toxiproxy)\n[![IRC Channel](https://img.shields.io/badge/chat-on%20freenode-brightgreen.svg)](https://kiwiirc.com/client/irc.freenode.net/#toxiproxy)\n\n![](http://i.imgur.com/sOaNw0o.png)\n\nToxiproxy is a framework for simulating network conditions. It\'s made\nspecifically to work in testing, CI and development environments, supporting\ndeterministic tampering with connections, but with support for randomized chaos\nand customization. **Toxiproxy is the tool you need to prove with tests that\nyour application doesn\'t have single points of failure.** We\'ve been\nsuccessfully using it in all development and test environments at Shopify since\nOctober, 2014. See our [blog post][blog] on resiliency for more information.\n\nToxiproxy usage consists of two parts. A TCP proxy written in Go (what this\nrepository contains) and a client communicating with the proxy over HTTP. You\nconfigure your application to make all test connections go through Toxiproxy\nand can then manipulate their health via HTTP. See [Usage](#usage)\nbelow on how to set up your project.\n\nFor example, to add 1000ms of latency to the response of MySQL from the [Ruby\nclient](https://github.com/Shopify/toxiproxy-ruby):\n\n```ruby\nToxiproxy[:mysql_master].downstream(:latency, latency: 1000).apply do\n  Shop.first # this takes at least 1s\nend\n```\n\nTo take down all Redis instances:\n\n```ruby\nToxiproxy[/redis/].down do\n  Shop.first # this will throw an exception\nend\n```\n\nWhile the examples in this README are currently in Ruby, there\'s nothing\nstopping you from creating a client in any other language (see\n[Clients](#clients)).\n\n## Table of Contents\n\n1. [Why yet another chaotic TCP proxy?](#why-yet-another-chaotic-tcp-proxy)\n2. [Clients](#clients)\n3. [Example](#example)\n4. [Usage](#usage)\n   1. [Installing](#1-installing-toxiproxy)\n      1. [Upgrading from 1.x](#upgrading-from-toxiproxy-1x)\n   2. [Populating](#2-populating-toxiproxy)\n   3. [Using](#3-using-toxiproxy)\n5. [Toxics](#toxics)\n   1. [Latency](#latency)\n   2. [Down](#down)\n   3. [Bandwidth](#bandwidth)\n   4. [Slow close](#slow_close)\n   5. [Timeout](#timeout)\n   6. [Slicer](#slicer)\n6. [HTTP API](#http-api)\n   1. [Proxy fields](#proxy-fields)\n   2. [Toxic fields](#toxic-fields)\n   3. [Endpoints](#endpoints)\n   4. [Populating Proxies](#populating-proxies)\n7. [CLI example](#cli-example)\n8. [FAQ](#frequently-asked-questions)\n9. [Development](#development)\n\n## Why yet another chaotic TCP proxy?\n\nThe existing ones we found didn\'t provide the kind of dynamic API we needed for\nintegration and unit testing. Linux tools like `nc` and so on are not\ncross-platform and require root, which makes them problematic in test,\ndevelopment and CI environments.\n\n## Clients\n\n* [toxiproxy-ruby](https://github.com/Shopify/toxiproxy-ruby)\n* [toxiproxy-go](https://github.com/Shopify/toxiproxy/tree/master/client)\n* [toxiproxy-python](https://github.com/douglas/toxiproxy-python)\n* [toxiproxy.net](https://github.com/mdevilliers/Toxiproxy.Net)\n* [toxiproxy-php-client](https://github.com/ihsw/toxiproxy-php-client)\n* [toxiproxy-node-client](https://github.com/ihsw/toxiproxy-node-client)\n* [toxiproxy-java](https://github.com/trekawek/toxiproxy-java)\n* [toxiproxy-haskell](https://github.com/jpittis/toxiproxy-haskell)\n\n## Example\n\nLet\'s walk through an example with a Rails application. Note that Toxiproxy is\nin no way tied to Ruby, it\'s just been our first use case. You can see the full example at\n[sirupsen/toxiproxy-rails-example](https://github.com/sirupsen/toxiproxy-rails-example).\nTo get started right away, jump down to [Usage](#usage).\n\nFor our popular blog, for some reason we\'re storing the tags for our posts in\nRedis and the posts themselves in MySQL. We might have a `Post` class that\nincludes some methods to manipulate tags in a [Redis set](http://redis.io/commands#set):\n\n```ruby\nclass Post < ActiveRecord::Base\n  # Return an Array of all the tags.\n  def tags\n    TagRedis.smembers(tag_key)\n  end\n\n  # Add a tag to the post.\n  def add_tag(tag)\n    TagRedis.sadd(tag_key, tag)\n  end\n\n  # Remove a tag from the post.\n  def remove_tag(tag)\n    TagRedis.srem(tag_key, tag)\n  end\n\n  # Return the key in Redis for the set of tags for the post.\n  def tag_key\n    "post:tags:#{self.id}"\n  end\nend\n```\n\nWe\'ve decided that erroring while writing to the tag data store\n(adding/removing) is OK. However, if the tag data store is down, we should be\nable to see the post with no tags. We could simply rescue the\n`Redis::CannotConnectError` around the `SMEMBERS` Redis call in the `tags`\nmethod. Let\'s use Toxiproxy to test that.\n\nSince we\'ve already installed Toxiproxy and it\'s running on our machine, we can\nskip to step 2. This is where we need to make sure Toxiproxy has a mapping for\nRedis tags. To `config/boot.rb` (before any connection is made) we add:\n\n```ruby\nrequire \'toxiproxy\'\n\nToxiproxy.populate([\n  {\n    name: "toxiproxy_test_redis_tags",\n    listen: "127.0.0.1:22222",\n    upstream: "127.0.0.1:6379"\n  }\n])\n```\n\nThen in `config/environments/test.rb` we set the `TagRedis` to be a Redis client\nthat connects to Redis through Toxiproxy by adding this line:\n\n```ruby\nTagRedis = Redis.new(port: 22222)\n```\n\nAll calls in the test environment now go through Toxiproxy. That means we can\nadd a unit test where we simulate a failure:\n\n```ruby\ntest "should return empty array when tag redis is down when listing tags" do\n  @post.add_tag "mammals"\n\n  # Take down all Redises in Toxiproxy\n  Toxiproxy[/redis/].down do\n    assert_equal [], @post.tags\n  end\nend\n```\n\nThe test fails with `Redis::CannotConnectError`. Perfect! Toxiproxy took down\nthe Redis successfully for the duration of the closure. Let\'s fix the `tags`\nmethod to be resilient:\n\n```ruby\ndef tags\n  TagRedis.smembers(tag_key)\nrescue Redis::CannotConnectError\n  []\nend\n```\n\nThe tests pass! We now have a unit test that proves fetching the tags when Redis\nis down returns an empty array, instead of throwing an exception. For full\ncoverage you should also write an integration test that wraps fetching the\nentire blog post page when Redis is down.\n\nFull example application is at\n[sirupsen/toxiproxy-rails-example](https://github.com/sirupsen/toxiproxy-rails-example).\n\n## Usage\n\nConfiguring a project to use Toxiproxy consists of three steps:\n\n1. Installing Toxiproxy\n2. Populating Toxiproxy\n3. Using Toxiproxy\n\n### 1. Installing Toxiproxy\n\n**Linux**\n\nSee [`Releases`](https://github.com/Shopify/toxiproxy/releases) for the latest\nbinaries and system packages for your architecture.\n\n**Ubuntu**\n\n```bash\n$ wget -O toxiproxy-2.1.4.deb https://github.com/Shopify/toxiproxy/releases/download/v2.1.4/toxiproxy_2.1.4_amd64.deb\n$ sudo dpkg -i toxiproxy-2.1.4.deb\n$ sudo service toxiproxy start\n```\n\n**OS X**\n\n```bash\n$ brew tap shopify/shopify\n$ brew install toxiproxy\n```\n\n**Windows**\n\nToxiproxy for Windows is available for download at https://github.com/Shopify/toxiproxy/releases/download/v2.1.4/toxiproxy-server-windows-amd64.exe\n\n**Docker**\n\nToxiproxy is available on [Docker Hub](https://hub.docker.com/r/shopify/toxiproxy/).\n\n```bash\n$ docker pull shopify/toxiproxy\n$ docker run -it shopify/toxiproxy\n```\n\nIf using Toxiproxy from the host rather than other containers, enable host networking with `--net=host`.\n\n**Source**\n\nIf you have Go installed, you can build Toxiproxy from source using the make file:\n```bash\n$ make build\n$ ./toxiproxy-server\n```\n\n#### Upgrading from Toxiproxy 1.x\n\nIn Toxiproxy 2.0 several changes were made to the API that make it incompatible with version 1.x.\nIn order to use version 2.x of the Toxiproxy server, you will need to make sure your client\nlibrary supports the same version. You can check which version of Toxiproxy you are running by\nlooking at the `/version` endpoint.\n\nSee the documentation for your client library for specific library changes. Detailed changes\nfor the Toxiproxy server can been found in [CHANGELOG.md](https://github.com/Shopify/toxiproxy/blob/master/CHANGELOG.md).\n\n### 2. Populating Toxiproxy\n\nWhen your application boots, it needs to make sure that Toxiproxy knows which\nendpoints to proxy where. The main parameters are: name, address for Toxiproxy\nto **listen** on and the address of the upstream.\n\nSome client libraries have helpers for this task, which is essentially just\nmaking sure each proxy in a list is created. Example from the Ruby client:\n\n```ruby\n# Make sure `shopify_test_redis_master` and `shopify_test_mysql_master` are\n# present in Toxiproxy\nToxiproxy.populate([\n  {\n    name: "shopify_test_redis_master",\n    listen: "127.0.0.1:22220",\n    upstream: "127.0.0.1:6379"\n  },\n  {\n    name: "shopify_test_mysql_master",\n    listen: "127.0.0.1:24220",\n    upstream: "127.0.0.1:3306"\n  }\n])\n```\n\nThis code needs to run as early in boot as possible, before any code establishes\na connection through Toxiproxy. Please check your client library for\ndocumentation on the population helpers.\n\nAlternatively use the CLI to create proxies, e.g.:\n\n```bash\ntoxiproxy-cli create shopify_test_redis_master -l localhost:26379 -u localhost:6379\n```\n\nWe recommend a naming such as the above: `<app>_<env>_<data store>_<shard>`.\nThis makes sure there are no clashes between applications using the same\nToxiproxy.\n\nFor large application we recommend storing the Toxiproxy configurations in a\nseparate configuration file. We use `config/toxiproxy.json`. This file can be\npassed to the server using the `-config` option, or loaded by the application\nto use with the `populate` function.\n\nAn example `config/toxiproxy.json`:\n\n```json\n[\n  {\n    "name": "web_dev_frontend_1",\n    "listen": "[::]:18080",\n    "upstream": "webapp.domain:8080",\n    "enabled": true\n  },\n  {\n    "name": "web_dev_mysql_1",\n    "listen": "[::]:13306",\n    "upstream": "database.domain:3306",\n    "enabled": true\n  }\n]\n```\n\nUse ports outside the ephemeral port range to avoid random port conflicts.\nIt\'s `32,768` to `61,000` on Linux by default, see\n`/proc/sys/net/ipv4/ip_local_port_range`.\n\n### 3. Using Toxiproxy\n\nTo use Toxiproxy, you now need to configure your application to connect through\nToxiproxy. Continuing with our example from step two, we can configure our Redis\nclient to connect through Toxiproxy:\n\n```ruby\n# old straight to redis\nredis = Redis.new(port: 6380)\n\n# new through toxiproxy\nredis = Redis.new(port: 22220)\n```\n\nNow you can tamper with it through the Toxiproxy API. In Ruby:\n\n```ruby\nredis = Redis.new(port: 22220)\n\nToxiproxy[:shopify_test_redis_master].downstream(:latency, latency: 1000).apply do\n  redis.get("test") # will take 1s\nend\n```\n\nOr via the CLI:\n\n```bash\ntoxiproxy-cli toxic add shopify_test_redis_master -t latency -a latency=1000\n```\n\nPlease consult your respective client library on usage.\n\n### Toxics\n\nToxics manipulate the pipe between the client and upstream. They can be added\nand removed from proxies using the [HTTP api](#http-api). Each toxic has its own parameters\nto change how it affects the proxy links.\n\nFor documentation on implementing custom toxics, see [CREATING_TOXICS.md](https://github.com/Shopify/toxiproxy/blob/master/CREATING_TOXICS.md)\n\n#### latency\n\nAdd a delay to all data going through the proxy. The delay is equal to `latency` +/- `jitter`.\n\nAttributes:\n\n - `latency`: time in milliseconds\n - `jitter`: time in milliseconds\n\n#### down\n\nBringing a service down is not technically a toxic in the implementation of\nToxiproxy. This is done by `POST`ing to `/proxies/{proxy}` and setting the\n`enabled` field to `false`.\n\n#### bandwidth\n\nLimit a connection to a maximum number of kilobytes per second.\n\nAttributes:\n\n - `rate`: rate in KB/s\n\n#### slow_close\n\nDelay the TCP socket from closing until `delay` has elapsed.\n\nAttributes:\n\n - `delay`: time in milliseconds\n\n#### timeout\n\nStops all data from getting through, and closes the connection after `timeout`. If\n`timeout` is 0, the connection won\'t close, and data will be delayed until the\ntoxic is removed.\n\nAttributes:\n\n - `timeout`: time in milliseconds\n\n#### slicer\n\nSlices TCP data up into small bits, optionally adding a delay between each\nsliced "packet".\n\nAttributes:\n\n - `average_size`: size in bytes of an average packet\n - `size_variation`: variation in bytes of an average packet (should be smaller than average_size)\n - `delay`: time in microseconds to delay each packet by\n\n#### limit_data\n\nCloses connection when transmitted data exceeded limit.\n\n - `bytes`: number of bytes it should transmit before connection is closed\n\n### HTTP API\n\nAll communication with the Toxiproxy daemon from the client happens through the\nHTTP interface, which is described here.\n\nToxiproxy listens for HTTP on port **8474**.\n\n#### Proxy fields:\n\n - `name`: proxy name (string)\n - `listen`: listen address (string)\n - `upstream`: proxy upstream address (string)\n - `enabled`: true/false (defaults to true on creation)\n\nTo change a proxy\'s name, it must be deleted and recreated.\n\nChanging the `listen` or `upstream` fields will restart the proxy and drop any active connections.\n\nIf `listen` is specified with a port of 0, toxiproxy will pick an ephemeral port. The `listen` field\nin the response will be updated with the actual port.\n\nIf you change `enabled` to `false`, it will take down the proxy. You can switch it\nback to `true` to reenable it.\n\n#### Toxic fields:\n\n - `name`: toxic name (string, defaults to `<type>_<stream>`)\n - `type`: toxic type (string)\n - `stream`: link direction to affect (defaults to `downstream`)\n - `toxicity`: probability of the toxic being applied to a link (defaults to 1.0, 100%)\n - `attributes`: a map of toxic-specific attributes\n\nSee [Toxics](#toxics) for toxic-specific attributes.\n\nThe `stream` direction must be either `upstream` or `downstream`. `upstream` applies\nthe toxic on the `client -> server` connection, while `downstream` applies the toxic\non the `server -> client` connection. This can be used to modify requests and responses\nseparately.\n\n#### Endpoints\n\nAll endpoints are JSON.\n\n - **GET /proxies** - List existing proxies and their toxics\n - **POST /proxies** - Create a new proxy\n - **POST /populate** - Create or replace a list of proxies\n - **GET /proxies/{proxy}** - Show the proxy with all its active toxics\n - **POST /proxies/{proxy}** - Update a proxy\'s fields\n - **DELETE /proxies/{proxy}** - Delete an existing proxy\n - **GET /proxies/{proxy}/toxics** - List active toxics\n - **POST /proxies/{proxy}/toxics** - Create a new toxic\n - **GET /proxies/{proxy}/toxics/{toxic}** - Get an active toxic\'s fields\n - **POST /proxies/{proxy}/toxics/{toxic}** - Update an active toxic\n - **DELETE /proxies/{proxy}/toxics/{toxic}** - Remove an active toxic\n - **POST /reset** - Enable all proxies and remove all active toxics\n - **GET /version** - Returns the server version number\n\n#### Populating Proxies\n\nProxies can be added and configured in bulk using the `/populate` endpoint. This is done by\npassing an json array of proxies to toxiproxy. If a proxy with the same name already exists,\nit will be compared to the new proxy and replaced if the `upstream` and `listen` address don\'t match.\n\nA `/populate` call can be included for example at application start to ensure all required proxies\nexist. It is safe to make this call several times, since proxies will be untouched as long as their\nfields are consistent with the new data.\n\n### CLI Example\n\n```bash\n$ toxiproxy-cli create redis -l localhost:26379 -u localhost:6379\nCreated new proxy redis\n$ toxiproxy-cli list\nListen          Upstream        Name  Enabled Toxics\n======================================================================\n127.0.0.1:26379 localhost:6379  redis true    None\n\nHint: inspect toxics with `toxiproxy-client inspect <proxyName>`\n```\n\n```bash\n$ redis-cli -p 26379\n127.0.0.1:26379> SET omg pandas\nOK\n127.0.0.1:26379> GET omg\n"pandas"\n```\n\n```bash\n$ toxiproxy-cli toxic add redis -t latency -a latency=1000\nAdded downstream latency toxic \'latency_downstream\' on proxy \'redis\'\n```\n\n```bash\n$ redis-cli -p 26379\n127.0.0.1:26379> GET omg\n"pandas"\n(1.00s)\n127.0.0.1:26379> DEL omg\n(integer) 1\n(1.00s)\n```\n\n```bash\n$ toxiproxy-cli toxic remove redis -n latency_downstream\nRemoved toxic \'latency_downstream\' on proxy \'redis\'\n```\n\n```bash\n$ redis-cli -p 26379\n127.0.0.1:26379> GET omg\n(nil)\n```\n\n```bash\n$ toxiproxy-cli delete redis\nDeleted proxy redis\n```\n\n```bash\n$ redis-cli -p 26379\nCould not connect to Redis at 127.0.0.1:26379: Connection refused\n```\n\n### Frequently Asked Questions\n\n**How fast is Toxiproxy?** The speed of Toxiproxy depends largely on your hardware,\nbut you can expect a latency of *< 100\xc2\xb5s* when no toxics are enabled. When running\nwith `GOMAXPROCS=4` on a Macbook Pro we achieved *~1000MB/s* throughput, and as high\nas *2400MB/s* on a higher end desktop. Basically, you can expect Toxiproxy to move\ndata around at least as fast the app you\'re testing.\n\n**Can Toxiproxy do randomized testing?** Many of the available toxics can be configured\nto have randomness, such as `jitter` in the `latency` toxic. There is also a\nglobal `toxicity` parameter that specifies the percentage of connections a toxic\nwill affect. This is most useful for things like the `timeout` toxic, which would\nallow X% of connections to timeout.\n\n**I am not seeing my Toxiproxy actions reflected for MySQL**. MySQL will prefer\nthe local Unix domain socket for some clients, no matter which port you pass it\nif the host is set to `localhost`. Configure your MySQL server to not create a\nsocket, and use `127.0.0.1` as the host. Remember to remove the old socket\nafter you restart the server.\n\n**Toxiproxy causes intermittent connection failures**. Use ports outside the\nephemeral port range to avoid random port conflicts. It\'s `32,768` to `61,000` on\nLinux by default, see `/proc/sys/net/ipv4/ip_local_port_range`.\n\n**Should I run a Toxiproxy for each application?** No, we recommend using the\nsame Toxiproxy for all applications. To distinguish between services we\nrecommend naming your proxies with the scheme: `<app>_<env>_<data store>_<shard>`.\nFor example, `shopify_test_redis_master` or `shopify_development_mysql_1`.\n\n### Development\n\n* `make`. Build a toxiproxy development binary for the current platform.\n* `make all`. Build Toxiproxy binaries and packages for all platforms. Requires\n  to have Go compiled with cross compilation enabled on Linux and Darwin (amd64)\n  as well as [`fpm`](https://github.com/jordansissel/fpm) in your `$PATH` to\n  build the Debian package.\n* `make test`. Run the Toxiproxy tests.\n* `make darwin`. Build binary for Darwin.\n* `make linux`. Build binary for Linux.\n* `make windows`. Build binary for Windows.\n\n### Release\n\n1. Ensure this release has run internally for `Shopify/shopify` for at least a\n   day which is the best fuzzy test for robustness we have.\n2. Update `CHANGELOG.md`\n3. Bump `VERSION`\n4. Change versions in `README.md`\n5. Commit\n6. Tag\n7. `make release` to create binaries, packages and push new Docker image\n8. Create [Github draft release](https://github.com/Shopify/toxiproxy/releases/new) against new tag and upload binaries and Debian package\n9. [Bump version for Homebrew](https://github.com/Shopify/homebrew-shopify/blob/master/toxiproxy.rb#L9)\n\n\n[blog]: https://shopifyengineering.myshopify.com/blogs/engineering/building-and-testing-resilient-ruby-on-rails-applications\n'