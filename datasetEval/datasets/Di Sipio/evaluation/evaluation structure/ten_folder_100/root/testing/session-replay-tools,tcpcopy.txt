b'# [TCPCopy](https://github.com/session-replay-tools/tcpcopy) - A TCP Stream Replay Tool\r\n\r\nTCPCopy is a TCP stream replay tool to support real testing of Internet server applications. \r\n\r\n\r\n## Description\r\nAlthough the real live flow is important for the test of Internet server applications, it is hard to simulate it as online environments are too complex. To support more realistic testing of Internet server applications, we develop a live flow reproduction tool - TCPCopy, which could generate the test workload that is similar to the production workload. Currently, TCPCopy has been widely used by companies in China.   \r\n\r\nTCPCopy has little influence on the production system except occupying additional CPU, memory and bandwidth. Moreover, the reproduced workload is similar to the production workload in request diversity, network latency and resource occupation.\r\n\r\n\r\n## Scenarios\r\n* Distributed stress testing\r\n  - Use tcpcopy to copy real-world data to stress test your server software. Bugs that only can be produced in high-stress situations can be found\r\n* Live testing\r\n  - Prove the new system is stable and find bugs that only occur in the real world\r\n* Regression testing\r\n* Performance comparison\r\n\r\n\r\n## Architecture \r\n\r\n![tcpcopy](https://raw.github.com/wangbin579/auxiliary/master/images/tcpcopy.GIF)\r\n\r\nAs shown in Figure 1, TCPCopy consists of two parts:  *tcpcopy* and *intercept*. While *tcpcopy* runs on the online server and captures the online requests, *intercept* runs on the assistant server and does some assistant work, such as passing response info to *tcpcopy*. It should be noted that the test application runs on the target server. \r\n\r\n*tcpcopy* utilizes raw socket input technique by default to capture the online packets at the network layer and does the necessary processing (including TCP interaction simulation, network latency control, and common upper-layer interaction simulation), and uses raw socket output technique by default to send packets to the target server (shown by pink arrows in the figure).\r\n\r\nThe only operation needed on the target server for TCPCopy is setting appropriate route commands to route response packets (shown by green arrows in the figure) to the assistant server. \r\n\r\n*intercept* is responsible for passing the response header(by default) to *tcpcopy*. By capturing the response packets, *intercept* will extract response header information and send the response header to *tcpcopy* using a special channel(shown by purple arrows in the figure). When *tcpcopy* receives the response header, it utilizes the header information to modify the attributes of online packets and continues to send another packet. It should be noticed that the responses from the target server are routed to the assistant server which should act as a black hole.\r\n\r\n\r\n## Quick start\r\n\r\nTwo quick start options are available for *intercept*:\r\n\r\n* [Download the latest intercept release](https://github.com/session-replay-tools/intercept/releases).\r\n* Clone the repo: `git clone git://github.com/session-replay-tools/intercept.git`.\r\n\r\nTwo quick start options are available for *tcpcopy*:\r\n\r\n* [Download the latest tcpcopy release](https://github.com/session-replay-tools/tcpcopy/releases).\r\n* Clone the repo: `git clone git://github.com/session-replay-tools/tcpcopy.git`.\r\n\r\n\r\n## Getting intercept installed on the assistant server\r\n1. cd intercept\r\n2. ./configure \r\n   - choose appropriate configure options if needed\r\n3. make\r\n4. make install\r\n\r\n\r\n### Configure Options for intercept\r\n    --single            run intercept at non-distributed mode\r\n    --with-pfring=PATH  set path to PF_RING library sources\r\n    --with-debug        compile intercept with debug support (saved in a log file)\r\n\r\n\r\n## Getting tcpcopy installed on the online server\r\n1. cd tcpcopy\r\n2. ./configure \r\n    - choose appropriate configure options if needed\r\n3. make\r\n4. make install\r\n\r\n\r\n### Configure Options for tcpcopy\r\n    --offline                   replay TCP streams from the pcap file\r\n    --pcap-capture              capture packets at the data link\r\n    --pcap-send                 send packets at the data link layer instead of the IP layer\r\n    --with-pfring=PATH          set path to PF_RING library sources\r\n    --set-protocol-module=PATH  set tcpcopy to work for an external protocol module\r\n    --single                    if intercept and tcpcopy are both configured with "--single" option, \r\n                                only one tcpcopy works together with intercept, \r\n                                and better performance is achieved.\r\n    --with-tcmalloc             use tcmalloc instead of malloc\r\n    --with-debug                compile tcpcopy with debug support (saved in a log file)\r\n\r\n\r\n   \r\n## Running TCPCopy\r\nAssume *tcpcopy* and *intercept* are both configured with "./configure".\r\n \r\n### 1) On the target server which runs server applications:\r\n      Set route commands appropriately to route response packets to the assistant server\r\n\r\n      For example:\r\n\r\n         Assume 61.135.233.161 is the IP address of the assistant server. We set the \r\n         following route command to route all responses to the 62.135.200.x\'s clients \r\n         to the assistant server.\r\n\r\n           route add -net 62.135.200.0 netmask 255.255.255.0 gw 61.135.233.161\r\n\r\n### 2) On the assistant server which runs intercept(root privilege or the CAP_NET_RAW capability is required):\r\n\r\n       ./intercept -F <filter> -i <device,>\r\n       \r\n       Note that the filter format is the same as the pcap filter.\r\n       For example:\r\n       \r\n          ./intercept -i eth0 -F \'tcp and src port 8080\' -d\r\n          \r\n          intercept will capture response packets of the TCP based application which listens\r\n          on port 8080 from device eth0 \r\n    \r\n\t\r\n### 3) On the online source server (root privilege or the CAP_NET_RAW capability is required):\r\n      \r\n      ./tcpcopy -x localServerPort-targetServerIP:targetServerPort -s <intercept server,> \r\n      [-c <ip range,>]\r\n      \r\n      For example(assume 61.135.233.160 is the IP address of the target server):\r\n\r\n        ./tcpcopy -x 80-61.135.233.160:8080 -s 61.135.233.161 -c 62.135.200.x\r\n        \r\n        tcpcopy would capture port \'80\' packets on current server, change client IP address \r\n        to one of 62.135.200.x series, send these packets to the target port \'8080\' of the \r\n        target server \'61.135.233.160\', and connect 61.135.233.161 for asking intercept to \r\n        pass response packets to it.\r\n        \r\n        Although "-c" parameter is optional, it is set here in order to simplify route \r\n        commands.\r\n\r\n## Note\r\n1. It is tested on Linux only (kernal 2.6 or above)\r\n2. TCPCopy may lose packets hence lose requests\r\n3. Root privilege or the CAP_NET_RAW capability(e.g. setcap CAP_NET_RAW=ep tcpcopy) is required\r\n4. TCPCopy only supports client-initiated connections now\r\n5. TCPCopy does not support replay for server applications which use SSL/TLS\r\n6. For MySQL session replay, please refer to https://github.com/session-replay-tools\r\n7. ip_forward should not be set on the assistant server \r\n8. Please execute "./tcpcopy -h" or "./intercept -h" for more details.\r\n\r\n## Influential Factors\r\nThere are several factors that could influence TCPCopy, which will be introduced in detail in the following sections.\r\n\r\n### 1. Capture Interface\r\n*tcpcopy* utilizes raw socket input interface by default to capture packets at the network layer on the online server. The system kernel may lose some packets when the system is busy. \r\n\r\nIf you configure *tcpcopy* with "--pcap-capture", then *tcpcopy* could capture packets at the data link layer and could also filter packets in the kernel. With PF_RING, *tcpcopy* would lose less packets when using pcap capturing.\r\n\r\nMaybe the best way to capture requests is to mirror ingress packets by switch and then divide the huge traffic to several machines by load balancer.\r\n\r\n### 2. Sending Interface\r\n*tcpcopy* utilizes raw socket output interface by default to send packets at the network layer to a target server. \r\nIf you want to avoid ip_conntrack problems or get better performance, configure *tcpcopy* with "--pcap-send", then with appropriate parameters *tcpcopy* could send packets at the data link layer to a target server.\r\n\r\n### 3.On the Way to the Target Server \r\nWhen a packet is sent by *tcpcopy*, it may encounter many challenges before reaching the target server. As the source IP address in the packet is still the end-user\'s IP address(by default) other than the online server\'s, some security devices may take it for an invalid or forged packet and drop it. In this case, when you use tcpdump to capture packets on the target server, no packets from the expected end-users will be captured. To know whether you are under such circumstances, you can choose a target server in the same network segment to do a test. If packets could be sent to the target server successfully in the same network segment but unsuccessfully across network segments, your packets may be dropped halfway. \r\n\r\nTo solve this problem, we suggest deploying *tcpcopy*, *target applications* and *intercept* on servers in the same network segment. There\'s also another solution with the help of a proxy in the same network segment. *tcpcopy* could send packets to the proxy and then the proxy would send the corresponding requests to the target server in another network segment.\r\n\r\nNote that deploying the target server\'s application on one virtual machine in the same segment may face the above problems.\r\n\r\n### 4. OS of the Target Server\r\nThe target server may set rpfilter, which would check whether the source IP address in the packet is forged. If yes, the packet will be dropped at the network layer.\r\n\r\nIf the target server could not receive any requests although packets can be captured by tcpdump on the target server, you should check if you have any corresponding rpfilter settings. If set, you have to remove the related settings to let the packets pass through the network layer.\r\n\r\nThere are also other reasons that cause *tcpcopy* not working, such as iptables setting problems.\r\n\r\n### 5. Applications on the Target Server\r\nIt is likely that the application on the target server could not process all the requests in time. On the one hand, bugs in the application may make the request not be responded for a long time. On the other hand, some protocols above TCP layer may only process the first request in the socket buffer and leave the remaining requests in the socket buffer unprocessed. \r\n\r\n### 6. OS of the assistant Server\r\nYou should not set ip_forward true or the assistant server can\'t act as a black hole.\r\n\r\n## Release History\r\n+ 2014.09  v1.0    TCPCopy released\r\n\r\n\r\n## Bugs and feature requests\r\nHave a bug or a feature request? [Please open a new issue](https://github.com/session-replay-tools/tcpcopy/issues). Before opening any issue, please search for existing issues.\r\n\r\n## Technical support\r\n\r\n![tcpcopy](https://raw.github.com/wangbin579/auxiliary/master/images/tcpcopy_support.png)\r\n\r\n## Copyright and license\r\n\r\nCopyright 2019 under [the BSD license](LICENSE).\r\n\r\n\r\n'