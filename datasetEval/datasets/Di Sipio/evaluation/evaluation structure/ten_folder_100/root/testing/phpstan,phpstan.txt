b'<h1 align="center">PHPStan - PHP Static Analysis Tool</h1>\n\n<p align="center">\n\t<img src="https://i.imgur.com/MOt7taM.png" alt="PHPStan" width="300" height="300">\n</p>\n\n<p align="center">\n\t<a href="https://travis-ci.org/phpstan/phpstan"><img src="https://travis-ci.org/phpstan/phpstan.svg" alt="Build Status"></a>\n\t<a href="https://packagist.org/packages/phpstan/phpstan"><img src="https://poser.pugx.org/phpstan/phpstan/v/stable" alt="Latest Stable Version"></a>\n\t<a href="https://packagist.org/packages/phpstan/phpstan/stats"><img src="https://poser.pugx.org/phpstan/phpstan/downloads" alt="Total Downloads"></a>\n\t<a href="https://choosealicense.com/licenses/mit/"><img src="https://poser.pugx.org/phpstan/phpstan/license" alt="License"></a>\n\t<a href="https://github.com/phpstan/phpstan"><img src="https://img.shields.io/badge/PHPStan-enabled-brightgreen.svg?style=flat" alt="PHPStan Enabled"></a>\n</p>\n\n------\n\nPHPStan focuses on finding errors in your code without actually running it. It catches whole classes of bugs\neven before you write tests for the code. It moves PHP closer to compiled languages in the sense that the correctness of each line of the code\ncan be checked before you run the actual line.\n\n**[Read more about PHPStan on Medium.com \xc2\xbb](https://medium.com/@ondrejmirtes/phpstan-2939cd0ad0e3)**\n\n**[Try out PHPStan on the on-line playground! \xc2\xbb](https://phpstan.org/)**\n\n## Sponsors\n\n<a href="https://mike-pretzlaw.de/"><img src="https://i.imgur.com/TW2US6H.png" alt="Mike Pretzlaw" width="247" height="64"></a>\n&nbsp;&nbsp;&nbsp;\n<a href="https://coders.thecodingmachine.com/phpstan"><img src="https://i.imgur.com/kQhNOTP.png" alt="TheCodingMachine" width="247" height="64"></a>\n&nbsp;&nbsp;&nbsp;\n<a href="https://packagist.com/?utm_source=phpstan&utm_medium=readme&utm_campaign=sponsorlogo"><img src="https://i.imgur.com/PmMC45f.png" alt="Private Packagist" width="326" height="64"></a>\n&nbsp;&nbsp;&nbsp;\n<a href="https://stackoverflow.com/jobs/273089/backend-software-engineer-musement-spa"><img src="https://i.imgur.com/uw5rAlR.png" alt="Musement" width="247" height="49"></a>\n&nbsp;&nbsp;&nbsp;\n<a href="https://blackfire.io/docs/introduction?utm_source=phpstan&utm_medium=github_readme&utm_campaign=logo"><img src="https://i.imgur.com/zR8rsqk.png" alt="Blackfire.io" width="254" height="64"></a>\n&nbsp;&nbsp;&nbsp;\n<a href="https://www.intracto.com/"><img src="https://i.imgur.com/XRCDGZi.png" alt="Intracto" width="254" height="65"></a>\n\nCheck out [PHPStan\'s Patreon](https://www.patreon.com/phpstan) for sponsoring options. One-time donations [through PayPal](https://paypal.me/phpstan) are also accepted. To request an invoice, [contact me](mailto:ondrej@mirtes.cz) through e-mail.\n\nBTC: bc1qd5s06wjtf8rzag08mk3s264aekn52jze9zeapt\n<br>LTC: LSU5xLsWEfrVx1P9yJwmhziHAXikiE8xtC\n\n## Prerequisites\n\nPHPStan requires PHP >= 7.1. You have to run it in environment with PHP 7.x but the actual code does not have to use\nPHP 7.x features. (Code written for PHP 5.6 and earlier can run on 7.x mostly unmodified.)\n\nPHPStan works best with modern object-oriented code. The more strongly-typed your code is, the more information\nyou give PHPStan to work with.\n\nProperly annotated and typehinted code (class properties, function and method arguments, return types) helps\nnot only static analysis tools but also other people that work with the code to understand it.\n\n## Installation\n\nTo start performing analysis on your code, require PHPStan in [Composer](https://getcomposer.org/):\n\n```\ncomposer require --dev phpstan/phpstan\n```\n\nComposer will install PHPStan\'s executable in its `bin-dir` which defaults to `vendor/bin`.\n\nIf you have conflicting dependencies or you want to install PHPStan globally, the best way is via a PHAR archive. You will always find the latest stable PHAR archive below the [release notes](https://github.com/phpstan/phpstan/releases). You can also use the [phpstan/phpstan-shim](https://packagist.org/packages/phpstan/phpstan-shim) package to install PHPStan via Composer without the risk of conflicting dependencies.\n\n<details>\n  <summary>Use PHPStan via Docker</summary>\n  \n[![Docker Stars](https://img.shields.io/docker/stars/phpstan/phpstan.svg)](https://hub.docker.com/r/phpstan/phpstan/)\n[![Docker Pulls](https://img.shields.io/docker/pulls/phpstan/phpstan.svg)](https://hub.docker.com/r/phpstan/phpstan/)\n\nThe image is based on [Alpine Linux](https://alpinelinux.org/) and built daily.\n\n## Supported tags\n\n- `0.11`, `latest`\n- `0.10`\n- `nightly` (dev-master)\n\n## How to use this image\n\n### Install\n\nInstall the container:\n\n```bash\ndocker pull phpstan/phpstan\n```\n\nAlternatively, pull a specific version:\n\n```bash\ndocker pull phpstan/phpstan:0.11\n```\n\n### Usage\n\nWe are recommend to use the images as an shell alias to access via short-command.\nTo use simply *phpstan* everywhere on CLI add this line to your ~/.zshrc, ~/.bashrc or ~/.profile.\n\n```bash\nalias phpstan=\'docker run -v $PWD:/app --rm phpstan/phpstan\'\n```\n\nIf you don\'t have set the alias, use this command to run the container:\n\n```bash\ndocker run --rm -v /path/to/app:/app phpstan/phpstan [some arguments for PHPStan]\n```\n\nFor example:\n\n```bash\ndocker run --rm -v /path/to/app:/app phpstan/phpstan analyse /app/src\n```\n\n### Customizing\n\n#### Install PHPStan extensions\n\nIf you need an PHPStan extension, for example [phpstan/phpstan-phpunit](https://github.com/phpstan/phpstan-phpunit), you can simply\nextend an existing image and add the relevant extension via Composer.\nIn some cases you need also some additional PHP extensions like DOM. (see section below)\n\nHere is an example Dockerfile for phpstan/phpstan-phpunit:\n\n```dockerfile\nFROM phpstan/phpstan:latest\nRUN composer global require phpstan/phpstan-phpunit\n```\n\nYou can update the `phpstan.neon` file in order to use the extension:\n\n```neon\nincludes:\n    - /composer/vendor/phpstan/phpstan-phpunit/extension.neon\n```\n\n#### Further PHP extension support\n\nSometimes your codebase requires some additional PHP extensions like "intl" or maybe "soap".\n\nTherefore you need to know that our Docker image extends the [official php:cli-alpine Docker image](https://hub.docker.com/_/php).\nSo only [the default built-in extensions](#default-built-in-php-extensions) are available (see below).\nAlso because PHPStan needs no further extensions to run itself.\n\nBut to solve this issue you can extend our Docker image in an own Dockerfile like this, for example to add "soap" and "intl":\n\n```dockerfile\nFROM phpstan/phpstan:latest\nRUN apk --update --progress --no-cache add icu-dev libxml2-dev \\\n    && docker-php-ext-install intl soap\n```\n\n#### Missing classes like "PHPUnit_Framework_TestCase"\n\nOften you use PHAR files like PHPUnit in your projects. These PHAR files provide sometimes own classes\nwhere your project classes extends from. But these cannot be found in\nthe vendor directory and so cannot be autoloaded. So you see error messages like this:\n*"Fatal error: Class \'PHPUnit_Framework_TestCase\' not found"*\n\nTo solve this issue you need an own configuration file, like "phpstan.neon".\nThis file can look like this:\n\n```neon\nparameters:\n\tautoload_files:\n\t\t- path/to/phpunit.phar\n```\n\nAfter creating this file in your project root you can run PHPStan for example via\n\n```bash\ndocker run -v $PWD:/app --rm phpstan/phpstan -c phpstan.neon --level=4\n```\n\nand now the required classes are loaded. Please take also a look in the [relevant part](https://github.com/phpstan/phpstan#autoloading) at the PHPStan documentation.\n\n---\n\n#### Default built-in PHP extensions\n\nYou can use the following command to determine which php extensions are already installed on the base image:\n\n```bash\ndocker run --rm php:cli-alpine -m\n```\n\nThis should give you an output like this:\n\n```ini\n[PHP Modules]\nCore\nctype\ncurl\ndate\ndom\nfileinfo\nfilter\nftp\nhash\niconv\njson\nlibxml\nmbstring\nmysqlnd\nopenssl\npcre\nPDO\npdo_sqlite\nPhar\nposix\nreadline\nReflection\nsession\nSimpleXML\nsodium\nSPL\nsqlite3\nstandard\ntokenizer\nxml\nxmlreader\nxmlwriter\nzlib\n\n[Zend Modules]\n```\n\n</details>\n\n## First run\n\nTo let PHPStan analyse your codebase, you have to use the `analyse` command and point it to the right directories.\n\nSo, for example if you have your classes in directories `src` and `tests`, you can run PHPStan like this:\n\n```bash\nvendor/bin/phpstan analyse src tests\n```\n\nPHPStan will probably find some errors, but don\'t worry, your code might be just fine. Errors found\non the first run tend to be:\n\n* Extra arguments passed to functions (e. g. function requires two arguments, the code passes three)\n* Extra arguments passed to print/sprintf functions (e. g. format string contains one placeholder, the code passes two values to replace)\n* Obvious errors in dead code\n* Magic behaviour that needs to be defined. See [Extensibility](#extensibility).\n\nAfter fixing the obvious mistakes in the code, look to the following section\nfor all the configuration options that will bring the number of reported errors to zero\nmaking PHPStan suitable to run as part of your continuous integration script.\n\n## Rule levels\n\nIf you want to use PHPStan but your codebase isn\'t up to speed with strong typing\nand PHPStan\'s strict checks, you can choose from currently 8 levels\n(0 is the loosest and 7 is the strictest) by passing `--level` to `analyse` command. Default level is `0`.\n\nThis feature enables incremental adoption of PHPStan checks. You can start using PHPStan\nwith a lower rule level and increase it when you feel like it.\n\nYou can also use `--level max` as an alias for the highest level. This will ensure that you will always use the highest level when upgrading to new versions of PHPStan. Please note that this can create a significant obstacle when upgrading to a newer version because you might have to fix a lot of code to bring the number of errors down to zero.\n\n## Extensibility\n\nUnique feature of PHPStan is the ability to define and statically check "magic" behaviour of classes -\naccessing properties that are not defined in the class but are created in `__get` and `__set`\nand invoking methods using `__call`.\n\nSee [Class reflection extensions](#class-reflection-extensions), [Dynamic return type extensions](#dynamic-return-type-extensions) and [Type-specifying extensions](#type-specifying-extensions).\n\nYou can also install official framework-specific extensions:\n\n* [Doctrine](https://github.com/phpstan/phpstan-doctrine)\n* [PHPUnit](https://github.com/phpstan/phpstan-phpunit)\n* [Nette Framework](https://github.com/phpstan/phpstan-nette)\n* [Dibi - Database Abstraction Library](https://github.com/phpstan/phpstan-dibi)\n* [PHP-Parser](https://github.com/phpstan/phpstan-php-parser)\n* [beberlei/assert](https://github.com/phpstan/phpstan-beberlei-assert)\n* [webmozart/assert](https://github.com/phpstan/phpstan-webmozart-assert)\n* [Symfony Framework](https://github.com/phpstan/phpstan-symfony)\n* [Mockery](https://github.com/phpstan/phpstan-mockery)\n\nUnofficial extensions for other frameworks and libraries are also available:\n\n* [Phony](https://github.com/eloquent/phpstan-phony)\n* [Prophecy](https://github.com/Jan0707/phpstan-prophecy)\n* [Laravel](https://github.com/nunomaduro/larastan)\n* [myclabs/php-enum](https://github.com/timeweb/phpstan-enum)\n* [Yii2](https://github.com/proget-hq/phpstan-yii2)\n* [PhpSpec](https://github.com/proget-hq/phpstan-phpspec)\n* [TYPO3](https://github.com/sascha-egerer/phpstan-typo3)\n* [moneyphp/money](https://github.com/JohnstonCode/phpstan-moneyphp)\n* [Drupal](https://github.com/mglaman/phpstan-drupal)\n* [WordPress](https://github.com/szepeviktor/phpstan-wordpress)\n* [Zend Framework](https://github.com/Slamdunk/phpstan-zend-framework)\n\nUnofficial extensions with third-party rules:\n\n* [thecodingmachine / phpstan-strict-rules](https://github.com/thecodingmachine/phpstan-strict-rules)\n* [localheinz / phpstan-rules](https://github.com/localheinz/phpstan-rules)\n* [pepakriz / phpstan-exception-rules](https://github.com/pepakriz/phpstan-exception-rules)\n* [Slamdunk / phpstan-extensions](https://github.com/Slamdunk/phpstan-extensions)\n* [ekino / phpstan-banned-code](https://github.com/ekino/phpstan-banned-code)\n\nNew extensions are becoming available on a regular basis!\n\n## Configuration\n\nConfig file is passed to the `phpstan` executable with `-c` option:\n\n```bash\nvendor/bin/phpstan analyse -l 4 -c phpstan.neon src tests\n```\n\nWhen using a custom project config file, you have to pass the `--level` (`-l`)\noption to `analyse` command (default value does not apply here).\n\nIf you do not provide config file explicitly, PHPStan will look for\nfiles named `phpstan.neon` or `phpstan.neon.dist` in current directory.\n\nThe resolution priority is as such:\n1. If config file is provided on command line, it is used.\n2. If config file `phpstan.neon` exists in current directory, it will be used.\n3. If config file `phpstan.neon.dist` exists in current directory, it will be used.\n4. If none of the above is true, no config will be used.\n\n[NEON file format](https://ne-on.org/) is very similar to YAML.\nAll the following options are part of the `parameters` section.\n\n#### Configuration variables\n - `%rootDir%` - root directory where PHPStan resides (i.e. `vendor/phpstan/phpstan` in Composer installation)\n - `%currentWorkingDirectory%` - current working directory where PHPStan was executed\n\n#### Configuration options\n\n - `tmpDir` - specifies the temporary directory used by PHPStan cache (defaults to `sys_get_temp_dir() . \'/phpstan\'`)\n - `level` - specifies analysis level - if specified, `-l` option is not required\n - `paths` - specifies analysed paths - if specified, paths are not required to be passed as arguments\n\nRelative paths in the configuration are made absolute according to the directory where the configuration file resides.\n\n### Autoloading\n\nPHPStan uses Composer autoloader so the easiest way how to autoload classes\nis through the `autoload`/`autoload-dev` sections in composer.json.\n\n#### Specify paths to scan\n\nIf PHPStan complains about some non-existent classes and you\'re sure the classes\nexist in the codebase AND you don\'t want to use Composer autoloader for some reason,\nyou can specify directories to scan and concrete files to include using\n`autoload_directories` and `autoload_files` array parameters:\n\n```\nparameters:\n\tautoload_directories:\n\t\t- build\n\tautoload_files:\n\t\t- generated/routes/GeneratedRouteList.php\n```\n\n#### Autoloading for global installation\n\nPHPStan supports global installation using [`composer global`](https://getcomposer.org/doc/03-cli.md#global) or via a [PHAR archive](#installation).\nIn this case, it\'s not part of the project autoloader, but it supports autodiscovery of the Composer autoloader\nfrom current working directory residing in `vendor/`:\n\n```bash\ncd /path/to/project\nphpstan analyse src tests # looks for autoloader at /path/to/project/vendor/autoload.php\n```\n\nIf you have your dependencies installed at a different path\nor you\'re running PHPStan from a different directory,\nyou can specify the path to the autoloader with the `--autoload-file|-a` option:\n\n```bash\nphpstan analyse --autoload-file=/path/to/autoload.php src tests\n```\n\n### Exclude files from analysis\n\nIf your codebase contains some files that are broken on purpose\n(e. g. to test behaviour of your application on files with invalid PHP code),\nyou can exclude them using the `excludes_analyse` array parameter. String at each line\nis used as a pattern for the [`fnmatch`](https://secure.php.net/manual/en/function.fnmatch.php) function.\n\n```\nparameters:\n\texcludes_analyse:\n\t\t- tests/*/data/*\n```\n\n### Include custom extensions\n\nIf your codebase contains php files with extensions other than the standard .php extension then you can add them\nto the `fileExtensions` array parameter:\n\n```\nparameters:\n\tfileExtensions:\n\t\t- php\n\t\t- module\n\t\t- inc\n```\n\n### Universal object crates\n\nClasses without predefined structure are common in PHP applications.\nThey are used as universal holders of data - any property can be set and read on them. Notable examples\ninclude `stdClass`, `SimpleXMLElement` (these are enabled by default), objects with results of database queries etc.\nUse `universalObjectCratesClasses` array parameter to let PHPStan know which classes\nwith these characteristics are used in your codebase:\n\n```\nparameters:\n\tuniversalObjectCratesClasses:\n\t\t- Dibi\\Row\n\t\t- Ratchet\\ConnectionInterface\n```\n\n### Add non-obviously assigned variables to scope\n\nIf you use some variables from a try block in your catch blocks, set `polluteCatchScopeWithTryAssignments` boolean parameter to `true`.\n\n```php\ntry {\n\t$author = $this->getLoggedInUser();\n\t$post = $this->postRepository->getById($id);\n} catch (PostNotFoundException $e) {\n\t// $author is probably defined here\n\tthrow new ArticleByAuthorCannotBePublished($author);\n}\n```\n\nIf you are enumerating over all possible situations in if-elseif branches\nand PHPStan complains about undefined variables after the conditions, you can write\nan else branch with throwing an exception:\n\n```php\nif (somethingIsTrue()) {\n\t$foo = true;\n} elseif (orSomethingElseIsTrue()) {\n\t$foo = false;\n} else {\n\tthrow new ShouldNotHappenException();\n}\n\ndoFoo($foo);\n```\n\nI recommend leaving `polluteCatchScopeWithTryAssignments` set to `false` because it leads to a clearer and more maintainable code.\n\n### Custom early terminating method calls\n\nPrevious example showed that if a condition branches end with throwing an exception, that branch does not have\nto define a variable used after the condition branches end.\n\nBut exceptions are not the only way how to terminate execution of a method early. Some specific method calls\ncan be perceived by project developers also as early terminating - like a `redirect()` that stops execution\nby throwing an internal exception.\n\n```php\nif (somethingIsTrue()) {\n\t$foo = true;\n} elseif (orSomethingElseIsTrue()) {\n\t$foo = false;\n} else {\n\t$this->redirect(\'homepage\');\n}\n\ndoFoo($foo);\n```\n\nThese methods can be configured by specifying a class on whose instance they are called like this:\n\n```\nparameters:\n\tearlyTerminatingMethodCalls:\n\t\tNette\\Application\\UI\\Presenter:\n\t\t\t- redirect\n\t\t\t- redirectUrl\n\t\t\t- sendJson\n\t\t\t- sendResponse\n```\n\n### Custom early terminating function calls\nIn addition to the custom early terminating method calls, you can specify custom early terminating function calls. For example a global helper function called `redirect()`\n\nThese functions can be configured by adding them to the `earlyTerminatingFunctionCalls` list like this:\n\n```\nparameters:\n\tearlyTerminatingFunctionCalls:\n\t\t\t- redirect\n```\n\n### Ignore error messages with regular expressions\n\nIf some issue in your code base is not easy to fix or just simply want to deal with it later,\nyou can exclude error messages from the analysis result with regular expressions:\n\n```\nparameters:\n\tignoreErrors:\n\t\t- \'#Call to an undefined method [a-zA-Z0-9\\\\_]+::method\\(\\)#\'\n\t\t- \'#Call to an undefined method [a-zA-Z0-9\\\\_]+::expects\\(\\)#\'\n\t\t- \'#Access to an undefined property PHPUnit_Framework_MockObject_MockObject::\\$[a-zA-Z0-9_]+#\'\n\t\t- \'#Call to an undefined method PHPUnit_Framework_MockObject_MockObject::[a-zA-Z0-9_]+\\(\\)#\'\n```\n\nTo exclude an error in a specific directory or file, specify a `path` or `paths` along with the `message`:\n\n```\nparameters:\n\tignoreErrors:\n\t\t-\n\t\t\tmessage: \'#Call to an undefined method [a-zA-Z0-9\\\\_]+::method\\(\\)#\'\n\t\t\tpath: some/dir/SomeFile.php\n\t\t-\n\t\t\tmessage: \'#Call to an undefined method [a-zA-Z0-9\\\\_]+::method\\(\\)#\'\n\t\t\tpaths:\n\t\t\t\t- some/dir/*\n\t\t\t\t- other/dir/*\n\t\t- \'#Other error to catch anywhere#\'\n```\n\nIf some of the patterns do not occur in the result anymore, PHPStan will let you know\nand you will have to remove the pattern from the configuration. You can turn off\nthis behaviour by setting `reportUnmatchedIgnoredErrors` to `false` in PHPStan configuration.\n\n### Bootstrap file\n\nIf you need to initialize something in PHP runtime before PHPStan runs (like your own autoloader),\nyou can provide your own bootstrap file:\n\n```\nparameters:\n\tbootstrap: phpstan-bootstrap.php\n```\n\n### Custom rules\n\nPHPStan allows writing custom rules to check for specific situations in your own codebase. Your rule class\nneeds to implement the `PHPStan\\Rules\\Rule` interface and registered as a service in the configuration file:\n\n```\nservices:\n\t-\n\t\tclass: MyApp\\PHPStan\\Rules\\DefaultValueTypesAssignedToPropertiesRule\n\t\ttags:\n\t\t\t- phpstan.rules.rule\n```\n\nFor inspiration on how to implement a rule turn to [src/Rules](https://github.com/phpstan/phpstan-src/tree/master/src/Rules)\nto see a lot of built-in rules.\n\nCheck out also [phpstan-strict-rules](https://github.com/phpstan/phpstan-strict-rules) repository for extra strict and opinionated rules for PHPStan!\n\nCheck as well [phpstan-deprecation-rules](https://github.com/phpstan/phpstan-deprecation-rules) for rules that detect usage of deprecated classes, methods, properties, constants and traits!\n\n### Custom error formatters\n\nPHPStan outputs errors via formatters. You can customize the output by implementing the `ErrorFormatter` interface in a new class and add it to the configuration. For existing formatters, see next chapter.\n\n```php\ninterface ErrorFormatter\n{\n\n\t/**\n\t * Formats the errors and outputs them to the console.\n\t *\n\t * @param \\PHPStan\\Command\\AnalysisResult $analysisResult\n\t * @param \\Symfony\\Component\\Console\\Style\\OutputStyle $style\n\t * @return int Error code.\n\t */\n\tpublic function formatErrors(\n\t\tAnalysisResult $analysisResult,\n\t\t\\Symfony\\Component\\Console\\Style\\OutputStyle $style\n\t): int;\n\n}\n```\n\nRegister the formatter in your `phpstan.neon`:\n\n```\nservices:\n\terrorFormatter.awesome:\n\t\tclass: App\\PHPStan\\AwesomeErrorFormatter\n```\n\nUse the name part after `errorFormatter.` as the CLI option value:\n\n```bash\nvendor/bin/phpstan analyse -c phpstan.neon -l 4 --error-format awesome src tests\n```\n\n### Existing error formatters to be used\n\nYou can pass the following keywords to the `--error-format=X` parameter in order to affect the output:\n\n- `table`: Default. Grouped errors by file, colorized. For human consumption.\n- `raw`: Contains one error per line, with path to file, line number, and error description\n- `checkstyle`: Creates a checkstyle.xml compatible output. Note that you\'d have to redirect output into a file in order to capture the results for later processing.\n- `json`: Creates minified .json output without whitespaces. Note that you\'d have to redirect output into a file in order to capture the results for later processing.\n- `prettyJson`: Creates human readable .json output with whitespaces and indentations. Note that you\'d have to redirect output into a file in order to capture the results for later processing.\n- `gitlab`: Creates format for use Code Quality widget on GitLab Merge Request.\n- `baselineNeon`: Creates a .neon output for including in your config. This allows a baseline for existing errors. Note that you\'d have to redirect output into a file in order to capture the results for later processing. [Detailed article about this feature.](https://medium.com/@ondrejmirtes/phpstans-baseline-feature-lets-you-hold-new-code-to-a-higher-standard-e77d815a5dff)\n\n## Class reflection extensions\n\nClasses in PHP can expose "magical" properties and methods decided in run-time using\nclass methods like `__get`, `__set` and `__call`. Because PHPStan is all about static analysis\n(testing code for errors without running it), it has to know about those properties and methods beforehand.\n\nWhen PHPStan stumbles upon a property or a method that is unknown to built-in class reflection, it iterates\nover all registered class reflection extensions until it finds one that defines the property or method.\n\nClass reflection extension cannot have `PHPStan\\Broker\\Broker` (service for obtaining class reflections) injected in the constructor due to circular reference issue, but the extensions can implement `PHPStan\\Reflection\\BrokerAwareExtension` interface to obtain Broker via a setter.\n\n### Properties class reflection extensions\n\nThis extension type must implement the following interface:\n\n```php\nnamespace PHPStan\\Reflection;\n\ninterface PropertiesClassReflectionExtension\n{\n\n\tpublic function hasProperty(ClassReflection $classReflection, string $propertyName): bool;\n\n\tpublic function getProperty(ClassReflection $classReflection, string $propertyName): PropertyReflection;\n\n}\n```\n\nMost likely you will also have to implement a new `PropertyReflection` class:\n\n```php\nnamespace PHPStan\\Reflection;\n\ninterface PropertyReflection\n{\n\n\tpublic function getType(): Type;\n\n\tpublic function getDeclaringClass(): ClassReflection;\n\n\tpublic function isStatic(): bool;\n\n\tpublic function isPrivate(): bool;\n\n\tpublic function isPublic(): bool;\n\n}\n```\n\nThis is how you register the extension in project\'s PHPStan config file:\n\n```\nservices:\n\t-\n\t\tclass: App\\PHPStan\\PropertiesFromAnnotationsClassReflectionExtension\n\t\ttags:\n\t\t\t- phpstan.broker.propertiesClassReflectionExtension\n```\n\n### Methods class reflection extensions\n\nThis extension type must implement the following interface:\n\n```php\nnamespace PHPStan\\Reflection;\n\ninterface MethodsClassReflectionExtension\n{\n\n\tpublic function hasMethod(ClassReflection $classReflection, string $methodName): bool;\n\n\tpublic function getMethod(ClassReflection $classReflection, string $methodName): MethodReflection;\n\n}\n```\n\nMost likely you will also have to implement a new `MethodReflection` class:\n\n```php\nnamespace PHPStan\\Reflection;\n\ninterface MethodReflection\n{\n\n\tpublic function getDeclaringClass(): ClassReflection;\n\n\tpublic function getPrototype(): self;\n\n\tpublic function isStatic(): bool;\n\n\tpublic function isPrivate(): bool;\n\n\tpublic function isPublic(): bool;\n\n\tpublic function getName(): string;\n\n\t/**\n\t * @return \\PHPStan\\Reflection\\ParameterReflection[]\n\t */\n\tpublic function getParameters(): array;\n\n\tpublic function isVariadic(): bool;\n\n\tpublic function getReturnType(): Type;\n\n}\n```\n\nThis is how you register the extension in project\'s PHPStan config file:\n\n```\nservices:\n\t-\n\t\tclass: App\\PHPStan\\EnumMethodsClassReflectionExtension\n\t\ttags:\n\t\t\t- phpstan.broker.methodsClassReflectionExtension\n```\n\n## Dynamic return type extensions\n\nIf the return type of a method is not always the same, but depends on an argument passed to the method,\nyou can specify the return type by writing and registering an extension.\n\nBecause you have to write the code with the type-resolving logic, it can be as complex as you want.\n\nAfter writing the sample extension, the variable `$mergedArticle` will have the correct type:\n\n```php\n$mergedArticle = $this->entityManager->merge($article);\n// $mergedArticle will have the same type as $article\n```\n\nThis is the interface for dynamic return type extension:\n\n```php\nnamespace PHPStan\\Type;\n\nuse PhpParser\\Node\\Expr\\MethodCall;\nuse PHPStan\\Analyser\\Scope;\nuse PHPStan\\Reflection\\MethodReflection;\n\ninterface DynamicMethodReturnTypeExtension\n{\n\n\tpublic function getClass(): string;\n\n\tpublic function isMethodSupported(MethodReflection $methodReflection): bool;\n\n\tpublic function getTypeFromMethodCall(MethodReflection $methodReflection, MethodCall $methodCall, Scope $scope): Type;\n\n}\n```\n\nAnd this is how you\'d write the extension that correctly resolves the EntityManager::merge() return type:\n\n```php\npublic function getClass(): string\n{\n\treturn \\Doctrine\\ORM\\EntityManager::class;\n}\n\npublic function isMethodSupported(MethodReflection $methodReflection): bool\n{\n\treturn $methodReflection->getName() === \'merge\';\n}\n\npublic function getTypeFromMethodCall(MethodReflection $methodReflection, MethodCall $methodCall, Scope $scope): Type\n{\n\tif (count($methodCall->args) === 0) {\n\t\treturn \\PHPStan\\Reflection\\ParametersAcceptorSelector::selectFromArgs(\n\t\t\t$scope,\n\t\t\t$methodCall->args,\n\t\t\t$methodReflection->getVariants()\n\t\t)->getReturnType();\n\t}\n\t$arg = $methodCall->args[0]->value;\n\n\treturn $scope->getType($arg);\n}\n```\n\nAnd finally, register the extension to PHPStan in the project\'s config file:\n\n```\nservices:\n\t-\n\t\tclass: App\\PHPStan\\EntityManagerDynamicReturnTypeExtension\n\t\ttags:\n\t\t\t- phpstan.broker.dynamicMethodReturnTypeExtension\n```\n\nThere\'s also an analogous functionality for:\n\n* **static methods** using `DynamicStaticMethodReturnTypeExtension` interface\nand `phpstan.broker.dynamicStaticMethodReturnTypeExtension` service tag.\n* **functions** using `DynamicFunctionReturnTypeExtension` interface and `phpstan.broker.dynamicFunctionReturnTypeExtension` service tag.\n\n## Type-specifying extensions\n\nThese extensions allow you to specify types of expressions based on certain pre-existing conditions. This is best illustrated with couple examples:\n\n```php\nif (is_int($variable)) {\n    // here we can be sure that $variable is integer\n}\n```\n\n```php\n// using PHPUnit\'s asserts\n\nself::assertNotNull($variable);\n// here we can be sure that $variable is not null\n```\n\nType-specifying extension cannot have `PHPStan\\Analyser\\TypeSpecifier` injected in the constructor due to circular reference issue, but the extensions can implement `PHPStan\\Analyser\\TypeSpecifierAwareExtension` interface to obtain TypeSpecifier via a setter.\n\nThis is the interface for type-specifying extension:\n\n```php\nnamespace PHPStan\\Type;\n\nuse PhpParser\\Node\\Expr\\StaticCall;\nuse PHPStan\\Analyser\\Scope;\nuse PHPStan\\Analyser\\SpecifiedTypes;\nuse PHPStan\\Analyser\\TypeSpecifierContext;\nuse PHPStan\\Reflection\\MethodReflection;\n\ninterface StaticMethodTypeSpecifyingExtension\n{\n\n\tpublic function getClass(): string;\n\n\tpublic function isStaticMethodSupported(MethodReflection $staticMethodReflection, StaticCall $node, TypeSpecifierContext $context): bool;\n\n\tpublic function specifyTypes(MethodReflection $staticMethodReflection, StaticCall $node, Scope $scope, TypeSpecifierContext $context): SpecifiedTypes;\n\n}\n```\n\nAnd this is how you\'d write the extension for the second example above:\n\n```php\npublic function getClass(): string\n{\n\treturn \\PHPUnit\\Framework\\Assert::class;\n}\n\npublic function isStaticMethodSupported(MethodReflection $staticMethodReflection, StaticCall $node, TypeSpecifierContext $context): bool;\n{\n\t// The $context argument tells us if we\'re in an if condition or not (as in this case).\n\treturn $staticMethodReflection->getName() === \'assertNotNull\' && $context->null();\n}\n\npublic function specifyTypes(MethodReflection $staticMethodReflection, StaticCall $node, Scope $scope, TypeSpecifierContext $context): SpecifiedTypes\n{\n\t// Assuming extension implements \\PHPStan\\Analyser\\TypeSpecifierAwareExtension.\n\treturn $this->typeSpecifier->create($node->var, \\PHPStan\\Type\\TypeCombinator::removeNull($scope->getType($node->var)), $context);\n}\n```\n\nAnd finally, register the extension to PHPStan in the project\'s config file:\n\n```\nservices:\n\t-\n\t\tclass: App\\PHPStan\\AssertNotNullTypeSpecifyingExtension\n\t\ttags:\n\t\t\t- phpstan.typeSpecifier.staticMethodTypeSpecifyingExtension\n```\n\nThere\'s also an analogous functionality for:\n\n* **dynamic methods** using `MethodTypeSpecifyingExtension` interface\nand `phpstan.typeSpecifier.methodTypeSpecifyingExtension` service tag.\n* **functions** using `FunctionTypeSpecifyingExtension` interface and `phpstan.typeSpecifier.functionTypeSpecifyingExtension` service tag.\n\n## Known issues\n\n* If `include` or `require` are used in the analysed code (instead of `include_once` or `require_once`),\nPHPStan will throw `Cannot redeclare class` error. Use the `_once` variants to avoid this error.\n* If PHPStan crashes without outputting any error, it\'s quite possible that it\'s\nbecause of a low memory limit set on your system. **Run PHPStan again** to read a couple of hints\nwhat you can do to prevent the crashes.\n\n## Code of Conduct\n\nThis project adheres to a [Contributor Code of Conduct](https://github.com/phpstan/phpstan/blob/master/CODE_OF_CONDUCT.md). By participating in this project and its community, you are expected to uphold this code.\n\n## Contributing\n\nAny contributions are welcome. PHPStan\'s source code open to pull requests lives at [`phpstan/phpstan-src`](https://github.com/phpstan/phpstan-src).\n'