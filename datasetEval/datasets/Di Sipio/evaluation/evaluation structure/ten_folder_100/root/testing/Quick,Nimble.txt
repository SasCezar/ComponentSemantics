b'# Nimble\n\n[![Build Status](https://travis-ci.org/Quick/Nimble.svg?branch=master)](https://travis-ci.org/Quick/Nimble)\n[![CocoaPods](https://img.shields.io/cocoapods/v/Nimble.svg)](https://cocoapods.org/pods/Nimble)\n[![Carthage Compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)\n[![Accio supported](https://img.shields.io/badge/Accio-supported-0A7CF5.svg?style=flat)](https://github.com/JamitLabs/Accio)\n[![Platforms](https://img.shields.io/cocoapods/p/Nimble.svg)](https://cocoapods.org/pods/Nimble)\n[![Reviewed by Hound](https://img.shields.io/badge/Reviewed_by-Hound-8E64B0.svg)](https://houndci.com)\n\nUse Nimble to express the expected outcomes of Swift\nor Objective-C expressions. Inspired by\n[Cedar](https://github.com/pivotal/cedar).\n\n```swift\n// Swift\nexpect(1 + 1).to(equal(2))\nexpect(1.2).to(beCloseTo(1.1, within: 0.1))\nexpect(3) > 2\nexpect("seahorse").to(contain("sea"))\nexpect(["Atlantic", "Pacific"]).toNot(contain("Mississippi"))\nexpect(ocean.isClean).toEventually(beTruthy())\n```\n\n# How to Use Nimble\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [Some Background: Expressing Outcomes Using Assertions in XCTest](#some-background-expressing-outcomes-using-assertions-in-xctest)\n- [Nimble: Expectations Using `expect(...).to`](#nimble-expectations-using-expectto)\n  - [Custom Failure Messages](#custom-failure-messages)\n  - [Type Safety](#type-safety)\n  - [Operator Overloads](#operator-overloads)\n  - [Lazily Computed Values](#lazily-computed-values)\n  - [C Primitives](#c-primitives)\n  - [Asynchronous Expectations](#asynchronous-expectations)\n  - [Objective-C Support](#objective-c-support)\n  - [Disabling Objective-C Shorthand](#disabling-objective-c-shorthand)\n- [Built-in Matcher Functions](#built-in-matcher-functions)\n  - [Type Checking](#type-checking)\n  - [Equivalence](#equivalence)\n  - [Identity](#identity)\n  - [Comparisons](#comparisons)\n  - [Types/Classes](#typesclasses)\n  - [Truthiness](#truthiness)\n  - [Swift Assertions](#swift-assertions)\n  - [Swift Error Handling](#swift-error-handling)\n  - [Exceptions](#exceptions)\n  - [Collection Membership](#collection-membership)\n  - [Strings](#strings)\n  - [Collection Elements](#collection-elements)\n  - [Collection Count](#collection-count)\n  - [Notifications](#notifications)\n  - [Matching a value to any of a group of matchers](#matching-a-value-to-any-of-a-group-of-matchers)\n  - [Custom Validation](#custom-validation)\n- [Writing Your Own Matchers](#writing-your-own-matchers)\n  - [PredicateResult](#predicateresult)\n  - [Lazy Evaluation](#lazy-evaluation)\n  - [Type Checking via Swift Generics](#type-checking-via-swift-generics)\n  - [Customizing Failure Messages](#customizing-failure-messages)\n    - [Basic Customization](#basic-customization)\n    - [Full Customization](#full-customization)\n  - [Supporting Objective-C](#supporting-objective-c)\n    - [Properly Handling `nil` in Objective-C Matchers](#properly-handling-nil-in-objective-c-matchers)\n  - [Migrating from the Old Matcher API](#migrating-from-the-old-matcher-api)\n    - [Minimal Step - Use `.predicate`](#minimal-step---use-predicate)\n    - [Convert to use `Predicate` Type with Old Matcher Constructor](#convert-to-use-predicate-type-with-old-matcher-constructor)\n    - [Convert to `Predicate` Type with Preferred Constructor](#convert-to-predicate-type-with-preferred-constructor)\n    - [Deprecation Roadmap](#deprecation-roadmap)\n- [Installing Nimble](#installing-nimble)\n  - [Installing Nimble as a Submodule](#installing-nimble-as-a-submodule)\n  - [Installing Nimble via CocoaPods](#installing-nimble-via-cocoapods)\n  - [Installing Nimble via Accio](#installing-nimble-via-accio)\n  - [Using Nimble without XCTest](#using-nimble-without-xctest)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# Some Background: Expressing Outcomes Using Assertions in XCTest\n\nApple\'s Xcode includes the XCTest framework, which provides\nassertion macros to test whether code behaves properly.\nFor example, to assert that `1 + 1 = 2`, XCTest has you write:\n\n```swift\n// Swift\n\nXCTAssertEqual(1 + 1, 2, "expected one plus one to equal two")\n```\n\nOr, in Objective-C:\n\n```objc\n// Objective-C\n\nXCTAssertEqual(1 + 1, 2, @"expected one plus one to equal two");\n```\n\nXCTest assertions have a couple of drawbacks:\n\n1. **Not enough macros.** There\'s no easy way to assert that a string\n   contains a particular substring, or that a number is less than or\n   equal to another.\n2. **It\'s hard to write asynchronous tests.** XCTest forces you to write\n   a lot of boilerplate code.\n\nNimble addresses these concerns.\n\n# Nimble: Expectations Using `expect(...).to`\n\nNimble allows you to express expectations using a natural,\neasily understood language:\n\n```swift\n// Swift\n\nimport Nimble\n\nexpect(seagull.squawk).to(equal("Squee!"))\n```\n\n```objc\n// Objective-C\n\n@import Nimble;\n\nexpect(seagull.squawk).to(equal(@"Squee!"));\n```\n\n> The `expect` function autocompletes to include `file:` and `line:`,\n  but these parameters are optional. Use the default values to have\n  Xcode highlight the correct line when an expectation is not met.\n\nTo perform the opposite expectation--to assert something is *not*\nequal--use `toNot` or `notTo`:\n\n```swift\n// Swift\n\nimport Nimble\n\nexpect(seagull.squawk).toNot(equal("Oh, hello there!"))\nexpect(seagull.squawk).notTo(equal("Oh, hello there!"))\n```\n\n```objc\n// Objective-C\n\n@import Nimble;\n\nexpect(seagull.squawk).toNot(equal(@"Oh, hello there!"));\nexpect(seagull.squawk).notTo(equal(@"Oh, hello there!"));\n```\n\n## Custom Failure Messages\n\nWould you like to add more information to the test\'s failure messages? Use the `description` optional argument to add your own text:\n\n```swift\n// Swift\n\nexpect(1 + 1).to(equal(3))\n// failed - expected to equal <3>, got <2>\n\nexpect(1 + 1).to(equal(3), description: "Make sure libKindergartenMath is loaded")\n// failed - Make sure libKindergartenMath is loaded\n// expected to equal <3>, got <2>\n```\n\nOr the *WithDescription version in Objective-C:\n\n```objc\n// Objective-C\n\n@import Nimble;\n\nexpect(@(1+1)).to(equal(@3));\n// failed - expected to equal <3.0000>, got <2.0000>\n\nexpect(@(1+1)).toWithDescription(equal(@3), @"Make sure libKindergartenMath is loaded");\n// failed - Make sure libKindergartenMath is loaded\n// expected to equal <3.0000>, got <2.0000>\n```\n\n## Type Safety\n\nNimble makes sure you don\'t compare two types that don\'t match:\n\n```swift\n// Swift\n\n// Does not compile:\nexpect(1 + 1).to(equal("Squee!"))\n```\n\n> Nimble uses generics--only available in Swift--to ensure\n  type correctness. That means type checking is\n  not available when using Nimble in Objective-C. :sob:\n\n## Operator Overloads\n\nTired of so much typing? With Nimble, you can use overloaded operators\nlike `==` for equivalence, or `>` for comparisons:\n\n```swift\n// Swift\n\n// Passes if squawk does not equal "Hi!":\nexpect(seagull.squawk) != "Hi!"\n\n// Passes if 10 is greater than 2:\nexpect(10) > 2\n```\n\n> Operator overloads are only available in Swift, so you won\'t be able\n  to use this syntax in Objective-C. :broken_heart:\n\n## Lazily Computed Values\n\nThe `expect` function doesn\'t evaluate the value it\'s given until it\'s\ntime to match. So Nimble can test whether an expression raises an\nexception once evaluated:\n\n```swift\n// Swift\n\n// Note: Swift currently doesn\'t have exceptions.\n//       Only Objective-C code can raise exceptions\n//       that Nimble will catch.\n//       (see https://github.com/Quick/Nimble/issues/220#issuecomment-172667064)\nlet exception = NSException(\n    name: NSInternalInconsistencyException,\n    reason: "Not enough fish in the sea.",\n    userInfo: ["something": "is fishy"])\nexpect { exception.raise() }.to(raiseException())\n\n// Also, you can customize raiseException to be more specific\nexpect { exception.raise() }.to(raiseException(named: NSInternalInconsistencyException))\nexpect { exception.raise() }.to(raiseException(\n    named: NSInternalInconsistencyException,\n    reason: "Not enough fish in the sea"))\nexpect { exception.raise() }.to(raiseException(\n    named: NSInternalInconsistencyException,\n    reason: "Not enough fish in the sea",\n    userInfo: ["something": "is fishy"]))\n```\n\nObjective-C works the same way, but you must use the `expectAction`\nmacro when making an expectation on an expression that has no return\nvalue:\n\n```objc\n// Objective-C\n\nNSException *exception = [NSException exceptionWithName:NSInternalInconsistencyException\n                                                 reason:@"Not enough fish in the sea."\n                                               userInfo:nil];\nexpectAction(^{ [exception raise]; }).to(raiseException());\n\n// Use the property-block syntax to be more specific.\nexpectAction(^{ [exception raise]; }).to(raiseException().named(NSInternalInconsistencyException));\nexpectAction(^{ [exception raise]; }).to(raiseException().\n    named(NSInternalInconsistencyException).\n    reason("Not enough fish in the sea"));\nexpectAction(^{ [exception raise]; }).to(raiseException().\n    named(NSInternalInconsistencyException).\n    reason("Not enough fish in the sea").\n    userInfo(@{@"something": @"is fishy"}));\n\n// You can also pass a block for custom matching of the raised exception\nexpectAction(exception.raise()).to(raiseException().satisfyingBlock(^(NSException *exception) {\n    expect(exception.name).to(beginWith(NSInternalInconsistencyException));\n}));\n```\n\n## C Primitives\n\nSome testing frameworks make it hard to test primitive C values.\nIn Nimble, it just works:\n\n```swift\n// Swift\n\nlet actual: CInt = 1\nlet expectedValue: CInt = 1\nexpect(actual).to(equal(expectedValue))\n```\n\nIn fact, Nimble uses type inference, so you can write the above\nwithout explicitly specifying both types:\n\n```swift\n// Swift\n\nexpect(1 as CInt).to(equal(1))\n```\n\n> In Objective-C, Nimble only supports Objective-C objects. To\n  make expectations on primitive C values, wrap then in an object\n  literal:\n\n```objc\nexpect(@(1 + 1)).to(equal(@2));\n```\n\n## Asynchronous Expectations\n\nIn Nimble, it\'s easy to make expectations on values that are updated\nasynchronously. Just use `toEventually` or `toEventuallyNot`:\n\n```swift\n// Swift\nDispatchQueue.main.async {\n    ocean.add("dolphins")\n    ocean.add("whales")\n}\nexpect(ocean).toEventually(contain("dolphins", "whales"))\n```\n\n\n```objc\n// Objective-C\n\ndispatch_async(dispatch_get_main_queue(), ^{\n    [ocean add:@"dolphins"];\n    [ocean add:@"whales"];\n});\nexpect(ocean).toEventually(contain(@"dolphins", @"whales"));\n```\n\nNote: toEventually triggers its polls on the main thread. Blocking the main\nthread will cause Nimble to stop the run loop. This can cause test pollution\nfor whatever incomplete code that was running on the main thread.  Blocking the\nmain thread can be caused by blocking IO, calls to sleep(), deadlocks, and\nsynchronous IPC.\n\nIn the above example, `ocean` is constantly re-evaluated. If it ever\ncontains dolphins and whales, the expectation passes. If `ocean` still\ndoesn\'t contain them, even after being continuously re-evaluated for one\nwhole second, the expectation fails.\n\nSometimes it takes more than a second for a value to update. In those\ncases, use the `timeout` parameter:\n\n```swift\n// Swift\n\n// Waits three seconds for ocean to contain "starfish":\nexpect(ocean).toEventually(contain("starfish"), timeout: 3)\n\n// Evaluate someValue every 0.2 seconds repeatedly until it equals 100, or fails if it timeouts after 5.5 seconds.\nexpect(someValue).toEventually(equal(100), timeout: 5.5, pollInterval: 0.2)\n```\n\n```objc\n// Objective-C\n\n// Waits three seconds for ocean to contain "starfish":\nexpect(ocean).withTimeout(3).toEventually(contain(@"starfish"));\n```\n\nYou can also provide a callback by using the `waitUntil` function:\n\n```swift\n// Swift\n\nwaitUntil { done in\n    ocean.goFish { success in\n        expect(success).to(beTrue())\n        done()\n    }\n}\n```\n\n```objc\n// Objective-C\n\nwaitUntil(^(void (^done)(void)){\n    [ocean goFishWithHandler:^(BOOL success){\n        expect(success).to(beTrue());\n        done();\n    }];\n});\n```\n\n`waitUntil` also optionally takes a timeout parameter:\n\n```swift\n// Swift\n\nwaitUntil(timeout: 10) { done in\n    ocean.goFish { success in\n        expect(success).to(beTrue())\n        done()\n    }\n}\n```\n\n```objc\n// Objective-C\n\nwaitUntilTimeout(10, ^(void (^done)(void)){\n    [ocean goFishWithHandler:^(BOOL success){\n        expect(success).to(beTrue());\n        done();\n    }];\n});\n```\n\nNote: `waitUntil` triggers its timeout code on the main thread. Blocking the main\nthread will cause Nimble to stop the run loop to continue. This can cause test\npollution for whatever incomplete code that was running on the main thread.\nBlocking the main thread can be caused by blocking IO, calls to sleep(),\ndeadlocks, and synchronous IPC.\n\nIn some cases (e.g. when running on slower machines) it can be useful to modify\nthe default timeout and poll interval values. This can be done as follows:\n\n```swift\n// Swift\n\n// Increase the global timeout to 5 seconds:\nNimble.AsyncDefaults.Timeout = 5\n\n// Slow the polling interval to 0.1 seconds:\nNimble.AsyncDefaults.PollInterval = 0.1\n```\n\n## Objective-C Support\n\nNimble has full support for Objective-C. However, there are two things\nto keep in mind when using Nimble in Objective-C:\n\n1. All parameters passed to the `expect` function, as well as matcher\n   functions like `equal`, must be Objective-C objects or can be converted into\n   an `NSObject` equivalent:\n\n   ```objc\n   // Objective-C\n\n   @import Nimble;\n\n   expect(@(1 + 1)).to(equal(@2));\n   expect(@"Hello world").to(contain(@"world"));\n\n   // Boxed as NSNumber *\n   expect(2).to(equal(2));\n   expect(1.2).to(beLessThan(2.0));\n   expect(true).to(beTruthy());\n\n   // Boxed as NSString *\n   expect("Hello world").to(equal("Hello world"));\n\n   // Boxed as NSRange\n   expect(NSMakeRange(1, 10)).to(equal(NSMakeRange(1, 10)));\n   ```\n\n2. To make an expectation on an expression that does not return a value,\n   such as `-[NSException raise]`, use `expectAction` instead of\n   `expect`:\n\n   ```objc\n   // Objective-C\n\n   expectAction(^{ [exception raise]; }).to(raiseException());\n   ```\n\nThe following types are currently converted to an `NSObject` type:\n\n - **C Numeric types** are converted to `NSNumber *`\n - `NSRange` is converted to `NSValue *`\n - `char *` is converted to `NSString *`\n\nFor the following matchers:\n\n- `equal`\n- `beGreaterThan`\n- `beGreaterThanOrEqual`\n- `beLessThan`\n- `beLessThanOrEqual`\n- `beCloseTo`\n- `beTrue`\n- `beFalse`\n- `beTruthy`\n- `beFalsy`\n- `haveCount`\n\nIf you would like to see more, [file an issue](https://github.com/Quick/Nimble/issues).\n\n## Disabling Objective-C Shorthand\n\nNimble provides a shorthand for expressing expectations using the\n`expect` function. To disable this shorthand in Objective-C, define the\n`NIMBLE_DISABLE_SHORT_SYNTAX` macro somewhere in your code before\nimporting Nimble:\n\n```objc\n#define NIMBLE_DISABLE_SHORT_SYNTAX 1\n\n@import Nimble;\n\nNMB_expect(^{ return seagull.squawk; }, __FILE__, __LINE__).to(NMB_equal(@"Squee!"));\n```\n\n> Disabling the shorthand is useful if you\'re testing functions with\n  names that conflict with Nimble functions, such as `expect` or\n  `equal`. If that\'s not the case, there\'s no point in disabling the\n  shorthand.\n\n# Built-in Matcher Functions\n\nNimble includes a wide variety of matcher functions.\n\n## Type Checking\n\nNimble supports checking the type membership of any kind of object, whether\nObjective-C conformant or not:\n\n```swift\n// Swift\n\nprotocol SomeProtocol{}\nclass SomeClassConformingToProtocol: SomeProtocol{}\nstruct SomeStructConformingToProtocol: SomeProtocol{}\n\n// The following tests pass\nexpect(1).to(beAKindOf(Int.self))\nexpect("turtle").to(beAKindOf(String.self))\n\nlet classObject = SomeClassConformingToProtocol()\nexpect(classObject).to(beAKindOf(SomeProtocol.self))\nexpect(classObject).to(beAKindOf(SomeClassConformingToProtocol.self))\nexpect(classObject).toNot(beAKindOf(SomeStructConformingToProtocol.self))\n\nlet structObject = SomeStructConformingToProtocol()\nexpect(structObject).to(beAKindOf(SomeProtocol.self))\nexpect(structObject).to(beAKindOf(SomeStructConformingToProtocol.self))\nexpect(structObject).toNot(beAKindOf(SomeClassConformingToProtocol.self))\n```\n\n```objc\n// Objective-C\n\n// The following tests pass\nNSMutableArray *array = [NSMutableArray array];\nexpect(array).to(beAKindOf([NSArray class]));\nexpect(@1).toNot(beAKindOf([NSNull class]));\n```\n\nObjects can be tested for their exact types using the `beAnInstanceOf` matcher:\n\n```swift\n// Swift\n\nprotocol SomeProtocol{}\nclass SomeClassConformingToProtocol: SomeProtocol{}\nstruct SomeStructConformingToProtocol: SomeProtocol{}\n\n// Unlike the \'beKindOf\' matcher, the \'beAnInstanceOf\' matcher only\n// passes if the object is the EXACT type requested. The following\n// tests pass -- note its behavior when working in an inheritance hierarchy.\nexpect(1).to(beAnInstanceOf(Int.self))\nexpect("turtle").to(beAnInstanceOf(String.self))\n\nlet classObject = SomeClassConformingToProtocol()\nexpect(classObject).toNot(beAnInstanceOf(SomeProtocol.self))\nexpect(classObject).to(beAnInstanceOf(SomeClassConformingToProtocol.self))\nexpect(classObject).toNot(beAnInstanceOf(SomeStructConformingToProtocol.self))\n\nlet structObject = SomeStructConformingToProtocol()\nexpect(structObject).toNot(beAnInstanceOf(SomeProtocol.self))\nexpect(structObject).to(beAnInstanceOf(SomeStructConformingToProtocol.self))\nexpect(structObject).toNot(beAnInstanceOf(SomeClassConformingToProtocol.self))\n```\n\n## Equivalence\n\n```swift\n// Swift\n\n// Passes if \'actual\' is equivalent to \'expected\':\nexpect(actual).to(equal(expected))\nexpect(actual) == expected\n\n// Passes if \'actual\' is not equivalent to \'expected\':\nexpect(actual).toNot(equal(expected))\nexpect(actual) != expected\n```\n\n```objc\n// Objective-C\n\n// Passes if \'actual\' is equivalent to \'expected\':\nexpect(actual).to(equal(expected))\n\n// Passes if \'actual\' is not equivalent to \'expected\':\nexpect(actual).toNot(equal(expected))\n```\n\nValues must be `Equatable`, `Comparable`, or subclasses of `NSObject`.\n`equal` will always fail when used to compare one or more `nil` values.\n\n## Identity\n\n```swift\n// Swift\n\n// Passes if \'actual\' has the same pointer address as \'expected\':\nexpect(actual).to(beIdenticalTo(expected))\nexpect(actual) === expected\n\n// Passes if \'actual\' does not have the same pointer address as \'expected\':\nexpect(actual).toNot(beIdenticalTo(expected))\nexpect(actual) !== expected\n```\n\nIt is important to remember that `beIdenticalTo` only makes sense when comparing\ntypes with reference semantics, which have a notion of identity. In Swift, \nthat means types that are defined as a `class`. \n\nThis matcher will not work when comparing types with value semantics such as\nthose defined as a `struct` or `enum`. If you need to compare two value types,\nconsider what it means for instances of your type to be identical. This may mean\ncomparing individual properties or, if it makes sense to do so, conforming your type \nto `Equatable` and using Nimble\'s equivalence matchers instead.\n\n\n```objc\n// Objective-C\n\n// Passes if \'actual\' has the same pointer address as \'expected\':\nexpect(actual).to(beIdenticalTo(expected));\n\n// Passes if \'actual\' does not have the same pointer address as \'expected\':\nexpect(actual).toNot(beIdenticalTo(expected));\n```\n\n## Comparisons\n\n```swift\n// Swift\n\nexpect(actual).to(beLessThan(expected))\nexpect(actual) < expected\n\nexpect(actual).to(beLessThanOrEqualTo(expected))\nexpect(actual) <= expected\n\nexpect(actual).to(beGreaterThan(expected))\nexpect(actual) > expected\n\nexpect(actual).to(beGreaterThanOrEqualTo(expected))\nexpect(actual) >= expected\n```\n\n```objc\n// Objective-C\n\nexpect(actual).to(beLessThan(expected));\nexpect(actual).to(beLessThanOrEqualTo(expected));\nexpect(actual).to(beGreaterThan(expected));\nexpect(actual).to(beGreaterThanOrEqualTo(expected));\n```\n\n> Values given to the comparison matchers above must implement\n  `Comparable`.\n\nBecause of how computers represent floating point numbers, assertions\nthat two floating point numbers be equal will sometimes fail. To express\nthat two numbers should be close to one another within a certain margin\nof error, use `beCloseTo`:\n\n```swift\n// Swift\n\nexpect(actual).to(beCloseTo(expected, within: delta))\n```\n\n```objc\n// Objective-C\n\nexpect(actual).to(beCloseTo(expected).within(delta));\n```\n\nFor example, to assert that `10.01` is close to `10`, you can write:\n\n```swift\n// Swift\n\nexpect(10.01).to(beCloseTo(10, within: 0.1))\n```\n\n```objc\n// Objective-C\n\nexpect(@(10.01)).to(beCloseTo(@10).within(0.1));\n```\n\nThere is also an operator shortcut available in Swift:\n\n```swift\n// Swift\n\nexpect(actual) \xe2\x89\x88 expected\nexpect(actual) \xe2\x89\x88 (expected, delta)\n\n```\n(Type <kbd>option</kbd>+<kbd>x</kbd> to get `\xe2\x89\x88` on a U.S. keyboard)\n\nThe former version uses the default delta of 0.0001. Here is yet another way to do this:\n\n```swift\n// Swift\n\nexpect(actual) \xe2\x89\x88 expected \xc2\xb1 delta\nexpect(actual) == expected \xc2\xb1 delta\n\n```\n(Type <kbd>option</kbd>+<kbd>shift</kbd>+<kbd>=</kbd> to get `\xc2\xb1` on a U.S. keyboard)\n\nIf you are comparing arrays of floating point numbers, you\'ll find the following useful:\n\n```swift\n// Swift\n\nexpect([0.0, 2.0]) \xe2\x89\x88 [0.0001, 2.0001]\nexpect([0.0, 2.0]).to(beCloseTo([0.1, 2.1], within: 0.1))\n\n```\n\n> Values given to the `beCloseTo` matcher must be coercable into a\n  `Double`.\n\n## Types/Classes\n\n```swift\n// Swift\n\n// Passes if \'instance\' is an instance of \'aClass\':\nexpect(instance).to(beAnInstanceOf(aClass))\n\n// Passes if \'instance\' is an instance of \'aClass\' or any of its subclasses:\nexpect(instance).to(beAKindOf(aClass))\n```\n\n```objc\n// Objective-C\n\n// Passes if \'instance\' is an instance of \'aClass\':\nexpect(instance).to(beAnInstanceOf(aClass));\n\n// Passes if \'instance\' is an instance of \'aClass\' or any of its subclasses:\nexpect(instance).to(beAKindOf(aClass));\n```\n\n> Instances must be Objective-C objects: subclasses of `NSObject`,\n  or Swift objects bridged to Objective-C with the `@objc` prefix.\n\nFor example, to assert that `dolphin` is a kind of `Mammal`:\n\n```swift\n// Swift\n\nexpect(dolphin).to(beAKindOf(Mammal))\n```\n\n```objc\n// Objective-C\n\nexpect(dolphin).to(beAKindOf([Mammal class]));\n```\n\n> `beAnInstanceOf` uses the `-[NSObject isMemberOfClass:]` method to\n  test membership. `beAKindOf` uses `-[NSObject isKindOfClass:]`.\n\n## Truthiness\n\n```swift\n// Passes if \'actual\' is not nil, true, or an object with a boolean value of true:\nexpect(actual).to(beTruthy())\n\n// Passes if \'actual\' is only true (not nil or an object conforming to Boolean true):\nexpect(actual).to(beTrue())\n\n// Passes if \'actual\' is nil, false, or an object with a boolean value of false:\nexpect(actual).to(beFalsy())\n\n// Passes if \'actual\' is only false (not nil or an object conforming to Boolean false):\nexpect(actual).to(beFalse())\n\n// Passes if \'actual\' is nil:\nexpect(actual).to(beNil())\n```\n\n```objc\n// Objective-C\n\n// Passes if \'actual\' is not nil, true, or an object with a boolean value of true:\nexpect(actual).to(beTruthy());\n\n// Passes if \'actual\' is only true (not nil or an object conforming to Boolean true):\nexpect(actual).to(beTrue());\n\n// Passes if \'actual\' is nil, false, or an object with a boolean value of false:\nexpect(actual).to(beFalsy());\n\n// Passes if \'actual\' is only false (not nil or an object conforming to Boolean false):\nexpect(actual).to(beFalse());\n\n// Passes if \'actual\' is nil:\nexpect(actual).to(beNil());\n```\n\n## Swift Assertions\n\nIf you\'re using Swift, you can use the `throwAssertion` matcher to check if an assertion is thrown (e.g. `fatalError()`). This is made possible by [@mattgallagher](https://github.com/mattgallagher)\'s [CwlPreconditionTesting](https://github.com/mattgallagher/CwlPreconditionTesting) library.\n\n```swift\n// Swift\n\n// Passes if \'somethingThatThrows()\' throws an assertion, \n// such as by calling \'fatalError()\' or if a precondition fails:\nexpect { try somethingThatThrows() }.to(throwAssertion())\nexpect { () -> Void in fatalError() }.to(throwAssertion())\nexpect { precondition(false) }.to(throwAssertion())\n\n// Passes if throwing an NSError is not equal to throwing an assertion:\nexpect { throw NSError(domain: "test", code: 0, userInfo: nil) }.toNot(throwAssertion())\n\n// Passes if the code after the precondition check is not run:\nvar reachedPoint1 = false\nvar reachedPoint2 = false\nexpect {\n    reachedPoint1 = true\n    precondition(false, "condition message")\n    reachedPoint2 = true\n}.to(throwAssertion())\n\nexpect(reachedPoint1) == true\nexpect(reachedPoint2) == false\n```\n\nNotes:\n\n* This feature is only available in Swift.\n* It is only supported for `x86_64` binaries, meaning _you cannot run this matcher on iOS devices, only simulators_.\n* The tvOS simulator is supported, but using a different mechanism, requiring you to turn off the `Debug executable` scheme setting for your tvOS scheme\'s Test configuration.\n\n## Swift Error Handling\n\nYou can use the `throwError` matcher to check if an error is thrown.\n\n```swift\n// Swift\n\n// Passes if \'somethingThatThrows()\' throws an \'Error\':\nexpect { try somethingThatThrows() }.to(throwError())\n\n// Passes if \'somethingThatThrows()\' throws an error within a particular domain:\nexpect { try somethingThatThrows() }.to(throwError { (error: Error) in\n    expect(error._domain).to(equal(NSCocoaErrorDomain))\n})\n\n// Passes if \'somethingThatThrows()\' throws a particular error enum case:\nexpect { try somethingThatThrows() }.to(throwError(NSCocoaError.PropertyListReadCorruptError))\n\n// Passes if \'somethingThatThrows()\' throws an error of a particular type:\nexpect { try somethingThatThrows() }.to(throwError(errorType: NimbleError.self))\n```\n\nWhen working directly with `Error` values, using the `matchError` matcher\nallows you to perform certain checks on the error itself without having to\nexplicitly cast the error.\n\nThe `matchError` matcher allows you to check whether or not the error:\n\n- is the same _type_ of error you are expecting.\n- represents a particular error value that you are expecting.\n\nThis can be useful when using `Result` or `Promise` types, for example.\n\n```swift\n// Swift\n\nlet actual: Error = ...\n\n// Passes if \'actual\' represents any error value from the NimbleErrorEnum type:\nexpect(actual).to(matchError(NimbleErrorEnum.self))\n\n// Passes if \'actual\' represents the case \'timeout\' from the NimbleErrorEnum type:\nexpect(actual).to(matchError(NimbleErrorEnum.timeout))\n\n// Passes if \'actual\' contains an NSError equal to the one provided:\nexpect(actual).to(matchError(NSError(domain: "err", code: 123, userInfo: nil)))\n```\n\nNote: This feature is only available in Swift.\n\n## Exceptions\n\n```swift\n// Swift\n\n// Passes if \'actual\', when evaluated, raises an exception:\nexpect(actual).to(raiseException())\n\n// Passes if \'actual\' raises an exception with the given name:\nexpect(actual).to(raiseException(named: name))\n\n// Passes if \'actual\' raises an exception with the given name and reason:\nexpect(actual).to(raiseException(named: name, reason: reason))\n\n// Passes if \'actual\' raises an exception which passes expectations defined in the given closure:\n// (in this case, if the exception\'s name begins with "a r")\nexpect { exception.raise() }.to(raiseException { (exception: NSException) in\n    expect(exception.name).to(beginWith("a r"))\n})\n```\n\n```objc\n// Objective-C\n\n// Passes if \'actual\', when evaluated, raises an exception:\nexpect(actual).to(raiseException())\n\n// Passes if \'actual\' raises an exception with the given name\nexpect(actual).to(raiseException().named(name))\n\n// Passes if \'actual\' raises an exception with the given name and reason:\nexpect(actual).to(raiseException().named(name).reason(reason))\n\n// Passes if \'actual\' raises an exception and it passes expectations defined in the given block:\n// (in this case, if name begins with "a r")\nexpect(actual).to(raiseException().satisfyingBlock(^(NSException *exception) {\n    expect(exception.name).to(beginWith(@"a r"));\n}));\n```\n\nNote: Swift currently doesn\'t have exceptions (see [#220](https://github.com/Quick/Nimble/issues/220#issuecomment-172667064)). \nOnly Objective-C code can raise exceptions that Nimble will catch.\n\n## Collection Membership\n\n```swift\n// Swift\n\n// Passes if all of the expected values are members of \'actual\':\nexpect(actual).to(contain(expected...))\n\n// Passes if \'actual\' is empty (i.e. it contains no elements):\nexpect(actual).to(beEmpty())\n```\n\n```objc\n// Objective-C\n\n// Passes if expected is a member of \'actual\':\nexpect(actual).to(contain(expected));\n\n// Passes if \'actual\' is empty (i.e. it contains no elements):\nexpect(actual).to(beEmpty());\n```\n\n> In Swift `contain` takes any number of arguments. The expectation\n  passes if all of them are members of the collection. In Objective-C,\n  `contain` only takes one argument [for now](https://github.com/Quick/Nimble/issues/27).\n\nFor example, to assert that a list of sea creature names contains\n"dolphin" and "starfish":\n\n```swift\n// Swift\n\nexpect(["whale", "dolphin", "starfish"]).to(contain("dolphin", "starfish"))\n```\n\n```objc\n// Objective-C\n\nexpect(@[@"whale", @"dolphin", @"starfish"]).to(contain(@"dolphin"));\nexpect(@[@"whale", @"dolphin", @"starfish"]).to(contain(@"starfish"));\n```\n\n> `contain` and `beEmpty` expect collections to be instances of\n  `NSArray`, `NSSet`, or a Swift collection composed of `Equatable` elements.\n\nTo test whether a set of elements is present at the beginning or end of\nan ordered collection, use `beginWith` and `endWith`:\n\n```swift\n// Swift\n\n// Passes if the elements in expected appear at the beginning of \'actual\':\nexpect(actual).to(beginWith(expected...))\n\n// Passes if the the elements in expected come at the end of \'actual\':\nexpect(actual).to(endWith(expected...))\n```\n\n```objc\n// Objective-C\n\n// Passes if the elements in expected appear at the beginning of \'actual\':\nexpect(actual).to(beginWith(expected));\n\n// Passes if the the elements in expected come at the end of \'actual\':\nexpect(actual).to(endWith(expected));\n```\n\n> `beginWith` and `endWith` expect collections to be instances of\n  `NSArray`, or ordered Swift collections composed of `Equatable`\n  elements.\n\n  Like `contain`, in Objective-C `beginWith` and `endWith` only support\n  a single argument [for now](https://github.com/Quick/Nimble/issues/27).\n\nFor code that returns collections of complex objects without a strict\nordering, there is the `containElementSatisfying` matcher:\n\n```swift\n// Swift\n\nstruct Turtle {\n    let color: String\n}\n\nlet turtles: [Turtle] = functionThatReturnsSomeTurtlesInAnyOrder()\n\n// This set of matchers passes regardless of whether the array is \n// [{color: "blue"}, {color: "green"}] or [{color: "green"}, {color: "blue"}]:\n\nexpect(turtles).to(containElementSatisfying({ turtle in\n    return turtle.color == "green"\n}))\nexpect(turtles).to(containElementSatisfying({ turtle in\n    return turtle.color == "blue"\n}, "that is a turtle with color \'blue\'"))\n\n// The second matcher will incorporate the provided string in the error message\n// should it fail\n```\n\n```objc\n// Objective-C\n\n@interface Turtle : NSObject\n@property (nonatomic, readonly, nonnull) NSString *color;\n@end\n\n@implementation Turtle \n@end\n\nNSArray<Turtle *> * __nonnull turtles = functionThatReturnsSomeTurtlesInAnyOrder();\n\n// This set of matchers passes regardless of whether the array is \n// [{color: "blue"}, {color: "green"}] or [{color: "green"}, {color: "blue"}]:\n\nexpect(turtles).to(containElementSatisfying(^BOOL(id __nonnull object) {\n    return [[turtle color] isEqualToString:@"green"];\n}));\nexpect(turtles).to(containElementSatisfying(^BOOL(id __nonnull object) {\n    return [[turtle color] isEqualToString:@"blue"];\n}));\n```\n\n## Strings\n\n```swift\n// Swift\n\n// Passes if \'actual\' contains \'substring\':\nexpect(actual).to(contain(substring))\n\n// Passes if \'actual\' begins with \'prefix\':\nexpect(actual).to(beginWith(prefix))\n\n// Passes if \'actual\' ends with \'suffix\':\nexpect(actual).to(endWith(suffix))\n\n// Passes if \'actual\' represents the empty string, "":\nexpect(actual).to(beEmpty())\n\n// Passes if \'actual\' matches the regular expression defined in \'expected\':\nexpect(actual).to(match(expected))\n```\n\n```objc\n// Objective-C\n\n// Passes if \'actual\' contains \'substring\':\nexpect(actual).to(contain(expected));\n\n// Passes if \'actual\' begins with \'prefix\':\nexpect(actual).to(beginWith(prefix));\n\n// Passes if \'actual\' ends with \'suffix\':\nexpect(actual).to(endWith(suffix));\n\n// Passes if \'actual\' represents the empty string, "":\nexpect(actual).to(beEmpty());\n\n// Passes if \'actual\' matches the regular expression defined in \'expected\':\nexpect(actual).to(match(expected))\n```\n\n## Collection Elements\n\nNimble provides a means to check that all elements of a collection pass a given expectation.\n\n### Swift\n\nIn Swift, the collection must be an instance of a type conforming to\n`Sequence`.\n\n```swift\n// Swift\n\n// Providing a custom function:\nexpect([1, 2, 3, 4]).to(allPass { $0! < 5 })\n\n// Composing the expectation with another matcher:\nexpect([1, 2, 3, 4]).to(allPass(beLessThan(5)))\n```\n\n### Objective-C\n\nIn Objective-C, the collection must be an instance of a type which implements\nthe `NSFastEnumeration` protocol, and whose elements are instances of a type\nwhich subclasses `NSObject`.\n\nAdditionally, unlike in Swift, there is no override to specify a custom\nmatcher function.\n\n```objc\n// Objective-C\n\nexpect(@[@1, @2, @3, @4]).to(allPass(beLessThan(@5)));\n```\n\n## Collection Count\n\n```swift\n// Swift\n\n// Passes if \'actual\' contains the \'expected\' number of elements:\nexpect(actual).to(haveCount(expected))\n\n// Passes if \'actual\' does _not_ contain the \'expected\' number of elements:\nexpect(actual).notTo(haveCount(expected))\n```\n\n```objc\n// Objective-C\n\n// Passes if \'actual\' contains the \'expected\' number of elements:\nexpect(actual).to(haveCount(expected))\n\n// Passes if \'actual\' does _not_ contain the \'expected\' number of elements:\nexpect(actual).notTo(haveCount(expected))\n```\n\nFor Swift, the actual value must be an instance of a type conforming to `Collection`.\nFor example, instances of `Array`, `Dictionary`, or `Set`.\n\nFor Objective-C, the actual value must be one of the following classes, or their subclasses:\n\n - `NSArray`,\n - `NSDictionary`,\n - `NSSet`, or\n - `NSHashTable`.\n\n## Notifications\n\n```swift\n// Swift\nlet testNotification = Notification(name: "Foo", object: nil)\n\n// passes if the closure in expect { ... } posts a notification to the default\n// notification center.\nexpect {\n    NotificationCenter.default.postNotification(testNotification)\n}.to(postNotifications(equal([testNotification]))\n\n// passes if the closure in expect { ... } posts a notification to a given\n// notification center\nlet notificationCenter = NotificationCenter()\nexpect {\n    notificationCenter.postNotification(testNotification)\n}.to(postNotifications(equal([testNotification]), fromNotificationCenter: notificationCenter))\n```\n\n> This matcher is only available in Swift.\n\n## Matching a value to any of a group of matchers\n\n```swift\n// Swift\n\n// passes if actual is either less than 10 or greater than 20\nexpect(actual).to(satisfyAnyOf(beLessThan(10), beGreaterThan(20)))\n\n// can include any number of matchers -- the following will pass\n// **be careful** -- too many matchers can be the sign of an unfocused test\nexpect(6).to(satisfyAnyOf(equal(2), equal(3), equal(4), equal(5), equal(6), equal(7)))\n\n// in Swift you also have the option to use the || operator to achieve a similar function\nexpect(82).to(beLessThan(50) || beGreaterThan(80))\n```\n\n```objc\n// Objective-C\n\n// passes if actual is either less than 10 or greater than 20\nexpect(actual).to(satisfyAnyOf(beLessThan(@10), beGreaterThan(@20)))\n\n// can include any number of matchers -- the following will pass\n// **be careful** -- too many matchers can be the sign of an unfocused test\nexpect(@6).to(satisfyAnyOf(equal(@2), equal(@3), equal(@4), equal(@5), equal(@6), equal(@7)))\n```\n\nNote: This matcher allows you to chain any number of matchers together. This provides flexibility,\n      but if you find yourself chaining many matchers together in one test, consider whether you\n      could instead refactor that single test into multiple, more precisely focused tests for\n      better coverage.\n\n## Custom Validation\n\n```swift\n// Swift\n\n// passes if .succeeded is returned from the closure\nexpect({\n    guard case .enumCaseWithAssociatedValueThatIDontCareAbout = actual else {\n        return .failed(reason: "wrong enum case")\n    }\n\n    return .succeeded\n}).to(succeed())\n\n// passes if .failed is returned from the closure\nexpect({\n    guard case .enumCaseWithAssociatedValueThatIDontCareAbout = actual else {\n        return .failed(reason: "wrong enum case")\n    }\n\n    return .succeeded\n}).notTo(succeed())\n```\n\nThe `String` provided with `.failed()` is shown when the test fails.\n\nWhen using `toEventually()` be careful not to make state changes or run process intensive code since this closure will be ran many times.\n\n# Writing Your Own Matchers\n\nIn Nimble, matchers are Swift functions that take an expected\nvalue and return a `Predicate` closure. Take `equal`, for example:\n\n```swift\n// Swift\n\npublic func equal<T: Equatable>(expectedValue: T?) -> Predicate<T> {\n    // Can be shortened to:\n    //   Predicate { actual in  ... }\n    //\n    // But shown with types here for clarity.\n    return Predicate { (actualExpression: Expression<T>) throws -> PredicateResult in\n        let msg = ExpectationMessage.expectedActualValueTo("equal <\\(expectedValue)>")\n        if let actualValue = try actualExpression.evaluate() {\n            return PredicateResult(\n                bool: actualValue == expectedValue!,\n                message: msg\n            )\n        } else {\n            return PredicateResult(\n                status: .fail,\n                message: msg.appendedBeNilHint()\n            )\n        }\n    }\n}\n```\n\nThe return value of a `Predicate` closure is a `PredicateResult` that indicates\nwhether the actual value matches the expectation and what error message to\ndisplay on failure.\n\n> The actual `equal` matcher function does not match when\n  `expected` are nil; the example above has been edited for brevity.\n\nSince matchers are just Swift functions, you can define them anywhere:\nat the top of your test file, in a file shared by all of your tests, or\nin an Xcode project you distribute to others.\n\n> If you write a matcher you think everyone can use, consider adding it\n  to Nimble\'s built-in set of matchers by sending a pull request! Or\n  distribute it yourself via GitHub.\n\nFor examples of how to write your own matchers, just check out the\n[`Matchers` directory](https://github.com/Quick/Nimble/tree/master/Sources/Nimble/Matchers)\nto see how Nimble\'s built-in set of matchers are implemented. You can\nalso check out the tips below.\n\n## PredicateResult\n\n`PredicateResult` is the return struct that `Predicate` return to indicate\nsuccess and failure. A `PredicateResult` is made up of two values:\n`PredicateStatus` and `ExpectationMessage`.\n\nInstead of a boolean, `PredicateStatus` captures a trinary set of values:\n\n```swift\n// Swift\n\npublic enum PredicateStatus {\n// The predicate "passes" with the given expression\n// eg - expect(1).to(equal(1))\ncase matches\n\n// The predicate "fails" with the given expression\n// eg - expect(1).toNot(equal(1))\ncase doesNotMatch\n\n// The predicate never "passes" with the given expression, even if negated\n// eg - expect(nil as Int?).toNot(equal(1))\ncase fail\n\n// ...\n}\n```\n\nMeanwhile, `ExpectationMessage` provides messaging semantics for error reporting.\n\n```swift\n// Swift\n\npublic indirect enum ExpectationMessage {\n// Emits standard error message:\n// eg - "expected to <string>, got <actual>"\ncase expectedActualValueTo(/* message: */ String)\n\n// Allows any free-form message\n// eg - "<string>"\ncase fail(/* message: */ String)\n\n// ...\n}\n```\n\nPredicates should usually depend on either `.expectedActualValueTo(..)` or\n`.fail(..)` when reporting errors. Special cases can be used for the other enum\ncases.\n\nFinally, if your Predicate utilizes other Predicates, you can utilize\n`.appended(details:)` and `.appended(message:)` methods to annotate an existing\nerror with more details.\n\nA common message to append is failing on nils. For that, `.appendedBeNilHint()`\ncan be used.\n\n## Lazy Evaluation\n\n`actualExpression` is a lazy, memoized closure around the value provided to the\n`expect` function. The expression can either be a closure or a value directly\npassed to `expect(...)`. In order to determine whether that value matches,\ncustom matchers should call `actualExpression.evaluate()`:\n\n```swift\n// Swift\n\npublic func beNil<T>() -> Predicate<T> {\n    // Predicate.simpleNilable(..) automatically generates ExpectationMessage for\n    // us based on the string we provide to it. Also, the \'Nilable\' postfix indicates\n    // that this Predicate supports matching against nil actualExpressions, instead of\n    // always resulting in a PredicateStatus.fail result -- which is true for\n    // Predicate.simple(..)\n    return Predicate.simpleNilable("be nil") { actualExpression in\n        let actualValue = try actualExpression.evaluate()\n        return PredicateStatus(bool: actualValue == nil)\n    }\n}\n```\n\nIn the above example, `actualExpression` is not `nil` -- it is a closure\nthat returns a value. The value it returns, which is accessed via the\n`evaluate()` method, may be `nil`. If that value is `nil`, the `beNil`\nmatcher function returns `true`, indicating that the expectation passed.\n\n## Type Checking via Swift Generics\n\nUsing Swift\'s generics, matchers can constrain the type of the actual value\npassed to the `expect` function by modifying the return type.\n\nFor example, the following matcher, `haveDescription`, only accepts actual\nvalues that implement the `Printable` protocol. It checks their `description`\nagainst the one provided to the matcher function, and passes if they are the same:\n\n```swift\n// Swift\n\npublic func haveDescription(description: String) -> Predicate<Printable?> {\n    return Predicate.simple("have description") { actual in\n        return PredicateStatus(bool: actual.evaluate().description == description)\n    }\n}\n```\n\n## Customizing Failure Messages\n\nWhen using `Predicate.simple(..)` or `Predicate.simpleNilable(..)`, Nimble\noutputs the following failure message when an expectation fails:\n\n```swift\n// where `message` is the first string argument and\n// `actual` is the actual value received in `expect(..)`\n"expected to \\(message), got <\\(actual)>"\n```\n\nYou can customize this message by modifying the way you create a `Predicate`.\n\n### Basic Customization\n\nFor slightly more complex error messaging, receive the created failure message\nwith `Predicate.define(..)`:\n\n```swift\n// Swift\n\npublic func equal<T: Equatable>(_ expectedValue: T?) -> Predicate<T> {\n    return Predicate.define("equal <\\(stringify(expectedValue))>") { actualExpression, msg in\n        let actualValue = try actualExpression.evaluate()\n        let matches = actualValue == expectedValue && expectedValue != nil\n        if expectedValue == nil || actualValue == nil {\n            if expectedValue == nil && actualValue != nil {\n                return PredicateResult(\n                    status: .fail,\n                    message: msg.appendedBeNilHint()\n                )\n            }\n            return PredicateResult(status: .fail, message: msg)\n        }\n        return PredicateResult(bool: matches, message: msg)\n    }\n}\n```\n\nIn the example above, `msg` is defined based on the string given to\n`Predicate.define`. The code looks akin to:\n\n```swift\n// Swift\n\nlet msg = ExpectationMessage.expectedActualValueTo("equal <\\(stringify(expectedValue))>")\n```\n\n### Full Customization\n\nTo fully customize the behavior of the Predicate, use the overload that expects\na `PredicateResult` to be returned.\n\nAlong with `PredicateResult`, there are other `ExpectationMessage` enum values you can use:\n\n```swift\npublic indirect enum ExpectationMessage {\n// Emits standard error message:\n// eg - "expected to <message>, got <actual>"\ncase expectedActualValueTo(/* message: */ String)\n\n// Allows any free-form message\n// eg - "<message>"\ncase fail(/* message: */ String)\n\n// Emits standard error message with a custom actual value instead of the default.\n// eg - "expected to <message>, got <actual>"\ncase expectedCustomValueTo(/* message: */ String, /* actual: */ String)\n\n// Emits standard error message without mentioning the actual value\n// eg - "expected to <message>"\ncase expectedTo(/* message: */ String)\n\n// ...\n}\n```\n\nFor matchers that compose other matchers, there are a handful of helper\nfunctions to annotate messages.\n\n`appended(message: String)` is used to append to the original failure message:\n\n```swift\n// produces "expected to be true, got <actual> (use beFalse() for inverse)"\n// appended message do show up inline in Xcode.\n.expectedActualValueTo("be true").appended(message: " (use beFalse() for inverse)")\n```\n\nFor a more comprehensive message that spans multiple lines, use\n`appended(details: String)` instead:\n\n```swift\n// produces "expected to be true, got <actual>\\n\\nuse beFalse() for inverse\\nor use beNil()"\n// details do not show inline in Xcode, but do show up in test logs.\n.expectedActualValueTo("be true").appended(details: "use beFalse() for inverse\\nor use beNil()")\n```\n\n## Supporting Objective-C\n\nTo use a custom matcher written in Swift from Objective-C, you\'ll have\nto extend the `NMBObjCMatcher` class, adding a new class method for your\ncustom matcher. The example below defines the class method\n`+[NMBObjCMatcher beNilMatcher]`:\n\n```swift\n// Swift\n\nextension NMBObjCMatcher {\n    public class func beNilMatcher() -> NMBObjCMatcher {\n        return NMBObjCMatcher { actualBlock, failureMessage, location in\n            let block = ({ actualBlock() as NSObject? })\n            let expr = Expression(expression: block, location: location)\n            return beNil().matches(expr, failureMessage: failureMessage)\n        }\n    }\n}\n```\n\nThe above allows you to use the matcher from Objective-C:\n\n```objc\n// Objective-C\n\nexpect(actual).to([NMBObjCMatcher beNilMatcher]());\n```\n\nTo make the syntax easier to use, define a C function that calls the\nclass method:\n\n```objc\n// Objective-C\n\nFOUNDATION_EXPORT id<NMBMatcher> beNil() {\n    return [NMBObjCMatcher beNilMatcher];\n}\n```\n\n### Properly Handling `nil` in Objective-C Matchers\n\nWhen supporting Objective-C, make sure you handle `nil` appropriately.\nLike [Cedar](https://github.com/pivotal/cedar/issues/100),\n**most matchers do not match with nil**. This is to bring prevent test\nwriters from being surprised by `nil` values where they did not expect\nthem.\n\nNimble provides the `beNil` matcher function for test writer that want\nto make expectations on `nil` objects:\n\n```objc\n// Objective-C\n\nexpect(nil).to(equal(nil)); // fails\nexpect(nil).to(beNil());    // passes\n```\n\nIf your matcher does not want to match with nil, you use `NonNilMatcherFunc`\nand the `canMatchNil` constructor on `NMBObjCMatcher`. Using both types will\nautomatically generate expected value failure messages when they\'re nil.\n\n```swift\n\npublic func beginWith<S: Sequence, T: Equatable where S.Iterator.Element == T>(startingElement: T) -> NonNilMatcherFunc<S> {\n    return NonNilMatcherFunc { actualExpression, failureMessage in\n        failureMessage.postfixMessage = "begin with <\\(startingElement)>"\n        if let actualValue = actualExpression.evaluate() {\n            var actualGenerator = actualValue.makeIterator()\n            return actualGenerator.next() == startingElement\n        }\n        return false\n    }\n}\n\nextension NMBObjCMatcher {\n    public class func beginWithMatcher(expected: AnyObject) -> NMBObjCMatcher {\n        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in\n            let actual = actualExpression.evaluate()\n            let expr = actualExpression.cast { $0 as? NMBOrderedCollection }\n            return beginWith(expected).matches(expr, failureMessage: failureMessage)\n        }\n    }\n}\n```\n\n## Migrating from the Old Matcher API\n\nPreviously (`<7.0.0`), Nimble supported matchers via the following types:\n\n- `Matcher`\n- `NonNilMatcherFunc`\n- `MatcherFunc`\n\nAll of those types have been replaced by `Predicate`. While migrating can be a\nlot of work, Nimble currently provides several steps to aid migration of your\ncustom matchers:\n\n### Minimal Step - Use `.predicate`\n\nNimble provides an extension to the old types that automatically naively\nconverts those types to the newer `Predicate`.\n\n```swift\n// Swift\npublic func beginWith<S: Sequence, T: Equatable where S.Iterator.Element == T>(startingElement: T) -> Predicate<S> {\n    return NonNilMatcherFunc { actualExpression, failureMessage in\n        failureMessage.postfixMessage = "begin with <\\(startingElement)>"\n        if let actualValue = actualExpression.evaluate() {\n            var actualGenerator = actualValue.makeIterator()\n            return actualGenerator.next() == startingElement\n        }\n        return false\n    }.predicate\n}\n```\n\nThis is the simpliest way to externally support `Predicate` which allows easier\ncomposition than the old Nimble matcher interface, with minimal effort to change.\n\n### Convert to use `Predicate` Type with Old Matcher Constructor\n\nThe second most convenient step is to utilize special constructors that\n`Predicate` supports that closely align to the constructors of the old Nimble\nmatcher types.\n\n```swift\n// Swift\npublic func beginWith<S: Sequence, T: Equatable where S.Iterator.Element == T>(startingElement: T) -> Predicate<S> {\n    return Predicate.fromDeprecatedClosure { actualExpression, failureMessage in\n        failureMessage.postfixMessage = "begin with <\\(startingElement)>"\n        if let actualValue = actualExpression.evaluate() {\n            var actualGenerator = actualValue.makeIterator()\n            return actualGenerator.next() == startingElement\n        }\n        return false\n    }\n}\n```\n\nThis allows you to completely drop the old types from your code, although the\nintended behavior may alter slightly to what is desired.\n\n### Convert to `Predicate` Type with Preferred Constructor\n\nFinally, you can convert to the native `Predicate` format using one of the\nconstructors not used to assist in the migration.\n\n### Deprecation Roadmap\n\nNimble 7 introduces `Predicate` but will support the old types with warning\ndeprecations. A couple major releases of Nimble will remain backwards\ncompatible with the old matcher api, although new features may not be\nbackported.\n\nThe deprecating plan is a 3 major versions removal. Which is as follows:\n\n 1. Introduce new `Predicate` API, deprecation warning for old matcher APIs.\n    (Nimble `v7.x.x`, `v8.x.x` and `v9.x.x`)\n 2. Introduce warnings on migration-path features (`.predicate`,\n    `Predicate`-constructors with similar arguments to old API). (Nimble\n    `v10.x.x`)\n 3. Remove old API. (Nimble `v11.x.x`)\n\n\n# Installing Nimble\n\n> Nimble can be used on its own, or in conjunction with its sister\n  project, [Quick](https://github.com/Quick/Quick). To install both\n  Quick and Nimble, follow [the installation instructions in the Quick\n  Documentation](https://github.com/Quick/Quick/blob/master/Documentation/en-us/InstallingQuick.md).\n\nNimble can currently be installed in one of two ways: using CocoaPods, or with\ngit submodules.\n\n## Installing Nimble as a Submodule\n\nTo use Nimble as a submodule to test your macOS, iOS or tvOS applications, follow\nthese 4 easy steps:\n\n1. Clone the Nimble repository\n2. Add Nimble.xcodeproj to the Xcode workspace for your project\n3. Link Nimble.framework to your test target\n4. Start writing expectations!\n\nFor more detailed instructions on each of these steps,\nread [How to Install Quick](https://github.com/Quick/Quick#how-to-install-quick).\nIgnore the steps involving adding Quick to your project in order to\ninstall just Nimble.\n\n## Installing Nimble via CocoaPods\n\nTo use Nimble in CocoaPods to test your macOS, iOS or tvOS applications, add\nNimble to your podfile and add the ```use_frameworks!``` line to enable Swift\nsupport for CocoaPods.\n\n```ruby\nplatform :ios, \'8.0\'\n\nsource \'https://github.com/CocoaPods/Specs.git\'\n\n# Whatever pods you need for your app go here\n\ntarget \'YOUR_APP_NAME_HERE_Tests\', :exclusive => true do\n  use_frameworks!\n  pod \'Nimble\', \'~> 6.0.0\'\nend\n```\n\nFinally run `pod install`.\n\n## Installing Nimble via Accio\n\nAdd the following to your Package.swift:\n\n```swift\n.package(url: "https://github.com/Quick/Nimble.git", .upToNextMajor(from: "8.0.1")),\n```\n\nNext, add `Nimble` to your App targets dependencies like so:\n\n```swift\n.testTarget(\n    name: "AppTests",\n    dependencies: [\n        "Nimble",\n    ]\n),\n```\n\nThen run `accio update`.\n\n## Using Nimble without XCTest\n\nNimble is integrated with XCTest to allow it work well when used in Xcode test\nbundles, however it can also be used in a standalone app. After installing\nNimble using one of the above methods, there are two additional steps required\nto make this work.\n\n1. Create a custom assertion handler and assign an instance of it to the\n   global `NimbleAssertionHandler` variable. For example:\n\n```swift\nclass MyAssertionHandler : AssertionHandler {\n    func assert(assertion: Bool, message: FailureMessage, location: SourceLocation) {\n        if (!assertion) {\n            print("Expectation failed: \\(message.stringValue)")\n        }\n    }\n}\n```\n```swift\n// Somewhere before you use any assertions\nNimbleAssertionHandler = MyAssertionHandler()\n```\n\n2. Add a post-build action to fix an issue with the Swift XCTest support\n   library being unnecessarily copied into your app\n  * Edit your scheme in Xcode, and navigate to Build -> Post-actions\n  * Click the "+" icon and select "New Run Script Action"\n  * Open the "Provide build settings from" dropdown and select your target\n  * Enter the following script contents:\n```\nrm "${SWIFT_STDLIB_TOOL_DESTINATION_DIR}/libswiftXCTest.dylib"\n```\n\nYou can now use Nimble assertions in your code and handle failures as you see\nfit.\n'