b'# Bindgen ![Logo](https://raw.githubusercontent.com/Papierkorb/bindgen/master/images/logo.png) [![Build Status](https://travis-ci.org/Papierkorb/bindgen.svg?branch=master)](https://travis-ci.org/Papierkorb/bindgen)\n\nA C/C++/Qt binding and wrapper generator.\n\n### Platform support\n\n<!-- Table is sorted from A-Z ascending, versions descending. -->\n\n| Arch    | System            | CI          | Clang version  |\n| ------- | ----------------- | ----------- | -------------- |\n| x86_64  | ArchLinux         | Travis      | *Rolling*      |\n| x86_64  | Debian 7          | Travis      | 4.0, 5.0       |\n| x86_64  | Ubuntu 17.04      | *None*      | 5.0            |\n| x86_64  | Ubuntu 16.04      | Travis      | 4.0, 5.0       |\n|         | Other systems     | Help wanted | ?              |\n\nYou require the LLVM and Clang development libraries and headers.  If you don\'t\nhave them already installed, bindgen will tell you.\n\n## Features\n\n| Feature                                          | Support |\n|--------------------------------------------------|---------|\n| Automatic Crystal binding generation             | **YES** |\n| Automatic Crystal wrapper generation             | **YES** |\n| Mapping C++ classes                              |         |\n|  +- Member methods                               | **YES** |\n|  +- Static methods                               | **YES** |\n|  +- Constructors                                 | **YES** |\n|  +- Overloaded operators                         |   TBD   |\n|  +- Conversion functions                         |   TBD   |\n| Mapping C/C++ global functions                   |         |\n|  +- Mapping global functions                     | **YES** |\n|  +- Wrapping as Crystal class                    | **YES** |\n| Overloaded methods (Also default arguments)      | **YES** |\n| Copying default argument values                  |         |\n|  +- Integer, float, boolean types                | **YES** |\n|  +- String                                       | **YES** |\n| Enumerations                                     | **YES** |\n| Copying structures                               | **YES** |\n| Custom type conversions between C/++ and Crystal | **YES** |\n| Automatic type wrapping and conversion           | **YES** |\n| Integration with Crystals GC                     | **YES** |\n| C++ Template instantiation for containers types  | **YES** |\n| Virtual methods                                  | **YES** |\n| Override virtual methods from Crystal            | **YES** |\n| Abstract classes                                 | **YES** |\n| Multiple inheritance wrapping                    | **YES** |\n| Qt integration                                   |         |\n|  +- QObject signals                              | **YES** |\n|  +- QFlags types                                 | **YES** |\n|  +- QMetaObject generation (mimic `moc`)         |   TBD   |\n| `#define` macro support                          |         |\n|  +- Mapping as enumeration                       | **YES** |\n|  +- Mapping as constant (Including strings)      | **YES** |\n| Copying in-source docs                           |   TBD   |\n| Platform specific type binding rules             | **YES** |\n| Portable path finding for headers, libs, etc.    | **YES** |\n\n\n## Projects using bindgen\n\n* [Qt5 Bindings](https://github.com/Papierkorb/qt5.cr)\n\n*Created a published, stable-y binding with bindgen?  Want to see it here?  PR!*\n\n# How To\n\n1. Add bindgen to your `shard.yml` and run `crystal deps`\n2. Copy `assets/bindgen_helper.hpp` into your `ext/`\n3. Copy and customize `TEMPLATE.yml`\n4. Run `lib/bindgen/tool.sh your_template.yml`\n\n```yaml\ndependencies:\n  bindgen:\n    github: Papierkorb/bindgen\n```\n\n**Note**: If you intend to ship the generated code with your shard, you can\nreplace `dependencies` with `development_dependencies`.\n\nSee `TEMPLATE.yml` for configuration documentation.\n\n# Mapping behaviour\n\nThe following rules are automatically applied to all bindings:\n\n* Method names get underscored: `addWidget() -> #add_widget`\n  * Setter methods are rewritten: `setWindowTitle() -> #window_title=`\n  * Getter methods are rewritten: `getWindowTitle() -> #window_title`\n  * Bool getters are rewritten: `getAwesome() -> #awesome?`\n  * `is` getters are rewritten: `isEmpty() -> #empty?`\n  * `has` getters are rewritten: `hasSpace() -> #has_space?`\n* On signal methods (For Qt signals):\n  * Keep their name for the `emit` version: `pressed() -> #pressed`\n  * Get an `on_` prefix for the connect version: `#on_pressed do .. end`\n* Enum fields get title-cased if not already: `color0 -> Color0`\n\n# Processors\n\nThe processor pipeline can be configured through the `processors:` array.  Its\nelements are run in the order they\'re defined, starting at the first element.\n\n**Note**: Don\'t worry: The `TEMPLATE.yml` file already comes with the\nrecommended pipeline pre-configured.\n\nThere are three kinds of processors:\n1. *Refining* ones modify the graph in some way, without a dependency to a later\n   generator.\n2. *Generation* processors add data to the graph so the later ran generators\n   have all data they need to work.\n3. *Information* processors don\'t modify the graph, but do checks or print data\n   onto the screen for debugging purposes.\n\nThe order is having first *Refining*, and *Generation* processors second in the\nconfigured pipeline.  *Information* processors can be run at any time.\n\nThe following list of processors is ordered alphabetically.\n\n### `AutoContainerInstantiation`\n\n* **Kind**: Refining\n* **Run after**: No specific dependency\n* **Run before**: `InstantiateContainers`\n\nWhen encountering a known container class on an instantiation that is not\nregistered yet, registers it.\n\nContainer classes still need to be declared in the configuration, but don\'t\nrequire an explicit `instantiations` attribute anymore:\n\n```yaml\ncontainers: # At the top-level of the config\n  - class: QList # Set the class name\n    type: Sequential # And its type\n    # instantiations: # Can be added, but doesn\'t need to be.\n```\n\n### `CopyStructs`\n\n* **Kind**: Refining\n* **Run after**: No specific dependency\n* **Run before**: No specific dependency\n\nCopies structures of those types, that have `copy_structure: true` set in the\nconfiguration.  A wrapper class of a `copy_structure` type will host the\nstructure directly (instead of a pointer) to it.\n\n### `CppWrapper`\n\n* **Kind**: Generation\n* **Run after**: *Refining* processors\n* **Run before**: `CrystalBinding`\n\nGenerates the C++ wrapper method `Call`s.\n\n### `CrystalBinding`\n\n* **Kind**: Generation\n* **Run after**: `CppWrapper`, `VirtualOverride` and `CrystalWrapper`\n* **Run before**: No specific dependency\n\nGenerates the `lib Binding` `fun`s.\n\n### `CrystalWrapper`\n\n* **Kind**: Generation\n* **Run after**: *Refining* processors\n* **Run before**:  `CrystalBinding` and `VirtualOverride`\n\nGenerates the Crystal methods in the wrapper classes.\n\n### `DefaultConstructor`\n\n* **Kind**: Refining\n* **Run after**: No specific dependency\n* **Run before**: No specific dependency\n\nClang doesn\'t expose default constructors methods for implicit default\nconstructors.  This processor finds these cases and adds an explicit constructor.\n\n### `DumpGraph`\n\n* **Kind**: Information\n* **Run after**: Any time\n* **Run before**: Any time\n\nDebugging processor dumping the current graph onto `STDERR`.\n\n### `Enums`\n\n* **Kind**: Refining\n* **Run after**: `FunctionClass`\n* **Run before**: No specific dependency\n\nAdds the copied enums to the graph.  Should be run after other processors adding\nclasses, so that enums can be added into classes.\n\n### `ExternC`\n\n* **Kind**: Refining\n* **Run after**: `Functions` and `FunctionClass`\n* **Run before**: No specific dependency\n\nChecks if a method require a C/C++ wrapper.  If not, marks the method to\nbind directly to the target method instead of writing a "trampoline"\nwrapper in C++.\n\n**Note**: This processor is *required* for variadic functions to work.  A\nvariadic function looks like this: `void func(int c, ...);`\n\nA method can be bound directly if all of these are true:\n\n1. It uses the C ABI (`extern "C"`)\n2. No argument uses a `to_cpp` converter\n3. The return type doesn\'t use a `from_cpp` converter\n\n**Note**: If all methods can be bound to directly, you can remove the `cpp`\ngenerator completely from your configuration.\n\n### `FilterMethods`\n\n* **Kind**: Refining\n* **Run after**: No specific dependency\n* **Run before**: No specific dependency\n\nRemoves all methods using an argument, or returning something, which is\nconfigured as `ignore: true`.  Also removes methods that show up in the\n`ignore_methods:` list.\n\nThis processor can be run at any time in theory, but should be run as first part\nof the pipeline.\n\n### `Functions`\n\n* **Kind**: Refining\n* **Run after**: `FunctionClass` and `ExternC`\n* **Run before**: No specific dependency\n\nMaps C functions, configured through the `functions:` map in the configuration.\n\n### `FunctionClass`\n\n* **Kind**: Refining\n* **Run after**: `ExternC`\n* **Run before**: `Inheritance` and `Functions`\n\nGenerates wrapper classes from OOP-like C APIs, using guidance from the user\nthrough configuration in the `functions:` map.\n\n### `Inheritance`\n\n* **Kind**: Refining\n* **Run after**: `FunctionClass`\n* **Run before**: `FilterMethods` and `VirtualOverride`\n\nImplements Crystal wrapper inheritance and adds `#as_X` conversion methods.\nAlso handles abstract classes in that it adds an `Impl` class, so code can\nreturn instances to the (otherwise) abstract class.\n\n### `InstantiateContainers`\n\n* **Kind**: Refining\n* **Run after**: `AutoContainerInstantiation` if used\n* **Run before**: No specific dependency\n\nAdds the container instantiation classes and wrappers.\n\n### `Macros`\n\n* **Kind**: Refining\n* **Run after**: No specific dependency\n* **Run before**: No specific dependency\n\nMaps `#define` macros into the graph.  The mapping is configured by the user in\nthe `macros:` list.  Only value-macros ("object-like macros") are supported,\nfunction-like macros are silently skipped.\n\n```c++\n// Okay:\n#define SOME_INT 1\n#define SOME_STRING "Hello"\n#define SOME_BOOL true\n\n// Not mapped:\n#define SOME_FUNCTION(x) (x + 1)\n```\n\n### `Qt`\n\n* **Kind**: Refining\n* **Run after**: No specific dependency\n* **Run before**: No specific dependency\n\nAdds Qt specific behaviour:\n\n1. Removes the `qt_check_for_QGADGET_macro` fake method.\n2. Provides `#on_SIGNAL` signal connection method.\n\n```crystal\nbtn = Qt::PushButton.new\nbtn.on_clicked do |checked| # Generated by this processor\n  puts "Checked: #{checked}"\nend\n```\n\n### `SanityCheck`\n\n* **Kind**: Information\n* **Run after**: Any time, as very last pipeline element is ideal.\n* **Run before**: Any time\n\nDoes sanity checks on the graph, focusing on Crystal bindings and wrappers.\n\nChecks are as follows:\n* Name of enums, libs, structures, classes, modules and aliases are valid\n* Name of constants are valid\n* Name of methods are valid\n* Enumerations have at least one constant\n* Flag-enumerations don\'t have `All` nor `None` constants\n* Method arguments and result types are reachable\n* Variadic methods are directly bound\n* Alias targets are reachable\n* Class base-classes are reachable\n\n### `VirtualOverride`\n\n* **Kind**: Refining, but ran after generation processors!\n* **Run after**: `CrystalWrapper`!\n* **Run before**: `CrystalBinding` and `CppWrapper`\n\nAdds C++ and Crystal wrapper code to allow overriding C++ virtual methods from\nwithin Crystal.  Requires the `Inheritance` processor.\n\n**Important Note**: Make sure to run this processor after `CrystalWrapper` but\nbefore `CrystalBinding`.\n\nIt needs to modify the `#initialize` methods, and generate `lib` structures,\nbindings, and C++ code too.\n\nThis is the recommended processor order:\n\n```yaml\nprocessors:\n  # ...\n  - crystal_wrapper\n  - virtual_override\n  - cpp_wrapper\n  - crystal_binding\n```\n\nAfter this, usage is the same as with any method:\n\n```crystal\nclass MyAdder < VirtualCalculator\n  # In C++: virtual int calculate(int a, int b);\n  # In Crystal:\n  def calculate(a, b)\n    a + b\n  end\nend\n```\n\n# Advanced configuration features\n\n## Conditions and dependencies in YAML files\n\nYAML configuration files support conditionals elements (So, `if`s), and loading\nexternal dependency files.\n\nApart from this logic, the configuration file is still valid YAML.\n\n**Note**: Conditionals and dependencies are *only* supported in\n*mappings* (`Hash` in Crystal).  Any such syntax encountered in something\nother than a *mapping* will not trigger any special behaviour.\n\n### Condition syntax\n\nYAML documents can define conditional parts in *mappings* by having a\nconditional key, with *mapping* value.  If the condition matches, the\n*mapping* value will be transparently embedded.  If it does not match, the\nvalue will be transparently skipped.\n\nCondition keys look like `if_X` or `elsif_X` or `else`.  `X` is the\ncondition, and it looks like `Y_is_Z` or `Y_match_Z`.  You can also use\n(one or more) spaces (` `) instead of exactly one underscore (`_`) to\nseparate the words.\n\n* `Y_is_Z` is true if the variable Y equals Z case-sensitively.\n* `Y_isnt_Z` is true if the variable Y doesn\'t equal Z case-sensitively.\n* `Y_match_Z` is true if the variable Y is matched by the regular expression\nin `Z`.  The regular expression is created case-sensitively.\n\nA condition block is opened by the first `if`.  Later condition keys can\nuse `elsif` or `else` (or `if` to open a *new* condition block).\n\n**Note**: `elsif` or `else` without an `if` will raise an exception.\n\nTheir behaviour is like in Crystal: `if` starts a condition block, `elsif`\nstarts an alternative condition block, and `else` is used if none of `if` or\n`elsif` matched.  It\'s possible to mix condition key-values with normal\nkey-values.\n\n**Note**: Conditions can be used in every *mapping*, even in *mappings* of\na conditional.  Each *mapping* acts as its own scope.\n\n#### Variables\n\nVariables are set by the user of the class (Probably through\n`ConfigReader.from_yaml`).  All variable values are strings.\n\nVariable names are **case-sensitive**.  A missing variable will be treated\nas having an empty value (`""`).\n\n#### Examples\n\n```yaml\nfoo: # A normal mapping\n  bar: 1\n\n# A condition: Matches if `platform` equals "arm".\nif_platform_is_arm: # In Crystal: `if platform == "arm"`\n  company: ARM et al\n\n# You can mix in values between conditionals.  It won\'t "break" following\n# elsif or else blocks.\nnot_a_condition: Hello\n\n# An elsif: Matches if 1) the previous conditions didn\'t match\n# 2) its own condition matches.\nelsif_platform_match_x86: # In Crystal: `elsif platform =~ /x86/`\n  company: Many different\n\n# An else: Matches if all previous conditions didn\'t match.\nelse:\n  company: No idea\n\n# At any time, you can start a new if sequence.\n"if today is friday": # You can use spaces instead of underscores too\n  hooray: true\n```\n\n### Dependencies\n\nTo modularize the configuration, you can require ("merge") external yaml\nfiles from within your configuration.\n\nThis is triggered by using a key named `<<`, and writing the file name as\nvalue: `<<: my_dependency.yml`.  The file-extension can also be omitted:\n`<<: my_dependency` in which case an `.yml` extension is assumed.\n\nThe dependency path is relative to the currently processed YAML file.\n\nYou can also require multiple dependencies into the same *mapping*:\n\n```yaml\ntypes:\n  Something: true # You can mix dependencies with normal fields.\n  <<: simple_types.yml\n  <<: complex_types.yml\n  <<: ignores.yml\n```\n\nThe dependency will be embedded into the open *mapping*: It\'s transparent\nto the client code.\n\nIt\'s perfectly possible to mix conditionals with dependencies:\n\n```yaml\nif_os_is_windows:\n  <<: windows-specific.yml\n```\n\n#### Errors\n\nAn exception will be raised if any of the following occur:\n\n* The maximum dependency depth of `10` (`MAX_DEPTH`) is exceeded.\n* The dependency name contains a dot: `../foo.yml` won\'t work.\n* The dependency name is absolute: `/foo/bar.yml` won\'t work.\n\n# Architecture of bindgen\n\nBindgen employs a pipeline inspired code architecture, which is strikingly\nsimilar to what most compilers use.\n\nThe code-flow is basically `Parser::Runner` to `Graph::Builder` to\n`Processor::Runner` to `Generator::Runner`.\n\n![Architecture flow diagram](https://raw.githubusercontent.com/Papierkorb/bindgen/master/images/architecture.png)\n\n## The Graph\n\nAn important data structure used throughout the program is *the graph*.\nCode-wise, it\'s represented by `Graph::Node` (And its sub-classes).  The nodes\ncan contain child nodes, making it a hierarchical structure.\n\nThis allows to represent (almost) arbitrary structures as defined by the user\nconfiguration.\n\nSay, we\'re wrapping `GreetLib`.  As any library, it comes with a bunch of\nclasses (`Greeter` and `Listener`), enums  (`Greetings`, `Type`) and other stuff\nlike constants (`PORT`).  The configuration file could look like this:\n\n```yaml\nmodule: GreetLib\nclasses: # We copy the structure of classes\n  Greeter: Greeter\n  Listener: Listener\nenums: # But map the enums differently\n  Type: Greeter::Type\n  Greeter::Greetings: Greetings\n```\n\nWhich will generate a graph looking like this:\n\n![Graph example](https://raw.githubusercontent.com/Papierkorb/bindgen/master/images/graph.png)\n\n**Note**: The concept is really similar to ASTs used by compilers.\n\n## Parser step\n\nBegin of the actual execution pipeline.  Calls out to the clang-based parser\ntool to read the C/C++ source code and write a JSON-formatted "database" onto\nstandard output.  This is directly caught by `bindgen` and subsequently parsed\nas `Parser::Document`.\n\n## Graph::Builder step\n\nThe second step takes the `Parser::Document` and transforms it into a\n`Graph::Namespace`.  This step is where the user configuration mapping is used.\n\n## Processor step\n\nThe third step runs all configured processors in-order.  These work with the\n`Graph` and mostly add methods and `Call`s so they can be bound later.  But\nthey\'re allowed to do whatever they want really, which makes it a good place\nto add more complex rewriting rules if desired.\n\nProcessors are responsible for many core features of bindgen.  The `TEMPLATE.yml`\nhas an already set-up pipeline.\n\n## Generator step\n\nThe final step now takes the finalized graph and writes the result into an\noutput of one or more files.  Generators do *not* change the graph in any way,\nand also don\'t build anything on their own.  They only write to output.\n\n## Contributing\n\n1. Talk to `Papierkorb` in `#crystal-lang` about what you\'re gonna do.\n2. You got the go-ahead?  The project\'s in an early state: Things may change without notice under you.\n3. Read the `STYLEGUIDE.md` for some tips.\n4. Then do the rest, PR and all.  You know the drill :)\n\n## License\n\nThis project (`bindgen`) and all of its sources, except those otherwise noted,\nall fall under the `GPLv3` license.  You can find a copy of its complete license\ntext in the `LICENSE` file.\n\nThe configuration used to generate code, and all code generated by this project,\nfall under the full copyright of the user of `bindgen`.  `bindgen` does not\nclaim any copyright, legal or otherwise, on your work.  Established projects\nshould define a license they want to use for the generated code and\nconfiguration.\n\n## Contributors\n\n- [Papierkorb](https://github.com/Papierkorb) Stefan Merettig - creator, maintainer\n'