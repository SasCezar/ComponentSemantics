b':toc: macro\n:toclevels: 99\n\n# Orion\n\nimage:https://travis-ci.org/obsidian/orion.svg?branch=master["Build Status", link="https://travis-ci.org/obsidian/orion"]\nimage:https://img.shields.io/github/tag/obsidian/orion.svg["GitHub release", link="https://github.com/obsidian/orion/tags"]\n\n\nA minimal, rails-esque routing library for `HTTP::Server`.\n\nOrion allows you to easily add routes, groups, and middleware in order to\nconstruct your application\'s routing layer.\n\ntoc::[]\n\n## Purpose\n\nThe purpose of the Orion router is to connect URLs to code. It provides a flexible\nand comprehensive DSL that will allow you to cover a variety of use cases. In addition,\nOrion will also generate a series of helpers to easily reference the defined paths\nwithin your application.\n\n## Installation\n\nAdd this to your application\'s `shard.yml`:\n\n```yaml\ndependencies:\n  orion:\n    github: obsidian/orion\n```\n\n... and require Orion in your project.\n\n```crystal\nrequire "orion"\n```\n\n## Usage\n\n### Defining a router\n\nYou can define a router by using the `router` macro with a constant name.\n\n```crystal\nrouter MyApplicationRouter do\n  # ...\nend\n```\n\n[[generic-route-arguments]]\n### Generic route arguments\nThere are a variety of ways that you can interact with basic routes. Below are\nsome examples and guidelines on the different ways you can interact with the router.\n\n#### Using `to: String` to target a controller and action\nOne of the most common ways we will be creating routes in this guide is to use\nthe `to` argument supplied with a controller and action in the form of a string.\nIn the example below `UsersController#create` will map to `UsersController.new(cxt : HTTP::Server::Context).create`.\n\n```crystal\nrouter MyApplicationRouter do\n  post "users", to: "UsersController#create"\nend\n```\n\n##### Non-constant\nBy passing a lowercased string, it still camelcase the string and add Controller.\nIn the example below `users#create` will map to `UsersController.new(cxt : HTTP::Server::Context).create`.\n\n```crystal\nrouter MyApplicationRouter do\n  post "users", to: "users#create"\nend\n```\n\n#### Using `controller: Type` and `action: Method`\nA longer form of the `to` argument strategy above allows us to pass the controller and action\nindependently.\n\n```crystal\nrouter MyApplicationRouter do\n  post "users", controller: UsersController, action: create\nend\n```\n\n#### Using block syntax\nSometimes, we may want a more link:https://github.com/kemalcr/kemal[kemal] or\nlink:http://sinatrarb.com/[sinatra] like approach. To accomplish this, we can\nsimply pass a block that yields `HTTP::Server::Context`.\n\n```crystal\nrouter MyApplicationRouter do\n  post "users" do |context|\n    context.response.puts "foo"\n  end\nend\n```\n\n#### Using a `call` able object\nLastly a second argument can be any\nobject that responds to `#call(cxt : HTTP::Server::Context)`.\n\n```crystal\nrouter MyApplicationRouter do\n  post "users", ->(context : HTTP::Server::Context) {\n    context.response.puts "foo"\n  }\nend\n```\n\n### Basic Routing\n\n#### Base route using `root`\n\nLets define the routers\'s `root` route. `root` is simply an alias for `get \'/\', action`.\nAll routes can either be a `String` pointing to a Controller action or a `Proc`\naccepting `HTTP::Server::Context` as a single argument. If a `String` is used like `controller#action`, it will expand into `Controller.new(context : HTTP::Server::Context).action`, therefor A controller must\nhave an initializer that takes `HTTP::Server::Context` as an argument, and the\nspecified action must not contain arguments.\n\n```crystal\n  router MyApplicationRouter do\n    root to: "home#index"\n  end\n```\n\n#### HTTP verb based routes\n\nA common way to interact with the router is to use standard HTTP verbs. Orion\nsupports all the standard HTTP verbs:\n\n`get`, `head`, `post`, `put`, `delete`, `connect`, `options`, `trace`, and `patch`\n\nYou can simply use one of the methods within the router and pass it\'s router and\nany variation of the xref:generic-route-arguments[Generic Route Arguments].\n\n```crystal\nrouter MyApplicationRouter do\n  post "users", to: "users#create"\nend\n```\n\n#### Catch all routes using `match`\n\nIn some instances you may just want to redirect all verbs to a particular\ncontroller and action.\n\nYou can simply use the `match` method within the router and pass it\'s router and\nany variation of the xref:generic-route-arguments[Generic Route Arguments].\n\n```crystal\nrouter MyApplicationRouter do\n  match "404", controller: ErrorsController, action: error_404\nend\n```\n\n### Resource Based Routing\n\nA common way in Orion to route is to do so against a known resource. This method\nwill create a series of routes targeted at a specific controller.\n\n_The following is an example controller definition and the matching\nresources definition._\n\n```crystal\nclass PostsController\n  include Orion::ControllerHelper\n  include ResponseHelpers\n\n  def index\n    @posts = Post.all\n    render :index\n  end\n\n  def new\n    @post = Post.new\n    render :new\n  end\n\n  def create\n    post = Post.create(request)\n    redirect to: post_path post_id: post.id\n  end\n\n  def show\n    @post = Post.find(request.path_params["post_id"])\n  end\n\n  def edit\n    @post = Post.find(request.path_params["post_id"])\n    render :edit\n  end\n\n  def update\n    post = Post.find(request.path_params["post_id"])\n    HTTP::FormData.parse(request) do |part|\n      post.attributes[part.name] = part.body.gets_to_end\n    end\n    redirect to: post_path post_id: post.id\n  end\n\n  def delete\n    post = Post.find(request.path_params["post_id"])\n    post.delete\n    redirect to: posts_path\n  end\n\nend\n\nrouter MyApplication do\n  resources :posts\nend\n```\n\n#### Including/Excluding Actions\n\nBy default, the actions `index`, `new`, `create`, `show`, `edit`, `update`, `delete`\nare included. You may include or exclude explicitly by using the `only` and `except` params.\n\n[quote]\nNOTE: The index action is not added for xref:singular-resources[singular resources].\n\n```crystal\nrouter MyApplication do\n  resources :posts, except: [:edit, :update]\n  resources :users, only: [:new, :create, :show]\nend\n```\n\n#### Nested Resources and Routes\n\nYou can add nested resources and member routes by providing a block to the\n`resources` definition.\n\n```crystal\nrouter MyApplication do\n  resources :posts do\n    post "feature", action: feature\n    resources :likes\n    resources :comments\n  end\nend\n```\n[[singular-resources]]\n#### Singular Resources\n\nIn addition to using the collection of `resources` method, You can also add\nsingular resources which do not provide a `id_param` or `index` action.\n\n```crystal\nrouter MyApplication do\n  resource :profile\nend\n```\n\n#### Customizing ID\n\nYou can customize the ID path parameter by passing the `id_param` parameter.\n\n```crystal\nrouter MyApplication do\n  resources :posts, id_param: :article_id\nend\n```\n\n#### Constraining the ID\n\nYou can set constraints on the ID parameter by passing the `id_constraint` parameter.\n\n_see xref:param-constraints[param constraints] for more details_\n\n```crystal\nrouter MyApplication do\n  resources :posts, id_constraint: /^\\d{4}$/\nend\n```\n\n#### Constraints\n\nSimilar to basic routes, `resource` and `resources` support the\nxref:format-constraints[`format`], xref:accept-type-constraints[`accept`],\nxref:content-type-constraints[`content_type`], and xref:type-constraints[`type`]\nconstraints.\n\n### Instrumenting handlers _(a.k.a. middleware)_\n\nInstances or Classes implementing\nlink:https://crystal-lang.org/api/HTTP/Handler.html[`HTTP::Handler`] _(a.k.a. middleware)_\ncan be inserted directly in your routes by using the `use` method.\n\n[quote]\nHandlers will only apply to the routes specified below them, so be sure to place\nyour handlers near the top of your route.\n\n```crystal\nrouter MyApplicationRouter do\n  use HTTP::ErrorHandler\n  use HTTP::LogHandler.new(File.open("tmp/application.log"))\nend\n```\n\n### Nested Routes using `scope`\n\nScopes are a method in which you can nest routes under a common path. This prevents\nthe need for duplicating paths and allows a developer to easily change the parent\nof a set of child paths.\n\n```crystal\nrouter MyApplicationRouter do\n  scope "users" do\n    root to: "Users#index"\n    get ":id", to: "Users#show"\n    delete ":id", to: "Users#destroy"\n  end\nend\n```\n\n#### Handlers within nested routes\n\nInstances of link:https://crystal-lang.org/api/HTTP/Handler.html[`HTTP::Handler`] can be\nused within a scope and will only apply to the subsequent routes within that scope.\nIt is important to note that the parent context\'s handlers will also be used.\n\n[quote]\nHandlers will only apply to the routes specified below them, so be sure to place\nyour handlers near the top of your scope.\n\n```crystal\nrouter MyApplicationRouter do\n  scope "users" do\n    use AuthorizationHandler.new\n    root to: "Users#index"\n    get ":id", to: "Users#show"\n    delete ":id", to: "Users#destroy"\n  end\nend\n```\n\n#### Route Helper prefixes\n\nWhen using xref:helpers[Helpers], you may want a prefix to be appended so that you don\'t have to\nrepeat it within each individual route. For example a scope with `helper_prefix: "users"`\ncontaining a route with `helper: "show"` will generate a helper method of `users_show`.\n\n```crystal\nrouter MyApplicationRouter do\n  scope "users", helper_prefix: "users" do\n    use AuthorizationHandler.new\n    get ":id", to: "Users#show", helper: "show"\n  end\nend\n```\n\n[[helper-caveats]]\n##### Caveats\n\nWhen considering helpers within scopes you may want to use a longer form of the\nhelper to get a better name. You can pass a named tuple with the fields `name`,\n`prefix`, and/or `suffix`.\n\n```crystal\nrouter MyApplicationRouter do\n  scope "users", helper_prefix: "user" do\n    use AuthorizationHandler.new\n    get ":id", to: "Users#show", helper: { prefix: "show" }\n  end\nend\n```\n\nThe above example will expand into `show_user` instead of `user_show`.\n\n### Concerns \xe2\x80\x93 Reusable code in your routers\n\nIn some instances you may want to create a pattern or concern that you wish\nto repeat across scopes or resources in your router.\n\n#### Defining a concern\n\nTo define a concern call `concern` with a `Symbol` for the name.\n\n```crystal\nrouter MyApplicationRouter do\n  concern :authenticated do\n    use Authentication.new\n  end\nend\n```\n\n#### Using concerns\n\nOnce a concern is defined you can call `implements` with a named concern from\nanywhere in your router.\n\n```crystal\nrouter MyApplicationRouter do\n  concern :authenticated do\n    use Authentication.new\n  end\n\n  scope "users" do\n    implements :authenticated\n    get ":id"\n  end\nend\n```\n\n### Method Overrides\n\nIn some situations certain environments may not support certain HTTP methods,\nwhen in these environments, there are a few methods to force a different method\nin the router. In either of the methods below, if you intend to pass a body, you\nshould be using the `POST` http method when you make the request.\n\n#### Header Overrides\n\nIf your client has the ability to set headers you can use the built in ability to\npass the `X-HTTP-Method-Override: [METHOD]` method with the method you wish to invoke on\nthe router.\n\n#### Parameter & Form Overrides\n\nIf your client has the ability to set headers you can use the\n`Orion::Handlers::MethodOverrideParam` to pass a `_method=[METHOD]` parameter as\na query parameter or form field with the method you wish to invoke on the router.\n\n```crystal\nrouter MyRouter do\n  use Orion::Handlers::MethodOverrideParam.new\n  # ... routes\nend\n```\n\n[[constraints]]\n### Constraints - More advanced rules for your routes\n\nConstraints can be used to further determine if a route is hit beyond just it\'s\npath. Routes have some predefined constraints you can specify, but you can also\npass in a custom constraint.\n\n[[param-constraints]]\n#### Parameter constraints\n\nWhen defining a route, you can pass in parameter constraints. The path params will\nbe checked against the provided regex before the route is chosen as a valid route.\n\n```crystal\nrouter MyApplicationRouter do\n  get "users/:id", constraints: { id: /[0-9]{4}/ }\nend\n```\n\n[[format-constraints]]\n#### Format constraints\n\nYou can constrain the request to a certain format. Such as restricting\nthe extension of the URL to \'.json\'.\n\n```crystal\nrouter MyApplicationRouter do\n  get "api/users/:id", format: "json"\nend\n```\n\n[[content-type-constraints]]\n#### Request Mime-Type constraints\n\nYou can constrain the request to a certain mime-type by using the `content_type` param\non the route. This will ensure that if the request has a body, that it provides the proper\ncontent type.\n\n```crystal\nrouter MyApplicationRouter do\n  put "api/users/:id", content_type: "application/json"\nend\n```\n\n[[accept-constraints]]\n#### Response Mime-Type constraints\n\nYou can constrain the response to a certain mime-type by using the `accept` param\non the route. This is similar to the format constraint, but allows clients to\nspecify the `Accept` header rather than the extension.\n\n[quote]\nOrion will automatically add mime-type headers for requests with no Accept header and\na specified extension.\n\n```crystal\nrouter MyApplicationRouter do\n  get "api/users/:id", accept: "application/json"\nend\n```\n\n[[type-constraints]]\n#### Combined Mime-Type constraints\n\nYou can constrain the request and response to a certain mime-type by using the `type` param\non the route. This will ensure that if the request has a body, that it provides the proper\ncontent type. In addition it will also validate that the client provides a proper\naccept header for the response.\n\n[quote]\nOrion will automatically add mime-type headers for requests with no Accept header and\na specified extension.\n\n```crystal\nrouter MyApplicationRouter do\n  put "api/users/:id", type: "application/json"\nend\n```\n\n#### Host constraints\n\nYou can constrain the request to a specific host by wrapping routes\nin a `host` block. In this method, any routes within the block will be\nmatched at that constraint.\n\nYou may also choose to limit the request to a certain format. Such as restricting\nthe extension of the URL to \'.json\'.\n\n```crystal\nrouter MyApplicationRouter do\n  host "example.com" do\n    get "users/:id", format: "json"\n  end\nend\n```\n\n#### Subdomain constraints\n\nYou can constrain the request to a specific subdomain by wrapping routes\nin a `subdomain` block. In this method, any routes within the block will be\nmatched at that constraint.\n\nYou may also choose to limit the request to a certain format. Such as restricting\nthe extension of the URL to \'.json\'.\n\n```crystal\nrouter MyApplicationRouter do\n  subdomain "api" do\n    get "users/:id", format: "json"\n  end\nend\n```\n\n#### Custom Constraints\n\nYou can also pass in your own constraints by just passing a class/struct that\nimplements the `Orion::Constraint` module.\n\n```crystal\nstruct MyConstraint\n  def matches?(req : HTTP::Request)\n    true\n  end\nend\n\nrouter MyApplicationRouter do\n  constraint MyConstraint.new do\n    get "users/:id", format: "json"\n  end\nend\n```\n\n[[helpers]]\n### Route Helpers\n\nRoute helpers provide type-safe methods to generate paths and urls to defined routes\nin your application. By including the `Helpers` module on the router (i.e. `MyApplicationRouter::Helpers`)\nyou can access any helper defined in the router by `{{name}}_path` to get its corresponding\nroute. In addition, when you have a `@context : HTTP::Server::Context` instance var,\nyou will also be able to access a `{{name}}_url` to get the full url.\n\n```crystal\nrouter MyApplicationRouter do\n  scope "users", helper_prefix: "user" do\n    get "/new", to: "UsersController#new", helper: "new"\n  end\nend\n\nclass UsersController\n  def new\n  end\nend\n\nclass MyController\n  include MyApplicationRouter::Helpers\n  delegate request, response, to: @context\n\n  def initialize(@context : HTTP::Server::Context)\n  end\n\n  def new\n    File.open("new.html") { |f| IO.copy(f, response) }\n  end\n\n  def show\n    user = User.find(request.path_params["id"])\n    response.headers["Location"] = new_user_path\n    response.status_code = 301\n    response.close\n  end\nend\n```\n\n#### Making route helpers from your routes\n\nIn order to make a helper from your route you can use the `helper` named\nargument in your route.\n\n```crystal\nrouter MyApplicationRouter do\n  scope "users" do\n    get "/new", to: "Users#new", helper: "new"\n  end\nend\n```\n\n#### Using route helpers in your code\n\nAs you add helpers they are added to the nested `Helpers` module of your router.\nyou may include this module anywhere in your code to get access to the methods,\nor call them on the module directly.\n\n_If `@context : HTTP::Server::Context` is present in the class, you will also be\nable to use the `{helper}_url` versions of the helpers._\n\n```crystal\nrouter MyApplicationRouter do\n  resources :users\nend\n\nclass User\n  include MyApplicationRouter::Helpers\n\n  def route\n    user_path user_id: self.id\n  end\nend\n\nputs MyApplicationRouter::Helpers.users_path\n```\n\n## Contributing\n\n1. Fork it https://github.com/<your-github-name>/orion/fork\n2. Create your feature branch (git checkout -b my-new-feature)\n3. Commit your changes (git commit -am \'Add some feature\')\n4. Push to the branch (git push origin my-new-feature)\n5. Create a new Pull Request\n\n## Contributors\n\n- link:https://github.com/jwaldrip[Jason Waldrip (jwaldrip)] - creator, maintainer\n'