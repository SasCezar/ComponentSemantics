b'[![Build Status](https://travis-ci.org/lucaong/immutable.svg?branch=master)](https://travis-ci.org/lucaong/immutable)\n\n# Immutable\n\nEfficient, thread-safe immutable data structures for Crystal.\n\nWhenever an `Immutable` data structure is "modified", the original remains\nunchanged and a modified copy is returned. However, the copy is efficient due to\nstructural sharing. This makes `Immutable` data structures inherently\nthread-safe, garbage collector friendly and performant.\n\nAt the moment, `Immutable` implements the following persistent data structures:\n\n  - `Immutable::Vector`: array-like ordered, integer-indexed collection\n  implementing efficient append, pop, update and lookup operations\n  - `Immutable::Map`: hash-like unordered key-value collection implementing\n  efficient lookup and update operations\n\n\n## Installation\n\nAdd this to your application\'s `shard.yml`:\n\n```yaml\ndependencies:\n  immutable:\n    github: lucaong/immutable\n```\n\n\n## Usage\n\nFor a list of all classes and methods refer to the [API documentation](http://lucaong.github.io/immutable/api/)\n\nTo use the immutable collections, require `immutable` in your code:\n\n```crystal\nrequire "immutable"\n```\n\n### Vector ([API docs](http://lucaong.github.io/immutable/api/Immutable/Vector.html))\n\n```crystal\n# Vector behaves mostly like an Array:\nvector = Immutable::Vector[1, 2, 3, 4, 5]  # => Vector [1, 2, 3, 4, 5]\nvector[0]                                  # => 1\nvector[-1]                                 # => 5\nvector.size                                # => 5\nvector.each { |elem| puts elem }\n\n# Updating a Vector always returns a modified copy:\nvector2 = vector.set(2, 0)                 # => Vector [1, 2, 0, 4, 5]\nvector2 = vector2.push(42)                 # => Vector [1, 2, 0, 4, 5, 42]\n\n# The original vector is unchanged:\nvector                                     # => Vector [1, 2, 3, 4, 5]\n\n# Bulk updates can be made faster by using `transient`:\nvector3 = vector.transient do |v|\n  1000.times { |i| v = v.push(i) }\nend\n```\n\n### Map ([API docs](http://lucaong.github.io/immutable/api/Immutable/Map.html))\n\n```crystal\n# Map behaves mostly like a Hash:\nmap = Immutable::Map[{:a => 1, :b => 2 }]  # => Map {:a => 1, :b => 2}\nmap[:a]                                  # => 1\n\n# Updating a Map always returns a modified copy:\nmap2 = map.set(:c, 3)                      # => Map {:a => 1, :b => 2, :c => 3}\nmap2 = map2.delete(:b)                     # => Map {:a => 1, :c => 3}\n\n# The original map in unchanged:\nmap                                        # => Map {:a => 1, :b => 2}\n\n# Bulk updates can be made faster by using `transient`:\nmap3 = Immutable::Map(String, Int32)[]\nmap3 = map3.transient do |m|\n  1000.times { |i| m = m.set(i.to_s, i) }\nend\n```\n\n### Nested structures\n\n```crystal\n# Nested arrays/hashes can be turned into immutable versions with the `.from`\n# method:\n\nnested = Immutable.from({:name => "Ada", :colors => [:blue, :green, :red] })\nnested # => Map {:name => "Ada", :colors => Vector [:blue, :green, :red]}\n```\n\n\n## Implementation\n\n`Immutable::Vector` is implemented as a bit-partitioned vector trie with a block\nsize of 32 bits, that guarantees O(Log32) lookups and updates, which is\neffectively constant time for practical purposes. Due to tail optimization,\nappends and pop are O(1) 31 times out of 32, and O(Log32) 1/32 of the times.\n\n`Immutable::Map` uses a bit-partitioned hash trie with a block size of 32 bits,\nthat also guarantees O(Log32) lookups and updates.\n\n\n## Contributing\n\n1. Fork it ( https://github.com/lucaong/immutable/fork )\n2. Create your feature branch (git checkout -b my-new-feature)\n3. Commit your changes (git commit -am \'Add some feature\')\n4. Push to the branch (git push origin my-new-feature)\n5. Create a new Pull Request\n\n\n## Contributors\n\n- [lucaong](https://github.com/lucaong) Luca Ongaro - creator, maintainer\n\n\n## Acknowledgement\n\nAlthough not a port, this project takes inspiration from similar libraries and\npersistent data structure implementations like:\n\n  - [Clojure persistent collections](http://clojure.org/reference/data_structures)\n  - [The Hamster gem for Ruby](https://github.com/hamstergem/hamster)\n\nWhen researching on the topic of persistent data structure implementation, these\nblog posts have been of great help:\n\n  - [Understanding Clojure\'s Persistent Vector](http://hypirion.com/musings/understanding-persistent-vector-pt-1) (also [Part 2](http://hypirion.com/musings/understanding-persistent-vector-pt-2), [Part 3](http://hypirion.com/musings/understanding-persistent-vector-pt-3) and [Understanding Clojure\'s Transients](http://hypirion.com/musings/understanding-clojure-transients))\n  - [Understanding Clojure\'s Persistent Hash Map](http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html)\n\nBig thanks to their authors for the great job explaining the internals of these\ndata structures.\n'