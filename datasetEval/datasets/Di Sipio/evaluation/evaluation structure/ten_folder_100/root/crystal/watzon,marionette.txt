b'# Marionette\n\nMarionette is a Crystal shard that replaces the functionality of Selenium (Firefox only for now) by communicating directly with an instance of the browser. It provides a simple, but powserful API which allows everything from navigation to screenshots to executing JavaScript.\n\n- [Marionette](#marionette)\n  - [Installation](#installation)\n  - [Usage](#usage)\n    - [Launch options](#launch-options)\n    - [The Browser Class](#the-browser-class)\n      - [new_session(capabilities)](#newsessioncapabilities)\n      - [close_session](#closesession)\n      - [on_request(&block : HTTP::Server::Context ->)](#onrequestblock--httpservercontext)\n      - [on_headers(&block : HTTP::Headers ->)](#onheadersblock--httpheaders)\n      - [on_har_capture(&block : HAR::Entries ->)](#onharcaptureblock--harentries)\n      - [har_entries](#harentries)\n      - [generate_har](#generatehar)\n      - [export_har(file, har = nil)](#exportharfile-har--nil)\n      - [goto(url)](#gotourl)\n      - [title](#title)\n      - [url](#url)\n      - [refresh](#refresh)\n      - [back](#back)\n      - [forward](#forward)\n      - [set_context](#setcontext)\n      - [context](#context)\n      - [using_context(&block)](#usingcontextblock)\n      - [current_window_handle](#currentwindowhandle)\n      - [current_chrome_window_handle](#currentchromewindowhandle)\n      - [window_handles](#windowhandles)\n      - [switch_to_window(handle)](#switchtowindowhandle)\n      - [window_rect](#windowrect)\n      - [set_window_rect(rect : WindowRect)](#setwindowrectrect--windowrect)\n      - [maximize_window](#maximizewindow)\n      - [minimize_window](#minimizewindow)\n      - [fullscreeen](#fullscreeen)\n      - [close_window](#closewindow)\n      - [orientation](#orientation)\n      - [set_orienation](#setorienation)\n      - [active_frame](#activeframe)\n      - [switch_to_frame(frame : String | HTMLElement | Nil, focus: true)](#switchtoframeframe--string--htmlelement--nil-focus-true)\n      - [switch_to_frame(by : LocatorStrategy, value, focus = true)](#switchtoframeby--locatorstrategy-value-focus--true)\n      - [switch_to_parent_frame](#switchtoparentframe)\n      - [cookies](#cookies)\n      - [cookie(name)](#cookiename)\n      - [element_enabled?(el)](#elementenabledel)\n      - [element_selected?(el)](#elementselectedel)\n      - [element_displayed?(el)](#elementdisplayedel)\n      - [element_tag_name(el)](#elementtagnameel)\n      - [element_text(el)](#elementtextel)\n      - [element_attribute(el, name)](#elementattributeel-name)\n      - [element_css_property(el, property)](#elementcsspropertyel-property)\n      - [element_rect(el)](#elementrectel)\n      - [click_element(el)](#clickelementel)\n      - [send_keys_to_element(el, *keys)](#sendkeystoelementel-keys)\n      - [clear_element(el)](#clearelementel)\n      - [find_elements(by : LocatorStrategy, value, start_node = nil)](#findelementsby--locatorstrategy-value-startnode--nil)\n      - [find_element(by : LocatorStrategy, value, start_node = nil)](#findelementby--locatorstrategy-value-startnode--nil)\n      - [take_screenshot(**options)](#takescreenshotoptions)\n        - [Options](#options)\n      - [save_screenshot(file, **options)](#savescreenshotfile-options)\n      - [execute_script(script, args = nil, timeout = @timeout, new_sandbox = true)](#executescriptscript-args--nil-timeout--timeout-newsandbox--true)\n      - [execute_script_async(script, args = nil, timeout = @timeout, new_sandbox = true)](#executescriptasyncscript-args--nil-timeout--timeout-newsandbox--true)\n      - [dismiss_dialog](#dismissdialog)\n      - [accept_dialog](#acceptdialog)\n      - [get_text_from_dialog](#gettextfromdialog)\n      - [send_keys_to_dialog(*keys)](#sendkeystodialogkeys)\n      - [quit](#quit)\n      - [restart](#restart)\n      - [clear_pref(pref)](#clearprefpref)\n      - [pref(pref, default_branch = false, value_type = "unspecified")](#prefpref-defaultbranch--false-valuetype--%22unspecified%22)\n      - [set_pref(pref, value, default_branch = false)](#setprefpref-value-defaultbranch--false)\n      - [set_prefs(prefs, defualt_branch = false)](#setprefsprefs-defualtbranch--false)\n      - [using_prefs(prefs, default_branch = false, &block)](#usingprefsprefs-defaultbranch--false-block)\n  - [Contributing](#contributing)\n  - [Contributors](#contributors)\n\n## Installation\n\nAdd this to your application\'s `shard.yml`:\n\n```yaml\ndependencies:\n  marionette:\n    github: watzon/marionette\n```\n\n## Usage\n\nFirst, of course, you need to require marionette in your project.\n\n```crystal\nrequire "marionette"\n```\n\n`Marionette` itself is a module which exposes two methods:\n\n- `launch(**options)`\n- `launch(**options, &block : Browser ->)`\n\nThe first `launch` method accepts [the launch options listed below](#launch-options) and returns a new `Browser` instance. The browser will not be closed at the end of the program\'s execution, so it\'s important to remember to run `Browser#quit` if the browser process was created with marionette.\n\nThe second `launch` method accepts [the same launch options](#launch-options) and a block. The newly created `Browser` instance is yielded to the block and the browser process will be closed automatically at the end of the block if the process was created with marionette.\n\n### Launch options\n\n`Marionette.launch` accepts all the same arguments as `Launcher#launch`. These arguments are:\n\n- **address** - The address that Firefox is listening on. (default: 127.0.0.1)\n- **port** - The port that Firefox is listening on. (default: 2828)\n- **executable** - The executable to launch. If `nil` an executable will be searched for. If `false` no executable will be launched.\n- **args** - Arguments to pass to the Firefox process (only if **executable** is not false)\n- **profile** - User profile path to launch with (only if **executable** is not false)\n- **headless** - Launch browser in headless mode (default: true) (only if **executable** is not false)\n- **stdout** - `IO` to use for STDOUT (only if **executable** is not false)\n- **stderr** - `IO` to use for STDERR (only if **executable** is not false)\n- **accept_insecure_certs** - Open all connections, even if the cert is invalid\n- **env** - Environment to pass to `Process` (only if **executable** is not false)\n- **default_viewport** - Default size of the browser window (default: {width: 800, height: 600})\n- **timeout** - Universal timeout (default: 60000)\n- **proxy** - NamedTuple with `address` and `port` for proxy.\n\n### The Browser Class\n\nMost of the time while using marionette you will be dealing directly with the `Browser` class. As its name implies, the `Browser` class represents the browser instance. It includes a plethora of methods for interacting with the browser, I\'ll try and document them here as best as I can.\n\n#### new_session(capabilities)\n\nCreate a new browser session with provided `capabilities` and returns the `session_id`.\n\n```crystal\nbrowser.new_session({"browserName": "chrome", "platformName": "linux"})\n```\n\n#### close_session\n\nCloses the current session without shutting down the browser.\n\n```crystal\nbrowser.close_session\n```\n\n#### on_request(&block : HTTP::Server::Context ->)\n\n> Note: To use this method the `extended` option must be set to true.\n\nPasses the full `HTTP::Server::Context` to the provided block for every request made by the browser. This method can be called more than once to add multiple handlers.\n\n```crystal\nbrowser.on_request do |ctx|\n  pp ctx.requst\n  pp ctx.response\nend\n```\n\n#### on_headers(&block : HTTP::Headers ->)\n\n> Note: To use this method the `extended` option must be set to true.\n\nPasses the headers for every request to the provided block. This method can be called more than once to add multiple handlers.\n\n```crystal\nbrowser.on_headers do |headers|\n  pp headers\nend\n```\n\n#### on_har_capture(&block : HAR::Entries ->)\n\n> Note: To use this method the `extended` option must be set to true.\n\nWhen the `extended` option is set to true automatic [HAR](https://en.wikipedia.org/wiki/.har) capturing will be enabled. `on_har_capture` sends each captured `HAR::Entries` object to the provided block.\n\n```crystal\nbrowser.on_har do |har|\n  pp har\nend\n```\n\n#### har_entries\n\n> Note: To use this method the `extended` option must be set to true.\n\nLists each an every `HAR::Entries` object captured so far.\n\n```crystal\nbrowser.har_entries\n# => [] of HAR::Entries\n```\n\n#### generate_har\n\n> Note: To use this method the `extended` option must be set to true.\n\nGenerates a `HAR::Data` object which can be modified or converted to json using `to_json`. This represents a `.har` file.\n\n```crystal\nbrowser.generate_har\n# => <#HAR::Data ...>\n```\n\n#### export_har(file, har = nil)\n\n> Note: To use this method the `extended` option must be set to true.\n\nGenerates and saves a `.har` file to the specified path. You can optionally provide it with a `HAR::Data` object to be saved.\n\n```crystal\nbrowser.export_har("google.com.har")\n```\n\n#### goto(url)\n\nNavigates the browser to the specified URL. If `extended` is true this will use a proxy under the hood to fetch the content from the URL and deliver it to the browser, otherwise the default WebDriver method will be used.\n\n```crystal\nbrowser.goto("https://www.google.com")\n```\n\n#### title\n\nGets the title of the current page.\n\n```crystal\nbrowser.goto("https://www.google.com")\nbrowser.title\n# => "Google"\n```\n\n#### url\n\nGets the URL of the current page.\n\n```crystal\nbrowser.goto("https://www.google.com")\nbrowser.url\n# => "https://www.google.com"\n```\n\n#### refresh\n\nRefreshes the page.\n\n```crystal\nbrowser.refresh\n```\n\n#### back\n\nGoes back to the previous page.\n\n```crystal\nbrowser.back\n```\n\n#### forward\n\nGoes forward to the next page.\n\n```crystal\nbrowser.forward\n```\n\n#### set_context\n\nSets the context of subsequent commands to be either `:chrome` (allowing you access to the Firefox UI itself) or `:content` (allowing access to the current page).\n\n```crystal\nbrowser.set_context(:chrome)\nbrowser.set_context(:content)\n```\n\n#### context\n\nGets the current browser context.\n\n```crystal\nbrowser.context\n# => BrowserContext::Content\nbrowser.set_context(:chrome)\nbrowser.context\n# => BrowserContext::Chrome\n```\n\n#### using_context(&block)\n\nSets the context for the provided block, then returns it to the previous context.\n\n```crystal\nusing_context do\n  # Do stuff\nend\n```\n\n#### current_window_handle\n\nGets the handle for the current window, useful for switching between window instances.\n\n```crystal\nbrowser.current_window_handle\n```\n\n#### current_chrome_window_handle\n\nGet the current chrome window\'s handle. Corresponds to a chrome window that may itself contain tabs identified by window_handles.\n\n```crystal\nbrowser.current_chrome_window_handle\n```\n\n#### window_handles\n\nReturns an array of handles for currently open windows.\n\n```crystal\nbrowser.current_window_handles\n# => ["123..."]\n```\n\n#### switch_to_window(handle)\n\nSwitches to the window with the provided handle.\n\n```crystal\nbrowser.switch_to_window("123...")\n```\n\n#### window_rect\n\nGets the current window as a `WindowRect` instance containing it\'s `x` and `y` positions as well as it\'s `width` and `height`.\n\n```crystal\nbrowser.window_rect\n# => <#Window:Rect x: 0, y: 0, width: 800, height: 600>\n```\n\n#### set_window_rect(rect : WindowRect)\n\nSets the window\'s size and position according to the provided `WindowRect` instance.\n\n```crystal\nrect = Marionette::WindowRect.new(x: 0, y: 0, width: 800, height: 600)\nbrowser.set_window_rect(rect)\n```\n\n#### maximize_window\n\nMaximizes the current window.\n\n```crystal\nbrowser.maximize_window\n```\n\n#### minimize_window\n\nMinimizes the current window.\n\n```crystal\nbrowser.minimize_window\n```\n\n#### fullscreeen\n\nMakes the current window fullscreen.\n\n```crystal\nbrowser.fullscreen\n```\n\n#### close_window\n\nCloses the current window.\n\n```crystal\nbrowser.close_window\n```\n\n#### orientation\n\nGet the screen orientation of the current browser. Returns either portrait-primary, landscape-primary, portrait-secondary, or landscape-secondary.\n\nTODO: Use an enum for this.\n\n```crystal\nbrowser.orientation\n# => "portrait-primary"\n```\n\n#### set_orienation\n\nSet the screen orientation to one of portrait-primary, landscape-primary, portrait-secondary, or landscape-secondary.\n\nTODO: Use an enum for this.\n\n```crystal\nbrowser.set_orientation("landscape-secondary")\n```\n\n#### active_frame\n\nGets the current frame as an `HTMLElement` or nil if the top level frame is active. (Note that frame means iframe)\n\n```crystal\nbrowser.active_frame\n# => nil\n```\n\n#### switch_to_frame(frame : String | HTMLElement | Nil, focus: true)\n\nSets the active frame to the provided element or element id. If frame is nil the top level frame will be the active frame.\n\n```crystal\nel = browser.find_element(:xpath, "//iframe")\nbrowser.switch_to_frame(el) if el\nbrowser.active_frame\n# => <#HTML::Element ...>\n```\n\n#### switch_to_frame(by : LocatorStrategy, value, focus = true)\n\nConvenience method for finding an element and switching the active frame to it. See [`find_element`](#findelementby--locatorstrategy-value-startnode--nil).\n\n#### switch_to_parent_frame\n\nSwitches the frame to the parent of the active frame.\n\n```crystal\nbrowser.switch_to_parent_frame\nbrowser.active_frame\n# => nil\n```\n\n#### cookies\n\nGet\'s all cookies for the current page as `HTTP::Cookie` instaneces.\n\n```crystal\nbrowser.cookies\n# => [<#HTTP::Cookie name: "KBD", value: "8hq2eko2epoijADlkjh9">]\n```\n\n#### cookie(name)\n\nGets a single cookie by name. Retuns nil if the cookie doesn\'t exist.\n\n```crystal\nbrowser.cookie("KBD")\n# => <#HTTP::Cookie name: "KBD", value: "8hq2eko2epoijADlkjh9">\n```\n\n#### element_enabled?(el)\n\nReturns true if the provided element is enabled. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.element_enabled?(el)\n# => true\n```\n\n#### element_selected?(el)\n\nReturns true if the provided element is selected. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.element_selected?(el)\n# => false\n```\n\n#### element_displayed?(el)\n\nReturns true if the provided element is displayed. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.element_displayed?(el)\n# => true\n```\n\n#### element_tag_name(el)\n\nReturns the tag name of `el`. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.element_tag_name(el)\n# => "input"\n```\n\n#### element_text(el)\n\nReturns the text of `el`. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.element_text(el)\n# => ""\n```\n\n#### element_attribute(el, name)\n\nReturns the value of the provided atribute name for `el`. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.element_attribute(el, "value")\n# => "Hello world"\n```\n\n#### element_css_property(el, property)\n\nReturns the value of the provided css property for `el`. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.element_css_property(el, "background-color")\n# => "#FFFFFF"\n```\n\n#### element_rect(el)\n\nReturns a `ElementRect` instance representing the provided element\'s position and size within the browser. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.element_rect(el)\n# => <#Elementrect x: 123.0, y: 99.0, width: 100.0, height: 80.0>\n```\n\n#### click_element(el)\n\nSimulate a click on `el`. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.click_element(el)\n```\n\n#### send_keys_to_element(el, *keys)\n\nSends keys to the provided element. Keys are strings. Keystrokes for special keys such as return anc backspace can be simulated by sending a special unicode character. To make this easier their is a convenience method [`key`]. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.send_keys(input, "Hello world", key(:enter))\n```\n\n#### clear_element(el)\n\nClears a clearable element, such as an `input`. `el` can be a `HTMLElement` or the ID of an element.\n\n```crystal\nbrowser.clear_element(input)\n```\n\n#### find_elements(by : LocatorStrategy, value, start_node = nil)\n\nFind all elements on the current page using the specified [`LocatorStrategy`](#locatorstrategy). If a `start_node` is provided it will be used as the container to search inside of. `start_node` can be a `HTMLElement` or the ID of an element.\n\n```crystal\ninputs = browser.find_elements(:xpath, "//input")\n```\n\n#### find_element(by : LocatorStrategy, value, start_node = nil)\n\nFind a single on the current page using the specified [`LocatorStrategy`](#locatorstrategy). If a `start_node` is provided it will be used as the container to search inside of. `start_node` can be a `HTMLElement` or the ID of an element.\n\n```crystal\ninput = browser.find_element(:xpath, "//input")\n```\n\n#### take_screenshot(**options)\n\nTakes a screenshot of a particular element or the current frame. If the current context is set to `:chrome` the screenshot will be of the entire browser, otherwise the screenshot will be of the current page or provided element.\n\n##### Options\n\n- **element : HTMLElement | String | Nil** - Element to take a screenshot of.\n- **hightlights : Array(HTMLElement | String) | Nil** - Array of elements to highlight.\n- **full : Bool** - Take a screenshot of the full page.\n- **scroll : Bool** - Scroll to the provided element.\n- **format : ScreenshotFormat** - Format to export the screenshot as.\n\n```crystal\nbrowser.take_screenshot(\n  element = nil,\n  highlights = nil,\n  full = true,\n  scroll = true,\n  format = :binary\n)\n```\n\n#### save_screenshot(file, **options)\n\nTake and save the screenshot to the specified file. Accepts the same options as [`take_screenshot`](#takescreenshotoptions)\n\n#### execute_script(script, args = nil, timeout = @timeout, new_sandbox = true)\n\nExecute JavaScript on the current page. `script` should be a valid JavaScript document as a String. `args` are the arguments to provide, which can be accessed with `arguments[n]` in the script. You can also provide a `timeout` and tell the browser to execute this code in a new sandbox (true by default). If `sandbox` is false the variables from any previously executed script will still exist.\n\nScripts are executed in the browser context and have access to [XPCOM](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings) bindings, allowing you to actually control aspects of the browser through JavaScript. Something that normally can\'t be done with sansboxed code executed by websites.\n\n```crystal\nbrowser.execute_script("alert(arguments[0])", ["Hello world"])\n```\n\n#### execute_script_async(script, args = nil, timeout = @timeout, new_sandbox = true)\n\nLike [`execute_script`](#executescriptscript-args--nil-timeout--timeout-newsandbox--true), but asynchronous.\n\n```crystal\nbrowser.execute_script_async("alert(arguments[0])", ["Hello world"])\n```\n\n#### dismiss_dialog\n\nDismisses a dialog/alert if there is one. Same as clicking no/cancel.\n\n```crystal\nbrowser.dismiss_dialog\n```\n\n#### accept_dialog\n\nAccepts a dialog if there is one. Same as clicking ok/yes.\n\n```crystal\nbrowser.accept_dialog\n```\n\n#### get_text_from_dialog\n\nGets the text from the current dialog if there is one, otherwise returns nil.\n\n```crystal\nbrowser.execute_script("alert(arguments[0])", ["Hello world"])\nbrowser.get_text_from_dialog\n# => "Hello world"\n```\n\n#### send_keys_to_dialog(*keys)\n\nSends keys to a dialog. Similar to [\'send_keys_to_element`](#sendkeystoelementel-keys).\n\n```crystal\nbrowser.send_keys_to_dialog("My name", key(:enter))\n```\n\n#### quit\n\nCloses the browser.\n\n```crystal\nbrowser.quit\n```\n\n#### restart\n\nAttempts to restart the browser without closing it. (Not working yet)\n\n```crystal\nbrowser.restart\n```\n\n#### clear_pref(pref)\n\nSets a preference back to it\'s default value.\n\n#### pref(pref, default_branch = false, value_type = "unspecified")\n\nGets the value of a user defined preference.\n\n#### set_pref(pref, value, default_branch = false)\n\nSets a preference to the provided value.\n\n#### set_prefs(prefs, defualt_branch = false)\n\nAccepts a Hash or Array of Tuples and sets each preference (key) to the value.\n\n#### using_prefs(prefs, default_branch = false, &block)\n\nSets the preferences for the provided block and then resets them afterwards.\n\n## Contributing\n\n1. Fork it ( https://github.com/watzon/marionette/fork )\n2. Create your feature branch (git checkout -b my-new-feature)\n3. Commit your changes (git commit -am \'Add some feature\')\n4. Push to the branch (git push origin my-new-feature)\n5. Create a new Pull Request\n\n## Contributors\n\n- [watzon](https://github.com/watzon)  - creator, maintainer\n'