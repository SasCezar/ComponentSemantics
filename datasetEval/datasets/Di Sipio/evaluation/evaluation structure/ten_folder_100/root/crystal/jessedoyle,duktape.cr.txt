b'# Duktape.cr\n\n[![GitHub version](https://badge.fury.io/gh/jessedoyle%2Fduktape.cr.svg)](http://badge.fury.io/gh/jessedoyle%2Fduktape.cr)\n[![Build Status](https://travis-ci.org/jessedoyle/duktape.cr.svg?branch=master)](https://travis-ci.org/jessedoyle/duktape.cr)\n\nDuktape.cr provides Crystal bindings to the [Duktape](https://github.com/svaarala/duktape) javascript engine.\n\n## Installation\n\nDuktape.cr is best installed using [Shards](https://github.com/ysbaddaden/shards).\n\nAdd this to your `shard.yml`:\n\n```yaml\nname: example  # your project\'s name\nversion: 1.0.0 # your project\'s version\n\ndependencies:\n  duktape:\n    github: jessedoyle/duktape.cr\n    version: ~> 0.18.1\n```\n\nthen execute:\n\n```bash\nshards install\n```\n\nShards will automatically make the native library. You can make the library manually by calling `make libduktape`.\n\n## Usage\n\nYou must first create a Duktape context:\n\n```crystal\nrequire "duktape"\n\nsbx = Duktape::Sandbox.new\n\nsbx.eval! <<-JS\n  var birthYear = 1990;\n\n  function calcAge(birthYear){\n    var current = new Date();\n    var year = current.getFullYear();\n    return year - birthYear;\n  }\n\n  print("You are " + calcAge(birthYear) + " years old.");\nJS\n```\n\nAn overwhelming majority of the [Duktape API](http://duktape.org/api.html) has been implemented. You can call the API functions directly on a `Duktape::Sandbox` or `Duktape::Context` instance:\n\n```crystal\nsbx = Duktape::Sandbox.new\nsbx.push_global_object   # [ global ]\nsbx.push_string "Math"   # [ global "Math" ]\nsbx.get_prop -2          # [ global Math ]\nsbx.push_string "PI"     # [ global Math "PI" ]\nsbx.get_prop -2          # [ global Math PI ]\npi = sbx.get_number -1\nputs "PI: #{pi}"         # => PI: 3.14159\nsbx.pop_3\n```\n\n## Eval vs Eval!\n\nAll of the evaluation API methods have a corresponding bang-method (`!`). The bang method calls will raise when a javascript error occurs, the non-bang methods will not raise on invalid javascript.\n\nFor example:\n\n```crystal\nsbx = Duktape::Context.new\nsbx.eval <<-JS\n  var a =\nJS\n```\n\nwill not raise any errors, but will return a non-zero error code.\n\nThe following code:\n\n```crystal\nsbx = Duktape::Context.new\nsbx.eval! <<-JS\n  __invalid();\nJS\n```\n\nwill raise `Duktape::SyntaxError`.\n\n## Sandbox vs Context\n\nYou should only execute untrusted javascript code from within a `Duktape::Sandbox` instance. A sandbox isolates code from insecure operations such as Duktape\'s internal `require` mechanism and the `Duktape` global javascript object.\n\nCreating a `Duktape::Context` gives code access to internal Duktape properties:\n\n```crystal\nctx = Duktape::Context.new\nctx.eval! <<-JS\n  print(Duktape.version);\nJS\n```\n\n## Setting a Timeout\n\n`Duktape::Sandbox` instances may optionally take an execution timeout limit in milliseconds. This provides protection against infinite loops when executing untrusted code.\n\nA `Duktape::RangeError` exception is raised when the following code executes for longer than specified:\n\n```crystal\nsbx = Duktape::Sandbox.new 500 # 500ms execution time limit\nsbx.eval! "while (true) {}"    # => RangeError\n```\n\n## Duktape::Runtime\n\nAn alternative interface for evaluating JS code is available via the `Duktape::Runtime` class. This class provides a streamlined evaluation API (similar to ExecJS) that allows easier access to javascript values without the need to call many low-level Duktape API functions.\n\nThe entire `Runtime` API is as follows:\n\n* `call(property, *args)` - Call the property or function with the given arguments and return the result.\n* `call([properties], *args)` - Call the property that is nested within an array of string property names.\n* `eval(source)` - Evaluate the javascript source and return the last value.\n* `exec(source)` - Evaluate the javascript source and always return `nil`.\n\n`Duktape::Runtime` instances can also be provided an initialization block when created.\n\nHere\'s an example:\n\n```crystal\n  require "duktape/runtime"\n\n  # A Runtime (optionally) accepts an initialization block\n  rt = Duktape::Runtime.new do |sbx|\n    sbx.eval! <<-JS\n      function test(a, b, c) { return a + b + c; }\n    JS\n  end\n\n  rt.call("test", 3, 4, 5) # => 12.0 (same as test(3, 4, 5);)\n  rt.call(["Math", "PI"])  # => 3.14159\n  rt.eval("1 + 1")         # => 2.0\n  rt.exec("1 + 1")         # => nil\n```\n\nNote that `duktape/runtime` is not loaded by the base `duktape` require, and may be used standalone if necessary (ie. replace your `require "duktape"` calls with `require "duktape/runtime"` if you want this functionality).\n\n## Calling Crystal Code from Javascript\n\n**Note**: This functionality is considered experimental and syntax/functionality may change dramatically between releases.\n\nIt is possible to call Crystal code from your javascript:\n\n```crystal\n  sbx = Duktape::Sandbox.new\n\n  # Push a global function named "add_together"\n  # that accepts two arguments.\n  sbx.push_global_proc("add_together", 2) do |ptr|\n    env = Duktape::Sandbox.new ptr\n\n    # Get the two arguments\n    # from the stack\n    a = env.require_number 0\n    b = env.require_number 1\n\n    env.push_number a + b # Push the return value to the stack\n    env.call_success      # call_success -> stack top is value returned\n  end\n\n  sbx.eval! "print(add_together(2, 3));" # => 5\n```\n\nThe `proc` object that is pushed to the Duktape stack accepts a pointer to a `Context` instance. We must wrap this pointer by calling `env = Duktape::Sandbox.new ptr`. The `proc` must also return an `Int32` status code - `env.call_failure` and `env.call_success` will provide the proper integer values.\n\n**Note**: Because it is currently not possible to pass closures to C bindings in Crystal, one must be careful that any variables used in the `proc` must not be referenced or initialized outside the scope of the `proc`. This is why variable names such as `env` are used.\n\n## Exceptions\n\nThe following exceptions may be thrown at runtime and may be rescued normally:\n\n* `Duktape::Error`\n* `Duktape::EvalError`\n* `Duktape::RangeError`\n* `Duktape::ReferenceError`\n* `Duktape::SyntaxError`\n* `Duktape::TypeError`\n* `Duktape::URIError`\n\nThese exceptions all inherit from `Duktape::Error`, so it may be used as a catch-all for runtime errors.\n\nThe following exceptions represent errors internal to the Duktape engine and are generally not recoverable when thrown from a context:\n\n* `Duktape::InternalError`\n* `Duktape::HeapError`\n\nThese exceptions all inherit from `Duktape::InternalError`.\n\n## Contributing\n\nI\'ll accept any pull requests that are well tested for bugs/features with Duktape.cr.\n\nYou should fork the main repo, create a feature branch, write tests and submit a pull request.\n\n## License\n\nDuktape.cr is licensed under the MIT License. Please see `LICENSE` for details.\n'