b'# <img src="https://stars.medv.io/mamantoha/crest.svg" align="right"/>\n\n<p align="left"><img src="https://raw.githubusercontent.com/mamantoha/crest/master/logo/logotype_horizontal.png" alt="crest" height="150px"></p>\n\n[![Codacy Badge](https://api.codacy.com/project/badge/Grade/16e439ef2706472988306ef13da91a51)](https://app.codacy.com/app/mamantoha/crest?utm_source=github.com&utm_medium=referral&utm_content=mamantoha/crest&utm_campaign=Badge_Grade_Dashboard)\n[![Build Status](https://travis-ci.org/mamantoha/crest.svg?branch=master)](https://travis-ci.org/mamantoha/crest)\n[![GitHub release](https://img.shields.io/github/release/mamantoha/crest.svg)](https://github.com/mamantoha/crest/releases)\n[![Commits Since Last Release](https://img.shields.io/github/commits-since/mamantoha/crest/latest.svg)](https://github.com/mamantoha/crest/pulse)\n[![Docs](https://img.shields.io/badge/docs-available-brightgreen.svg)](https://mamantoha.github.io/crest/)\n[![License](https://img.shields.io/github/license/mamantoha/crest.svg)](https://github.com/mamantoha/crest/blob/master/LICENSE)\n\nHTTP and REST client for Crystal, inspired by the Ruby\'s RestClient gem.\n\nBeloved features:\n\n* Redirects support.\n* HTTP(S) proxy support.\n* Elegant Key/Value headers, cookies, params, and payload.\n* Multipart file uploads.\n* Digest access authentication.\n* Logging.\n\nHopefully, someday I can remove this shard though. Ideally, Crystal\'s standard library would do all this already.\n\n## Installation\n\nAdd this to your application\'s `shard.yml`:\n\n```yaml\ndependencies:\n  crest:\n    github: mamantoha/crest\n```\n\n## Usage\n\n```crystal\nrequire "crest"\n```\n\nBasic usage:\n\n```crystal\nCrest.get(\n  "http://httpbin.org/get",\n  params: {:lang => "en"}\n)\n# curl -L "http://httpbin.org/get?lang=en"\n\nCrest.post(\n  "http://httpbin.org/post",\n  form: {:age => 27, :name => {:first => "Kurt", :last => "Cobain"}}\n)\n# curl -L --data "age=27&name[first]=Kurt&name[last]=Cobain" -X POST "http://httpbin.org/post"\n\nCrest.post(\n  "http://httpbin.org/post",\n  form: {"file" => File.open("avatar.png"), "name" => "John"}\n)\n# curl -X POST http://httpbin.org/post -F \'file=@avatar.png\' -F \'name=John\' -H \'Content-Type: multipart/form-data\'\n```\n\n### Request\n\n`Crest::Request` accept next parameters:\n\nMandatory parameters:\n\n* `:method` - HTTP method (`:get`. `:post`, `:put`, `:patch`,  `:delete`, `:options`, `head`)\n* `:url` - URL (e.g.: `http://httpbin.org/ip`)\n\nOptional parameters:\n\n* `:headers` -  a hash containing the request headers\n* `:cookies` -  a hash containing the request cookies\n* `:form` -  a hash containing form params\n* `:params` -  a hash that represent query-string separated from the preceding part by a question mark (`?`) a sequence of attribute\xe2\x80\x93value pairs separated by a delimiter (`&`)\n* `auth` - access authentication method `basic` or `digest` (default to `basic`)\n* `:user` and `:password` - for authentication\n* `:tls` - client certificates, you can pass in a custom `OpenSSL::SSL::Context::Client` (default to `nil`)\n* `:p_addr`, `:p_port`, `:p_user`, and `:p_pass` - specify a per-request proxy by passing these parameters\n* `:max_redirects` -  maximum number of redirections (default to 10)\n* `:logging` -  enable logging (default to `false`)\n* `:logger` -  set logger (default to `Crest::CommonLogger`)\n* `:handle_errors` - error handling (default to `true`)\n* `:http_client` - instance of `HTTP::Client`\n\nMore detailed examples:\n\n```crystal\nrequest = Crest::Request.new(:post,\n  "http://httpbin.org/post",\n  headers: {"Content-Type" => "application/json"},\n  form: {:width => 640, "height" => "480"}\n)\nrequest.execute\n# curl -L --data "width=640&height=480" --header "Content-Type: application/json" -X POST "http://httpbin.org/post"\n```\n\n```crystal\nCrest::Request.execute(:get,\n  "http://httpbin.org/get",\n  params: {:width => 640, "height" => "480"},\n  headers: {"Content-Type" => "application/json"})\n)\n# curl -L --header "Content-Type: application/json" "http://httpbin.org/get?width=640&height=480"\n```\n\n```crystal\nCrest::Request.get(\n  "http://httpbin.org/get",\n  p_addr: "127.0.0.1",\n  p_port: 3128,\n  p_user: "admin",\n  p_pass: "1234"\n)\n# curl -L --proxy http://127.0.0.1:3128 --proxy-user admin:1234 "http://httpbin.org/get"\n```\n\nA block can be passed to the `Crest::Request` initializer.\n\nThis block will then be called with the `Crest::Request`.\n\n```crystal\nrequest = Crest::Request.new(:get, "http://httpbin.org/headers") do |request|\n  request.headers.add("foo", "bar")\nend\n\nrequest.execute\n# curl -L --header "foo: bar" http://httpbin.org/headers\n```\n\n### Resource\n\nA `Crest::Resource` class can be instantiated for access to a RESTful resource,\nincluding authentication, proxy and logging.\n\nAdditionally, you can set default `params` and `headers` separately.\nSo can use `Crest::Resource` to share common `headers` and `params`.\n\nThe final `headers` and `params` consist of:\n\n* default headers from initializer\n* headers provided in call method (`get`, `post`, etc)\n\nThis is especially useful if you wish to define your site in one place and\ncall it in multiple locations.\n\n```crystal\nresource = Crest::Resource.new(\n  "http://httpbin.org",\n  params: {"key" => "value"},\n  headers: {"Content-Type" => "application/json"}\n)\n\nresource["/get"].get(\n  headers: {"Auth-Token" => "secret"}\n)\n\nresource["/post"].post(\n  form: {:height => 100, "width" => "100"},\n  params: {:secret => "secret"}\n)\n```\n\nUse the `[]` syntax to allocate subresources:\n\n```crystal\nsite = Crest::Resource.new("http://httpbin.org")\n\nsite["/post"].post(form: {:param1 => "value1", :param2 => "value2"})\n# curl -L --data "param1=value1&param2=value2" -X POST http://httpbin.org/post\n```\n\nYou can pass `suburl` through `Request#http_verb` methods:\n\n```crystal\nsite = Crest::Resource.new("http://httpbin.org")\n\nsite.post("/post", form: {:param1 => "value1", :param2 => "value2"})\n# curl -L --data "param1=value1&param2=value2" -X POST http://httpbin.org/post\n\nsite.get("/get", params: {:status => "active"})\n# curl -L http://httpbin.org/get?status=active\n```\n\nA block can be passed to the `Crest::Resource` instance.\n\nThis block will then be called with the `Crest::Resource`.\n\n```crystal\nresource = Crest::Resource.new("http://httpbin.org") do |resource|\n  resource.headers.merge!({"foo" => "bar"})\nend\n\nresource["/headers"].get\n```\n\nWith HTTP basic authentication:\n\n```crystal\nresource = Crest::Resource.new(\n  "http://httpbin.org/basic-auth/user/passwd",\n  user: "user",\n  password: "passwd"\n)\n```\n\nWith Proxy authentication:\n\n```crystal\nresource = Crest::Resource.new(\n  "http://httpbin.org/get",\n  p_host: "localhost",\n  p_port: 3128\n)\n```\n\n### Result handling\n\nThe result of a `Crest::Request` and `Crest::Resource` is a `Crest::Response` object.\n\nResponse objects have several useful methods:\n\n* `Response#body`: The response body as a `String`\n* `Response#body_io`: The response body as a `IO`\n* `Response#status`: The response status as a `HTTP::Status`\n* `Response#status_code`: The HTTP response code\n* `Response#headers`: A hash of HTTP response headers\n* `Response#cookies`: A hash of HTTP cookies set by the server\n* `Response#request`: The `Crest::Request` object used to make the request\n* `Response#http_client_res`: The `HTTP::Client::Response` object\n* `Response#history`: A list of each response received in a redirection chain\n\n### Exceptions\n\n* for result codes between `200` and `207`, a `Crest::Response` will be returned\n* for result codes `301`, `302`, `303` or `307`, the redirection will be followed and the request transformed into a `GET`\n* for other cases, a `Crest::RequestFailed` holding the Response will be raised\n* call `.response` on the exception to get the server\'s response\n\n```crystal\nCrest.get("http://httpbin.org/status/404")\n# => HTTP status code 404: Not Found (Crest::NotFound)\n\nbegin\n  Crest.get("http://httpbin.org/status/404")\nrescue ex : Crest::NotFound\n  puts ex.response\nend\n```\n\nTo not raise exceptions but return the `Crest::Response` you can set `:handle_errors => false`.\n\n```crystal\nresponse = Crest.get("http://httpbin.org/status/404", handle_errors: false) do |resp|\n  case resp\n  when .success?\n    puts resp.body_io.gets_to_end\n  when .client_error?\n    puts "Client error"\n  when .server_error?\n    puts "Server error"\n  end\nend\n# => Client error\n\nresponse.status_code # => 404\n```\n\nBut note that it may be more straightforward to use exceptions to handle different HTTP error response cases:\n\n```crystal\nresponse = begin\n  Crest.get("http://httpbin.org/status/404")\nrescue ex : Crest::NotFound\n  puts "Not found"\n  ex.response\nrescue ex : Crest::InternalServerError\n  puts "Internal server error"\n  ex.response\nend\n# => Not found\n\nresponse.status_code # => 404\n```\n\n### Streaming responses\n\nNormally, when you use `Crest`, `Crest::Request` or `Crest::Resource` methods to retrieve data, the entire response is buffered in memory and returned as the response to the call.\n\nHowever, if you are retrieving a large amount of data, for example an iso, or any other large file, you may want to stream the response directly to disk rather than loading it in memory. If you have a very large file, it may become impossible to load it into memory.\n\nIf you want to stream the data from the response to a file as it comes, rather than entirely in memory, you can pass a block to which you pass a additional logic, which you can use to stream directly to a file as each chunk is received.\n\nWith a block, an `Crest::Response` body is returned and the response\'s body is available as an `IO` by invoking `Crest::Response#body_io`.\n\nThe following is an example:\n\n```crystal\nCrest.get("https://github.com/crystal-lang/crystal/archive/0.27.0.zip") do |resp|\n  filename = resp.filename || "crystal.zip"\n\n  File.open(filename, "w") do |file|\n    IO.copy(resp.body_io, file)\n  end\nend\n```\n\n### Advanced Usage\n\nThis section covers some of `crest` more advanced features.\n\n#### Multipart\n\nYeah, that\'s right! This does multipart sends for you!\n\n```crystal\nfile = File.open("#{__DIR__}/example.png")\nCrest.post("http://httpbin.org/post", form: {:image => file})\n```\n\n```crystal\nfile = File.open("#{__DIR__}/example.png")\nresource = Crest::Resource.new("https://httpbin.org")\nresponse = resource["/post"].post(form: {:image => file})\n```\n\n#### JSON payload\n\n`crest` does not speak JSON natively, so serialize your *form* to a string before passing it to `crest`.\n\n```crystal\nCrest.post(\n  "http://httpbin.org/post",\n  headers: {"Content-Type" => "application/json"},\n  form: {:foo => "bar"}.to_json\n)\n```\n\n#### Headers\n\nRequest headers can be set by passing a hash containing keys and values representing header names and values:\n\n```crystal\nresponse = Crest.get(\n  "http://httpbin.org/bearer",\n  headers: {"Authorization" => "Bearer cT0febFoD5lxAlNAXHo6g"}\n)\nresponse.headers\n# => {"Authorization" => ["Bearer cT0febFoD5lxAlNAXHo6g"]}\n```\n\n#### Cookies\n\n`Request` and `Response` objects know about HTTP cookies, and will automatically extract and set headers for them as needed:\n\n```crystal\nresponse = Crest.get(\n  "http://httpbin.org/cookies/set",\n  params: {"k1" => "v1", "k2" => "v2"}\n)\nresponse.cookies\n# => {"k1" => "v1", "k2" => "v2"}\n```\n\n```crystal\nresponse = Crest.get(\n  "http://httpbin.org/cookies",\n  cookies: {"k1" => "v1"}\n)\nresponse.cookies\n# => {"k1" => "v1"}\n```\n\n#### Basic access authentication\n\nFor basic access authentication for an HTTP user agent you should to provide a `user` name and `password` when making a request.\n\n```crystal\nCrest.get(\n  "http://httpbin.org/basic-auth/user/passwd",\n  user: "user",\n  password: "passwd"\n)\n# curl -L --user user:passwd http://httpbin.org/basic-auth/user/passwd\n```\n\n#### Digest access authentication\n\nFor digest access authentication for an HTTP user agent you should to provide a `user` name and `password` when making a request.\n\n```crystal\nCrest.get(\n  "https://httpbin.org/digest-auth/auth/user/passwd/MD5",\n  auth: "digest",\n  user: "user",\n  password: "passwd"\n)\n# curl -L --digest --user user:passwd https://httpbin.org/digest-auth/auth/user/passwd/MD5\n```\n\n#### SSL/TLS support\n\nIf `tls` is given it will be used:\n\n```crystal\nCrest.get("https://expired.badssl.com", tls: OpenSSL::SSL::Context::Client.insecure)\n```\n\n#### Proxy\n\nIf you need to use a proxy, you can configure individual requests with the proxy host and port arguments to any request method:\n\n```crystal\nCrest.get(\n  "http://httpbin.org/ip",\n  p_addr: "localhost",\n  p_port: 3128\n)\n```\n\nTo use authentication with your proxy, use next syntax:\n\n```crystal\nCrest.get(\n  "http://httpbin.org/ip",\n  p_addr: "localhost",\n  p_port: 3128,\n  p_user: "user",\n  p_pass: "qwerty"\n)\n```\n\n#### Logging\n\n> `Logger` class is completely taken from [halite](https://github.com/icyleaf/halite) shard.\n> Thanks [icyleaf](https://github.com/icyleaf)!\n\nBy default, the `Crest` does not enable logging. You can enable it per request by setting `logging: true`:\n\n```crystal\nCrest.get("http://httpbin.org/get", logging: true)\n```\n\n##### Filter sensitive information from logs with a regex matcher\n\n```crystal\nresource = Crest::Request.get("http://httpbin.org/get", params: {api_key => "secret"}, logging: true) do |request|\n  request.logger.filter(/(api_key=)(\\w+)/, "\\\\1[REMOVED]")\nend\n\n# => crest | 2018-07-04 14:49:49 | GET | http://httpbin.org/get?api_key=[REMOVED]\n```\n\n##### Customize logger\n\nYou can create the custom logger by integration `Crest::Logger` abstract class.\nHere has two methods must be implement: `Crest::Logger.request` and `Crest::Logger.response`.\n\n```crystal\nclass MyLogger < Crest::Logger\n  def request(request)\n    @logger.info ">> | %s | %s" % [request.method, request.url]\n  end\n\n  def response(response)\n    @logger.info "<< | %s | %s" % [response.status_code, response.url]\n  end\nend\n\nCrest.get("http://httpbin.org/get", logging: true, logger: MyLogger.new)\n```\n\n#### Redirection\n\nBy default, `crest` will follow HTTP 30x redirection requests.\n\nTo disable automatic redirection, set `:max_redirects => 0`.\n\n```crystal\nCrest::Request.execute(method: :get, url: "http://httpbin.org/redirect/1", max_redirects: 0)\n# => Crest::Found: 302 Found\n```\n\n#### Access HTTP::Client\n\nYou can access `HTTP::Client` via the `http_client` instance method.\n\nThis is usually used to set additional options (e.g. read timeout, authorization header etc.)\n\n```crystal\nclient = HTTP::Client.new("httpbin.org")\nclient.read_timeout = 1.second\n\nbegin\n  Crest::Request.new(:get,\n    "http://httpbin.org/delay/10",\n    http_client: client\n  )\nrescue IO::Timeout\n  puts "Timeout!"\nend\n```\n\n```crystal\nclient = HTTP::Client.new("httpbin.org")\nclient.read_timeout = 1.second\n\nbegin\n  resource = Crest::Resource.new("http://httpbin.org", http_client: client)\n  resource.get("/delay/10")\nrescue IO::Timeout\n  puts "Timeout!"\nend\n```\n\n#### Convert Request object to cURL command\n\nUse `to_curl` method on instance of `Crest::Request` to convert request to cURL command.\n\n```crystal\nrequest = Crest::Request.new(\n  :post,\n  "http://httpbin.org/post",\n  form: {"title" => "New Title", "author" => "admin"}\n)\nrequest.to_curl\n# => curl -X POST http://httpbin.org/post -d \'title=New+Title&author=admin\' -H \'Content-Type: application/x-www-form-urlencoded\'\n```\n\n```crystal\nrequest = Crest::Request.new(\n  :get,\n  "http://httpbin.org/basic-auth/user/passwd",\n  user: "user",\n  password: "passwd"\n)\nrequest.to_curl\n# => curl -X GET http://httpbin.org/basic-auth/user/passwd --user user:passwd\n```\n\nAlso you can directly use `Crest::Curlify` which accept instance of `Crest::Request`\n\n```crystal\nrequest = Crest::Request.new(:get, "http://httpbin.org")\nCrest::Curlify.new(request).to_curl\n# => curl -X GET http://httpbin.org\n```\n\n## Development\n\nInstall dependencies:\n\n```console\nshards\n```\n\nTo run test:\n\n```console\ncrystal spec\n```\n\n### Workbook\n\n```console\ncrystal play\nopen http://localhost:8080\n```\n\nThen select the Workbook -> Requests from the menu.\n\n## Contributing\n\n1. Fork it (<https://github.com/mamantoha/crest/fork>)\n2. Create your feature branch (git checkout -b my-new-feature)\n3. Commit your changes (git commit -am \'Add some feature\')\n4. Push to the branch (git push origin my-new-feature)\n5. Create a new Pull Request\n\n## Contributors\n\n* [mamantoha](https://github.com/mamantoha) Anton Maminov - creator, maintainer\n* [icyleaf](https://github.com/icyleaf) Icyleaf Wang - logging support\n* [psikoz](https://github.com/psikoz) Logo design\n\n## License\n\nCopyright: 2017-2019 Anton Maminov (anton.maminov@gmail.com)\n\nThis library is distributed under the MIT license. Please see the LICENSE file.\n'