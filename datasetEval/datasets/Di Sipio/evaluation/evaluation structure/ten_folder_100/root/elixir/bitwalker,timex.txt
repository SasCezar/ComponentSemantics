b'## Timex\n\n[![Master](https://travis-ci.org/bitwalker/timex.svg?branch=master)](https://travis-ci.org/bitwalker/timex)\n[![Hex.pm Version](http://img.shields.io/hexpm/v/timex.svg?style=flat)](https://hex.pm/packages/timex)\n[![InchCI](https://inch-ci.org/github/bitwalker/timex.svg?branch=master)](https://inch-ci.org/github/bitwalker/timex)\n[![Coverage Status](https://coveralls.io/repos/github/bitwalker/timex/badge.svg?branch=master)](https://coveralls.io/github/bitwalker/timex?branch=master)\n\nTimex is a rich, comprehensive Date/Time library for Elixir projects, with full timezone support via the `:tzdata` package. If\nyou need to manipulate dates, times, datetimes, timestamps, etc., then Timex is for you! It is very easy to use Timex types\nin place of default Erlang types, as well as Ecto types via the `timex_ecto` package.\n\nThe complete documentation for Timex is located [here](https://hexdocs.pm/timex).\n\n## Migrating to Timex 3.x\n\nSee the Migrating section further down for details. If you are migrating from earlier than 2.x,\nplease review [this migration doc for 1.x to 2.x](https://github.com/bitwalker/timex/tree/2.2.1#migrating).\n\nTimex 3.0 is a significant rewrite, in order to accommodate Elixir 1.3\'s new Calendar types in a semantically\ncorrect way. The external API is mostly the same, but there are changes, many without deprecations, so please\nread the changelog carefully.\n\n## Getting Started\n\nThere are some brief examples on usage below, but I highly recommend you review the\nAPI docs [here](https://hexdocs.pm/timex), there are many examples, and some extra pages with\nricher documentation on specific subjects such as custom formatters/parsers, etc.\n\n### Adding Timex To Your Project\n\nTo use Timex with your projects, edit your `mix.exs` file and add it as a dependency:\n\n```elixir\ndefp deps do\n  [{:timex, "~> 3.5"}]\nend\n\ndefp application do\n  [applications: [:timex]]\nend\n```\n\n### Quickfast introduction\n\nTo use Timex, I recommend you add `use Timex` to the top of the module where you will be working with Timex modules,\nall it does is alias common types so you can work with them more comfortably. If you want to see the specific aliases\nadded, check the top of the `Timex` module, in the `__using__/1` macro definition.\n\nHere\'s a few simple examples:\n\n```elixir\n> use Timex\n> Timex.today\n~D[2016-02-29]\n\n> datetime = Timex.now\n#<DateTime(2016-02-29T12:30:30.120+00:00Z Etc/UTC)\n\n> Timex.now("America/Chicago")\n#<DateTime(2016-02-29T06:30:30.120-06:00 America/Chicago)\n\n> Duration.now\n#<Duration(P46Y6M24DT21H57M33.977711S)>\n\n> {:ok, default_str} = Timex.format(datetime, "{ISO:Extended}")\n{:ok, "2016-02-29T12:30:30.120+00:00"}\n\n> {:ok, relative_str} = Timex.shift(datetime, minutes: -3) |> Timex.format("{relative}", :relative)\n{:ok, "3 minutes ago"}\n\n> strftime_str = Timex.format!(datetime, "%FT%T%:z", :strftime)\n"2016-02-29T12:30:30+00:00"\n\n> Timex.parse(strftime_str, "{ISO:Extended}")\n{:ok, #<DateTime(2016-02-29T12:30:30.120+00:00 Etc/Utc)}\n\n> Timex.parse!(strftime_str, "%FT%T%:z", :strftime)\n#<DateTime(2016-02-29T12:30:30.120+00:00 Etc/Utc)\n\n> Duration.diff(Duration.now, Duration.zero, :days)\n16850\n\n> Timex.shift(date, days: 3)\n~D[2016-03-03]\n\n> Timex.shift(datetime, hours: 2, minutes: 13)\n#<DateTime(2016-02-29T14:43:30.120Z Etc/UTC)>\n\n> timezone = Timezone.get("America/Chicago", Timex.now)\n#<TimezoneInfo(America/Chicago - CDT (-06:00:00))>\n\n> Timezone.convert(datetime, timezone)\n#<DateTime(2016-02-29T06:30:30.120-06:00 America/Chicago)>\n\n> Timex.before?(Timex.today, Timex.shift(Timex.today, days: 1))\ntrue\n\n> Timex.before?(Timex.shift(Timex.today, days: 1), Timex.today)\nfalse\n\n> interval = Timex.Interval.new(from: ~D[2016-03-03], until: [days: 3])\n%Timex.Interval{from: ~N[2016-03-03 00:00:00], left_open: false,\n right_open: true, step: [days: 1], until: ~N[2016-03-06 00:00:00]}\n\n> ~D[2016-03-04] in interval\ntrue\n\n> ~N[2016-03-04 00:00:00] in interval\ntrue\n\n> ~N[2016-03-02 00:00:00] in interval\nfalse\n\n> Timex.Interval.overlaps?(Timex.Interval.new(from: ~D[2016-03-04], until: [days: 1]), interval)\ntrue\n\n> Timex.Interval.overlaps?(Timex.Interval.new(from: ~D[2016-03-07], until: [days: 1]), interval)\nfalse\n\n```\n\nThere are a ton of other functions, all of which work with Erlang datetime tuples, Date, NaiveDateTime, and DateTime. The Duration module contains functions for working with Durations, including Erlang timestamps (such as those returned from `:timer.tc`)\n\n## Extensibility\n\nTimex exposes a number of extension points for you, in order to accommodate different use cases:\n\nTimex itself defines it\'s core operations on the Date, DateTime, and NaiveDateTime types using the `Timex.Protocol` protocol. From there, all other Timex functionality is derived. If you have custom date/datetime types you want to use with Timex, this is the protocol you would need to implement.\n\nTimex also defines a `Timex.Comparable` protocol, which you can extend to add comparisons to custom date/datetime types.\n\nYou can provide your own formatter/parser for datetime strings by implementing the `Timex.Format.DateTime.Formatter` and/or `Timex.Parse.DateTime.Parser` behaviours, depending on your needs.\n\n## Common Issues\n\n### `iso_*` Functions\n\nTimex functions of the form `iso_*` behave based on how the ISO calendar represents dates/times and not the ISO8601 date format. This confusion has occurred before, and it\'s important to note this!\n\n### Timex with escript\n\nIf you need to use Timex from within an escript, add `{:tzdata, "~> 0.1.8", override: true}` to your deps, more recent versions of :tzdata are unable to work in an escript because of the need to load ETS table files from priv, and due to the way ETS loads these files, it\'s not possible to do so.\n\n### Automatic time zone updates\n\nTimex includes the [Tzdata](https://github.com/lau/tzdata) library for time zone data. Tzdata has an automatic update capability that fetches updates from IANA and which is enabled by default; if you want to disable it, check [the Tzdata documentation](https://github.com/lau/tzdata#automatic-data-updates) for details.\n\n## Migrating\n\nIf you have been using Timex pre-3.x, and you are looking to migrate, it will be fairly painless as long as you review the `CHANGELOG.md` file and make note of anything that has changed which you are using. In almost every single case, the functionality has simply moved, or is accessed slightly differently. In some cases behaviour has changed, but the old behaviour can be achieved manually. For those things which were removed or are no longer available, it is almost certainly because those things are no longer recommended, or no longer make sense for this library. If I have missed something, or there is a good justification for re-adding something which was removed, I\'m always open to discussing it on the issue tracker.\n\n### Overview of 3.x changes\n\nPlease see the `CHANGELOG.md` file for the list of all changes made, below are a brief recap of the major points, and\ninstructions on how to migrate your existing Timex-based code to 3.x.\n\n- Virtually all of Timex\'s API is consolidated around three modules: `Timex`, `Duration`, and `Interval`. There are public APIs in other modules of course, but most everything you do can be done via one of those three.\n- All Timex-provided types have been removed, with the exception of `Time` which has been renamed to `Duration` to better fit it\'s purpose,\n`TimezoneInfo`, which is still used internally, and accessible externally, and `AmbiguousDateTime`, which is still required when dealing with ambiguous `DateTime` structs. `Date` and `DateTime` are now part of Elixir 1.3, and `NaiveDateTime` has been added as a first class type as well.\n- Conversions have been rehashed, and are now accessed via the `Timex` module: `to_date`, `to_datetime`, `to_naive_datetime`, `to_erl`, `to_unix`, `to_gregorian_seconds`, and `to_gregorian_microseconds`. Use these to convert back and forth between types. With very few exceptions, there are no `from_*` conversions. You must construct a standard type either with the standard library functions (such as `NaiveDateTime.new`), or by converting from another standard type (i.e. Erlang datetime tuple to NaiveDateTime).\n\nA variety of improvements came about as well:\n\n- Microsecond precision everywhere it can be maintained\n- Various bug fixes from the 2.x release which were held back\n- A lot of code clean up\n- Faster compilation\n- Fixed typespecs, docs, and tests across the board\n- Added Julian calendar support\n\n\n## Roadmap\n\nThe following are an unordered list of things I plan for Timex in the future, if you\nhave specific requests, please open an issue with "RFC" in the title, and we can discuss\nit, and hopefully get input from the community.\n\n- 100% test coverage (well under way!)\n- QuickCheck tests (haven\'t started this, but I really want to start ASAP)\n- `{ASP.NET}` formatting/parsing token for interop with .NET services (probably in the next release)\n- Relative time formatter/parser, along the lines of Moment.js\'s `fromNow`, `toNow`, `timeTo`, and `timeFrom` formatting functions.\n- Calendar time formatter/parser, along the lines of Moment.js\'s calendar time formatter\n- Recurring dates/times API\n\n## License\n\nThis software is licensed under [the MIT license](LICENSE.md).\n'