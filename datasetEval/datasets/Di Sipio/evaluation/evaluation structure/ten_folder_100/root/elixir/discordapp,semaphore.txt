b'# Semaphore\n\n[![Master](https://travis-ci.org/discordapp/semaphore.svg?branch=master)](https://travis-ci.org/discordapp/semaphore)\n[![Hex.pm Version](http://img.shields.io/hexpm/v/semaphore.svg?style=flat)](https://hex.pm/packages/semaphore)\n\nProgramming in Erlang and Elixir usually allows for no locking since the VM essentially handles it for you when\ncommunicating between processes. However, what about the situation when you have thousands of processes attempting\nto interact with a single resource such as a process? Usually they will overload the process and explode the\nmessage queue. ETS is the Swiss Army knife of the Erlang VM and can be applied to this problem. By using `:ets.update_counter`\nand `:write_concurrency` we can achieve a **fast** low contention semaphore on ETS.\n\n## Usage\n\nAdd it to `mix.exs`\n\n```elixir\ndefp deps do\n  [{:semaphore, "~> 1.1"}]\nend\n```\n\nThen just use it like a semaphore in any other language.\n\n```elixir\nif Semaphore.acquire(:test, 1) do\n  IO.puts "acquired"\n  Semaphore.release(:test)\nend\n\ncase Semaphore.call(:test, 1, fn -> :ok end) do\n  :ok ->\n    IO.puts "success"\n  {:error, :max} ->\n    IO.puts "too many callers"\nend\n```\n\n## License\n\nSemaphore is released under [the MIT License](LICENSE).\nCheck [LICENSE](LICENSE) file for more information.\n'