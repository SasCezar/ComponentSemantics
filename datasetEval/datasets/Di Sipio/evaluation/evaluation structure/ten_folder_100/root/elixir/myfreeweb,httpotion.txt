b'[![hex.pm version](https://img.shields.io/hexpm/v/httpotion.svg?style=flat)](https://hex.pm/packages/httpotion)\n[![hex.pm downloads](https://img.shields.io/hexpm/dt/httpotion.svg?style=flat)](https://hex.pm/packages/httpotion)\n[![API Docs](https://img.shields.io/badge/api-docs-yellow.svg?style=flat)](https://hexdocs.pm/httpotion/)\n[![Build Status](https://img.shields.io/travis/myfreeweb/httpotion.svg?style=flat)](https://travis-ci.org/myfreeweb/httpotion)\n[![unlicense](https://img.shields.io/badge/un-license-green.svg?style=flat)](http://unlicense.org)\n\n# HTTPotion\n\nHTTP client for [Elixir], based on [ibrowse].\nContinues the HTTPun tradition of [HTTParty], [HTTPretty], [HTTParrot] and [HTTPie].\n\n*Note*: unfortunately, ibrowse seems a bit buggy and not super actively maintained. You might want to check out [Tesla](https://github.com/teamon/tesla) with hackney instead, and [this](https://github.com/teamon/tesla/issues/293#issuecomment-522312859) cert verification setup.\n\n## Installation\n\nAdd HTTPotion to your project\'s dependencies in `mix.exs`:\n\n```elixir\n  defp deps do\n    [\n      {:httpotion, "~> 3.1.0"}\n    ]\n  end\n\n  def application do\n    [ applications: [:httpotion] ]\n    # Application dependency auto-starts it, otherwise: HTTPotion.start\n  end\n```\n\nAnd fetch your project\'s dependencies:\n\n```bash\n$ mix deps.get\n```\n\n## Usage\n\n*Note*: You can load HTTPotion into the Elixir REPL by executing this command from the root of your project:\n\n```\n$ iex -S mix\n```\n\n*Note*: HTTPotion now enables certificate verification by default, using a few default CA bundle paths (`/etc/ssl/cert.pem` etc.) or the [certifi](https://hex.pm/packages/certifi) package (which is not a mandatory dependency).\n\nSome basic examples:\n\n```elixir\niex> response = HTTPotion.get "https://httpbin.org/get"\n%HTTPotion.Response{\n  body: "{\\n\xe2\x80\xa6",\n  headers: %HTTPotion.Headers{ hdrs: %{"connection" => "keep-alive", \xe2\x80\xa6} },\n  status_code: 200\n}\n\niex> HTTPotion.Response.success?(response)\ntrue\n\n# Response headers are wrapped to allow case-insensitive access (and to support both atoms and strings)\niex> response.headers[:sErvEr]\n"meinheld/0.6.1"\n\niex> response.headers["ConTenT-TyPe"]\n"application/json"\n\n# Response headers can have multiple values\niex> response = HTTPotion.get "https://httpbin.org/response-headers?foo=1&foo=2&bar=1"\n%HTTPotion.Response{\n  body: "{\\n\xe2\x80\xa6",\n  headers: %HTTPotion.Headers{ hdrs: %{"foo" => ["1", "2"], "bar" => "1" \xe2\x80\xa6} },\n  status_code: 200\n}\n\n# You can provide a map for the query string\niex> HTTPotion.get("https://httpbin.org/get", query: %{page: 2})\n%HTTPotion.Response{body: "\xe2\x80\xa6", headers: \xe2\x80\xa6, status_code: 200}\n\n# Follow redirects\niex> HTTPotion.get("https://httpbin.org/redirect-to?url=http%3A%2F%2Fexample.com%2F", follow_redirects: true)\n%HTTPotion.Response{body: "\xe2\x80\xa6<title>Example Domain</title>\xe2\x80\xa6", headers: \xe2\x80\xa6, status_code: 200}\n\n# Send form data\niex> HTTPotion.post "https://httpbin.org/post", [body: "hello=" <> URI.encode_www_form("w o r l d !!"),\n  headers: ["User-Agent": "My App", "Content-Type": "application/x-www-form-urlencoded"]]\n%HTTPotion.Response{body: "\xe2\x80\xa6", headers: \xe2\x80\xa6, status_code: 200}\n\n# Use a custom method\niex> HTTPotion.request :propfind, "http://httpbin.org/post", [body: "I have no idea what I\'m doing"]\n%HTTPotion.Response{body: "\xe2\x80\xa6", headers: \xe2\x80\xa6, status_code: 405}\n\n# Send Basic auth credentials\niex> HTTPotion.get "https://httpbin.org/basic-auth/foo/bar", [basic_auth: {"foo", "bar"}]\n%HTTPotion.Response{\n  body: "\xe2\x80\xa6",\n  headers: %HTTPotion.Headers { hdrs: %{"Access-Control-Allow-Credentials": "true", \xe2\x80\xa6} },\n  status_code: 200\n}\n\n# Pass options to ibrowse (note that it usually takes char_lists, not elixir strings)\niex> HTTPotion.get "https://check-tls.akamaized.net", [ ibrowse: [ ssl_options: [ versions, [:\'tlsv1.1\'] ] ] ]\n%HTTPotion.Response{body: "\xe2\x80\xa6TLS SNI: present - Check TLS - (https,tls1.1,ipv4)\xe2\x80\xa6", headers: \xe2\x80\xa6, status_code: 200}\n\n# Change the timeout (default is 5000 ms)\niex> HTTPotion.get "https://example.com", [timeout: 10_000]\n\n# If there is an error a `HTTPotion.ErrorResponse` is returned\niex> HTTPotion.get "http://localhost:1"\n%HTTPotion.ErrorResponse{message: "econnrefused"}\n\n# You can also raise `HTTPError` with the `bang` version of request\niex> HTTPotion.get! "http://localhost:1"\n** (HTTPotion.HTTPError) econnrefused\n```\n\nThe `Response` is [a struct](https://elixir-lang.org/getting-started/structs.html), you can access its fields like: `response.body`.\n\n`response.headers` is a struct (`HTTPotion.Headers`) that wraps a map to provide case-insensitive access (so you can use `response.headers[:authorization]` and it doesn\'t matter if the server returned `AuThOrIZatIOn` or something).\n\n`HTTPError` is [an exception](https://elixir-lang.org/getting-started/try-catch-and-rescue.html) that happens when a bang request (`request!` / `get!` / \xe2\x80\xa6) fails.\n\nAvailable options and their default values:\n\n```elixir\n{\n  body: "",                # Request\'s body contents, e.g. "{json: \\"string\\"}"\n  headers: [],             # Request\'s headers, e.g. [Accept: "application/json"]\n  query: nil,              # Query string, e.g. %{page: 1}\n  timeout: 5000,           # Timeout in milliseconds, e.g. 5000\n  basic_auth: nil,         # Basic auth credentials, e.g. {"username", "password"}\n  stream_to: nil,          # A process to stream the response to when performing async requests\n  direct: nil,             # An ibrowse worker for direct mode\n  ibrowse: [],             # ibrowse options\n  auto_sni: true,          # Whether TLS SNI should be automatically configured (does URI parsing)\n  follow_redirects: false, # Whether redirects should be followed\n}\n\n```\n\n### Metaprogramming magic\n\nYou can extend `HTTPotion.Base` to make cool HTTP API wrappers (this example uses [Poison] for JSON):\n\n```elixir\ndefmodule GitHub do\n  use HTTPotion.Base\n\n  def process_url(url) do\n    "https://api.github.com/" <> url\n  end\n\n  def process_request_headers(headers) do\n    Dict.put headers, :"User-Agent", "github-potion"\n  end\n\n  def process_response_body(body) do\n    body |> Poison.decode!\n  end\nend\n```\n\n```elixir\niex> GitHub.get("users/myfreeweb").body["public_repos"]\n233\n```\n\nRead the source to see all the hooks.\n\nKeep in mind that `process_response_body` and `process_response_chunk` get iodata.\nBy default, they call `IO.iodata_to_binary`.\nBut efficient parsers like Poison can work directly on iodata.\n\n### Asynchronous requests\n\nYou can get the response streamed to your current process asynchronously:\n\n```elixir\niex> HTTPotion.get "http://httpbin.org/get", [stream_to: self]\n%HTTPotion.AsyncResponse{id: -576460752303419903}\n\niex> flush\n%HTTPotion.AsyncHeaders{\n  id: -576460752303419903,\n  status_code: 200,\n  headers: %HTTPotion.Headers{ hdrs: %{"connection" => "keep-alive", \xe2\x80\xa6} }\n}\n%HTTPotion.AsyncChunk{\n  id: -576460752303419903,\n  chunk: "{\\n\xe2\x80\xa6"\n}\n%HTTPotion.AsyncEnd{\n  id: -576460752303419903\n}\n```\n\nNote that instead of `process_response_body`, `process_response_chunk` is called on the chunks before sending them out to the receiver (the `stream_to` process).\n\n### Direct access to ibrowse workers\n\nibrowse allows you to use its separate worker processes directly.\nWe expose this functionality through the `direct` option.\n\nDon\'t forget that you have to pass the URL to the worker process, which means the worker only communicates with one server (domain!)\n\n```elixir\niex> {:ok, worker_pid} = HTTPotion.spawn_worker_process("http://httpbin.org")\n\niex> HTTPotion.get "httpbin.org/get", [direct: worker_pid]\n%HTTPotion.Response{body: "\xe2\x80\xa6", headers: ["Connection": "close", \xe2\x80\xa6], status_code: 200}\n```\n\nYou can even combine it with async!\n\n```elixir\niex> {:ok, worker_pid} = HTTPotion.spawn_worker_process("http://httpbin.org")\n\niex> HTTPotion.post "httpbin.org/post", [direct: worker_pid, stream_to: self, headers: ["User-Agent": "hello it\'s me"]]\n%HTTPotion.AsyncResponse{id: {1372,8757,656584}}\n```\n\n### Type analysis\n\nHTTPotion contains [typespecs] so your usage can be checked with [dialyzer], probably via [dialyxir] or [elixir-ls].\n\nHTTPotion\'s tests are checked with dialyxir.\n\n[Elixir]: https://elixir-lang.org\n[ibrowse]: https://github.com/cmullaparthi/ibrowse\n[HTTParty]: https://github.com/jnunemaker/httparty\n[HTTPretty]: https://github.com/gabrielfalcao/HTTPretty\n[HTTParrot]: https://github.com/edgurgel/httparrot\n[HTTPie]: https://github.com/jkbr/httpie\n[Poison]: https://github.com/devinus/poison\n[typespecs]: https://elixir-lang.org/getting-started/typespecs-and-behaviours.html\n[dialyzer]: http://erlang.org/doc/man/dialyzer.html\n[dialyxir]: https://github.com/jeremyjh/dialyxir\n[elixir-ls]: https://github.com/JakeBecker/elixir-ls\n\n## Contributing\n\nPlease feel free to submit pull requests!\n\nBy participating in this project you agree to follow the [Contributor Code of Conduct](https://www.contributor-covenant.org/version/1/4/).\n\n[The list of contributors is available on GitHub](https://github.com/myfreeweb/httpotion/graphs/contributors).\n\n## License\n\nThis is free and unencumbered software released into the public domain.  \nFor more information, please refer to the `UNLICENSE` file or [unlicense.org](http://unlicense.org).\n'