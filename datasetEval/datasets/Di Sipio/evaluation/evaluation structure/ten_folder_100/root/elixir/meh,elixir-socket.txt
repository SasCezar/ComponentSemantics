b'Elixir sockets made decent\n==========================\nThis library wraps `gen_tcp`, `gen_udp` and `gen_sctp`, `ssl` and implements\nwebsockets and socks.\n\nInstallation\n--------\nIn your `mix.exs` file\n\n```\ndefp deps do\n  [\n    # ...\n    {:socket, "~> 0.3"},\n    # ...\n  ]\nend\n```\n\nThen run `mix deps.get` to install\n\nExamples\n--------\n\n```elixir\ndefmodule HTTP do\n  def get(uri) when is_binary(uri) or is_list(uri) do\n    get(URI.parse(uri))\n  end\n\n  def get(%URI{host: host, port: port, path: path}) do\n    sock = Socket.TCP.connect! host, port, packet: :line\n    sock |> Socket.Stream.send! "GET #{path || "/"} HTTP/1.1\\r\\nHost: #{host}\\r\\n\\r\\n"\n\n    [_, code, text] = Regex.run ~r"HTTP/1.1 (.*?) (.*?)\\s*$", sock |> Socket.Stream.recv!\n\n    headers = headers([], sock) |> Enum.into(%{})\n\n    sock |> Socket.packet! :raw\n    body = sock |> Socket.Stream.recv!(String.to_integer(headers["Content-Length"]))\n\n    { { String.to_integer(code), text }, headers, body }\n  end\n\n  defp headers(acc, sock) do\n    case sock |> Socket.Stream.recv! do\n      "\\r\\n" ->\n        acc\n\n      line ->\n        [_, name, value] = Regex.run ~r/^(.*?):\\s*(.*?)\\s*$/, line\n\n        headers([{ name, value } | acc], sock)\n    end\n  end\nend\n```\n\nWebsockets\n----------\n\n### Client\n\n```elixir\nsocket = Socket.Web.connect! "echo.websocket.org"\nsocket |> Socket.Web.send! { :text, "test" }\nsocket |> Socket.Web.recv! # => {:text, "test"}\n```\n\nIn order to connect to a TLS websocket, use the `secure: true` option:\n\n```elixir\nsocket = Socket.Web.connect! "echo.websocket.org", secure: true\n```\n\nThe `connect!` function also accepts other parameters, most notably the `path` parameter, which is used when the websocket server endpoint exists on a path below the domain ie. "example.com/websocket":\n\n```elixir\nsocket = Socket.Web.connect! "example.com", path: "/websocket"\n```\n\nNote that websocket servers send ping messages. A pong reply from your client tells the server to keep the connection open and to send more data. If your client doesn\'t send a pong reply then the server will close the connection. Here\'s an example of how to get get both the data you want and reply to a server\'s pings:\n\n```elixir\nsocket = Socket.Web.connect! "echo.websocket.org"\ncase socket |> Socket.Web.recv! do\n  {:text, data} ->\n    # process data\n  {:ping, _ } ->\n    socket |> Socket.Web.send!({:pong, ""})\nend\n```\n\n### Server\n\n```elixir\nserver = Socket.Web.listen! 80\nclient = server |> Socket.Web.accept!\n\n# here you can verify if you want to accept the request or not, call\n# `Socket.Web.close!` if you don\'t want to accept it, or else call\n# `Socket.Web.accept!`\nclient |> Socket.Web.accept!\n\n# echo the first message\nclient |> Socket.Web.send!(client |> Socket.Web.recv!)\n```\n'