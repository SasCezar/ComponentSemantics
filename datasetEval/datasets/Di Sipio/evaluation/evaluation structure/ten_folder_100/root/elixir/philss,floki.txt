b'[![Build status](https://travis-ci.org/philss/floki.svg?branch=master)](https://travis-ci.org/philss/floki)\n[![Floki version](https://img.shields.io/hexpm/v/floki.svg)](https://hex.pm/packages/floki)\n[![Hex.pm](https://img.shields.io/hexpm/dt/floki.svg)](https://hex.pm/packages/floki)\n[![Inline docs](https://inch-ci.org/github/philss/floki.svg?branch=master)](https://inch-ci.org/github/philss/floki)\n[![SourceLevel](https://app.sourcelevel.io/github/philss/floki.svg)](https://app.sourcelevel.io/github/philss/floki)\n\n<img src="assets/images/floki-logo-with-type.svg" width="500" alt="Floki logo">\n\n**Floki is a simple HTML parser that enables search for nodes using CSS selectors**.\n\n[Check the documentation](https://hexdocs.pm/floki).\n\n## Usage\n\nTake this HTML as an example:\n\n```html\n<!doctype html>\n<html>\n<body>\n  <section id="content">\n    <p class="headline">Floki</p>\n    <span class="headline">Enables search using CSS selectors</span>\n    <a href="https://github.com/philss/floki">Github page</a>\n    <span data-model="user">philss</span>\n  </section>\n  <a href="https://hex.pm/packages/floki">Hex package</a>\n</body>\n</html>\n```\n\nHere are some queries that you can perform (with return examples):\n\n```elixir\nFloki.find(html, "p.headline")\n# => [{"p", [{"class", "headline"}], ["Floki"]}]\n\n\nFloki.find(html, "p.headline")\n|> Floki.raw_html\n# => <p class="headline">Floki</p>\n```\n\nEach HTML node is represented by a tuple like:\n\n    {tag_name, attributes, children_nodes}\n\nExample of node:\n\n    {"p", [{"class", "headline"}], ["Floki"]}\n\nSo even if the only child node is the element text, it is represented inside a list.\n\nYou can write a simple HTML crawler with Floki and [HTTPoison](https://github.com/edgurgel/httpoison):\n\n```elixir\nhtml\n|> Floki.find(".pages a")\n|> Floki.attribute("href")\n|> Enum.map(fn(url) -> HTTPoison.get!(url) end)\n\n```\n\nIt is simple as that!\n\n## Installation\n\nAdd Floki to your `mix.exs`:\n\n```elixir\ndefp deps do\n  [\n    {:floki, "~> 0.23.0"}\n  ]\nend\n```\n\nAfter that, run `mix deps.get`.\n\n## Dependencies\n\nFloki needs the `leex` module in order to compile.\nNormally this module is installed with Erlang in a complete installation.\n\nIf you get this [kind of error](https://github.com/philss/floki/issues/35),\nyou need to install the `erlang-dev` and `erlang-parsetools` packages in order get the `leex` module.\nThe packages names may be different depending on your OS.\n\n### Optional - Using html5ever as the HTML parser\n\nYou can configure Floki to use [html5ever](https://github.com/servo/html5ever) as your HTML parser.\nThis is recommended if you need [better performance](https://gist.github.com/philss/70b4b0294f29501c3c7e0f60338cc8bd)\nand a more accurate parser. However `html5ever` is being under active development and **may be unstable**.\n\nSince it\'s written in Rust, we need to install Rust and compile the project.\nLuckily we have the [html5ever Elixir NIF](https://github.com/hansihe/html5ever_elixir) that makes the integration very easy.\n\nYou still need to install Rust in your system. To do that, please\n[follow the instruction](https://www.rust-lang.org/en-US/install.html) presented in the official page.\n\n#### Installing html5ever\n\nAfter setup Rust, you need to add `html5ever` NIF to your dependency list:\n\n```elixir\ndefp deps do\n  [\n    {:floki, "~> 0.23.0"},\n    {:html5ever, "~> 0.7.0"}\n  ]\nend\n```\n\nRun `mix deps.get` and compiles the project with `mix compile` to make sure it works.\n\nThen you need to configure your app to use `html5ever`:\n\n```elixir\n# in config/config.exs\n\nconfig :floki, :html_parser, Floki.HTMLParser.Html5ever\n```\n\nAfter that you are able to use `html5ever` as your HTML parser with Floki.\n\nFor more info, check the article [Rustler - Safe Erlang and Elixir NIFs in Rust](http://hansihe.com/2017/02/05/rustler-safe-erlang-elixir-nifs-in-rust.html).\n\n## More about Floki API\n\nTo parse a HTML document, try:\n\n```elixir\nhtml = """\n  <html>\n  <body>\n    <div class="example"></div>\n  </body>\n  </html>\n"""\n\nFloki.parse(html)\n# => {"html", [], [{"body", [], [{"div", [{"class", "example"}], []}]}]}\n```\n\nTo find elements with the class `example`, try:\n\n```elixir\nFloki.find(html, ".example")\n# => [{"div", [{"class", "example"}], []}]\n```\n\nTo convert your node tree back to raw HTML (spaces are ignored):\n\n```elixir\nFloki.find(html, ".example")\n|> Floki.raw_html\n# =>  <div class="example"></div>\n```\n\nTo fetch some attribute from elements, try:\n\n```elixir\nFloki.attribute(html, ".example", "class")\n# => ["example"]\n```\n\nYou can get attributes from elements that you already have:\n\n```elixir\nFloki.find(html, ".example")\n|> Floki.attribute("class")\n# => ["example"]\n```\n\nIf you want to get the text from an element, try:\n\n```elixir\nFloki.find(html, ".headline")\n|> Floki.text\n\n# => "Floki"\n```\n\n## Supported selectors\n\nHere you find all the [CSS selectors](https://www.w3.org/TR/selectors/#selectors) supported in the current version:\n\n| Pattern         | Description                  |\n|-----------------|------------------------------|\n| *               | any element                  |\n| E               | an element of type `E`       |\n| E[foo]          | an `E` element with a "foo" attribute |\n| E[foo="bar"]    | an E element whose "foo" attribute value is exactly equal to "bar" |\n| E[foo~="bar"]   | an E element whose "foo" attribute value is a list of whitespace-separated values, one of which is exactly equal to "bar" |\n| E[foo^="bar"]   | an E element whose "foo" attribute value begins exactly with the string "bar" |\n| E[foo$="bar"]   | an E element whose "foo" attribute value ends exactly with the string "bar" |\n| E[foo*="bar"]   | an E element whose "foo" attribute value contains the substring "bar" |\n| E[foo\\|="en"]    | an E element whose "foo" attribute has a hyphen-separated list of values beginning (from the left) with "en" |\n| E:nth-child(n)  | an E element, the n-th child of its parent |\n| E:first-child   | an E element, first child of its parent |\n| E:last-child   | an E element, last child of its parent |\n| E:nth-of-type(n)  | an E element, the n-th child of its type among its siblings |\n| E:first-of-type   | an E element, first child of its type among its siblings |\n| E:last-of-type   | an E element, last child of its type among its siblings |\n| E.warning       | an E element whose class is "warning" |\n| E#myid          | an E element with ID equal to "myid" |\n| E:not(s)        | an E element that does not match simple selector s |\n| E F             | an F element descendant of an E element |\n| E > F           | an F element child of an E element |\n| E + F           | an F element immediately preceded by an E element |\n| E ~ F           | an F element preceded by an E element |\n\nThere are also some selectors based on non-standard specifications. They are:\n\n| Pattern              | Description                                         |\n|----------------------|-----------------------------------------------------|\n| E:fl-contains(\'foo\') | an E element that contains "foo" inside a text node |\n\n## Special thanks\n\n* [@arasatasaygin](https://github.com/arasatasaygin) for Floki\'s logo from the [Open Logos project](http://openlogos.org/).\n\n## License\n\nFloki is under MIT license. Check the `LICENSE` file for more details.\n'