b'![](http://i.imgur.com/WwqN8JO.png)\n# HTTPoison [![Build Status](https://travis-ci.org/edgurgel/httpoison.svg?branch=master)](https://travis-ci.org/edgurgel/httpoison) [![Hex pm](http://img.shields.io/hexpm/v/httpoison.svg?style=flat)](https://hex.pm/packages/httpoison) [![hex.pm downloads](https://img.shields.io/hexpm/dt/httpoison.svg?style=flat)](https://hex.pm/packages/httpoison)\n\nHTTP client for Elixir, based on\n[HTTPotion](https://github.com/myfreeweb/httpotion)\n([documentation](http://hexdocs.pm/httpoison/)).\n\n## But... why something so similar to HTTPotion?\n\nHTTPoison uses [hackney](https://github.com/benoitc/hackney) to execute HTTP requests instead of ibrowse. I like hackney :thumbsup:\n\nUsing hackney we work only with binaries instead of string lists.\n\n## Installation\n\nFirst, add HTTPoison to your `mix.exs` dependencies:\n\n```elixir\ndef deps do\n  [\n    {:httpoison, "~> 1.6"}\n  ]\nend\n```\n\nand run `$ mix deps.get`. Add `:httpoison` to your applications list if your Elixir version is 1.3 or lower:\n\n```elixir\ndef application do\n  [applications: [:httpoison]]\nend\n```\n\n## Usage\n\n```elixir\niex> HTTPoison.start\niex> HTTPoison.get! "http://httparrot.herokuapp.com/get"\n%HTTPoison.Response{\n  body: "{\\n  \\"args\\": {},\\n  \\"headers\\": {} ...",\n  headers: [{"Connection", "keep-alive"}, {"Server", "Cowboy"},\n  {"Date", "Sat, 06 Jun 2015 03:52:13 GMT"}, {"Content-Length", "495"},\n  {"Content-Type", "application/json"}, {"Via", "1.1 vegur"}],\n  status_code: 200\n}\niex> HTTPoison.get! "http://localhost:1"\n** (HTTPoison.Error) :econnrefused\niex> HTTPoison.get "http://localhost:1"\n{:error, %HTTPoison.Error{id: nil, reason: :econnrefused}}\n\niex> HTTPoison.post "http://httparrot.herokuapp.com/post", "{\\"body\\": \\"test\\"}", [{"Content-Type", "application/json"}]\n{:ok, %HTTPoison.Response{body: "{\\n  \\"args\\": {},\\n  \\"headers\\": {\\n    \\"host\\": \\"httparrot.herokuapp.com\\",\\n    \\"connection\\": \\"close\\",\\n    \\"accept\\": \\"application/json\\",\\n    \\"content-type\\": \\"application/json\\",\\n    \\"user-agent\\": \\"hackney/1.6.1\\",\\n    \\"x-request-id\\": \\"4b85de44-6227-4480-b506-e3b9b4f0318a\\",\\n    \\"x-forwarded-for\\": \\"76.174.231.199\\",\\n    \\"x-forwarded-proto\\": \\"http\\",\\n    \\"x-forwarded-port\\": \\"80\\",\\n    \\"via\\": \\"1.1 vegur\\",\\n    \\"connect-time\\": \\"1\\",\\n    \\"x-request-start\\": \\"1475945832992\\",\\n    \\"total-route-time\\": \\"0\\",\\n    \\"content-length\\": \\"16\\"\\n  },\\n  \\"url\\": \\"http://httparrot.herokuapp.com/post\\",\\n  \\"origin\\": \\"10.180.37.142\\",\\n  \\"form\\": {},\\n  \\"data\\": \\"{\\\\\\"body\\\\\\": \\\\\\"test\\\\\\"}\\",\\n  \\"json\\": {\\n    \\"body\\": \\"test\\"\\n  }\\n}",\n    headers: [{"Connection", "keep-alive"}, {"Server", "Cowboy"},\n    {"Date", "Sat, 08 Oct 2016 16:57:12 GMT"}, {"Content-Length", "681"},\n    {"Content-Type", "application/json"}, {"Via", "1.1 vegur"}],\nstatus_code: 200}}\n```\n\nYou can also easily pattern match on the `HTTPoison.Response` struct:\n\n```elixir\ncase HTTPoison.get(url) do\n  {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->\n    IO.puts body\n  {:ok, %HTTPoison.Response{status_code: 404}} ->\n    IO.puts "Not found :("\n  {:error, %HTTPoison.Error{reason: reason}} ->\n    IO.inspect reason\nend\n```\n### Options\n\nThere are a number of supported options(*not to be confused with the HTTP options method*), documented [here](https://hexdocs.pm/httpoison/HTTPoison.html#request/5), that can be added to your request. The example below shows the use of the `:ssl` and `:recv_timeout` options for a post request to an api that requires a bearer token. The `:ssl` option allows you to set options accepted by the [Erlang SSL module](http://erlang.org/doc/man/ssl.html), and `:recv_timeout` sets a timeout on receiving a response, the default is 5000ms.\n\n```elixir\ntoken = "some_token_from_another_request"\nurl = "https://example.com/api/endpoint_that_needs_a_bearer_token"\nheaders = ["Authorization": "Bearer #{token}", "Accept": "Application/json; Charset=utf-8"]\noptions = [ssl: [{:versions, [:\'tlsv1.2\']}], recv_timeout: 500]\n{:ok, response} = HTTPoison.get(url, headers, options)\n```\n\nAnd the example below shows the use of the `:ssl` options for a post request to an api that requires a client certification.\n\n```elixir\nurl = "https://example.org/api/endpoint_that_needs_client_cert"\noptions = [ssl: [certfile: "certs/client.crt"]]\n{:ok, response} = HTTPoison.post(url, [], options)\n```\n\n### Wrapping `HTTPoison.Base`\n\nYou can also use the `HTTPoison.Base` module in your modules in order to make\ncool API clients or something. The following example wraps `HTTPoison.Base` in\norder to build a client for the GitHub API\n([Poison](https://github.com/devinus/poison) is used for JSON decoding):\n\n```elixir\ndefmodule GitHub do\n  use HTTPoison.Base\n\n  @expected_fields ~w(\n    login id avatar_url gravatar_id url html_url followers_url\n    following_url gists_url starred_url subscriptions_url\n    organizations_url repos_url events_url received_events_url type\n    site_admin name company blog location email hireable bio\n    public_repos public_gists followers following created_at updated_at\n  )\n\n  def process_request_url(url) do\n    "https://api.github.com" <> url\n  end\n\n  def process_response_body(body) do\n    body\n    |> Poison.decode!\n    |> Map.take(@expected_fields)\n    |> Enum.map(fn({k, v}) -> {String.to_atom(k), v} end)\n  end\nend\n```\n\n```elixir\niex> GitHub.start\niex> GitHub.get!("/users/myfreeweb").body[:public_repos]\n37\n```\n\nIt\'s possible to extend the functions listed below:\n\n```elixir\ndef process_request_body(body), do: body\n\ndef process_request_headers(headers) when is_map(headers) do\n  Enum.into(headers, [])\nend\n\ndef process_request_headers(headers), do: headers\n\ndef process_request_options(options), do: options\n\ndef process_request_url(url), do: url\n\ndef process_response_body(body), do: body\n\ndef process_response_chunk(chunk), do: chunk\n\ndef process_response_headers(headers), do: headers\n\ndef process_response_status_code(status_code), do: status_code\n```\n\n### Async requests\n\nHTTPoison now comes with async requests!\n\n```elixir\niex> HTTPoison.get! "https://github.com/", %{}, stream_to: self\n%HTTPoison.AsyncResponse{id: #Reference<0.0.0.1654>}\niex> flush\n%HTTPoison.AsyncStatus{code: 200, id: #Reference<0.0.0.1654>}\n%HTTPoison.AsyncHeaders{headers: %{"Connection" => "keep-alive", ...}, id: #Reference<0.0.0.1654>}\n%HTTPoison.AsyncChunk{chunk: "<!DOCTYPE html>...", id: #Reference<0.0.0.1654>}\n%HTTPoison.AsyncEnd{id: #Reference<0.0.0.1654>}\n:ok\n```\n\n**Warning: this option can flood a receiver in messages.**\n\nIf a server may send very large messages the `async: :once` option should be used.\nThis will send only a single chunk at a time the receiver can call `HTTPoison.stream_next/1` to indicate ability to process more chunks.\n\n### Cookies\n\nHTTPoison allows you to send cookies:\n\n```elixir\niex> HTTPoison.get!("http://httparrot.herokuapp.com/cookies", %{}, hackney: [cookie: ["session=a933ec1dd923b874e691; logged_in=true"]])\n%HTTPoison.Response{body: "{\\n  \\"cookies\\": {\\n    \\"session\\": \\"a933ec1dd923b874e691\\",\\n    \\"logged_in\\": \\"true\\"\\n  }\\n}",\n headers: [{"Connection", "keep-alive"}, ...],\n status_code: 200}\n```\n\nYou can also receive cookies from the server by reading the `"set-cookie"` headers in the response:\n\n```elixir\niex(1)> response = HTTPoison.get!("http://httparrot.herokuapp.com/cookies/set?foo=1")\niex(2)> cookies = Enum.filter(response.headers, fn\n...(2)> {key, _} -> String.match?(key, ~r/\\Aset-cookie\\z/i)\n...(2)> end)\n[{"Set-Cookie", "foo=1; Version=1; Path=/"}]\n```\n\nYou can see more usage examples in the test files (located in the\n[`test/`](test)) directory.\n\n### Connection Pools\n\nNormally **hackney** [opens and closes connections on demand](https://github.com/benoitc/hackney#reuse-a-connection), but it also creates a [default pool](https://github.com/benoitc/hackney#use-the-default-pool) of connections which are reused for requests to the same host. If the connection and host support keepalive, the connection is kept open until explicitly closed.\n\nTo use the default pool, you can just declare it as an option:\n\n```elixir\nHTTPoison.get("httpbin.org/get", [], hackney: [pool: :default])\n```\n\nIt is possible to use different pools for different purposes when a more fine grained allocation of resources is necessary.\n\n#### Simple pool declaration\n\nThe easiest way is to just pass the name of the pool, and hackney will create it if it doesn\'t exist. Pools are independent from each other (they won\'t compete for connections) and are created with the default configuration.\n\n```elixir\nHTTPoison.get("httpbin.org/get", [], hackney: [pool: :first_pool])\nHTTPoison.get("httpbin.org/get", [], hackney: [pool: :second_pool])\n```\n\n#### Explicit pool creation\n\nIf you want to use different configuration options you can create a pool manually [when your app starts](http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html#the-application-callback) with `:hackney_pool.start_pool/2`.\n\n```elixir\n:ok = :hackney_pool.start_pool(:first_pool, [timeout: 15000, max_connections: 100])\n```\n\nFrom the already linked [hackney\'s readme](https://github.com/benoitc/hackney#use-the-default-pool):\n\n> `timeout` is the time we keep the connection alive in the pool, `max_connections` is the number of connections maintained in the pool. Each connection in a pool is monitored and closed connections are removed automatically.\n\n#### Pools as supervised processes\n\nA third option is to add the pool as part of your supervision tree:\n\n```elixir\nchildren = [\n  :hackney_pool.child_spec(:first_pool, [timeout: 15000, max_connections: 100])\n]\n```\n\nAdd that to the application supervisor and `first_pool` will be available to be used by HTTPoison/hackney.\n\n### Multipart\n\n#### Request\n\nHTTPoison supports making `multipart` requests. E.g.:\n\n```elixir\nHTTPoison.post("https://myurl.php", {:multipart, [{:file, "test.txt", {"form-data", [{"name", "mytest"}, {"filename", "test.txt"}]}, []}]})\n```\n\nFurther examples of `multipart` requests can be found [in the issues](https://github.com/edgurgel/httpoison/issues?utf8=%E2%9C%93&q=is%3Aissue+multipart) (e.g.: [here](https://github.com/edgurgel/httpoison/issues/144#issue-160035453) and [here](https://github.com/edgurgel/httpoison/issues/237#issuecomment-313132804)).\n\nFor more complex queries regarding multipart requests, you should follow the [hackney docs for the `multipart` API](https://github.com/benoitc/hackney#send-a-body).\n\n#### Response\n\nHTTPoison supports parsing `multipart` responses. E.g.:\n\n```elixir\niex(1)> response = %HTTPoison.Response{\n...(1)>   body: "--123\\r\\nContent-type: application/json\\r\\n\\r\\n{\\"1\\": \\"first\\"}\\r\\n--123\\r\\nContent-type: application/json\\r\\n\\r\\n{\\"2\\": \\"second\\"}\\r\\n--123--\\r\\n",\n...(1)>   headers: [{"Content-Type", "multipart/mixed;boundary=123"}],\n...(1)>   request_url: "http://localhost",\n...(1)>   status_code: 200\n...(1)> }\n%HTTPoison.Response{\n  body: "--123\\r\\nContent-type: application/json\\r\\n\\r\\n{\\"1\\": \\"first\\"}\\r\\n--123\\r\\nContent-type: application/json\\r\\n\\r\\n{\\"2\\": \\"second\\"}\\r\\n--123--\\r\\n",\n  headers: [{"Content-Type", "multipart/mixed;boundary=123"}],\n  request_url: "http://localhost",\n  status_code: 200\n}\n\niex(2)> HTTPoison.Handlers.Multipart.decode_body(response)\n[\n  {[{"Content-Type", "application/json"}], "{\\"1\\": \\"first\\"}"},\n  {[{"Content-Type", "application/json"}], "{\\"2\\": \\"second\\"}"}\n]\n```\n\nFor more complex queries regarding multipart response parsing, you should follow the [hackney docs for the `hackney_multipart` API](https://github.com/benoitc/hackney/blob/master/doc/hackney_multipart.md).\n\n## License\n\n    Copyright \xc2\xa9 2013-2019 Eduardo Gurgel <eduardo@gurgel.me>\n\n    This work is free. You can redistribute it and/or modify it under the\n    terms of the MIT License. See the LICENSE file for more details.\n'