b'# Tesla\n\n[![Build Status](https://github.com/teamon/tesla/workflows/Test/badge.svg)](https://github.com/teamon/tesla/actions)\n[![Hex.pm](https://img.shields.io/hexpm/v/tesla.svg)](http://hex.pm/packages/tesla)\n[![Hex.pm](https://img.shields.io/hexpm/dt/tesla.svg)](https://hex.pm/packages/tesla)\n[![Hex.pm](https://img.shields.io/hexpm/dw/tesla.svg)](https://hex.pm/packages/tesla)\n[![codecov](https://codecov.io/gh/teamon/tesla/branch/master/graph/badge.svg)](https://codecov.io/gh/teamon/tesla)\n[![Inline docs](https://inch-ci.org/github/teamon/tesla.svg)](http://inch-ci.org/github/teamon/tesla)\n\nTesla is an HTTP client loosely based on [Faraday](https://github.com/lostisland/faraday).\nIt embraces the concept of middleware when processing the request/response cycle.\n\n> Note that this README refers to the `master` branch of Tesla, not the latest\n  released version on Hex. See [the documentation](http://hexdocs.pm/tesla) for\n  the documentation of the version you\'re using.\n\n---\n\n## [`0.x` to `1.0` Migration Guide](https://github.com/teamon/tesla/wiki/0.x-to-1.0-Migration-Guide)\n\n```elixir\ndefp deps do\n  [{:tesla, "~> 1.3.0"}]\nend\n```\n\n[Documentation for 0.x branch](https://github.com/teamon/tesla/tree/0.x)\n\n---\n\n## HTTP Client example\n\nDefine module with `use Tesla` and choose from a variety of middleware.\n\n```elixir\ndefmodule GitHub do\n  use Tesla\n\n  plug Tesla.Middleware.BaseUrl, "https://api.github.com"\n  plug Tesla.Middleware.Headers, [{"authorization", "token xyz"}]\n  plug Tesla.Middleware.JSON\n\n  def user_repos(login) do\n    get("/user/" <> login <> "/repos")\n  end\nend\n```\n\nThen use it like this:\n\n```elixir\n{:ok, response} = GitHub.user_repos("teamon")\n\nresponse.status\n# => 200\n\nresponse.body\n# => [%{\xe2\x80\xa6}, \xe2\x80\xa6]\n\nresponse.headers\n# => [{"content-type", "application/json"}, ...]\n```\n\nSee below for documentation.\n\n## Installation\n\nAdd `tesla` as dependency in `mix.exs`:\n\n```elixir\ndefp deps do\n  [\n    {:tesla, "~> 1.3.0"},\n\n    # optional, but recommended adapter\n    {:hackney, "~> 1.14.0"},\n\n    # optional, required by JSON middleware\n    {:jason, ">= 1.0.0"}\n  ]\nend\n\n```\n\nConfigure default adapter in `config/config.exs` (optional).\n\n```elixir\n# config/config.exs\n\nconfig :tesla, adapter: Tesla.Adapter.Hackney\n```\n\n> The default adapter is erlang\'s built-in `httpc`, but it is not recommended\nto use it in production environment as it does not validate SSL certificates\n[among other issues](https://github.com/teamon/tesla/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Ahttpc+).\n\n## Documentation\n\n- [Middleware](#middleware)\n- [Runtime middleware](#runtime-middleware)\n- [Adapters](#adapters)\n- [Streaming](#streaming)\n- [Multipart](#multipart)\n- [Testing](#testing)\n- [Writing middleware](#writing-middleware)\n- [Direct usage](#direct-usage)\n- [Cheatsheet](#cheatsheet)\n- [Cookbook](https://github.com/teamon/tesla/wiki)\n- [Changelog](https://github.com/teamon/tesla/releases)\n\n## Middleware\n\nTesla is built around the concept of composable middlewares.\nThis is very similar to how [Plug Router](https://github.com/elixir-plug/plug#the-plug-router) works.\n\n### Basic\n\n- [`Tesla.Middleware.BaseUrl`](https://hexdocs.pm/tesla/Tesla.Middleware.BaseUrl.html) - set base url\n- [`Tesla.Middleware.Headers`](https://hexdocs.pm/tesla/Tesla.Middleware.Headers.html) - set request headers\n- [`Tesla.Middleware.Query`](https://hexdocs.pm/tesla/Tesla.Middleware.Query.html) - set query parameters\n- [`Tesla.Middleware.Opts`](https://hexdocs.pm/tesla/Tesla.Middleware.Opts.html) - set request options\n- [`Tesla.Middleware.FollowRedirects`](https://hexdocs.pm/tesla/Tesla.Middleware.FollowRedirects.html) - follow 3xx redirects\n- [`Tesla.Middleware.MethodOverride`](https://hexdocs.pm/tesla/Tesla.Middleware.MethodOverride.html) - set X-Http-Method-Override\n- [`Tesla.Middleware.Logger`](https://hexdocs.pm/tesla/Tesla.Middleware.Logger.html) - log requests (method, url, status, time)\n- [`Tesla.Middleware.KeepRequest`](https://hexdocs.pm/tesla/Tesla.Middleware.KeepRequest.html) - keep request body & headers\n- [`Tesla.Middleware.PathParams`](https://hexdocs.pm/tesla/Tesla.Middleware.PathParams.html) - use templated URLs\n\n### Formats\n\n- [`Tesla.Middleware.FormUrlencoded`](https://hexdocs.pm/tesla/Tesla.Middleware.FormUrlencoded.html) - urlencode POST body, useful for POSTing a map/keyword list\n- [`Tesla.Middleware.JSON`](https://hexdocs.pm/tesla/Tesla.Middleware.JSON.html) - JSON request/response body\n- [`Tesla.Middleware.Compression`](https://hexdocs.pm/tesla/Tesla.Middleware.Compression.html) - gzip & deflate\n- [`Tesla.Middleware.DecodeRels`](https://hexdocs.pm/tesla/Tesla.Middleware.DecodeRels.html) - decode `Link` header into `opts[:rels]` field in response\n\n### Auth\n\n- [`Tesla.Middleware.BasicAuth`](https://hexdocs.pm/tesla/Tesla.Middleware.BasicAuth.html) - HTTP Basic Auth\n- [`Tesla.Middleware.DigestAuth`](https://hexdocs.pm/tesla/Tesla.Middleware.DigestAuth.html) - Digest access authentication\n\n### Error handling\n\n- [`Tesla.Middleware.Timeout`](https://hexdocs.pm/tesla/Tesla.Middleware.Timeout.html) - timeout request after X milliseconds despite of server response\n- [`Tesla.Middleware.Retry`](https://hexdocs.pm/tesla/Tesla.Middleware.Retry.html) - retry few times in case of connection refused\n- [`Tesla.Middleware.Fuse`](https://hexdocs.pm/tesla/Tesla.Middleware.Fuse.html) - fuse circuit breaker integration\n\n## Runtime middleware\n\nAll HTTP functions (`get`, `post`, etc.) can take a dynamic client as the first argument.\nThis allow to use convenient syntax for modifying the behaviour in runtime.\n\nConsider the following case: GitHub API can be accessed using OAuth token authorization.\n\nWe can\'t use `plug Tesla.Middleware.Headers, [{"authorization", "token here"}]`\nsince this would be compiled only once and there is no way to insert dynamic user token.\n\nInstead, we can use `Tesla.client` to create a client with dynamic middleware:\n\n```elixir\ndefmodule GitHub do\n  # notice there is no `use Tesla`\n\n  def user_repos(client, login) do\n    # pass `client` argument to `Tesla.get` function\n    Tesla.get(client, "/user/" <> login <> "/repos")\n  end\n\n  def issues(client) do\n    Tesla.get(client, "/issues")\n  end\n\n  # build dynamic client based on runtime arguments\n  def client(token) do\n    middleware = [\n      {Tesla.Middleware.BaseUrl, "https://api.github.com"},\n      Tesla.Middleware.JSON,\n      {Tesla.Middleware.Headers, [{"authorization", "token: " <> token }]}\n    ]\n\n    Tesla.client(middleware)\n  end\nend\n```\n\nand then:\n\n```elixir\nclient = GitHub.client(user_token)\nclient |> GitHub.user_repos("teamon")\nclient |> GitHub.get("/me")\n```\n\n## Adapters\n\nTesla supports multiple HTTP adapter that do the actual HTTP request processing.\n\n- [`Tesla.Adapter.Httpc`](https://hexdocs.pm/tesla/Tesla.Adapter.Httpc.html) - the default, built-in erlang [httpc](http://erlang.org/doc/man/httpc.html) adapter\n- [`Tesla.Adapter.Hackney`](https://hexdocs.pm/tesla/Tesla.Adapter.Hackney.html) - [hackney](https://github.com/benoitc/hackney), "simple HTTP client in Erlang"\n- [`Tesla.Adapter.Ibrowse`](https://hexdocs.pm/tesla/Tesla.Adapter.Ibrowse.html) - [ibrowse](https://github.com/cmullaparthi/ibrowse), "Erlang HTTP client"\n- [`Tesla.Adapter.Gun`](https://hexdocs.pm/tesla/Tesla.Adapter.Gun.html) - [gun](https://github.com/ninenines/gun), "HTTP/1.1, HTTP/2 and Websocket client for Erlang/OTP"\n- [`Tesla.Adapter.Mint`](https://hexdocs.pm/tesla/Tesla.Adapter.Mint.html) - [mint](https://github.com/elixir-mint/mint), "Functional HTTP client for Elixir with support for HTTP/1 and HTTP/2"\n\nWhen using adapter other than httpc remember to add it to the dependencies list in `mix.exs`\n\n```elixir\ndefp deps do\n  [{:tesla, "~> 1.3.0"},\n   {:jason, ">= 1.0.0"}, # optional, required by JSON middleware\n   {:hackney, "~> 1.10"}] # or :gun etc.\nend\n```\n\n### Adapter options\n\nIn case there is a need to pass specific adapter options you can do it in one of three ways:\n\nUsing `adapter` macro:\n\n```elixir\ndefmodule GitHub do\n  use Tesla\n\n  adapter Tesla.Adapter.Hackney, recv_timeout: 30_000, ssl_options: [certfile: "certs/client.crt"]\nend\n```\n\nUsing `Tesla.client/2`:\n\n```elixir\ndef new(...) do\n  middleware = [...]\n  adapter = {Tesla.Adapter.Hackney, [recv_timeout: 30_000]}\n  Tesla.client(middleware, adapter)\nend\n```\n\nPassing directly to `get`/`post`/etc.\n\n```elixir\nMyClient.get("/", opts: [adapter: [recv_timeout: 30_000]])\nTesla.get(client, "/", opts: [adapter: [recv_timeout: 30_000]])\n```\n\n## Streaming\n\nIf adapter supports it, you can pass a [Stream](http://elixir-lang.org/docs/stable/elixir/Stream.html) as body, e.g.:\n\n```elixir\ndefmodule ElasticSearch do\n  use Tesla\n\n  plug Tesla.Middleware.BaseUrl, "http://localhost:9200"\n  plug Tesla.Middleware.JSON\n\n  def index(records_stream) do\n    stream = records_stream |> Stream.map(fn record -> %{index: [some, data]} end)\n    post("/_bulk", stream)\n  end\nend\n```\n\nEach piece of stream will be encoded as JSON and sent as a new line (conforming to JSON stream format)\n\n## Multipart\n\nYou can pass a `Tesla.Multipart` struct as the body.\n\n```elixir\nalias Tesla.Multipart\n\nmp =\n  Multipart.new()\n  |> Multipart.add_content_type_param("charset=utf-8")\n  |> Multipart.add_field("field1", "foo")\n  |> Multipart.add_field("field2", "bar",\n    headers: [{"content-id", "1"}, {"content-type", "text/plain"}]\n  )\n  |> Multipart.add_file("test/tesla/multipart_test_file.sh")\n  |> Multipart.add_file("test/tesla/multipart_test_file.sh", name: "foobar")\n  |> Multipart.add_file_content("sample file content", "sample.txt")\n\n{:ok, response} = MyApiClient.post("http://httpbin.org/post", mp)\n```\n\n## Testing\n\nYou can set the adapter to `Tesla.Mock` in tests.\n\n```elixir\n# config/test.exs\n# Use mock adapter for all clients\nconfig :tesla, adapter: Tesla.Mock\n# or only for one\nconfig :tesla, MyApi, adapter: Tesla.Mock\n```\n\nThen, mock requests before using your client:\n\n```elixir\ndefmodule MyAppTest do\n  use ExUnit.Case\n\n  import Tesla.Mock\n\n  setup do\n    mock(fn\n      %{method: :get, url: "http://example.com/hello"} ->\n        %Tesla.Env{status: 200, body: "hello"}\n\n      %{method: :post, url: "http://example.com/world"} ->\n        json(%{"my" => "data"})\n    end)\n\n    :ok\n  end\n\n  test "list things" do\n    assert {:ok, %Tesla.Env{} = env} = MyApp.get("/hello")\n    assert env.status == 200\n    assert env.body == "hello"\n  end\nend\n```\n\n## Writing middleware\n\nA Tesla middleware is a module with `c:Tesla.Middleware.call/3` function, that at some point calls `Tesla.run/2` with `env` and `next` to process\nthe rest of stack.\n\n```elixir\ndefmodule MyMiddleware do\n  @behaviour Tesla.Middleware\n\n  def call(env, next, options) do\n    env\n    |> do_something_with_request()\n    |> Tesla.run(next)\n    |> do_something_with_response()\n  end\nend\n```\n\nThe arguments are:\n\n- `env` - `Tesla.Env` instance\n- `next` - middleware continuation stack; to be executed with `Tesla.run/2` with `env` and `next`\n- `options` - arguments passed during middleware configuration (`plug MyMiddleware, options`)\n\nThere is no distinction between request and response middleware, it\'s all about executing `Tesla.run/2` function at the correct time.\n\nFor example, a request logger middleware could be implemented like this:\n\n```elixir\ndefmodule Tesla.Middleware.RequestLogger do\n  @behaviour Tesla.Middleware\n\n  def call(env, next, _) do\n    env\n    |> IO.inspect()\n    |> Tesla.run(next)\n  end\nend\n```\n\nand response logger middleware like this:\n\n```elixir\ndefmodule Tesla.Middleware.ResponseLogger do\n  @behaviour Tesla.Middleware\n\n  def call(env, next, _) do\n    env\n    |> Tesla.run(next)\n    |> IO.inspect()\n  end\nend\n```\n\nSee [built-in middlewares](https://github.com/teamon/tesla/tree/master/lib/tesla/middleware) for more examples.\n\nMiddleware should have documentation following this template:\n\n````elixir\ndefmodule Tesla.Middleware.SomeMiddleware do\n  @moduledoc """\n  Short description what it does\n\n  Longer description, including e.g. additional dependencies.\n\n\n  ### Example usage\n\n  ```\n  defmodule MyClient do\n    use Tesla\n\n    plug Tesla.Middleware.SomeMiddleware, most: :common, options: "here"\n  end\n  ```\n\n  ### Options\n\n  - `:list` - all possible options\n  - `:with` - their default values\n  """\n\n  @behaviour Tesla.Middleware\nend\n````\n\n## Direct usage\n\nYou can also use Tesla directly, without creating a client module.\nThis however won\xe2\x80\x99t include any middleware.\n\n```elixir\n# Example get request\n{:ok, response} = Tesla.get("http://httpbin.org/ip")\n\nresponse.status\n# => 200\n\nresponse.body\n# => "{\\n  "origin": "87.205.72.203"\\n}\\n"\n\nresponse.headers\n# => [{"content-type", "application/json" ...}]\n\n{:ok, response} = Tesla.get("http://httpbin.org/get", query: [a: 1, b: "foo"])\n\nresponse.url\n# => "http://httpbin.org/get?a=1&b=foo"\n\n# Example post request\n{:ok, response} =\n  Tesla.post("http://httpbin.org/post", "data", headers: [{"content-type", "application/json"}])\n```\n\n## Cheatsheet\n\n### Making requests 101\n\n```elixir\n# GET /path\nget("/path")\n\n# GET /path?a=hi&b[]=1&b[]=2&b[]=3\nget("/path", query: [a: "hi", b: [1, 2, 3]])\n\n# GET with dynamic client\nget(client, "/path")\nget(client, "/path", query: [page: 3])\n\n# arguments are the same for GET, HEAD, OPTIONS & TRACE\nhead("/path")\noptions("/path")\ntrace("/path")\n\n# POST, PUT, PATCH\npost("/path", "some-body-i-used-to-know")\nput("/path", "some-body-i-used-to-know", query: [a: "0"])\npatch("/path", multipart)\n```\n\n### Configuring HTTP functions visibility\n\n```elixir\n# generate only get and post function\nuse Tesla, only: ~w(get post)a\n\n# generate only delete function\nuse Tesla, only: [:delete]\n\n# generate all functions except delete and options\nuse Tesla, except: [:delete, :options]\n```\n\n### Disable docs for HTTP functions\n\n```elixir\nuse Tesla, docs: false\n```\n\n### Decode only JSON response (do not encode request)\n\n```elixir\nplug Tesla.Middleware.DecodeJson\n```\n\n### Use other JSON library\n\n```elixir\n# use JSX\nplug Tesla.Middleware.JSON, engine: JSX, engine_opts: [strict: [:comments]]\n\n# use custom functions\nplug Tesla.Middleware.JSON, decode: &JSX.decode/1, encode: &JSX.encode/1\n```\n\n### Custom middleware\n\n```elixir\ndefmodule Tesla.Middleware.MyCustomMiddleware do\n  def call(env, next, options) do\n    env\n    |> do_something_with_request()\n    |> Tesla.run(next)\n    |> do_something_with_response()\n  end\nend\n```\n\n## Contributing\n\n1. Fork it (https://github.com/teamon/tesla/fork)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am \'Add some feature\'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create new Pull Request\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details\n\nCopyright (c) 2015-2018 [Tymon Tobolski](http://teamon.eu/about/)\n'