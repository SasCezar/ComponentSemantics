b'[![Hex.pm Version](http://img.shields.io/hexpm/v/libcluster.svg?style=flat)](https://hex.pm/packages/libcluster)\n[![Build Status](https://travis-ci.org/bitwalker/libcluster.svg?branch=master)](https://travis-ci.org/bitwalker/libcluster)\n\nThis library provides a mechanism for automatically forming clusters of Erlang nodes, with\neither static or dynamic node membership. It provides a publish/subscribe mechanism for cluster\nevents so that you can easily be notified when cluster members join or leave, and provides a\npluggable "strategy" system, with a variety of strategies provided out of the\nbox.\n\nYou can find supporting documentation [here](https://hexdocs.pm/libcluster).\n\n## Features\n\n- Automatic cluster formation/healing\n- Choice of multiple clustering strategies out of the box:\n  - Standard Distributed Erlang facilities (e.g. `epmd`, `.hosts.erlang`), which supports IP-based or DNS-based names\n  - Multicast UDP gossip, using a configurable port/multicast address,\n  - Kubernetes via its metadata API using via a configurable label selector and\n    node basename; or alternatively, using DNS.\n  - Rancher, via its [metadata API][rancher-api]\n- Easy to provide your own custom clustering strategies for your specific environment.\n- Easy to use provide your own distribution plumbing (i.e. something other than\n  Distributed Erlang), by implementing a small set of callbacks. This allows\n  `libcluster` to support projects like\n  [Partisan](https://github.com/lasp-lang/partisan).\n\n## Installation\n\n```elixir\ndefp deps do\n  [{:libcluster, "~> MAJ.MIN"}]\nend\n```\n\nYou can determine the latest version by running `mix hex.info libcluster` in\nyour shell, or by going to the `libcluster` [page on Hex.pm](https://hex.pm/packages/libcluster).\n\n## Usage\n\nIt is easy to get started using `libcluster`, simply decide which strategy you\nwant to use to form a cluster, define a topology, and then start the `Cluster.Supervisor` module in\nthe supervision tree of an application in your Elixir system, as demonstrated below:\n\n```elixir\ndefmodule MyApp.App do\n  use Application\n\n  def start(_type, _args) do\n    topologies = [\n      example: [\n        strategy: Cluster.Strategy.Epmd,\n        config: [hosts: [:"a@127.0.0.1", :"b@127.0.0.1"]],\n      ]\n    ]\n    children = [\n      {Cluster.Supervisor, [topologies, [name: MyApp.ClusterSupervisor]]},\n      # ..other children..\n    ]\n    Supervisor.start_link(children, strategy: :one_for_one, name: MyApp.Supervisor)\n  end\nend\n```\n\nThe following section describes topology configuration in more detail.\n\n## Example Configuration\n\nYou can configure `libcluster` either in your Mix config file (`config.exs`) as\nshown below, or construct the keyword list structure manually, as shown in the\nprevious section. Either way, you need to pass the configuration to the\n`Cluster.Supervisor` module in it\'s start arguments. If you prefer to use Mix\nconfig files, then simply use `Application.get_env(:libcluster, :topologies)` to\nget the config that `Cluster.Supervisor` expects.\n\n```elixir\nconfig :libcluster,\n  topologies: [\n    example: [\n      # The selected clustering strategy. Required.\n      strategy: Cluster.Strategy.Epmd,\n      # Configuration for the provided strategy. Optional.\n      config: [hosts: [:"a@127.0.0.1", :"b@127.0.0.1"]],\n      # The function to use for connecting nodes. The node\n      # name will be appended to the argument list. Optional\n      connect: {:net_kernel, :connect_node, []},\n      # The function to use for disconnecting nodes. The node\n      # name will be appended to the argument list. Optional\n      disconnect: {:erlang, :disconnect_node, []},\n      # The function to use for listing nodes.\n      # This function must return a list of node names. Optional\n      list_nodes: {:erlang, :nodes, [:connected]},\n    ]\n  ]\n```\n\n## Strategy Configuration\n\nFor instructions on configuring each strategy included with `libcluster`, please\nvisit the docs on [HexDocs](https://hexdocs.pm/libcluster), and look at the\nmodule doc for the strategy you want to use. The authoritative documentation for\neach strategy is kept up to date with the module implementing it.\n\n## Clustering\n\nYou have a handful of choices with regards to cluster management out of the box: \n\n- `Cluster.Strategy.Epmd`, which relies on `epmd` to connect to a configured set of hosts.\n- `Cluster.Strategy.ErlangHosts`, which uses the `.hosts.erlang` file to\n  determine which hosts to connect to.\n- `Cluster.Strategy.Gossip`, which uses multicast UDP to form a cluster between\n  nodes gossiping a heartbeat.\n- `Cluster.Strategy.Kubernetes`, which uses the Kubernetes Metadata API to query\n  nodes based on a label selector and basename.\n- `Cluster.Strategy.Kubernetes.DNS`, which uses DNS to join nodes under a shared\n  headless service in a given namespace.\n- `Cluster.Strategy.Rancher`, which like the Kubernetes strategy, uses a\n  metadata API to query nodes to cluster with.\n\nYou can also define your own strategy implementation, by implementing the\n`Cluster.Strategy` behavior. This behavior expects you to implement a\n`start_link/1` callback, optionally overriding `child_spec/1` if needed. You don\'t necessarily have\nto start a process as part of your strategy, but since it\'s very likely you will need to maintain some state, designing your\nstrategy as an OTP process (e.g. `GenServer`) is the ideal method, however any\nvalid OTP process will work. See the `Cluster.Strategy` module for details on\nthe callbacks you need to implement and the arguments they receive.\n\nIf you do not wish to use the default Erlang distribution protocol, you may provide an alternative means of connecting/\ndisconnecting nodes via the `connect` and `disconnect` configuration options, if not using Erlang distribution you must provide a `list_nodes` implementation as well.\nThey take a `{module, fun, args}` tuple, and append the node name being targeted to the `args` list. How to implement distribution in this way is left as an\nexercise for the reader, but I recommend taking a look at the [Firenest](https://github.com/phoenixframework/firenest) project\ncurrently under development. By default, `libcluster` uses Distributed Erlang.\n\n### Third-Party Strategies\n\nThe following list of third-party strategy implementations is not comprehensive,\nbut are known to exist.\n\n- [libcluster_ec2](https://github.com/kyleaa/libcluster_ec2) - EC2 clustering strategy based on tags\n- [libcluster_consul](https://github.com/arcz/libcluster_consul) - Consul clustering strategy\n\n## License\n\nMIT\n\n[rancher-api]: http://rancher.com/docs/rancher/latest/en/rancher-services/metadata-service/\n'