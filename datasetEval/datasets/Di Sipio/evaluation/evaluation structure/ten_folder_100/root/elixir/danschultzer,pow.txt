b'# ![Pow](assets/logo-full.svg)\n\n[![Build Status](https://travis-ci.org/danschultzer/pow.svg?branch=master)](https://travis-ci.org/danschultzer/pow) [![hex.pm](http://img.shields.io/hexpm/v/pow.svg?style=flat)](https://hex.pm/packages/pow)\n\nPow is a robust, modular, and extendable authentication and user management solution for Phoenix and Plug-based apps.\n\n## Features\n\n* User registration\n* Session based authorization\n* [Per Endpoint/Plug configuration](#configuration)\n* [API token authorization](guides/api.md)\n* Mnesia cache with automatic cluster healing\n* [Multitenancy](guides/multitenancy.md)\n* [User roles](guides/user_roles.md)\n* [Extendable](#extensions)\n* I18n\n* [And more](guides/why_pow.md)\n\n## Installation\n\nAdd Pow to your list of dependencies in `mix.exs`:\n\n```elixir\ndefp deps do\n  [\n    # ...\n    {:pow, "~> 1.0.15"}\n  ]\nend\n```\n\nRun `mix deps.get` to install it.\n\n## Getting started\n\n### Phoenix app\n\n**Umbrella project**: Check out the [umbrella project guide](guides/umbrella_project.md).\n\nInstall the necessary files:\n\n```bash\nmix pow.install\n```\n\nThis will add the following files to your app:\n\n```bash\nLIB_PATH/users/user.ex\nPRIV_PATH/repo/migrations/TIMESTAMP_create_user.ex\n```\n\nAdd the following to `config/config.exs`:\n\n```elixir\nconfig :my_app, :pow,\n  user: MyApp.Users.User,\n  repo: MyApp.Repo\n```\n\nSet up `WEB_PATH/endpoint.ex` to enable session based authentication (`Pow.Plug.Session` is added after `Plug.Session`):\n\n```elixir\ndefmodule MyAppWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :my_app\n\n  # ...\n\n  plug Plug.Session,\n    store: :cookie,\n    key: "_my_app_key",\n    signing_salt: "secret"\n\n  plug Pow.Plug.Session, otp_app: :my_app\n\n  plug MyAppWeb.Phoenix.Router\nend\n```\n\nAdd Pow routes to `WEB_PATH/router.ex`:\n\n```elixir\ndefmodule MyAppWeb.Router do\n  use MyAppWeb, :router\n  use Pow.Phoenix.Router\n\n  # ... pipelines\n\n  pipeline :protected do\n    plug Pow.Plug.RequireAuthenticated,\n      error_handler: Pow.Phoenix.PlugErrorHandler\n  end\n\n  scope "/" do\n    pipe_through :browser\n\n    pow_routes()\n  end\n\n  scope "/", MyAppWeb do\n    pipe_through [:browser, :protected]\n\n    # Add your protected routes here\n  end\n\n  # ... routes\nend\n```\n\nThat\'s it! Run `mix ecto.setup` and you can now visit `http://localhost:4000/registration/new`, and create a new user.\n\n### Modify templates\n\nBy default, Pow will only expose files that are necessary.\n\nIf you wish to modify the templates, you can generate them (and the view files) using:\n\n```bash\nmix pow.phoenix.gen.templates\n```\n\nRemember to add `web_module: MyAppWeb` to the configuration so that the view you\'ve just generated will be used instead:\n\n```elixir\nconfig :my_app, :pow,\n  # ...\n  web_module: MyAppWeb\n```\n\n## Extensions\n\nPow is made so it\'s easy to extend the functionality with your own complimentary library. The following extensions are included in this library:\n\n* [PowResetPassword](lib/extensions/reset_password/README.md)\n* [PowEmailConfirmation](lib/extensions/email_confirmation/README.md)\n* [PowPersistentSession](lib/extensions/persistent_session/README.md)\n* [PowInvitation](lib/extensions/invitation/README.md)\n\nCheck out the ["Other libraries"](#other-libraries) section for other extensions.\n\n### Add extensions support\n\nTo keep it easy to understand and configure Pow, you\'ll have to enable the extensions yourself.\n\nLet\'s install the `PowResetPassword` and `PowEmailConfirmation` extensions.\n\nFirst, install extension migrations by running:\n\n```bash\nmix pow.extension.ecto.gen.migrations --extension PowResetPassword --extension PowEmailConfirmation\n```\n\nThen run the migrations with `mix ecto.migrate`. Now, update `config/config.ex` with the `:extensions` and `:controller_callbacks` key:\n\n```elixir\nconfig :my_app, :pow,\n  user: MyApp.Users.User,\n  repo: MyApp.Repo,\n  extensions: [PowResetPassword, PowEmailConfirmation],\n  controller_callbacks: Pow.Extension.Phoenix.ControllerCallbacks\n```\n\nUpdate `LIB_PATH/users/user.ex` with the extensions:\n\n```elixir\ndefmodule MyApp.Users.User do\n  use Ecto.Schema\n  use Pow.Ecto.Schema\n  use Pow.Extension.Ecto.Schema,\n    extensions: [PowResetPassword, PowEmailConfirmation]\n\n  # ...\n\n  def changeset(user_or_changeset, attrs) do\n    user_or_changeset\n    |> pow_changeset(attrs)\n    |> pow_extension_changeset(attrs)\n  end\nend\n```\n\nAdd Pow extension routes to `WEB_PATH/router.ex`:\n\n```elixir\ndefmodule MyAppWeb.Router do\n  use MyAppWeb, :router\n  use Pow.Phoenix.Router\n  use Pow.Extension.Phoenix.Router,\n    extensions: [PowResetPassword, PowEmailConfirmation]\n\n  # ...\n\n  scope "/" do\n    pipe_through :browser\n\n    pow_routes()\n    pow_extension_routes()\n  end\n\n  # ...\nend\n```\n\n#### Modify extension templates\n\nTemplates and views for extensions can be generated with:\n\n```bash\nmix pow.extension.phoenix.gen.templates --extension PowResetPassword --extension PowEmailConfirmation\n```\n\nPlease follow the instructions in ["Modify templates"](#modify-templates) to enable customization of templates and views.\n\n### Mailer support\n\nMany extensions require a mailer to have been set up. Let\'s create a mailer mock module in  `WEB_PATH/pow_mailer.ex`:\n\n```elixir\ndefmodule MyAppWeb.PowMailer do\n  use Pow.Phoenix.Mailer\n  require Logger\n\n  def cast(%{user: user, subject: subject, text: text, html: html, assigns: _assigns}) do\n    # Build email struct to be used in `process/1`\n\n    %{to: user.email, subject: subject, text: text, html: html}\n  end\n\n  def process(email) do\n    # Send email\n\n    Logger.debug("E-mail sent: #{inspect email}")\n  end\nend\n```\n\nUpdate `config/config.ex` with `:mailer_backend` key:\n\n```elixir\nconfig :my_app, :pow,\n  # ...\n  mailer_backend: MyAppWeb.PowMailer\n```\n\nThis mailer module will only output the mail to your log, so you can e.g. try out the reset password and email confirmation links. You should integrate the Pow mailer with your actual mailer system. For Swoosh or Bamboo integration, check out the [Configuring mailer guide](guides/configuring_mailer.md).\n\n#### Modify mailer templates\n\nSince Phoenix doesn\'t ship with a mailer setup by default you should first modify `my_app_web.ex` with a `:mailer_view` macro:\n\n```elixir\ndefmodule MyAppWeb do\n  # ...\n\n  def mailer_view do\n    quote do\n      use Phoenix.View, root: "lib/my_app_web/templates",\n                        namespace: MyAppWeb\n\n      use Phoenix.HTML\n    end\n  end\n\n  # ...\n\nend\n```\n\nNow generate the view and template files:\n\n```bash\nmix pow.extension.phoenix.mailer.gen.templates --extension PowResetPassword --extension PowEmailConfirmation\n```\n\nThis will generate view files in `WEB_PATH/views/mailer/`, and html and text templates in `WEB_PATH/templates/mailer` directory.\n\nAdd `web_mailer_module: MyAppWeb` to the configuration so Pow will use the views you\'ve just generated:\n\n```elixir\nconfig :my_app, :pow,\n  # ...\n  web_mailer_module: MyAppWeb\n```\n\nThe generated view files contain the subject lines for the emails.\n\n## Configuration\n\nPow is built to be modular, and easy to configure. The configuration is passed to method calls as well as plug options, and they will take priority over any environment configuration. It\'s ideal in case you got an umbrella app with multiple separate user domains.\n\nThe easiest way to use Pow with Phoenix is to use a `:otp_app` in method calls and set the app environment configuration. It will keep a persistent fallback configuration that you configure in one place.\n\n### Module groups\n\nPow has three main groups of modules that each can be used individually, or in conjunction with each other:\n\n#### Pow.Plug\n\nThis group will handle the plug connection. The configuration will be assigned to `conn.private[:pow_config]` and passed through the controller to the users\' context module. The Plug module has methods to authenticate, create, update, and delete users, and will generate/renew the session automatically.\n\n#### Pow.Ecto\n\nThis group contains all modules related to the Ecto based user schema and context. By default, Pow will use the `Pow.Ecto.Context` module to authenticate, create, update and delete users with lookups to the database. However, it\'s straightforward to extend or write your custom user context. You can do this by setting the `:users_context` configuration key.\n\n#### Pow.Phoenix\n\nThis group contains the controllers, views, and templates for Phoenix. You only need to set the (session) plug in `endpoint.ex` and add the routes to `router.ex`. Views and templates are not generated by default, instead, the compiled views and templates in Pow are used. You can generate the templates used by running `mix pow.phoenix.gen.templates`. You can also customize flash messages and callback routes by creating your own using `:messsages_backend` and `:routes_backend`.\n\nThe registration and session controllers can be changed with your customized versions too, but since the routes are built on compile time, you\'ll have to set them up in `router.ex` with `:pow` namespace. For minor pre/post-processing of requests, you can use the `:controller_callbacks` option. It exists to make it easier to modify flow with extensions (e.g., send a confirmation email upon user registration).\n\n### Pow.Extension\n\nThis module helps build extensions for Pow. There\'re three extension mix tasks to generate Ecto migrations and phoenix templates.\n\n```bash\nmix pow.extension.ecto.gen.migrations\n```\n\n```bash\nmix pow.extension.phoenix.gen.templates\n```\n\n```bash\nmix pow.extension.phoenix.mailer.gen.templates\n```\n\n### Authorization plug\n\nPow ships with a session plug module. You can easily switch it out with a different one. As an example, here\'s how you do that with `Phoenix.Token`:\n\n```elixir\ndefmodule MyAppWeb.Pow.Plug do\n  use Pow.Plug.Base\n\n  @session_key :pow_user_token\n  @salt "user salt"\n  @max_age 86400\n\n  def fetch(conn, config) do\n    conn  = Plug.Conn.fetch_session(conn)\n    token = Plug.Conn.get_session(conn, @session_key)\n\n    MyAppWeb.Endpoint\n    |> Phoenix.Token.verify(@salt, token, max_age: @max_age)\n    |> maybe_load_user(conn)\n  end\n\n  defp maybe_load_user({:ok, user_id}, conn), do: {conn, MyApp.Repo.get(User, user_id)}\n  defp maybe_load_user({:error, _any}, conn), do: {conn, nil}\n\n  def create(conn, user, config) do\n    token = Phoenix.Token.sign(MyAppWeb.Endpoint, @salt, user.id)\n    conn  =\n      conn\n      |> Plug.Conn.fetch_session()\n      |> Plug.Conn.put_session(@session_key, token)\n\n    {conn, user}\n  end\n\n  def delete(conn, config) do\n    conn\n    |> Plug.Conn.fetch_session()\n    |> Plug.Conn.delete_session(@session_key)\n  end\nend\n\ndefmodule MyAppWeb.Endpoint do\n  # ...\n\n  plug MyAppWeb.Pow.Plug, otp_app: :my_app\nend\n```\n\n### Ecto changeset\n\nThe user module has a fallback `changeset/2` method. If you want to add custom validations, you can use the `pow_changeset/2` method like so:\n\n```elixir\ndefmodule MyApp.Users.User do\n  use Ecto.Schema\n  use Pow.Ecto.Schema\n\n  schema "users" do\n    field :custom, :string\n\n    pow_user_fields()\n\n    timestamps()\n  end\n\n  def changeset(user_or_changeset, attrs) do\n    user_or_changeset\n    |> pow_changeset(attrs)\n    |> Ecto.Changeset.cast(attrs, [:custom])\n    |> Ecto.Changeset.validate_required([:custom])\n  end\nend\n```\n\n### Phoenix controllers\n\nControllers in Pow are very slim and consists of just one `Pow.Plug` method call with response methods. If you wish to change the flow of the `Pow.Phoenix.RegistrationController` and `Pow.Phoenix.SessionController`, the best way is to create your own and modify `router.ex`.\n\nHowever, to make it easier to integrate extension, you can add callbacks to the controllers that do some light pre/post-processing of the request:\n\n```elixir\ndefmodule MyCustomExtension.Phoenix.ControllerCallbacks do\n  use Pow.Extension.Phoenix.ControllerCallbacks.Base\n\n  def before_respond(Pow.Phoenix.RegistrationController, :create, {:ok, user, conn}, _config) do\n    # send email\n\n    {:ok, user, conn}\n  end\nend\n```\n\nYou can add methods for `before_process/4` (before the action happens) and `before_respond/4` (before parsing the results from the action).\n\n#### Testing with authenticated users\n\nTo test with authenticated users in your controller tests, you just have to assign the user to the conn in your setup callback:\n\n```elixir\nsetup %{conn: conn} do\n  user = %User{email: "test@example.com"}\n  conn = Pow.Plug.assign_current_user(conn, user, otp_app: :my_app)\n\n  {:ok, conn: conn}\nend\n```\n\n### I18n\n\nAll templates can be generated and modified to use your Gettext module.\n\nFor flash messages, you can create the following module:\n\n```elixir\ndefmodule MyAppWeb.Pow.Messages do\n  use Pow.Phoenix.Messages\n  use Pow.Extension.Phoenix.Messages,\n    extensions: [PowResetPassword]\n\n  import MyAppWeb.Gettext\n\n  def user_not_authenticated(_conn), do: gettext("You need to sign in to see this page.")\n\n  # Message methods for extensions has to be prepended with the snake cased\n  # extension name. So the `email_has_been_sent/1` method from\n  # `PowResetPassword` is written as `pow_reset_password_email_has_been_sent/1`\n  # in your messages module.\n  def pow_reset_password_email_has_been_sent(_conn), do: gettext("An email with reset instructions has been sent to you. Please check your inbox.")\nend\n```\n\nAdd `messages_backend: MyAppWeb.Pow.Messages` to your configuration. You can find all the messages in `Pow.Phoenix.Messages` and `[Pow Extension].Phoenix.Messages`.\n\n### Callback routes\n\nYou can customize callback routes by creating the following module:\n\n```elixir\ndefmodule MyAppWeb.Pow.Routes do\n  use Pow.Phoenix.Routes\n  alias MyAppWeb.Router.Helpers, as: Routes\n\n  def after_sign_in_path(conn), do: Routes.some_path(conn, :index)\nend\n```\n\nAdd `routes_backend: MyAppWeb.Pow.Routes` to your configuration. You can find all the routes in `Pow.Phoenix.Routes`.\n\n### Password hashing function\n\nYou can change the password hashing function easily. For example, this is how you use [comeonin with Argon2](https://github.com/riverrun/argon2_elixir):\n\n```elixir\ndefmodule MyApp.Users.User do\n  use Ecto.Schema\n  use Pow.Ecto.Schema,\n    password_hash_methods: {&Argon2.hash_pwd_salt/1,\n                            &Argon2.verify_pass/2}\n\n  # ...\nend\n```\n\n### Current user and sign out link\n\nYou can use `Pow.Plug.current_user/1` to fetch the current user from the connection.\n\nThis can be used to show sign in or sign out links in your Phoenix template:\n\n```elixir\n<%= if Pow.Plug.current_user(@conn) do %>\n  <span><%= link "Sign out", to: Routes.pow_session_path(@conn, :delete), method: :delete %></span>\n<% else %>\n  <span><%= link "Register", to: Routes.pow_registration_path(@conn, :new) %></span>\n  <span><%= link "Sign in", to: Routes.pow_session_path(@conn, :new) %></span>\n<% end %>\n```\n\nThe current user can also be fetched by using the template assigns set in the configuration with `:current_user_assigns_key` (defaults to `@current_user`).\n\n## Plugs\n\n### Pow.Plug.Session\n\nEnables session-based authorization. The user struct will be collected from a cache store through a GenServer using a unique token generated for the session. The token will be reset every time the authorization level changes (handled by `Pow.Plug`) or after a certain interval (default 15 minutes).\n\nThe user struct fetched can be out of sync with the database if the row in the database is updated by actions outside Pow. In this case it\'s recommended to [add a plug](guides/sync_user.md) that reloads the user struct and reassigns it to the connection.\n\nCustom metadata can be set for the session by assigning a private `:pow_session_metadata` key in the conn. Read the `Pow.Plug.Session` module docs for more details.\n\n#### Cache store\n\nBy default `Pow.Store.Backend.EtsCache` is started automatically and can be used in development and test environment.\n\nFor a production environment, you should use a distributed, persistent cache store. Pow makes this easy with `Pow.Store.Backend.MnesiaCache`. To start MnesiaCache in your Phoenix app, add it to your `application.ex` supervisor:\n\n```elixir\ndefmodule MyAppWeb.Application do\n  use Application\n\n  def start(_type, _args) do\n    children = [\n      MyApp.Repo,\n      MyAppWeb.Endpoint,\n      Pow.Store.Backend.MnesiaCache\n      # # Or in a distributed system:\n      # {Pow.Store.Backend.MnesiaCache, extra_db_nodes: Node.list()},\n      # Pow.Store.Backend.MnesiaCache.Unsplit # Recover from netsplit\n    ]\n\n    opts = [strategy: :one_for_one, name: MyAppWeb.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n\n  # ...\nend\n```\n\nUpdate the config `cache_store_backend: Pow.Store.Backend.MnesiaCache`.\n\nRemember to add `:mnesia` to your `:extra_applications` so it\'ll be available for your release build.\n\nThe MnesiaCache requires write access. If you\'ve a read-only file system you should take a look at the [Redis cache backend store guide](guides/redis_cache_store_backend.md).\n\n### Pow.Plug.RequireAuthenticated\n\nWill halt connection if no current user is not present in assigns. Expects an `:error_handler` option.\n\n### Pow.Plug.RequireNotAuthenticated\n\nWill halt connection if a current user is present in assigns. Expects an `:error_handler` option.\n\n## Migrating from Coherence\n\nIf you\'re currently using Coherence, you can migrate your app to use Pow instead. Follow the instructions in [Coherence migration guide](guides/coherence_migration.md).\n\n## Pow security practices\n\n* The `user_id_field` value is always treated as case insensitive\n* If the `user_id_field` is `:email`, it\'ll be validated based on RFC 5322 (excluding IP validation)\n* The `:password` has a minimum length of 8 characters\n* The `:password` has a maximum length of 4096 bytes [to prevent DOS attacks against Pbkdf2](https://github.com/riverrun/pbkdf2_elixir/blob/master/lib/pbkdf2.ex#L21)\n* The `:password_hash` is generated with `PBKDF2-SHA512` with 100,000 iterations\n* The session value contains a UUID token that is used to pull credentials through a GenServer\n* The credentials are stored in a key-value cache with TTL of 30 minutes\n* The credentials and session are renewed after 15 minutes if any activity is detected\n* The credentials and session are renewed when user updates\n\nSome of the above is based on [OWASP](https://www.owasp.org/) or [NIST SP800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) recommendations.\n\n## Other libraries\n\n[PowAssent](https://github.com/danschultzer/pow_assent) - Multi-provider support for Pow with strategies for Twitter, Github, Google, Facebook and more\n\n## Contributing\n\nPlease read [CONTRIBUTING.md](CONTRIBUTING.md).\n\n## LICENSE\n\n(The MIT License)\n\nCopyright (c) 2018-2019 Dan Schultzer & the Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \'Software\'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n'