b'![](https://github.com/expede/witchcraft/raw/master/brand/Wordmark/PNG/WC-wordmark-lrg@2x.png)\n\n`Witchcraft` is a library providing common algebraic and categorical abstractions to Elixir.\nMonoids, functors, monads, arrows, categories, and other dark magic right at your fingertips.\n\n[![Build Status](https://travis-ci.org/expede/witchcraft.svg?branch=master)](https://travis-ci.org/expede/witchcraft)\n[![Inline docs](http://inch-ci.org/github/expede/witchcraft.svg?branch=master)](http://inch-ci.org/github/expede/witchcraft)\n[![API Docs](https://img.shields.io/badge/api-docs-MediumPurple.svg?style=flat)](http://hexdocs.pm/witchcraft/)\n[![license](https://img.shields.io/github/license/mashape/apistatus.svg?maxAge=2592000)](https://github.com/expede/witchcraft/blob/master/LICENSE)\n\n[![](https://opencollective.com/witchcraft/tiers/backer.svg?avatarHeight=50)](https://opencollective.com/witchcraft/contribute/tier/8074-backer)\n\n[![](https://opencollective.com/witchcraft/tiers/sponsor.svg?avatarHeight=50)](https://opencollective.com/witchcraft/contribute/tier/8075-sponsor)\n\n# README\n\n## Table of Contents\n\n* [Quick Start](#quick-start)\n* [Library Family](#library-family)\n* [Values](#values)\n* [Type Class Hierarchy](#type-class-hierarchy)\n* [Writing Class Instances](#writing-class-instances)\n* [Operators](#operators)\n* [Haskell Translation Table](#haskell-translation-table)\n* [Prior Art and Further Reading](#prior-art-and-further-reading)\n* [Credits](#credits)\n\n## Quick Start\n\n```elixir\ndef deps do\n  [{:witchcraft, "~> 1.0"}]\nend\n\n# ...\n\nuse Witchcraft\n```\n\n## Library Family\n\n```\nQuark    TypeClass\n    \xe2\x86\x98    \xe2\x86\x99\n   Witchcraft\n       \xe2\x86\x93\n     Algae\n```\n\n| Name                                              | Description                                                   |\n|--------------------------------------------------:|---------------------------------------------------------------|\n| [`Quark`](https://hex.pm/packages/quark)          | Standard combinators (`id`, `compose`, &c)                    |\n| [`TypeClass`](https://hex.pm/packages/type_class) | Used internally to generate type classes                      |\n| [`Algae`](https://hex.pm/packages/algae)          | Algebraic data types that implement `Witchcraft` type classes |\n\n## Values\n\n### Beginner Friendliness\n\nYou shouldn\'t have to learn another language just to understand powerful abstractions!\nBy enabling people to use a language that they already know, and is already in the\nsame ballpark in terms of values (emphasis on immutability, &c), we can teach and\nlearn faster.\n\nAs much as possible, keep things friendly and well explained.\nConcrete examples are available via doctests.\n\n### Consistency & Ethos\n\nElixir does a lot of things differently from certain other functional languages.\nThe idea of a data "subject" being piped though functions is conceptually different from\npure composition of functions that are later applied. `Witchcraft` honours the\nElixir/Elm/OCaml way, and operators point in the direction that data travels.\n\nSome functions in the Elixir standard library have been expanded to work with more\ntypes while keeping the basic idea the same. For example, `<>` has been expanded\nto work on any [monoid](https://hexdocs.pm/witchcraft/Witchcraft.Monoid.html)\n(such as integers, lists, bitstrings, and so on).\n\nAll operators have named equivalents, and auto-currying variants of higher order functions\nare left at separate names so you can performance tune as needed (currying is helpful for\nmore abstract code). With a few exceptions (we\'re looking at you, `Applicative`),\npipe-ordering is maintained.\n\n### Pragmatism\nConvincing a company to use a language like [Haskell](https://www.haskell.org)\nor [PureScript](http://www.purescript.org) can be challenging. Elixir is gaining\na huge amount of interest. Many people have been able to introduce these concepts\ninto companies using Scala, so we should be able to do the same here.\n\nAll functions are compatible with regular Elixir code, and no types are enforced aside\nfrom what is used in protocol dispatch. Any struct can be made into a Witchcraft\nclass instance (given that it conforms to the properties).\n\n## Type Class Hierarchy\n\n```\nSemigroupoid  Semigroup  Setoid   Foldable   Functor -----------\xe2\x94\x90\n     \xe2\x86\x93           \xe2\x86\x93         \xe2\x86\x93         \xe2\x86\x93      \xe2\x86\x99   \xe2\x86\x93   \xe2\x86\x98           |\n  Category     Monoid     Ord    Traversable  Apply  Bifunctor  |\n     \xe2\x86\x93                                       \xe2\x86\x99    \xe2\x86\x98             \xe2\x86\x93\n   Arrow                            Applicative   Chain       Extend\n                                             \xe2\x86\x98    \xe2\x86\x99             \xe2\x86\x93\n                                              Monad           Comonad\n```\n\nHaving a clean slate, we have been able to use a clean set of type classes. This is largely\ntaken from the [Fantasy Land Specification](https://github.com/fantasyland/fantasy-land)\nand Edward Kmett\'s [`semigroupoids`](https://hackage.haskell.org/package/semigroupoids) package.\n\nAs usual, all `Applicative`s are `Functor`s, and all `Monad`s are `Applicative`s.\nThis grants us the ability to reuse functions in their child classes.\nFor example, `of` can be used for both `pure` and `return`, `lift/*` can handle\nboth `liftA*` and `liftM*`, and so on.\n\n### Import Chains\n\nIt is very common to want to import a class and all of its dependencies.\nYou can do this with `use`. For example, you can import the entire library with:\n\n```elixir\nuse Witchcraft\n```\n\nOr import a module plus all others that it depends on:\n\n```elixir\nuse Witchcraft.Applicative\n```\n\nAny options that you pass to `use` will be propagated all the way down the chain:\n\n```elixir\nuse Witchcraft.Applicative, except: [~>: 2]\n```\n\nSome modules override `Kernel` operators and functions. While this is generally safe,\nif you would like to skip all overrides, pass `override_kernel: false` as an option:\n\n```elixir\nuse Witchcraft.Applicative, override_kernel: false\n\n# Or even\n\nuse Witchcraft, override_kernel: false\n```\n\n## Writing Class Instances\n\nHow to make your custom struct compatible with `Witchcraft`:\n\n1. Read the [`TypeClass` README](https://hexdocs.pm/type_class/readme.html)\n2. Implement the [`TypeClass` data generator protocol](https://hexdocs.pm/type_class/TypeClass.Property.Generator.html#content) for your struct\n3. Use [`definst`](https://hexdocs.pm/type_class/TypeClass.html#definst/3) ("define instance") instead of `defimpl`:\n\n```elixir\ndefinst Witchcraft.Functor, for: Algae.Id do\n  def map(%{id: data}, fun), do: %Algae.Id{id: fun.(data)}\nend\n```\n\nAll classes have properties that your instance must conform to at compile time.\n`mix` will alert you to any failing properties by name, and will refuse to compile\nwithout them. Sometimes it is not possible to write an instance that will pass the check,\nand you can either write a [custom generator](https://hexdocs.pm/type_class/readme.html#custom_generator-1)\nfor that instance, or [force](https://hexdocs.pm/type_class/readme.html#force_type_instance-true)\nthe instance. If you must resort to forcing the instance, please write a test\nof the property for some specific case to be reasonably sure that it will be compatible\nwith the rest of the library.\n\nMore reference instances are available in [`Algae`](https://github.com/expede/algae).\n\n## Operators\n\n| Family       | Function         | Operator |\n|-------------:|:-----------------|:---------|\n| Setoid       | `equivalent?`    | `==`     |\n|              | `nonequivalent?` | `!=`     |\n| Ord          | `greater_than?`  | `>`      |\n|              | `lesser_than?`   | `<`      |\n| Semigroup    | `append`         | `<>`     |\n| Functor      | `lift`           | `~>`     |\n|              | `convey`         | `~>>`    |\n|              | `chain`          | `>>>`    |\n|              | `over`           | `<~`     |\n|              | `ap`             | `<<~`    |\n|              | `reverse_chain`  | `<<<`    |\n| Semigroupoid | `compose`        | `<\\|>`   |\n|              | `pipe_compose`   | `<~>`    |\n| Arrow        | `product`        | `^^^`    |\n|              | `fanout`         | `&&&`    |\n\n\n## Haskell Translation Table\n\n| Haskell Prelude | Witchcraft         |\n|----------------:|:-------------------|\n| `flip ($)`      | `\\|>/2` (`Kernel`) |\n| `.`             | `<\\|>/2`           |\n| `<<<`           | `<\\|>/2`           |\n| `>>>`           | `<~>/2`            |\n| `<>`            | `<>/2`             |\n| `<$>`           | `<~/2`             |\n| `flip (<$>)`    | `~>/2`             |\n| `fmap`          | `lift/2`           |\n| `liftA`         | `lift/2`           |\n| `liftA2`        | `lift/3`           |\n| `liftA3`        | `lift/4`           |\n| `liftM`         | `lift/2`           |\n| `liftM2`        | `lift/3`           |\n| `liftM3`        | `lift/4`           |\n| `ap`            | `ap/2`             |\n| `<*>`           | `<<~/2`            |\n| `<**>`          | `~>>/2`            |\n| `*>`            | `then/2`           |\n| `<*`            | `following/2`      |\n| `pure`          | `of/2`             |\n| `return`        | `of/2`             |\n| `>>`            | `then/2`           |\n| `>>=`           | `>>>/2`            |\n| `=<<`           | `<<</2`            |\n| `***`           | `^^^/2`            |\n| `&&&`           | `&&&/2`            |\n\n## Prior Art and Further Reading\n\nThis library draws heavy inspiration from mathematics, other languages,\nand other Elixir libraries. We would be ashamed not to mention them here.\nThere is much, much more out there, but these are our highlights and inspirations.\n\nThe [`Monad`](https://hexdocs.pm/monad/Monad.html) library predates `Witchcraft`\nby several years. This library proved that it is entirely possible\nto bring do-notation to Elixir. It takes a very different approach:\nit is very up-front that it has a very loose definition of what it means for\nsomething to be a "monad", and relies on `behaviour`s rather than ad-hoc polymorphism.\n\n[The Fantasy Land Spec](https://github.com/fantasyland/fantasy-land) is a spec for\nprojects such as this one, but targeted at Javascript. It does not come with its\nown implementation, but provides a [helpful chart](https://github.com/fantasyland/fantasy-land/raw/master/figures/dependencies.png)\nof class hierarchies.\n\nIn many ways, [`Scalaz`](https://github.com/scalaz/scalaz), and later [`cats`](http://typelevel.org/cats/),\nwere the first widely-used port of categorical & algebraic ideas to\na mainstream language. While dismissed by some as "[Haskell fan fiction](https://twitter.com/plt_hulk/status/341292374355501056)",\nit showed that we can write our own Haskell fanfic in all sorts of languages.\n\nObviously the Haskell [`Prelude`](https://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html)\ndeserves mention. Haskell has inspired so many programmers to write clean,\ndeclarative, functional code based on principled abstractions. We\'ll spare you\nthe love letter to [SPJ](https://en.wikipedia.org/wiki/Simon_Peyton_Jones),\nthe Glasgow team, and the original Haskell committee, but we\'re deeply appreciative\nof how they pushed the state of the art forward.\n\n[`classy-prelude`/`mono-traversable`](https://github.com/snoyberg/mono-traversable)\nhave also made a lot of progress towards a base library that incorporates modern ideas\nin a clean package, and was an inspiration to taking a similar approach with Witchcraft.\n\nThe [`semigroupoids`](https://hackage.haskell.org/package/semigroupoids) library\nfrom the eminent [Edward Kmett](https://github.com/ekmett) provided many\nreference implementations and is helping set the future expansion of\nthe foldable class lineage in Witchcraft.\n\nInterested in learning more of the underlying ideas? The maintainers can heavily\nrecommend [Conceptual Mathematics](http://www.cambridge.org/catalogue/catalogue.asp?isbn=9780521719162),\n[Category Theory for the Sciences](https://mitpress.mit.edu/books/category-theory-sciences),\nand [Categories for the Working Mathematician](https://en.wikipedia.org/wiki/Categories_for_the_Working_Mathematician).\nReading these books probably won\'t change your code overnight. Some people call it\n"[general abstract nonsense](https://en.wikipedia.org/wiki/Abstract_nonsense)"\nfor a reason. That said, it does provide a nice framework for thinking about\nthese abstract ideas, and is a recommended pursuit for all that are curious.\n\n## Credits\n\n### Logo\nA big thank you to [Brandon Labb\xc3\xa9](https://dribbble.com/brandonlabbe) for creating\nthe project logo.\n\n### Sponsor\n[Robot Overlord](http://robotoverlord.io) sponsors much of the development of Witchcraft,\nand dogfoods the library in real-world applications.\n'