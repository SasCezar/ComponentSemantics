b'![Wallaby](https://i.imgur.com/eQ1tlI3.png)\n============\n[![Actions Status](https://github.com/elixir-wallaby/wallaby/workflows/CI/badge.svg)](https://github.com/elixir-wallaby/wallaby/actions)\n[![Hex pm](https://img.shields.io/hexpm/v/wallaby.svg?style=flat)](https://hex.pm/packages/wallaby)\n[![Coverage Status](https://coveralls.io/repos/github/keathley/wallaby/badge.svg?branch=master)](https://coveralls.io/github/keathley/wallaby?branch=master)\n[![Inline docs](http://inch-ci.org/github/keathley/wallaby.svg)](http://inch-ci.org/github/keathley/wallaby)\n\nWallaby helps you test your web applications by simulating realistic user interactions.\nBy default it runs each test case concurrently and manages browsers for you.\nHere\'s an example test for a simple Todo application:\n\n```elixir\ndefmodule MyApp.Features.TodoTest do\n  use MyApp.FeatureCase, async: true\n\n  import Wallaby.Query, only: [css: 2, text_field: 1, button: 1]\n\n  test "users can create todos", %{session: session} do\n    session\n    |> visit("/todos")\n    |> fill_in(text_field("New Todo"), with: "Write my first Wallaby test")\n    |> click(button("Save"))\n    |> assert_has(css(".alert", text: "You created a todo"))\n    |> assert_has(css(".todo-list > .todo", text: "Write my first Wallaby test"))\n  end\nend\n```\n\nBecause Wallaby manages multiple browsers for you, its possible to test several users interacting with a page simultaneously.\n\n```elixir\ndefmodule MyApp.Features.MultipleUsersTest do\n  use MyApp.FeatureCase, async: true\n\n  import Wallaby.Query, only: [text_field: 1, button: 1, css: 2]\n\n  @page message_path(Endpoint, :index)\n  @message_field text_field("Share Message")\n  @share_button button("Share")\n\n  def message(msg), do: css(".messages > .message", text: msg)\n\n  test "That users can send messages to each other" do\n    {:ok, user1} = Wallaby.start_session\n    user1\n    |> visit(@page)\n    |> fill_in(@message_field, with: "Hello there!")\n    |> click(@share_button)\n\n    {:ok, user2} = Wallaby.start_session\n    user2\n    |> visit(@page)\n    |> fill_in(@message_field, with: "Hello yourself")\n    |> click(@share_button)\n\n    user1\n    |> assert_has(message("Hello yourself"))\n\n    user2\n    |> assert_has(message("Hello there!"))\n  end\nend\n```\n\nRead on to see what else Wallaby can do or check out the [Official Documentation](https://hexdocs.pm/wallaby).\n\n## Setup\n\nAdd Wallaby to your list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [{:wallaby, "~> 0.23.0", [runtime: false, only: :test]}]\nend\n```\n\nThen ensure that Wallaby is started in your `test_helper.exs`:\n\n```elixir\n{:ok, _} = Application.ensure_all_started(:wallaby)\n```\n\n### Phoenix\n\nIf you\'re testing a Phoenix application with Ecto 2 or 3 and a database that supports sandbox mode then you can enable concurrent testing by adding the `Phoenix.Ecto.SQL.Sandbox` plug to your `Endpoint`.\nIt\'s important that this is at the top of `endpoint.ex` before any other plugs.\n\n```elixir\n# lib/endpoint.ex\n\ndefmodule YourApp.Endpoint do\n  use Phoenix.Endpoint, otp_app: :your_app\n\n  if Application.get_env(:your_app, :sql_sandbox) do\n    plug Phoenix.Ecto.SQL.Sandbox\n  end\n```\n\nMake sure Phoenix is set up to serve endpoints in tests and that the SQL sandbox is enabled:\n\n```elixir\n# config/test.exs\n\nconfig :your_app, YourApplication.Endpoint,\n  server: true\n\nconfig :your_app, :sql_sandbox, true\n```\n\nThen in your `test_helper.exs` you can provide some configuration to Wallaby.\nAt minimum, you need to specify a `:base_url`, so Wallaby knows how to resolve relative paths.\n\n```elixir\n# test/test_helper.exs\n\nApplication.put_env(:wallaby, :base_url, YourApplication.Endpoint.url)\n```\n\n#### Assets\n\nAssets are not re-compiled when you run `mix test`.\nThis can lead to confusion if you\'ve made changes in javascript or css but tests are still failing.\nThere are two common ways to avoid this confusion.\n\nThe first solution is to run `webpack --mode development --watch` from the assets directory.\nThis will ensure that assets get recompiled after any changes.\n\nThe second solution is to add a new alias to your mix config that recompiles assets for you:\n\n```elixir\n  def project do\n    [\n      app: :my_app,\n      version: "1.0.0",\n      aliases: aliases()\n    ]\n  end\n\n  defp aliases, do: [\n    "test": [\n      "assets.compile --quiet",\n      "ecto.create --quiet",\n      "ecto.migrate",\n      "test",\n    ],\n    "assets.compile": &compile_assets/1\n  ]\n\n  defp compile_assets(_) do\n    Mix.shell().cmd("./assets/node_modules/webpack/bin/webpack.js --mode development",\n      quiet: true\n    )\n  end\n```\n\nThis method is less error prone but it will cause a delay when starting your test suite.\n\n#### Umbrella Apps\n\nIf you\'re testing an umbrella application containing a Phoenix application for the web interface (`MyWebApp`) and a separate persistence application (`MyPersistenceApp`) using Ecto 2 or 3 with a database that supports sandbox mode, then you can use the same setup as above, with a few tweaks.\n\n```elixir\n# my_web_app/lib/endpoint.ex\n\ndefmodule MyWebApp.Endpoint do\n  use Phoenix.Endpoint, otp_app: :my_web_app\n\n  if Application.get_env(:my_persistence_app, :sql_sandbox) do\n    plug Phoenix.Ecto.SQL.Sandbox\n  end\n```\n\nMake sure `MyWebApp` is set up to serve endpoints in tests and that the SQL sandbox is enabled:\n\n```elixir\n# my_web_app/config/test.exs\n\nconfig :my_web_app, MyWebApp.Endpoint,\n  server: true\n\nconfig :my_persistence_app, :sql_sandbox, true\n```\n\nThen in `MyWebApp`\'s `test_helper.exs` you can provide some configuration to Wallaby.\nAt minimum, you need to specify a `:base_url`, so Wallaby knows how to resolve relative paths.\n\n```elixir\n# my_web_app/test/test_helper.exs\n\nApplication.put_env(:wallaby, :base_url, MyWebApp.Endpoint.url)\n```\n\nYou will also want to add `phoenix_ecto` as a dependency to `MyWebApp`:\n\n```elixir\n# my_web_app/mix.exs\n\ndef deps do\n  [\n    {:wallaby, "~> 0.23", only: :test},\n    {:phoenix_ecto, "~> 3.0", only: :test}\n  ]\nend\n```\n\n### PhantomJS\n\nWallaby requires PhantomJS. You can install PhantomJS through NPM or your package manager of choice:\n\n```\n$ npm install -g phantomjs-prebuilt\n```\n\nWallaby will use whatever PhantomJS you have installed in your path. If you need to specify a specific PhantomJS you can pass the path in the configuration:\n\n```elixir\nconfig :wallaby, phantomjs: "some/path/to/phantomjs"\n```\n\nYou can also pass arguments to PhantomJS through the `phantomjs_args` config setting, e.g.:\n\n```elixir\nconfig :wallaby, phantomjs_args: "--webdriver-logfile=phantomjs.log"\n```\n\n### Writing tests\n\nIt\'s easiest to add Wallaby to your test suite by creating a new case template (in case of an umbrella app, take care to adjust `YourApp` appropriately):\n\n```elixir\ndefmodule YourApp.FeatureCase do\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      use Wallaby.DSL\n\n      alias YourApp.Repo\n      import Ecto\n      import Ecto.Changeset\n      import Ecto.Query\n\n      import YourApp.Router.Helpers\n    end\n  end\n\n  setup tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(YourApp.Repo)\n\n    unless tags[:async] do\n      Ecto.Adapters.SQL.Sandbox.mode(YourApp.Repo, {:shared, self()})\n    end\n\n    metadata = Phoenix.Ecto.SQL.Sandbox.metadata_for(YourApp.Repo, self())\n    {:ok, session} = Wallaby.start_session(metadata: metadata)\n    {:ok, session: session}\n  end\nend\n```\n\nThen you can write tests like so:\n\n```elixir\ndefmodule YourApp.UserListTest do\n  use YourApp.FeatureCase, async: true\n\n  import Wallaby.Query, only: [css: 2]\n\n  test "users have names", %{session: session} do\n    session\n    |> visit("/users")\n    |> find(css(".user", count: 3))\n    |> List.first()\n    |> assert_has(css(".user-name", text: "Chris"))\n  end\nend\n```\n\n## API\n\nThe full documentation for the DSL is in the [official documentation](https://hexdocs.pm/wallaby).\n\n### Queries and Actions\n\nWallaby\'s API is broken into 2 concepts: Queries and Actions.\n\nQueries allow us to declaratively describe the elements that we would like to interact with and Actions allow us to use those queries to interact with the DOM.\n\nLets say that our html looks like this:\n\n```html\n<ul class="users">\n  <li class="user">\n    <span class="user-name">Ada</span>\n  </li>\n  <li class="user">\n    <span class="user-name">Grace</span>\n  </li>\n  <li class="user">\n    <span class="user-name">Alan</span>\n  </li>\n</ul>\n```\n\nIf we wanted to interact with all of the users then we could write a query like so `css(".user", count: 3)`.\n\nIf we only wanted to interact with a specific user then we could write a query like this `css(".user-name", count: 1, text: "Ada")`. Now we can use those queries with some actions:\n\n```elixir\nsession\n|> find(css(".user", count: 3))\n|> List.first\n|> assert_has(css(".user-name", count: 1, text: "Ada"))\n```\n\nThere are several queries for common html elements defined in the [Query module](https://hexdocs.pm/wallaby/Wallaby.Query.html#content).\nAll actions accept a query.\nThis makes it easy to use queries we\'ve already defined.\nActions will block until the query is either satisfied or the action times out.\nBlocking reduces race conditions when elements are added or removed dynamically.\n\n### Navigation\n\nWe can navigate directly to pages with `visit`:\n\n```elixir\nvisit(session, "/page.html")\nvisit(session, user_path(Endpoint, :index, 17))\n```\n\nIt\'s also possible to click links directly:\n\n```elixir\nclick(session, link("Page 1"))\n```\n\n### Finding\n\nWe can find a specific element or list of elements with `find`:\n\n```elixir\n@user_form   css(".user-form")\n@name_field  text_field("Name")\n@email_field text_field("Email")\n@save_button button("Save")\n\nfind(page, @user_form, fn(form) ->\n  form\n  |> fill_in(@name_field, with: "Chris")\n  |> fill_in(@email_field, with: "c@keathley.io")\n  |> click(@save_button)\nend)\n```\n\nPassing a callback to `find` will return the parent which makes it easy to chain `find` with other actions:\n\n```elixir\npage\n|> find(css(".users"), & assert has?(&1, css(".user", count: 3)))\n|> click(link("Next Page"))\n```\n\nWithout the callback `find` returns the element.\nThis provides a way to scope all future actions within an element.\n\n```elixir\npage\n|> find(css(".user-form"))\n|> fill_in(text_field("Name"), with: "Chris")\n|> fill_in(text_field("Email"), with: "c@keathley.io")\n|> click(button("Save"))\n```\n\n### Interacting with forms\n\nThere are a few ways to interact with form elements on a page:\n\n```elixir\nfill_in(session, text_field("First Name"), with: "Chris")\nclear(session, text_field("last_name"))\nclick(session, option("Some option"))\nclick(session, radio_button("My Fancy Radio Button"))\nclick(session, button("Some Button"))\n```\n\nIf you need to send specific keys to an element, you can do that with `send_keys`:\n\n```elixir\nsend_keys(session, ["Example", "Text", :enter])\n```\n\n### Assertions\n\nWallaby provides custom assertions to make writing tests easier:\n\n```elixir\nassert_has(session, css(".signup-form"))\nrefute_has(session, css(".alert"))\nhas?(session, css(".user-edit-modal", visible: false))\n```\n\n`assert_has` and `refute_has` both take a parent element as their first argument.\nThey return that parent, making it easy to chain them together with other actions.\n\n```elixir\nsession\n|> assert_has(css(".signup-form"))\n|> fill_in(text_field("Email", with: "c@keathley.io"))\n|> click(button("Sign up"))\n|> refute_has(css(".error"))\n|> assert_has(css(".alert", text: "Welcome!"))\n```\n\n### Window Size\n\nYou can set the default window size by passing in the `window_size` option into `Wallaby.start_session\\1`.\n\n```elixir\nWallaby.start_session(window_size: [width: 1280, height: 720])\n```\n\nYou can also resize the window and get the current window size during the test.\n\n```elixir\nresize_window(session, 100, 100)\nwindow_size(session)\n```\n\n### Screenshots\n\nIt\'s possible take screenshots:\n\n```elixir\ntake_screenshot(session)\n```\n\nAll screenshots are saved to a `screenshots` directory in the directory that the tests were run in.\n\nIf you want to customize the screenshot directory you can pass it as a config value:\n\n```elixir\n# config/test.exs\nconfig :wallaby, screenshot_dir: "/file/path"\n\n# test_helper.exs\nApplication.put_env(:wallaby, :screenshot_dir, "/file/path")\n```\n\n### Automatic screenshots\n\nYou can automatically take screenshots on an error:\n\n```elixir\n# config/test.exs\nconfig :wallaby, screenshot_on_failure: true\n\n# test_helper.exs\nApplication.put_env(:wallaby, :screenshot_on_failure, true)\n```\n\n## JavaScript\n\n### Asynchronous code\n\nTesting asynchronous JavaScript code can expose timing issues and race conditions.\nWe might try to interact with an element that hasn\'t yet appeared on the page.\nElements can become stale while we\'re trying to interact with them.\n\nWallaby helps solve this by blocking.\nInstead of manually setting timeouts we can use `assert_has` and some declarative queries to block until the DOM is in a good state.\n\n```elixir\nsession\n|> click(button("Some Async Button"))\n|> assert_has(css(".async-result"))\n|> click(button("Next Action"))\n```\n\n### Interacting with dialogs\n\nWallaby provides several ways to interact with JavaScript dialogs such as `window.alert`, `window.confirm` and `window.prompt`.\n\nYou can use one of the following functions:\n\n* For `window.alert` use `accept_alert/2`\n* For `window.confirm` use `accept_confirm/2` or `dismiss_confirm/2`\n* For `window.prompt` use `accept_prompt/2-3` or `dismiss_prompt/2`\n\nAll of these take a function as last parameter, which must include the necessary interactions to trigger the dialog. For example:\n\n```elixir\nalert_message = accept_alert session, fn(session) ->\n  click(session, link("Trigger alert"))\nend\n```\n\nTo emulate user input for a prompt, `accept_prompt` takes an optional parameter:\n\n```elixir\nprompt_message = accept_prompt session, [with: "User input"], fn(session) ->\n  click(session, link("Trigger prompt"))\nend\n```\n\n### JavaScript logging and errors\n\nWallaby captures both JavaScript logs and errors.\nAny uncaught exceptions in JavaScript will be re-thrown in Elixir.\nThis can be disabled by specifying `js_errors: false` in your Wallaby config.\n\nJavaScript logs are written to :stdio by default.\nThis can be changed to any IO device by setting the `:js_logger` option in your Wallaby config.\nFor instance if you want to write all JavaScript console logs to a file you could do something like this:\n\n```elixir\n{:ok, file} = File.open("browser_logs.log", [:write])\nApplication.put_env(:wallaby, :js_logger, file)\n```\n\nLogging can be disabled by setting `:js_logger` to `nil`.\n\n## Config\n\n### Adjusting timeouts\n\nWallaby uses [hackney](https://github.com/benoitc/hackney) under the hood, so we offer a hook that allows you to control any hackney options you\'d like to have sent along on every request.\nThis can be controlled with the `:hackney_options` setting in `config.exs`.\n\n```elixir\nconfig :wallaby,\n  hackney_options: [timeout: :infinity, recv_timeout: :infinity]\n\n# Overriding a value\nconfig :wallaby,\n  hackney_options: [timeout: 5_000]\n```\n\n### Drivers\n\nWallaby works with PhantomJS out of the box. There is also experimental support for both headless chrome and selenium.\nThe driver can be specified by setting the `driver` option in the wallaby config like so:\n\n```elixir\n# Chrome\nconfig :wallaby,\n  driver: Wallaby.Experimental.Chrome\n\n# Selenium\nconfig :wallaby,\n  driver: Wallaby.Experimental.Selenium\n```\n\nSee below for more information on the experimental drivers.\n\n## Experimental Driver Support\n\nCurrently Wallaby provides experimental support for both headless chrome and selenium.\nBoth of these drivers are still "experimental" because they don\'t support the full API yet and because the implementation is changing rapidly.\nBut, if you would like to use them in your project here\'s what you\'ll need to do.\n\nPlease refer to the [documentation](https://hexdocs.pm/wallaby/Wallaby.Experimental.Chrome.html#content) for further information about using the Chrome driver.\n\n### Headless Chrome\n\nIn order to run headless chrome you\'ll need to have ChromeDriver >= 2.30 and chrome >= 60.\nPrevious versions of both of these tools _may_ work, but several features will be buggy.\nIf you want to setup chrome in a CI environment then you\'ll still need to install and run xvfb.\nThis is due to a bug in ChromeDriver 2.30 that inhibits ChromeDriver from handling input text correctly.\nThe bug should be fixed in ChromeDriver 2.31.\n\n### Selenium\n\nPlease refer to the [documentation](https://hexdocs.pm/wallaby/Wallaby.Experimental.Selenium.html#content) for further information about using the Selenium driver.\n\n## Contributing\n\nWallaby is a community project. PRs and Issues are greatly welcome.\n\nTo get started and setup the project, make sure you\'ve got Elixir 1.5+ installed and then:\n\n```\n$ mix deps.get\n$ npm install -g phantomjs-prebuilt # unless you\'ve already got PhantomJS installed\n$ mix test # Make sure the tests pass!\n```\n\nBesides running the unit tests above, it is recommended to run the driver\nintegration tests too:\n\n```\n# Run only phantomjs integration tests\n$ WALLABY_DRIVER=phantom mix test\n\n# Run all tests (unit and all drivers)\n$ mix test.all\n```\n'