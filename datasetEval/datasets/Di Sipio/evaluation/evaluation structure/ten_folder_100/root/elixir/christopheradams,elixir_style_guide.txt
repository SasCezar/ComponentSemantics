b'# [The Elixir Style Guide][Elixir Style Guide]\n\n## Table of Contents\n\n* __[Prelude](#prelude)__\n* __[About](#about)__\n* __[Formatting](#formatting)__\n  * [Whitespace](#whitespace)\n  * [Indentation](#indentation)\n  * [Parentheses](#parentheses)\n  * [Syntax](#syntax)\n* __[The Guide](#the-guide)__\n  * [Expressions](#expressions)\n  * [Naming](#naming)\n  * [Comments](#comments)\n    * [Comment Annotations](#comment-annotations)\n  * [Modules](#modules)\n  * [Documentation](#documentation)\n  * [Typespecs](#typespecs)\n  * [Structs](#structs)\n  * [Exceptions](#exceptions)\n  * [Collections](#collections)\n  * [Strings](#strings)\n  * _Regular Expressions_\n  * [Metaprogramming](#metaprogramming)\n  * [Testing](#testing)\n* __[Resources](#resources)__\n  * [Alternative Style Guides](#alternative-style-guides)\n  * [Tools](#tools)\n* __[Getting Involved](#getting-involved)__\n  * [Contributing](#contributing)\n  * [Spread the Word](#spread-the-word)\n* __[Copying](#copying)__\n  * [License](#license)\n  * [Attribution](#attribution)\n\n## Prelude\n\n> Liquid architecture. It\'s like jazz \xe2\x80\x94 you improvise, you work together, you\n> play off each other, you make something, they make something.\n>\n> \xe2\x80\x94Frank Gehry\n\nStyle matters.\n[Elixir] has plenty of style but like all languages it can be stifled.\nDon\'t stifle the style.\n\n## About\n\nThis is community style guide for the [Elixir programming language][Elixir].\nPlease feel free to make pull requests and suggestions, and be a part of\nElixir\'s vibrant community.\n\nIf you\'re looking for other projects to contribute to please see the\n[Hex package manager site][Hex].\n\n<a name="translations"></a>\nTranslations of the guide are available in the following languages:\n\n* [Chinese Simplified]\n* [Chinese Traditional]\n* [French]\n* [Japanese]\n* [Korean]\n* [Portuguese]\n* [Spanish]\n\n## Formatting\n\nElixir v1.6 introduced a [Code Formatter] and [Mix format] task.\nThe formatter should be preferred for all new projects and source code.\n\nThe rules in this section are applied automatically by the code formatter, but\nare provided here as examples of the preferred style.\n\n### Whitespace\n\n* <a name="trailing-whitespace"></a>\n  Avoid trailing whitespace.\n  <sup>[[link](#trailing-whitespace)]</sup>\n\n* <a name="newline-eof"></a>\n  End each file with a newline.\n  <sup>[[link](#newline-eof)]</sup>\n\n* <a name="line-endings"></a>\n  Use Unix-style line endings (\\*BSD/Solaris/Linux/OSX users are covered by\n  default, Windows users have to be extra careful).\n  <sup>[[link](#line-endings)]</sup>\n\n* <a name="autocrlf"></a>\n  If you\'re using Git you might want to add the following configuration\n  setting to protect your project from Windows line endings creeping in:\n  <sup>[[link](#autocrlf)]</sup>\n\n  ```sh\n  git config --global core.autocrlf true\n  ```\n\n* <a name="line-length"></a>\n  Limit lines to 98 characters.\n  Otherwise, set the `:line_length` option in your `.formatter.exs` file.\n  <sup>[[link](#line-length)]</sup>\n\n* <a name="spaces"></a>\n  Use spaces around operators, after commas, colons and semicolons.\n  Do not put spaces around matched pairs like brackets, parentheses, etc.\n  Whitespace might be (mostly) irrelevant to the Elixir runtime, but its proper\n  use is the key to writing easily readable code.\n  <sup>[[link](#spaces)]</sup>\n\n  ```elixir\n  sum = 1 + 2\n  {a, b} = {2, 3}\n  [first | rest] = [1, 2, 3]\n  Enum.map(["one", <<"two">>, "three"], fn num -> IO.puts(num) end)\n  ```\n\n* <a name="no-spaces"></a>\n  Do not use spaces after non-word operators that only take one argument; or\n  around the range operator.\n  <sup>[[link](#no-spaces)]</sup>\n\n  ```elixir\n  0 - 1 == -1\n  ^pinned = some_func()\n  5 in 1..10\n  ```\n\n* <a name="def-spacing"></a>\n  Use blank lines between `def`s to break up a function into logical\n  paragraphs.\n  <sup>[[link](#def-spacing)]</sup>\n\n  ```elixir\n  def some_function(some_data) do\n    some_data |> other_function() |> List.first()\n  end\n\n  def some_function do\n    result\n  end\n\n  def some_other_function do\n    another_result\n  end\n\n  def a_longer_function do\n    one\n    two\n\n    three\n    four\n  end\n  ```\n\n* <a name="defmodule-spacing"></a>\n  Don\'t put a blank line after `defmodule`.\n  <sup>[[link](#defmodule-spacing)]</sup>\n\n* <a name="long-dos"></a>\n  If the function head and `do:` clause are too long to fit on the same line, put\n  `do:` on a new line, indented one level more than the previous line.\n  <sup>[[link](#long-dos)]</sup>\n\n  ```elixir\n  def some_function([:foo, :bar, :baz] = args),\n    do: Enum.map(args, fn arg -> arg <> " is on a very long line!" end)\n  ```\n\n  When the `do:` clause starts on its own line, treat it as a multiline\n  function by separating it with blank lines.\n\n  ```elixir\n  # not preferred\n  def some_function([]), do: :empty\n  def some_function(_),\n    do: :very_long_line_here\n\n  # preferred\n  def some_function([]), do: :empty\n\n  def some_function(_),\n    do: :very_long_line_here\n  ```\n\n* <a name="add-blank-line-after-multiline-assignment"></a>\n  Add a blank line after a multiline assignment as a\n  visual cue that the assignment is \'over\'.\n  <sup>[[link](#add-blank-line-after-multiline-assignment)]</sup>\n\n  ```elixir\n  # not preferred\n  some_string =\n    "Hello"\n    |> String.downcase()\n    |> String.trim()\n  another_string <> some_string\n\n  # preferred\n  some_string =\n    "Hello"\n    |> String.downcase()\n    |> String.trim()\n\n  another_string <> some_string\n  ```\n\n  ```elixir\n  # also not preferred\n  something =\n    if x == 2 do\n      "Hi"\n    else\n      "Bye"\n    end\n  String.downcase(something)\n\n  # preferred\n  something =\n    if x == 2 do\n      "Hi"\n    else\n      "Bye"\n    end\n\n  String.downcase(something)\n  ```\n\n* <a name="multiline-enums"></a>\n  If a list, map, or struct spans multiple lines, put each element, as well as\n  the opening and closing brackets, on its own line.\n  Indent each element one level, but not the brackets.\n  <sup>[[link](#multiline-enums)]</sup>\n\n  ```elixir\n  # not preferred\n  [:first_item, :second_item, :next_item,\n  :final_item]\n\n  # preferred\n  [\n    :first_item,\n    :second_item,\n    :next_item,\n    :final_item\n  ]\n  ```\n\n* <a name="multiline-list-assign"></a>\n  When assigning a list, map, or struct, keep the opening bracket on the same\n  line as the assignment.\n  <sup>[[link](#multiline-list-assign)]</sup>\n\n  ```elixir\n  # not preferred\n  list =\n  [\n    :first_item,\n    :second_item\n  ]\n\n  # preferred\n  list = [\n    :first_item,\n    :second_item\n  ]\n  ```\n\n* <a name="multiline-case-clauses"></a>\n  When `case` or `cond` clauses span multiple lines, separate each clause with a\n  blank line.\n  <sup>[[link](#multiline-case-clauses)]</sup>\n\n  ```elixir\n  # not preferred\n  case arg do\n    true ->\n      :ok\n    false ->\n      :error\n  end\n\n  # preferred\n  case arg do\n    true ->\n      :ok\n\n    false ->\n      :error\n  end\n  ```\n\n* <a name="comments-above-line"></a>\n  Place comments above the line they comment on.\n  <sup>[[link](#comments-above-line)]</sup>\n\n  ```elixir\n  String.first(some_string) # not preferred\n\n  # preferred\n  String.first(some_string)\n  ```\n\n* <a name="comment-leading-spaces"></a>\n  Use one space between the leading `#` character of the comment and the text of\n  the comment.\n  <sup>[[link](#comment-leading-spaces)]</sup>\n\n  ```elixir\n  #not preferred\n  String.first(some_string)\n\n  # preferred\n  String.first(some_string)\n  ```\n\n### Indentation\n\n* <a name="with-clauses"></a>\n  Indent and align successive `with` clauses.\n  Put the `do:` argument on a new line, aligned with the previous clauses.\n  <sup>[[link](#with-clauses)]</sup>\n\n  ```elixir\n  with {:ok, foo} <- fetch(opts, :foo),\n       {:ok, my_var} <- fetch(opts, :my_var),\n       do: {:ok, foo, my_var}\n  ```\n\n* <a name="with-else"></a>\n  If the `with` expression has a `do` block with more than one line, or has an\n  `else` option, use multiline syntax.\n  <sup>[[link](#with-else)]</sup>\n\n  ```elixir\n  with {:ok, foo} <- fetch(opts, :foo),\n       {:ok, my_var} <- fetch(opts, :my_var) do\n    {:ok, foo, my_var}\n  else\n    :error ->\n      {:error, :bad_arg}\n  end\n  ```\n\n### Parentheses\n\n* <a name="parentheses-pipe-operator"></a>\n  Use parentheses for one-arity functions when using the pipe operator (`|>`).\n  <sup>[[link](#parentheses-pipe-operator)]</sup>\n\n  ```elixir\n  # not preferred\n  some_string |> String.downcase |> String.trim\n\n  # preferred\n  some_string |> String.downcase() |> String.trim()\n  ```\n\n* <a name="function-names-with-parentheses"></a>\n  Never put a space between a function name and the opening parenthesis.\n  <sup>[[link](#function-names-with-parentheses)]</sup>\n\n  ```elixir\n  # not preferred\n  f (3 + 2)\n\n  # preferred\n  f(3 + 2)\n  ```\n\n* <a name="function-calls-and-parentheses"></a>\n  Use parentheses in function calls, especially inside a pipeline.\n  <sup>[[link](#function-calls-and-parentheses)]</sup>\n\n  ```elixir\n  # not preferred\n  f 3\n\n  # preferred\n  f(3)\n\n  # not preferred and parses as rem(2, (3 |> g)), which is not what you want.\n  2 |> rem 3 |> g\n\n  # preferred\n  2 |> rem(3) |> g\n  ```\n\n* <a name="keyword-list-brackets"></a>\n  Omit square brackets from keyword lists whenever they are optional.\n  <sup>[[link](#keyword-list-brackets)]</sup>\n\n  ```elixir\n  # not preferred\n  some_function(foo, bar, [a: "baz", b: "qux"])\n\n  # preferred\n  some_function(foo, bar, a: "baz", b: "qux")\n  ```\n\n## The Guide\n\nThe rules in this section may not be applied by the code formatter, but they are\ngenerally preferred practice.\n\n### Expressions\n\n* <a name="single-line-defs"></a>\n  Run single-line `def`s that match for the same function together, but separate\n  multiline `def`s with a blank line.\n  <sup>[[link](#single-line-defs)]</sup>\n\n  ```elixir\n  def some_function(nil), do: {:error, "No Value"}\n  def some_function([]), do: :ok\n\n  def some_function([first | rest]) do\n    some_function(rest)\n  end\n  ```\n\n* <a name="multiple-function-defs"></a>\n  If you have more than one multiline `def`, do not use single-line `def`s.\n  <sup>[[link](#multiple-function-defs)]</sup>\n\n  ```elixir\n  def some_function(nil) do\n    {:error, "No Value"}\n  end\n\n  def some_function([]) do\n    :ok\n  end\n\n  def some_function([first | rest]) do\n    some_function(rest)\n  end\n\n  def some_function([first | rest], opts) do\n    some_function(rest, opts)\n  end\n  ```\n\n* <a name="pipe-operator"></a>\n  Use the pipe operator to chain functions together.\n  <sup>[[link](#pipe-operator)]</sup>\n\n  ```elixir\n  # not preferred\n  String.trim(String.downcase(some_string))\n\n  # preferred\n  some_string |> String.downcase() |> String.trim()\n\n  # Multiline pipelines are not further indented\n  some_string\n  |> String.downcase()\n  |> String.trim()\n\n  # Multiline pipelines on the right side of a pattern match\n  # should be indented on a new line\n  sanitized_string =\n    some_string\n    |> String.downcase()\n    |> String.trim()\n  ```\n\n  While this is the preferred method, take into account that copy-pasting\n  multiline pipelines into IEx might result in a syntax error, as IEx will\n  evaluate the first line without realizing that the next line has a pipeline.\n  To avoid this, you can wrap the pasted code in parentheses.\n\n* <a name="avoid-single-pipelines"></a>\n  Avoid using the pipe operator just once.\n  <sup>[[link](#avoid-single-pipelines)]</sup>\n\n  ```elixir\n  # not preferred\n  some_string |> String.downcase()\n\n  # preferred\n  String.downcase(some_string)\n  ```\n\n* <a name="bare-variables"></a>\n  Use _bare_ variables in the first part of a function chain.\n  <sup>[[link](#bare-variables)]</sup>\n\n  ```elixir\n  # not preferred\n  String.trim(some_string) |> String.downcase() |> String.codepoints()\n\n  # preferred\n  some_string |> String.trim() |> String.downcase() |> String.codepoints()\n  ```\n\n* <a name="fun-def-parentheses"></a>\n  Use parentheses when a `def` has arguments, and omit them when it doesn\'t.\n  <sup>[[link](#fun-def-parentheses)]</sup>\n\n  ```elixir\n  # not preferred\n  def some_function arg1, arg2 do\n    # body omitted\n  end\n\n  def some_function() do\n    # body omitted\n  end\n\n  # preferred\n  def some_function(arg1, arg2) do\n    # body omitted\n  end\n\n  def some_function do\n    # body omitted\n  end\n  ```\n\n* <a name="do-with-single-line-if-unless"></a>\n  Use `do:` for single line `if/unless` statements.\n  <sup>[[link](#do-with-single-line-if-unless)]</sup>\n\n  ```elixir\n  # preferred\n  if some_condition, do: # some_stuff\n  ```\n\n* <a name="unless-with-else"></a>\n  Never use `unless` with `else`.\n  Rewrite these with the positive case first.\n  <sup>[[link](#unless-with-else)]</sup>\n\n  ```elixir\n  # not preferred\n  unless success do\n    IO.puts(\'failure\')\n  else\n    IO.puts(\'success\')\n  end\n\n  # preferred\n  if success do\n    IO.puts(\'success\')\n  else\n    IO.puts(\'failure\')\n  end\n  ```\n\n* <a name="true-as-last-condition"></a>\n  Use `true` as the last condition of the `cond` special form when you need a\n  clause that always matches.\n  <sup>[[link](#true-as-last-condition)]</sup>\n\n  ```elixir\n  # not preferred\n  cond do\n    1 + 2 == 5 ->\n      "Nope"\n\n    1 + 3 == 5 ->\n      "Uh, uh"\n\n    :else ->\n      "OK"\n  end\n\n  # preferred\n  cond do\n    1 + 2 == 5 ->\n      "Nope"\n\n    1 + 3 == 5 ->\n      "Uh, uh"\n\n    true ->\n      "OK"\n  end\n  ```\n\n* <a name="parentheses-and-functions-with-zero-arity"></a>\n  Use parentheses for calls to functions with zero arity, so they can be\n  distinguished from variables.\n  Starting in Elixir 1.4, the compiler will warn you about\n  locations where this ambiguity exists.\n  <sup>[[link](#parentheses-and-functions-with-zero-arity)]</sup>\n\n  ```elixir\n  defp do_stuff, do: ...\n\n  # not preferred\n  def my_func do\n    # is this a variable or a function call?\n    do_stuff\n  end\n\n  # preferred\n  def my_func do\n    # this is clearly a function call\n    do_stuff()\n  end\n  ```\n\n### Naming\n\n* <a name="snake-case"></a>\n  Use `snake_case` for atoms, functions and variables.\n  <sup>[[link](#snake-case)]</sup>\n\n  ```elixir\n  # not preferred\n  :"some atom"\n  :SomeAtom\n  :someAtom\n\n  someVar = 5\n\n  def someFunction do\n    ...\n  end\n\n  # preferred\n  :some_atom\n\n  some_var = 5\n\n  def some_function do\n    ...\n  end\n  ```\n\n* <a name="camel-case"></a>\n  Use `CamelCase` for modules (keep acronyms like HTTP, RFC, XML uppercase).\n  <sup>[[link](#camel-case)]</sup>\n\n  ```elixir\n  # not preferred\n  defmodule Somemodule do\n    ...\n  end\n\n  defmodule Some_Module do\n    ...\n  end\n\n  defmodule SomeXml do\n    ...\n  end\n\n  # preferred\n  defmodule SomeModule do\n    ...\n  end\n\n  defmodule SomeXML do\n    ...\n  end\n  ```\n\n* <a name="predicate-macro-names-with-guards"></a>\n  The name of macros suitable for use in guard expressions should be prefixed\n  with `is_`.\n  For a list of allowed expressions, see the [Guard][Guard Expressions] docs.\n  <sup>[[link](#predicate-macro-names-with-guards)]</sup>\n\n  ```elixir\n  defguard is_cool(var) when var == "cool"\n  defguardp is_very_cool(var) when var == "very cool"\n  ```\n\n* <a name="predicate-macro-names-no-guards"></a>\n  The names of predicate functions _that cannot be used within guards_ should\n  have a trailing question mark (`?`) rather than the `is_` (or similar) prefix.\n  <sup>[[link](#predicate-macro-names-no-guards)]</sup>\n\n  ```elixir\n  def cool?(var) do\n    # Complex check if var is cool not possible in a pure function.\n  end\n  ```\n\n* <a name="private-functions-with-same-name-as-public"></a>\n  Private functions with the same name as public functions should start with\n  `do_`.\n  <sup>[[link](#private-functions-with-same-name-as-public)]</sup>\n\n  ```elixir\n  def sum(list), do: do_sum(list, 0)\n\n  # private functions\n  defp do_sum([], total), do: total\n  defp do_sum([head | tail], total), do: do_sum(tail, head + total)\n  ```\n\n### Comments\n\n* <a name="expressive-code"></a>\n  Write expressive code and try to convey your program\'s intention through\n  control-flow, structure and naming.\n  <sup>[[link](#expressive-code)]</sup>\n\n* <a name="comment-grammar"></a>\n  Comments longer than a word are capitalized, and sentences use punctuation.\n  Use [one space][Sentence Spacing] after periods.\n  <sup>[[link](#comment-grammar)]</sup>\n\n  ```elixir\n  # not preferred\n  # these lowercase comments are missing punctuation\n\n  # preferred\n  # Capitalization example\n  # Use punctuation for complete sentences.\n  ```\n\n* <a name="comment-line-length"></a>\n  Limit comment lines to 100 characters.\n  <sup>[[link](#comment-line-length)]</sup>\n\n#### Comment Annotations\n\n* <a name="annotations"></a>\n  Annotations should usually be written on the line immediately above the\n  relevant code.\n  <sup>[[link](#annotations)]</sup>\n\n* <a name="annotation-keyword"></a>\n  The annotation keyword is uppercase, and is followed by a colon and a space,\n  then a note describing the problem.\n  <sup>[[link](#annotation-keyword)]</sup>\n\n  ```elixir\n  # TODO: Deprecate in v1.5.\n  def some_function(arg), do: {:ok, arg}\n  ```\n\n* <a name="exceptions-to-annotations"></a>\n  In cases where the problem is so obvious that any documentation would be\n  redundant, annotations may be left with no note.\n  This usage should be the exception and not the rule.\n  <sup>[[link](#exceptions-to-annotations)]</sup>\n\n  ```elixir\n  start_task()\n\n  # FIXME\n  Process.sleep(5000)\n  ```\n\n* <a name="todo-notes"></a>\n  Use `TODO` to note missing features or functionality that should be added at a\n  later date.\n  <sup>[[link](#todo-notes)]</sup>\n\n* <a name="fixme-notes"></a>\n  Use `FIXME` to note broken code that needs to be fixed.\n  <sup>[[link](#fixme-notes)]</sup>\n\n* <a name="optimize-notes"></a>\n  Use `OPTIMIZE` to note slow or inefficient code that may cause performance\n  problems.\n  <sup>[[link](#optimize-notes)]</sup>\n\n* <a name="hack-notes"></a>\n  Use `HACK` to note code smells where questionable coding practices were used\n  and should be refactored away.\n  <sup>[[link](#hack-notes)]</sup>\n\n* <a name="review-notes"></a>\n  Use `REVIEW` to note anything that should be looked at to confirm it is\n  working as intended.\n  For example: `REVIEW: Are we sure this is how the client does X currently?`\n  <sup>[[link](#review-notes)]</sup>\n\n* <a name="custom-keywords"></a>\n  Use other custom annotation keywords if it feels appropriate, but be sure to\n  document them in your project\'s `README` or similar.\n  <sup>[[link](#custom-keywords)]</sup>\n\n### Modules\n\n* <a name="one-module-per-file"></a>\n  Use one module per file unless the module is only used internally by another\n  module (such as a test).\n  <sup>[[link](#one-module-per-file)]</sup>\n\n* <a name="underscored-filenames"></a>\n  Use `snake_case` file names for `CamelCase` module names.\n  <sup>[[link](#underscored-filenames)]</sup>\n\n  ```elixir\n  # file is called some_module.ex\n\n  defmodule SomeModule do\n  end\n  ```\n\n* <a name="module-name-nesting"></a>\n  Represent each level of nesting within a module name as a directory.\n  <sup>[[link](#module-name-nesting)]</sup>\n\n  ```elixir\n  # file is called parser/core/xml_parser.ex\n\n  defmodule Parser.Core.XMLParser do\n  end\n  ```\n\n* <a name="module-attribute-ordering"></a>\n  List module attributes and directives in the following order:\n  <sup>[[link](#module-attribute-ordering)]</sup>\n\n  1. `@moduledoc`\n  1. `@behaviour`\n  1. `use`\n  1. `import`\n  1. `alias`\n  1. `require`\n  1. `@module_attribute`\n  1. `defstruct`\n  1. `@type`\n  1. `@callback`\n  1. `@macrocallback`\n  1. `@optional_callbacks`\n\n  Add a blank line between each grouping, and sort the terms (like module names)\n  alphabetically.\n  Here\'s an overall example of how you should order things in your modules:\n\n  ```elixir\n  defmodule MyModule do\n    @moduledoc """\n    An example module\n    """\n\n    @behaviour MyBehaviour\n\n    use GenServer\n\n    import Something\n    import SomethingElse\n\n    alias My.Long.Module.Name\n    alias My.Other.Module.Example\n\n    require Integer\n\n    @module_attribute :foo\n    @other_attribute 100\n\n    defstruct [:name, params: []]\n\n    @type params :: [{binary, binary}]\n\n    @callback some_function(term) :: :ok | {:error, term}\n\n    @macrocallback macro_name(term) :: Macro.t()\n\n    @optional_callbacks macro_name: 1\n\n    ...\n  end\n  ```\n\n* <a name="module-pseudo-variable"></a>\n  Use the `__MODULE__` pseudo variable when a module refers to itself. This\n  avoids having to update any self-references when the module name changes.\n  <sup>[[link](#module-pseudo-variable)]</sup>\n\n  ```elixir\n  defmodule SomeProject.SomeModule do\n    defstruct [:name]\n\n    def name(%__MODULE__{name: name}), do: name\n  end\n  ```\n\n* <a name="alias-self-referencing-modules"></a>\n  If you want a prettier name for a module self-reference, set up an alias.\n  <sup>[[link](#alias-self-referencing-modules)]</sup>\n\n  ```elixir\n  defmodule SomeProject.SomeModule do\n    alias __MODULE__, as: SomeModule\n\n    defstruct [:name]\n\n    def name(%SomeModule{name: name}), do: name\n  end\n  ```\n\n* <a name="repetitive-module-names"></a>\n  Avoid repeating fragments in module names and namespaces.\n  This improves overall readability and\n  eliminates [ambiguous aliases][Conflicting Aliases].\n  <sup>[[link](#repetitive-module-names)]</sup>\n\n  ```elixir\n  # not preferred\n  defmodule Todo.Todo do\n    ...\n  end\n\n  # preferred\n  defmodule Todo.Item do\n    ...\n  end\n  ```\n\n### Documentation\n\nDocumentation in Elixir (when read either in `iex` with `h` or generated with\n[ExDoc]) uses the [Module Attributes] `@moduledoc` and `@doc`.\n\n* <a name="moduledocs"></a>\n  Always include a `@moduledoc` attribute in the line right after `defmodule` in\n  your module.\n  <sup>[[link](#moduledocs)]</sup>\n\n  ```elixir\n  # not preferred\n\n  defmodule AnotherModule do\n    use SomeModule\n\n    @moduledoc """\n    About the module\n    """\n    ...\n  end\n\n  # preferred\n\n  defmodule AThirdModule do\n    @moduledoc """\n    About the module\n    """\n\n    use SomeModule\n    ...\n  end\n  ```\n\n* <a name="moduledoc-false"></a>\n  Use `@moduledoc false` if you do not intend on documenting the module.\n  <sup>[[link](#moduledoc-false)]</sup>\n\n  ```elixir\n  defmodule SomeModule do\n    @moduledoc false\n    ...\n  end\n  ```\n\n* <a name="moduledoc-spacing"></a>\n  Separate code after the `@moduledoc` with a blank line.\n  <sup>[[link](#moduledoc-spacing)]</sup>\n\n  ```elixir\n  # not preferred\n  defmodule SomeModule do\n    @moduledoc """\n    About the module\n    """\n    use AnotherModule\n  end\n\n  # preferred\n  defmodule SomeModule do\n    @moduledoc """\n    About the module\n    """\n\n    use AnotherModule\n  end\n  ```\n\n* <a name="heredocs"></a>\n  Use heredocs with markdown for documentation.\n  <sup>[[link](#heredocs)]</sup>\n\n  ```elixir\n  # not preferred\n  defmodule SomeModule do\n    @moduledoc "About the module"\n  end\n\n  defmodule SomeModule do\n    @moduledoc """\n    About the module\n\n    Examples:\n    iex> SomeModule.some_function\n    :result\n    """\n  end\n\n  # preferred\n  defmodule SomeModule do\n    @moduledoc """\n    About the module\n\n    ## Examples\n\n        iex> SomeModule.some_function\n        :result\n    """\n  end\n  ```\n\n### Typespecs\n\nTypespecs are notation for declaring types and specifications, for\ndocumentation or for the static analysis tool Dialyzer.\n\nCustom types should be defined at the top of the module with the other\ndirectives (see [Modules](#modules)).\n\n* <a name="typedocs"></a>\n  Place `@typedoc` and `@type` definitions together, and separate each\n  pair with a blank line.\n  <sup>[[link](#typedocs)]</sup>\n\n  ```elixir\n  defmodule SomeModule do\n    @moduledoc false\n\n    @typedoc "The name"\n    @type name :: atom\n\n    @typedoc "The result"\n    @type result :: {:ok, term} | {:error, term}\n\n    ...\n  end\n  ```\n\n* <a name="union-types"></a>\n  If a union type is too long to fit on a single line, put each part of the\n  type on a separate line, indented one level past the name of the type.\n  <sup>[[link](#union-types)]</sup>\n\n  ```elixir\n  # not preferred\n  @type long_union_type ::\n          some_type | another_type | some_other_type | one_more_type | a_final_type\n\n  # preferred\n  @type long_union_type ::\n          some_type\n          | another_type\n          | some_other_type\n          | one_more_type\n          | a_final_type\n  ```\n\n* <a name="naming-main-types"></a>\n  Name the main type for a module `t`, for example: the type specification for a\n  struct.\n  <sup>[[link](#naming-main-types)]</sup>\n\n  ```elixir\n  defstruct [:name, params: []]\n\n  @type t :: %__MODULE__{\n          name: String.t() | nil,\n          params: Keyword.t()\n        }\n  ```\n\n* <a name="spec-spacing"></a>\n  Place specifications right before the function definition,\n  after the `@doc`,\n  without separating them by a blank line.\n  <sup>[[link](#spec-spacing)]</sup>\n\n  ```elixir\n  @doc """\n  Some function description.\n  """\n  @spec some_function(term) :: result\n  def some_function(some_data) do\n    {:ok, some_data}\n  end\n  ```\n\n### Structs\n\n* <a name="nil-struct-field-defaults"></a>\n  Use a list of atoms for struct fields that default to `nil`, followed by the\n  other keywords.\n  <sup>[[link](#nil-struct-field-defaults)]</sup>\n\n  ```elixir\n  # not preferred\n  defstruct name: nil, params: nil, active: true\n\n  # preferred\n  defstruct [:name, :params, active: true]\n  ```\n\n* <a name="struct-def-brackets"></a>\n  Omit square brackets when the argument of a `defstruct` is a keyword list.\n  <sup>[[link](#struct-def-brackets)]</sup>\n\n  ```elixir\n  # not preferred\n  defstruct [params: [], active: true]\n\n  # preferred\n  defstruct params: [], active: true\n\n  # required - brackets are not optional, with at least one atom in the list\n  defstruct [:name, params: [], active: true]\n  ```\n\n* <a name="multiline-structs"></a>\n  If a struct definition spans multiple lines, put each element on its own line,\n  keeping the elements aligned.\n  <sup>[[link](#multiline-structs)]</sup>\n\n  ```elixir\n  defstruct foo: "test",\n            bar: true,\n            baz: false,\n            qux: false,\n            quux: 1\n  ```\n\n  If a multiline struct requires brackets, format it as a multiline list:\n\n  ```elixir\n  defstruct [\n    :name,\n    params: [],\n    active: true\n  ]\n  ```\n\n### Exceptions\n\n* <a name="exception-names"></a>\n  Make exception names end with a trailing `Error`.\n  <sup>[[link](#exception-names)]</sup>\n\n  ```elixir\n  # not preferred\n  defmodule BadHTTPCode do\n    defexception [:message]\n  end\n\n  defmodule BadHTTPCodeException do\n    defexception [:message]\n  end\n\n  # preferred\n  defmodule BadHTTPCodeError do\n    defexception [:message]\n  end\n  ```\n\n* <a name="lowercase-error-messages"></a>\n  Use lowercase error messages when raising exceptions, with no trailing\n  punctuation.\n  <sup>[[link](#lowercase-error-messages)]</sup>\n\n  ```elixir\n  # not preferred\n  raise ArgumentError, "This is not valid."\n\n  # preferred\n  raise ArgumentError, "this is not valid"\n  ```\n\n### Collections\n\n* <a name="keyword-list-syntax"></a>\n  Always use the special syntax for keyword lists.\n  <sup>[[link](#keyword-list-syntax)]</sup>\n\n  ```elixir\n  # not preferred\n  some_value = [{:a, "baz"}, {:b, "qux"}]\n\n  # preferred\n  some_value = [a: "baz", b: "qux"]\n  ```\n\n* <a name="map-key-atom"></a>\n  Use the shorthand key-value syntax for maps when all of the keys are atoms.\n  <sup>[[link](#map-key-atom)]</sup>\n\n  ```elixir\n  # not preferred\n  %{:a => 1, :b => 2, :c => 0}\n\n  # preferred\n  %{a: 1, b: 2, c: 3}\n  ```\n\n* <a name="map-key-arrow"></a>\n  Use the verbose key-value syntax for maps if any key is not an atom.\n  <sup>[[link](#map-key-arrow)]</sup>\n\n  ```elixir\n  # not preferred\n  %{"c" => 0, a: 1, b: 2}\n\n  # preferred\n  %{:a => 1, :b => 2, "c" => 0}\n  ```\n\n### Strings\n\n* <a name="strings-matching-with-concatenator"></a>\n  Match strings using the string concatenator rather than binary patterns:\n  <sup>[[link](#strings-matching-with-concatenator)]</sup>\n\n  ```elixir\n  # not preferred\n  <<"my"::utf8, _rest::bytes>> = "my string"\n\n  # preferred\n  "my" <> _rest = "my string"\n  ```\n\n### Regular Expressions\n\n_No guidelines for regular expressions have been added yet._\n\n### Metaprogramming\n\n* <a name="avoid-metaprogramming"></a>\n  Avoid needless metaprogramming.\n  <sup>[[link](#avoid-metaprogramming)]</sup>\n\n### Testing\n\n* <a name="testing-assert-order"></a>\n  When writing [ExUnit] assertions, put the expression being tested to the left\n  of the operator, and the expected result to the right, unless the assertion is\n  a pattern match.\n  <sup>[[link](#testing-assert-order)]</sup>\n\n  ```elixir\n  # preferred\n  assert actual_function(1) == true\n\n  # not preferred\n  assert true == actual_function(1)\n\n  # required - the assertion is a pattern match\n  assert {:ok, expected} = actual_function(3)\n  ```\n\n## Resources\n\n### Alternative Style Guides\n\n* [Aleksei Magusev\'s Elixir Style Guide](https://github.com/lexmag/elixir-style-guide#readme)\n  \xe2\x80\x94 An opinionated Elixir style guide stemming from the coding style practiced\n  in the Elixir core libraries.\n  Developed by [Aleksei Magusev](https://github.com/lexmag) and\n  [Andrea Leopardi](https://github.com/whatyouhide), members of Elixir core team.\n  While the Elixir project doesn\'t adhere to any specific style guide,\n  this is the closest available guide to its conventions.\n\n* [Credo\'s Elixir Style Guide](https://github.com/rrrene/elixir-style-guide#readme)\n  \xe2\x80\x94 Style Guide for the Elixir language, implemented by\n  [Credo](http://credo-ci.org) static code analysis tool.\n\n### Tools\n\nRefer to [Awesome Elixir][Code Analysis] for libraries and tools that can help\nwith code analysis and style linting.\n\n## Getting Involved\n\n### Contributing\n\nIt\'s our hope that this will become a central hub for community discussion on\nbest practices in Elixir.\nFeel free to open tickets or send pull requests with improvements.\nThanks in advance for your help!\n\nCheck the [contributing guidelines][Contributing] for more information.\n\n### Spread the Word\n\nA community style guide is meaningless without the community\'s support. Please\ntweet, [star][Stargazers], and let any Elixir programmer know\nabout [this guide][Elixir Style Guide] so they can contribute.\n\n## Copying\n\n### License\n\n![Creative Commons License](http://i.creativecommons.org/l/by/3.0/88x31.png)\nThis work is licensed under a\n[Creative Commons Attribution 3.0 Unported License][License]\n\n### Attribution\n\nThe structure of this guide, bits of example code, and many of the initial\npoints made in this document were borrowed from the [Ruby community style guide].\nA lot of things were applicable to Elixir and allowed us to get _some_ document\nout quicker to start the conversation.\n\nHere\'s the [list of people who have kindly contributed][Contributors] to this\nproject.\n\n<!-- Links -->\n[Chinese Simplified]: https://github.com/geekerzp/elixir_style_guide/blob/master/README-zhCN.md\n[Chinese Traditional]: https://github.com/elixirtw/elixir_style_guide/blob/master/README_zhTW.md\n[Code Analysis]: https://github.com/h4cc/awesome-elixir#code-analysis\n[Code Of Conduct]: https://github.com/elixir-lang/elixir/blob/master/CODE_OF_CONDUCT.md\n[Code Formatter]: https://hexdocs.pm/elixir/Code.html#format_string!/2\n[Conflicting Aliases]: https://elixirforum.com/t/using-aliases-for-fubar-fubar-named-module/1723\n[Contributing]: https://github.com/christopheradams/elixir_style_guide/blob/master/CONTRIBUTING.md\n[Contributors]: https://github.com/christopheradams/elixir_style_guide/graphs/contributors\n[Elixir Style Guide]: https://github.com/christopheradams/elixir_style_guide\n[Elixir]: http://elixir-lang.org\n[ExDoc]: https://github.com/elixir-lang/ex_doc\n[ExUnit]: https://hexdocs.pm/ex_unit/ExUnit.html\n[French]: https://github.com/ronanboiteau/elixir_style_guide/blob/master/README_frFR.md\n[Guard Expressions]: https://hexdocs.pm/elixir/guards.html#list-of-allowed-expressions\n[Hex]: https://hex.pm/packages\n[Japanese]: https://github.com/kenichirow/elixir_style_guide/blob/master/README-jaJP.md\n[Korean]: https://github.com/marocchino/elixir_style_guide/blob/new-korean/README-koKR.md\n[License]: http://creativecommons.org/licenses/by/3.0/deed.en_US\n[Mix format]: https://hexdocs.pm/mix/Mix.Tasks.Format.html\n[Module Attributes]: http://elixir-lang.org/getting-started/module-attributes.html#as-annotations\n[Portuguese]: https://github.com/gusaiani/elixir_style_guide/blob/master/README_ptBR.md\n[Ruby community style guide]: https://github.com/bbatsov/ruby-style-guide\n[Sentence Spacing]: http://en.wikipedia.org/wiki/Sentence_spacing\n[Spanish]: https://github.com/albertoalmagro/elixir_style_guide/blob/spanish/README_esES.md\n[Stargazers]: https://github.com/christopheradams/elixir_style_guide/stargazers\n'