b'# gRPC Elixir\n\n[![Hex.pm](https://img.shields.io/hexpm/v/grpc.svg)](https://hex.pm/packages/grpc)\n[![Build Status](https://travis-ci.org/elixir-grpc/grpc.svg?branch=master)](https://travis-ci.org/elixir-grpc/grpc)\n[![Inline docs](http://inch-ci.org/github/elixir-grpc/grpc.svg?branch=master)](http://inch-ci.org/github/elixir-grpc/grpc)\n\nAn Elixir implementation of [gRPC](http://www.grpc.io/).\n\n**WARNING: Be careful to use it in production! Test and benchmark in advance.**\n\n**NOTICE: Erlang/OTP needs >= 20.3.2**\n\n## Installation\n\nThe package can be installed as:\n\n  1. Add `grpc` to your list of dependencies in `mix.exs`:\n\n      ```elixir\n      def deps do\n        [{:grpc, github: "elixir-grpc/grpc"}]\n      end\n      ```\n\n  2. (Before Elixir 1.4)Ensure `grpc` is started before your application:\n\n      ```elixir\n      def application do\n        [applications: [:grpc]]\n      end\n      ```\n\n## Usage\n\n1. Generate Elixir code from proto file as [protobuf-elixir](https://github.com/tony612/protobuf-elixir#usage) shows(especially the `gRPC Support` section).\n2. Implement the server side code like below and remember to return the expected message types.\n```elixir\ndefmodule Helloworld.Greeter.Server do\n  use GRPC.Server, service: Helloworld.Greeter.Service\n\n  @spec say_hello(Helloworld.HelloRequest.t, GRPC.Server.Stream.t) :: Helloworld.HelloReply.t\n  def say_hello(request, _stream) do\n    Helloworld.HelloReply.new(message: "Hello #{request.name}")\n  end\nend\n```\n\n3. Start the server\n\nYou can start the gRPC server as a supervised process. First, add `GRPC.Server.Supervisor` to your supervision tree.\n\n```elixir\n# Define your endpoint\ndefmodule Helloworld.Endpoint do\n  use GRPC.Endpoint\n\n  intercept GRPC.Logger.Server\n  run Helloworld.Greeter.Server\nend\n\n# In the start function of your Application\ndefmodule HelloworldApp do\n  use Application\n  def start(_type, _args) do\n    children = [\n      # ...\n      supervisor(GRPC.Server.Supervisor, [{Helloworld.Endpoint, 50051}])\n    ]\n\n    opts = [strategy: :one_for_one, name: YourApp]\n    Supervisor.start_link(children, opts)\n  end\nend\n```\n\nThen start it when starting your application:\n\n```elixir\n# config.exs\nconfig :grpc, start_server: true\n\n# test.exs\nconfig :grpc, start_server: false\n\n$ iex -S mix\n```\n\nor run grpc.server using a mix task\n\n```\n$ mix grpc.server\n```\n\n4. Call rpc:\n```elixir\niex> {:ok, channel} = GRPC.Stub.connect("localhost:50051")\niex> request = Helloworld.HelloRequest.new(name: "grpc-elixir")\niex> {:ok, reply} = channel |> Helloworld.Greeter.Stub.say_hello(request)\n\n# With interceptors\niex> {:ok, channel} = GRPC.Stub.connect("localhost:50051", interceptors: [GRPC.Logger.Client])\n...\n```\n\nCheck [examples](examples) and [interop](interop)(Interoperability Test) for some examples.\n\n## TODO\n\n- [x] Unary RPC\n- [x] Server streaming RPC\n- [x] Client streaming RPC\n- [x] Bidirectional streaming RPC\n- [x] Helloworld and RouteGuide examples\n- [x] Doc and more tests\n- [x] Authentication with TLS\n- [x] Improve code generation from protos ([protobuf-elixir](https://github.com/tony612/protobuf-elixir) [#8](https://github.com/elixir-grpc/grpc/issues/8))\n- [x] Timeout for unary calls\n- [x] Errors handling\n- [x] Benchmarking\n- [x] Logging\n- [x] Interceptors(See `GRPC.Endpoint`)\n- [x] [Connection Backoff](https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md)\n- [x] Data compression\n- [x] Support other encoding(other than protobuf)\n\n## Benchmark\n\n1. [Simple benchmark](examples/helloworld/README.md#Benchmark) by using [ghz](https://ghz.sh/)\n\n2. [Benchmark](benchmark) followed by official spec\n\n## Sponsors\n\nThis project is being sponsored by [Tubi](https://tubitv.com/). Thank you!\n\n<img src="https://user-images.githubusercontent.com/1253659/37473536-4db44048-28a9-11e8-90d5-f8a2f5a8d53c.jpg" height="80">\n\n## Contributing\n\nYou contributions are welcome!\n\nPlease open issues if you have questions, problems and ideas. You can create pull\nrequests directly if you want to fix little bugs, add small features and so on.\nBut you\'d better use issues first if you want to add a big feature or change a\nlot of code.\n'