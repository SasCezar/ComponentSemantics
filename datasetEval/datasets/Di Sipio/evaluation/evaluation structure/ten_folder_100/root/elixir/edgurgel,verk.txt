b'![Verk](https://i.imgur.com/unSd0Zr.png)\n#  [![Build Status](https://travis-ci.org/edgurgel/verk.svg?branch=master)](https://travis-ci.org/edgurgel/verk) [![Hex pm](http://img.shields.io/hexpm/v/verk.svg?style=flat)](https://hex.pm/packages/verk) [![Coverage Status](https://coveralls.io/repos/edgurgel/verk/badge.svg?branch=master&service=github)](https://coveralls.io/github/edgurgel/verk?branch=master) [![hex.pm downloads](https://img.shields.io/hexpm/dt/verk.svg?style=flat)](https://hex.pm/packages/verk)\n\n> This README follows master, which may differ from the last version. Check [here](https://github.com/edgurgel/verk/tree/v1.6.3) for the README related to the last version.\n\nVerk is a job processing system backed by Redis. It uses the same job definition of Sidekiq/Resque.\n\nThe goal is to be able to isolate the execution of a queue of jobs as much as possible.\n\nEvery queue has its own supervision tree:\n\n* A pool of workers;\n* A `QueueManager` that interacts with Redis to get jobs and enqueue them back to be retried if necessary;\n* A `WorkersManager` that will interact with the `QueueManager` and the pool to execute jobs.\n\nVerk will hold one connection to Redis per queue plus one dedicated to the `ScheduleManager` and a pool of connections for other use cases like deleting a job from retry set or enqueuing new jobs.\n\nThe `ScheduleManager` fetches jobs from the `retry` set to be enqueued back to the original queue when it\'s ready to be retried.\n\nIt also has one GenStage producer called `Verk.EventProducer`.\n\nThe image below is an overview of Verk\'s supervision tree running with two queues named `queue_one` and `queue_two` each with 5 workers.\n\n![Supervision Tree](https://i.imgur.com/AeOsKio.png)\n\nFeature set:\n\n* Retry mechanism with exponential backoff\n* Dynamic addition/removal of queues\n* Reliable job processing using Redis Streams!\n* Error and event tracking\n\n## Installation\n\nFirst, add Verk to your `mix.exs` dependencies:\n\n```elixir\ndef deps do\n  [{:verk, "~> 1.0"}]\nend\n```\n\nand run `$ mix deps.get`.\n\nAdd `Verk.Supervisor` to your supervision tree:\n\n```elixir\ndefmodule Example.App do\n  use Application\n\n  def start(_type, _args) do\n    import Supervisor.Spec\n    tree = [supervisor(Verk.Supervisor, [])]\n    opts = [name: Simple.Sup, strategy: :one_for_one]\n    Supervisor.start_link(tree, opts)\n  end\nend\n```\n\nFinally we need to configure how Verk will process jobs.\n\n## Configuration\n\nExample configuration for Verk having 2 queues: `default` and `priority`\n\nThe queue `default` will have a maximum of 25 jobs being processed at a time and `priority` just 10.\n\n```elixir\nconfig :verk, queues: [default: 25, priority: 10],\n              max_retry_count: 10,\n              max_dead_jobs: 100,\n              poll_interval: 5000,\n              start_job_log_level: :info,\n              done_job_log_level: :info,\n              fail_job_log_level: :info,\n              node_id: "1",\n              redis_url: "redis://127.0.0.1:6379"\n```\n\nVerk supports the convention `{:system, "ENV_NAME", default}` for reading environment configuration at runtime using [Confex](https://hexdocs.pm/confex/readme.html):\n\n```elixir\nconfig :verk, queues: [default: 25, priority: 10],\n              max_retry_count: 10,\n              max_dead_jobs: 100,\n              poll_interval: {:system, :integer, "VERK_POLL_INTERVAL", 5000},\n              start_job_log_level: :info,\n              done_job_log_level: :info,\n              fail_job_log_level: :info,\n              node_id: "1",\n              redis_url: {:system, "VERK_REDIS_URL", "redis://127.0.0.1:6379"}\n```\n\nNow Verk is ready to start processing jobs! :tada:\n\n## Workers\n\nA job is defined by a module and arguments:\n\n```elixir\ndefmodule ExampleWorker do\n  def perform(arg1, arg2) do\n    arg1 + arg2\n  end\nend\n```\n\nThis job can be enqueued using `Verk.enqueue/1`:\n\n```elixir\nVerk.enqueue(%Verk.Job{queue: :default, class: "ExampleWorker", args: [1,2], max_retry_count: 5})\n```\n\nThis job can also be scheduled using `Verk.schedule/2`:\n\n ```elixir\n perform_at = Timex.shift(Timex.now, seconds: 30)\n Verk.schedule(%Verk.Job{queue: :default, class: "ExampleWorker", args: [1,2]}, perform_at)\n ```\n\n### Retry at\n\nA job can define the function `retry_at/2` for custom retry time delay:\n\n```elixir\ndefmodule ExampleWorker do\n  def perform(arg1, arg2) do\n    arg1 + arg2\n  end\n\n  def retry_at(failed_at, retry_count) do\n    failed_at + retry_count\n  end\nend\n```\n\nIn this example, the first retry will be scheduled a second later,\nthe second retry will be scheduled two seconds later, and so on.\n\nIf `retry_at/2` is not defined the default exponential backoff is used.\n\n### Keys in arguments\n\nBy default, Verk will decode keys in arguments to binary strings.\nYou can change this behavior for jobs enqueued by Verk with the following configuration:\n```elixir\nconfig :verk, :args_keys, value\n```\n\nThe following values are valid:\n\n* `:strings` (default) - decodes keys as binary strings\n* `:atoms` - keys are converted to atoms using `String.to_atom/1`\n* `:atoms!` - keys are converted to atoms using `String.to_existing_atom/1`\n\n\n## Queues\n\nIt\'s possible to dynamically add and remove queues from Verk.\n\n```elixir\nVerk.add_queue(:new, 10) # Adds a queue named `new` with 10 workers\n```\n\n```elixir\nVerk.remove_queue(:new) # Terminate and delete the queue named `new`\n```\n\n## Reliability\n\nVerk\'s goal is to never have a job that exists only in memory. It uses Redis as the single source of truth to retry and track jobs that were being processed if some crash happened.\n\nVerk will re-enqueue jobs if the application crashed while jobs were running. It will also retry jobs that failed keeping track of the errors that happened.\n\nThe jobs that will run on top of Verk should be idempotent as they may run more than once.\n\n## Error tracking\n\nOne can track when jobs start and finish or fail. This can be useful to build metrics around the jobs. The `QueueStats` handler does some kind of metrics using these events: https://github.com/edgurgel/verk/blob/master/lib/verk/queue_stats.ex\n\nVerk has an Event Manager that notifies the following events:\n\n* `Verk.Events.JobStarted`\n* `Verk.Events.JobFinished`\n* `Verk.Events.JobFailed`\n* `Verk.Events.QueueRunning`\n* `Verk.Events.QueuePausing`\n* `Verk.Events.QueuePaused`\n\nOne can define an error tracking handler like this:\n\n```elixir\ndefmodule TrackingErrorHandler do\n  use GenStage\n\n  def start_link() do\n    GenStage.start_link(__MODULE__, :ok)\n  end\n\n  def init(_) do\n    filter = fn event -> event.__struct__ == Verk.Events.JobFailed end\n    {:consumer, :state, subscribe_to: [{Verk.EventProducer, selector: filter}]}\n  end\n\n  def handle_events(events, _from, state) do\n    Enum.each(events, &handle_event/1)\n    {:noreply, [], state}\n  end\n\n  defp handle_event(%Verk.Events.JobFailed{job: job, failed_at: failed_at, stacktrace: trace}) do\n    MyTrackingExceptionSystem.track(stacktrace: trace, name: job.class)\n  end\nend\n```\n\nNotice the selector to get just the type JobFailed. If no selector is set every event is sent.\n\nThen adding the consumer to your supervision tree:\n\n  ```elixir\n  defmodule Example.App do\n    use Application\n\n    def start(_type, _args) do\n      import Supervisor.Spec\n      tree = [supervisor(Verk.Supervisor, []),\n              worker(TrackingErrorHandler, [])]\n      opts = [name: Simple.Sup, strategy: :one_for_one]\n      Supervisor.start_link(tree, opts)\n    end\n  end\n  ```\n\n## Dashboard ?\n\nCheck [Verk Web](https://github.com/edgurgel/verk_web)!\n\n![Dashboard](http://i.imgur.com/LsDKIVT.png)\n\n## Metrics ?\n\nCheck [Verk Stats](https://github.com/edgurgel/verk-stats)\n\n## Sponsorship\n\nInitial development sponsored by [Carnival.io](http://carnival.io)\n'