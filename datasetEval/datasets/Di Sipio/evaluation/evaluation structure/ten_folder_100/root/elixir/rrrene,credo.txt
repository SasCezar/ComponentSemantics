b'# Credo [![Build Status](https://travis-ci.org/rrrene/credo.svg?branch=master)](https://travis-ci.org/rrrene/credo) [![Inline docs](https://inch-ci.org/github/rrrene/credo.svg?branch=master)](https://inch-ci.org/github/rrrene/credo) [![Hex Version](https://img.shields.io/hexpm/v/credo.svg)](https://hex.pm/packages/credo) [![ElixirWeekly](https://img.shields.io/badge/featured-ElixirWeekly-a054ff.svg)](https://elixirweekly.net)\n\nCredo is a static code analysis tool for the Elixir language with a focus on teaching and code consistency.\n\nIt implements [its own style guide](https://github.com/rrrene/elixir-style-guide).\n\n## What can it do?\n\n`credo` can show you refactoring opportunities in your code, complex code fragments, warn you about common mistakes, show inconsistencies in your naming scheme and - if needed - help you enforce a desired coding style.\n\nIf you are a Rubyist it is best described as an opinionated mix between [Inch](https://github.com/rrrene/inch) and [Rubocop](https://github.com/bbatsov/rubocop).\n\n\n![Credo](https://raw.github.com/rrrene/credo/master/assets/screenshot.png)\n\n\n## Installation\n\nThe easiest way to add Credo to your project is by [using Mix](http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html).\n\nAdd `:credo` as a dependency to your project\'s `mix.exs`:\n\n```elixir\ndefp deps do\n  [\n    {:credo, "~> 1.1.0", only: [:dev, :test], runtime: false}\n  ]\nend\n```\n\nAnd run:\n\n    $ mix deps.get\n\n\n\n## Basic Usage\n\nTo run credo in the current project, **just type**:\n\n    $ mix credo\n\nThis will run the code analysis and suggest places to edit your code.\n\n**If you want to enforce a style guide** and need a more traditional linting experience, try\n\n    $ mix credo --strict\n\nand continue reading in the Configuration section.\n\n\n\nIf you want the **list of issues grouped by files** instead of suggestions just type:\n\n    $ mix credo list\n\nYou will get output like this:\n\n    \xe2\x94\x83 Refactoring opportunities\n    \xe2\x94\x83\n    \xe2\x94\x83 [R] \xe2\x86\x97 If/else blocks should not have a negated condition in `if`.\n    \xe2\x94\x83       lib/phoenix/channel.ex:26 (Phoenix.Channel.subscribe)\n    \xe2\x94\x83 [R] \xe2\x86\x92 Function is too complex (max ABC is 15, was 43).\n    \xe2\x94\x83       lib/phoenix/router.ex:563:8 (Phoenix.Router.add_resources)\n    \xe2\x94\x83 [R] \xe2\x86\x92 Function is too complex (max ABC is 15, was 16).\n    \xe2\x94\x83       lib/phoenix/router/socket.ex:12:12 (Phoenix.Router.Socket.channel)\n    \xe2\x94\x83\n\nNow you might want to know more about that particular entry, **just copy the filename+line-number combo into the command**:\n\n    $ mix credo lib/phoenix/channel.ex:26\n\n    \xe2\x94\x83 Phoenix.Channel\n    \xe2\x94\x83\n    \xe2\x94\x83   [R] Category: refactor\n    \xe2\x94\x83    \xe2\x86\x97  Priority: medium\n    \xe2\x94\x83\n    \xe2\x94\x83       If/else blocks should not have a negated condition in `if`.\n    \xe2\x94\x83       lib/phoenix/channel.ex:26 (Phoenix.Channel.subscribe)\n    \xe2\x94\x83\n    \xe2\x94\x83    __ CODE IN QUESTION\n    \xe2\x94\x83\n    \xe2\x94\x83       if !Socket.authenticated?(socket, channel, topic) do\n    \xe2\x94\x83\n    \xe2\x94\x83    __ WHY IT MATTERS\n    \xe2\x94\x83\n    \xe2\x94\x83       An `if` block with a negated condition should not contain an else block.\n    \xe2\x94\x83\n    \xe2\x94\x83       So while this is fine:\n    \xe2\x94\x83\n    \xe2\x94\x83           if !allowed? do\n    \xe2\x94\x83             raise "Not allowed!"\n    \xe2\x94\x83           end\n    \xe2\x94\x83\n    \xe2\x94\x83       The code in this example ...\n    \xe2\x94\x83\n    \xe2\x94\x83           if !allowed? do\n    \xe2\x94\x83             raise "Not allowed!"\n    \xe2\x94\x83           else\n    \xe2\x94\x83             proceed_as_planned\n    \xe2\x94\x83           end\n    \xe2\x94\x83\n    \xe2\x94\x83       ... should be refactored to look like this:\n    \xe2\x94\x83\n    \xe2\x94\x83           if allowed? do\n    \xe2\x94\x83             proceed_as_planned\n    \xe2\x94\x83           else\n    \xe2\x94\x83             raise "Not allowed!"\n    \xe2\x94\x83           end\n    \xe2\x94\x83\n    \xe2\x94\x83       The reason for this is not a technical but a human one. It is easier to wrap\n    \xe2\x94\x83       your head around a positive condition and then thinking "and else we do ...".\n    \xe2\x94\x83\n    \xe2\x94\x83       In the above example raising the error in case something is not allowed\n    \xe2\x94\x83       might seem so important to put it first. But when you revisit this code a\n    \xe2\x94\x83       while later or have to introduce a colleague to it, you might be surprised\n    \xe2\x94\x83       how much clearer things get when the "happy path" comes first.\n\n\n\n## Configuration\n\n\n### Configuration via .credo.exs\n\nCredo is configured via a file called `.credo.exs`. This file can live in your project\'s `config/` or root folder, both is fine.\n\nThis also works for umbrella projects, where you can have individual `.credo.exs` files for each app or a global one in the umbrella\'s `config/` or root folder.\n\n```elixir\n# config/.credo.exs\n%{\n  configs: [\n    %{\n      name: "default",\n      files: %{\n        included: ["lib/", "src/", "web/", "apps/"],\n        excluded: []\n      },\n      checks: [\n        {Credo.Check.Consistency.TabsOrSpaces},\n\n        # For some checks, like AliasUsage, you can only customize the priority\n        # Priority values are: `low, normal, high, higher`\n        {Credo.Check.Design.AliasUsage, priority: :low},\n\n        # For others you can also set parameters\n        {Credo.Check.Readability.MaxLineLength, priority: :low, max_length: 80},\n\n        # You can also customize the exit_status of each check.\n        # If you don\'t want TODO comments to cause `mix credo` to fail, just\n        # set this value to 0 (zero).\n        {Credo.Check.Design.TagTODO, exit_status: 2},\n\n        # To deactivate a check:\n        # Put `false` as second element:\n        {Credo.Check.Design.TagFIXME, false},\n\n        # ... several checks omitted for readability ...\n      ]\n    }\n  ]\n}\n```\n\n`mix credo --config-name <NAME_OF_CONFIG>` allows you to use a specific config (instead of `default`) inside a config file.\n\n`mix credo --config-file <PATH_TO_CONFIG_FILE>` let\'s you use a specific config file.\n\nFinally, you can use `mix credo gen.config` to generate a complete example configuration.\n\n\n### Inline Configuration via Config Comments\n\nUsers of Credo can now disable individual lines or files for all or just\nspecific checks.\n\n```elixir\ndefp do_stuff() do\n  # credo:disable-for-next-line\n  IO.inspect {:we_want_this_inspect_in_production!}\nend\n```\n\nThere are four config comments:\n\n* `# credo:disable-for-this-file` - to disable for the entire file\n* `# credo:disable-for-next-line` - to disable for the next line\n* `# credo:disable-for-previous-line` - to disable for the previous line\n* `# credo:disable-for-lines:<count>` - to disable for the given number of lines (negative for previous lines)\n\nEach of these can also take the name of the check you want to disable:\n\n```elixir\ndefp my_fun() do\n  # credo:disable-for-next-line Credo.Check.Warning.IoInspect\n  IO.inspect {:we_want_this_inspect_in_production!}\nend\n```\n\nLastly, you can put a regular expression (`/.+/`) instead of a check name to disable multiple checks (or if you do not want to type out the checks):\n\n```elixir\ndefp my_fun() do\n  # credo:disable-for-next-line /\\.Warning\\./\n  IO.inspect {:we_want_this_inspect_in_production!}\nend\n```\n\n\n## Exit Status\n\nCredo fails with an exit status != 0 if it shows any issues. This enables shell based pipeline workflows (e.g. on CI systems) which test Credo compliance.\n\nThe exit status of each check is used to construct a bit map of the types of\nissues which were encountered by or-ing them together to produce the final\nresult:\n\n```elixir\nuse Bitwise\n\nissues\n|> Enum.map(&(&1.exit_status))\n|> Enum.reduce(0, &(&1 ||| &2))\n```\n\nThis way you can reason about the encountered issues right from the exit status.\n\nDefault values for the checks are based on their category:\n\n    consistency:  1\n    design:       2\n    readability:  4\n    refactor:     8\n    warning:     16\n\nSo an exit status of 12 tells you that you have only Readability Issues and Refactoring Opportunities, but e.g. no Warnings.\n\n\n## Commands\n\n### suggest (default command)\n\n`suggest` is the default command of Credo. It suggests issues to fix in your code, but it cuts the list to a digestable count. If you want to see the full list, use the `--all`  switch.\n\nExample usage:\n\n    $ mix credo                         # display standard report\n    $ mix credo suggest                 # same thing, since it\'s the default command\n    $ mix credo --all --format=json     # include low priority issues, output as JSON\n\n    $ mix credo suggest --help          # more options\n\n\n### list\n\n`list` also suggests issues, but it groups them by file and does NOT cut the list to a certain count.\n\nExample usage:\n\n    $ mix credo list                      # show issues grouped by file\n    $ mix credo list --format=oneline     # show issues grouped by file, one issue per line\n    $ mix credo list --format=oneline -a  # same thing, include low priority issues\n\n    $ mix credo list --help               # more options\n\n\n### explain\n\n`explain` allows you to dig deeper into an issue, by showing you details about the issue and the reasoning by it being reported. To be convenient, you can just copy-paste the `filename:line_number:column` string from the report behind the Credo command to check it out.\n\n*Credits:* This is inspired by how you can snap the info from failed tests behind `mix test`.\n\nExample usage:\n\n    $ mix credo lib/my_app/server.ex:10:24          # show explanation for the issue\n    $ mix credo explain lib/my_app/server.ex:10:24  # same thing\n\nThere are no additional options.\n\n\n\n### categories\n\n`categories` shows you all issue categories and explains their semantics.\n\nThere are no additional options.\n\n\n### info\n\n`info` shows you information relevant to investigating errors and submitting bug reports.\n\nExample usage:\n\n    $ mix credo info\n    $ mix credo info --verbose\n    $ mix credo info --verbose --format=json\n\n## Command line options\n\n\n### Output Formats\n\nUse `--format` to format the output in one of the following formats:\n\n- `--format=flycheck` for [Flycheck](http://www.flycheck.org/) output\n- `--format=json` for [JSON](https://www.json.org/) output\n\n\n### Only run some checks\n\nTo run only a subset of checks, you can use the `--checks` or the `-c` alias (also aliased as `--only`).\n\n```bash\n# to only run the Readability checks, use:\n\n$ mix credo --only readability\n\n# to only run Readability checks and Warnings, use:\n\n$ mix credo --only readability,warning\n```\n\nThe second example illustrates how the command takes a comma-separated list. All commands matching **any** of the passed items will be run.\n\nYou can use partial names to quickly run checks. `mix credo --only todo` will show all `# TODO` comments since `todo` will match Credo.Check.Design.Tag**TODO**. `mix credo --only inspect` will show you all calls to `IO.inspect` since it matches Credo.Check.Warning.Io**Inspect**.\n\n\n### Ignore some checks\n\nTo ignore selected checks, you can use the `--ignore-checks` or the `-i` alias (also aliased as `--ignore`).\n\n```bash\n# to ignore all Readability checks, use:\n\n$ mix credo --ignore readability\n\n# to ignore all Readability checks and the DuplicatedCode check, use:\n\n$ mix credo --ignore readability,duplicated\n```\n\nThe second example illustrates how the command takes a comma-separated list. All commands matching any of the passed items will be ignored.\n\nYou can use partial names to quickly exclude checks. `mix credo --ignore nameredec` will exclude all checks for variables/parameters having the same name as declared functions by matching Credo.Check.Warning.**NameRedeclarationBy...**\n\n\n### Parsing source from STDIN\n\nYou can also use Credo to parse source that has been piped directly into it.\nThis is especially useful when integrating with external editors. You can use this feature by passing the `--read-from-stdin` option as follows:\n\n```bash\n$ echo \'IO.puts("hello world");\' | mix credo --format=flycheck --read-from-stdin\n# stdin:1: C: There is no whitespace around parentheses/brackets most of the time, but here there is.\n```\n\nNotice the origin if the source is coming annotated as `stdin`, you can change this annotation by passing it along after option like so:\n\n```bash\n$ echo \'IO.puts("hello world");\' | mix credo --format=flycheck --read-from-stdin /path/representing/the_current/source.ex\n# /path/representing/the_current/source.ex:1: C: There is no whitespace around parentheses/brackets most of the time, but here there is.\n```\n\nDo note with the passed option as filename is a stub that is just used to prefix the error and so certain editors can annotate the original file.\n\n\n### Using Credo as stand alone\n\nIf you do not want or are not allowed to include Credo in the current project you can also install it as an archive. For this, you also need to install [bunt](https://github.com/rrrene/bunt):\n\n```bash\ngit clone git@github.com:rrrene/bunt.git\ncd bunt\nmix archive.build\nmix archive.install\ncd -\ngit clone git@github.com:rrrene/credo.git\ncd credo\nmix deps.get\nmix archive.build\nmix archive.install\n```\n\n**Important:** You have to install `bunt` as well:\n\n```bash\ngit clone https://github.com/rrrene/bunt\ncd bunt\nmix archive.build\nmix archive.install\n```\n\nYou will now be able to invoke credo as usual through Mix with `mix credo`. This option is especially handy so credo can be used by external editors.\n\n\n### Show code snippets in the output\n\nUse the `--verbose` switch to include the code snippets in question in the output.\n\n\n### Show all issues including low priority ones\n\nUse the `--all-priorities` switch to include low priority issues in the output (aliased as `--strict`).\n\n\n## Issues\n\nLike any code linter, Credo reports issues. Contrary to many other linters these issues are not created equal. Each issue is assigned a priority, based on a base priority set by the config and a dynamic component based on violation severity and location in the source code.\n\nThese priorities hint at the importance of each issue and are displayed in the command-line interface using arrows: \xe2\x86\x91 \xe2\x86\x97 \xe2\x86\x92 \xe2\x86\x98 \xe2\x86\x93\n\nBy default, only issues with a positive priority are part of the report (\xe2\x86\x91 \xe2\x86\x97 \xe2\x86\x92).\n\n\n\n## Checks\n\n\n### Consistency\n\nThese checks take a look at your code and ensure a consistent coding style. Using tabs or spaces? Both is fine, just don\'t mix them or Credo will tell you.\n\n\n### Readability\n\nReadability checks do not concern themselves with the technical correctness of your code, but how easy it is to digest.\n\n\n### Refactoring Opportunities\n\nThe Refactor checks show you opportunities to avoid future problems and technical debt.\n\n\n### Software Design\n\nWhile refactor checks show you possible problems, these checks try to highlight possibilities, like - potentially intended - duplicated code or `TODO:` and `FIXME` annotations.\n\n\n### Warnings\n\nThese checks warn you about things that are potentially dangerous, like a missed call to `IEx.pry` or a call to `String.downcase` without saving the result.\n\n## Plugins\n\nPlugins can provide additional functionality to Credo.\n\nThis functionality can include:\n\n- adding new commands\n- overriding existing commands (e.g. implement better Explain command)\n- modifying the default config\n- adding checks, which can add their own issues, with their own categories,\n- prepending/appending steps to Credo\'s execution process\n- adding new CLI options\n\n### Using plugins\n\nPlugins are just modules. Most of the time, a Credo plugin will be published on Hex. You include it as a dependency:\n\n```elixir\n{:credo_demo_plugin, "~> 0.1.0"},\n```\n\nPlugins, like checks, are just modules and functions.\nThey can be included by listing them under the `:plugins` field in Credo\'s configuration file.\n\n```elixir\n%{\n  configs: [\n    %{\n      name: "default",\n      plugins: [\n        {CredoDemoPlugin, []}\n      ]\n    }\n  ]\n}\n```\n\n### Configuring plugins\n\nPlugins can be configured via params, just like checks.\nEach entry consists of a two-element tuple: the plugin\'s module and a keyword list of parameters, which can be used to configure the plugin itself.\n\n```elixir\n%{\n  configs: [\n    %{\n      name: "default",\n      plugins: [\n        {CredoDemoPlugin, [castle: "Grayskull"]}\n      ]\n    }\n  ]\n}\n```\n\nPlugins can be deactivated by setting the second tuple element to `false`.\n\n```elixir\n%{\n  configs: [\n    %{\n      name: "default",\n      plugins: [\n        {CredoDemoPlugin, []},\n        {CredoYetAnotherPlugin, false} # <-- don\'t load this for now\n      ]\n    }\n  ]\n}\n```\n\n### Creating a plugin\n\nA plugin is basically just a module that provides an `init/1` callback.\n\n```elixir\ndefmodule CredoDemoPlugin do\n  def init(exec) do\n    # but what do we do here??\n    exec\n  end\nend\n```\n\nThe `Credo.Plugin` module provides a number of functions for extending Credo\'s core features.\n\n```elixir\ndefmodule CredoDemoPlugin do\n  @config_file File.read!(".credo.exs")\n\n  import Credo.Plugin\n\n  def init(exec) do\n    exec\n    |> register_default_config(@config_file)\n    |> register_command("demo", CredoDemoPlugin.DemoCommand)\n    |> register_cli_switch(:castle, :string, :X)\n    |> append_task(:convert_cli_options_to_config, CredoDemoPlugin.ConvertCliSwitchesToPluginParams)\n    |> prepend_task(:set_default_command, CredoDemoPlugin.SetDemoAsDefaultCommand)\n  end\nend\n```\n\n### Add new commands\n\nCommands are just modules with a call function and adding new commands is easy.\n\n```elixir\n# credo_demo_plugin.ex\ndefmodule CredoDemoPlugin do\n  import Credo.Plugin\n\n  def init(exec) do\n    register_command(exec, "demo", CredoDemoPlugin.DemoCommand)\n  end\nend\n```\n\n```elixir\n# credo_demo_plugin/demo_command.ex\ndefmodule CredoDemoPlugin.DemoCommand do\n  alias Credo.CLI.Output.UI\n  alias Credo.Execution\n\n  def call(exec, _) do\n    castle = Execution.get_plugin_param(exec, CredoPlus, :castle)\n\n    UI.puts("By the power of #{castle}!")\n\n    exec\n  end\nend\n```\n\nUsers can use this command by typing\n\n```bash\n$ mix credo demo\nBy the power of !\n```\n\n### Override an existing command\n\nSince commands are just modules with a call function, overriding existing commands is easy.\n\n```elixir\ndefmodule CredoDemoPlugin do\n  import Credo.Plugin\n\n  def init(exec) do\n    register_command(exec, "explain", CredoDemoPlugin.MyBetterExplainCommand)\n  end\nend\n```\n\nThis example would have the effect that typing `mix credo lib/my_file.ex:42` would no longer run the built-in `Explain` command, but rather our plugin\'s `MyBetterExplain` command.\n\n### Modifying the default config\n\nPlugins can add default configuration to Credo.\n\n```elixir\ndefmodule CredoDemoPlugin do\n  import Credo.Plugin\n\n  def init(exec) do\n    register_default_config(exec, @config_file)\n  end\nend\n```\n\nThe configuration\'s loading order is this:\n\n1. Credo\'s own default config\n2. Default configs added by plugins\n3. Config files in the user\'s file system\n\nConfig values set in later stages are overwriting values from earlier ones.\n\n### Adding checks\n\nTo add checks from your plugin, simply extend the default config ...\n\n```elixir\n# credo_demo_plugin.ex\ndefmodule CredoDemoPlugin do\n  @config_file File.read!(".credo.exs")\n\n  import Credo.Plugin\n\n  def init(exec) do\n    register_default_config(exec, @config_file)\n  end\nend\n```\n\n... and then add the new checks there:\n\n```elixir\n# .credo.exs\n%{\n  configs: [\n    %{\n      name: "default",\n      checks: [\n        {CredoDemoPlugin.MyNewCheck, []}\n      ]\n    }\n  ]\n}\n```\n\nSince we are extending the default config, we can also deactivate checks and "replace" them with new ones:\n\n```elixir\n# .credo.exs\n%{\n  configs: [\n    %{\n      name: "default",\n      checks: [\n        {Credo.Check.Readability.ModuleDoc, false},\n        {CredoDemoPlugin.BetterModuleDoc, []}\n      ]\n    }\n  ]\n}\n```\n\n### Inserting tasks into Credo\'s execution process\n\nCredo\'s execution process consists of several steps, each with a set of tasks, which you can hook into.\n\nPrepending or appending tasks to these steps is easy:\n\n```elixir\n# credo_demo_plugin.ex\ndefmodule CredoDemoPlugin do\n  import Credo.Plugin\n\n  def init(exec) do\n    prepend_task(exec, :set_default_command, CredoDemoPlugin.SetDemoAsDefaultCommand)\n  end\nend\n```\n\n```elixir\n# credo_demo_plugin/set_demo_as_default_command.ex\ndefmodule CredoPlus.SetDemoAsDefaultCommand do\n  use Credo.Execution.Task\n\n  alias Credo.CLI.Options\n\n  def call(exec, _opts) do\n    set_command(exec, exec.cli_options.command || "demo")\n  end\n\n  defp set_command(exec, command) do\n    %Execution{exec | cli_options: %Options{exec.cli_options | command: command}}\n  end\nend\n```\n\nThis example would have the effect that typing `mix credo` would no longer run the built-in `Suggest` command, but rather our plugin\'s `Demo` command.\n\n### Adding new CLI options\n\nWe saw how plugins can be configured via params in the "Configuring plugins" section:\n\n```elixir\n{CredoDemoPlugin, [castle: "Grayskull"]}\n```\n\nBut what about those situations where we want to be able to configure things on-the-fly via the CLI?\nPlugins should be able to provide custom CLI options as well, so we can do something like:\n\n```bash\n$ mix credo --castle Winterfell\nUnknown switch: --castle\n```\n\nRegistering a custom CLI switch is easy:\n\n```elixir\ndefmodule CredoDemoPlugin do\n  import Credo.Plugin\n\n  def init(exec) do\n    register_cli_switch(exec, :castle, :string, :X)\n  end\nend\n```\n\nOf course, having a CLI option is not worth much if we can not utilize it.\nThis is why every registered CLI switch is automatically converted into a plugin param of the same name.\n\n```bash\n$ mix credo --castle Winterfell\nBy the power of Winterfell!\n```\n\nPlugin authors can also provide a function to control the plugin param\'s name and value more granularly:\n\n```elixir\ndefmodule CredoDemoPlugin do\n  import Credo.Plugin\n\n  def init(exec) do\n    register_cli_switch(exec, :kastle, :string, :K, fn(switch_value) ->\n      {:castle, switch_value}\n    end)\n  end\nend\n```\n\n## Integrations\n\n### IDE/Editor\n\nSome IDEs and editors are able to run Credo in the background and mark issues inline.\n\n* [IntelliJ Elixir](https://github.com/KronicDeth/intellij-elixir#credo) - Elixir plugin for JetBrains IDEs (IntelliJ IDEA, Rubymine, PHPStorm, PyCharm, etc)\n* [linter-elixir-credo](https://atom.io/packages/linter-elixir-credo) - Package for Atom editor (by @smeevil)\n\n### Automated Code Review\n\n* [Codacy](https://www.codacy.com/) - checks your code from style to security, duplication, complexity, and also integrates with coverage.\n* [Stickler CI](https://stickler-ci.com/) - checks your code for style and best practices across your entire stack.\n\n## Contributing\n\n1. [Fork it!](http://github.com/rrrene/credo/fork)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am \'Add some feature\'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create new Pull Request\n\n\n\n## Author\n\nRen\xc3\xa9 F\xc3\xb6hring (@rrrene)\n\n\n\n## License\n\nCredo is released under the MIT License. See the LICENSE file for further\ndetails.\n'