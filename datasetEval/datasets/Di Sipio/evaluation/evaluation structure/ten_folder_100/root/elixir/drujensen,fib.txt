b"# Recursive Fibonacci Benchmark using top languages on Github\n\nTop 10: JavaScript, Java, Python, Ruby, Php, C++, C#, C, Go [reference](http://www.techworm.net/2016/09/top-10-popular-programming-languages-github.html)\n\nOthers: Crystal, Rust, Swift, Mono, Elixir, Perl, R, Julia, D, Nim, Pascal, Fortran, Cython, Pony, OCaml, Lisp, Haskell, Erlang, Escript, Dart, Clojure, Scheme, Lua, Python3, Perl, Perl6, Bash, Emoji\n\nThe code performs a recursive fibonacci to the 46th position with the result of 2,971,215,073.  This is the original version where the sequence starts at 1 instead of 0. 1,1,2,3,5,8...\n\nFibonacci can be written many different ways.  The goal of this project is to compare how each language handles the exact same code.\n\nHere is the Ruby version:\n```\ndef fib(n)\n  return 1 if n <= 1\n  fib(n - 1) + fib(n - 2)\nend\n\nputs fib(46)\n```\n\nHere is the Crystal version:\n```\ndef fib(n : UInt64)\n  return 1_u64 if n <= 1\n  fib(n - 1) + fib(n - 2)\nend\n\nputs fib(46)\n```\n\nAll tests are run on:\n - MacBook Pro (Retina, 15-inch, Mid 2015)\n - Processor: 2.5 GHz Intel Core i7\n - Memory: 16 GB 1600 MHz DDR3\n - OS: macOS Mojave 10.14.5\n - Docker Container: 2.0.0.3\n - Docker Image: ubuntu:18.04\n\nYou can run the tests using Docker: `docker run -it drujensen/fib`\n\nLast benchmark was ran on June 12, 2019\n\n## Natively compiled, statically typed\n\n| Language | Time, s | Compile | Run |\n|----------|---------|---------|-----|\n| Nim |    0.429 | nim cpp -d:release fib.nim | time ./fib |\n| C++ |    3.856 | g++ -O3 -o fib fib.cpp | time ./fib |\n| C |    3.881 | gcc -O3 -o fib fib.c | time ./fib |\n| Fortran |    3.889 | gfortran -O3 -o fib fib.f03 | time ./fib |\n| Cython |    4.147 | cython --embed -o fib.pyx.c fib.pyx && gcc -O3 -o fib fib.pyx.c | time ./fib |\n| D |    5.274 | ldc2 -O3 -release -flto=full -of=fib fib.d | time ./fib |\n| Pony |    5.806 | ponyc -s -b fib -p ./fib.pony | time ./fib |\n| Rust |    5.812 | rustc -C opt-level=s fib.rs | time ./fib |\n| Crystal |    5.817 | crystal build --release fib.cr | time ./fib |\n| Swift |    6.483 | swiftc -O -g fib.swift | time ./fib |\n| OCaml |    7.831 | ocamlopt -O3 -o fib fib.ml | time ./fib |\n| Pascal |    9.269 | fpc -O3 ./fib.pas | time ./fib |\n| Go |   11.390 | go build fib.go | time ./fib |\n| Lisp |   13.290 | sbcl --load fib.lisp | time ./fib |\n| Haskell |   23.700 | ghc -O3 -o fib fib.hs | time ./fib |\n\n- Why is Nim is so fast? [https://forum.nim-lang.org/t/4253](https://forum.nim-lang.org/t/4253)\n\n## VM compiled bytecode, statically typed\n\n| Language | Time, s | Compile | Run |\n|----------|---------|---------|-----|\n| Java |    7.070 | javac Fib.java | time java Fib |\n| C# |   10.628 | dotnet build -c Release -o ./bin | time dotnet ./bin/fib.dll |\n| C# (Mono) |   13.809 | mcs Fib.cs | time mono Fib.exe |\n| Erlang |   14.213 | erlc +native +'{hipe,[o3]}' fib.erl | time erl -noinput -noshell -s fib |\n\n## VM compiled before execution, mixed/dynamically typed\n\n| Language | Time, s | Run |\n|----------|---------|-----|\n| Dart |    9.716 | time dart fib.dart |\n| Julia |   10.716 | time julia -O3 fib.jl |\n| Escript |   14.647 | time escript fib.es |\n| Lua Jit |   15.470 | time luajit fib.lua |\n| Node |   22.036 | time node fib.js |\n| Elixir |    23.190 | time elixir fib.exs |\n| Clojure |    27.719 | time clojure fib.cljc |\n\n- Elixir is using ERL_COMPILER_OPTIONS='[native,{hipe, [o3]}]'\n\nNOTE: These languages include compilation time which should be taken into consideration when comparing.\n\n## Interpreted, dynamically typed\n\n| Language | Time, s | Run |\n|----------|---------|-----|\n| Php |  161.610 | time php fib.php |\n| Scheme | 221.163 | time guile fib.scm |\n| Ruby |  260.350 | time ruby fib.rb |\n| Lua |  460.107 | time lua fib.lua |\n| Python3 |  657.607 | time python3 fib.py |\n| Python |  675.068 | time python fib.py |\n| Perl | 1663.980 | time perl fib.pl |\n| Tcl | 1957.335 | time tclsh fib.tcl |\n| Perl 6 | 5419.500 | time perl6 fib.p6 |\n| K         |      DNF | time k fib.k |\n| R         |      DNF | time r -f fib.r |\n| Bash      |      DNF | time bash fib.sh |\n| PowerShell |     DNF | time pwsh fib.ps1 |\n\nNOTE: Interpreted languages have a startup time cost that should be taken into consideration when comparing.\n\n## Optimized code that breaks the benchmark\n\nThe code examples provided in the [optimized](optimized) folder use techniques that break the benchmark. They do not perform the same internal tasks as the other examples so are not a good for an apples to apples comparison. They all perform at sub-second response times. It demonstrates that all benchmarks will have some caveat.\n\nSeveral of these examples add very little changes to the original code that are worth mentioning:\n - The [C++ constexpr](optimized/fib-constexpr.cpp) is using a `constexpr` which optimizes the recursive call to a constant.\n - The [Lisp compiletime](optimized/fib-compiletime.lisp) shows how you can perform the calculation at compile time. simply add `#.` before outputing the results.\n - The [Python lru_cache](optimized/fib-cache.py) is using `lru_cache` directive with no code changes.\n - The [Ruby mem](optimized/fib-mem.rb), [Crystal mem](optimized/fib-mem.cr) and [JS mem](optimized/fib-mem.js) are maintaining a simple cache to avoid recalculating the results for that value.\n\nFor the fun of it, here are the benchmarks for the optimized versions\n\nLast benchmark was ran on November 30, 2018\n\n## Optimized\n\n| Language | Time, s | Compile | Run |\n|----------|---------|---------|-----|\n| Nim Constant |    0.003 | nim cpp -d:release fib_const.nim | time ./fib_cont |\n| Crystal Memoized |    0.004 | crystal build --release fib-mem.cr | time ./fib-mem |\n| Perl Memoized 2 |    0.005 |  | time perl fib-mem2.pl |\n| OCaml TCO |    0.005 | ocamlopt -O3 -o fib_tail fib_tail.ml | time ./fib_tail |\n| Haskell Memoized |    0.005 | ghc -O3 -o fib_mem fib_mem.hs | time ./fib_mem |\n| Nim Memoized |    0.005 | nim cpp -d:release fib_mem.nim | time ./fib_mem |\n| Swift Memoized |    0.006 | swiftc -O -g fib-mem.swift | time ./fib-mem |\n| C++ Constant |    0.006 | g++-8 -O3 -o fib-const fib-constexpr.cpp | time ./fib-const |\n| Go Memoized |    0.006 | go build fib-mem.go | time ./fib-mem |\n| Perl Inline |    0.007 |  | time perl fib-inline.py |\n| D Memoized |    0.007 | ldc2 -O3 -release -flto=full -of=fib-mem fib-mem.d | time ./fib-mem |\n| Lisp Compile Time |    0.008 | sbcl --load fib-compiletime.lisp | time ./fib-compiletime |\n| Perl Memoized |    0.015 |  | time perl fib-mem.pl |\n| Python Cached |    0.034 |  | time python3 fib-cache.py |\n| Lua Memoized |    0.040 |  | time lua fib-mem.lua |\n| Node Memoized |    0.065 |  | time node fib-mem.js |\n| Ruby Memoized |    0.081 |  | time ruby fib-mem.rb |\n| Erlang Memoized |    0.104 | erlc +native +'{hipe,[o3]}' fib_mem.erl | time erl -noinput -noshell -s fib_mem |\n| Escript Memoized |    0.139 |  | time escript fib_mem.es |\n| K Memoized |    0.220 |  | time k fib-mem.k |\n| Java Iterative |    0.233 | javac FibOptimized.java | time java FibOptimized |\n| Elixir Iterative |    0.461 |  | time elixir fib-iterative.exs |\n| Perl6 Memoized |    0.915 |  | time perl6 fib-mem.p6 |\n\n## Versions\n\nAll compilers are installed using `asdf` or `apt` on Ubuntu 18.04 docker image:\n- gcc         7.4.0\n- g++         7.4.0\n- java        openjdk-11.0.1\n- ruby        2.6.3\n- clojure     1.10.0\n- crystal     0.29.0\n- dart        2.2.0\n- dotnet-core 2.2.105\n- erlang      22.0.2\n- elixir      1.8.2\n- elm         0.19.0\n- golang      1.12.5\n- haskell     8.6.5\n- julia       1.1.1\n- lua         5.3.5\n- luajit      2.1.0-beta3\n- nim         v0.20.0\n- nodejs      8.12.0\n- pascal      3.0.4\n- perl        5.28.1\n- php         7.3.6\n- python      2.7.16\n- python3     3.7.3\n- rust        1.35.0\n- R           3.6.0\n- D (lcd2)    1.15.1\n- ponyc       0.28.1\n- swift       5.0.1\n- cython      0.26.1\n- gfortran    7.4.0\n- ocaml       4.07.1\n- perl6       2018.06\n- lisp (sbcl) 1.4.5\n- tcl         8.6\n- scheme      2.2\n\n## Caveats\n\n[Fibonacci Benchmark](https://crystal-lang.org/2016/07/15/fibonacci-benchmark.html)\n"