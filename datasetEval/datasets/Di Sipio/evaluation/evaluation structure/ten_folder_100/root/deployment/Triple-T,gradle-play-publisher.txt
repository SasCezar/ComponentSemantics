b'<p align="center">\n    <img alt="Logo" src="assets/logo.svg" width="25%" />\n</p>\n\n<h1 align="center">\n    Gradle Play Publisher\n</h1>\n\n<p align="center">\n    <a href="https://circleci.com/gh/Triple-T/gradle-play-publisher">\n        <img src="https://circleci.com/gh/Triple-T/gradle-play-publisher.svg?style=svg" />\n    </a>\n    <a href="https://plugins.gradle.org/plugin/com.github.triplet.play">\n        <img src="https://img.shields.io/maven-metadata/v/https/plugins.gradle.org/m2/com/github/triplet/play/com.github.triplet.play.gradle.plugin/maven-metadata.xml.svg?label=Gradle%20Plugins%20Portal" />\n    </a>\n</p>\n\nGradle Play Publisher is Android\'s unofficial release automation Gradle Plugin. It can do anything\nfrom building, uploading, and then promoting your App Bundle or APK to publishing app listings and\nother metadata.\n\n## Table of contents\n\n1. [Quickstart guide](#quickstart-guide)\n1. [Prerequisites](#prerequisites)\n   1. [Initial Play Store upload](#initial-play-store-upload)\n   1. [Signing configuration](#signing-configuration)\n   1. [Service Account](#service-account)\n1. [Basic setup](#basic-setup)\n   1. [Installation](#installation)\n   1. [Authenticating Gradle Play Publisher](#authenticating-gradle-play-publisher)\n1. [Task organization](#task-organization)\n1. [Managing artifacts](#managing-artifacts)\n   1. [Common configuration](#common-configuration)\n   1. [Publishing an App Bundle](#publishing-an-app-bundle)\n   1. [Publishing APKs](#publishing-apks)\n   1. [Uploading an Internal Sharing artifact](#uploading-an-internal-sharing-artifact)\n   1. [Promoting artifacts](#promoting-artifacts)\n   1. [Handling version conflicts](#handling-version-conflicts)\n1. [Managing Play Store metadata](#managing-play-store-metadata)\n   1. [Quickstart](#quickstart)\n   1. [Directory structure](#directory-structure)\n   1. [Publishing listings](#publishing-listings)\n   1. [Publishing in-app products](#publishing-in-app-products)\n1. [Working with product flavors](#working-with-product-flavors)\n   1. [Disabling publishing](#disabling-publishing)\n   1. [Combining artifacts into a single release](#combining-artifacts-into-a-single-release)\n   1. [Using multiple Service Accounts](#using-multiple-service-accounts)\n1. [Advanced topics](#advanced-topics)\n   1. [Using CLI options](#using-cli-options)\n   1. [Encrypting Service Account keys](#encrypting-service-account-keys)\n   1. [Using HTTPS proxies](#using-https-proxies)\n\n## Quickstart guide\n\n1. Upload the first version of your APK or App Bundle using the\n   [Google Play Console](https://play.google.com/apps/publish)\n1. [Create a Google Play Service Account](#service-account)\n1. [Sign your release builds](https://developer.android.com/studio/publish/app-signing#gradle-sign)\n   with a valid `signingConfig`\n1. [Add and apply the plugin](#installation)\n1. [Authenticate GPP](#authenticating-gradle-play-publisher)\n\n## Prerequisites\n\n### Initial Play Store upload\n\nThe first APK or App Bundle needs to be uploaded via the Google Play Console because registering the\napp with the Play Store cannot be done using the Play Developer API. For all subsequent uploads and\nchanges, GPP may be used.\n\n### Signing configuration\n\nTo successfully upload apps to the Play Store, they must be signed with your developer key. Make\nsure you have\n[a valid signing configuration](https://developer.android.com/studio/publish/app-signing#gradle-sign).\n\n### Service Account\n\nTo use GPP, you must create a service account with access to the Play Developer API:\n\n1. If you don\'t already have one, create a GCP project for your app(s)\n1. Create a\n   [service account key](https://console.cloud.google.com/apis/credentials/serviceaccountkey)\n   1. Select `New service account`\n   1. Give it a name, but don\'t select any roles\n   1. Leave JSON checked\n   1. If it asks for roles, continue without selecting any\n1. Move the downloaded JSON credentials into your project and\n   [tell GPP about it](#authenticating-gradle-play-publisher)\n1. [Link your developer account](https://play.google.com/apps/publish#ApiAccessPlace) to the GCP\n   project in which you created the service account\n1. Give your service account\n   [permissions to publish apps](https://play.google.com/apps/publish#AdminPlace) on your behalf\n   1. Click `Invite new user`\n   1. Copypasta the service account email (you can find it in the JSON credentials)\n   1. Don\'t touch the roles\n   1. Specify which apps the service account should have access to:\n      <img alt="Minimum Service Account permissions" src="assets/min-perms.png" width="66%" />\n\n## Basic setup\n\n### Installation\n\nApply the plugin to each individual `com.android.application` module where you want to use GPP\nthrough the `plugins {}` DSL:\n\n<details open><summary>Kotlin</summary>\n\n```kt\nplugins {\n    id("com.android.application")\n    id("com.github.triplet.play") version "2.6.1"\n}\n```\n\n</details>\n\n<details><summary>Groovy</summary>\n\n```groovy\nplugins {\n    id \'com.android.application\'\n    id \'com.github.triplet.play\' version \'2.6.1\'\n}\n```\n\n</details>\n\n#### Snapshot builds\n\nIf you\'re prepared to cut yourself on the bleeding edge of GPP development, snapshot builds are\navailable from\n[Sonatype\'s `snapshots` repository](https://oss.sonatype.org/content/repositories/snapshots/com/github/triplet/gradle/play-publisher/):\n\n<details open><summary>Kotlin</summary>\n\n```kt\nbuildscript {\n    repositories {\n        // ...\n        maven("https://oss.sonatype.org/content/repositories/snapshots")\n    }\n\n    dependencies {\n        // ...\n        classpath("com.github.triplet.gradle:play-publisher:2.7.0-SNAPSHOT")\n    }\n}\n```\n\n</details>\n\n<details><summary>Groovy</summary>\n\n```groovy\nbuildscript {\n    repositories {\n        // ...\n        maven { url \'https://oss.sonatype.org/content/repositories/snapshots\' }\n    }\n\n    dependencies {\n        // ...\n        classpath \'com.github.triplet.gradle:play-publisher:2.7.0-SNAPSHOT\'\n    }\n}\n```\n\n</details>\n\n### Authenticating Gradle Play Publisher\n\nAfter you\'ve gone through the [Service Account setup](#service-account), you should have a JSON file\nwith your private key. Add a `play` block alongside your `android` one with the file\'s location:\n\n```kt\nandroid { ... }\n\nplay {\n    serviceAccountCredentials = file("your-key.json")\n}\n```\n\n## Task organization\n\nGPP follows the Android Gradle Plugin\'s naming convention: `[action][Variant][Thing]`. For example,\n`publishPaidReleaseBundle` will be generated if have a `paid` product flavor.\n\nLifecycle tasks to publish multiple product flavors at once are also available. For example,\n`publishBundle` publishes all variants.\n\nTo find available tasks, run `./gradlew tasks --group publishing` and use\n`./gradlew help --task [task]` where `task` is something like `publishBundle` to get more detailed\ndocumentation for a specific task.\n\n> Note: if a task conflict occurs, say with the `maven-publish` plugin for example, be sure to apply\n> the GPP plugin *last*. Conflicting tasks will then be prefixed with `gpp` (ex: `publish` ->\n> `gppPublish`).\n\n## Managing artifacts\n\nGPP supports uploading both the App Bundle and APK. Once uploaded, GPP also supports promoting those\nartifacts to different tracks.\n\n### Common configuration\n\nSeveral options are available to customize how your artifacts are published:\n\n* `track` is the target stage for an artifact, i.e. `internal`/`alpha`/`beta`/`production` or any\n  custom track\n  * Defaults to `internal`\n* `releaseStatus` is the type of release, i.e. `completed`/`draft`/`inProgress`/`halted`\n  * Defaults to `completed`\n* `userFraction` is the percentage of users who will receive a staged release\n  * Defaults to `0.1` aka 10%\n  * **Note:** the `userFraction` is only applicable where `releaseStatus=[inProgress/halted]`\n\nExample configuration:\n\n```kt\nplay {\n    // Overrides defaults\n    track = "production"\n    userFraction = 0.5\n    releaseStatus = "inProgress"\n\n    // ...\n}\n```\n\n#### Uploading release notes\n\nWhile GPP can automatically build and find your artifact, you\'ll need to tell the plugin where to\nfind your release notes.\n\nAdd a file under `src/[sourceSet]/play/release-notes/[language]/[track].txt` where `sourceSet`\nis a [full variant name](https://developer.android.com/studio/build/build-variants#sourceset-build),\n`language` is one of the\n[Play Store supported codes](https://support.google.com/googleplay/android-developer/answer/3125566),\nand `track` is the channel you want these release notes to apply to (or `default` if unspecified).\n\nAs an example, let\'s assume you have these two different release notes:\n\n```\nsrc/main/play/release-notes/en-US/default.txt\n.../beta.txt\n```\n\nWhen you publish to the beta channel, the `beta.txt` release notes will be uploaded. For any other\nchannel, `default.txt` will be uploaded.\n\n> Note: the Play Store limits your release notes to a maximum of 500 characters.\n\n#### Uploading developer facing release names\n\nThe Play Console supports customizing release names. These aren\'t visible to users, but may be\nuseful for internal processes. Similar to release notes, release names may be specified by placing\na `[track].txt` file in the `release-names` directory under your `play` folder. For example, here\'s\na custom release name for the alpha track in the `play/release-names/alpha.txt` file:\n\n```\nMy custom release name\n```\n\nIf it makes more sense to specify the release name in your build script, the `releaseName` property\nis available:\n\n```kt\nplay {\n    // ...\n    releaseName = "My custom release name"\n}\n```\n\n> Note: the `play.releaseName` property takes precedence over the resource files.\n\nThere is also a `--release-name` CLI option for quick access. For example,\n`./gradlew publishBundle --release-name "Hello World!"`.\n\n> Note: the Play Store limits your release names to a maximum of 50 characters.\n\n#### Uploading a pre-existing artifact\n\nBy default, GPP will build your artifact from source. In advanced use cases, this might not be the\ndesired behavior. For example, if you need to inject translations into your APK or App Bundle after\nbuilding it but before publishing it. Or perhaps you simply already have an artifact you wish to\npublish. GPP supports this class of use cases by letting you specify a directory in which\npublishable artifacts may be found:\n\n```kt\nplay {\n    // ...\n    artifactDir = file("path/to/apk-or-app-bundle/dir")\n}\n```\n\nFor quick access, you can also use the `--artifact-dir` CLI option:\n\n```sh\n./gradlew publishBundle --artifact-dir path/to/app-bundle/dir\n```\n\n> Note: all artifacts in the specified directory will be published.\n\n#### Retaining artifacts\n\nGPP supports keeping around old artifacts such as OBB files or WearOS APKs:\n\n```kt\nplay {\n    // ...\n    retain {\n        artifacts = listOf(123) // Old APK version code\n        mainObb = 123 // Old main OBB version code\n        patchObb = 123 // Old patch OBB version code\n    }\n}\n```\n\n### Publishing an App Bundle\n\nRun `./gradlew publishBundle`.\n\n#### Defaulting to the App Bundle\n\nYou\'ll notice that if you run `./gradlew publish`, it uploads an APK by default. To change this,\ndefault to the App Bundle:\n\n```kt\nplay {\n    // ...\n    defaultToAppBundles = true\n}\n```\n\n### Publishing APKs\n\nRun `./gradlew publishApk`. Splits will be uploaded if available.\n\n### Uploading an Internal Sharing artifact\n\nRun `./gradlew uploadReleasePrivateBundle` for App Bundles and `./gradlew uploadReleasePrivateApk`\nfor APKs. To upload an existing artifact, read about\n[how to do so](#uploading-a-pre-existing-artifact).\n\n#### Installing Internal Sharing artifacts\n\nTo accelerate development, GPP supports uploading and then immediately installing Internal Sharing\nartifacts. This is similar to the AGP\'s `install[Variant]` task.\n\nRun `./gradlew installReleasePrivateArtifact` to install an artifact built on-the-fly and\n`./gradlew uploadReleasePrivateBundle --artifact-dir path/to/artifact installReleasePrivateArtifact`\nto install an existing artifact.\n\n### Promoting artifacts\n\nExisting releases can be promoted and/or updated to the [configured track](#common-configuration)\nwith `./gradlew promoteArtifact`.\n\nBy default, the track *from* which to promote a release is determined by the most unstable channel\nthat contains a release. Example: if the alpha channel has no releases, but the beta and prod\nchannels do, the beta channel will be picked. To configure this manually, use the `fromTrack`\nproperty:\n\n```kt\nplay {\n    // ...\n    fromTrack = "alpha"\n}\n```\n\nSimilarly, the track *to* which to promote a release defaults to the `promoteTrack` property. If\nunspecified, the `track` property will be used instead. Example configuration:\n\n```kt\nplay {\n    // ...\n    promoteTrack = "beta"\n}\n```\n\nIf you need to execute a one-time promotion, you can use the CLI args. For example, this is how you\nwould promote an artifact from the alpha \xe2\x9e\xa1\xef\xb8\x8f beta track with only 25% of users getting the release:\n\n```sh\n./gradlew promoteArtifact \\\n  --from-track alpha --promote-track beta \\\n  --release-status inProgress --user-fraction .25\n```\n\n### Handling version conflicts\n\nIf an artifact already exists with a version code greater than or equal to the one you\'re trying to\nupload, an error will be thrown when attempting to publish the new artifact. You have two options:\n\n* Ignore the error and continue (`ignore`)\n* Automatically pick the correct version code so you don\'t have to manually update it (`auto`)\n\nExample configuration:\n\n```kt\nplay {\n    // ...\n    resolutionStrategy = "ignore"\n}\n```\n\n#### Post-processing outputs sanitized by auto resolution\n\nFor example, you could update you app\'s version name based on the new version code:\n\n```kt\nplay {\n    // ...\n    resolutionStrategy = "auto"\n    outputProcessor { // this: ApkVariantOutput\n        versionNameOverride = "$versionNameOverride.$versionCode"\n    }\n}\n```\n\n## Managing Play Store metadata\n\nGPP supports uploading any metadata you might want to change with each release, from screenshots and\ndescriptions to in-app purchases and subscriptions.\n\n### Quickstart\n\nGPP includes a bootstrap task that pulls down your existing listing and initializes everything for\nyou. To use it, run `./gradlew bootstrap`.\n\n> Note: if you have a pre-existing `play` folder, it will be reset.\n\n### Directory structure\n\nGPP follows the Android Gradle Plugin\'s source set\n[guidelines and priorities](https://developer.android.com/studio/build/build-variants#sourceset-build).\n`src/[sourceSet]/play` is the base directory for Play Store metadata. Since `main` is the most\ncommon source set, it will be assumed in all following examples.\n\nIn addition to merging metadata across variants, GPP merges translations. That is, if a resources is\nprovided in a default language such as `en-US` but not in `fr-FR`, the resource will be copied over\nwhen uploading French metadata.\n\n### Publishing listings\n\nRun `./gradlew publishListing`.\n\n#### Uploading global app metadata\n\nBase directory: `play`\n\nFile | Description\n--- | ---\n`contact-email.txt` | Developer email\n`contact-phone.txt` | Developer phone\n`contact-website.txt` | Developer website\n`default-language.txt` | The default language for both your Play Store listing and translation merging as described above\n\n#### Uploading text based listings\n\nBase directory: `play/listings/[language]` where `language` is one of the\n[Play Store supported codes](https://support.google.com/googleplay/android-developer/answer/3125566)\n\nFile | Description | Character limit\n--- | --- | ---\n`title.txt`| App title | 50\n`short-description.txt` | Tagline | 80\n`full-description.txt` | Full description | 4000\n`video-url.txt` | Youtube product video | N/A\n\n#### Uploading graphic bases listings\n\nDirectory: `play/listings/[language]/graphics` where `language` is defined as in the previous\nsection\n\nImage files are organized a bit differently than in previous sections. Instead of the file name, the\nparent directory\'s name is used as the media type. This is because multiple images may be provided\nfor the same media type. While file names are arbitrary, they will be uploaded in alphabetical order\nand presented on the Play Store as such. Therefore, we recommend using a number as the file name\n(`1.png` for example). Both PNG and JPEG images are supported.\n\nDirectory | Max # of images | Image dimension constraints (px)\n--- | --- | ---\n`icon` | 1 | 512x512\n`feature-graphic` | 1 | 1024x500\n`promo-graphic` | 1 | 180x120\n`phone-screenshots` | 8 | [320..3840]x[320..3840]\n`tablet-screenshots` | 8 | [320..3840]x[320..3840]\n`large-tablet-screenshots` | 8 | [320..3840]x[320..3840]\n`tv-banner` | 1 | 1280x720\n`tv-screenshots` | 8 | [320..3840]x[320..3840]\n`wear-screenshots` | 8 | [320..3840]x[320..3840]\n\n### Publishing in-app products\n\nRun `./gradlew publishProducts`.\n\nManually setting up in-app purchase files is not recommended. [Bootstrap them instead](#quickstart)\nwith `./gradlew bootstrap --products`.\n\n## Working with product flavors\n\nWhen working with product flavors, granular configuration is key. GPP provides varying levels of\ngranularity to best support your needs, all through the `playConfigs` block:\n\n<details open><summary>Kotlin</summary>\n\n```kt\nplay {\n    // In a simple app, this play block is all you\'ll need. However, in an app with product flavors,\n    // the play block becomes a place to store default configurations. Anything configured in here\n    // will apply to all product flavors, that is, unless an override is supplied in the playConfigs\n    // block.\n}\n\nandroid {\n    // Suppose we have the following flavors\n    flavorDimensions("customer", "type")\n    productFlavors {\n        register("firstCustomer") { setDimension("customer") }\n        register("secondCustomer") { setDimension("customer") }\n\n        register("demo") { setDimension("type") }\n        register("full") { setDimension("type") }\n    }\n\n    playConfigs {\n        // Now, we can configure GPP however precisely is required.\n\n        // Configuration overrides occur in a cascading manner from most to least specific. That is,\n        // a property configured in a build type + flavor combo overrides that same property\n        // configured in a flavor combo, which overrides a build type combo, which in turn overrides\n        // the play block. Properties not configured are inherited.\n        register("firstCustomerFullRelease") { ... } // Build type + flavor\n        register("firstCustomer") { ... } // Flavor\n        register("release") { ... } // Build type\n    }\n}\n```\n\n</details>\n\n<details><summary>Groovy</summary>\n\n```groovy\nplay {\n    // In a simple app, this play block is all you\'ll need. However, in an app with product flavors,\n    // the play block becomes a place to store default configurations. Anything configured in here\n    // will apply to all product flavors, that is, unless an override is supplied in the playConfigs\n    // block.\n}\n\nandroid {\n    // Suppose we have the following flavors\n    flavorDimensions \'customer\', \'type\'\n    productFlavors {\n        firstCustomer { dimension \'customer\' }\n        secondCustomer { dimension \'customer\' }\n\n        demo { dimension \'type\' }\n        full { dimension \'type\' }\n    }\n\n    playConfigs {\n        // Now, we can configure GPP however precisely is required.\n\n        // Configuration overrides occur in a cascading manner from most to least specific. That is,\n        // a property configured in a build type + flavor combo overrides that same property\n        // configured in a flavor combo, which overrides a build type combo, which in turn overrides\n        // the play block. Properties not configured are inherited.\n        firstCustomerFullRelease { ... } // Build type + flavor\n        firstCustomer { ... } // Flavor\n        release { ... } // Build type\n    }\n}\n```\n\n</details>\n\n### Disabling publishing\n\nSometimes, you may not want to publish all variants of your app. Or maybe you don\'t want publishing\nenabled on CI or local dev machines. Whatever the case may be, GPP can be disabled with the\n`enabled` property:\n\n<details open><summary>Kotlin</summary>\n\n```kt\nandroid {\n    // ...\n\n    playConfigs {\n        register("myCustomVariantOrProductFlavor") {\n            isEnabled = true\n        }\n\n        // ...\n    }\n}\n\nplay {\n    isEnabled = false // This disables GPP by default. It could be the other way around.\n    // ...\n}\n```\n\n</details>\n\n<details><summary>Groovy</summary>\n\n```groovy\nandroid {\n    // ...\n\n    playConfigs {\n        myCustomVariantOrProductFlavor {\n            enabled = true\n        }\n\n        // ...\n    }\n}\n\nplay {\n    enabled = false // This disables GPP by default. It could be the other way around.\n    // ...\n}\n```\n\n</details>\n\n### Combining artifacts into a single release\n\nBy default, GPP assumes every product flavor consists of a separate, independent app. To tell GPP\nthis isn\'t the case, you must use the `commit` property:\n\n<details open><summary>Kotlin</summary>\n\n```kt\nandroid {\n    // ...\n\n    playConfigs {\n        register("someFlavor1") {\n            commit = false\n        }\n\n        register("someFlavor[2..N)") {\n            commit = false\n        }\n\n        register("someFlavorN") {\n            // This isn\'t actually needed since the default is true. Here\'s what you *do* need:\n            // 1. A starter no-commit variant (someFlavor1 in this case)\n            // 2. (Optional) Intermediate no-commit variants (someFlavor2, someFlavor3, ...)\n            // 3. One finisher variant to commit (aka do NOT mark someFlavorN as no-commit)\n            commit = true\n        }\n\n        // ...\n    }\n}\n\nafterEvaluate {\n    // Now make sure the tasks execute in the right order\n    val intermediateTasks = listOf(\n            "publishSomeFlavor2Release[Apk/Bundle]",\n            "publishSomeFlavor3Release[Apk/Bundle]",\n            ...\n    )\n    tasks.matching { it.name in intermediateTasks }.configureEach {\n        mustRunAfter("publishSomeFlavor1Release[Apk/Bundle]")\n    }\n    tasks.named("publishSomeFlavorNRelease[Apk/Bundle]").configure {\n        mustRunAfter(intermediateTasks)\n    }\n}\n```\n\n</details>\n\n<details><summary>Groovy</summary>\n\n```groovy\nandroid {\n    // ...\n\n    playConfigs {\n        someFlavor1 {\n            commit = false\n        }\n\n        someFlavor[2..N) {\n            commit = false\n        }\n\n        someFlavorN {\n            // This isn\'t actually needed since the default is true. Here\'s what you *do* need:\n            // 1. A starter no-commit variant (someFlavor1 in this case)\n            // 2. (Optional) Intermediate no-commit variants (someFlavor2, someFlavor3, ...)\n            // 3. One finisher variant to commit (aka do NOT mark someFlavorN as no-commit)\n            commit = true\n        }\n\n        // ...\n    }\n}\n\nafterEvaluate {\n    // Now make sure the tasks execute in the right order\n    def intermediateTasks = [\n            "publishSomeFlavor2Release[Apk/Bundle]",\n            "publishSomeFlavor3Release[Apk/Bundle]",\n            ...\n    ]\n    tasks.matching { intermediateTasks.contains(it.name) }.configureEach {\n        mustRunAfter("publishSomeFlavor1Release[Apk/Bundle]")\n    }\n    tasks.named("publishSomeFlavorNRelease[Apk/Bundle]").configure {\n        mustRunAfter(intermediateTasks)\n    }\n}\n```\n\n</details>\n\n### Using multiple Service Accounts\n\nIf you need to publish each build flavor to a separate Play Store account, simply provide separate\ncredentials per product flavor.\n\n<details open><summary>Kotlin</summary>\n\n```kt\nandroid {\n    // ...\n\n    playConfigs {\n        register("firstCustomer") {\n            serviceAccountCredentials = file("customer-one-key.json")\n        }\n\n        register("secondCustomer") {\n            serviceAccountCredentials = file("customer-two-key.json")\n        }\n    }\n}\n```\n\n</details>\n\n<details><summary>Groovy</summary>\n\n```groovy\nandroid {\n    // ...\n\n    playConfigs {\n        firstCustomer {\n            serviceAccountCredentials = file(\'customer-one-key.json\')\n        }\n\n        secondCustomer {\n            serviceAccountCredentials = file(\'customer-two-key.json\')\n        }\n    }\n}\n```\n\n</details>\n\n## Advanced topics\n\n### Using CLI options\n\nAll configuration options available in the `play` block are also available as CLI options so you\ndon\'t have to update your build file when making one-time changes. For example, to configure\n`play.track` on demand, use the `--track` option. `camelCase` options are converted to\n`kebab-case` ones.\n\nTo get a list of options and their quick documentation, use `./gradlew help --task [task]` where\n`task` is something like `publishBundle`.\n\n### Encrypting Service Account keys\n\nIf you commit unencrypted Service Account keys to source, you run the risk of letting anyone access\nyour Google Play account. To circumvent this issue, many CI servers support encrypting files while\nkeeping fake versions in public source control. Here is a set of\n[common fake files](https://github.com/SUPERCILEX/Robot-Scouter/tree/38407b3d6db74edb6c9de33b862655dfbd010a70/ci-dummies)\nyou might need and ways to encrypt your real keys for a few common CI servers:\n\n- [Travis CI](https://docs.travis-ci.com/user/encrypting-files/)\n- [CircleCI](https://github.com/circleci/encrypted-files)\n- [Jenkins](https://github.com/samrocketman/jervis/wiki/Secure-secrets-in-repositories)\n\n### Using HTTPS proxies\n\nIf you need to use GPP behind an HTTPS-proxy, but it fails with an `SSLHandshakeException`, you can\nprovide your own truststore via the `javax.net.ssl.trustStore` property in your project\'s\n`gradle.properties`:\n\n```properties\nsystemProp.javax.net.ssl.trustStore=/path/to/your/truststore.ks\nsystemProp.javax.net.ssl.trustStorePassword=YourTruststorePassword\n```\n\nGPP will automatically pick it up and use your proxy.\n'