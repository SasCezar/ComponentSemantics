b'# Gradle Cargo plugin [![Build Status](https://travis-ci.org/bmuschko/gradle-cargo-plugin.svg?branch=master)](https://travis-ci.org/bmuschko/gradle-cargo-plugin)\n\n![Cargo Logo](https://codehaus-cargo.github.io/cargo/attachments/cargo-banner-left.png)\n\n<table border=1>\n    <tr>\n        <td>\n            Over the past couple of years this plugin has seen many releases. Thanks to everyone involved! \n            Unfortunately, I don\'t have much time to contribute anymore. In practice this means far less activity, \n            responsiveness on issues and new releases from my end.\n        </td>\n    </tr>\n    <tr>\n        <td>\n            I am \n            <a href="https://discuss.gradle.org/t/looking-for-new-owners-for-gradle-plugins/9735">actively looking for contributors</a> \n            willing to take on maintenance and implementation of the project. If you are interested and would love to see this \n            plugin continue to thrive, shoot me a <a href="mailto:benjamin.muschko@gmail.com">mail</a>.\n        </td>\n    </tr>\n</table>\n\nThe plugin provides deployment capabilities for web applications to local and remote containers in any given\nGradle build by leveraging the [Cargo Ant tasks](https://codehaus-cargo.github.io/cargo/Ant+support.html). The plugin supports WAR and EAR\nartifacts.\n\nThe typical use case for this plugin is to support deployment during development. Keep in mind that Cargo uses hot deployment\nwhich over time fills up the PermGen memory of the JVM process running your container. Continuously deploying an artifact will\ninevitablity lead to a `java.lang.OutOfMemoryError`. Cargo does support container management capabilities (starting/stopping\nof remote containers) via the so-called [Cargo daemon](https://codehaus-cargo.github.io/cargo/Cargo+Daemon.html). However, in continuous deployment\nscenarios you often want to need perform more complex operations.\n\n## Usage\n\nTo use the plugin\'s functionality, you will need to add the its binary artifact to your build script\'s classpath and apply\nthe plugin.\n\n### Adding the plugin binary to the build\n\nThe plugin JAR needs to be defined in the classpath of your build script. It is directly available on\n[Bintray](https://bintray.com/bmuschko/gradle-plugins/com.bmuschko%3Agradle-cargo-plugin/). The following code snippet \nshows an example on how to retrieve it from Bintray:\n\n    buildscript {\n        repositories {\n            jcenter()\n        }\n\n        dependencies {\n            classpath \'com.bmuschko:gradle-cargo-plugin:2.6.1\'\n        }\n    }\n\n### Provided plugins\n\nThe JAR file comes with two plugins:\n\n<table>\n    <tr>\n        <th>Plugin Identifier</th>\n        <th>Depends On</th>\n        <th>Type</th>\n        <th>Description</th>\n    </tr>\n    <tr>\n        <td>com.bmuschko.cargo-base</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-cargo-plugin/docs/groovydoc/com/bmuschko/gradle/cargo/CargoBasePlugin.html">CargoBasePlugin</a></td>\n        <td>Provides Cargo custom task types, pre-configures classpath and deployables.</td>\n    </tr>\n    <tr>\n        <td>com.bmuschko.cargo</td>\n        <td>com.bmuschko.cargo-base</td>\n        <td><a href="http://bmuschko.github.io/gradle-cargo-plugin/docs/groovydoc/com/bmuschko/gradle/cargo/CargoPlugin.html">CargoPlugin</a></td>\n        <td>Provides a set of local and remote Cargo tasks and exposes extension for configuration.</td>\n    </tr>\n</table>\n\nThe `com.bmuschko.cargo` plugin helps you get started quickly. If you only need to deal with a single container product, this is the\npreferrable option. Most plugin users will go with this option. To use the Cargo plugin, include the following code snippet\nin your build script:\n\n    apply plugin: \'com.bmuschko.cargo\'\n\nIf you need full control over your deployment tasks, you will want to use the `com.bmuschko.cargo-base` plugin. The downside is that each task\nhas to be configured individually in your build script. To use the Cargo base plugin, include the following code snippet\nin your build script:\n\n    apply plugin: \'com.bmuschko.cargo-base\'\n\n### Configuring the Cargo version\n\nThe `com.bmuschko.cargo-base` plugin already sets up the dependencies for Cargo. In order to do so, it chooses a default\nversion of the libraries. Alternatively, you can define a custom version of the Cargo libraries. To do so, please use\nthe `cargo` configuration name in your `dependencies` closure. Remote deployment functionality will only work with a Cargo\nversion >= 1.1.0 due to a bug in the library. Please see [CARGO-962](https://codehaus-cargo.atlassian.net/browse/CARGO-962) for more information.\nThe following example demonstrates how to use the version 1.4.5 of the Cargo libraries:\n\n    dependencies {\n        def cargoVersion = \'1.4.5\'\n        cargo "org.codehaus.cargo:cargo-core-uberjar:$cargoVersion",\n              "org.codehaus.cargo:cargo-ant:$cargoVersion"\n    }\n\n## Tasks\n\nThe `cargo` plugin pre-defines the following tasks out-of-the-box:\n\n<table>\n    <tr>\n        <th>Task Name</th>\n        <th>Depends On</th>\n        <th>Type</th>\n        <th>Description</th>\n    </tr>\n    <tr>\n        <td>cargoDeployRemote</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-cargo-plugin/docs/groovydoc/com/bmuschko/gradle/cargo/tasks/remote/CargoDeployRemote.html">CargoDeployRemote</a></td>\n        <td>Deploys a deployable to remote container.</td>\n    </tr>\n    <tr>\n        <td>cargoUndeployRemote</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-cargo-plugin/docs/groovydoc/com/bmuschko/gradle/cargo/tasks/remote/CargoUndeployRemote.html">CargoUndeployRemote</a></td>\n        <td>Undeploys a deployable from remote container.</td>\n    </tr>\n    <tr>\n        <td>cargoRedeployRemote</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-cargo-plugin/docs/groovydoc/com/bmuschko/gradle/cargo/tasks/remote/CargoRedeployRemote.html">CargoRedeployRemote</a></td>\n        <td>Redeploys a deployable to remote container.</td>\n    </tr>\n    <tr>\n        <td>cargoRunLocal</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-cargo-plugin/docs/groovydoc/com/bmuschko/gradle/cargo/tasks/local/CargoRunLocal.html">CargoRunLocal</a></td>\n        <td>Starts the local container, deploys a deployable and waits for the user to press CTRL + C to stop.</td>\n    </tr>\n    <tr>\n        <td>cargoStartLocal</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-cargo-plugin/docs/groovydoc/com/bmuschko/gradle/cargo/tasks/local/CargoStartLocal.html">CargoStartLocal</a></td>\n        <td>Starts the local container, deploys a deployable and then do other tasks (for example, execute tests).</td>\n    </tr>\n    <tr>\n        <td>cargoRedeployLocal</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-cargo-plugin/docs/groovydoc/com/bmuschko/gradle/cargo/tasks/local/CargoRedeployLocal.html">CargoRedeployLocal</a></td>\n        <td>Redeploys a deployable on local container.</td>\n    </tr>\n    <tr>\n        <td>cargoStopLocal</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-cargo-plugin/docs/groovydoc/com/bmuschko/gradle/cargo/tasks/local/CargoStopLocal.html">CargoStopLocal</a></td>\n        <td>Stops local container.</td>\n    </tr>\n    <tr>\n        <td>cargoConfigureLocal</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-cargo-plugin/docs/groovydoc/com/bmuschko/gradle/cargo/tasks/local/CargoConfigureLocal.html">CargoConfigureLocal</a></td>\n        <td>Configures the local container.</td>\n    </tr>\n</table>\n\n## Project layout\n\nThe Cargo plugin uses the same layout as the War plugin.\n\n## Extension properties\n\nThe Cargo plugin defines the following convention properties in the `cargo` closure:\n\n* `containerId`: The container ID you are targeting. Please see the [list of supported containers](https://codehaus-cargo.github.io/cargo/Home.html) on the Cargo website.\n* `port`: The TCP port the container responds on (defaults to 8080).\n\nWithin `cargo` you can define optional properties for the 1..n deployment artifacts in a closure named `deployable`. Each\ndeployment artifact would be specified in its own closure:\n\n* `file`: Any type that can be passed to [Project.files(Object...)](https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#files-java.lang.Object...-) and resolves to a single file or a directory including arbitrary artifacts, exploded WAR directories and dependency configurations to be deployed to container (defaults to project/module artifact - WAR or EAR file).\n* `context`: The URL context the container is handling your web application on (defaults to WAR/EAR name).\n\nKeep in mind that you do not have to define the `deployable` closure if you just want to deploy the artifact defined by your\nGradle project/module.\n\nWithin `cargo` you can define properties for remote containers in a closure named `remote`:\n\n* `protocol`: The protocol of the remote container (defaults to `http`).\n* `hostname`: The hostname of the remote container.\n* `username`: The username credential for the remote container (optional).\n* `password`: The password credential for the remote container (optional).\n\nWithin `cargo` you can define properties for local containers in a closure named `local`:\n\n* `jvmArgs`: The JVM arguments for a local container.\n* `outputFile`: The log file of your local container (defaults to writing to the console).\n* `logFile`: The Cargo log file of your local container (defaults to writing to the console).\n* `logLevel`: The log level to run the container with (optional). The valid levels are `low`, `medium` and `high`.\n* `homeDir`: The home directory of your local container installation.\n* `configHomeDir`: The home directory of your local container\'s configuration.\n* `configFile`: The [configuration files](https://codehaus-cargo.github.io/cargo/Configuration+files+option.html) you want to add to your\ncontainer\'s configuration. The `configFile` is a closure itself and requires you to provide the attributes `files` and `toDir`.\nA [`FileCollection`](http://www.gradle.org/docs/current/javadoc/org/gradle/api/file/FileCollection.html) should be used as `files` attribute and `toDir` should be a `String`.\nMultiple configuration file destinations can be defined by creating more than one `configFile` closure.\n* `rmiPort`: The port to use when communicating with this server, for example to start and stop it.\n* `startStopTimeout`: The timeout (in ms) in which to determine if the container is successfully started or stopped (defaults to 120000ms).\n* `extraClasspath`: A [`FileCollection`](http://www.gradle.org/docs/current/javadoc/org/gradle/api/file/FileCollection.html)\nthat provides extra elements to the local [container classpath](http://cargo.codehaus.org/Container+Classpath) (optional).\n* `sharedClasspath`: A [`FileCollection`](http://www.gradle.org/docs/current/javadoc/org/gradle/api/file/FileCollection.html)\nthat provides extra elements to the [application classpath](https://codehaus-cargo.github.io/cargo/Application+Classpath.html), and not to the\nlocal container (optional).\n\n### Container properties\n\nWithin `local` and `remote` you can define container-specific properties. These properties can be looked up on\nthe Cargo homepage. The following example shows how to set the AJP port for a local Tomcat container:\n\n    cargo {\n        local {\n            containerProperties {\n                property \'cargo.tomcat.ajp.port\', 9099\n            }\n        }\n    }\n\n### System properties\n\nLocal containers can use system properties passed to it. The following example shows how to set a single system property named `myproperty`:\n\n    cargo {\n        local {\n            systemProperties {\n                property \'myproperty\', \'myvalue\'\n            }\n        }\n    }\n\n### Automatically bootstrapping a local container\n\nIf you decide to use the [ZIP installer](https://codehaus-cargo.github.io/cargo/Installer.html) Cargo will automatically download your container. You can\ndefine its properties in the closure `installer`. The installer only applies to "local" Cargo tasks.\n\n* `installUrl`: The URL to download the container distribution from.\n* `downloadDir`: Target directory to download the container distribution to.\n* `extractDir`: Directory to extract the downloaded container distribution to.\n\nPlease refer to the individual configuration properties on the Cargo homepage. All of these properties can be overridden\nby project properties. The name of the project properties is the same as in the Cargo manual.\n\nIf you wish to benefit from Gradle dependency cache when resolving container distributions you can use a configuration instead of a url when configuring the installer:\n\n    configurations {\n        tomcat\n    }\n    \n    dependencies {\n        tomcat "org.apache.tomcat:tomcat:9.0.14@zip"\n    }\n    \n    cargo {\n        local {\n            installer {\n                installConfiguration = configurations.tomcat\n            }\n        }\n    }\n\n### Example\n\n    cargo {\n        containerId = \'tomcat6x\'\n        port = 9090\n\n        deployable {\n            context = \'myawesomewebapp\'\n        }\n\n        remote {\n            hostname = \'cloud.internal.it\'\n            username = \'superuser\'\n            password = \'secretpwd\'\n        }\n\n        local {\n            homeDir = file(\'/home/user/dev/tools/apache-tomcat-6.0.32\')\n            outputFile = file(\'build/output.log\')\n            startStopTimeout = 60000\n\n            containerProperties {\n                property \'cargo.tomcat.ajp.port\', 9099\n            }\n        }\n    }\n\n## FAQ\n\n**I want to automatically assemble my project\'s artifact when executing a Cargo deployment task.**\n\nThe task `cargoRunLocal` does not automatically depend on the `assemble` task. The reason behind that is that you might\nnot want to deploy your project\'s artifact or your project does not generate a WAR or EAR file. Instead you might want\nto deploy one or more external artifacts. If your workflow looks like "compile the code", "generate the artifact" and "deploy"\nthen you make a Cargo deployment task depends on the `assemble` task. Here\'s one example:\n\n    cargoRunLocal.dependsOn assemble\n\n**I am working on a multi-project build. Can I apply the same Cargo configuration to all of my web projects?**\n\nGradle allows for filtering subprojects by certain criteria. To inject the relevant configuration from the root project\nof your build, you will need to identify all subprojects that apply the War plugin (of course the same concept works\nfor Ear projects). Use the `configure` method to apply the Cargo plugin and your configuration as shown in the following\ncode snippet:\n\n    def webProjects() {\n        subprojects.findAll { subproject -> subproject.plugins.hasPlugin(\'war\') }\n    }\n\n    gradle.projectsEvaluated {\n        configure(webProjects()) {\n            apply plugin: \'com.bmuschko.cargo\'\n\n            cargo {\n                containerId = \'tomcat7x\'\n\n                remote {\n                    hostname = \'localhost\'\n                    username = \'manager\'\n                    password = \'manager\'\n                }\n            }\n        }\n    }\n\n**I would like to deploy multiple artifacts to my container. How do I do that?**\n\nYou would specify each artifact in a separate `deployable` closure. Each of the closures should assign a unique URL context.\nThe following example demonstrates how a Cargo setup with three different artifacts deployed to a local Tomcat:\n\n    cargo {\n        containerId = \'tomcat6x\'\n        port = 9090\n\n        deployable {\n            file = file(\'/home/foo/bar/web-services.war\')\n            context = \'web-services\'\n        }\n\n        deployable {\n            file = file(\'/home/foo/bar/web-app.war\')\n            context = \'web-app\'\n        }\n\n        deployable {\n            file = file(\'/home/foo/bar/enterprise-app.ear\')\n            context = \'enterprise-app\'\n        }\n\n        local {\n            homeDir = file(\'/home/user/dev/tools/apache-tomcat-6.0.32\')\n        }\n    }\n\n**Is there a way to let Cargo automatically install the container I\'d like to use?**\n\nCargo allows for defining a container that gets automatically downloaded and installed on your local disk. All you need to\ndo is to specify the `installer` closure. The following code snippet downloads, installs and uses Tomcat 7:\n\n    cargo {\n        containerId = \'tomcat7x\'\n\n        local {\n            installer {\n                installUrl = \'http://apache.osuosl.org/tomcat/tomcat-7/v7.0.27/bin/apache-tomcat-7.0.27.zip\'\n                downloadDir = file("$buildDir/download")\n                extractDir = file("$buildDir/extract")\n            }\n        }\n    }\n\n**I\'d like to add a configuration file to my local container. How do I do that?**\n\nFor local containers a closure named `configFile` can be used that defines the source files and directory you would like\nto use the file from at runtime. If you need to copy files into more than one destinations just create multiple `configFile` closures.\n\n    cargo {\n        containerId = \'jboss5x\'\n\n        local {\n            configFile {\n                files = project.files(\'src/main/jboss5/login-config.xml\')\n                toDir = \'conf\'\n            }\n\n            configFile {\n                files = project.files(\'src/main/jboss5/login-config.xml\', \'src/main/jboss5/sample-users.properties\')\n                toDir = \'conf/props\'\n            }\n        }\n    }\n\nTo add binary file(s) you should use `file` closure(s) instead:\n\n    cargo {\n        containerId = \'glassfish3x\'\n\n        local {\n            file {\n                file = file(\'../config/db/mysql-connector-java-5.1.23-bin.jar\')\n                toDir = \'lib\'\n            }\n        }\n    }\n\n**I want to set up and configure my own Cargo task for more than one container. Can this be done?**\n\nAbsolutely. The Cargo base plugin provides all tasks needed to set up deployment tasks. All you need to do is to create one\nor more tasks and configure the mandatory properties. The following example shows how to set up local container tasks\nfor Tomcat and Jetty:\n\n    apply plugin: \'com.bmuschko.cargo-base\'\n\n    task myTomcatRun(type: com.bmuschko.gradle.cargo.tasks.local.CargoRunLocal) {\n        containerId = \'tomcat7x\'\n        homeDir = file(\'/home/user/dev/tools/apache-tomcat-7.0.42\')\n    }\n\n    task myJettyRun(type: com.bmuschko.gradle.cargo.tasks.local.CargoRunLocal) {\n        containerId = \'jetty9x\'\n        homeDir = file(\'/home/user/dev/tools/jetty-distribution-9.0.4.v20130625\')\n    }\n\n**I\'d like to create deployment tasks for a rolling deployment to multiple remote containers. How do I do this?**\n\nGradle allows for dynamically creating tasks based on your build script logic. The following example shows how to create\nthree Tomcat deployment tasks and how to configure them with the help of a simple data structure. At the end of the script we\nalso add another task that triggers the deployment to all remote containers.\n\n    class RemoteContainer {\n        String name\n        String hostname\n        Integer port\n        String username\n        String password\n    }\n\n    def remoteContainers = [new RemoteContainer(name: \'tomcat1\', hostname: \'remote-tomcat1\',\n                                                port: 9090, username: \'admin\', password: \'s3cr3t\'),\n                            new RemoteContainer(name: \'tomcat2\', hostname: \'remote-tomcat2\',\n                                                port: 8050, username: \'deployer\', password: \'qwerty\'),\n                            new RemoteContainer(name: \'tomcat3\', hostname: \'remote-tomcat3\',\n                                                port: 8888, username: \'su\', password: \'powerful\')]\n\n    apply plugin: \'com.bmuschko.cargo-base\'\n\n    remoteContainers.each { config ->\n        task "deployRemote${config.name.capitalize()}"(type: com.bmuschko.gradle.cargo.tasks.remote.CargoDeployRemote) {\n            description = "Deploys WAR to remote Tomcat \'${config.name}\'."\n            containerId = \'tomcat7x\'\n            hostname = config.hostname\n            port = config.port\n            username = config.username\n            password = config.password\n        }\n    }\n\n    task deployToAllRemoteTomcats {\n        dependsOn remoteContainers.collect { "deployRemote${it.name.capitalize()}" }\n        description = \'Deploys to all remote Tomcat containers.\'\n        group = \'deployment\'\n    }\n\n**Before a remote deployment I would like to restart my container. Can this be done?**\n\nYes, this is possible with the help of the [Cargo daemon](https://codehaus-cargo.github.io/cargo/Cargo+Daemon.html) functionality. Please\nrefer to the Cargo online documentation for setting up the Cargo daemon JVM process and configuring a container. With\nthis plugin, you can use custom tasks to start and stop a container. The following example stops, starts and then redeploys\nan artifact.\n\n    apply plugin: \'com.bmuschko.cargo\'\n\n    cargo {\n        ...\n    }\n\n    ext.tomcat7HandleId = \'tomcat7\'\n\n    task cargoDaemonStop(type: com.bmuschko.gradle.cargo.tasks.daemon.CargoDaemonStop) {\n        handleId = tomcat7HandleId\n    }\n\n    task cargoDaemonStart(type: com.bmuschko.gradle.cargo.tasks.daemon.CargoDaemonStart) {\n        handleId = tomcat7HandleId\n    }\n\n    cargoDaemonStart.mustRunAfter cargoDaemonStop\n    cargoRedeployRemote.dependsOn cargoDaemonStop, cargoDaemonStart\n\n'