b'# Gradle Tomcat plugin [![Build Status](https://travis-ci.org/bmuschko/gradle-tomcat-plugin.svg?branch=master)](https://travis-ci.org/bmuschko/gradle-tomcat-plugin)\n\n![Tomcat Logo](http://tomcat.apache.org/res/images/tomcat.png)\n\n<table border=1>\n    <tr>\n        <td>\n            Over the past couple of years this plugin has seen many releases. Thanks to everyone involved! \n            Unfortunately, I don\'t have much time to contribute anymore. In practice this means far less activity, \n            responsiveness on issues and new releases from my end.\n        </td>\n    </tr>\n    <tr>\n        <td>\n            I am \n            <a href="https://discuss.gradle.org/t/looking-for-new-owners-for-gradle-plugins/9735">actively looking for contributors</a> \n            willing to take on maintenance and implementation of the project. If you are interested and would love to see this \n            plugin continue to thrive, shoot me a <a href="mailto:benjamin.muschko@gmail.com">mail</a>.\n        </td>\n    </tr>\n</table>\n\nThe plugin provides deployment capabilities of web applications to an embedded Tomcat web container in any given\nGradle build. It extends the [War plugin](http://www.gradle.org/war_plugin.html). At the moment the Tomcat versions\n6.0.x, 7.0.x, 8.0.x, 8.5.x and 9.0.x are supported.\n\nThe typical use case for this plugin is to support deployment during development. The plugin allows for rapid web application\ndevelopment due to the container\'s fast startup times. Gradle starts the embedded container in the same JVM. Currently,\nthe container cannot be forked as a separate process. This plugin also can\'t deploy a WAR file to a remote container. If\nyou are looking for this capability, please have a look at the [Cargo plugin](https://github.com/bmuschko/gradle-cargo-plugin)\ninstead.\n\n## Usage\n\nTo use the plugin\'s functionality, you will need to add the its binary artifact to your build script\'s classpath and apply the plugin.\n\n### Adding the plugin binary to the build\n\nThe plugin JAR needs to be defined in the classpath of your build script. It is directly available on\n[Bintray](https://bintray.com/bmuschko/gradle-plugins/com.bmuschko%3Agradle-tomcat-plugin).\nThe following code snippet shows an example on how to retrieve it from Bintray:\n\n```groovy\nbuildscript {\n    repositories {\n        jcenter()\n    }\n\n    dependencies {\n        classpath \'com.bmuschko:gradle-tomcat-plugin:2.5\'\n    }\n}\n```\n\n### Provided plugins\n\nThe JAR file comes with two plugins:\n\n<table>\n    <tr>\n        <th>Plugin Identifier</th>\n        <th>Depends On</th>\n        <th>Type</th>\n        <th>Description</th>\n    </tr>\n    <tr>\n        <td>com.bmuschko.tomcat-base</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-tomcat-plugin/docs/groovydoc/com/bmuschko/gradle/tomcat/TomcatBasePlugin.html">TomcatBasePlugin</a></td>\n        <td>Provides Tomcat custom task types, pre-configures classpath.</td>\n    </tr>\n    <tr>\n        <td>com.bmuschko.tomcat</td>\n        <td>com.bmuschko.tomcat-base</td>\n        <td><a href="http://bmuschko.github.io/gradle-tomcat-plugin/docs/groovydoc/com/bmuschko/gradle/tomcat/TomcatPlugin.html">TomcatPlugin</a></td>\n        <td>Provides tasks for starting and stopping an embedded Tomcat container and exposes extension named <code>tomcat</code>.</td>\n    </tr>\n</table>\n\nThe `com.bmuschko.tomcat` plugin helps you get started quickly. If you are OK if the preconfigured tasks, this is the\npreferrable option. Most plugin users will go with this option. To use the Tomcat plugin, include the following code snippet\nin your build script:\n\n    apply plugin: \'com.bmuschko.tomcat\'\n\nIf you need full control over your tasks or don\'t want to go with the preconfigured tasks, you will want to use the `com.bmuschko.tomcat-base`\nplugin. That might be the case if you want to set up the container solely for functional testing. The downside is that each task\nhas to be configured individually in your build script. To use the Tomcat base plugin, include the following code snippet\nin your build script:\n\n    apply plugin: \'com.bmuschko.tomcat-base\'\n\n### Assigning the Tomcat libraries\n\nAdditionally, the Tomcat runtime libraries need to be added to the configuration `tomcat`. At the moment the Tomcat\nversions 6.0.x, 7.0.x, 8.0.x, 8.5.x and 9.0.x are supported by the plugin. Make sure you don\'t mix up Tomcat libraries of different\nversions.\n\n**Tomcat 6.0.x:**\n\n```groovy\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    def tomcatVersion = \'6.0.51\'\n    tomcat "org.apache.tomcat:catalina:${tomcatVersion}",\n           "org.apache.tomcat:coyote:${tomcatVersion}",\n           "org.apache.tomcat:jasper:${tomcatVersion}"\n}\n```\n\n**Tomcat 7.0.x:**\n\n```groovy\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    def tomcatVersion = \'7.0.76\'\n    tomcat "org.apache.tomcat.embed:tomcat-embed-core:${tomcatVersion}",\n           "org.apache.tomcat.embed:tomcat-embed-logging-juli:${tomcatVersion}",\n           "org.apache.tomcat.embed:tomcat-embed-jasper:${tomcatVersion}"\n}\n```\n\n**Tomcat 8.0.x:**\n\n```groovy\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    def tomcatVersion = \'8.0.42\'\n    tomcat "org.apache.tomcat.embed:tomcat-embed-core:${tomcatVersion}",\n           "org.apache.tomcat.embed:tomcat-embed-logging-juli:${tomcatVersion}",\n           "org.apache.tomcat.embed:tomcat-embed-jasper:${tomcatVersion}"\n}\n```\n\n**Tomcat 8.5.x:**\n\nPlease be aware that the dependency `tomcat-embed-logging-juli` is only required to enable container logging via Log4J 1.x (which is no longer support by the Log4J community). Log4J 2.x can be used for container logging without declaring any extra libraries.\n\n```groovy\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    def tomcatVersion = \'8.5.16\'\n    tomcat "org.apache.tomcat.embed:tomcat-embed-core:${tomcatVersion}",\n           "org.apache.tomcat.embed:tomcat-embed-logging-juli:8.5.2",\n           "org.apache.tomcat.embed:tomcat-embed-jasper:${tomcatVersion}"\n}\n\ntomcat {\n    httpProtocol = \'org.apache.coyote.http11.Http11Nio2Protocol\'\n    ajpProtocol  = \'org.apache.coyote.ajp.AjpNio2Protocol\'\n}\n```\n\n**Tomcat 9.0.x:**\n\nPlease be aware that the dependency `tomcat-embed-logging-juli` is only required to enable container logging via Log4J 1.x (which is no longer support by the Log4J community). Log4J 2.x can be used for container logging without declaring any extra libraries.\n\n```groovy\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    def tomcatVersion = \'9.0.1\'\n    tomcat "org.apache.tomcat.embed:tomcat-embed-core:${tomcatVersion}",\n           "org.apache.tomcat.embed:tomcat-embed-logging-juli:9.0.0.M6",\n           "org.apache.tomcat.embed:tomcat-embed-jasper:${tomcatVersion}"\n}\n\ntomcat {\n    httpProtocol = \'org.apache.coyote.http11.Http11Nio2Protocol\'\n    ajpProtocol  = \'org.apache.coyote.ajp.AjpNio2Protocol\'\n}\n```\n\n## Tasks\n\nThe `com.bmuschko.tomcat` plugin pre-defines the following tasks out-of-the-box:\n\n<table>\n    <tr>\n        <th>Task Name</th>\n        <th>Depends On</th>\n        <th>Type</th>\n        <th>Description</th>\n    </tr>\n    <tr>\n        <td>tomcatRun</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-tomcat-plugin/docs/groovydoc/com/bmuschko/gradle/tomcat/tasks/TomcatRun.html">TomcatRun</a></td>\n        <td>Starts a Tomcat instance and deploys the exploded web application to it.</td>\n    </tr>\n    <tr>\n        <td>tomcatRunWar</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-tomcat-plugin/docs/groovydoc/com/bmuschko/gradle/tomcat/tasks/TomcatRunWar.html">TomcatRunWar</a></td>\n        <td>Starts a Tomcat instance and deploys the WAR to it.</td>\n    </tr>\n    <tr>\n        <td>tomcatStop</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-tomcat-plugin/docs/groovydoc/com/bmuschko/gradle/tomcat/tasks/TomcatStop.html">TomcatStop</a></td>\n        <td>Stops the Tomcat instance.</td>\n    </tr>\n    <tr>\n        <td>tomcatJasper</td>\n        <td>-</td>\n        <td><a href="http://bmuschko.github.io/gradle-tomcat-plugin/docs/groovydoc/com/bmuschko/gradle/tomcat/tasks/TomcatJasper.html">TomcatJasper</a></td>\n        <td>Runs the JSP compiler and turns JSP pages into Java source using <a href="http://tomcat.apache.org/tomcat-7.0-doc/jasper-howto.html">Jasper</a>.</td>\n    </tr>\n</table>\n\n## Project layout\n\nThe Tomcat plugin uses the same layout as the War plugin.\n\n## Extension properties\n\nThe Tomcat plugin exposes the following properties through the extension named `tomcat`:\n\n* `httpPort`: The TCP port which Tomcat should listen for HTTP requests on (defaults to `8080`).\n* `httpsPort`: The TCP port which Tomcat should listen for HTTPS requests on (defaults to `8443`).\n* `ajpPort`: The TCP port which Tomcat should listen for AJP requests on (defaults to `8009`).\n* `stopPort`: The TCP port which Tomcat should listen for admin requests on (defaults to `8081`).\n* `stopKey`: The key to pass to Tomcat when requesting it to stop (defaults to `null`).\n* `contextPath`: The URL context path under which the web application will be registered (defaults to WAR name).\n* `enableSSL`: Determines whether the HTTPS connector should be created (defaults to `false`).\n* `daemon`: Specifies whether the Tomcat server should run in the background. When true, this task completes as soon as the\nserver has started. When false, this task blocks until the Tomcat server is stopped (defaults to `false`).\n* `keystoreFile`: The keystore file to use for SSL, if enabled (by default, a keystore will be generated).\n* `httpProtocol`: The HTTP protocol handler class name to be used (defaults to `org.apache.coyote.http11.Http11Protocol`).\n* `httpsProtocol`: The HTTPS protocol handler class name to be used (defaults to `org.apache.coyote.http11.Http11Protocol`).\n* `ajpProtocol`: The AJP protocol handler class name to be used (defaults to `org.apache.coyote.ajp.AjpProtocol`).\n* `users`: List of users with `username`, `password` and `roles`. Used to configure tomcat with basic authentication \nwith these users.\n\n### Example\n\nThe following example code shows how to change the default HTTP/HTTPS ports. To enable SSL we set the property `enableSSL` to `true`.\nThe web application will be accessible under the context path `sample-app`.\n\n```groovy\ntomcat {\n    httpPort = 8090\n    httpsPort = 8091\n    enableSSL = true\n    contextPath = \'sample-app\'\n    \n    users {\n        user {\n            username = \'user1\'\n            password = \'123456\'\n            roles = [\'developers\', \'admin\']\n        }\n\n        user {\n            username = \'user2\'\n            password = \'abcdef\'\n            roles = [\'manager\']\n        }\n    }\n}\n```\n\n## Task properties\n\nFurthermore, you can set the following optional task properties:\n\n* `contextPath`: The URL context path your web application will be registered under (defaults to WAR name).\n* `webDefaultXml`: The default web.xml. If it doesn\'t get defined an instance of `org.apache.catalina.servlets.DefaultServlet`\nand `org.apache.jasper.servlet.JspServlet` will be set up.\n* `additionalRuntimeResources`: Defines additional runtime JARs or directories that are not provided by the web application.\n* `URIEncoding`: Specifies the character encoding used to decode the URI bytes by the HTTP Connector (defaults to `UTF-8`).\n* `daemon`: Specifies whether the Tomcat server should run in the background. When true, this task completes as soon as the\nserver has started. When false, this task blocks until the Tomcat server is stopped (defaults to `false`).\n* `configFile`: The path to the Tomcat context XML file (defaults to `src/main/webapp/META-INF/context.xml` for `tomcatRun`,\ndefaults to `META-INF/context.xml` within the WAR for `tomcatRunWar`).\n* `outputFile`: The file to write Tomcat log messages to. If the file already exists new messages will be appended.\n* `reloadable`: Forces context scanning if you don\'t use a context file (defaults to `true`).\n* `keystorePass`: The keystore password to use for SSL, if enabled.\n* `truststoreFile`: The truststore file to use for SSL, if enabled.\n* `truststorePass`: The truststore password to use for SSL, if enabled.\n* `clientAuth`: The clientAuth setting to use, values may be: `true`, `false` or `want` (defaults to `false`).\n\nNote: `keystoreFile` and `truststoreFile` each require an instance of a `File` object e.g. `file("/path/my.file")`\n\n### Example\n\nIn the following example code, we declare a custom context file for the task `tomcatRun`.\n\n```groovy\ntomcatRun.configFile = file(\'context.xml\')\n```\n\nTo configure the Jasper compiler task you can choose to set the following properties within the `jasper` closure of the\n`tomcat` extension:\n\n* `validateXml`: Determines whether `web.xml` should be validated (defaults to `null`).\n* `validateTld`: Determines whether `web.xml` should be validated (defaults to `null`).\n* `uriroot`: The web application root directory (defaults to `src/main/webapp`).\n* `webXmlFragment`: The generated web XML fragment file to be referenced by your `web.xml` file.\n* `addWebXmlMappings`: Automatically add the generated web XML fragment to the `web.xml` file.  Caution: this will modify the `web.xml` file in the project, not the build directory.\n* `outputDir`: The output directory the compiled JSPs will end up in (defaults to `build/jasper`).\n* `classdebuginfo`: Should the class file be compiled with debugging information (defaults to `true`).\n* `compiler`: Which compiler Ant should use to compile JSP pages. See the Ant documentation for more information. If the value is not set, then the default Eclipse JDT Java compiler will be used instead of using Ant. No default value.\n* `compilerSourceVM`: What JDK version are the source files compatible with (defaults to `1.6`).\n* `compilerTargetVM`: What JDK version are the generated files compatible with (defaults to `1.6`).\n* `poolingEnabled`: Determines whether tag handler pooling is enabled. This is a compilation option. It will not alter the behaviour of JSPs that have already been compiled (defaults to `true`).\n* `errorOnUseBeanInvalidClassAttribute`: Should Jasper issue an error when the value of the class attribute in an useBean action is not a valid bean class (defaults to `true`).\n* `genStringAsCharArray`: Should text strings be generated as char arrays, to improve performance in some cases (defaults to `false`).\n* `ieClassId`: The class-id value to be sent to Internet Explorer when using `<jsp:plugin>` tags (defaults to `clsid:8AD9C840-044E-11D1-B3E9-00805F499D93`).\n* `javaEncoding`: Java file encoding to use for generating java source files (defaults to `UTF8`).\n* `trimSpaces`: Should white spaces in template text between actions or directives be trimmed (defaults to `TrimSpaces.TRUE`).\n* `xpoweredBy`: Determines whether X-Powered-By response header is added by generated servlet (defaults to `false`).\n\n### Example\n\n```groovy\ntomcat {\n    jasper {\n        validateXml = true\n        webXmlFragment = file("$webAppDir/WEB-INF/generated_web.xml")\n        outputDir = file("$webAppDir/WEB-INF/src")\n    }\n}\n```\n\n## FAQ\n\n**I get a compile exception when calling a JSP. Is there something I am missing?**\n\nThe exception you might see is probably similar to this one: `org.apache.jasper.JasperException: Unable to compile class for JSP`.\nTomcat 7.x and 8.x requires you to have [Eclipse ECJ 3.6.x](http://www.eclipse.org/jdt/core/) in your the classpath. However, this\nversion of the dependency does not exist in Maven Central. You\'ll have to download that dependency and put it in your own\nrepository or define a repository on your local disk where you can drop it in. Here\'s an example:\n\n```groovy\nrepositories {\n     flatDir name: \'localRepository\', dirs: \'lib\'\n}\n```\n\n**Why do I get a `java.lang.ClassCastException` on `javax.servlet.Servlet`?**\n\nTomcat is very sensitive to having multiple versions of the dependencies `javax.servlet:servlet-api` and `javax.servlet:jsp-api`\nin its classpath. By default they already get pulled in as transitive dependencies of the embedded Tomcat libraries. The\nexception you might see looks similar to this one:\n\n```\njava.lang.ClassCastException: org.springframework.web.servlet.DispatcherServlet cannot be cast to javax.servlet.Servlet\n        at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1062)\n        at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:1010)\n        at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4935)\n        at org.apache.catalina.core.StandardContext$3.call(StandardContext.java:5262)\n        at org.apache.catalina.core.StandardContext$3.call(StandardContext.java:5257)\n        at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:138)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n        at java.lang.Thread.run(Thread.java:662)\n```\n\nTo fix this make sure you define your JSP and Servlet module dependencies with the scope `providedCompile` like this:\n\n```groovy\nprovidedCompile \'javax.servlet:servlet-api:2.5\',\n                \'javax.servlet:jsp-api:2.0\'\n```\n\n**How do I remote debug my Tomcat started up by the plugin?**\n\nIf you want to be able to debug your application remotely you have to set the following JVM options in your `GRADLE_OPTS`\nenvironment variable before starting up the container. The port number you choose is up to you.\n\n```\n-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005\n```\n\nTomcat will then listen on the specified port for incoming remote debugging connections. When starting up the container\nyou should see the following message:\n\n```\nListening for transport dt_socket at address: 5005\n```\n\nCheck your IDE documentation on how to configure connecting to the remote debugging port.\n\n* [IntelliJ Remote Run/Debug Configuration](http://www.jetbrains.com/idea/webhelp/run-debug-configuration-remote.html)\n* [Eclipse Remote Debugging](http://help.eclipse.org/indigo/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Fconcepts%2Fcremdbug.htm)\n\n**My Tomcat container needs to use a JNDI datasource. How do I set up my project?**\n\nFirst of all you got to make sure to declare the connection pool dependency using the `tomcat` configuration.\n\n**Tomcat 6.0.x:**\n\n```groovy\ndef tomcatVersion = \'6.0.35\'\ntomcat "org.apache.tomcat:dbcp:${tomcatVersion}"\n```\n\nSee [coordinates on Maven Central](https://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.tomcat%22%20AND%20a%3A%22dbcp%22) for details.\n\n**Later versions:**\n\n```groovy\ndef tomcatVersion = \'9.0.8\'\ntomcat "org.apache.tomcat:tomcat-dbcp:${tomcatVersion}"\n```\n\nSee [coordinates on Maven Central](https://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.tomcat%22%20AND%20a%3A%22tomcat-dbcp%22) for details.\n\nIf you decide to go with the default settings place your `context.xml` in the directory `src/main/webapp/META-INF`. To\nset a custom location you can use the convention property `configFile`. Here\'s an example on how to set it for the tasks\n`tomcatRun` and `tomcatRunWar`.\n\n```groovy\n[tomcatRun, tomcatRunWar]*.configFile = file(\'context.xml\')\n```\n\nPlease refer to the [Tomcat documentation](http://tomcat.apache.org/tomcat-7.0-doc/config/context.html#Defining_a_context) for a list\nof context attributes. The following example shows how to set up a MySQL JNDI datasource.\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<Context>\n    <Resource name="jdbc/mydatabase"\n              auth="Container"\n              type="javax.sql.DataSource"\n              username="superuser"\n              password="secretpasswd"\n              driverClassName="com.mysql.jdbc.Driver"\n              url="jdbc:mysql://localhost:3306/mydb"\n              validationQuery="select 1"\n              maxActive="10"\n              maxIdle="4"/>\n</Context>\n```\n\n**How do I use hot code deployment with the plugin?**\n\nThe plugin provides out-of-the-box support for swapping out byte code through the property `reloadable`. By default this option\nis turned out so you don\'t need any additional configuration changes. All you need to do is to have a running instance of the\ncontainer initiated by `tomcatRun`. Fire up your favorite editor, change a production source file, save it and recompile your\nsources in another terminal via `gradle compileJava`. After a couple of seconds the context is reloaded and you should see the\nbehavior reflected in the terminal window running the container:\n\n```\nReloading Context with name [/myapp] has started\nReloading Context with name [/myapp] is completed\n```\n\nAlternatively, you can use other commericial byte code swap technologies. The configuration is usually product-specific.\nPlease refer to the product\'s documentation on how to set it up for your project. The following section describes how to set up Gradle and the plugin with [JRebel](http://zeroturnaround.com/jrebel/).\nFirst of all download [JRebel](http://zeroturnaround.com/jrebel/current/), install it on your machine and set up the [license](http://zeroturnaround.com/reference-manual/install.html#install-1.3).\nTo tell JRebel which directory to scan for changed byte code you need to create a [rebel.xml](file://localhost/Users/benjamin/dev/tools/jrebel/doc/app.html#app) file. In\nyour web module place the file under `build/classes/main` so it can be loaded by the Tomcat plugin. For creating the configuration of the file\nthe [Gradle JRebel plugin](http://zeroturnaround.com/blog/jrebel-gradle-plugin-beta/) comes in handy. It\'s not required\nto use the plugin. You can also decide to create the configuration by hand. Keep in mind that `gradle clean` will delete the file. \nFor setting up JRebel in a multi-module project scenario please refer to the documentation. The following code snippet shows an example\n`rebel.xml` file.\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<application xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.zeroturnaround.com"\n            xsi:schemaLocation="http://www.zeroturnaround.com http://www.zeroturnaround.com/alderaan/rebel-2_0.xsd">\n    <classpath>\n        <dir name="/Users/ben/dev/projects/mywebproject/build/classes/main">\n        </dir>\n    </classpath>\n\n    <web>\n        <link target="/">\n            <dir name="/Users/ben/dev/projects/mywebproject/src/main/webapp">\n            </dir>\n        </link>\n    </web>\n</application>\n```\n\nEdit your Gradle startup script and add the following line to it to tell Gradle to [use the JRebel agent](http://zeroturnaround.com/reference-manual/server.html#server-4.5.36).\nPlease make sure to set the environment variable `REBEL_HOME` that points to your JRebel installation directory.\n\n```\nJAVA_OPTS="-javaagent:$REBEL_HOME/jrebel.jar $JAVA_OPTS"\n```\n\nOn startup of your web module using `gradle tomcatRun` you should see information about the JRebel license being used and\nthe directories being scanned for changes. For our example `rebel.xml` file it would look like this:\n\n```\nJRebel: Directory \'/Users/ben/dev/projects/mywebproject/build/classes/main\' will be monitored for changes.\nJRebel: Directory \'/Users/ben/dev/projects/mywebproject/src/main/webapp\' will be monitored for changes.\n```\n\nIf a file has been recompiled JRebel indicates this by writing it to the console like this:\n\n```\nJRebel: Reloading class \'de.muschko.web.controller.TestController\'.\n```\n\n**In need to run in-container integration tests as part of my build. What needs to be done?**\n\nUsually unit and integration tests are kept separate by convention. One convention could be to name the test source\nfiles differently e.g. integration tests always end with the suffix `IntegrationTest`, unit test files end with `Test`.\nBy doing that you can run them separately. For running the integration tests you will want to run the Tomcat task as daemon\nthread and shut it down once your tests are done. The following example demonstrates how to set up a Gradle task that provides this\nfunctionality. Of course this is only one way of doing it. The following example requires Gradle >= 1.7:\n\n```groovy\napply plugin: \'com.bmuschko.tomcat-base\'\n\next {\n    tomcatStopPort = 8081\n    tomcatStopKey = \'stopKey\'\n}\n\ntask integrationTomcatRun(type: com.bmuschko.gradle.tomcat.tasks.TomcatRun) {\n    stopPort = tomcatStopPort\n    stopKey = tomcatStopKey\n    daemon = true\n}\n\ntask integrationTomcatStop(type: com.bmuschko.gradle.tomcat.tasks.TomcatStop) {\n    stopPort = tomcatStopPort\n    stopKey = tomcatStopKey\n}\n\ntask integrationTest(type: Test) {\n    include \'**/*IntegrationTest.*\'\n    dependsOn integrationTomcatRun\n    finalizedBy integrationTomcatStop\n}\n\ntest {\n    exclude \'**/*IntegrationTest.*\'\n}\n```\n\n**How do I add JAR files or directories that are not part of my web application source code?**\n\nEvery task of type `AbstractTomcatRun` exposes a property named `additionalRuntimeResources` that is used to mixed in\nwith the web application runtime classpath.\n\n```groovy\n[tomcatRun, tomcatRunWar].each { task ->\n    task.additionalRuntimeResources << file(\'/Users/bmuschko/config/props\')\n    task.additionalRuntimeResources << file(\'/Users/bmuschko/ext/jars/my.jar\')\n}\n```\n'