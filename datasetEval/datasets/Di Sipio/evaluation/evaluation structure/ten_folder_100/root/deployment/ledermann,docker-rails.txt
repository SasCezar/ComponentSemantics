b'# Docker-Rails\n\n[![Code Climate](https://codeclimate.com/github/ledermann/docker-rails/badges/gpa.svg)](https://codeclimate.com/github/ledermann/docker-rails)\n[![Issue Count](https://codeclimate.com/github/ledermann/docker-rails/badges/issue_count.svg)](https://codeclimate.com/github/ledermann/docker-rails)\n[![Depfu](https://badges.depfu.com/badges/2f883bd05b4dca8448484ff9289ea15f/overview.svg)](https://depfu.com/github/ledermann/docker-rails)\n[![](https://images.microbadger.com/badges/image/ledermann/docker-rails.svg)](https://microbadger.com/images/ledermann/docker-rails)\n\nSimple Rails 6 application to demonstrate using Docker for production deployment. The application is a very simple kind of CMS (content management system) allowing to manage posts. Beside the boring [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) functionality it has some non-default features.\n\nThis project aims to build a lean Docker image for use in production. Therefore it\'s based on the official Alpine Ruby image, uses multi-stage building and some [optimizations that I described in my blog](https://www.georg-ledermann.de/blog/2018/04/19/dockerize-rails-the-lean-way/). This results in an image size of ~80MB.\n\n\n## Features\n\n- Auto refresh via [ActionCable](https://github.com/rails/rails/tree/master/actioncable): If a displayed post gets changed by another user/instance, it refreshes automatically using the publish/subscribe pattern\n- Full text search via [Elasticsearch](https://www.elastic.co/products/elasticsearch) and the [Searchkick](https://github.com/ankane/searchkick) gem to find post content (with suggestions)\n- Autocompletion with [autocompleter](https://github.com/kraaden/autocomplete)\n- Editing HTML content with the WYSIWYG JavaScript editor [Trix](https://github.com/basecamp/trix)\n- Uploading images directly to S3 with the [Shrine](https://github.com/janko-m/shrine) gem and [jQuery-File-Upload](https://github.com/blueimp/jQuery-File-Upload)\n- Background jobs with [ActiveJob](https://github.com/rails/rails/tree/master/activejob) and the [Sidekiq](http://sidekiq.org/) gem (to handle full text indexing, image processing and ActionCable broadcasting)\n- Cron scheduling with [Sidekiq-Cron](https://github.com/ondrejbartas/sidekiq-cron) to handle daily data updates from Wikipedia\n- Permalinks using the [FriendlyId](https://github.com/norman/friendly_id) gem\n- Infinitive scrolling (using the [Kaminari](https://github.com/kaminari/kaminari) gem and some JavaScript)\n- User authentication with the [Clearance](https://github.com/thoughtbot/clearance/) gem\n- Sending HTML e-mails with [Premailer](https://github.com/fphilipe/premailer-rails) and the [Really Simple Responsive HTML Email Template](https://github.com/leemunroe/responsive-html-email-template)\n- Admin dashboards with [Blazer](https://github.com/ankane/blazer) gem\n- JavaScript with [Stimulus](https://stimulusjs.org/)\n- Bundle JavaScript libraries with [Yarn](https://yarnpkg.com)\n\n\n## Why?\n\nThis project demonstrates my way of building Rails applications. The techniques used to build the app should not be considered as "best practice", maybe there are better ways to build. Any [feedback](https://github.com/ledermann/docker-rails/issues/new) would be appreciated.\n\n\n## Multi container architecture\n\nThere is a separate **docker-compose.yml** for every environment: [development](docker-compose.yml), [test](docker-compose.test.yml) and [production](docker-compose.production.yml). The whole stack is divided into multiple different containers:\n\n- **app:** Main part. It contains the Rails code to handle web requests (by using the [Puma](https://github.com/puma/puma) gem). See the [Dockerfile](/Dockerfile) for details. The image is based on the Alpine variant of the official [Ruby image](https://hub.docker.com/_/ruby/) and uses multi-stage building.\n- **worker:** Background processing. It contains the same Rails code, but only runs Sidekiq\n- **db:** PostgreSQL database\n- **elasticsearch:** Full text search engine\n- **redis:** In-memory key/value store (used by Sidekiq, ActionCable and for caching)\n- **backup:** Regularly backups the database as a dump via CRON to an Amazon S3 bucket\n\nFor running tests using RSpec, there is an additional container:\n\n- **selenium:** Standalone Chrome for executing system tests containing JavaScript\n\n## Check it out!\n\nTo start up the application in your local Docker environment:\n\n```bash\ngit clone https://github.com/ledermann/docker-rails.git\ncd docker-rails\ndocker-compose build\ndocker-compose run app yarn install\ndocker-compose up\n```\n\nWait some minutes while the database will be prepared by fetching articles from Wikipedia. Then,\nnavigate your browser to `http://[DOCKER_HOST]:[DOCKER_PORT]`.\n\nSign in to the admin account:\n\n* Username: `admin@example.org`\n* Password: `secret`\n\nEnjoy!\n\n\n## Tests / CI\n\nOn every push, the test suite (including [RuboCop](https://github.com/bbatsov/rubocop) checks) is run and a production image is built via [GitHub Actions](https://github.com/ledermann/docker-rails/actions). If successful, the new Docker image is pushed to a private GitLab Docker Registry.\n\n\n## Production deployment\n\nThe Docker image build for production is different from development or test. It includes precompiled assets only (no node_modules and no sources). The [spec folder](/spec) is removed and the Alpine packages for Node and Yarn are not installed.\n\nThe stack is ready to host with [nginx proxy](https://github.com/jwilder/nginx-proxy) and [letsencrypt-nginx-proxy-companion](https://github.com/JrCs/docker-letsencrypt-nginx-proxy-companion). See [docker-compose.production.yml](/docker-compose.production.yml) for example setup.\n\n\n## Demo\n\nA demo installation is set up on [https://docker-rails.georg-ledermann.de](https://docker-rails.georg-ledermann.de).\n'