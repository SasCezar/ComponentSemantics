b'Anaconda\n========\n\n[![Build Status](https://travis-ci.org/ChimeraCoder/anaconda.svg?branch=master)](https://travis-ci.org/ChimeraCoder/anaconda) [![Build Status](https://ci.appveyor.com/api/projects/status/63pi6csod8bps80i/branch/master?svg=true)](https://ci.appveyor.com/project/ChimeraCoder/anaconda/branch/master) [![GoDoc](https://godoc.org/github.com/ChimeraCoder/anaconda?status.svg)](https://godoc.org/github.com/ChimeraCoder/anaconda)\n\nAnaconda is a simple, transparent Go package for accessing version 1.1 of the Twitter API.\n\nSuccessful API queries return native Go structs that can be used immediately, with no need for type assertions.\n\n\n\nExamples\n--------\n\n### Authentication\n\nIf you already have the access token (and secret) for your user (Twitter provides this for your own account on the developer portal), creating the client is simple:\n\n```go\napi := anaconda.NewTwitterApiWithCredentials("your-access-token", "your-access-token-secret", "your-consumer-key", "your-consumer-secret")\n```\n\n### Queries\n\nQueries are conducted using a pointer to an authenticated `TwitterApi` struct. In v1.1 of Twitter\'s API, all requests should be authenticated.\n\n```go\nsearchResult, _ := api.GetSearch("golang", nil)\nfor _ , tweet := range searchResult.Statuses {\n    fmt.Println(tweet.Text)\n}\n```\nCertain endpoints allow separate optional parameter; if desired, these can be passed as the final parameter.\n\n```go\n//Perhaps we want 30 values instead of the default 15\nv := url.Values{}\nv.Set("count", "30")\nresult, err := api.GetSearch("golang", v)\n```\n\n(Remember that `url.Values` is equivalent to a `map[string][]string`, if you find that more convenient notation when specifying values). Otherwise, `nil` suffices.\n\n### Streaming\n\nAnaconda supports the Streaming APIs. You can use `PublicStream*` or `UserStream` API methods.\nA go loop is started an gives you an stream that sends `interface{}` objects through it\'s `chan` `C`\nObjects which you can cast into a tweet, event and more.\n\n\n````go\nv := url.Values{}\ns := api.UserStream(v)\n\nfor t := range s.C {\n  switch v := t.(type) {\n  case anaconda.Tweet:\n    fmt.Printf("%-15s: %s\\n", v.User.ScreenName, v.Text)\n  case anaconda.EventTweet:\n    switch v.Event.Event {\n    case "favorite":\n      sn := v.Source.ScreenName\n      tw := v.TargetObject.Text\n      fmt.Printf("Favorited by %-15s: %s\\n", sn, tw)\n    case "unfavorite":\n      sn := v.Source.ScreenName\n      tw := v.TargetObject.Text\n      fmt.Printf("UnFavorited by %-15s: %s\\n", sn, tw)\n    }\n  }\n}\n````\n\n\n\nEndpoints\n---------\n\nAnaconda implements most of the endpoints defined in the [Twitter API documentation](https://developer.twitter.com/en/docs). For clarity, in most cases, the function name is simply the name of the HTTP method and the endpoint (e.g., the endpoint `GET /friendships/incoming` is provided by the function `GetFriendshipsIncoming`).\n\nIn a few cases, a shortened form has been chosen to make life easier (for example, retweeting is simply the function `Retweet`)\n\n\n\nError Handling, Rate Limiting, and Throttling\n---------------------------------------------\n\n### Error Handling\n\nTwitter errors are returned as an `ApiError`, which satisfies the `error` interface and can be treated as a vanilla `error`. However, it also contains the additional information returned by the Twitter API that may be useful in deciding how to proceed after encountering an error.\n\n\nIf you make queries too quickly, you may bump against Twitter\'s [rate limits](https://developer.twitter.com/en/docs/basics/rate-limits). If this happens, `anaconda` automatically retries the query when the rate limit resets, using the `X-Rate-Limit-Reset` header that Twitter provides to determine how long to wait.\n\nIn other words, users of the `anaconda` library should not need to handle rate limiting errors themselves; this is handled seamlessly behind-the-scenes. If an error is returned by a function, another form of error must have occurred (which can be checked by using the fields provided by the `ApiError` struct).\n\n\n(If desired, this feature can be turned off by calling `ReturnRateLimitError(true)`.)\n\n\n### Throttling\n\nAnaconda now supports automatic client-side throttling of queries to avoid hitting the Twitter rate-limit.\n\nThis is currently *off* by default; however, it may be turned on by default in future versions of the library, as the implementation is improved.\n\n\nTo set a delay between queries, use the `SetDelay` method:\n\n```go\napi.SetDelay(10 * time.Second)\n```\n\nDelays are set specific to each `TwitterApi` struct, so queries that use different users\' access credentials are completely independent.\n\n\nTo turn off automatic throttling, set the delay to `0`:\n\n```go\napi.SetDelay(0 * time.Second)\n```\n\n### Query Queue Persistence\n\nIf your code creates a NewTwitterApi in a regularly called function, you\'ll need to call `.Close()` on the API struct to clear the queryQueue and allow the goroutine to exit. Otherwise you could see goroutine and therefor heap memory leaks in long-running applications.\n\n### Google App Engine\n\nSince Google App Engine doesn\'t make the standard `http.Transport` available, it\'s necessary to tell Anaconda to use a different client context.\n\n```go\napi = anaconda.NewTwitterApi("", "")\nc := appengine.NewContext(r)\napi.HttpClient.Transport = &urlfetch.Transport{Context: c}\n```\n\n\nLicense\n-------\nAnaconda is free software licensed under the MIT/X11 license. Details provided in the LICENSE file.\n'