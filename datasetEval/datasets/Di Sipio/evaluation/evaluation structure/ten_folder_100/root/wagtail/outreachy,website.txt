b'# What is Outreachy?\n\nOutreachy is a three-month paid internship program for people traditionally underrepresented in tech.\nThis repository is for the Django code that comprises the [Outreachy website](https://www.outreachy.org).\n\n# Current state of Outreachy tech\n\nThe Outreachy web presence is in a couple of different places:\n * [Outreachy website](https://www.outreachy.org)\n * [GitHub website code repository](https://github.com/outreachy/website/)\n * [GitHub repository for creative works and miscellaneous scripts](https://github.com/outreachy/creative-works-and-scripts/)\n * [Repository CI Status](https://travis-ci.org/outreachy/website.svg?branch=master)\n\nOlder/deprecated websites include:\n - [GNOME Outreachy homepage](https://www.gnome.org/outreachy/) - shell homepage, where the outreachy.org domain currently redirects to\n - [GNOME wiki Outreachy pages](http://wiki.gnome.org/Outreachy) - moinmoin based wiki with information about how to apply and sponsor\n - [Outreachy application system](http://outreachy.gnome.org) - PHP-based application system currently hosted on OpenShift\n - irc.gnome.org #outreachy - GNOME IRC channel - where applicants get help\n - [Outreachy Planeteria](http://www.planeteria.info/outreach) - blog aggregation for Outreachy interns\n\n# Future Long-term Goals\n\n - Replace planetaria with one hosted on our domain (that allows for filtering which blogs are displayed?)\n - Track longitudinal information of alumni, so we can share success stories and improve our program\n - Track sponsorship information\n - Create a better way of displaying the list of potential Outreachy projects - e.g. allow searching, tagging for programming language or design or documentation or user experience\n\n# How does the Outreachy website tech work together?\n\nThe Outreachy website is built on a [Python](https://www.python.org/) and a web framework called [Django](https://www.djangoproject.com/). Additionally, the Outreachy website uses a content management system called [Wagtail](https://wagtail.io/), which builds on top of Django. On the Outreachy webserver, we run [Dokku](http://dokku.viewdocs.io/dokku/), which helps us deploy new code, manage our Let\'s Encrypt SSL certificates, and backup the Outreachy website database. Only Outreachy organizers have ssh access to push new code to the server.\n\n# Optional helpful background reading\n\n[Django topic guides](https://docs.djangoproject.com/en/1.11/topics/), particularly the [models](https://docs.djangoproject.com/en/1.11/topics/db/models/) guide.\n\n# Setting up your development environment\n\nYou can run Django locally to test changes to the code, test creating new pages, test adding new users, etc. The local tests you run will not impact the main Outreachy website, only your local version of the website. You should test changes locally before submitting a pull request.\n\nTo set up your local development environment, first clone the repository to your local machine:\n\n```\ngit clone https://github.com/outreachy/website.git\ncd website\n```\n\nIn order to develop with Python, you\'ll need the Python 3 development headers, so install them (for example, `apt-get install python3-dev` on Ubuntu). You\'ll also need to install node.js.\n\nNext, you\'ll need to create a new virtualenv. A "virtualenv" is a separate virtual environment for working on different Python projects. It\'s good practice to create a virtual environment for each Python project you\'re working on, in case they have conflicting dependencies, and so that you make sure to record all the dependencies for each project.\n\nThese instructions will help you create a new virtualenv that will have all the python packages installed that you need to work on the Outreachy website. We use [pipenv](https://pipenv.readthedocs.io/en/latest/) for this purpose.\n\nTo install pipenv, you\'ll need to either [install Homebrew](https://brew.sh/) (if you\'re on a Mac or Windows) or (if you\'re running Linux) [install Linuxbrew](http://linuxbrew.sh/).\n\nThen [install pipenv](https://pipenv.readthedocs.io/en/latest/install/#installing-pipenv).\n\nThe following command will automatically create a virtual environment and install the Python dependencies specified in the `Pipfile`. If you need help understanding pipenv, run `pipenv --help`\nMake sure that you are in the `website` directory first, and have *not* run `pipenv shell` yet, then:\n\n```\npipenv install\n```\n\n[Note: Pipenv automatically records changes in the project\'s dependencies in the `Pipfile` when you add/remove packages. You can add a package with the command `pipenv install <package>`. You can remove a package with the command `pipenv uninstall <package>`.]\n\nNow, you activate the virtual environment by typing the following command in the directory of the project:\n\n```\npipenv shell\n```\n\nIn addition to the Python packages that were installed for you when you created the virtualenv, you also need to install some Node.js packages; these will be placed in a `node_modules` directory inside your project folder. Make sure you have `npm` installed, then run:\n\n```\nnpm install\n```\n\nIf this is your first time creating a local version of the website for testing, you\'ll need to set up the local website database from scratch. The following command will create a new database with the models in the Outreachy website. The database will initially have no website pages, but will eventually store your local test pages.\n\n```\n./manage.py migrate\n```\n\nThe next step is to create an admin account for the local website.\n\n```\n./manage.py createsuperuser\n```\n\nand run the tests.\n\n```\nPATH="$PWD/node_modules/.bin:$PATH" ./manage.py test\n```\n\nYou\'ll need to set up a new internship round, following the instructions in the next section.\n\n# Django shell\n\nDjango has a \'shell\' mode where you can run snippets of Python code. This is extremely useful for figuring out why view code isn\'t working. You can also use it to test complicated [query sets](https://docs.djangoproject.com/en/1.11/topics/db/queries/#retrieving-objects). It\'s also useful for doing quick tests of how templates (especially email templates) will look.\n\nYou can run the shell on either your local copy of the database, or you can run it on the remote server\'s database. If you start the shell on your local computer, it will load your local copy of the code and your local database. If you start the shell on the remote server, it will load the server\'s version of the code and the server\'s database. Remember, if you change any of the Python code, you\'ll need to exit the shell (CTRL-d) and restart it to reload the code.\n\n## Setting up a new internship round\n\nWhen you\'ve first cloned and [set up the Outreachy website development environment](#setting-up-your-development-environment), you\'ll need to create a new internship round. The website expects to have at least one past round, and some pages won\'t work without a round. You may also need to set up a new round in your local database so you can test how the website looks during some particular phase. (See the section below for more explanation of the phases of the Outreachy round.)\n\nIn either case, the best way to do that is to use the shell to call into `home/factories.py` to create a new internship round. First, start the Django shell:\n\n```\n./manage.py shell\n```\n\nYou\'ll get a Python prompt that looks fairly similar to the standard Python shell, except that all the Django code you\'ve written is available. It will look like this:\n\n```\n$ ./manage.py shell\nPython 3.6.6 (default, Jun 27 2018, 14:44:17) \n[GCC 8.1.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n(InteractiveConsole)\n>>> \n```\n\nFirst, import all the models in `home/models.py`:\n\n```\n>>> from home.models import *\n```\n\nWe\'ll also need to import all the methods in `home/factories.py`:\n\n```\n>>> from home.factories import *\n```\n\nThe advantage of using the factories methods is that it automatically computes reasonable dates for all round deadlines, based on what the Outreachy internship round schedule normally is. You just have to give it one date and it will calculate the rest.\n\n### Initial applications open\n\nThe Outreachy application period has two distinct periods: the initial application period and the contribution period. During the initial application period, applicants submit an eligibility form and essays (an initial application). All people who have an approved initial application will be notified by email. Then the contribution period will start. Approved applicants will contact mentors and work on project tasks (contributions).\n\nLet\'s assume you want an internship round where we\'re in the middle of the initial application period. We can set the initial applications deadline (`initial_applications_close`) to be one week (seven days) after today:\n\n```\n>>> import datetime\n>>> current_round = RoundPageFactory(\n\tstart_from="initial_applications_close",\n\tdays_after_today=7)\n```\n\nNote: Normally in the Django shell, you need to call the `save()` method to write the RoundPage object in the local database. The factories code automatically calls the `save()` method for you. Should you need to delete an object from the database, you can call the `delete()` method. Don\'t call `save()` afterwards, because that will write the object back to the database.\n\nIf you get an error when running the factories code, it\'s often hard to tell what exactly is wrong. Most often, the issue is that a variable is missing that needs to be passed to the factories method. That usually means the factories code needs to create that object from scratch, which will cause it to create a new RoundPage. That will show up as an error `django.core.exceptions.ValidationError: {\'slug\': [\'This slug is already in use\']}`. If the factories method you were calling was making multiple objects, you\'ll need to debug which call failed. You can do that by adding a with section to invoke the factories debugger, and an atomic transaction block to ensure that no objects that were created before the factory method failed are saved to the database:\n\n```\n>>> from django.db import transaction\n>>> with factory.debug(), transaction.atomic():\n...     current_round = RoundPageFactory(\n...\t\tstart_from="initial_applications_close",\n...\t\tdays_after_today=7)\n>>>\n```\n### Contributions open\n\nLet\'s assume you want an internship round where we\'re in the middle of the contribution period. We can set the deadline for when the final applications for projects are due (`appslate`) to be one week from today:\n\n```\n>>> import datetime\n>>> current_round = RoundPageFactory(\n\tstart_from="contributions_close",\n\tdays_after_today=7)\n```\n\nNote: Normally in the Django shell, you need to call the `save()` method to write the RoundPage object in the local database. The factories code automatically calls the `save()` method for you. Should you need to delete an object from the database, you can call the `delete()` method. Don\'t call `save()` afterwards, because that will write the object back to the database.\n\nIf you get an error when running the factories code, it\'s often hard to tell what exactly is wrong. Most often, the issue is that a variable is missing that needs to be passed to the factories method. That usually means the factories code needs to create that object from scratch, which will cause it to create a new RoundPage. That will show up as an error `django.core.exceptions.ValidationError: {\'slug\': [\'This slug is already in use\']}`. If the factories method you were calling was making multiple objects, you\'ll need to debug which call failed. You can do that by adding a with section to invoke the factories debugger, and an atomic transaction block to ensure that no objects that were created before the factory method failed are saved to the database:\n\n```\n>>> from django.db import transaction\n>>> with factory.debug(), transaction.atomic():\n...     current_round = RoundPageFactory(\n...\t\tstart_from="contributions_close",\n...\t\tdays_after_today=7)\n>>>\n```\n\n# Testing the local website\n\nOnce you\'ve run the above setup commands, you should be all set to start testing your local website. First, run the command to start the Django webserver and serve up the local website.\n\n```\nPATH="$PWD/node_modules/.bin:$PATH" ./manage.py runserver\n```\n\nTo make sure you\'ve set up an internship round successfully, go to the internship project selection page at `http://localhost:8000/apply/project-selection/`. You should see that the internship round dates are correct. If you created an internship round where the final application date has passed, you can see older rounds at `http://localhost:8000/past-projects/`.\n\nTo go to the Django administrative interface, go to `http://localhost:8000/django-admin/`. You can log in into with the account you created with `./manage.py createsuperuser`. If you\'re new to Django, you may want to find the RoundPage you created and edit some of the dates. You can find it by clicking the \'Round pages\' link under the HOME section. You\'ll see the changed dates reflected in the internship project selection page if you refresh it.\n\nIt\'s unlikely you\'ll need to access the Wagtail admin interface, where the local CMS content is managed. If you do need to access the Wagtail admin interface, go to `http://localhost:8000/admin/`. Use the same account you created with the `./manage.py createsuperuser` command.\n\n# Tour of the code base\n\nWhen you first clone this project, you\'ll see a couple top level directories:\n * `bin`\n * `contacts`\n * `docs`\n * `home`\n * `outreachyhome`\n * `search`\n\nIf you\'ve followed the steps above to set up your development environment, Django may have generated some directories and put files in them. Don\'t modify or commit files from those directories. You can use `git status --ignored` to show you which directories are not supposed to be under revision control. Top-level directories you shouldn\'t commit to are ones like `media`, `node_modules`, and `static`. These directories are in the .gitignore file, so your changes to those files won\'t be listed if you run `git status`.\n\nThe `bin` directory almost never changes. It includes a script that\'s run by dokku before the website is deployed to outreachy.org.\n\nThe top-level directory `docs` is where our maintenance and design documents go. It also includes the intern and mentor agreements, and our privacy policy.\n\nThe `outreachyhome` directory contains the base HTML page templates for all pages on the website. It also includes all the Django project settings for both development and production environments. This directory isn\'t changed very often.\n\nDjango breaks up functionality into a project (a Django web application) and apps (smaller a set of Python code that implements a specific feature). There is only one project deployed on a site at a time, but there could be many apps deployed. You can read more about what an application is in [the Django documentation](https://docs.djangoproject.com/en/2.0/ref/applications/).  \n\nIn the Outreachy repository, the directory `outreachy-home` is the project. We have several apps:\n* `home` which contains models used on most the Outreachy pages\n* `search` which was set up during the wagtail installation to allow searching for pages and media\n* `contacts` which is a Django app for our contact page\n\n## External Django Packages\n\nThe Outreachy website also uses some Django apps that are listed in the `INSTALLED_APPS` variable in `outreachyhome/settings/base.py`. The Python module code for those Django apps aren\'t found in top-level directories in the repository. That\'s because the Python module code was installed into your virtualenv directory when you ran `pipenv install`. That command looked at the Python package requirements listed in `Pipfile` and installed each of the packages.\n\nIf you want to look at the source code of the installed external Django applications, you can use `pipenv open MODULE` to examine the source code files associated with that module. For example, say you notice the `home/models.py` file has an import line `from django.contrib.auth.models import User`. You can use pipenv open to look at the models.py file that contains the User class by running the command `pipenv open django.contrib.auth`. That will open all the files in the auth module in your editor, and you can then open models.py and search for `class User`.\n\n## Outreachy terminology\n\nPlease use the gender-neutral ["they/them" pronouns](http://pronoun.is/they) and gender-neutral language to refer to all Outreachy participants.\n\n * **FOSS:** Free and Open Source Software.\n * **Project:** A series of intern tasks to improve FOSS.\n * **Community:** A community is a set of related projects. For instance, if Django participated as an Outreachy community, the community might mentor projects to improve Django core functionality, Django extensions, or Django documentation.\n * **Mentor:** A mentor defines a project. They work with applicants to help them complete contributions to the project during the application process. A mentor selects an applicant to be the intern for their project. The mentor works remotely with the selected intern during the internship. An intern can have one or more mentors. Most Outreachy mentors only mentor one intern.\n * **Coordinator:** Each internship project must be associated with a FOSS community participating in Outreachy. That community provides funding for interns, either directly from community funds, or by finding a company or foundation to sponsor interns. Each community has one or more coordinators, who review submitted projects, approve mentors, set internship funding sources, and generally provide a communication link between the mentors and Outreachy organizers. Some smaller communities have only one coordinator, who is also the only mentor.\n * **Outreachy organizers:** There is a small set of organizers who oversee the entire Outreachy program. They communicate with coordinators about funding, onboard new communities, review inern feedback, authorize intern payments, answer questions, and promote the program to potential applicants.\n * **Applicant:** During the application process, Outreachy applicants make contributions to projects and apply to be an Outreachy intern.\n * **Intern:** An accepted applicant works with a mentor for three months during the internship period.\n\n## Outreachy Internship Phases\n\nThe Outreachy website changes depending on what phase of the internship round Outreachy is in. The phases of the internship round are:\n\n 1. Community sign up and mentor project submission\n 2. Initial application submission\n 3. Applicant contribution period\n 4. Final application submission period\n 5. Intern selection period\n 6. Intern announcement\n 7. Internship period\n\nSome of these phases overlap. For example, the project submission period ends part-way through the applicant contribution period. Since Outreachy internships run twice a year, that means one internship round may overlap with another. For example, the end of the intership period often overlaps with the community sign up and mentor project submission phase.\n\n## Internship Rounds and Communities\n\nThe Outreachy internship round is represented by `class RoundPage` in `home/models.py`. It contains dates that define the phases of the internship rounds, the round name, the round number, links to future intern chats over video and text.\n\nA FOSS community is represented by the `class Community` in `home/models.py`. It contains things like the community name.\n\nCommunities can participate in multiple Outreachy internship rounds. We record their participation in each round in with the `class Participation` in `home/models.py`. A participation includes details like who is sponsoring the Outreachy interns for this community. A participation model has a "link" (a ForeignKey) to one `Community` and one `RoundPage` object. So, for example, we could say "Debian participated the May 2019 Outreachy internship round."\n\nThe relationships described above can be represented by this diagram:\n\n![A Participation is related to a Community and a RoundPage. A Project is related to a Participation.](https://github.com/outreachy/website/raw/master/docs/graphics/RoundPage-Community-Participation-Project.png)\n\n## ApprovalStatus class\n\nYou\'ll notice in the diagram above that both `class Participation` and `class Project` have `class ApprovalStatus` as a base class. The ApprovalStatus class is a way to keep track of who submitted an object, who has permissions to approve an object, and what the status of the approval is. An ApprovalStatus object can be in the pending, approved, rejected, or withdrawn state.\n\nOutreachy coordinators sign up their community to participate in a particular Outreachy internship round. That puts the associated Participation into the pending state. Outreachy organizers then review the Participation and approve or reject it. Coordinators can withdraw their community\'s participation at any time. For Participation objects, coordinators are considered the submitters of the Participation, and organizers are the approvers.\n\nOnce a community signs up to participate (and even before it\'s approved), Outreachy mentors can submit projects. That puts the associated Project into the pending state. Coordinators then review the Project and approve or reject it. Project mentors can withdraw their project\'s participation at any time. For Project objects, mentors are the submitters and coordinators are the approvers.\n\nMost classes with an ApprovalStatus will have emails sent to the submitter when they are approved, but some don\'t. Review the view code in `home/views.py` to see what emails are sent when the status changes.\n\n## CoordinatorApproval class\n\nThe community coordinator role is represented by the CoordinatorApproval class. It has a foreign key to a Community, because we expect the coordinator to remain the same from round to round. New coordinators are on-boarded as people change roles, but most coordinators stick around for at least 2-4 internship rounds.\n\n![A CoordinatorApproval has a foreign key to a Community.](https://github.com/outreachy/website/raw/master/docs/graphics/Participation-Community-CoordinatorApproval-Project-MentorApproval.highlighted-CoordinatorApproval.png)\n\nWhen testing the website on your local machine, it\'s useful to create a coordinator account that you can log into. This allows you to see how the website looks at various points in the round to a coordinator. You can create a new CoordinatorApproval object using the `home/factories.py` function `CoordinatorApprovalFactory()`.\n\nThe factory will fill in random names, phrases, and choices for any required fields in the CoordinatorApproval, Comrade, User, and Community objects. If you want to override any of those fields, you can pass that field value as an assignment in the same format you would for a [Django filter queryset](https://docs.djangoproject.com/en/1.11/topics/db/queries/#retrieving-specific-objects-with-filters).\n\nIn the example code below, we\'ll create a new CoordinatorApproval object. The factories code automatically sets all passwords for User accounts to `test`. We\'ll set the CoordinatorApproval approval status to approved (by default, all ApprovalStatus objects are created with the withdrawn approval status). The example sets the community name to "Really Awesome Community", but you can use the name of your favorite FOSS community instead.\n\n```\n>>> name = "Really Awesome Community"\n>>> coord1 = CoordinatorApprovalFactory(\n\tcoordinator__account__username="coord1",\n\tapproval_status=ApprovalStatus.APPROVED,\n\tcommunity__name=name,\n\tcommunity__slug=slugify(name))\n>>> really_awesome_community = coord1.community\n```\n\nIf you want to create a second coordinator under the same community, you can run this command:\n\n```\n>>> coord2 = CoordinatorApprovalFactory(\n\tcoordinator__account__username="coord2",\n\tapproval_status=ApprovalStatus.APPROVED,\n\tcommunity=really_awesome_community)\n```\n\nIf you visit `http://localhost:8000/communities/cfp/really-awesome-community/`, you should see the randomly generated names of the coordinators. You can log in with the superuser account or one of the coordinator\'s accounts to see how the page changes once you log in.\n\n## Participation and Sponsorship classes\n\nEach community can sign up to participate in an Outreachy internship round. That sign up is represented by `class Participation`. As part of signing up to participate in Outreachy, each community must provide sponsorship for at least one intern ($6,500 USD). When a community signs up, we require the coordinator to fill out information about their sponsor names and sponsorship amounts. The sponsor information is stored in `class Sponsorship`, which has a foreign key to the Participation object.\n\nYou can use the Django shell to create a new participation. The example below assumes you already have a pre-created community that is being referenced by the variable name `really_awesome_community`, and a pre-created RoundPage `current_round`. The code also sets the approval status to say the community has been approved to participate in this round. The example sets that the community will be receiving sponsorship for two interns. We\'ll save a reference to that Participation object in the variable participation.\n\n```\n>>> sponsorship = SponsorshipFactory(\n\tparticipation__participating_round=current_round,\n\tparticipation__community=really_awesome_community,\n\tparticipation__approval_status=ApprovalStatus.APPROVED,\n\tamount=13000)\n>>> participation = sponsorship.participation\n```\n\n## Project and MentorApproval classes\n\nIn Outreachy, mentors submit projects under a participating community. Mentors are in charge of defining the project description and tasks that the applicants work on during the contribution phase. Each project can have one or more mentors.\n\nA project is represented by the `class Project` in `home/models.py`. It has a ForeignKey to a `Participation` (the representation of a community participating in an internship round).\n\nThe mentor(s) for that project are represented by the `class MentorApproval` in `home/models.py`. That provides a link between the mentor\'s account on Outreachy (a `Comrade` object) and the Project object. A mentor submit or co-mentor more than one project, which will create multiple MentorApproval objects.\n\n![A MentorApproval has a foreign key to a Project.](https://github.com/outreachy/website/raw/master/docs/graphics/Participation-Community-CoordinatorApproval-Project-MentorApproval.highlighted-MentorApproval-Project.png)\n\nWhen testing the website on your local machine, it\'s useful to create a mentor account that you can log into. This allows you to see how the website looks at various points in the round to a mentor. You can create a new MentorApproval object using the `home/factories.py` function `MentorApprovalFactory()`.\n\nThe factory will fill in random names, phrases, and choices for any required fields in the Comrade, User, and Project objects. If you want to override any of those fields, you can pass that field value as an assignment in the same format you would for a [Django filter queryset](https://docs.djangoproject.com/en/1.11/topics/db/queries/#retrieving-specific-objects-with-filters).\n\nIn the example Django shell code below, we\'ll create a MentorApproval object. The factories code automatically sets the password for the mentor to `test`. We\'ll set the MentorApproval approval status and the Project approval status to approved. (By default, all ApprovalStatus objects are created with the withdrawn approval status.) The code assumes you have a pre-created Participation object referenced by the variable `participation`. The code will associate the Project with that community\'s participation in the internship round, rather than allowing the factories code to create new Community and RoundPage objects with random values.\n\n```\n>>> mentor1 = MentorApprovalFactory(\n\tmentor__account__username="mentor1",\n\tapproval_status=ApprovalStatus.APPROVED,\n\tproject__project_round=participation,\n\tproject__approval_status=ApprovalStatus.APPROVED)\n>>> project = mentor1.project\n```\n\nIf you want to create a co-mentor under the same project, you can run these two commands:\n\n```\n>>> mentor2 = MentorApprovalFactory(\n\tmentor__account__username="mentor2",\n\tapproval_status=ApprovalStatus.APPROVED,\n\tproject=project)\n```\n\n## Models for Applicants\n\nWhen a person wants to apply to Outreachy, their first step is to fill out an initial application. That application is reviewed by Outreachy organizers and approved or rejected. The initial application may be automatically rejected if the person is not eligible to be paid or they have too many time commitments. The initial application must be re-submitted each internship round, because the person\'s time commitments and payment eligibility may change from round to round. The initial application is represented by `class ApplicantApproval`.\n\nAfter the applicant\'s initial application is approved, their next step is to pick one or more Outreachy projects and make a contribution to it. A contribution is a small task that an applicant finds in the project\'s issue tracker. Once a contribution is started, the applicant can then record the contribution in the Outreachy website. The contribution form asks for the date started, completed, a URL for the contribution (typically to the issue tracker), and a description of the contribution. The recorded contribution is represented by `class Contribution`.\n\nThe last step is for an applicant to create a final application to each project they made a contribution to. The final application includes questions about the applicant\'s past experiences with FOSS communities, relevant projects, and a timeline of project tasks for the internship project they\'re applying to. The final application is represented by `class FinalApplication`.\n\nApplicants can record many contributions for the same Project, or different projects. Applicants can submit multiple final applications to different projects. The associated Contribution and FinalApplication objects will all have foriegn keys back to the ApplicantApproval and Project objects.\n\nIf the applicant applies to another round, they have to create a new initial application (ApplicantApproval object) and new Contribution and FinalApplication objects associated with the Project they\'re applying for.\n\n![Diagram showing the relationship from a RoundPage through a Project to a Contribution, then an ApplicationApproval, to a FinalApplication](https://github.com/outreachy/website/raw/master/docs/graphics/RoundPage-Participation-Project-Contribution-ApplicantApproval-FinalApplication.png)\n\n### Creating ApplicantApproval Test Objects\n\nIt can be useful to log into your local test website and see how the pages look from an applicant\'s perspective. The following Django shell example creates a new ApplicantApproval. It assumes you already have a pre-created RoundPage referenced by the variable `current_round`. It sets the initial application\'s approval status to approved. The code sets the applicant\'s account username. The factories code automatically sets the password to `test`.\n\n```\n>>> applicant1 = ApplicantApprovalFactory(\n\tapplication_round=current_round,\n\tapproval_status=ApprovalStatus.APPROVED,\n\tapplicant__account__username="applicant1")\n```\n\n### Creating Contribution Test Objects\n\nThe following Django shell example creates a new Contribution object. It assumes you already have a pre-created ApplicantApproval referenced by the variable `applicant1` and a pre-created Project referenced by the variable `project`.\n\n```\n>>> ContributionFactory(\n\tproject=project,\n\tapplicant=applicant1,\n\tround=project.project_round.participating_round)\n```\n\n### Creating FinalApplication Test Objects\n\nThe following Django shell example creates a new FinalApplication object. It assumes you already have a pre-created ApplicantApproval referenced by the variable `applicant1` and a pre-created Project referenced by the variable `project`. It sets the FinalApplication approval status to pending.\n\n```\n>>> FinalApplicationFactory(\n\tproject=project,\n\tapplicant=applicant1,\n\tround=project.project_round.participating_round,\n\tapproval_status=ApprovalStatus.PENDING)\n```\n\n## InternSelection and MentorRelationship classes\n\nWhen the contribution period is over and the deadline has passed to submit a final application, Outreachy mentors decide which interns they want to select. As part of that process, they must sign a mentor agreement that states they understand their commitments to this internship. The signed contract for this internship with this applicant is stored in `class MentorRelationship`.\n\nWhen the mentor picks an intern, that intern selection is represented by `class InternSelection`. That model stores information about the internship, such as what project the applicant will be interning with, if the intern has custom start or end dates, if the internship is approved by the Outreachy organizers, etc.\n\nIf a co-mentor for the same Project signs up to participate as a mentor for this intern, another MentorRelationship object will be created. Mentors from a different Project can select the applicant as an intern. That would create a MentorRelationship to the MentorApproval for that mentor in that other project. If mentors from two different projects select the same applicant, it shows up as an intern selection conflict on their project applicant review page, the community applicant review page, and the organizer dashboard.\n\nThe relationship between an InternSelection and a MentorRelationship is shown below:\n\n![An InternSelection is related to a MentorApproval through a MentorRelationship](https://github.com/outreachy/website/raw/master/docs/graphics/MentorApproval-MentorRelationship-Project-ApplicantApproval-InternSelection.png)\n\n# Running tests manually\n\n## Starting tests manually\n\nIf you want to run the test suite manually, you can run the command:\n\n```\nPATH="$PWD/node_modules/.bin:$PATH" ./manage.py test home/\n```\n\nYou can add verbosity flags to get more output from the tests:\n\n```\nPATH="$PWD/node_modules/.bin:$PATH" ./manage.py test -v2 home/\n```\n\nYou can run tests from a particular file by passing the file name without the .py extension:\n\n```\nPATH="$PWD/node_modules/.bin:$PATH" ./manage.py test home.<file name>\n```\n\nYou can run one test in a particular file:\n\n```\nPATH="$PWD/node_modules/.bin:$PATH" ./manage.py test home.<file name>.<class name>.<function name>\n```\n\n## Running test code in the shell\n\nSometimes when writing a new test, you want to test your code in the shell first. The test suite will do some set up automatically to create a local test Client that uses your local code and a new test database. You can replicate that by running the following commands:\n\n```\nPATH="$PWD/node_modules/.bin:$PATH" ./manage.py shell\nPython 3.6.8 (default, Jan  3 2019, 03:42:36) \n[GCC 8.2.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n(InteractiveConsole)\n>>> from django.test import Client\n>>> c = Client(HTTP_HOST=\'localhost\')\n```\n\nNow you can create objects and look at responses from page requests against your local database, e.g.:\n\n```\n>>> from django.urls import reverse\n>>> from home.scenarios import *\n>>> InternshipWeekScenario(week = 1, community__name=\'Debian\', community__slug=\'debian\')\n<home.scenarios.Scenario object at 0x7f5797f6c438>\n>>> response = c.get(\'/communities/cfp/debian\')\n>>> response.status_code\n200\n```\n\n# Adding a new Django app\n\nIf you have a set of Django models, views, and templates that is a discrete chunk of functionality, you may want to create a new app in the top-level directory. If we want to call our new app `contacts` we can run the helper script to set up our app:\n\n```\n./manage.py startapp contact\n```\n\nThat script will stick some boilerplate examples in a new directory:\n\n```\n$ ls contacts/\nadmin.py  apps.py  __init__.py  migrations  models.py  tests.py  views.py\n```\n\nYou may need to add a `templates` directory to that app:\n\n```\nmakedir contacts/templates\n```\n\n# Dokku logs\n\nIf you\'ve deployed to a test server with the Django debugging settings turned on, Django will send all emails to the console. If you want to create new test users, you\'ll need to extract the verification URL from the log. You can run:\n\n```\nssh -t dokku@outreachy.org logs test\n```\n\n# Sentry error logging\n\nOutreachy uses Sentry to log error messages received on both the Outreachy website and the test website. Unfortunately, that means if you ever use dokku to start the Python shell on the remote website, any typos you have end up getting reported to Sentry. To suppress those error messages, you can unset the `SENTRY_DSN` environment variable:\n\n```\nssh -t dokku@www.outreachy.org run www env --unset=SENTRY_DSN python manage.py shell\n```\n\n# Migrations\n\nWhen you change some aspect of a field in a model, that can create a change to the underlying database information. For example, if you change a field name from "foo" to "bar", the Django object database has to change such that you can quenry for objects using the new name. You can read more about migrations and how to create and apply them in the Django migrations documentation. We suggest starting with the [simple migrations introduction in the Django tutorial](https://docs.djangoproject.com/en/1.11/intro/tutorial02/#activating-models), and then looking at the [more detailed migrations documentation](https://docs.djangoproject.com/en/1.11/topics/migrations/) if needed.\n\nIn most cases, there are only two commands you need to run to create and apply a migration. The first is:\n\n```./manage.py makemigrations```\n\nThis will examine the code changes you\'ve made, and automatically generate a Python file that describes how the underlying database schema should change. Make sure to commit this file along with your model code changes. Then the second command you\'ll run is:\n\n```./manage.py migrate```\n\nThis will apply the database schema change to your local test environment. If the Outreachy organizers push a change that includes a migration to the production or testing sites, they will need to update the server\'s database schema by running `ssh dokku@outreachy.org run www python manage.py migrate` or `ssh dokku@outreachy.org run test python manage.py migrate`.\n\nThe next two sections describe some of the trickier aspects of migrations that we\'ve run into.\n\n## Rolling back migrations\n\nIf you have migrated the database (either locally or on the server) and want to go back to a previous migration, you can run:\n\n```\n./manage.py migrate home [version number]\n```\n\n## Delicate migrations\n\nSometimes a field doesn\'t work out exactly the way you wanted it to, and you want to change the field type. In this example, we\'ll be changing a simple BooleanField to CharField to support three different choices. This is a dance, because we want to preserve the values in the old field to populate the contents of a new field.\n\n1. Define the new CharField. Set \'null=True\' in the argument list.\n\n2. Run `./manage.py makemigrations && ./manage.py migrate`\n\n3. Create an empty migration: `./manage.py makemigrations home --empty`\n\n4. Edit the new empty migration file. You\'ll need to define a new function that takes `apps` and `schema_editor`, like it\'s documented in the `0005_populate_uuid_values.py` file in the [Django "Writing a migration" documentation.](https://docs.djangoproject.com/en/1.11/howto/writing-migrations/). You can access the objects for that Model, and set the new field based on values in the old field. Make sure to add your function to the operations list. Note that you might have to copy some class members that represent the choice short code in the database into the migration, because all migrations only have access model class members that are Django fields (like CharField or BooleanField). For an example, see the `home/migrations/0068_auto_20180828_1832.py` file in this repo.\n\n5. Remove the `null=True` argument from your model, and delete the old field. You might need to remove the field from admin.py and the views. Then run `./manage.py makemigrations && ./manage.py migrate`. That will generate a third migration to make sure the field must be non-null, but the second migration will set the field on all objects. When Django prompts you about changing a nullable field to a non-nullable field, choose \'Ignore for now\'.\n\n6. The third migration will fail if someone has added a new model object between the second migration and the third migration. In this case, you should roll back to the first migration (where you first added the field). You can pass the migration number to go back to: `./manage.py migrate home PREFIX` This should be a unique prefix (like the first four numbers of the migration). Then you can try to run the migration again: `./manage.py migrate`. Repeat as necessary.\n\n# Why Django?\n\nWe evaluated a couple different choices:\n - CiviCRM\n - Wordpress\n - Red Hen\n - Django\n\nCiviCRM proved too clunky to use, and ultimately their data model didn\'t necessarily fit our data models. Wordpress might have been fine with a template plugin and would have good user experience, but with everything we wanted to do, we felt we would ultimately outgrow Wordpress.\n\nThere are other proprietary tools for tracking sponsorship information, but since Outreachy is a project under the Software Freedom Conservancy and the Outreachy organizers believe in the power of free and open source, we have decided not to use proprietary software wherever possible.\n\nDjango fit our needs for flexibility, data model definition, and future use cases. However, the Django admin interface is pretty clunky and intimidating. We wanted to have a very easy way for all our organizers to quickly edit content. The Wagtail CMS plugin provides a nice user interface and template system, while still allowing programmers to fully use Django to implement models. It also provides internal revision tracking for page content, which means we can easily roll back content changes from the wagtail admin web interface if necessary.\n'