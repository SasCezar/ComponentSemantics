b'# MagicOnion\n[![CircleCI](https://circleci.com/gh/Cysharp/MagicOnion.svg?style=svg)](https://circleci.com/gh/Cysharp/MagicOnion) [![Releases](https://img.shields.io/github/release/Cysharp/MagicOnion.svg)](https://github.com/Cysharp/MagicOnion/releases)\n\nUnified Realtime/API Engine for .NET Core and Unity.\n\n[\xf0\x9f\x93\x96 Table of contents](#-table-of-contents)\n\n## What is it?\nMagicOnion is an Realtime Network Engine like [SignalR](https://github.com/aspnet/AspNetCore/tree/master/src/SignalR), [Socket.io](https://socket.io/) and RPC-Web API Framework like any web-framework.\n\nMagicOnion is built on [gRPC](https://grpc.io/) so fast(HTTP/2) and compact(binary) network transport. It does not requires `.proto` and generate unlike plain gRPC. Protocol schema can share a C# interface and classes.\n\n![image](https://user-images.githubusercontent.com/46207/50965239-c4fdb000-1514-11e9-8365-304c776ffd77.png)\n\n> Share interface as schema and request as API Service seems like normal C# code\n\n![image](https://user-images.githubusercontent.com/46207/50965825-7bae6000-1516-11e9-9501-dc91582f4d1b.png)\n\n> StreamingHub realtime service, broadcast data to many connected clients\n\nMagicOnion is for Microservices(communicate between .NET Core Servers like Orleans, ServiceFabric, AMBROSIA), API Service(for WinForms/WPF like WCF, ASP.NET Core MVC), Native Client\xe2\x80\x99s API(for Xamarin, Unity) and Realtime Server that replacement like Socket.io, SignalR, Photon, UNet, etc.\n\n## Quick Start\nfor .NET 4.6, 4.7 and .NET Standard 2.0(.NET Core) available in NuGet. Unity supports see [Unity client Supports](#unity-client-supports) section. HttpGateway + Swagger Intergarion supports see [Swagger](#swagger) section.\n\n```\nInstall-Package MagicOnion\n```\nMagicOnion has two sides, `Service` for like web-api and `StreamingHub` for relatime communication. At first, see define `Service`.\n\n```csharp\nusing Grpc.Core;\nusing MagicOnion;\nusing MagicOnion.Server;\nusing System;\n\n// define interface as Server/Client IDL.\n// implements T : IService<T> and share this type between server and client.\npublic interface IMyFirstService : IService<IMyFirstService>\n{\n    // Return type must be `UnaryResult<T>` or `Task<UnaryResult<T>>`.\n    // If you can use C# 7.0 or newer, recommend to use `UnaryResult<T>`.\n    UnaryResult<int> SumAsync(int x, int y);\n}\n\n// implement RPC service to Server Project.\n// inehrit ServiceBase<interface>, interface\npublic class MyFirstService : ServiceBase<IMyFirstService>, IMyFirstService\n{\n    // You can use async syntax directly.\n    public async UnaryResult<int> SumAsync(int x, int y)\n    {\n        Logger.Debug($"Received:{x}, {y}");\n\n        return x + y;\n    }\n}\n```\n\n\nand, launch the server.\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        GrpcEnvironment.SetLogger(new Grpc.Core.Logging.ConsoleLogger());\n\n        // setup MagicOnion and option.\n        var service = MagicOnionEngine.BuildServerServiceDefinition(isReturnExceptionStackTraceInErrorDetail: true);\n\n        var server = new global::Grpc.Core.Server\n        {\n            Services = { service },\n            Ports = { new ServerPort("localhost", 12345, ServerCredentials.Insecure) }\n        };\n        \n        // launch gRPC Server.\n        server.Start();\n\n        // and wait.\n        Console.ReadLine();\n    }\n}\n```\n\nwrite the client.\n\n```csharp\n// standard gRPC channel\nvar channel = new Channel("localhost", 12345, ChannelCredentials.Insecure);\n\n// get MagicOnion dynamic client proxy\nvar client = MagicOnionClient.Create<IMyFirstService>(channel);\n\n// call method.\nvar result = await client.SumAsync(100, 200);\nConsole.WriteLine("Client Received:" + result);\n```\n\nMagicOnion allows primitive, multiple request value. Complex type is serialized by LZ4 Compressed MsgPack by [MessagePack for C#](https://github.com/neuecc/MessagePack-CSharp) so type should follow MessagePack for C# rules.\n\n> for Server Hosting, We recommend to use `MagicOnion.Hosting`, it is easy to host and wait terminate signal, load from config, support DI, etc. see [Server host](#server-host) section.\n\n\n## \xf0\x9f\x93\x96 Table of contents\n\n- [What is it?](#what-is-it)\n- [Quick Start](#quick-start)\n- Fundamentals\n    - [StreamingHub](#streaminghub)\n    - [Filter](#filter)\n    - [ClientFilter](#clientfilter)\n    - [ServiceContext and Lifecycle](#servicecontext-and-lifecycle)\n    - [ExceptionHandling and StatusCode](#exceptionhandling-and-statuscode)\n    - [Group and GroupConfiguration](#group-and-groupconfiguration)\n    - [Project Structure](#project-structure)\n    - [Dependency Injection](#dependency-injection)\n- Client and Server\n    - [Unity client supports](#unity-client-supports)\n    - [Server Host](#server-host)\n        - [Server Host options](#server-host-options)\n- Deployment\n    - [Host in Docker](#host-in-docker)\n    - [SSL/TLS](#ssltls)\n- Integrations\n    - [Swagger](#swagger)\n    - [Telemetry](#telemetry)\n- Advanced\n    - [MagicOnionOption/Logging](#magiconionoptionlogging)\n    - [Raw gRPC APIs](#raw-grpc-apis)\n    - [Zero deserialization mapping](#zero-deserialization-mapping)\n- [Author Info](#author-info)\n- [License](#license)\n\n## Fundamentals\n### StreamingHub\nStreamingHub is a fully-typed realtime server<->client communication framework.\n\nThis sample is for Unity(use Vector3, GameObject, etc) but StreamingHub supports .NET Core, too.\n\n```csharp\n// Server -> Client definition\npublic interface IGamingHubReceiver\n{\n    // return type shuold be `void` or `Task`, parameters are free.\n    void OnJoin(Player player);\n    void OnLeave(Player player);\n    void OnMove(Player player);\n}\n \n// Client -> Server definition\n// implements `IStreamingHub<TSelf, TReceiver>`  and share this type between server and client.\npublic interface IGamingHub : IStreamingHub<IGamingHub, IGamingHubReceiver>\n{\n    // return type shuold be `Task` or `Task<T>`, parameters are free.\n    Task<Player[]> JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation);\n    Task LeaveAsync();\n    Task MoveAsync(Vector3 position, Quaternion rotation);\n}\n \n// for example, request object by MessagePack.\n[MessagePackObject]\npublic class Player\n{\n    [Key(0)]\n    public string Name { get; set; }\n    [Key(1)]\n    public Vector3 Position { get; set; }\n    [Key(2)]\n    public Quaternion Rotation { get; set; }\n}\n```\n\n```csharp\n// Server implementation\n// implements : StreamingHubBase<THub, TReceiver>, THub\npublic class GamingHub : StreamingHubBase<IGamingHub, IGamingHubReceiver>, IGamingHub\n{\n    // this class is instantiated per connected so fields are cache area of connection.\n    IGroup room;\n    Player self;\n    IInMemoryStorage<Player> storage;\n\n    public async Task<Player[]> JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation)\n    {\n        self = new Player() { Name = userName, Position = position, Rotation = rotation };\n\n        // Group can bundle many connections and it has inmemory-storage so add any type per group. \n        (room, storage) = await Group.AddAsync(roomName, self);\n\n        // Typed Server->Client broadcast.\n        Broadcast(room).OnJoin(self);\n\n        return storage.AllValues.ToArray();\n    }\n\n    public async Task LeaveAsync()\n    {\n        await room.RemoveAsync(this.Context);\n        Broadcast(room).OnLeave(self);\n    }\n\n    public async Task MoveAsync(Vector3 position, Quaternion rotation)\n    {\n        self.Position = position;\n        self.Rotation = rotation;\n        Broadcast(room).OnMove(self);\n    }\n\n    // You can hook OnConnecting/OnDisconnected by override.\n    protected override async ValueTask OnDisconnected()\n    {\n        // on disconnecting, if automatically removed this connection from group.\n        return CompletedTask;\n    }\n}\n```\n\nYou can write client like this.\n\n```csharp\npublic class GamingHubClient : IGamingHubReceiver\n{\n    Dictionary<string, GameObject> players = new Dictionary<string, GameObject>();\n \n    IGamingHub client;\n \n    public async Task<GameObject> ConnectAsync(Channel grpcChannel, string roomName, string playerName)\n    {\n        var client = StreamingHubClient.Connect<IGamingHub, IGamingHubReceiver>(grpcChannel, this);\n \n        var roomPlayers = await client.JoinAsync(roomName, playerName, Vector3.zero, Quaternion.identity);\n        foreach (var player in roomPlayers)\n        {\n            (this as IGamingHubReceiver).OnJoin(player);\n        }\n \n        return players[playerName];\n    }\n \n    // methods send to server.\n \n    public Task LeaveAsync()\n    {\n        return client.LeaveAsync();\n    }\n \n    public Task MoveAsync(Vector3 position, Quaternion rotation)\n    {\n        return client.MoveAsync(position, rotation);\n    }\n \n    // dispose client-connection before channel.ShutDownAsync is important!\n    public Task DisposeAsync()\n    {\n        return client.DisposeAsync();\n    }\n \n    // You can watch connection state, use this for retry etc.\n    public Task WaitForDisconnect()\n    {\n        return client.WaitForDisconnect();\n    }\n \n    // Receivers of message from server.\n \n    void IGamingHubReceiver.OnJoin(Player player)\n    {\n        Debug.Log("Join Player:" + player.Name);\n \n        var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        cube.name = player.Name;\n        cube.transform.SetPositionAndRotation(player.Position, player.Rotation);\n        players[player.Name] = cube;\n    }\n \n    void IGamingHubReceiver.OnLeave(Player player)\n    {\n        Debug.Log("Leave Player:" + player.Name);\n \n        if (players.TryGetValue(player.Name, out var cube))\n        {\n            GameObject.Destroy(cube);\n        }\n    }\n \n    void IGamingHubReceiver.OnMove(Player player)\n    {\n        Debug.Log("Move Player:" + player.Name);\n \n        if (players.TryGetValue(player.Name, out var cube))\n        {\n            cube.transform.SetPositionAndRotation(player.Position, player.Rotation);\n        }\n    }\n}\n```\n\n### Filter\nMagicOnion filter is powerful feature to hook before-after invoke. It is useful than gRPC server interceptor.\n\n![image](https://user-images.githubusercontent.com/46207/50969421-cb465900-1521-11e9-8824-8a34cc52bbe4.png)\n\n```csharp\n// You can attach per class/method like [SampleFilter]\n// for StreamingHub methods, implement StreamingHubFilterAttribute instead.\npublic class SampleFilterAttribute : MagicOnionFilterAttribute\n{\n    public override async ValueTask Invoke(ServiceContext context, Func<ServiceContext, ValueTask> next)\n    {\n        try\n        {\n            /* on before */\n            await next(context); // next\n            /* on after */\n        }\n        catch\n        {\n            /* on exception */\n            throw;\n        }\n        finally\n        {\n            /* on finally */\n        }\n    }\n}\n```\n\nHere is example of what kind of filter can be stacked.\n\n![image](https://user-images.githubusercontent.com/46207/50969539-2bd59600-1522-11e9-84ab-15dd85e3dcac.png)\n\nGlobalFilter can attach to MagicOnionOptions.\n\nMagicOnion filters supports [DI](#dependency-injection) by [MagicOnion.Hosting](#server-host).\n\n```csharp\npublic class MyStreamingHubFilterAttribute : StreamingHubFilterAttribute\n{\n    private readonly ILogger _logger;\n\n    // the `logger` parameter will be injected at instantiating.\n    public MyStreamingHubFilterAttribute(ILogger<MyStreamingHubFilterAttribute> logger)\n    {\n        _logger = logger;\n    }\n\n    public override async ValueTask Invoke(StreamingHubContext context, Func<StreamingHubContext, ValueTask> next)\n    {\n        _logger.LogInformation($"MyStreamingHubFilter Begin: {context.Path}");\n        await next(context);\n        _logger.LogInformation($"MyStreamingHubFilter End: {context.Path}");\n    }\n}\n```\n\nRegister filters using attributes with constructor injection(you can use `[FromTypeFilter]` and `[FromServiceFilter]`).\n\n```\n[FromTypeFilter(typeof(MyFilterAttribute))]\npublic class MyService : ServiceBase<IMyService>, IMyService\n{\n    // The filter will instantiate from type.\n    [FromTypeFilter(typeof(MySecondFilterAttribute))]\n    public UnaryResult<int> Foo()\n    {\n        return UnaryResult(0);\n    }\n\n    // The filter will instantiate from type with some arguments. if the arguments are missing, it will be obtained from `IServiceLocator` \n    [FromTypeFilter(typeof(MyThirdFilterAttribute), Arguments = new object[] { "foo", 987654 })]\n    public UnaryResult<int> Bar()\n    {\n        return UnaryResult(0);\n    }\n\n    // The filter instance will be provided via `IServiceLocator`.\n    [FromServiceFilter(typeof(MyFourthFilterAttribute))]\n    public UnaryResult<int> Baz()\n    {\n        return UnaryResult(0);\n    }\n}\n```\n\n### ClientFilter\nMagicOnion client-filter is a powerful feature to hook before-after invoke. It is useful than gRPC client interceptor.\n\n> Currently only suppots on Unary.\n\n```csharp\n// you can attach in MagicOnionClient.Create.\nvar client = MagicOnionClient.Create<ICalcService>(channel, new IClientFilter[]\n{\n    new LoggingFilter(),\n    new AppendHeaderFilter(),\n    new RetryFilter()\n});\n```\n\nYou can create custom client-filter by implements `IClientFilter.SendAsync`.\n\n```csharp\npublic class IDemoFilter : IClientFilter\n{\n    public async ValueTask<ResponseContext> SendAsync(RequestContext context, Func<RequestContext, ValueTask<ResponseContext>> next)\n    {\n        try\n        {\n            /* Before Request, context.MethodPath/CallOptions/Items, etc */\n\n            var response = await next(context); /* Call next filter or method body */\n\n            /* After Request, response.GetStatus/GetTrailers/GetResponseAs<T>, etc */\n\n            return response;\n        }\n        catch (RpcException ex)\n        {\n            /* Get gRPC Error Response */\n            throw;\n        }\n        catch (OperationCanceledException ex)\n        {\n            /* If canceled */\n            throw;\n        }\n        catch (Exception ex)\n        {\n            /* Other Exception */\n            throw;\n        }\n        finally\n        {\n            /* Common Finalize */\n        }\n    }\n}\n```\n\nHere is the sample filters, you can imagine what you can do.\n\n```csharp\npublic class AppendHeaderFilter : IClientFilter\n{\n    public async ValueTask<ResponseContext> SendAsync(RequestContext context, Func<RequestContext, ValueTask<ResponseContext>> next)\n    {\n        // add the common header(like authentcation).\n        var header = context.CallOptions.Headers;\n        header.Add("x-foo", "abcdefg");\n        header.Add("x-bar", "hijklmn");\n\n        return await next(context);\n    }\n}\n\npublic class LoggingFilter : IClientFilter\n{\n    public async ValueTask<ResponseContext> SendAsync(RequestContext context, Func<RequestContext, ValueTask<ResponseContext>> next)\n    {\n        Console.WriteLine("Request Begin:" + context.MethodPath); // Debug.Log in Unity.\n\n        var sw = Stopwatch.StartNew();\n        var response = await next(context);\n        sw.Stop();\n\n        Console.WriteLine("Request Completed:" + context.MethodPath + ", Elapsed:" + sw.Elapsed.TotalMilliseconds + "ms");\n\n        return response;\n    }\n}\n\npublic class ResponseHandlingFilter : IClientFilter\n{\n    public async ValueTask<ResponseContext> SendAsync(RequestContext context, Func<RequestContext, ValueTask<ResponseContext>> next)\n    {\n        var response = await next(context);\n\n        if (context.MethodPath == "ICalc/Sum")\n        {\n            // You can cast response type.\n            var sumResult = await response.GetResponseAs<int>();\n            Console.WriteLine("Called Sum, Result:" + sumResult);\n        }\n\n        return response;\n    }\n}\n\npublic class MockRequestFilter : IClientFilter\n{\n    public async ValueTask<ResponseContext> SendAsync(RequestContext context, Func<RequestContext, ValueTask<ResponseContext>> next)\n    {\n        if (context.MethodPath == "ICalc/Sum")\n        {\n            // don\'t call next, return mock result.\n            return new ResponseContext<int>(9999);\n        }\n\n        return await next(context);\n    }\n}\n\npublic class RetryFilter : IClientFilter\n{\n    public async ValueTask<ResponseContext> SendAsync(RequestContext context, Func<RequestContext, ValueTask<ResponseContext>> next)\n    {\n        Exception lastException = null;\n        var retryCount = 0;\n        while (retryCount != 3)\n        {\n            try\n            {\n                // using same CallOptions so be careful to add duplicate headers or etc.\n                return await next(context);\n            }\n            catch (Exception ex)\n            {\n                lastException = ex;\n            }\n            retryCount++;\n        }\n\n        throw new Exception("Retry failed", lastException);\n    }\n}\n\npublic class EncryptFilter : IClientFilter\n{\n    public async ValueTask<ResponseContext> SendAsync(RequestContext context, Func<RequestContext, ValueTask<ResponseContext>> next)\n    {\n        context.SetRequestMutator(bytes => Encrypt(bytes));\n        context.SetResponseMutator(bytes => Decrypt(bytes));\n        \n        return await next(context);\n    }\n}\n```\n\n### ServiceContext and Lifecycle\nService/StreamingHub\'s method or `MagicOnionFilter` can access `this.Context` it is \n\n| Property | Description |\n| --- | --- |\n| `ConcurrentDictionary<string, object>` Items | Object storage per request/connection. |\n| `Guid` ContextId | Unieuq ID per request(Service)/connection(StreamingHub). |\n| `DateTime` Timestamp | Timestamp that request/connection is started time. |\n| `Type` ServiceType | Invoked Class. |\n| `MethodInfo` MethodInfo | Invoked Method. |\n| `ILookup<Type, Attribute> AttributeLookup | Cached Attributes that merged both service and method. |\n| `ServerCallContext` CallContext | Raw gRPC Context. |\n| `IFormatterResolver` FormatterResolver | Using MessagePack resolver. |\n| `IServiceLocator` ServiceLocator | Get the registered service. |\n\n`Items` is useful, for example authentication filter add UserId to Items and take out from service method.\n\n> If using StreamingHub, ServiceContext means per connected context so `Items` is not per method invoke. `StreamingHubContext.Items` supports per streaming hub method request but currently can not take from streaming hub method(only use in StreamingHubFilter). [Issue:#67](https://github.com/Cysharp/MagicOnion/issues/67), it will fix.\n\nMagicOnion supports get current context globaly like HttpContext.Current. `ServiceContext.Current` can get it but it requires `MagicOnionOptions.EnableCurrentContext = true`, default is false.\n\nLifecycle image of ServiceBase\n\n```\ngRPC In(\n    var context = new ServiceContext();\n    Filter.Invoke(context, \n        var service = new ServiceImpl();\n        service.ServiceContext = context;\n        service.MethodInvoke(\n            /* method impl */\n        )\n    )\n)\n```\n\nLifecycle image of StreamingHub(StreamingHub is inherited from ServiceBase)\n\n```\ngRPC In(\n    var context = new ServiceContext();\n    Filter.Invoke(context, \n        var hub = new StreamingHubImpl();\n        hub.ServiceContext = context;\n        hub.Connect(\n            while (connecting) {\n                Streaming In(\n                    var streamingHubContext = new StreamingHubContext(context);\n                    StreamingHubFilter.Invoke(streamingHubContext,\n                        hub.MethodInvoke(\n                            /* method impl */\n                        )\n                    )\n                )\n            }\n        )\n    )\n)\n```\n\nStreamingHub instance is shared while connecting so StreamingHub\'s field can use cache area of connection.\n\n### ExceptionHandling and StatusCode\nIf you are return custom status code from server to client, you can use `throw new ReturnStatusException`.\n\n```csharp\npublic Task SendMessageAsync(string message)\n{\n    if (message.Contains("foo"))\n    {\n        //\n        throw new ReturnStatusException((Grpc.Core.StatusCode)99, "invalid");\n    }\n\n    // ....\n```\n\nClient can receive exception as gRPC\'s `RpcException`. If performance centric to avoid exception throw, you can use raw gRPC CallContext.Status(`ServiceContext.CallCaontext.Status`) and set status directly.\n\nMagicOnion\'s engine catched exception(except ReturnStatusException), set `StatusCode.Unknown` and client received gRPC\'s `RpcException`. If `MagicOnionOption.IsReturnExceptionStackTraceInErrorDetail` is true, client can receive StackTrace of server exception, it is very useful for debugging but has critical issue about sercurity so should only to enable debug build.\n\n### Group and GroupConfiguration\nStreamingHub\'s broadcast system is called Group. It can get from StreamingHub impl method, `this.Group`(this.Group type is `HubGroupRepository`, not `IGroup`).\n\nCurrent connection can add to group by `this.Group.AddAsync(string groupName)`, return value(`IGroup`) is joined group broadcaster so cache to field. It is enable per connection(if disconnected, automaticaly leaved from group). If you want to use some restriction, you can use `TryAddAsync(string groupName, int incluciveLimitCount, bool createIfEmpty)`.\n\n`IGroup` can pass to StreamingHub.`Broadcast`, `BroadcastExceptSelf`, `BroadcastExcept` and calls client proxy.\n\n```csharp\npublic class ChatHub : StreamingHubBase<IChatHub, IMessageReceiver>, IChatHub\n{\n    string userName;\n    IGroup room;\n\n    public async Task JoinAsync(string userName, string roomName)\n    {\n        this.userName = userName;\n        this.room = await Group.AddAsync(roomName);\n    }\n\n    public async Task SendMessageAsync(string message)\n    {\n        Broadcast(room).OnReceiveMessage(userName, message);\n    }\n}\n```\n\n> GroupRepository is created per StreamingHub type\n\n> If you want to create ServerSide loop and broadcast out of StreamingHub, you can pass Broadcast(room) result but it is unnatural, I\'ll add support kit of create server-side loop  \n\nGroup has in-memory storage, it can store extra data to group member. It can set `Group.AddAsync(string groupName, TStorage data)` instead of standard AddAsync.\n\nData is can get from `group.GetInMemoryStorage<T>` and can invoke `AllValues`, `Set(Guid connectionId, T Value)`, `Get(Guid connectionId)`.\n\n> StreamingHub\'s ConnectionId is ServiceContext.ContextId\n\nDefault MagicOnion\'s group is inmemory and using `ImmutableArrayGroup`. This group implementation is tuned for small room, not enter/leave frequently. If large room and enter/leave frequently design, you can use `ConcurrentDictionaryGroup`. It can configure by `GroupConfigurationAttribute` or `MagicOnionOptions.DefaultGroupRepositoryFactory`.\n\n```csharp\n// use ***GroupRepositoryFactory type.\n[GroupConfiguration(typeof(ConcurrentDictionaryGroupRepositoryFactory))]\npublic class ChatHub : StreamingHubBase<IChatHub, IMessageReceiver>, IChatHub\n{\n    // ...\n}\n```\n\nMagicOnion has distribute system called redis-backplane for group broadcast.\n\n![image](https://user-images.githubusercontent.com/46207/50974777-5f6aed00-152f-11e9-97f3-ba2a0c97f0eb.png)\n\n* Install-Package MagicOnion.Redis\n\n```csharp\n// set RedisGroupRepositoryFactory\n[GroupConfiguration(typeof(RedisGroupRepositoryFactory))]\npublic class ...\n{\n}\n\n// configure ConnectionMultiplexer(StackExchange.Redis) to MagicOnionOption.ServiceLocator\nvar option = new MagicOnionOption();\noption.ServiceLocator.Register(new ConnectionMultiplexer(...));\n```\n\n### Project Structure\nIf creates Server-Client project, I recommend make three projects. `Server`, `ServerDefinition`, `Client`.\n\n![image](https://cloud.githubusercontent.com/assets/46207/21081857/e0f6dfce-c012-11e6-850d-358c5b928a82.png)\n\nServerDefinition is only defined interface(`IService<>`, `IStreamingHub<,>`)(and some share request/response types).\n\nIf debugging, I recommend use [SwitchStartupProject](https://marketplace.visualstudio.com/items?itemName=vs-publisher-141975.SwitchStartupProjectforVS2017) exteinson of VisualStudio and launch both Server and Client.\n\n```json\n"MultiProjectConfigurations": {\n    "Server + Client": {\n        "Projects": {\n            "FooService": {},\n            "FooClient": {}\n        }\n    }\n}\n```\n\nIt can step-in/out seamlessly in server and client.\n\nfor Unity, you can\'t share by DLL(because can\'t share `IServer<>` because it is different reference both Unity and Server). It is slightly complex so we provides sample project and explanation.\n\nsee: [samples](https://github.com/Cysharp/MagicOnion/tree/master/samples) page and ReadMe.\n\n\n### Dependency Injection\nYou can use DI(constructor injection) by GenericHost.\n\n```csharp\nstatic async Task Main(string[] args)\n{\n    await MagicOnionHost.CreateDefaultBuilder()\n        .ConfigureServices((hostContext, services) =>\n        {\n            // DI, you can register types on this section.\n\n            // mapping config json to IOption<MyConfig>\n            // requires "Microsoft.Extensions.Options.ConfigurationExtensions" package\n            services.Configure<MyConfig>(hostContext.Configuration);\n        })\n        .RunConsoleAsync();\n}\n\npublic class MyFirstService : ServiceBase<IMyFirstService>, IMyFirstService\n{\n    IOptions<MyConfig> config;\n    ILogger<MyFirstService> logger;\n\n    public MyFirstService(IOptions<MyConfig> config, ILogger<MyFirstService> logger)\n    {\n        this.config = config;\n        this.logger = logger;\n    }\n\n    // ...\n}\n```\n\n## Server and Clients\n\n### Unity client Supports\nYou can download `MagicOnion.Client.Unity.package` and `moc.zip`(MagicOnionCompiler) in the [releases page](https://github.com/cysharp/MagicOnion/releases). But MagicOnion has no dependency so download gRPC lib from [gRPC daily builds](https://packages.grpc.io/), click Build ID and download `grpc_unity_package.*.*.*-dev.zip`. One more, requires MessagePack for C# for serialization, you can download `MessagePack.Unity.*.*.*.unitypackage` and `mpc.zip`(MessagePackCompiler) from [MessagePack-CSharp/releases](https://github.com/neuecc/MessagePack-CSharp/releases).\n\nMagicOnion only supports `.NET 4.x` runtime and recommend to supports C# 7.0(Unity 2018.3) version. Allow unsafe Code and add `ENABLE_UNSAFE_MSGPACK`, you can use `UnsafeDirectBlitResolver` to extremely fast serialization.\n\nDefault MagicOnion\'s Unity client works well on Unity Editor or not IL2CPP env. But for IL2CPP environment, you need client code generation. `moc` is cross-platform standalone application.\n\n```\nmoc arguments help:\n  -i, --input=VALUE          [required]Input path of analyze csproj\n  -o, --output=VALUE         [required]Output path(file) or directory base(in separated mode)\n  -u, --unuseunityattr       [optional, default=false]Unuse UnityEngine\'s RuntimeInitializeOnLoadMethodAttribute on MagicOnionInitializer\n  -c, --conditionalsymbol=VALUE [optional, default=empty]conditional compiler symbol\n  -n, --namespace=VALUE      [optional, default=MagicOnion]Set namespace root name\n  -a, asyncsuffix      [optional, default=false]Use methodName to async suffix\n```\n\nPlease try it to run iOS/Android etc.\n\nProject structure and code generation sample, see [samples](https://github.com/Cysharp/MagicOnion/tree/master/samples) page and ReadMe.\n\n### Server host\nI\'ve recommend to use [.NET Generic Host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.2) to host .NET Core app. `MagicOnion.Hosting` package helps to build to use MagicOnion.\n\n* Install-Package MagicOnion.Hosting\n\n```csharp\n// using MagicOnion.Hosting\nstatic async Task Main(string[] args)\n{\n    // you can use new HostBuilder() instead of CreateDefaultBuilder\n    await new HostBuilder()\n        .UseMagicOnion()\n        .RunConsoleAsync();\n}\n```\n\nIf you can want to load configuration, set logging, etc, see .NET Generic Host documantation.\n\nCreateDefaultBuilder\'s setup details is same as [MicroBatchFramework](https://github.com/Cysharp/MicroBatchFramework), it is similar as `WebHost.CreateDefaultBuilder` on ASP.NET Core. for the details, see [MicroBatchFramework#configure-configuration](https://github.com/Cysharp/MicroBatchFramework#configure-configuration)\n\n\n### Server host options\nConfigure MagicOnion hosting using `Microsoft.Extensions.Options` that align to .NET Core way. In many real use cases, Using setting files (ex. appsettings.json), environment variables, etc ... to configure an application.\n\nFor example, We have Production and Development configurations and have some differences about listening ports, certificates and others.\n\nThis example makes hosting MagicOnion easier and configurations moved to external files, environment variables. appsettings.json looks like below.\n\n```csharp\n{\n  "MagicOnion": {\n    "Service": {\n      "IsReturnExceptionStackTraceInErrorDetail": false\n    },\n    "ChannelOptions": {\n      "grpc.primary_user_agent": "MagicOnion/1.0 (Development)",\n      "grpc.max_receive_message_length": 4194304\n    },\n    "ServerPorts": [\n      {\n        "Host": "localhost",\n        "Port": 12345,\n        "UseInsecureConnection": false,\n        "ServerCredentials": [\n          {\n            "CertificatePath": "./server.crt",\n            "KeyPath": "./server.key"\n          }\n        ]\n      }\n    ]\n  }}\n```\n\nAn application setting files is not required by default. You can simply call UseMagicOnion() then it starts service on localhost:12345 (Insecure connection).\n\n```csharp\nclass Program\n{\n   static async Task Main(string[] args)\n   {\n       await MagicOnionHost.CreateDefaultBuilder()\n           .UseMagicOnion()\n           .RunConsoleAsync();\n   }\n}\n```\n\nOf course, you can also flexibly configure hosting by code. During configuration, you can access `IHostingEnvironment` / `IConfiguration` instances and configure \n`MagicOnionOptions`.\n\n```csharp\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        await MagicOnionHost.CreateDefaultBuilder()\n            .UseMagicOnion()\n            .ConfigureServices((hostContext, services) =>\n            {\n                services.Configure<MagicOnionHostingOptions>(options =>\n                {\n                    if (hostContext.HostingEnvironment.IsDevelopment())\n                    {\n                        options.Service.GlobalFilters = new[] { new MyFilterAttribute(null) };\n                    }\n                    options.ChannelOptions.MaxReceiveMessageLength = 1024 * 1024 * 10;\n                });\n            })\n            .RunConsoleAsync();\n    }\n}\n```\n\nThis configuration method supports multiple MagicOnion hosting scenarios.\n\n```json\n{\n  "MagicOnion": {\n    "ServerPorts": [\n      {\n        "Host": "localhost",\n        "Port": 12345,\n        "UseInsecureConnection": true\n      }\n    ]\n  },\n  "MagicOnion-Management": {\n    "ServerPorts": [\n      {\n        "Host": "localhost",\n        "Port": 23456,\n        "UseInsecureConnection": true\n      }\n    ]\n  }\n}\n```\n\n```csharp\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        await MagicOnionHost.CreateDefaultBuilder()\n            .UseMagicOnion(types: new[] { typeof(MyService) })\n            .UseMagicOnion(configurationName: "MagicOnion-Management", types: new[] { typeof(ManagementService) })\n            .ConfigureServices((hostContext, services) =>\n            {\n                services.Configure<MagicOnionHostingOptions>(options =>\n                {\n                    options.ChannelOptions.MaxReceiveMessageLength = 1024 * 1024 * 10;\n                });\n                services.Configure<MagicOnionHostingOptions>("MagicOnion-Management", options =>\n                {\n                    if (hostContext.HostingEnvironment.IsDevelopment())\n                    {\n                        options.Service.GlobalFilters = new[] { new MyFilterAttribute(null) };\n                    }\n                });\n            })\n            .RunConsoleAsync();\n    }\n}\n```\n\n## Deployment\n\n### Host in Docker\nIf you hosting the samples on a server, recommend to use container. Add Dockerfile like below.\n\n```dockerfile\nFROM mcr.microsoft.com/dotnet/core/sdk:2.2 AS sdk\nCOPY . ./workspace\n\nRUN dotnet publish ./workspace/samples/ChatApp/ChatApp.Server/ChatApp.Server.csproj -c Release -o /app\n\nFROM mcr.microsoft.com/dotnet/core/runtime:2.2\nCOPY --from=sdk /app .\nENTRYPOINT ["dotnet", "ChatApp.Server.dll"]\n\n# Expose ports.\nEXPOSE 12345\n```\n\nAnd docker build, send to any container registory.\n\nHere is the sample of deploy AWS [ECR](https://us-east-2.console.aws.amazon.com/ecr/) and [ECS](https://us-east-2.console.aws.amazon.com/ecs) by CircleCI.\n```yml\nversion: 2.1\norbs:\n# see: https://circleci.com/orbs/registry/orb/circleci/aws-ecr\n# use Environment Variables : AWS_ECR_ACCOUNT_URL\n#                             AWS_ACCESS_KEY_ID\t\n#                             AWS_SECRET_ACCESS_KEY\n#                             AWS_REGION  \n  aws-ecr: circleci/aws-ecr@4.0.1\n# see: https://circleci.com/orbs/registry/orb/circleci/aws-ecs\n# use Environment Variables : AWS_ACCESS_KEY_ID\t\n#                             AWS_SECRET_ACCESS_KEY\n#                             AWS_REGION\n  aws-ecs: circleci/aws-ecs@0.0.7\nworkflows:\n  build-push:\n    jobs:\n      - aws-ecr/build_and_push_image:\n          repo: sample-magiconion\n      - aws-ecs/deploy-service-update:\n          requires:\n            - aws-ecr/build_and_push_image\n          family: \'sample-magiconion-service\'\n          cluster-name: \'sample-magiconion-cluster\'\n          container-image-name-updates: \'container=sample-magiconion-service,tag=latest\'\n          \n```\n\nHere is the sample of deploy [Google Cloud Platform(GCP)](https://console.cloud.google.com/) by CircleCI.\n```yml\nversion: 2.1\norbs:\n  # see: https://circleci.com/orbs/registry/orb/circleci/gcp-gcr\n  # use Environment Variables : GCLOUD_SERVICE_KEY\n  #                             GOOGLE_PROJECT_ID\n  #                             GOOGLE_COMPUTE_ZONE\n    gcp-gcr: circleci/gcp-gcr@0.6.0\nworkflows:\n    build_and_push_image:\n        jobs:\n            - gcp-gcr/build-and-push-image:\n                image: sample-magiconion\n                registry-url: asia.gcr.io # other: gcr.io, eu.gcr.io, us.gcr.io\n```\n\nDepending on the registration information of each environment and platform, fine tuning may be necessary, so please refer to the platform documentation and customize your own.\n\n### SSL/TLS\nAs [official gRPC doc](https://grpc.io/docs/guides/auth/) notes gRPC supports SSL/TLS, and MagicOnion also support SSL/TLS. \n\n> gRPC has SSL/TLS integration and promotes the use of SSL/TLS to authenticate the server, and to encrypt all the data exchanged between the client and the server. Optional mechanisms are available for clients to provide certificates for mutual authentication\n\nI will explain how to setup "SSL/TLS MagicOnion on localhost" with following 4 steps.\n\n* [generate certificate](#generate-certificate)\n* [simulate dummy domain on localhost](#simulate-dummy-domain-on-localhost)\n* [server configuration](#server-configuration)\n* [client configuration](#client-configuration)\n\nLet\'s use [samples/ChatApp/ChatApp.Server](https://github.com/Cysharp/MagicOnion/tree/master/samples/ChatApp/ChatApp.Server) for server project, and [samples/ChatApp/ChatApp.Unity](https://github.com/Cysharp/MagicOnion/tree/master/samples/ChatApp/ChatApp.Unity) for client project.\n\n#### generate certificate\n\nCertificates are required to establish SSL/TLS with Server/Client channel connection.\nLet\'s use [OpenSSL](https://github.com/openssl/openssl) to create required certificates.\n\nFollowing command will create 3 files `server.csr`, `server.key` and `server.crt`.\ngRPC/MagicOnion Server requires server.crt and server.key, and Client require server.crt.\n\n```shell\n# move to your server project\n$ cd MagicOnion/samples/ChatApp/ChatApp.Server\n\n# generate certificates\n# NOTE: CN=xxxx should match domain name to magic onion server pointing domain name\n$ openssl genrsa 2048 > server.key\n$ openssl req -new -sha256 -key server.key -out server.csr -subj "/C=JP/ST=Tokyo/L=Tokyo/O=MagicOnion Demo/OU=Dev/CN=*.example.com"\n$ openssl x509 -req -in server.csr -signkey server.key -out server.crt -days 7300 -extensions server\n\n# server will use server.crt and server.key, leave generated certificates.\n\n# client will use server.crt, copy certificate to StreamingAssets folder.\n$ mkdir ../ChatApp.Unity/Assets/StreamingAssets\n$ cp server.crt ../ChatApp.Unity/Assets/StreamingAssets/server.crt\n```\n\nPlease modify `/C=JP/ST=Tokyo/L=Tokyo/O=MagicOnion Demo/OU=Dev/CN=*.example.com` as you need.\nMake sure `CN=xxxx` should match to domain that your MagicOnion Server will recieve request from your client.\n\n> ATTENTION: Make sure **server.key** is very sensitive file, while **server.crt** can be public. DO NOT COPY server.key to your client.\n\n#### simulate dummy domain on localhost\n\nEditting `hosts` file is the simple way to redirect dummy domain request to your localhost.\n\nLet\'s set your CN to you hosts, example is `dummy.example.com`. \nOpen hosts file and add your entry.\n\n```shell\n# NOTE: edit hosts to test on localhost\n# Windows: (use scoop to install sudo, or open elevated cmd or notepad.)\nPS> sudo notepad c:\\windows\\system32\\drivers\\etc\\hosts\n# macos:\n$ sudo vim /private/etc/hosts\n# Linux:\n$ sudo vim /etc/hosts\n```\n\nEntry format would be similar to this, please follow to your platform hosts rule.\n\n```shell\n127.0.0.1\tdummy.example.com\n```\n\nAfter modifying hosts, `ping` to your dummy domain and confirm localhost is responding.\n\n```shell\n$ ping dummy.example.com\n\npinging to dummy.example.com [127.0.0.1] 32 bytes data:\n127.0.0.1 response: bytecount =32 time <1ms TTL=128\n```\n\n#### server configuration\n\n> NOTE: Server will use **server.crt** and **server.key**, if you didn\'t copy OpenSSL generated `server.crt` and `server.key`, please back to [generate certificate](#generate-certificate) section and copy them.\n\nOpen `samples/ChatApp/ChatApp.Server/ChatApp.Server.csproj` and add folloging lines before `</Project>`.\n\n```xml\n  <ItemGroup>\n    <Folder Include="LinkFromUnity\\" />\n  </ItemGroup>\n\n  <!-- FOR SSL/TLS SUPPORT -->\n  <ItemGroup>\n    <None Update="server.crt">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n    <None Update="server.key">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n  </ItemGroup>\n\n</Project>\n```\n\nOpen `samples/ChatApp/ChatApp.Server/Program.cs`, there are default Insecure channel definition with `ServerCredentials.Insecure`.\nWhat you need is change this line to use `SslServerCredentials`.\n\n```csharp\nnew ServerPort("localhost", 12345, ServerCredentials.Insecure))\n```\n\nAdd following lines before `await MagicOnionHost.CreateDefaultBuilder()`\n\n```csharp\nvar config = new ConfigurationBuilder().AddEnvironmentVariables().Build();\nvar certificates = new System.Collections.Generic.List<KeyCertificatePair> { new KeyCertificatePair(System.IO.File.ReadAllText("server.crt"), System.IO.File.ReadAllText("server.key")) };\nvar credential = new SslServerCredentials(certificates);\n```\n\nYou may required following using namespaces.\n\n```csharp\nusing Microsoft.Extensions.Configuration;\nusing System.Collections.Generic;\nusing System.IO;\n```\n\nReplace existing `new ServerPort("localhost", 12345, ServerCredentials.Insecure))` line with following.\n\n```csharp\nnew ServerPort(config.GetValue<string>("MAGICONION_HOST", "127.0.0.1"), 12345, credential))\n```\n\n> NOTE: Replace `localhost` to `127.0.0.1` enforce IPv4 connection.\n\nDebug run server on Visual Studio, any IDE or docker.\n\n```shell\nD0729 11:08:21.767387 Grpc.Core.Internal.NativeExtension gRPC native library loaded successfully.\nApplication started. Press Ctrl+C to shut down.\nHosting environment: Production\n```\n\n#### client configuration\n\n> NOTE: Client will use **server.crt**, if you didn\'t copy OpenSSL generated `server.crt` and `server.key`, please back to [generate certificate](#generate-certificate) section and copy it.\n\nOpen `samples/ChatApp/ChatApp.Unity/Assets/ChatComponent.cs`, channel creation is defined as `ChannelCredentials.Insecure` in `InitializeClient()`.\nWhat you need tois change this line to use `SslCredentials`.\n\n\n```csharp\nthis.channel = new Channel("localhost", 12345, ChannelCredentials.Insecure);\n```\n\nReplace this line to following.\n\n```csharp\nvar serverCred = new SslCredentials(File.ReadAllText(Path.Combine(Application.streamingAssetsPath, "server.crt")));\nthis.channel = new Channel("dummy.example.com", 12345, serverCred);\n```\n\nPlay on Unity Editor and confirm Unity MagicOnion Client can connect to MagicOnion Server.\n\n![image](https://user-images.githubusercontent.com/3856350/62017554-1be97f00-b1f2-11e9-9769-70464fe6d425.png)\n\n> NOTE: If there are any trouble establish SSL/TLS connection, Unity Client will show `disconnected server.` log.\n\n## Integrations\n### Swagger\nMagicOnion has built-in Http1 JSON Gateway and [Swagger](http://swagger.io/) integration for Unary operation. It can execute and debug RPC-API easily.\n\n* Install-Package MagicOnion.HttpGateway\n\nHttpGateway is built on ASP.NET Core. for example, with `Microsoft.AspNetCore.Server.WebListener`.\n\n```csharp\n// using MagicOnion.Hosting;\n// using Microsoft.Extensions.DependencyInjection;\n// using Microsoft.Extensions.Hosting;\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        // setup MagicOnion hosting.\n        var magicOnionHost = MagicOnionHost.CreateDefaultBuilder()\n            .UseMagicOnion(\n                new MagicOnionOptions(isReturnExceptionStackTraceInErrorDetail: true),\n                new ServerPort("localhost", 12345, ServerCredentials.Insecure))\n            .UseConsoleLifetime()\n            .Build();\n\n        // NuGet: Microsoft.AspNetCore.Server.Kestrel\n        var webHost = new WebHostBuilder()\n            .ConfigureServices(collection =>\n            {\n                // Add MagicOnionServiceDefinition for reference from Startup.\n                collection.AddSingleton<MagicOnionServiceDefinition>(magicOnionHost.Services.GetService<MagicOnionHostedServiceDefinition>().ServiceDefinition);\n            })\n            .UseKestrel()\n            .UseStartup<Startup>()\n            .UseUrls("http://localhost:5432")\n            .Build();\n\n        // Run and wait both.\n        await Task.WhenAll(webHost.RunAsync(), magicOnionHost.RunAsync());\n    }\n}\n\n// WebAPI Startup configuration.\npublic class Startup\n{\n    // Inject MagicOnionServiceDefinition from DIl\n    public void Configure(IApplicationBuilder app, MagicOnionServiceDefinition magicOnion)\n    {\n        // Optional:Add Summary to Swagger\n        // var xmlName = "Sandbox.NetCoreServer.xml";\n        // var xmlPath = Path.Combine(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location), xmlName);\n\n        // HttpGateway requires two middlewares.\n        // One is SwaggerView(MagicOnionSwaggerMiddleware)\n        // One is Http1-JSON to gRPC-MagicOnion gateway(MagicOnionHttpGateway)\n        app.UseMagicOnionSwagger(magicOnion.MethodHandlers, new SwaggerOptions("MagicOnion.Server", "Swagger Integration Test", "/")\n        {\n            // XmlDocumentPath = xmlPath\n        });\n        app.UseMagicOnionHttpGateway(magicOnion.MethodHandlers, new Channel("localhost:12345", ChannelCredentials.Insecure));\n    }\n}\n```\n\nOpen `http://localhost:5432`, you can see swagger view.\n\n![image](https://cloud.githubusercontent.com/assets/46207/21295663/6a9d3e28-c59d-11e6-8081-18d14e359567.png)\n\n### Telemetry\n\nYou can configure Telemetry for MagicOnion with `MagicOnion.OpenTelemetry` package.\nLet\'s see overview and how to try on localhost.\n\n* overview\n* examples of implementation\n* try visualization on localhost\n* metrics customization\n* implement your own metrics\n\n#### overview\n\nMagicOnion.OpenTelemetry is implementation of [open\\-telemetry/opentelemetry\\-dotnet: OpenTelemetry \\.NET SDK](https://github.com/open-telemetry/opentelemetry-dotnet), so you can use any OpenTelemetry exporter, like [Prometheus](https://prometheus.io/), [StackDriver](https://cloud.google.com/stackdriver/pricing), [Zipkin](https://zipkin.io/) and others.\n\nYou can collect telemetry and use exporter on MagicOnion Serverside.\n\n#### examples of implementation\n\nWhat you need to do for Telemetry is followings.\n\n* configure exporter.\n* add reference to the MagicOnion.OpenTelemetry.\n* configure DI for OpenTelemetry-dotnet.\n* configure filters/logger for telemetry.\n\nLet\'s follow the steps. \n\n**configure exporeter**\n\nBefore implementing exporeters, I\'ve recommend check samples offering on [opentelemetry\\-dotnet/samples/Exporters at master \xc2\xb7 open\\-telemetry/opentelemetry\\-dotnet](https://github.com/open-telemetry/opentelemetry-dotnet/tree/master/samples/Exporters).\n\nHere\'s prometheus exporter sample implementation, paste this before `MagicOnionHost.CreateDefaultBuilder()`.\nThis implementation allow prometheus to collect MagicOnion metrics from http://localhost:9184/metrics.\n\n```csharp\n# Program.cs\nvar exporter = new PrometheusExporter(\n    new PrometheusExporterOptions()\n    {\n        Url = $"http://localhost:9184/metrics/",\n    },\n    Stats.ViewManager);\nexporter.Start();\n\n// await MagicOnionHost.CreateDefaultBuilder(useSimpleConsoleLogger: true)\n```\n\nIf you are running on any VM, Container or Kubernetes, you can configure exporter host & port by through ConfigurationBuilder.\nFollowing example allow you to change exporter host/port by environment variables `PROMETHEUS_EXPORTER_HOST` & `PROMETHEUS_EXPORTER_PORT`.\n\n```csharp\n# Program.cs\nvar config = new ConfigurationBuilder().AddEnvironmentVariables().Build();\nvar exporterHost = config.GetValue<string>("PROMETHEUS_EXPORTER_HOST", "localhost");\nvar exporterPort = config.GetValue<string>("PROMETHEUS_EXPORTER_PORT", "9182");\nvar exporter = new PrometheusExporter(\n    new PrometheusExporterOptions()\n    {\n        Url = $"http://{exporterHost}:{exporterPort}/metrics/",\n    },\n    Stats.ViewManager);\nexporter.Start();\n\n// await MagicOnionHost.CreateDefaultBuilder(useSimpleConsoleLogger: true)\n```\n\n**add reference to the MagicOnion.OpenTelemetry**\n\nPlease add [MagicOnion.OpenTelemetry](https://www.nuget.org/packages/MagicOnion.OpenTelemetry) nuget package to your MagicOnion server project.\n\n```shell\ndotnet add package MagicOnion.OpenTelemetry\n```\n\nYou are ready to configure MagicOnion Filter & Logger for OpenTelemetry.\n\n**configure DI for OpenTelemetry-dotnet**\n\nopentelemetry-dotnet requires DI for `ITracer` and `ISampler`.\nMake sure register them in DI with MagicOnion Builder.\n\n```csharp\n# Program.cs\nawait MagicOnionHost.CreateDefaultBuilder(useSimpleConsoleLogger: true)\n    .ConfigureServices(collection =>\n    {\n        collection.AddSingleton<ITracer>(Tracing.Tracer);\n        collection.AddSingleton<ISampler>(Samplers.AlwaysSample);\n    })\n    .UseMagicOnion(....)\n```\n\n**configure filters/logger for telemetry**\n\nUse `MagicOnionOptions` to register filters and logger for telemetry.\nYou can collect MagicOnion metrics with `MagicOnionFilter`, MagicOnion.OpenTelemetry offers `OpenTelemetryCollectorFilter` and `OpenTelemetryHubCollectorFilter` for you.\nAlso register MagicOnionLogger to collect metrics on each hook point prepared on `IMagicOnionLogger`, MagicOnion.OpenTelemetry offers `OpenTelemetryCollectorLogger` for you.\n\n```csharp\nawait MagicOnionHost.CreateDefaultBuilder(useSimpleConsoleLogger: true)\n    .ConfigureServices(collection =>\n    {\n        collection.AddSingleton<ITracer>(Tracing.Tracer);\n        collection.AddSingleton<ISampler>(Samplers.AlwaysSample);\n    })\n    .UseMagicOnion()\n    .ConfigureServices((hostContext, services) =>\n    {\n        services.Configure<MagicOnionHostingOptions>(options =>\n        {\n             options.Service.GlobalFilters.Add<OpenTelemetryCollectorFilter>();\n             options.Service.GlobalStreamingHubFilters.Add<OpenTelemetryHubCollectorFilter>();\n             options.Service.MagicOnionLogger = new OpenTelemetryCollectorLogger(Stats.StatsRecorder, Tags.Tagger, null);\n        });\n    })\n    .RunConsoleAsync();\n```\n\nAll implementation is done! Let\'s Debug run Server and confirm you can see metrics on http://localhost:9182/metrics.\n\n![image](https://user-images.githubusercontent.com/3856350/62096698-83213500-b2bf-11e9-88ff-52ef673ac4f5.png)\n\nYou may find `MagicOnion_measure_BuildServiceDefinition{MagicOnion_keys_Method="BuildServiceDefinition"}` are collected, and other metrics will shown as #HELP.\nThey will export when Unary/StreamingHub request is comming.\n\nIf you want insert your own tag to default metrics, please add `ITagContext` when register `OpenTelemetryCollectorLogger`.\nFollowing will add verion tag for each metrics.\n\n```csharp\nMagicOnionLogger = new OpenTelemetryCollectorLogger(Stats.StatsRecorder, Tags.Tagger, new TagContext(new Dictionary<TagKey, TagValue>\n{\n    // add version to all default metrics\n    { TagKey.Create("version"), TagValue.Create("1.0.0") },\n}))\n```\n\nNow each metrics contains `version` tag like `MagicOnion_measure_BuildServiceDefinition{MagicOnion_keys_Method="BuildServiceDefinition",version="1.0.0"}`.\n\n#### try visualization on localhost\n\nYou can try Prometheus collecter and visualize metrics on Grafana, all these operation can be done by docker-compose.\nPlease follow the steps.\n\n* Apply above `examples of implementation` settings to the [MagicOnion/samples/ChatApp/ChatApp.Server](https://github.com/Cysharp/MagicOnion/tree/master/samples/ChatApp/ChatApp.Server).\n\n* Copy all items in [MagicOnion/docs/telemetry](https://github.com/Cysharp/MagicOnion/tree/master/docs/telemetry) directory to [MagicOnion/samples/ChatApp].\n\n```shell\n# Windows\n> xcopy MagicOnion\\docs\\telemetry MagicOnion\\samples\\ChatApp /H /E\n# Bash\n$ cp -rT MagicOnion/docs/telemetry MagicOnion/samples/ChatApp\n```\n\n* Build & Launch docker-compose, you are all systems are up and running on your localhost.\n\n```shell\n$ cd MagicOnion/samples/ChatApp\n$ docker-compose build\n$ docker-compose up\n\nCreating network "chatapp_default" with the default driver\nCreating alertmanager         ... done\nCreating prometheus           ... done\nCreating chatapp_magiconion_1 ... done\nCreating cAdvisor             ... done\nCreating grafana              ... done\n```\n\nWhen you launch docker-compose, followings set of service will launch for you.\n\n* **MagicOnion** stats export on http://localhost:9182/metrics/.\n* **cAdvisor** launch on http://localhost:8080.\n* **Prometheus** launch on http://localhost:9090.\n* **Grafana** launch on http://localhost:3000. (default username: `admin`, password: `admin`)\n* **Alertmanager** to notify alert to Slack.\n* optional: if you want **node_exporter**, uncomment in `docker-compose.yml` and it launch on http://localhost:9100. make sure host volume is mounted to container.\n\nTo configure Grafana dashboard, follow the steps.\n\n* add DataSource: Data Souces> add > Prometheus (prometheus URL will be http://prometheus:9090)\n* add Dashboard:\n    * **Prometheus 2.0 Stats** dashboard: open Data Source > prometheus > dashboard tab > add Prometheus 2.0 Stats\n    * **Docker and Host Monitoring w/ Prometheus** dashboard (cAdvisor): open Dashboard > Manage > Import > https://grafana.com/grafana/dashboards/179\n    * **MagicOnion Overview** dashboard (MagicOnion & cAdvisor): open Dashboard > Manage > Import > https://grafana.com/grafana/dashboards/10584\n    * optional: **node_exporter 1.8** dashboard: open Dashboard > Manage > Import > https://grafana.com/grafana/dashboards/1860\n\nNow you can observe MagicOnion metrics through Grafana.\n\n![image](https://user-images.githubusercontent.com/3856350/61683238-c58ec300-ad4f-11e9-9057-1cfb9c30cd67.png)\n\nTo configure alert eather, modify `prometheus/config/alert.rules` and set slack incoming url on `alertmanager/config.yml`.\n\n#### implement your own metrics\n\nImplement `IMagicOnionLogger` to configure your metrics. You can collect metrics when following callbacks are invoked by filter.\n\n```csharp\nnamespace MagicOnion.Server\n{\n    public interface IMagicOnionLogger\n    {\n        void BeginBuildServiceDefinition();\n        void BeginInvokeHubMethod(StreamingHubContext context, ArraySegment<byte> request, Type type);\n        void BeginInvokeMethod(ServiceContext context, byte[] request, Type type);\n        void EndBuildServiceDefinition(double elapsed);\n        void EndInvokeHubMethod(StreamingHubContext context, int responseSize, Type type, double elapsed, bool isErrorOrInterrupted);\n        void EndInvokeMethod(ServiceContext context, byte[] response, Type type, double elapsed, bool isErrorOrInterrupted);\n        void InvokeHubBroadcast(string groupName, int responseSize, int broadcastGroupCount);\n        void ReadFromStream(ServiceContext context, byte[] readData, Type type, bool complete);\n        void WriteToStream(ServiceContext context, byte[] writeData, Type type);\n    }\n}\n```\n\nWhen implement your own metrics, define `IView` and register it `Stats.ViewManager.RegisterView(YOUR_VIEW);`, then send metrics.\n\nThere are several way to send metrics.\n\n> Send each metrics each line.\n\n```csharp\nstatsRecorder.NewMeasureMap().Put(YOUR_METRICS, 1).Record(TagContext);\n```\n\n> Put many metrics and send at once: \n\n```csharp\nvar map = statsRecorder.NewMeasureMap(); map.Put(YOUR_METRICS, 1);\nmap.Put(YOUR_METRICS2, 2);\nmap.Put(YOUR_METRICS3, 10);\nif (isErrorOrInterrupted)\n{\n    map.Put(YOUR_METRICS4, 3);\n}\n\nmap.Record(TagContext);\n```\n\n> create tag scope and set number of metrics.\n\n```csharp\nvar tagContextBuilder = Tagger.CurrentBuilder.Put(FrontendKey, TagValue.Create("mobile-ios9.3.5"));\nusing (var scopedTags = tagContextBuilder.BuildScoped())\n{\n    StatsRecorder.NewMeasureMap().Put(YOUR_METRICS, 1).Record();\n    StatsRecorder.NewMeasureMap().Put(YOUR_METRICS2, 2).Record();\n    StatsRecorder.NewMeasureMap().Put(YOUR_METRICS3, 10).Record();\n}\n```\n\nMake sure your View\'s column, and metrics TagKey is matched. Otherwise none of metrics will shown.\n\n## Advanced\n### MagicOnionOption/Logging\n\n\n`MagicOnionOption` can pass to `MagicOnionEngine.BuildServerServiceDefinition(MagicOnionOptions option)`.\n\n| Property | Description |\n| --- | --- |\n| `IMagicOnionLogger` MagicOnionLogger | Set the diagnostics info logger. |\n| `bool` DisableEmbeddedService | Disable embedded service(ex:heartbeat), default is false. |\n| `IList<MagicOnionFilterDescriptor>` GlobalFilters | Global MagicOnion filters. |\n| `bool` EnableCurrentContext | Enable ServiceContext.Current option by AsyncLocal, default is false. |\n| `IList<StreamingHubFilterDescriptor>` Global StreamingHub filters. | GlobalStreamingHubFilters |\n| `IGroupRepositoryFactory` DefaultGroupRepositoryFactory | Default GroupRepository factory for StreamingHub, default is ``. |\n| `IServiceLocator` ServiceLocator | Add the extra typed option. |\n| `bool` IsReturnExceptionStackTraceInErrorDetail | If true, MagicOnion handles exception ownself and send to message. If false, propagate to gRPC engine. Default is false. |\n| `IFormatterResolver` FormatterResolver | MessagePack serialization resolver. Default is used ambient default(MessagePackSerialzier.Default). |\n\n`IMagicOnionLogger` is structured logger of MagicOnion. Implements your custom logging code and append it, default is `NullMagicOnionLogger`(do nothing). MagicOnion has some built in logger, `MagicOnionLogToGrpcLogger` that structured log to string log and send to `GrpcEnvironment.Logger`. `MagicOnionLogToGrpcLoggerWithDataDump` is includes data dump it is useful for debugging(but slightly heavy, recommended to only use debugging). `MagicOnionLogToGrpcLoggerWithNamedDataDump` is more readable than simple WithDataDump logger.\n\nIf you want to add many loggers, you can use `CompositeLogger`(for gRPC logging), `CompositeMagicOnionLogger`(for MagicOnion structured logging) to composite many loggers.\n### Raw gRPC APIs\nMagicOnion can define and use primitive gRPC APIs(ClientStreaming, ServerStreaming, DuplexStreaming). Especially DuplexStreaming is used underlying StreamingHub. If there is no reason, we recommend using StreamingHub.\n\n```csharp\n// Definitions\npublic interface IMyFirstService : IService<IMyFirstService>\n{\n    UnaryResult<string> SumAsync(int x, int y);\n    Task<UnaryResult<string>> SumLegacyTaskAsync(int x, int y);\n    Task<ClientStreamingResult<int, string>> ClientStreamingSampleAsync();\n    Task<ServerStreamingResult<string>> ServertSreamingSampleAsync(int x, int y, int z);\n    Task<DuplexStreamingResult<int, string>> DuplexStreamingSampleAync();\n}\n\n// Server\npublic class MyFirstService : ServiceBase<IMyFirstService>, IMyFirstService\n{\n    // VisualStudio 2017(C# 7.0), Unity 2018.3 supports return `async UnaryResult` directly\n    // I recommend disable async-warning on project level. <NoWarn>1998</NoWarn>\n    public async UnaryResult<string> SumAsync(int x, int y)\n    {\n        Logger.Debug($"Called SumAsync - x:{x} y:{y}");\n\n        return (x + y).ToString();\n    }\n\n    // VS2015(C# 6.0), Unity 2018.2 use Task\n    public async Task<UnaryResult<string>> SumLegacyTaskAsync(int x, int y)\n    {\n        Logger.Debug($"Called SumAsync - x:{x} y:{y}");\n\n        // use UnaryResult method.\n        return UnaryResult((x + y).ToString());\n    }\n\n    public async Task<ClientStreamingResult<int, string>> ClientStreamingSampleAsync()\n    {\n        Logger.Debug($"Called ClientStreamingSampleAsync");\n\n        // If ClientStreaming, use GetClientStreamingContext.\n        var stream = GetClientStreamingContext<int, string>();\n\n        // receive from client asynchronously\n        await stream.ForEachAsync(x =>\n        {\n            Logger.Debug("Client Stream Received:" + x);\n        });\n\n        // StreamingContext.Result() for result value.\n        return stream.Result("finished");\n    }\n\n    public async Task<ServerStreamingResult<string>> ServertSreamingSampleAsync(int x, int y, int z)\n    {\n        Logger.Debug($"Called ServertSreamingSampleAsync - x:{x} y:{y} z:{z}");\n\n        var stream = GetServerStreamingContext<string>();\n\n        var acc = 0;\n        for (int i = 0; i < z; i++)\n        {\n            acc = acc + x + y;\n            await stream.WriteAsync(acc.ToString());\n        }\n\n        return stream.Result();\n    }\n\n    public async Task<DuplexStreamingResult<int, string>> DuplexStreamingSampleAync()\n    {\n        Logger.Debug($"Called DuplexStreamingSampleAync");\n\n        // DuplexStreamingContext represents both server and client streaming.\n        var stream = GetDuplexStreamingContext<int, string>();\n\n        var waitTask = Task.Run(async () =>\n        {\n            // ForEachAsync(MoveNext, Current) can receive client streaming.\n            await stream.ForEachAsync(x =>\n            {\n                Logger.Debug($"Duplex Streaming Received:" + x);\n            });\n        });\n\n        // WriteAsync is ServerStreaming.\n        await stream.WriteAsync("test1");\n        await stream.WriteAsync("test2");\n        await stream.WriteAsync("finish");\n\n        await waitTask;\n\n        return stream.Result();\n    }\n}\n```\n\nClient sample.\n\n```csharp\nstatic async Task UnaryRun(IMyFirstService client)\n{\n    // await(C# 7.0, Unity 2018.3)\n    var vvvvv = await client.SumAsync(10, 20);\n    Console.WriteLine("SumAsync:" + vvvvv);\n    \n    // if use Task<UnaryResult>(Unity 2018.2), use await await\n    var vvvv2 = await await client.SumLegacyTaskAsync(10, 20);\n}\n\nstatic async Task ClientStreamRun(IMyFirstService client)\n{\n    var stream = await client.ClientStreamingSampleAsync();\n\n    for (int i = 0; i < 3; i++)\n    {\n        await stream.RequestStream.WriteAsync(i);\n    }\n    await stream.RequestStream.CompleteAsync();\n\n    var response = await stream.ResponseAsync;\n\n    Console.WriteLine("Response:" + response);\n}\n\nstatic async Task ServerStreamRun(IMyFirstService client)\n{\n    var stream = await client.ServertSreamingSampleAsync(10, 20, 3);\n\n    await stream.ResponseStream.ForEachAsync(x =>\n    {\n        Console.WriteLine("ServerStream Response:" + x);\n    });\n}\n\nstatic async Task DuplexStreamRun(IMyFirstService client)\n{\n    var stream = await client.DuplexStreamingSampleAync();\n\n    var count = 0;\n    await stream.ResponseStream.ForEachAsync(async x =>\n    {\n        Console.WriteLine("DuplexStream Response:" + x);\n\n        await stream.RequestStream.WriteAsync(count++);\n        if (x == "finish")\n        {\n            await stream.RequestStream.CompleteAsync();\n        }\n    });\n}\n```\n\n### Zero deserialization mapping\nIn RPC, especially in real-time communication involving frequent transmission of data, it is often the serialization process where data is converted before being sent that limits the performance. In MagicOnion, serialization is done by my MessagePack for C#, which is the fastest binary serializer for C#, so it cannot be a limiting factor. Also, in addition to performance, it also provides flexibility regarding data in that variables of any type can be sent as long as they can be serialized by MessagePack for C#.\n\nAlso, taking advantage of the fact that both the client and the server run on C# and data stored on internal memory are expected to share the same layout, I added an option to do mapping through memory copy without serialization/deserialization in case of a value-type variable.\n\nEspecially in Unity, this is can combinate with `MessagePack.UnityShims` package of NuGet.\n\n```csharp\n// It supports standard struct-type variables that are provided by Unity, such as Vector3, and arrays containing them, as well as custom struct-type variables and their arrays.\n// I recommend doing this explicitly using [StructLayout(LayoutKind.Explicit)] to accurately match the size.\npublic struct CustomStruct\n{\n    public long Id;\n    public int Hp;\n    public int Mp;\n    public byte Status;\n}\n \n// ---- Register the following code when initializing.\n \n// By registering it, T and T[] can be handled using zero deserialization mapping.\nUnsafeDirectBlitResolver.Register<CustomStruct>();\n \n// The struct-type above as well as Unity-provided struct-types (Vector2, Rect, etc.), and their arrays are registered as standards.\nCompositeResolver.RegisterAndSetAsDefault(\n    UnsafeDirectBlitResolver.Instance,\n    MessagePack.Unity.Extension.UnityBlitResolver.Instance\n    );\n \n// --- Now the communication will be in the format above when they are used for transmission.\nawait client.SendAsync(new CustomStruct { Hp = 99 });\n```\n\nNothing needs to be processed here, so it promises the best performance theoretically possible in terms of transmission speed. However, since these struct-type variables need to be copied, I recommend handling everything as ref as a rule when you need to define a large struct-type, or it might slow down the process.\n\nI believe that this can be easily and effectively applied to sending a large number of Transforms, such as an array of Vector3 variables.\n\n## Author Info\nThis library is mainly developed by Yoshifumi Kawai(a.k.a. neuecc).  \nHe is the CEO/CTO of Cysharp which is a subsidiary of [Cygames](https://www.cygames.co.jp/en/).  \nHe is awarding Microsoft MVP for Developer Technologies(C#) since 2011.  \nHe is known as the creator of [UniRx](https://github.com/neuecc/UniRx/) and [MessagePack for C#](https://github.com/neuecc/MessagePack-CSharp/).\n\n## License\nThis library is under the MIT License.\n'