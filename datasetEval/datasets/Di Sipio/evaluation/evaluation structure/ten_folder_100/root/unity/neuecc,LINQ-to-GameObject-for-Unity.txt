b'LINQ to GameObject\n===\nLINQ to GameObject is GameObject extensions for Unity that allows traverse hierarchy and append GameObject. The design aims both to get the power of LINQ and **performance** of iteration.\n\nYou can install from [Unity Asset Store - LINQ to GameObject](http://u3d.as/content/neuecc/linq-to-game-object) as FREE. Unity Forums support thread, ask me any questions - [http://forum.unity3d.com/threads/linq-to-gameobject.292611/](http://forum.unity3d.com/threads/linq-to-gameobject.292611/)\n\nAxis\n---\nThe concept of LINQ to GameObject is axis on tree.\n\n![](Images/axis.jpg)\n\nEvery traverse method returns `IEnumerable<GameObject>` and deferred exectuion. For example\n\n```csharp\norigin.Ancestors();   // Container, Root\norigin.Children();    // Sphere_A, Sphere_B, Group, Sphere_A, Sphere_B\norigin.Descendants(); // Sphere_A, Sphere_B, Group, P1, Group, Sphere_B, P2, Sphere_A, Sphere_B\norigin.BeforeSelf(); // C1, C2\norigin.AfterSelf();  // C3, C4\n```\n\nYou can chain query(LINQ to Objects) and use some specified methods(`Destroy`, `OfComponent` and others).\n\n```csharp\n// destroy all filtered(tag == "foobar") objects\nroot.Descendants().Where(x => x.tag == "foobar").Destroy();\n\n// destroy all cloned objects\norigin.transform.root.gameObject\n    .Descendants()\n    .Where(x => x.name.EndsWith("(Clone)"))\n    .Destroy();\n\n// get FooScript under self childer objects and self\nvar fooScripts = root.ChildrenAndSelf().OfComponent<FooScript>(); \n```\n\n> Note: LINQ to GameObject is optimized for iteration, returns struct enumerable and struct enumerator instead of `IEnumerable<GameObject>`. More details, see the [Peformance Tips](https://github.com/neuecc/LINQ-to-GameObject-for-Unity#performance-tips) section.\n\nHow to use\n---\nImport LINQ to GameObject from Unity Asset Store - [http://u3d.as/content/neuecc/linq-to-game-object](http://u3d.as/content/neuecc/linq-to-game-object).\n\nAll methods are extension of GameObject, using `Unity.Linq` then you can use all extension methods.\n\n```csharp\nusing Unity.Linq;\n```\n![](Images/using.jpg)\n\nOperate\n---\nLINQ to GameObject have several operate methods, append child(`Add`, `AddFirst`, `AddBeforeSelf`, `AddAfterSelf`), append multiple objects(`AddRange`, `AddFirstRange`, `AddBeforeSelfRange`, `AddAfterSelfRange`) and destroy object(`Destroy`).\n\n![image](https://cloud.githubusercontent.com/assets/46207/17275579/e5f4d4ba-5747-11e6-900f-30193a4ef7b4.png)\n\n```csharp\nvar root = GameObject.Find("root"); \nvar cube = Resources.Load("Prefabs/PrefabCube") as GameObject; \n\n// add do attach parent, set same layer and fix localPosition/Scale/Rotation.\n// added child is cloned and returns child object.\nvar clone = root.Add(cube);\n\n// choose sibling position and allow append multiple objects.\nvar clones = root.AddAfterSelfRange(new[] { cube, cube, cube });  \n\n// destroy do check null.\nroot.Destroy();\n```\n\nAdd method\'s child is cloned. It is useful for instantiate prefab scenario. If you want to move only child, you can use(`MoveToLast`, `MoveToFirst`, `MoveToBeforeSelf`, `MoveToAfterSelf`) and (`MoveToLastRange`, `MoveToFirstRange`, `MoveToBeforeSelfRange`, `MoveToAfterSelfRange`) instead of Add.\n\nAll operate methods are extension methods of GameObject, too. You need `using Unity.Linq`.\n\nReference : Traverse\n---\nAll traverse methods can find inactive object. If not found, return type is `GameObject` methods return null, return type is `IEnumerable<GameObject>` methods return empty sequence.\n\nMethod | Description \n-------| -----------\nParent|Gets the parent GameObject of this GameObject. If this GameObject has no parent, returns null.\nChild|Gets the first child GameObject with the specified name. If there is no GameObject with the speficided name, returns null.\nChildren|Returns a collection of the child GameObjects.\nChildrenAndSelf|Returns a collection of GameObjects that contain this GameObject, and the child GameObjects.\nAncestors|Returns a collection of the ancestor GameObjects of this GameObject.\nAncestorsAndSelf|Returns a collection of GameObjects that contain this element, and the ancestors of this GameObject.\nDescendants|Returns a collection of the descendant GameObjects.\nDescendantsAndSelf|Returns a collection of GameObjects that contain this GameObject, and all descendant GameObjects of this GameObject.\nBeforeSelf|Returns a collection of the sibling GameObjects before this GameObject.\nBeforeSelfAndSelf|Returns a collection of GameObjects that contain this GameObject, and the sibling GameObjects before this GameObject.\nAfterSelf|Returns a collection of the sibling GameObjects after this GameObject.\nAfterSelfAndSelf|Returns a collection of GameObjects that contain this GameObject, and the sibling GameObjects after this GameObject.\n\n`Descendants` has `descendIntoChildren` overload, it stops traverse children when does not match condition.\n\nReference : Operate\n---\nOperate methods have four optional parameter. `cloneType` configure cloned child GameObject\'s localPosition/Scale/Rotation, default copies original local transform. `setActive` configure activates/deactivates child GameObject. If null, doesn\'t set specified value. `specifiedName` configure set name of child GameObject. If null, doesn\'t set specified value. `setLayer` configure set child GameObject\'s layer same with parent, default doesn\'t set layer.\n\nMethod | Description \n-------| -----------\nAdd|Adds the GameObject/Component as children of this GameObject. Target is cloned.\nAddRange|Adds the GameObject/Component as children of this GameObject. Target is cloned.\nAddFirst|Adds the GameObject/Component as the first children of this GameObject. Target is cloned.\nAddFirstRange|Adds the GameObject/Component as the first children of this GameObject. Target is cloned.\nAddBeforeSelf|Adds the GameObject/Component before this GameObject. Target is cloned.\nAddBeforeSelfRange|Adds the GameObject/Component before this GameObject. Target is cloned.\nAddAfterSelf|Adds the GameObject/Component after this GameObject. Target is cloned.\nAddAfterSelfRange|Adds the GameObject/Component after this GameObject. Target is cloned.\nDestroy|Destroy this GameObject safety(check null).\n\nThere are `TransformCloneType` that used Add methods.\n\n> If target is `RectTransform` always use `SetParent(parent, false)` and ignores `TransformCloneType`\n\nValue|Description\n-------| -----------\nKeepOriginal|Set to same as Original. This is default of Add methods.\nFollowParent|Set to same as Parent.\nOrigin|Set to Position = zero, Scale = one, Rotation = identity.\nDoNothing|Position/Scale/Rotation as is.\n\nMoveTo methods similar with Add but don\'t clone target.\n\nMethod | Description \n-------| -----------\nMoveToLast|Move the GameObject/Component as children of this GameObject. \nMoveToLastRange|Move the GameObject/Component as children of this GameObject. \nMoveToFirst|Move the GameObject/Component as the first children of this GameObject. \nMoveToFirstRange|Move the GameObject/Component as the first children of this GameObject. \nMoveToBeforeSelf|Move the GameObject/Component before this GameObject. \nMoveToBeforeSelfRange|Move the GameObject/Component before this GameObject. \nMoveToAfterSelf|Move the GameObject/Component after this GameObject. \nMoveToAfterSelfRange|Move the GameObject/Component after this GameObject. \n\nThere are `TransformMoveType` that used MoveTo methods.\n\n> If target is `RectTransform` always use `SetParent(parent, false)` and ignores `TransformMoveType`\n\nValue|Description\n-------| -----------\nFollowParent|Set to same as Parent.\nOrigin|Set to Position = zero, Scale = one, Rotation = identity.\nDoNothing|Position/Scale/Rotation as is. This is default of MoveTo methods.          \n\nReference : Extensions\n---\n`IEnumerable<GameObject>` Extensions. If multiple GameObjects in the source collection have the same GameObject will be included multiple times in the result collection. To avoid this, use the `Distinct`(LINQ to Objects) method.\n\nMethod|Description\n-------|-----------\nAncestors|Returns a collection of GameObjects that contains the ancestors of every GameObject in the source collection.\nAncestorsAndSelf|Returns a collection of GameObjects that contains every GameObject in the source collection, and the ancestors of every GameObject in the source collection.\nDescendants|Returns a collection of GameObjects that contains the descendant GameObjects of every GameObject in the source collection.\nDescendantsAndSelf|Returns a collection of GameObjects that contains every GameObject in the source collection, and the descendent GameObjects of every GameObject in the source collection.\nChildren|Returns a filtered collection of the child GameObjects of every GameObject in the source collection. Only GameObjects that have a matching name are included in the collection.\nChildrenAndSelf|Returns a collection of GameObjects that contains every GameObject in the source collection, and the child GameObjects of every GameObject in the source collection.\nDestroy|Destroy every GameObject in the source collection safety(check null).\nOfComponent|Returns a collection of specified component in the source collection.\n\nPerformance Tips\n---\nLINQ to GameObject is optimized heavily. Traverse methods returns hand optimized struct enumerator so it can avoid garbage when enumerate.\n\n> Unity compiler has bugs so can not avoid IDisposable boxing cost. But Unity 5.5 upgrade compiler and it was fixed, yeah!\n\nSome LINQ methods are optimized. `First`, `FirstOrDefault`, `ToArray` path through the optimized path.\n\nLINQ to GameObject also provides `ToArrayNonAlloc`. It is like `Physics.RaycastNonAlloc` or `void GetComponentsInChildren<T>(List<T> results)` and reuse `List<T>`. You can reuse array for no garbage.\n\n```csharp\nGameObject[] array = new GameObject[0];\n\n// travese on every update but no allocate memory\nvoid Update()\n{\n    var size = origin.Children().ToArrayNonAlloc(ref array);\n    for (int i = 0; i < size; i++)\n    {\n        var element = array[i];\n    }\n}\n```\n\n`ToArray` and `ToArrayNonAlloc` have five overloads. `()`, `(Func<GameObject, T> selector)`, `(Func<GameObject, bool> filter)`, `(Func<GameObject, bool> filter, Func<GameObject, T> selector)`, `(Func<GameObject, TState> let, Func<TState, bool> filter, Func<TState, T> selector)` for Optimize `Where().Select().ToArray()` pattern.\n\nIf you use simple iteration or use `ForEach` or `ToArrayNonAlloc`, LINQ to GameObject guarantees no gc allocate and performance is very fast.\n\nIf you use `DescendantsAndSelf().OfComponent<T>()`, it may possible to substitude `GetComponentsInChildren<T>` that is always fast than LINQ traverse(because LINQ traverse can not have native magics). So you can substitude native methods, use it. If you needs other query, use LINQ.\n\n> Descendants(AndSelf) returns single Component on each GameObject, GetComponentsInChildren returns multiple Component on each GameObject, so behaviour is different. LINQ to GameObject\'s Descendants is heavily optimized, internal iterator of `ForEach` and `ToArray` is specialize tuned.\n \nAuthor Info\n---\nYoshifumi Kawai(a.k.a. neuecc) is software developer in Japan.  \nHe is Director/CTO at Grani, Inc.  \nGrani is top social game developer in Japan.   \nHe awarded Microsoft MVP for Visual C# since 2011.  \nHe is known by creator of [linq.js](http://linqjs.codeplex.com/)(LINQ to Objects for JavaScript) and [UniRx](https://github.com/neuecc/UniRx)(Reactive Extensions for Unity)\n\nBlog: https://medium.com/@neuecc (ENG)   \nBlog: http://neue.cc/ (JPN)  \nTwitter: https://twitter.com/neuecc (JPN)\n\nLicense\n---\nThis library is under MIT License.\n'