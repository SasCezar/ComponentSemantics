b'<p align="center">\n<img src="https://github.com/Zewo/Venice/blob/master/Images/header.png?raw=true" width="250" />\n</p>\n\n# Venice\n\n[![Swift][swift-badge]][swift-url]\n[![License][mit-badge]][mit-url]\n[![Slack][slack-badge]][slack-url]\n[![Travis][travis-badge]][travis-url]\n[![Codecov][codecov-badge]][codecov-url]\n[![Codebeat][codebeat-badge]][codebeat-url]\n[![Documentation][docs-badge]][docs-url]\n\n**Venice** provides [structured concurrency](http://libdill.org//structured-concurrency.html) and [CSP](https://en.wikipedia.org/wiki/Communicating_sequential_processes) for **Swift**.\n\n## Features\n\n- Coroutines\n- Coroutine cancelation\n- Coroutine groups\n- Channels\n- Receive-only channels\n- Send-only channels\n- File descriptor polling\n\n**Venice** wraps a [fork](https://github.com/Zewo/libdill) of the C library [libdill](https://github.com/sustrik/libdill).\n\n## Installation\n\nBefore using Venice you need to install our [libdill](https://github.com/Zewo/libdill) fork. Follow the instruction for your operating system.\n\n### macOS\n\nOn **macOS** install **libdill** using [brew](https://brew.sh).\n\n```sh\nbrew install zewo/tap/libdill\n```\n\n### Linux\n\nOn **Linux** we have to add our **apt** source first. You only need to run this command once in a lifetime. You don\'t need to run it again if you already have.\n\n```sh\necho "deb [trusted=yes] http://apt.zewo.io ./" | sudo tee -a /etc/apt/sources.list\nsudo apt-get update\n```\n\nNow just install the **libdill** apt package.\n\n```sh\nsudo apt-get install libdill\n```\n\n### Add **Venice** to **Package.swift**\n\nAfter installing **libdill** just add `Venice` as a dependency in your `Package.swift` file.\n\n```swift\nimport PackageDescription\n\nlet package = Package(\n    dependencies: [\n        .Package(url: "https://github.com/Zewo/Venice.git", majorVersion: 0, minor: 19)\n    ]\n)\n```\n\n## Test Coverage\n\n<p align="center">\n    <a href="https://codecov.io/gh/Zewo/Venice"><img src="https://codecov.io/gh/Zewo/Venice/branch/master/graphs/sunburst.svg" height="200" alt="Coverage Sunburst"/></a>\n</p>\n\nThe inner-most circle is the entire project, moving away from the center are folders then, finally, a single file. The size and color of each slice is represented by the number of statements and the coverage, respectively.\n\n## Documentation\n\nYou can check the [Venice API reference](http://zewo.github.io/Venice/) for more in-depth documentation.\n\n## Structured Concurrency\n\nStructured concurrency means that lifetimes of concurrent functions are cleanly nested. If coroutine `foo` launches coroutine `bar`, then `bar` must finish before `foo` finishes.\n\nThis is not structured concurrency:\n\n<p align="left">\n    <img src="http://libdill.org/index1.jpeg" alt="Not Structured Concurrency"/>\n</p>\n\nThis is structured concurrency:\n\n<p align="left">\n    <img src="http://libdill.org/index2.jpeg" alt="Structured Concurrency"/>\n</p>\n\nThe goal of structured concurrency is to guarantee encapsulation. If the `main` function calls `foo`, which in turn launches `bar` in a concurrent fashion, `main` will be guaranteed that once `foo` has finished, there will be no leftover functions still running in the background.\n\nWhat you end up with is a tree of coroutines rooted in the `main` function. This tree spreads out towards the smallest worker functions, and you may think of this as a generalization of the call stack \xe2\x80\x94 a call tree, if you will. In it, you can walk from any particular function towards the root until you reach the main function:\n\n<p align="center">\n    <img src="http://libdill.org/index3.jpeg" alt="Call Tree"/>\n</p>\n\nVenice implements structured concurrency by allowing you to cancel a running coroutine.\n\n```swift\nlet coroutine = try Coroutine {\n    let resource = malloc(1000)\n    \n    defer {\n        free(resource)\n    }\n    \n    while true {\n        try Coroutine.wakeUp(100.milliseconds.fromNow())\n        print(".")\n    }\n}\n\ntry Coroutine.wakeUp(1.second.fromNow())\ncoroutine.cancel()\n```\n\n When a coroutine is being canceled all coroutine-blocking calls will start to throw `VeniceError.canceledCoroutine`. On one hand, this forces the function to finish quickly (there\'s not much you can do without coroutine-blocking functions); on the other hand, it provides an opportunity for cleanup.\n\nIn the example above, when `coroutine.cancel` is called the call to `Coroutine.wakeUp` inside the coroutine will throw `VeniceError.canceledCoroutine` and then the `defer` statement will run, thus releasing the memory allocated for `resource`.\n\n## Threads\n\nYou can use Venice in multi-threaded programs. However, individual threads are strictly separated. You may think of each thread as a separate process.\n\nIn particular, a coroutine created in a thread will be executed in that same thread, and it will never migrate to a different one.\n\nIn a similar manner, a handle, such as a channel or a coroutine handle, created in one thread cannot be used in a different thread.\n\n## License\n\nThis project is released under the MIT license. See [LICENSE](LICENSE) for details.\n\n[swift-badge]: https://img.shields.io/badge/Swift-3.1-orange.svg?style=flat\n[swift-url]: https://swift.org\n\n[mit-badge]: https://img.shields.io/badge/License-MIT-blue.svg?style=flat\n[mit-url]: https://tldrlegal.com/license/mit-license\n\n[slack-image]: http://s13.postimg.org/ybwy92ktf/Slack.png\n[slack-badge]: https://zewo-slackin.herokuapp.com/badge.svg\n[slack-url]: http://slack.zewo.io\n\n[travis-badge]: https://travis-ci.org/Zewo/Venice.svg?branch=master\n[travis-url]: https://travis-ci.org/Zewo/Venice\n\n[codecov-badge]: https://codecov.io/gh/Zewo/Venice/branch/master/graph/badge.svg\n[codecov-url]: https://codecov.io/gh/Zewo/Venice\n\n[codebeat-badge]: https://codebeat.co/badges/bd12fff5-d499-4636-83e6-d4edf89585c5\n[codebeat-url]: https://codebeat.co/projects/github-com-zewo-venice\n\n[docs-badge]: http://zewo.github.io/Venice/badge.svg\n[docs-url]: http://zewo.github.io/Venice\n'