b'[![npm Version](https://img.shields.io/npm/v/import-js.svg)](https://www.npmjs.com/package/import-js) [![License](https://img.shields.io/npm/l/import-js.svg)](https://www.npmjs.com/package/import-js) [![Build Status](https://travis-ci.org/Galooshi/import-js.svg)](https://travis-ci.org/Galooshi/import-js) [![Test Coverage](https://codeclimate.com/github/Galooshi/import-js/badges/coverage.svg)](https://codeclimate.com/github/Galooshi/import-js/coverage)\n\nImportJS is a tool to automatically import dependencies in your JavaScript\nproject. Use it along with one of our editor integrations for\n[Atom][atom-import-js], [Emacs][emacs-import-js], [Sublime][sublime-import-js],\n[Vim][vim-import-js], or [VS Code][vs-code-import-js].\n\n![Demo of ImportJS in action](https://raw.github.com/galooshi/import-js/master/import-js-demo.gif)\n\n## Editor support\n\nThere are ImportJS plugins for the following editors:\n\n- [Atom][atom-import-js]\n- [Emacs][emacs-import-js]\n- [Sublime][sublime-import-js]\n- [Vim][vim-import-js]\n- [VS Code][vs-code-import-js]\n- [(your editor here?)](CONTRIBUTING.md)\n\n[atom-import-js]: https://github.com/galooshi/atom-import-js\n[emacs-import-js]: https://github.com/galooshi/emacs-import-js\n[sublime-import-js]: https://github.com/galooshi/sublime-import-js\n[vim-import-js]: https://github.com/galooshi/vim-import-js\n[vs-code-import-js]: https://github.com/dabbott/vscode-import-js\n\nDetailed instructions on how to install ImportJS can be found in the editor\nlinks above.\n\n*Want to add another editor to the list?* [See how to\ncontribute](CONTRIBUTING.md).\n\n\n## Dependency on Babel 7\n\nImportJS uses [Babel 7](https://babeljs.io/docs/en/next/v7-migration.html) from version [3.1.0](https://github.com/Galooshi/import-js/releases/tag/v3.1.0). In most cases, Babel 7 is backwards-compatible with Babel 6, but if you run into issues (such as [this one about decorators](https://github.com/Galooshi/import-js/issues/515)), consider installing a previous version of ImportJS (e.g. [3.0.0](https://github.com/Galooshi/import-js/releases/tag/v3.0.0)) or updating your project to be Babel 7 compatible.\n\n\n## Importing: Example\n\nLet\'s say that you have a JavaScript project with the following structure:\n\n```\n.\n|-- index.html\n|-- components\n|     |-- button.js\n|     |-- icon.js\n|-- vendor\n|     |--\n|-- pages\n|     |-- index.js\n```\n\nNow, imagine that you\'re editing `pages/index.js` which contains:\n\n```javascript\ndocument.createElement(new Button({ text: \'Save\' }).toDOMElement());\n```\n\nAt this point, `Button` is undefined, so we need to import it. If you are used\nto doing this manually, this involves figuring out the path to the JavaScript\nmodule that defines `Button`. With ImportJS you instead place your cursor on\nthe word "Button", then hit `<leader>j` (Vim), `(M-x) import-js-import` (Emacs),\nor choose "ImportJS: import word under cursor" (Sublime). The file buffer will\nnow change to the following:\n\n```javascript\nimport Button from \'../components/button\';\n\ndocument.createElement(new Button({ text: \'Save\' }).toDOMElement());\n```\n\nThat\'s basically it. ImportJS will help you find modules and automatically add\n`import` statements. But, keep reading for more neat features.\n\n## Fix imports\n\nImportJS can be used to automatically fix all imports in the current file. By\nhitting `<leader>i` (Vim), `(M-x) import-js-fix` (Emacs), or choose `ImportJS:\nfix all imports` (Sublime), all your undefined variables will be resolved, and\nall your unused imports will be removed.\n\nIf you\'re using JSX, ImportJS will automatically import `React` for you.\n\n## Go to module\n\nSince ImportJS is pretty good at finding JS modules, it makes sense that\nthere\'s an option to open/go to a file rather than import it. This is similar\nto Vim\'s built in ["Open file under cursor"][vim open file]. Use it by placing\nthe cursor on a variable and hit `<leader>g` (Vim), `(M-x) import-js-goto`\n(Emacs), or choose "ImportJS: goto module" (Sublime).\n\n[vim open file]: http://vim.wikia.com/wiki/Open_file_under_cursor\n\n## Things to note\n\n- Only files ending in `.js\\*` and `.ts*` are considered when importing\n- As part of resolving imports, all imports will be sorted and placed into\n  groups. *Grouping and sorting can be disabled, see the `groupImports` and `sortImports` configuration\n  options. Comments and whitespace will be preserved if these are both disabled.*\n- You can speed up ImportJS by installing\n  [Watchman](https://facebook.github.io/watchman/). See [Speeding it\n  up!](#speeding-it-up) for more information.\n\n## Configuration\n\nImportJS is configured through a JavaScript file (`.importjs.js`).\n\nThe file needs to export a single object containing you configuration settings, like the\nexample below.\n\n```javascript\nmodule.exports = {\n    excludes: [\n        \'./react-components/**/test/**\'\n    ]\n    // continue with the rest of your settings...\n}\n```\n\nSave this file in the root folder of your project (e.g. where the package.json\nfile is found). You can also save it to the user home directory if you want to\nshare a global config between different projects.\n\nThe following configuration options are supported.\n\n- [`aliases`](#aliases)\n- [`declarationKeyword`](#declarationkeyword)\n- [`environments`](#environments)\n- [`excludes`](#excludes)\n- [`globals`](#globals)\n- [`groupImports`](#groupimports)\n- [`ignorePackagePrefixes`](#ignorepackageprefixes)\n- [`importDevDependencies`](#importdevdependencies)\n- [`importFunction`](#importfunction)\n- [`importStatementFormatter`](#importstatementformatter)\n- [`logLevel`](#loglevel)\n- [`maxLineLength`](#maxlinelength)\n- [`minimumVersion`](#minimumversion)\n- [`moduleNameFormatter`](#modulenameformatter)\n- [`namedExports`](#namedexports)\n- [`sortImports`](#sortimports)\n- [`stripFileExtensions`](#stripfileextensions)\n- [`danglingCommas`](#danglingcommas)\n- [`tab`](#tab)\n- [`useRelativePaths`](#userelativepaths)\n- [`mergableOptions`](#mergableoptions)\n\n### `excludes`\n\nDefine a list of glob patterns that match files and directories that you don\'t\nwant to include for importing.\n\n```javascript\nexcludes: [\n  \'./react-components/**/test/**\',\n]\n```\n\n### `aliases`\n\nSome variable names might not easily map to a file in the filesystem. For those,\nyou can add them to the `aliases` configuration.\n\n```javascript\naliases: {\n  $: \'third-party-libs/jquery\',\n  _: \'third-party-libs/underscore\',\n}\n```\n\nAliases can be made dynamic by using the `{filename}` string. This part of the\nalias will be replaced by the name of the file you are currently editing.\n\ne.g.\n\n```javascript\naliases: {\n  styles: \'./{filename}.scss\',\n}\n```\n\nwill for a file `foo/bar.js` result in\n\n```javascript\nimport styles from \'./bar.scss\';\n```\n\n### `environments`\n\nThis list of environments controls what core modules are available when\nimporting, and what variables are considered global by default. The supported\nvalues right now are\n\n- `[\'meteor\']` - make the core modules for [Meteor][Meteor]\n  available, and add a bunch of [meteor\n  globals](https://github.com/sindresorhus/globals/blob/38d9a0c/globals.json#L1116)\n- `[\'node\']` - make [all the core modules for Node][node core modules]\n  available, and add a bunch of [node\n  globals](https://github.com/sindresorhus/globals/blob/38d9a0c/globals.json#L848)\n- `[\'browser\']` - add a bunch of [browser\n  globals](https://github.com/sindresorhus/globals/blob/38d9a0c/globals.json#L162)\n- `[\'jasmine\']` - add a bunch of [jasmine\n  globals](https://github.com/sindresorhus/globals/blob/38d9a0c/globals.json#L901)\n- `[\'jest\']` - add a bunch of [jest\n  globals](https://github.com/sindresorhus/globals/blob/38d9a0c/globals.json#L921)\n- + a few more, as defined by https://github.com/sindresorhus/globals\n\n[Meteor]: https://meteor.com\n[Node core modules]: https://nodejs.org/api/modules.html#modules_core_modules\n\n```javascript\nenvironments: [\'meteor\', \'node\']\n```\n\n### `namedExports`\n\n*Note: Since 2.1.0 ImportJS finds your named exports automatically. Most\nlikely you don\'t need this option. If you end up having to use this\nconfiguration anyway, there might be a bug in the exports-finding parts of\nImportJS. [File an issue](https://github.com/Galooshi/import-js/issues) and\ntell us about it!\n\nIf you have an ES6/ES2015 module that exports multiple things (named exports),\nor a CommonJS module that exports an object with properties on it that you want\nto destructure when importing, you can add those to a `namedExports`\nconfiguration option.\n\n```javascript\nnamedExports: {\n  underscore: [\n    \'omit\',\n    \'debounce\',\n    \'memoize\'\n  ],\n  \'lib/utils\': [\n    \'escape\',\n    \'hasKey\',\n  ],\n}\n```\n\nImports that use the `import` declaration keyword then use [named imports\nsyntax][]. e.g.\n\n```javascript\nimport { memoize } from \'underscore\';\n\nmemoize(() => { foo() });\n```\n\nand imports that use `const` or `var` use [ES2015 Destructuring\nAssigment][destructing assignment], e.g.\n\n```javascript\nconst { memoize } = require(\'underscore\');\n\nmemoize(() => { foo() });\n```\n\n[named imports syntax]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import\n[destructuring assignment]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n\nThe key used to describe the named exports should be a valid import path. This\ncan be e.g. the name of a package found under `node_modules`, a path to a\nmodule you created yourself, or a relative import path.\n\n### `declarationKeyword`\n\nThe default value for this property is `import`, making your import statements\nuse the [ES2015 modules syntax][]:\n\n[ES2015 modules syntax]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import\n\n```javascript\nimport Foo from \'foo\';\n```\n\nIf you aren\'t ready for ES2015 yet, you have the option to use `var` or `const`\ninstead.\n\n```javascript\ndeclarationKeyword: \'const\'\n```\n\nIn such case, your import statements will look something like this:\n\n```javascript\nvar Foo = require(\'foo\'); // "declarationKeyword": "var"\nconst Foo = require(\'foo\'); // "declarationKeyword": "const"\n```\n\n### `globals`\n\nProvide a list of global identifiers used in the code. ImportJS will ignore\nthese when trying to import all undefined variables.\n\n*Note: If you use the [`environments`](#environments) configuration option\ncorrectly, you might not need to specify globals*.\n\n### `groupImports`\n\nBy default, ImportJS will put imports into groups:\n\n1. Core modules\n2. Package dependencies\n3. One or more groups with internal imports\n\nYou can turn off this behavior by setting `groupImports` to `false`. When\ndisabled, imports are listed alphabetically in one list.\n\n```javascript\ngroupImports: false\n```\n\n### `sortImports`\n\nBy default, ImportJS will sort imports by the name or path of the imported module.\n\nYou can turn off this behavior by setting `sortImports` to `false`. When\ndisabled, existing imports are not rearranged, and new imports are always added above existing imports.\n\n```javascript\nsortImports: false\n```\n\n### `emptyLineBetweenGroups`\n\nBy default, ImportJS will insert empty line between import groups.\n\nYou can turn off this behavior by setting `emptyLineBetweenGroups` to `false`.\n\n```javascript\nemptyLineBetweenGroups: false\n```\n\n### `importDevDependencies`\n\nImportJS will look for package dependencies listed in `package.json` when\nimporting. By default, only modules listed under `dependencies` and\n`peerDependencies` will be used. By setting `importDevDependencies` to\n`true`, `devDependencies` will also be taken into account.\n\n```javascript\nimportDevDependencies: true\n```\n\n### `danglingCommas`\n\nBy default, ImportJS will add trailing commas when constructing import statements with multiple named imports.\n\nYou can turn off this behavior by setting `danglingCommas` to `false`.\n\n```javascript\ndanglingCommas: false\n```\n\n### `importFunction`\n\n*Note: this only applies if you are using `var` or `const` as\n`declarationKeyword`.*\n\nThe default value for this configuration option is `"require"`, which is [the\nstandard CommonJS function name used for\nimporting](http://wiki.commonjs.org/wiki/Modules/1.1).\n\n```javascript\nimportFunction: \'myCustomRequireFunction\'\n```\n\n### `stripFileExtensions`\n\nAn array that controls what file extensions are stripped out from the resulting\nimport statement. The default configuration strips out `[".js", ".jsx", ".ts",\n".tsx"]`. Set to an empty array `[]` to avoid stripping out extensions.\n\n```javascript\nstripFileExtensions: [\'.web.js\', \'.js\']\n```\n\n### `useRelativePaths`\n\nThis option is enabled by default. When enabled, imports will be resolved\nrelative to the current file being edited.\n\n```javascript\nimport Foo from \'./foo\';\nimport Bar from \'../baz/bar\';\n```\n\nYou can disable this by setting it to false:\n\n```javascript\nuseRelativePaths: false\n```\n\nPackage dependencies (located in `node_modules`) will not be imported\nrelatively.\n\n### `ignorePackagePrefixes`\n\nIf you have package dependencies specified in `package.json` that are prefixed\nwith e.g. an organization name but want to be able to import these without the\npackage prefix, you can set the `ignorePackagePrefixes` configuration option.\n\n```javascript\nignorePackagePrefixes: [\'my-company-\']\n```\n\nWhen package dependencies are matched, these prefixes will be ignored. As an\nexample, a variable named `validator` would match a package named\n`my-company-validator`.\n\n### `minimumVersion`\n\nSetting `minimumVersion` will warn people who are running a version of\nImportJS that is older than what your `.importjs.js` configuration file\nrequires. If your plugin version is older than this value, you will be shown a\nwarning that encourages you to upgrade your plugin.\n\n```javascript\nminimumVersion: \'1.0.0\'\n```\n\n### `maxLineLength`\n\nDefaults to `80`. This setting controls when import statements are broken into\nmultiple lines.\n\n```javascript\nmaxLineLength: 70\n```\n\n### `moduleNameFormatter`\n\nUse a function here to control how the resulting module name string will look\nlike. It\'s useful if you for instance want to add a custom prefix to certain\nimports. Apart from the standard `pathToCurrentFile` and `pathToImportedModule`\nvalues passed in to all configuration functions, this method is also passed a\n`moduleName` value, which in general is what you want to manipulate.\n\n```javascript\nmoduleNameFormatter({ moduleName, pathToCurrentFile }) {\n if (/-test/.test(pathToCurrentFile)) {\n   // Import a mocked version in test files\n   return `mocks/${moduleName}`;\n }\n\n if (moduleName.startsWith(\'foo\')) {\n   // Add a leading slash to foo imports\n   return `/${moduleName}`;\n }\n\n // Fall back to the original specifier. It\'s important that this function\n // always returns a string.\n return moduleName;\n},\n```\n\n### `importStatementFormatter`\n\nUse a function here to control how the resulting import statement will look\nlike. This is useful if you for instance want to strip out trailing semicolons\n(that ImportJS adds by default).\n\nNote: this method should only be used in rare cases. There\'s a chance that\nImportJS won\'t be able to recognize the resulting import statement next time it\nis about to import something.\n\n```javascript\nimportStatementFormatter({ importStatement }) {\n  return importStatement.replace(/;$/, \'\');\n},\n```\n\n### `tab`\n\nDefaults to two spaces (`"  "`). This setting controls how indentation is\nconstructed when import statements are broken into multiple lines.\n\n```javascript\ntab: \'\\t\'\n```\n\n### `logLevel`\n\nOne of `["debug", "info", "warn", "error"]`. This controls what ends up in the\nlogfile. The default is `info`.\n\n```javascript\nlogLevel: \'debug\'\n```\n\nThe logfile is written to "importjs.log" in your operating system\'s default\ndirectory for temporary files. You can get the path to the log file by running\n`importjsd logpath`.\n\n### `mergableOptions`\n\nA dictionary of Options that be merged with defaults and values provided by an [`environment`](#environments). This can be used to overwrite options provided by environments. Defaults to:\n\n```javascript\nmergableOptions: {\n  aliases: true,\n  coreModules: true,\n  namedExports: true,\n  globals: true,\n}\n```\n\nNote: the `mergableOptions` option will always be merged and will be ignored if\nincluded in a user config.\n\nTo disable merging a particular option or set of options, set the key to\n`false`:\n\n```javascript\nmergableOptions: {\n  globals: false\n}\n```\n\nFor example, if you are using the `meteor` environment but want to explicitly\nimport modules which are provided as globals, you can use this setting to\noverwrite the environment globals.\n\n```javascript\nconst globals = require(\'globals\');\nmodule.exports = {\n  environments: [\'meteor\', \'node\'],\n  mergableOptions: {\n    globals: false // Overwrite globals\n  },\n  globals: [\n    // Add the globals you want back in\n    ...Object.keys(globals.builtin), // include javascript builtins\n    ...Object.keys(globals.node), // include node globals\n    \'Package\', \'Npm\' // Include meteor globals for `package.js` files\n  ]\n}\n```\n\n## Dynamic configuration\n\nDifferent sections of your application may have special importing needs. For\ninstance, your tests might need the `\'const\'` declaration keyword, but the rest\nof your application can use `\'import\'`. To be able to target these special\ncases, you can turn your configuration option into a function. When ImportJS\nresolves a configuration option, it will check to see if a function is used. In\nsuch case, the function is invoked with the following arguments:\n\n- `pathToCurrentFile`: (always available) A path to the file you are editing.\n- `pathToImportedModule` (not available for some options) A path to the\n  file/module you are importing.\n\nHere\'s an example of how to dynamically control the `declarationKeyword`\nconfiguration option based on the file you are importing:\n\n```javascript\n// .importjs.js\nfunction isTestFile(path) {\n  return path.endsWith(\'-test.js\');\n}\n\nmodule.exports = {\n  declarationKeyword({ pathToImportedModule }) {\n    if (isTestFile(pathToImportedModule)) {\n      return \'const\';\n    }\n    return \'import\';\n  },\n}\n```\n\nHere\'s a more elaborate example taking both `pathToImportedModule` and\n`pathToCurrentFile` into account:\n\n```javascript\nmodule.exports = {\n  useRelativePaths({ pathToImportedModule, pathToCurrentFile }) {\n    if (pathToCurrentFile.endsWith(\'-mock.js\')) {\n      return false;\n    }\n    if (pathToImportedModule.endsWith(\'-test.js\')) {\n      return false;\n    }\n    return true;\n  },\n}\n```\n\nIn order to use functions, you need to use the JavaScript configuration file\n(`.importjs.js`).\n\n## Command-line tool\n\nImportJS comes with a handy command-line tool that can help you perform\nimporting outside of an editor. Under the hood, this is what most of the editor\nintegrations use.\n\n```bash\n\xe2\xa8\xa0 importjs --help\n\n  Usage: importjs [options] [command]\n\n\n  Commands:\n\n    word [options] <word> <pathToFile>\n    search [options] <word> <pathToFile>\n    fix [options] <pathToFile>\n    rewrite [options] <pathToFile>\n    add [options] <imports> <pathToFile>\n    goto <word> <pathToFile>\n    start [options]                       start a daemon\n    cachepath                             show path to cache file\n    logpath                               show path to log file\n\n  Options:\n\n    -h, --help     output usage information\n    -V, --version  output the version number\n\n  Examples:\n\n    $ importjs word someModule path/to/file.js\n    $ importjs search someModule* path/to/file.js\n    $ importjs fix path/to/file.js\n    $ importjs rewrite --overwrite path/to/file.js\n    $ importjs add \'{ "foo": "path/to/foo", "bar": "path/to/bar" }\' path/to/file.js\n    $ importjs goto someModule path/to/file.js\n    $ importjs cachepath\n    $ importjs logpath\n    $ importjs start --parent-pid=12345\n```\n\n### Batch-rewriting\n\nIf you want to change how imports are constructed in an existing project, you\ncan use the command-line tool in combination with `find` to batch-update a set\nof files. E.g.\n\n```bash\nfind ./app -name "**.js*" -exec importjs rewrite --overwrite {} \\;\n```\n\nSince the `--overwrite` flag makes ImportJS destructive (files are overwritten),\nit\'s a good thing to double-check that the `find` command returns the right\nfiles before adding the `-exec` part.\n\n## Specifying alternate package directory\n\nImportJS looks for the `package.json` file in the closest ancestor directory for the file you\'re editing to find node modules to import. However, sometimes it might pull dependencies from a directory further up the chain. For example, your directory structure might look like this:\n\n```\n.\n|-- package.json\n|-- components\n|     |-- button.js\n|     |-- icon.js\n|-- node_modules\n|     |-- react\n|-- subpackage\n|     |-- package.json\n|     |-- components\n|           |-- bulletin.js\n```\n\nIf you were to use ImportJS on `subpackage/components/bulletin.js` which imports React, ImportJS would not know that `react` is a valid dependency.\n\nTo tell ImportJS to skip a directory and keep searching upwards to find the root package directory, specify `"importjs": { "isRoot": false }` in the `package.json` of the directory to ignore. In this case, you would want something like this:\n\n```json\n{\n  "name": "subpackage",\n  ...\n  "importjs": {\n    "isRoot": false\n  }\n}\n```\n\n## Running as a daemon\n\n*Note*: This section is intended mostly for developers of editor plugins. If\nyou are using one of the standard editor plugins, you are most likely using the\ndaemon under the hood already.\n\nYou can run ImportJS in a background process and communicate with it using\n`stdin` and `stdout`. This will make importing faster because we\'re not\nspinning up a node environment on every invocation.\n\nThe daemon is started by running running `importjsd`. It accepts commands sent\nvia `stdin`. Each command is a (oneline) JSON string ending with a newline. The\ncommand structure is basically the same as for the command-line tool, but\nwrapped in JSON instead of expressed on the command line. Here are a few\nexamples:\n\nRun `fix imports`:\n```json\n{\n  "command": "fix",\n  "fileContent": "const foo = bar();\\n",\n  "pathToFile": "foo.js",\n}\n```\n\nImport a single word:\n```json\n{\n  "command": "word",\n  "commandArg": "bar",\n  "fileContent": "const foo = bar();\\n",\n  "pathToFile": "foo.js",\n}\n```\n\nGoto:\n```json\n{\n  "command": "goto",\n  "commandArg": "bar",\n  "fileContent": "const foo = bar();\\n",\n  "pathToFile": "foo.js",\n}\n```\n\nResults are printed to `stdout` in JSON format. The response will look the same\nas what the command-line tool produces. If an error occurs, it will also end up\nin `stdout` as JSON (an object with an `error` key).\n\nOn startup, the daemon will print a path to a logfile. If you want to find out\nwhat\'s going on behind the scenes, you can inspect this file. If you don\'t have\naccess to the console log of the daemon, you\'ll find the logfile in\n`os.tmpdir() + \'/importjs.log` (which will resolve to something like\n`var/folders/1l/_t6tm7195nd53936tsvh2pcr0000gn/T/importjs.log` on a Mac).\n\n## Speeding it up!\n\nIf you have a large application, traversing the file system to find modules can\nbe slow. That\'s why ImportJS has built-in integration with\n[Watchman](https://facebook.github.io/watchman/), a fast and robust file\nwatching service developed by Facebook. All you have to do to get a performance\nboost is to [install watchman\nlocally](https://facebook.github.io/watchman/docs/install.html), and make sure\nto use an up-to-date editor plugin (Watchman is only used when ImportJS is run\nas a daemon).\n\n## Contributing\n\nSee the [CONTRIBUTING.md](CONTRIBUTING.md) document for tips on how to run, test\nand develop ImportJS locally.\n\n## Thank you:\n- @janpaul123 for writing the Sublime plugin.\n- @kevinkehl for getting the parentheses right for the Emacs plugin\n- @rhettlivingston for making import-js work for Meteor, and for driving the\n  development forward by bringing in lots of experience and great ideas.\n- @dabbott for writing the VS Code plugin.\n\nHappy hacking!\n'