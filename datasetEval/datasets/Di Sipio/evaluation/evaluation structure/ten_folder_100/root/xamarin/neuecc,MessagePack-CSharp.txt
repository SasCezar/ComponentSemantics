b'# MessagePack for C# (.NET, .NET Core, Unity, Xamarin)\n\n[![NuGet](https://img.shields.io/nuget/v/MessagePack.svg)](https://www.nuget.org/packages/messagepack)\n[![NuGet](https://img.shields.io/nuget/vpre/MessagePack.svg)](https://www.nuget.org/packages/messagepack)\n[![Releases](https://img.shields.io/github/release/neuecc/MessagePack-CSharp.svg)](https://github.com/neuecc/MessagePack-CSharp/releases)\n\n[![Join the chat at https://gitter.im/MessagePack-CSharp/Lobby](https://badges.gitter.im/MessagePack-CSharp/Lobby.svg)](https://gitter.im/MessagePack-CSharp/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Build Status](https://dev.azure.com/ils0086/MessagePack-CSharp/_apis/build/status/MessagePack-CSharp-CI)](https://dev.azure.com/ils0086/MessagePack-CSharp/_build/latest?definitionId=2)\n\nThe extremely fast [MessagePack](http://msgpack.org/) serializer for C#. It is 10x faster than [MsgPack-Cli](https://github.com/msgpack/msgpack-cli) and outperforms other C# serializers. MessagePack for C# also ships with built-in support for LZ4 compression - an extremely fast compression algorithm. Performance is important, particularly in applications like game development, distributed computing, microservice architecture, and caching.\n\n![Perf comparison graph](https://cloud.githubusercontent.com/assets/46207/23835716/89c8ab08-07af-11e7-9183-9e9415bdc87f.png)\n\nMessagePack has compact binary size and full set of general purpose expression. Please see the [comparison with JSON, protobuf, ZeroFormatter section](#comparison). Learn [why MessagePack C# is fastest](#performance).\n\n## Installation\n\nThis library is distributed via NuGet package and with special [support for Unity](#unity).\n\n### NuGet packages\n\nWe target .NET Standard 2.0 with special optimizations for .NET Core 2.1+.\n\n```ps1\nInstall-Package MessagePack\n```\n\nInstall the optional C# analyzer to get warnings for coding mistakes and code fixes to save you time:\n\n```ps1\nInstall-Package MessagePackAnalyzer\n```\n\nExtension Packages (learn more in our [extensions section](#extensions)):\n\n```ps1\nInstall-Package MessagePack.ImmutableCollection\nInstall-Package MessagePack.ReactiveProperty\nInstall-Package MessagePack.UnityShims\nInstall-Package MessagePack.AspNetCoreMvcFormatter\n```\n\n### Unity\n\nFor Unity, download from [releases](https://github.com/neuecc/MessagePack-CSharp/releases) page, providing `.unitypackage`. Unity IL2CPP or Xamarin AOT Environment, check the [pre-code generation section](#aot).\n\n### Migration notes from v1.x\n\nIf you were using MessagePack-CSharp v1.x, check out [how to update to our new v2.x version](doc/migration.md).\n\n## Quick Start\n\nDefine the class to be serialized and attribute the class with `[MessagePackObject]`.\nAttribute public members (property or field) with `[Key]`.\n\n```csharp\n[MessagePackObject]\npublic class MyClass\n{\n    // Key is serialization index, it is important for versioning.\n    [Key(0)]\n    public int Age { get; set; }\n\n    [Key(1)]\n    public string FirstName { get; set; }\n\n    [Key(2)]\n    public string LastName { get; set; }\n\n    // public members and does not serialize target, mark IgnoreMemberttribute\n    [IgnoreMember]\n    public string FullName { get { return FirstName + LastName; } }\n}\n```\n\nCall `MessagePackSerializer.Serialize<T>/Deserialize<T>` to serialize/deserialize your object graph.\nYou can also use the `ConvertToJson` method to see a human readable representation of the msgpack that was written.\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var mc = new MyClass\n        {\n            Age = 99,\n            FirstName = "hoge",\n            LastName = "huga",\n        };\n\n        // call Serialize/Deserialize, that\'s all.\n        byte[] bytes = MessagePackSerializer.Serialize(mc);\n        MyClass mc2 = MessagePackSerializer.Deserialize<MyClass>(bytes);\n\n        // you can dump msgpack binary to human readable json.\n        // In default, MeesagePack for C# reduce property name information.\n        // [99,"hoge","huga"]\n        var json = MessagePackSerializer.ConvertToJson(bytes);\n        Console.WriteLine(json);\n    }\n}\n```\n\nBy default the attribute is required. Optionally it can be unnecessary, see [Object Serialization section](#object-serialization) and [Formatter Resolver section](#resolvers) for details.\n\n## Analyzer\n\nThe MessagePackAnalyzer helps to:\n\n1. Automate defining your serializable objects.\n1. Produces compiler warnings due to incorrect attribute use, accessibility, and more.\n\n![analyzergif](https://cloud.githubusercontent.com/assets/46207/23837445/ce734eae-07cb-11e7-9758-d69f0f095bc1.gif)\n\nIf you want to allow a specific type (for example, when registering a custom type), put `MessagePackAnalyzer.json` at the project root and make the Build Action to `AdditionalFiles`.\n\n![image](https://cloud.githubusercontent.com/assets/46207/23837427/8a8d507c-07cb-11e7-9277-5a566eb0bfde.png)\n\nThis is a sample of the contents of `MessagePackAnalyzer.json`:\n\n```json\n[ "MyNamespace.FooClass", "MyNameSpace.BarStruct" ]\n```\n\n## Built-in support types\n\nThese types can serialize by default.\n\nPrimitives(`int`, `string`, etc...), `Enum`, `Nullable<>`,  `TimeSpan`,  `DateTime`, `DateTimeOffset`, `Nil`, `Guid`, `Uri`, `Version`, `StringBuilder`, `BitArray`, `ArraySegment<>`, `BigInteger`, `Complex`, `Array[]`, `Array[,]`, `Array[,,]`, `Array[,,,]`, `KeyValuePair<,>`, `Tuple<,...>`, `ValueTuple<,...>`, `List<>`, `LinkedList<>`, `Queue<>`, `Stack<>`, `HashSet<>`, `ReadOnlyCollection<>`, `IList<>`, `ICollection<>`, `IEnumerable<>`, `Dictionary<,>`, `IDictionary<,>`, `SortedDictionary<,>`, `SortedList<,>`, `ILookup<,>`, `IGrouping<,>`, `ObservableCollection<>`, `ReadOnlyOnservableCollection<>`, `IReadOnlyList<>`, `IReadOnlyCollection<>`, `ISet<>`, `ConcurrentBag<>`, `ConcurrentQueue<>`, `ConcurrentStack<>`, `ReadOnlyDictionary<,>`, `IReadOnlyDictionary<,>`, `ConcurrentDictionary<,>`, `Lazy<>`, custom inherited `ICollection<>` or `IDictionary<,>` with paramterless constructor, `IList`, `IDictionary` and custom inherited `ICollection` or `IDictionary` with paramterless constructor(includes `ArrayList` and `Hashtable`).\n\nYou can add custom type support and has some official/third-party extension package. for ImmutableCollections(`ImmutableList<>`, etc), for ReactiveProperty and for Unity(`Vector3`, `Quaternion`, etc...), for F#(Record, FsList, Discriminated Unions, etc...). Please see [extensions section](https://github.com/neuecc/MessagePack-CSharp#extensions).\n\n`MessagePack.Nil` is built-in null/void/unit representation type of MessagePack for C#.\n\n## Object Serialization\n\nMessagePack for C# can serialize your own public `Class` or `Struct`. Serialization target must marks `[MessagePackObject]` and `[Key]`. Key type can choose int or string. If key type is int, serialized format is used array. If key type is string, serialized format is used map. If you define `[MessagePackObject(keyAsPropertyName: true)]`, does not require `KeyAttribute`.\n\n```csharp\n[MessagePackObject]\npublic class Sample1\n{\n    [Key(0)]\n    public int Foo { get; set; }\n    [Key(1)]\n    public int Bar { get; set; }\n}\n\n[MessagePackObject]\npublic class Sample2\n{\n    [Key("foo")]\n    public int Foo { get; set; }\n    [Key("bar")]\n    public int Bar { get; set; }\n}\n\n[MessagePackObject(keyAsPropertyName: true)]\npublic class Sample3\n{\n    // no needs KeyAttribute\n    public int Foo { get; set; }\n\n    // If ignore public member, you can use IgnoreMemberAttribute\n    [IgnoreMember]\n    public int Bar { get; set; }\n}\n\n// [10,20]\nConsole.WriteLine(MessagePackSerializer.ToJson(new Sample1 { Foo = 10, Bar = 20 }));\n\n// {"foo":10,"bar":20}\nConsole.WriteLine(MessagePackSerializer.ToJson(new Sample2 { Foo = 10, Bar = 20 }));\n\n// {"Foo":10}\nConsole.WriteLine(MessagePackSerializer.ToJson(new Sample3 { Foo = 10, Bar = 20 }));\n```\n\nAll patterns serialization target are public instance member(field or property). If you want to avoid serialization target, you can add `[IgnoreMember]` to target member.\n\n> target class must be public, does not allows private, internal class.\n\nWhich should uses int key or string key? I recommend use int key because faster and compact than string key. But string key has key name information, it is useful for debugging.\n\nMessagePackSerializer requests target must put attribute is for robustness. If class is grown, you need to be conscious of versioning. MessagePackSerializer uses default value if key does not exists. If uses int key, should be start from 0 and should be sequential. If unnecessary properties come out, please make a missing number. Reuse is bad. Also, if Int Key\'s jump number is too large, it affects binary size.\n\n```csharp\n[MessagePackObject]\npublic class IntKeySample\n{\n    [Key(3)]\n    public int A { get; set; }\n    [Key(10)]\n    public int B { get; set; }\n}\n\n// [null,null,null,0,null,null,null,null,null,null,0]\nConsole.WriteLine(MessagePackSerializer.ToJson(new IntKeySample()));\n```\n\nI want to use like JSON.NET! I don\'t want to put attribute! If you think that way, you can use a contractless resolver.\n\n```csharp\npublic class ContractlessSample\n{\n    public int MyProperty1 { get; set; }\n    public int MyProperty2 { get; set; }\n}\n\nvar data = new ContractlessSample { MyProperty1 = 99, MyProperty2 = 9999 };\nvar bin = MessagePackSerializer.Serialize(data, MessagePack.Resolvers.ContractlessStandardResolver.Instance);\n\n// {"MyProperty1":99,"MyProperty2":9999}\nConsole.WriteLine(MessagePackSerializer.ToJson(bin));\n\n// You can set ContractlessStandardResolver as default.\nMessagePackSerializer.SetDefaultResolver(MessagePack.Resolvers.ContractlessStandardResolver.Instance);\n\n// serializable.\nvar bin2 = MessagePackSerializer.Serialize(data);\n```\n\nI want to serialize private member! In default, can not serialize/deserialize private members. But you can use allow-private resolver.\n\n```csharp\n[MessagePackObject]\npublic class PrivateSample\n{\n    [Key(0)]\n    int x;\n\n    public void SetX(int v)\n    {\n        x = v;\n    }\n\n    public int GetX()\n    {\n        return x;\n    }\n}\n\nvar data = new PrivateSample();\ndata.SetX(9999);\n\n// You can choose StandardResolverAllowPrivate or  ContractlessStandardResolverAllowPrivate\nvar bin = MessagePackSerializer.Serialize(data, MessagePack.Resolvers.DynamicObjectResolverAllowPrivate.Instance);\n```\n\nI don\'t need type, I want to use like BinaryFormatter! You can use as typeless resolver and helpers. Please see [Typeless section](https://github.com/neuecc/MessagePack-CSharp#typeless).\n\nResolver is key customize point of MessagePack for C#. Details, please see [extension point](https://github.com/neuecc/MessagePack-CSharp#extension-point-iformatterresolver).\n\n## DataContract compatibility\n\nYou can use `[DataContract]` instead of `[MessagePackObject]`. If type is marked DataContract, you can use `[DataMember]` instead of `[Key]` and `[IgnoreDataMember]` instead of `[IgnoreMember]`.\n\n`[DataMember(Order = int)]` is same as `[Key(int)]`, `[DataMember(Name = string)]` is same as `[Key(string)]`. If use `[DataMember]`, same as `[Key(nameof(propertyname)]`.\n\nUsing DataContract makes it a shared class library and you do not have to refer to MessagePack for C#. However, it is not included in analysis by Analyzer or code generation by `mpc.exe`. Also, functions like `UnionAttribute`, `MessagePackFormatterAttribute`, `SerializationConstructorAttribute` etc can not be used. For this reason, I recommend that you use the MessagePack for C# attribute basically.\n\n## Serialize ImmutableObject (SerializationConstructor)\n\nMessagePack for C# supports deserialize immutable object. For example, this struct can serialize/deserialize naturally.\n\n```csharp\n[MessagePackObject]\npublic struct Point\n{\n    [Key(0)]\n    public readonly int X;\n    [Key(1)]\n    public readonly int Y;\n\n    public Point(int x, int y)\n    {\n        this.X = x;\n        this.Y = y;\n    }\n}\n\nvar data = new Point(99, 9999);\nvar bin = MessagePackSerializer.Serialize(data);\n\n// Okay to deserialize immutable obejct\nvar point = MessagePackSerializer.Deserialize<Point>(bin);\n```\n\nMessagePackSerializer choose constructor with the most matched argument, match index if key in integer or match name(ignore case) if key is string. If encounts `MessagePackDynamicObjectResolverException: can\'t find matched constructor parameter` you should check about this.\n\nIf can not match automatically, you can specify to use constructor manually by `[SerializationConstructorAttribute]`.\n\n```csharp\n[MessagePackObject]\npublic struct Point\n{\n    [Key(0)]\n    public readonly int X;\n    [Key(1)]\n    public readonly int Y;\n\n    [SerializationConstructor]\n    public Point(int x)\n    {\n        this.X = x;\n        this.Y = -1;\n    }\n\n    // If not marked attribute, used this(most matched argument)\n    public Point(int x, int y)\n    {\n        this.X = x;\n        this.Y = y;\n    }\n}\n```\n\n## Serialization Callback\n\nIf object implements `IMessagePackSerializationCallbackReceiver`, received `OnBeforeSerialize` and `OnAfterDeserialize` on serilization process.\n\n```csharp\n[MessagePackObject]\npublic class SampleCallback : IMessagePackSerializationCallbackReceiver\n{\n    [Key(0)]\n    public int Key { get; set; }\n\n    public void OnBeforeSerialize()\n    {\n        Console.WriteLine("OnBefore");\n    }\n\n    public void OnAfterDeserialize()\n    {\n        Console.WriteLine("OnAfter");\n    }\n}\n```\n\n## Union\n\nMessagePack for C# supports serialize interface. It is like `XmlInclude` or `ProtoInclude`. MessagePack for C# there called *Union*. `UnionAttribute` can only attach to interface or abstract class. It requires discriminated integer key and sub-type.\n\n```csharp\n// mark inheritance types\n[MessagePack.Union(0, typeof(FooClass))]\n[MessagePack.Union(1, typeof(BarClass))]\npublic interface IUnionSample\n{\n}\n\n[MessagePackObject]\npublic class FooClass : IUnionSample\n{\n    [Key(0)]\n    public int XYZ { get; set; }\n}\n\n[MessagePackObject]\npublic class BarClass : IUnionSample\n{\n    [Key(0)]\n    public string OPQ { get; set; }\n}\n\n// ---\n\nIUnionSample data = new FooClass() { XYZ = 999 };\n\n// serialize interface.\nvar bin = MessagePackSerializer.Serialize(data);\n\n// deserialize interface.\nvar reData = MessagePackSerializer.Deserialize<IUnionSample>(bin);\n\n// use type-switch of C# 7.0\nswitch (reData)\n{\n    case FooClass x:\n        Console.WriteLine(x.XYZ);\n        break;\n    case BarClass x:\n        Console.WriteLine(x.OPQ);\n        break;\n    default:\n        break;\n}\n```\n\nC# 7.0 type-switch is best match for Union. Union is serialized to two-length array.\n\n```csharp\nIUnionSample data = new BarClass { OPQ = "FooBar" };\n\nvar bin = MessagePackSerializer.Serialize(data);\n\n// Union is serialized to two-length array, [key, object]\n// [1,["FooBar"]]\nConsole.WriteLine(MessagePackSerializer.ToJson(bin));\n```\n\nUsing Union in Abstract Class, you can use same of interface.\n\n```csharp\n[Union(0, typeof(SubUnionType1))]\n[Union(1, typeof(SubUnionType2))]\n[MessagePackObject]\npublic abstract class ParentUnionType\n{\n    [Key(0)]\n    public int MyProperty { get; set; }\n}\n\n[MessagePackObject]\npublic class SubUnionType1 : ParentUnionType\n{\n    [Key(1)]\n    public int MyProperty1 { get; set; }\n}\n\n[MessagePackObject]\npublic class SubUnionType2 : ParentUnionType\n{\n    [Key(1)]\n    public int MyProperty2 { get; set; }\n}\n```\n\nSerialization of inherited type, flatten in array(or map), be carefult to integer key, it cannot duplicate parent and all childrens.\n\n## Dynamic (Untyped) Deserialization\n\nIf use `MessagePackSerializer.Deserialize<object>` or `MessagePackSerializer.Deserialize<dynamic>`, convert messagepack binary to primitive values that convert from msgpack-primitive to `bool`, `char`, `sbyte`, `byte`, `short`, `int`, `long`, `ushort`, `uint`, `ulong`, `float`, `double`, `DateTime`, `string`, `byte[]`, `object[]`, `IDictionary<object, object>`.\n\n```csharp\n// sample binary.\nvar model = new DynamicModel { Name = "foobar", Items = new[] { 1, 10, 100, 1000 } };\nvar bin = MessagePackSerializer.Serialize(model, ContractlessStandardResolver.Instance);\n\n// dynamic, untyped\nvar dynamicModel = MessagePackSerializer.Deserialize<dynamic>(bin, ContractlessStandardResolver.Instance);\n\nConsole.WriteLine(dynamicModel["Name"]); // foobar\nConsole.WriteLine(dynamicModel["Items"][2]); // 100\n```\n\nSo you can access indexer for msgpack map and array.\n\n## Object Type Serialization\n\n`StandardResolver` and `ContractlessStandardResolver` can serialize `object` type as concrete type by `DynamicObjectTypeFallbackResolver`.\n\n```csharp\nvar objects = new object[] { 1, "aaa", new ObjectFieldType { Anything = 9999 } };\nvar bin = MessagePackSerializer.Serialize(objects);\n\n// [1,"aaa",[9999]]\nConsole.WriteLine(MessagePackSerializer.ToJson(bin));\n\n// Support Anonymous Type Serialize\nvar anonType = new { Foo = 100, Bar = "foobar" };\nvar bin2 = MessagePackSerializer.Serialize(anonType, MessagePack.Resolvers.ContractlessStandardResolver.Instance);\n\n// {"Foo":100,"Bar":"foobar"}\nConsole.WriteLine(MessagePackSerializer.ToJson(bin2));\n```\n\n> Unity supports is limited.\n\nWhen deserializing, same as Dynamic(Untyped) Deserialization.\n\n## Typeless\n\nTypeless API is like `BinaryFormatter`, embed type information to binary so no needs type to deserialize.\n\n```csharp\nobject mc = new Sandbox.MyClass()\n{\n    Age = 10,\n    FirstName = "hoge",\n    LastName = "huga"\n};\n\n// serialize to typeless\nvar bin = MessagePackSerializer.Typeless.Serialize(mc);\n\n// binary data is embeded type-assembly information.\n// ["Sandbox.MyClass, Sandbox",10,"hoge","huga"]\nConsole.WriteLine(MessagePackSerializer.ToJson(bin));\n\n// can deserialize to MyClass with typeless\nvar objModel = MessagePackSerializer.Typeless.Deserialize(bin) as MyClass;\n```\n\nType information is serialized by mspgack `ext` format, typecode is 100.\n\n`MessagePackSerializer.Typeless` is shortcut of `Serialize/Deserialize<object>(TypelessContractlessStandardResolver.Instance)`. If you want to configure default typeless resolver, you can set by `MessagePackSerializer.Typeless.RegisterDefaultResolver`.\n\nTypelessFormatter can use standalone and combinate with existing resolvers.\n\n```csharp\n// replace `object` uses typeless\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    new[] { MessagePack.Formatters.TypelessFormatter.Instance },\n    new[] { MessagePack.Resolvers.StandardResolver.Instance });\n\npublic class Foo\n{\n    // use Typeless(this field only)\n    [MessagePackFormatter(typeof(TypelessFormatter))]\n    public object Bar;\n}\n```\n\nIf type name was changed, can not deserialize. If you need to typename fallback, you can use `TypelessFormatter.BindToType`.\n\n```csharp\nMessagePack.Formatters.TypelessFormatter.BindToType = typeName =>\n{\n    if (typeName.StartsWith("SomeNamespace"))\n    {\n        typeName = typeName.Replace("SomeNamespace", "AnotherNamespace");\n    }\n\n    return Type.GetType(typeName, false);\n};\n```\n\n## Performance\n\nBenchmarks comparing to other serializers run on `Windows 10 Pro x64 Intel Core i7-6700K 4.00GHz, 32GB RAM`. Benchmark code is [here](https://github.com/neuecc/ZeroFormatter/tree/master/sandbox/PerformanceComparison) - and there [version info](https://github.com/neuecc/ZeroFormatter/blob/bc63cb925d/sandbox/PerformanceComparison/packages.config), ZeroFormatter and [FlatBuffers](https://google.github.io/flatbuffers/) has infinitely fast deserializer so ignore deserialize performance.\n\n![image](https://cloud.githubusercontent.com/assets/46207/23835765/55fe494e-07b0-11e7-98be-5e7a9411da40.png)\n\n MessagePack for C# uses many techniques for improve performance.\n\n* Serializer uses only `IBufferWriter<byte>` rather than `System.IO.Stream` for reduced overhead.\n* Buffers are rented from pools to reduce allocations, keeping throughput high through reduced GC pressure.\n* Don\'t create intermediate utility instance(XxxWriter/Reader, XxxContext, etc...)\n* Utilize dynamic code generation to avoid boxing value types. Use AOT generation on platforms that prohibit JIT.\n* Getting cached generated formatter on static generic field (don\'t use dictinary-cache because dictionary lookup is overhead). See [Resolvers](https://github.com/neuecc/MessagePack-CSharp/tree/209f301e2e595ed366408624011ba2e856d23429/src/MessagePack/Resolvers)\n* Heavily tuned dynamic IL code generation to avoid boxing value types. See [DynamicObjectTypeBuilder](https://github.com/neuecc/MessagePack-CSharp/blob/209f301e2e595ed366408624011ba2e856d23429/src/MessagePack/Resolvers/DynamicObjectResolver.cs#L142-L754).\nUse AOT generation on platforms that prohibit JIT.\n* Call PrimitiveAPI directly when il code generation knows target is primitive\n* Reduce branch of variable length format when il code generation knows target(integer/string) range\n* Don\'t use `IEnumerable<T>` abstraction on iterate collection, [see:CollectionFormatterBase](https://github.com/neuecc/MessagePack-CSharp/blob/209f301e2e595ed366408624011ba2e856d23429/src/MessagePack/Formatters/CollectionFormatter.cs#L192-L355) and inherited collection formatters\n* Uses pre generated lookup table to reduce check messagepack type, [see: MessagePackBinary](https://github.com/neuecc/MessagePack-CSharp/blob/209f301e2e595ed366408624011ba2e856d23429/src/MessagePack/MessagePackBinary.cs#L15-L212)\n* Uses optimized type key dictionary for non-generic methods, [see: ThreadsafeTypeKeyHashTable](https://github.com/neuecc/MessagePack-CSharp/blob/91312921cb7fe987f48336768c898a76ac7dbb40/src/MessagePack/Internal/ThreadsafeTypeKeyHashTable.cs)\n* Avoid string key decode for lookup map(string key) key and uses automata based name lookup with il inlining code generation, see: [AutomataDictionary](https://github.com/neuecc/MessagePack-CSharp/blob/bcedbce3fd98cb294210d6b4a22bdc4c75ccd916/src/MessagePack/Internal/AutomataDictionary.cs)\n* For string key encode, pre-generated member name bytes and use fixed sized binary copy in IL, see: [UnsafeMemory.cs](https://github.com/neuecc/MessagePack-CSharp/blob/f17ddc5d107d3a2f66f60398b214ef87919ff892/src/MessagePack/Internal/UnsafeMemory.cs)\n\nBefore creating this library, I implemented a fast fast serializer with [ZeroFormatter#Performance](https://github.com/neuecc/ZeroFormatter#performance). And this is a further evolved implementation. MessagePack for C# is always fast, optimized for all types(primitive, small struct, large object, any collections).\n\n### Deserialize Performance per options\n\nPerformance varies depending on options. This is a micro benchamark with [BenchmarkDotNet](https://github.com/dotnet/BenchmarkDotNet). Target object has 9 members(`MyProperty1` ~ `MyProperty9`), value are zero.\n\n |              Method |        Mean | Error | Scaled |  Gen 0 | Allocated |\n |-------------------- |------------:|------:|-------:|-------:|----------:|\n |              IntKey |    72.67 ns |    NA |   1.00 | 0.0132 |      56 B |\n |           StringKey |   217.95 ns |    NA |   3.00 | 0.0131 |      56 B |\n |     Typeless_IntKey |   176.71 ns |    NA |   2.43 | 0.0131 |      56 B |\n |  Typeless_StringKey |   378.64 ns |    NA |   5.21 | 0.0129 |      56 B |\n |       MsgPackCliMap | 1,355.26 ns |    NA |  18.65 | 0.1431 |     608 B |\n |     MsgPackCliArray |   455.28 ns |    NA |   6.26 | 0.0415 |     176 B |\n |         ProtobufNet |   265.85 ns |    NA |   3.66 | 0.0319 |     136 B |\n |            Hyperion |   366.47 ns |    NA |   5.04 | 0.0949 |     400 B |\n |       JsonNetString | 2,783.39 ns |    NA |  38.30 | 0.6790 |    2864 B |\n | JsonNetStreamReader | 3,297.90 ns |    NA |  45.38 | 1.4267 |    6000 B |\n |           JilString |   553.65 ns |    NA |   7.62 | 0.0362 |     152 B |\n |     JilStreamReader | 1,408.46 ns |    NA |  19.38 | 0.8450 |    3552 B |\n\nIntKey, StringKey, Typeless_IntKey, Typeless_StringKey are MessagePack for C# options. All MessagePack for C# options achive zero memory allocation on deserialization process. JsonNetString/JilString is deserialized from string. JsonNetStreamReader/JilStreamReader is deserialized from UTF8 byte[] with StreamReader. Deserialization is normally read from Stream. Thus, it will be restored from byte[](or Stream) instead of string.\n\nMessagePack for C# IntKey is fastest. StringKey is slower than IntKey because matching from the character string is required. If IntKey, read array length, for(array length) { binary decode }. If StringKey, read map length, for(map length) { decode key, lookup by key, binary decode } so requires additional two steps(decode key and lookup by key).\n\nString key is often useful, contractless, simple replacement of JSON, interoperability with other languages, and more certain versioning. MessagePack for C# is also optimized for String Key. First of all, it do not decode UTF8 byte[] to String for matching with the member name, it will look up the byte[] as it is(avoid decode cost and extra allocation).\n\nAnd It will try to match each `long type` (per 8 character, if it is not enough, pad with 0) using [automata](https://en.wikipedia.org/wiki/Automata_theory) and inline it when IL code generating.\n\n![image](https://user-images.githubusercontent.com/46207/29754771-216b40e2-8bc7-11e7-8310-1c3602e80a08.png)\n\nThis also avoids calculating the hash code of byte[], and the comparison can be made several times on a long unit.\n\nThis is the sample decompile of generated deserializer code by [ILSpy](http://ilspy.net/).\n\n![image](https://user-images.githubusercontent.com/46207/29754804-b5ba0f44-8bc7-11e7-9f6b-0c8f3c041237.png)\n\nIf the number of nodes is large, search with a embedded binary search.\n\nExtra note, this is serialize benchmark result.\n\n |              Method |        Mean | Error | Scaled |  Gen 0 | Allocated |\n |-------------------- |------------:|------:|-------:|-------:|----------:|\n |              IntKey |    84.11 ns |    NA |   1.00 | 0.0094 |      40 B |\n |           StringKey |   126.75 ns |    NA |   1.51 | 0.0341 |     144 B |\n |     Typeless_IntKey |   183.31 ns |    NA |   2.18 | 0.0265 |     112 B |\n |  Typeless_StringKey |   193.95 ns |    NA |   2.31 | 0.0513 |     216 B |\n |       MsgPackCliMap |   967.68 ns |    NA |  11.51 | 0.1297 |     552 B |\n |     MsgPackCliArray |   284.20 ns |    NA |   3.38 | 0.1006 |     424 B |\n |         ProtobufNet |   176.43 ns |    NA |   2.10 | 0.0665 |     280 B |\n |            Hyperion |   280.14 ns |    NA |   3.33 | 0.1674 |     704 B |\n |       ZeroFormatter |   149.95 ns |    NA |   1.78 | 0.1009 |     424 B |\n |       JsonNetString | 1,432.55 ns |    NA |  17.03 | 0.4616 |    1944 B |\n | JsonNetStreamWriter | 1,775.72 ns |    NA |  21.11 | 1.5526 |    6522 B |\n |           JilString |   547.51 ns |    NA |   6.51 | 0.3481 |    1464 B |\n |     JilStreamWriter |   778.78 ns |    NA |   9.26 | 1.4448 |    6066 B |\n\n Of course, IntKey is fastest but StringKey also good.\n\n## LZ4 Compression\n\nMessagePack is a fast and *compact* format but it is not compression. [LZ4](https://github.com/lz4/lz4) is extremely fast compression algorithm, with MessagePack for C# can achive extremely fast perfrormance and extremely compact binary size!\n\nMessagePack for C# has built-in LZ4 support. You can use `MessagePackSerializerOptions.LZ4Standard` instead of `MessagePackSerializerOptions.Standard`. Builtin support is special, I\'ve created serialize-compression pipeline and special tuned for the pipeline so share the working memory, don\'t allocate, don\'t resize until finished.\n\nSerialized binary is not simply compressed lz4 binary. Serialized binary is valid MessagePack binary used ext-format and custom typecode(99).\n\n```csharp\nvar array= Enumerable.Range(1, 100).Select(x => new MyClass { Age = 5, FirstName = "foo", LastName = "bar" }).ToArray();\n\n// call MessagePackSerializerOptions.LZ4Standard instead of default\nvar lz4Bytes = MessagePackSerializer.Serialize(array, MessagePackSerializerOptions.LZ4Standard);\nvar mc2 = MessagePackSerializer.Deserialize<MyClass[]>(lz4Bytes, MessagePackSerializerOptions.LZ4Standard);\n\n// you can dump lz4 message pack\n// [[5,"hoge","huga"],[5,"hoge","huga"],....]\nvar json = MessagePackSerializer.ConvertToJson(lz4Bytes, MessagePackSerializerOptions.LZ4Standard);\nConsole.WriteLine(json);\n\n// lz4Bytes is valid MessagePack, it is using ext-format( [TypeCode:99, SourceLength|CompressedBinary] )\n// [99,"0gAAA+vf3ABkkwWjZm9vo2JhcgoA////yVBvo2Jhcg=="]\nvar rawJson = MessagePackSerializer.ConvertToJson(lz4Bytes);\nConsole.WriteLine(rawJson);\n```\n\nBuilt-in LZ4 support uses primitive LZ4 API(LZ4 Block Format). The LZ4 API is more efficient if you know the size of original source length. Therefore, size is written as a header to the extension payload as a msgpack Int32 value. To decompress with a different LZ4 implementation you may need to read or manually seek past this length header.\n\nIf target binary size under 64 bytes, LZ4MessagePackSerializer does not compress to optimize small size serialization.\n\n### Attributions\n\nlz4 compression support is using Milosz Krajewski\'s [lz4net](https://github.com/MiloszKrajewski/lz4net) code with some modified.\n\n## <a name="comparison"></a>Compare with protobuf, JSON, ZeroFormatter\n\n[protbuf-net](https://github.com/mgravell/protobuf-net) is major, most used binary-format library on .NET. I love protobuf-net and respect that great work. But if uses protobuf-net for general-purpose serialization format, you may encounts annoying issue.\n\n```csharp\n[ProtoContract]\npublic class Parent\n{\n    [ProtoMember(1)]\n    public int Primitive { get; set; }\n    [ProtoMember(2)]\n    public Child Prop { get; set; }\n    [ProtoMember(3)]\n    public int[] Array { get; set; }\n}\n\n[ProtoContract]\npublic class Child\n{\n    [ProtoMember(1)]\n    public int Number { get; set; }\n}\n\nusing (var ms = new MemoryStream())\n{\n    // serialize null.\n    ProtoBuf.Serializer.Serialize<Parent>(ms, null);\n\n    ms.Position = 0;\n    var result = ProtoBuf.Serializer.Deserialize<Parent>(ms);\n\n    Console.WriteLine(result != null); // True, not null. but all property are zero formatted.\n    Console.WriteLine(result.Primitive); // 0\n    Console.WriteLine(result.Prop); // null\n    Console.WriteLine(result.Array); // null\n}\n\nusing (var ms = new MemoryStream())\n{\n    // serialize empty array.\n    ProtoBuf.Serializer.Serialize<Parent>(ms, new Parent { Array = new int[0] });\n\n    ms.Position = 0;\n    var result = ProtoBuf.Serializer.Deserialize<Parent>(ms);\n\n    Console.WriteLine(result.Array == null); // True, null!\n}\n```\n\nprotobuf(-net) can not handle null and empty collection correctly. Because protobuf has no `null` representation( [this](http://stackoverflow.com/questions/21631428/protobuf-net-deserializes-empty-collection-to-null-when-the-collection-is-a-prop) is the protobuf-net authors answer).\n\n[MessagePack specification](https://github.com/msgpack/msgpack/blob/master/spec.md) can completely serialize C# type system. This is the reason to recommend MessagePack over protobuf.\n\nProtocol Buffers has good IDL and [gRPC](http://www.grpc.io/), that is a much good point than MessagePack. If you want to use IDL, I recommend [Google.Protobuf](https://github.com/google/protobuf/tree/master/csharp/src/Google.Protobuf) than MessagePack.\n\nJSON is good general-purpose format. It is perfect, simple and enough spec. [Utf8Json](https://github.com/neuecc/Utf8Json) which created me that adopts same architecture as MessagePack for C# and avoid encoding/decoing cost so work like binary. If you want to know about binary vs text, see [Utf8Json/which serializer should be used](https://github.com/neuecc/Utf8Json#which-serializer-should-be-used) section.\n\n[ZeroFormatter](https://github.com/neuecc/ZeroFormatter/) is similar as [FlatBuffers](https://google.github.io/flatbuffers/) but specialized to C#. It is special. Deserialization is infinitely fast but instead the binary size is large. And ZeroFormatter\'s caching algorithm requires additional memory.\n\nFor many common uses, MessagePack for C# would be better.\n\n## Hint to achieve maximum performance to use MessagePack-CSharp\n\nMessagePack for C# prioritizes maximize performance by default. However, there are also default options that sacrifice max performance for convenience.\n\n### Use IntKey instead of StringKey(Contractless)\n\nIn [Deserialize Performance per options](https://github.com/neuecc/MessagePack-CSharp#deserialize-performance-per-options) sections shows the result of IntKey vs StringKey. IntKey serializes object-graph as msgpack-array format. StringKey serializes object-graph as msgpack-map format.\n\nFor example this type is serialized to\n\n```csharp\n[MessagePackObject]\npublic class Person\n{\n    [Key(0)] or [Key("name")]\n    public string Name { get; set;}\n    [Key(1)] or [Key("age")]\n    public int Age { get; set;}\n}\n\nnew Person { Name = "foobar", Age = 999 }\n```\n\nIntKey: `["foobar", 999]`, MapKey: `{"name:"foobar","age":999}`. IntKey is always fast in both serialize and deserialize because does not handle map key name, and always has the smallest binary size.\n\nStringKey is often useful, contractless, simple replacement of JSON, interoperability with other languages, and more certain versioning. But to achieve maximum performance, use IntKey.\n\n### Create own custom composite resolver\n\n`CompositeResolver.Create` is easy way to create combine resolvers. But formatter lookup has some overhead. If you create custom resolver (or use `StaticCompositeResolver.Instance`), you can avoid overhead.\n\n```csharp\npublic class MyApplicationResolver : IFormatterResolver\n{\n    public static readonly IFormatterResolver Instance = new MyApplicationResolver();\n\n    // configure your custom resolvers.\n    private static readonly IFormatterResolver[] Resolvers = new IFormatterResolver[]\n    {\n    };\n\n    private MyApplicationResolver() { }\n\n    public IMessagePackFormatter<T> GetFormatter<T>()\n    {\n        return Cache<T>.Formatter;\n    }\n\n    private static class Cache<T>\n    {\n        public static IMessagePackFormatter<T> Formatter;\n\n        static Cache()\n        {\n            // configure your custom formatters.\n            if (typeof(T) == typeof(XXX))\n            {\n                Formatter = new ICustomFormatter();\n                return;\n            }\n\n            foreach (var resolver in Resolvers)\n            {\n                var f = resolver.GetFormatter<T>();\n                if (f != null)\n                {\n                    Formatter = f;\n                    return;\n                }\n            }\n        }\n    }\n}\n```\n\n> NOTE: If you are creating a library, recommend using the above custom resolver instead of CompositeResolver.Create. Also, it must not use StaticCompositeResolver.\n\n### Use native resolvers\n\nIn default, MessagePack-CSharp serializes GUID as string. This is much slower than the native .NET format GUID. The same applies to Decimal. If your application makes heavy use of GUIDs and Decimals and you don\'t have to worry about interconnection with other languages, you can replace them with native serializers by `NativeGuidResolver`, `NativeDecimalResolver`.\n\nAlso, DateTime is serialized using the MessagePack timestamp format. By using the `NativeDateTimeResolver`, it is possible to maintain Kind and perform faster serialization.\n\n### Careful to copying buffer\n\n`MessagePackSerializer.Serialize` returns `byte[]` in default. The final `byte[]` is copied from an internal buffer pool. That is an extra cost.  You can use `IBufferWriter<T>` or `Stream` API, it writes buffer directly. If you want to require a buffer pool outside of serializer, you should implement custom `IBufferWriter<byte>`.\n\nIn deserialization, `MessagePackSerializer.Deserialize(ReadOnlyMemory<byte> buffer)` is better than `Deserialize(Stream stream)` overload. This is because the overload of Stream starts reading the data, generating `ReadOnlySequence<byte>`, and then starting deserialization.\n\n## Extensions\n\nMessagePack for C# has extension point and you can add external type\'s serialization support. There are official extension support.\n\n```ps1\nInstall-Package MessagePack.ImmutableCollection\nInstall-Package MessagePack.ReactiveProperty\nInstall-Package MessagePack.UnityShims\nInstall-Package MessagePack.AspNetCoreMvcFormatter\n```\n\n`MessagePack.ImmutableCollection` package add support for [System.Collections.Immutable](https://www.nuget.org/packages/System.Collections.Immutable/) library. It adds `ImmutableArray<>`, `ImmutableList<>`, `ImmutableDictionary<,>`, `ImmutableHashSet<>`, `ImmutableSortedDictionary<,>`, `ImmutableSortedSet<>`, `ImmutableQueue<>`, `ImmutableStack<>`, `IImmutableList<>`, `IImmutableDictionary<,>`, `IImmutableQueue<>`, `IImmutableSet<>`, `IImmutableStack<>` serialization support.\n\n`MessagePack.ReactiveProperty` package add support for [ReactiveProperty](https://github.com/runceel/ReactiveProperty) library. It adds `ReactiveProperty<>`, `IReactiveProperty<>`, `IReadOnlyReactiveProperty<>`, `ReactiveCollection<>`, `Unit` serialization support. It is useful for save viewmodel state.\n\n`MessagePack.UnityShims` package provides shim of [Unity](https://unity3d.com/)\'s standard struct(`Vector2`, `Vector3`, `Vector4`, `Quaternion`, `Color`, `Bounds`, `Rect`, `AnimationCurve`, `Keyframe`, `Matrix4x4`, `Gradient`, `Color32`, `RectOffset`, `LayerMask`, `Vector2Int`, `Vector3Int`, `RangeInt`, `RectInt`, `BoundsInt`) and their formatters. It can enable to communicate between server and Unity client.\n\nAfter install, extension package must enable by configuration. Here is sample of enable all extension.\n\n```csharp\n// set extensions to default resolver.\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    // enable extension packages first\n    ImmutableCollectionResolver.Instance,\n    ReactivePropertyResolver.Instance,\n    MessagePack.Unity.Extension.UnityBlitResolver.Instance,\n    MessagePack.Unity.UnityResolver.Instance,\n\n    // finaly use standard(default) resolver\n    StandardResolver.Instance\n);\nvar options = MessagePackSerializerOptions.Standard.WithResolver(resolver);\n\n// pass options to every time or set as default\nMessagePackSerializer.DefaultOptions = options;\n```\n\nConfiguration details, see:[Extension Point section](https://github.com/neuecc/MessagePack-CSharp#extension-point-iformatterresolver).\n\n`MessagePack.AspNetCoreMvcFormatter` is add-on of [ASP.NET Core MVC](https://github.com/aspnet/Mvc)\'s serialization to boostup performance. This is configuration sample.\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddMvc().AddMvcOptions(option =>\n    {\n        option.OutputFormatters.Clear();\n        option.OutputFormatters.Add(new MessagePackOutputFormatter(ContractlessStandardResolver.Options));\n        option.InputFormatters.Clear();\n        option.InputFormatters.Add(new MessagePackInputFormatter(ContractlessStandardResolver.Options));\n    });\n}\n```\n\nAuthor is creating other extension packages, too.\n\n* [MagicOnion](https://github.com/Cysharp/MagicOnion) - gRPC based HTTP/2 RPC Streaming Framework\n* [MasterMemory](https://github.com/Cysharp/MasterMemory) - Embedded Readonly In-Memory Document Database\n\nYou can make your own extension serializers or integrate with framework, let\'s create them and share it!\n\n* [MessagePack.FSharpExtensions](https://github.com/pocketberserker/MessagePack.FSharpExtensions) - supports F# list,set,map,unit,option,discriminated union\n* [MessagePack.NodaTime](https://github.com/ARKlab/MessagePack) -\nSupport for NodaTime types to MessagePack C#\n* [WebApiContrib.Core.Formatter.MessagePack](https://github.com/WebApiContrib/WebAPIContrib.Core#formatters) - supports ASP.NET Core MVC([details in blog post](https://www.strathweb.com/2017/06/using-messagepack-with-asp-net-core-mvc/))\n* [MessagePack.MediaTypeFormatter](https://github.com/sketch7/MessagePack.MediaTypeFormatter) - MessagePack MediaTypeFormatter\n\n# API\n\n## High-Level API (`MessagePackSerializer`)\n\nThe `MessagePackSerializer` class is the entry point of MessagePack for C#. Its static methods make up the main API of MessagePack for C#.\n\n| API | Description |\n| --- | --- |\n| `Serialize<T>` | Serializes an object graph to msgpack binary. Async variety for Stream available. Non-generic overloads available. |\n| `Deserialize<T>` | Deserializes msgpack binary to an object graph. Async variety for Stream available. Non-generic overloads available. |\n| `SerializeToJson` | Serialize a MessagePack-compatible object graph to JSON instead of msgpack. Useful for debugging. |\n| `ConvertToJson` | Convert msgpack binary to JSON. Useful for debugging.  |\n| `ConvertFromJson` | Convert JSON to msgpack binary. |\n\nA `MessagePackSerializer.Typeless` class offers most of the same APIs as above, but removes all type arguments, forcing serialization to include the full type name of the root object. It uses the `TypelessContractlessStandardResolver`. Consider the result to be a .NET-specific msgpack binary.\n\nMessagePack for C# fundamentally serializes with `IBufferWriter<byte>` level and deserializes with `ReadOnlySequence<byte>` or `Memory<byte>`. Method overloads are provided for conveniently working with common buffer types and the .NET `Stream` class, but some of these convenience overloads require copying a buffer once.\n\nHigh-Level API uses memory pool internally to avoid unnecessary memory allocation. If result size is under 64K, allocates GC memory only for the return bytes.\n\nEach serialize/deserialize method takes an optional `MessagePackSerializerOptions` parameter which can be used to specify a custom `IFormatterResolver` to use or to activate LZ4 compression support.\n\n## Low-Level API (`IMessagePackFormatter<T>`)\n\nThe `IMessagePackFormatter<T>` interface is responsible for serializing a unique type. For example `Int32Formatter : IMessagePackFormatter<Int32>` represents Int32 MessagePack serializer.\n\n```csharp\npublic interface IMessagePackFormatter<T>\n{\n    void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options);\n    T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options);\n}\n```\n\nMany built-in formatters exists under `MessagePack.Formatters`. Your custom types are usually automatically supported with the built-in type resolvers that generate new `IMessagePackFormatter<T>` types on-the-fly using dynamic code generation. See our [AOT code generation](#aot) support for platforms that do not support this.\n\nTo take more control over the serialization of your custom types, write your own `IMessagePackFormatter<T>` implementation.\nHere is sample of write own formatter. Note its use of the primitive API that is described in the next section.\n\n```csharp\n/// <summary>Serializes a <see cref="FileInfo" /> by its full path as a string.</summary>\npublic class FileInfoFormatter<T> : IMessagePackFormatter<FileInfo>\n{\n    public void Serialize(ref MessagePackWriter writer, FileInfo value, MessagePackSerializerOptions optionsr)\n    {\n        if (value == null)\n        {\n            writer.WriteNil();\n            return;\n        }\n\n        writer.WriteString(value.FullName);\n    }\n\n    public FileInfo Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n    {\n        if (reader.TryReadNil())\n        {\n            return null;\n        }\n\n        var path = reader.ReadString();\n        return new FileInfo(path);\n    }\n}\n```\n\nYour custom formatters must be discoverable via some `IFormatterResolver`. Learn more in our [resolvers](#resolvers).\n\nYou can see many other samples from [builtin formatters](https://github.com/neuecc/MessagePack-CSharp/tree/master/src/MessagePack/Formatters).\n\n## Primitive API (`MessagePackWriter`, `MessagePackReader`)\n\nThe `MessagePackWriter` and `MessagePackReader` structs make up the lowest-level API. They read and write the primitives types defined in the msgpack specification.\n\n### `MessagePackReader`\n\nA `MessagePackReader` can efficiently read from `ReadOnlyMemory<byte>` or `ReadOnlySequence<byte>` without any allocating\nexcept to allocate a new `string` as required by the `ReadString()` method. All other methods return either value structs\nor `ReadOnlySequence<byte>` slices for extensions/arrays.\nReading directly from `ReadOnlySequence<byte>` means the reader can directly consume some modern high perforamnce APIs such as `PipeReader`.\n\n| Method | Description |\n| --- | --- |\n| `Skip` | Advances the reader\'s position past the current value. If the value is complex (e.g. map, array) the entire structure is skipped. |\n| `Read*` | Read and return a value whose type is named by the method name from the current reader position. Throws if the expected type does not match the actual type. When reading numbers, the type need not match the binary-specified type exactly. The numeric value will be coerced into the desired type or throw if the integer type is too small for a large value. |\n| `TryReadNil` | Advances beyond the current value if the current value is `nil` and returns `true`; otherwise leaves the reader\'s position unchanged and returns `false`. |\n| `ReadBytes` | Returns a slice of the input sequence representing the contents of a `byte[]`, and advances the reader. |\n| `ReadStringSequence` | Returns a slice of the input sequence representing the contents of a `string` without decoding it, and advances the reader. |\n| `Clone` | Creates a new `MessagePackReader` with the specified input sequence and the same settings as the original reader. |\n| `CreatePeekReader` | Creates a new reader with the same position as this one, allowing the caller to "read ahead" without impacting the original reader\'s position. |\n| `NextCode` | Reads the low-level msgpack `byte` that describes the type of the next value. Does not advance the reader. See [msgpack format of first byte](https://github.com/msgpack/msgpack/blob/master/spec.md#overview). Its static class has `ToMessagePackType` and `ToFormatName` utility methods. `MessagePackRange` means Min-Max fix range of msgpack format. |\n| `NextMessagePackType` | Describes the `NextCode` value as a higher level category. Does not advance the reader. See [msgpack spec of source types](https://github.com/msgpack/msgpack/blob/master/spec.md#serialization-type-to-format-conversion). |\n| (others) | Other methods and properties as described by the .xml doc comment file and Intellisense. |\n\nThe `MessagePackReader` is capable of automatically interpreting both the old and new msgpack spec.\n\n### `MessagePackWriter`\n\nA `MessagePackWriter` writes to a given instance of `IBufferWriter<byte>`. Several common implementations of this exist, allowing zero allocations and minimal buffer copies while writing directly to several I/O APIs including `PipeWriter`.\n\nThe `MessagePackWriter` writes the new msgpack spec by default, but can write msgpack compatible with the old spec by setting the `OldSpec` property to `true`.\n\n| Method | Description |\n| --- | --- |\n| `Clone` | Creates a new `MessagePackWriter` with the specified underlying `IBufferWriter<byte>` and the same settings as the original writer. |\n| `Flush` | Writes any buffered bytes to the underlying `IBufferWriter<byte>`. |\n| `WriteNil` | Writes the msgpack equivalent of .NET\'s `null` value. |\n| `Write` | Writes any msgpack primitive value in the most compact form possible. Has overloads for every primitive type defined by the msgpack spec. |\n| `Write*IntType*` | Writes an integer value in exactly the msgpack type specified, even if a more compact format exists. |\n| `WriteMapHeader` | Introduces a map by specifying the number of key=value pairs it contains. |\n| `WriteArrayHeader` | Introduces an array by specifying the number of elements it contains. |\n| `WriteExtensionFormat` | Writes the full content of an extension value including length, type code and content. |\n| `WriteExtensionFormatHeader` | Writes just the header (length and type code) of an extension value. |\n| `WriteRaw` | Copies the specified bytes directly to the underlying `IBufferWriter<byte>` without any validation. |\n| (others) | Other methods and properties as described by the .xml doc comment file and Intellisense. |\n\n`DateTime` is serialized to [MessagePack Timestamp format](https://github.com/msgpack/msgpack/blob/master/spec.md#formats-timestamp), it serialize/deserialize UTC and loses `Kind` info and requires that `MessagePackWriter.OldSpec == false`.\nIf you use the `NativeDateTimeResolver`, `DateTime` values will be serialized using .NET\'s native `Int64` represnetation, which preserves `Kind` info but may not be interoperable with non-.NET platforms.\n\n## <a name="resolvers"></a>Extension Point (`IFormatterResolver`)\n\nAn `IFormatterResolver` is storage of typed serializers. The `MessagePackSerializer` API accepts a `MessagePackSerializerOptions` object which specifies the `IFormatterResolver` to use, allowing customization of the serialization of complex types.\n\n| Resolver Name | Description |\n| --- | --- |\n| BuiltinResolver | Builtin primitive and standard classes resolver. It includes primitive(int, bool, string...) and there nullable, array and list. and some extra builtin types(Guid, Uri, BigInteger, etc...). |\n| StandardResolver | Composited resolver. It resolves in the following order `builtin -> attribute -> dynamic enum -> dynamic generic -> dynamic union -> dynamic object -> dynamic object fallback`. This is the default of MessagePackSerializer. |\n| ContractlessStandardResolver | Composited `StandardResolver`(except dynamic object fallback) -> `DynamicContractlessObjectResolver` -> `DynamicObjectTypeFallbackResolver`. It enables contractless serialization. |\n| StandardResolverAllowPrivate | Same as StandardResolver but allow serialize/deserialize private members. |\n| ContractlessStandardResolverAllowPrivate | Same as ContractlessStandardResolver but allow serialize/deserialize private members. |\n| PrimitiveObjectResolver | MessagePack primitive object resolver. It is used fallback in `object` type and supports `bool`, `char`, `sbyte`, `byte`, `short`, `int`, `long`, `ushort`, `uint`, `ulong`, `float`, `double`, `DateTime`, `string`, `byte[]`, `ICollection`, `IDictionary`. |\n| DynamicObjectTypeFallbackResolver | Serialize is used type in from `object` type, deserialize is used PrimitiveObjectResolver. |\n| AttributeFormatterResolver | Get formatter from `[MessagePackFormatter]` attribute. |\n| CompositeResolver | Composes several resolvers and/or formatters together in an ordered list, allowing reuse and overriding of behaviors of existing resolvers and formatters. |\n| NativeDateTimeResolver | Serialize by .NET native DateTime binary format. It keeps `DateTime.Kind` that loses by standard(msgpack timestamp) format. |\n| NativeGuidResolver | Serialize by .NET native Guid binary representation. It is faster than standard(string) representation. |\n| NativeDecimalResolver | Serialize by .NET natvie decimal binary representation. It is faster than standard(string) representation. |\n| DynamicEnumResolver | Resolver of enum and there nullable, serialize there underlying type. It uses dynamic code generation to avoid boxing and boostup performance serialize there name. |\n| DynamicEnumAsStringResolver | Resolver of enum and there nullable.  It uses reflection call for resolve nullable at first time. |\n| DynamicGenericResolver | Resolver of generic type(`Tuple<>`, `List<>`, `Dictionary<,>`, `Array`, etc). It uses reflection call for resolve generic argument at first time. |\n| DynamicUnionResolver | Resolver of interface marked by UnionAttribute. It uses dynamic code generation to create dynamic formatter. |\n| DynamicObjectResolver | Resolver of class and struct maked by MessagePackObjectAttribute. It uses dynamic code generation to create dynamic formatter. |\n| DynamicContractlessObjectResolver | Resolver of all classes and structs. It does not needs MessagePackObjectAttribute and serialized key as string(same as marked [MessagePackObject(true)]). |\n| DynamicObjectResolverAllowPrivate | Same as DynamicObjectResolver but allow serialize/deserialize private members. |\n| DynamicContractlessObjectResolverAllowPrivate | Same as DynamicContractlessObjectResolver but allow serialize/deserialize private members. |\n| TypelessObjectResolver | Used for `object`, embed .NET type in binary by `ext(100)` format so no need to pass type in deserilization.  |\n| TypelessContractlessStandardResolver | Composited resolver. It resolves in the following order `nativedatetime -> builtin -> attribute -> dynamic enum -> dynamic generic -> dynamic union -> dynamic object -> dynamiccontractless -> typeless`. This is the default of `MessagePackSerializer.Typeless`  |\n\nEach invocation of `MessagePackSerializer` accepts only a single resolver. Most object graphs will need more than one for serialization, so composing a single resolver made up of several is often required, and can be done with the `CompositeResolver` as shown below:\n\n```csharp\n// Do this once and store it for reuse.\nvar resolver = new MessagePack.Resolvers.CompositeResolver();\nresolver.RegisterResolver(\n    // resolver custom types first\n    ImmutableCollectionResolver.Instance,\n    ReactivePropertyResolver.Instance,\n    MessagePack.Unity.Extension.UnityBlitResolver.Instance,\n    MessagePack.Unity.UnityResolver.Instance,\n\n    // finally use standard resolver\n    StandardResolver.Instance);\nvar options = MessagePackSerializerOptions.Standard.WithResolver(resolver);\n\n// Each time you serialize/deserialize, specify the options:\nbyte[] msgpackBytes = MessagePackSerializer.Serialize(myObject, options);\nT myObject2 = MessagePackSerializer.Deserialize<MyObject>(msgpackBytes, options);\n```\n\nCreated resolver can set as default by `MessagePackSerializer.DefaultOptions = options`, it can avoid explicitly pass custom resolver but **WARNING**: When developing an application where you control all MessagePack-related code it may be safe to rely on this mutable static to control behavior.\nFor all other libraries or multi-purpose applications that use `MessagePackSerializer` you should explicitly specify the `MessagePackSerializerOptions` to use with each method invocation to guarantee your code behaves as you expect even when sharing an `AppDomain` or process with other MessagePack users that may change this static property.\n\nHere is sample of use `DynamicEnumAsStringResolver` with `DynamicContractlessObjectResolver` (It is JSON.NET-like lightweight setting.)\n\n```csharp\n// composite same as StandardResolver\nvar resolver = new MessagePack.Resolvers.CompositeResolver();\nresolver.RegisterResolver(\n    MessagePack.Resolvers.BuiltinResolver.Instance,\n    MessagePack.Resolvers.AttributeFormatterResolver.Instance,\n\n    // replace enum resolver\n    MessagePack.Resolvers.DynamicEnumAsStringResolver.Instance,\n\n    MessagePack.Resolvers.DynamicGenericResolver.Instance,\n    MessagePack.Resolvers.DynamicUnionResolver.Instance,\n    MessagePack.Resolvers.DynamicObjectResolver.Instance,\n\n    MessagePack.Resolvers.PrimitiveObjectResolver.Instance,\n\n    // final fallback(last priority)\n    MessagePack.Resolvers.DynamicContractlessObjectResolver.Instance);\n```\n\nIf you want to make your extension package, you should write both the formatter and resolver\nfor easier consumption.\nHere is sample of a resolver:\n\n```csharp\npublic class SampleCustomResolver : IFormatterResolver\n{\n    // Resolver should be singleton.\n    public static readonly IFormatterResolver Instance = new SampleCustomResolver();\n\n    private SampleCustomResolver()\n    {\n    }\n\n    // GetFormatter<T>\'s get cost should be minimized so use type cache.\n    public IMessagePackFormatter<T> GetFormatter<T>()\n    {\n        return FormatterCache<T>.Formatter;\n    }\n\n    private static class FormatterCache<T>\n    {\n        public static readonly IMessagePackFormatter<T> Formatter;\n\n        // generic\'s static constructor should be minimized for reduce type generation size!\n        // use outer helper method.\n        static FormatterCache()\n        {\n            Formatter = (IMessagePackFormatter<T>)SampleCustomResolverGetFormatterHelper.GetFormatter(typeof(T));\n        }\n    }\n}\n\ninternal static class SampleCustomResolverGetFormatterHelper\n{\n    // If type is concrete type, use type-formatter map\n    static readonly Dictionary<Type, object> formatterMap = new Dictionary<Type, object>()\n    {\n        {typeof(FileInfo), new FileInfoFormatter()}\n        // add more your own custom serializers.\n    };\n\n    internal static object GetFormatter(Type t)\n    {\n        object formatter;\n        if (formatterMap.TryGetValue(t, out formatter))\n        {\n            return formatter;\n        }\n\n        // If target type is generics, use MakeGenericType.\n        if (t.IsGenericParameter && t.GetGenericTypeDefinition() == typeof(ValueTuple<,>))\n        {\n            return Activator.CreateInstance(typeof(ValueTupleFormatter<,>).MakeGenericType(t.GenericTypeArguments));\n        }\n\n        // If type can not get, must return null for fallback mecanism.\n        return null;\n    }\n}\n```\n\n## MessagePackFormatterAttribute\n\nMessagePackFormatterAttribute is lightweight extension point of class, struct, interface, enum and property/field. This is like JSON.NET\'s JsonConverterAttribute. For example, serialize private field, serialize x10 formatter.\n\n```csharp\n[MessagePackFormatter(typeof(CustomObjectFormatter))]\npublic class CustomObject\n{\n    string internalId;\n\n    public CustomObject()\n    {\n        this.internalId = Guid.NewGuid().ToString();\n    }\n\n    // serialize/deserialize internal field.\n    class CustomObjectFormatter : IMessagePackFormatter<CustomObject>\n    {\n        public void Serialize(ref MessagePackWriter writer, CustomObject value, MessagePackSerializerOptions options)\n        {\n            options.Resolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.internalId, options);\n        }\n\n        public CustomObject Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n        {\n            var id = options.Resolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);\n            return new CustomObject { internalId = id };\n        }\n    }\n}\n\n// per field, member\n\npublic class Int_x10Formatter : IMessagePackFormatter<int>\n{\n    public int Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n    {\n        return reader.ReadInt32() * 10;\n    }\n\n    public void Serialize(ref MessagePackWriter writer, int value, MessagePackSerializerOptions options)\n    {\n        writer.WriteInt32(value * 10);\n    }\n}\n\n[MessagePackObject]\npublic class MyClass\n{\n    // You can attach custom formatter per member.\n    [Key(0)]\n    [MessagePackFormatter(typeof(Int_x10Formatter))]\n    public int MyProperty1 { get; set; }\n}\n```\n\nFormatter is retrieved by `AttributeFormatterResolver`, it is included in `StandardResolver`.\n\n## IgnoreFormatter\n\n`IgnoreFormatter<T>` is lightweight extension point of class and struct, if exists can\'t serializable type in external type, you can register `IgnoreFormatter<T>` that serialize to nil.\n\n```csharp\n// CompositeResolver can set custom formatter.\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    new IMessagePackFormatter[]\n    {\n        // for example, register reflection infos(can not serialize in default)\n        new IgnoreFormatter<MethodBase>(),\n        new IgnoreFormatter<MethodInfo>(),\n        new IgnoreFormatter<PropertyInfo>(),\n        new IgnoreFormatter<FieldInfo>()\n    },\n    new IFormatterResolver[]\n    {\n        ContractlessStandardResolver.Instance\n    });\n```\n\n## Reserved Extension Types\n\nMessagePack for C# already used some messagepack ext type codes, be careful to use same ext code.\n\n| Code | Type | Use by |\n| ---  | ---  | --- |\n| -1 | DateTime | msgpack-spec reserved for timestamp |\n| 30 | Vector2[] | for Unity, UnsafeBlitFormatter |\n| 31 | Vector3[] | for Unity, UnsafeBlitFormatter |\n| 32 | Vector4[] | for Unity, UnsafeBlitFormatter |\n| 33 | Quaternion[] | for Unity, UnsafeBlitFormatter |\n| 34 | Color[] | for Unity, UnsafeBlitFormatter |\n| 35 | Bounds[] | for Unity, UnsafeBlitFormatter |\n| 36 | Rect[] | for Unity, UnsafeBlitFormatter |\n| 37 | Int[] | for Unity, UnsafeBlitFormatter |\n| 38 | Float[] | for Unity, UnsafeBlitFormatter |\n| 39 | Double[] | for Unity, UnsafeBlitFormatter |\n| 99 | All | LZ4MessagePackSerializer |\n| 100 | object | TypelessFormatter |\n\n## Unity support\n\nUnity lower support version is `2018.3`, Api Compatibility Level is supporrt both `.NET 4.x` and `.NET Standard 2.0`.\n\nYou can install by unitypackage in [releases](https://github.com/neuecc/MessagePack-CSharp/releases/) page. If build target as PC, you can use as is but if build target uses IL2CPP, you can not use `Dynamic***Resolver` so require to use pre-code generation. Please see [pre-code generation section](#aot).\n\nCurrently `CompositeResolver.Create` can not work on IL2CPP so recommend to use `StaticCompositeResolver.Instance.Register` instead.\n\nIn Unity, MessagePackSerializer can serialize `Vector2`, `Vector3`, `Vector4`, `Quaternion`, `Color`, `Bounds`, `Rect`, `AnimationCurve`, `Keyframe`, `Matrix4x4`, `Gradient`, `Color32`, `RectOffset`, `LayerMask`, `Vector2Int`, `Vector3Int`, `RangeInt`, `RectInt`, `BoundsInt` and there nullable, there array, there list by built-in extension `UnityResolver`. It is included StandardResolver by default.\n\nMessagePack for C# has additional unsafe extension.  `UnsafeBlitResolver` is special resolver for extremely fast unsafe serialization/deserialization for struct array.\n\n![image](https://cloud.githubusercontent.com/assets/46207/23837633/76589924-07ce-11e7-8b26-e50eab548938.png)\n\nx20 faster Vector3[] serialization than native JsonUtility. If use `UnsafeBlitResolver`, serialize special format(ext:typecode 30~39)  `Vector2[]`, `Vector3[]`, `Quaternion[]`, `Color[]`, `Bounds[]`, `Rect[]`. If use `UnityBlitWithPrimitiveArrayResolver`, supports `int[]`, `float[]`, `double[]` too. This special feature is useful for serialize Mesh(many `Vector3[]`) or many transform position.\n\nIf you want to use unsafe resolver, register `UnityBlitResolver` or `UnityBlitWithPrimitiveArrayResolver`.\n\nHere is sample of configuration.\n\n```csharp\nStaticCompositeResolver.Instance.Register(\n    MessagePack.Unity.UnityResolver.Instance,\n    MessagePack.Unity.Extension.UnityBlitWithPrimitiveArrayResolver.Instance,\n    MessagePack.Resolvers.StandardResolver.Instance,\n);\n\nvar options = MessagePackSerializerOptions.Standard.WithResolver(StaticCompositeResolver.Instance);\nMessagePackSerializer.DefaultOptions = options;\n```\n\n`MessagePack.UnityShims` NuGet package is for .NET ServerSide serialization support to communicate with Unity. It includes shim of Vector3 etc and Safe/Unsafe serialization extension.\n\nIf you want to share class between Unity and Server, you can use `SharedProject` or `Reference as Link` or glob reference(with `LinkBase`) etc. Anyway you need to source-code level share. This is sample project structure of use glob reference(recommended).\n\n- ServerProject(.NET 4.6/.NET Core/.NET Standard)\n  - [`<Compile Include="..\\UnityProject\\Assets\\Scripts\\Shared\\**\\*.cs" LinkBase="Shared" />`]\n  - [MessagePack]\n  - [MessagePack.UnityShims]\n- UnityProject\n  - [Concrete SharedCodes]\n  - [MessagePack](not dll/NuGet, use MessagePack.Unity.unitypackage\'s sourcecodes)\n\n## <a name="aot"></a>AOT Code Generation (to support Unity/Xamarin)\n\nBy default, MessagePack for C# serializes custom objects by using [generating IL](https://msdn.microsoft.com/en-us/library/system.reflection.emit.ilgenerator.aspx) at runtime for custom, highly tuned formatters for each type. This code generation has a minor upfront perf cost.\nBecause strict-AOT environments such as Xamarin and Unity IL2CPP forbid runtime code generation, MessagePack provides a way for you to run a code generator ahead of time as well.\n\n> Note: When Unity targets the PC it allows dynamic code generation, so AOT is not required.\n\nIf you want to avoid the upfront dynamic generation cost or you need to run on Xamarin or Unity, you need AOT code generation. `mpc` (MessagePackCompiler) is the code generator of MessagePack for C#. mpc uses [Roslyn](https://github.com/dotnet/roslyn) to analyze source code.\n\nThe easiest way to acquire and run mpc is as a dotnet tool.\n\n```\ndotnet tool install --global MasterMemory.Generator\n```\n\nInstalling it as a local tool allows you to include the tools and versions that you use in your source control system. Run these commands in the root of your repo:\n\n```\ndotnet new tool-manifest\ndotnet tool install MessagePack.Generator\n```\n\nCheck in your `.config\\dotnet-tools.json` file. On another machine you can "restore" your tool using the `dotnet tool restore` command.\n\nOnce you have the tool installed, simply invoke using `dotnet mpc` within your repo:\n\n```\ndotnet mpc -h\n```\n\nAlternatively, you can download mpc from the [releases](https://github.com/neuecc/MessagePack-CSharp/releases/) page, that includes platform native binaries(don\'t require dotnet runtime).\n\n```\nargument list:\n-i, -input: Input path of analyze csproj or directory, if input multiple csproj split with \',\'.\n-o, -output: Output file path(.cs) or directory(multiple generate file).\n-c, -conditionalSymbol: [default=null]Conditional compiler symbols, split with \',\'.\n-r, -resolverName: [default=GeneratedResolver]Set resolver name.\n-n, -namespace: [default=MessagePack]Set namespace root name.\n-m, -useMapMode: [default=False]Force use map mode serialization.\n-ms, -multipleIfDirectiveOutputSymbols: [default=null]Generate #if-- files by symbols, split with \',\'.\n```\n\n```cmd\n// Simple Sample:\nmpc.exe -i "..\\src\\Sandbox.Shared.csproj" -o "MessagePackGenerated.cs"\n\n// Use force map simulate DynamicContractlessObjectResolver\nmpc.exe -i "..\\src\\Sandbox.Shared.csproj" -o "MessagePackGenerated.cs" -m\n```\n\nBy default, `mpc.exe` generates resolver to `MessagePack.Resolvers.GeneratedResolver` and formatters generates to `MessagePack.Formatters.***`.\n\n```csharp\n// Do this once\nStaticCompositeResolver.Instance.Register(new IFormatterResolver[]\n{\n    MessagePack.Resolvers.GeneratedResolver.Instance,\n    MessagePack.Resolvers.StandardResolver.Instance,\n});\n\n// Store it for reuse.\nvar options = MessagePackSerializerOptions.Standard.WithResolver(resolver);\n\n// Each time you serialize/deserialize, specify the options:\nbyte[] msgpackBytes = MessagePackSerializer.Serialize(myObject, options);\nT myObject2 = MessagePackSerializer.Deserialize<MyObject>(msgpackBytes, options);\n\n// or set as application default.\nMessagePackSerializer.DefaultOptions = options;\n```\n\nIn Unity, you can use MessagePack CodeGen windows at `Windows -> MessagePack -> CodeGenerator`.\n\n![](https://user-images.githubusercontent.com/46207/69414381-f14da400-0d55-11ea-9f8d-9af448d347dc.png)\n\nIt helps install .NET Core runtime, install mpc(as Global Tools), execute mpc. Currently this tool is experimental so please tell me your opinion.\n\nFor Xamarin, you can use `MessagePack.MSBuild.Tasks` that is same as mpc but you can use in csproj easily.\n\n```xml\n<ItemGroup>\n    <!-- Install MSBuild Task(with PrivateAssets="All", it means to use dependency only in build time). -->\n    <PackageReference Include="MessagePack.MSBuild.Tasks" Version="*" PrivateAssets="All" />\n</ItemGroup>\n\n<!-- Call code generator before-build. -->\n<Target Name="MessagePackGen" BeforeTargets="BeforeBuild">\n    <!-- Configuration of Code-Generator -->\n    <MessagePackGenerator Input="$(ProjectPath)" Output="$(ProjectDir)MessagePack" />\n</Target>\n```\n\nMSBuild Task\'s configuration list is here.\n\n```xml\n<MessagePackGenerator\n    Input="string:required"\n    Output="string:required"\n    ConditionalSymbol="string:optional"\n    ResolverName="string:optional"\n    Namespace="string:optional"\n    UseMapMode="bool:optional"\n    MultipleIfDirectiveOutputSymbols="string:optional"\n/>\n```\n\n## RPC\n\nMessagePack advocated [MessagePack RPC](https://github.com/msgpack-rpc/msgpack-rpc), but formulation is stopped and it is not widely used.\n\n### MagicOnion\n\nI\'ve created gRPC based MessagePack HTTP/2 RPC streaming framework called [MagicOnion](https://github.com/Cysharp/MagicOnion). gRPC usually communicates with Protocol Buffers using IDL. But MagicOnion uses MessagePack for C# and does not needs IDL. If communicates C# to C#, schemaless(C# classes as schema) is better than IDL.\n\n### StreamJsonRpc\n\nThe StreamJsonRpc library is based on [JSON-RPC](https://www.jsonrpc.org/) and includes [a pluggable formatter architecture](https://github.com/microsoft/vs-streamjsonrpc/blob/master/doc/extensibility.md#alternative-formatters) and includes [a sample MessagePack plugin](https://github.com/microsoft/vs-streamjsonrpc/blob/master/src/StreamJsonRpc.Tests/MessagePackFormatter.cs).\n\n## How to build\n\nSee our [contributor\'s guide](CONTRIBUTING.md).\n\n## Author Info\n\nYoshifumi Kawai(a.k.a. neuecc) is a software developer in Japan.\nHe is the Director/CTO at Grani, Inc.\nGrani is a mobile game developer company in Japan and well known for using C#.\nHe is awarding Microsoft MVP for Visual C# since 2011.\nHe is known as the creator of [UniRx](http://github.com/neuecc/UniRx/) (Reactive Extensions for Unity)\n\n* Blog: [https://medium.com/@neuecc](https://medium.com/@neuecc) (English)\n* Blog: [http://neue.cc/](http://neue.cc/) (Japanese)\n* Twitter: [https://twitter.com/neuecc](https://twitter.com/neuecc) (Japanese)\n'