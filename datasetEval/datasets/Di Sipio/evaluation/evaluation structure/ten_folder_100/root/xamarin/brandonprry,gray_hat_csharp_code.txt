b"Gray Hat C# - Creating and Automating Security Tools\n===============\n\n<https://www.nostarch.com/grayhatcsharp>\n\nThis repository contains fully-fleshed out code examples from the book Gray Hat\nC#. In this book, a wide variety of security oriented tools and libraries will\nbe written using the C# programming language, allowing for cross-platform\nautomation of the most crucial aspects of a security engineer's roles in a\nmodern organization. Many of the topics will also be highly useful for hobbyists\nand security enthusiasts who are looking to gain more experience with common\nsecurity concepts and tools with real world examples for both offensive and\ndefensive purposes.\n\n\nWe cover a broad slice of concepts a modern security engineer must be\nfamiliar with, starting with a brief introduction to the C# language.\nAfter the introduction, we focus on fuzzing web application\nvulnerabilities and writing exploits for them. This is followed by C#\npayloads for pentesters to use for remote command execution and\npersistence. Then, we move onto security tool automation using true APIs, not\njust calling programs from the system shell. Finally, we focus on\nreverse engineering and forensics in the final chapters.\n\n\nThe solution was developed on Linux with MonoDevelop and OS X with Xamarin\nStudio. However, every line of code should work across all platforms and this\nshould Just Work(tm) in Visual Studio on Windows.\n\n\nThe Chapters\n====\n\nChapter 1 - Crash Course\n--\nIn chapter one, we learn the basics of C# object-oriented programming with very\nsimple examples. We briefly cover object-oriented principles such as\ninheritance, but also cover more advanced features of the C# language such as\ndelegates and Platform Invoke (P/Invoke).\n\n<https://msdn.microsoft.com/en-us/library/kx37x362.aspx>\n\nChapter 2 - Fuzzing and Exploiting XSS and SQL Injection\n--\nIn chapter two, we are introduced to the HTTP library used to communicate with\nweb servers in order to write small HTTP request fuzzers looking for XSS and SQL\ninjection in a variety of different data types. We also write exploits for two\ntypes of SQL injection techniques; UNION and boolean-based.\n\n<https://www.owasp.org/index.php/SQL_Injection>\n\n<https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)>\n\nChapter 3 - Fuzzing SOAP Endpoints\n--\nIn chapter three, we take the concept of the fuzzers in the previous chapter to\nthe next level, and also introduce the excellent XML libraries available in the\nstandard library. We write a small fuzzer that retrieves and parses a SOAP WSDL\nin order to automatically generate HTTP requests in order to find potential SQL\ninjections.\n\n<https://en.wikipedia.org/wiki/SOAP>\n\nChapter 4 - Writing Connect-backs, Binds, and Metasploit Payloads\n--\nIn chapter four, we break from the focus on HTTP and move onto payloads that we\ncan create. We first create a couple of simple payloads, one over TCP and one\nover UDP. Then we learn how to generate x86/x86_64 shellcode in Metasploit to\ncreate cross-platform and cross-architecture payloads.\n\nChapter 5 - Automating Nessus\n--\nIn chapter five, we start back again with HTTP in order to begin automating the\nNessus vulnerability scanner. We go over how to create, watch, and report on\nscans on CIDR ranges programmatically.\n\n<https://www.tenable.com>\n\nChapter 6 - Automating Nexpose\n--\nIn chapter six, we maintain the focus on tool automation by moving onto\nautomating the Nexpose vulnerability scanner. Nexpose, whose API is also HTTP\nbased, can also achieve automated vulnerability scans and reports and offers a\nfree year license for their Community product, very useful for home enthusiasts.\n\n<https://www.rapid7.com/products/nexpose/>\n\nChapter 7 - Automating OpenVAS\n--\nIn chapter seven, we conclude the focus on vulnerability scanner automation with\nOpenVAS, a free and open source vulnerability scanner. OpenVAS has a fundamentally\ndifferent kind of API than both Nessus and Nexpose, and is also very useful for\nhobbyists or home enthusiasts.\n\n<http://www.openvas.org>\n\nChapter 8 - Automating the Cuckoo Sandbox\n--\nIn chapter eight, we move into the incident response area and focus on automating\nthe Cuckoo Sandbox. Using an easy to consume RESTful JSON API, we automate\nsubmitting potential malware samples, then reporting on the results.\n\n<http://www.cuckoosandbox.org>\n\nChapter 9 - Automating sqlmap\n--\nIn chapter nine, we move onto more than just finding potential SQL injections with\nfuzzers and begin exploiting SQL injections to their fullest extent by automating\nsqlmap. Using an easy to use JSON API shipped with sqlmap, we first create small\ntools to submit single URLs. Once done with the introduction, we integrate sqlmap\ninto the SOAP WSDL fuzzer from chapter three, so any potential SQL injection\nvulnerabilities can be automatically exploited and validated.\n\n<http://sqlmap.org/>\n\nChapter 10 - Automating ClamAV\n--\nIn chapter ten, we focus on interacting with native, unmanaged libraries. ClamAV,\na popular and open source antivirus project, is not written in a .NET language, but\nwe can still interface with its core libraries as well as remotely via a TCP daemon.\nWe cover how to automate ClamAV in both scenarios.\n\n<http://www.clamav.net>\n\nChapter 11 - Automating Metasploit\n--\nIn chapter eleven, we put the focus back on Metasploit. We learn how to\nprogrammatically drive Metasploit via the MSGPACK RPC that is shipped with the core\nframework in order to exploit and report on shelled hosts.\n\n<https://www.rapid7.com/products/metasploit/>\n\nChapter 12 - Automating Arachni\n--\nIn chapter twelve, we focus on automating the blackbox web application scanner\nArachni, a free and open source project, though dual-licensed. Using both the\nsimpler REST HTTP API and the more powerful MSGPACK RPC that is the shipped\nwith the project, we create small tools to automatically scan a URL and report\nthe findings as we scan.\n\n<http://www.arachni-scanner.com>\n\nChapter 13 - Decompiling and Reversing Managed Assemblies\n--\nIn chapter thirteen, we move into reverse engineering. There are easy to use .NET\ndecompilers for Windows, but not for Mac or Linux, so we write a small one\nourselves. We also discuss the useful ```monodis``` tool, which allows granular\ninsight into the inner working of a .NET assembly.\n\n<http://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/>\n\n<http://www.mono-project.com/docs/tools+libraries/tools/monodis/>\n\nChapter 14 - Reading Offline Windows NT Registry Hives\n--\nIn chapter fourteen, we move into the digital forensics area and focus on registry\nhives. Going over the binary structure of the Windows registry, we learn how to\nparse and read offline registry hives, which allows us to easily retrieve the\nsystem's boot key, used to encrypt password hash information in the SAM registry\nhive.\n\n<https://github.com/msuhanov/regf/blob/master/Windows%20registry%20file%20format%20specification.md>\n\nConclusion\n==\nIn the end, I want the reader to leave having a broad understanding of the\npotential the C# programming language can have at their home or organization, who\nmay be struggling to enact and follow through with mature vulnerability management\nor security-oriented SDLCs due to resource constraints.\n"