b'[![Join the chat at https://gitter.im/flecsdev/community](https://badges.gitter.im/flecsdev/community.svg)](https://gitter.im/flecsdev/community?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Discord Chat](https://img.shields.io/discord/633826290415435777.svg)](https://discord.gg/) [![Build Status](https://travis-ci.org/SanderMertens/flecs.svg?branch=master)](https://travis-ci.org/SanderMertens/flecs)\n[![Build status](https://ci.appveyor.com/api/projects/status/t99p1per439ctg1a/branch/master?svg=true)](https://ci.appveyor.com/project/SanderMertens/flecs/branch/master)\n[![codecov](https://codecov.io/gh/SanderMertens/flecs/branch/master/graph/badge.svg)](https://codecov.io/gh/SanderMertens/flecs)\n\n![flecs](https://user-images.githubusercontent.com/9919222/54175082-b107f900-4446-11e9-9cbc-91c096f7c0b1.png)\n\nFlecs is a [Fast](https://github.com/SanderMertens/ecs_benchmark) and Lightweight ECS ([Entity Component System](#what-is-an-entity-component-system)). Flecs packs as much punch as possible into a small library with a tiny C99 API and zero dependencies. Here are some of the things it can do:\n\n- Process entities on multiple threads with a lock-free, zero-overhead staging architecture [[learn more](Manual.md#staging)]\n- Organize components & systems in reusable, library-friendly modules [[learn more](Manual.md#modules)]\n- Run systems every frame, periodically, on demand or on change events [[learn more](Manual.md#reactive-systems)]\n\nAdditionally, flecs has a flexible engine that lets you do many things, like:\n\n- A prefab system with variants, overrides and prefab nesting [[learn more](Manual.md#prefabs)]\n- Create system expressions with AND, OR, NOT and optional operators [[learn more](Manual.md#system-signatures)]\n- Create hierarchies, indexes and [DAGs](https://en.wikipedia.org/wiki/Directed_acyclic_graph) with container entities [[learn more](Manual.md#containers)]\n\nMake sure to check the flecs [dashboard](https://github.com/SanderMertens/flecs-systems-admin):\n\n![dashboard](https://user-images.githubusercontent.com/9919222/54180572-309ec380-4459-11e9-9e48-1a08de57ff91.png)\n\n## What is an Entity Component System?\nECS (Entity Component System) is a way to organize code that is mostly used in gaming and simulation projects. ECS code generally performs better than traditional OOP, and is typically easier to reuse. The main differences between ECS and OOP are composition is a first class citizen in ECS, and that data is represented as plain data types rather than encapsulated classes.  A framework is an Entity Component System if it:\n\n- Has _entities_ that are unique identifiers (integers)\n- Has _components_ that are plain data types which can be added to entities\n- Has _systems_ that are functions which are matched against entities with a set of components\n\nFor more information, check [the Entity Component System FAQ](https://github.com/SanderMertens/ecs-faq)!\n\n## Example\nThe following code shows a simple flecs application:\n\n```c\ntypedef struct Position {\n    float x;\n    float y;\n} Position;\n\ntypedef int32_t Speed;\n\nvoid Move(ecs_rows_t *rows) {\n    ECS_COLUMN(rows, Position, p, 1);\n    ECS_COLUMN(rows, Speed, s, 2);\n    \n    for (int i = 0; i < rows->count; i ++) {\n        p[i].x += s[i] * rows->delta_time;\n        p[i].y += s[i] * rows->delta_time;\n    }\n}\n\nint main(int argc, char *argv[]) {\n    ecs_world_t *world = ecs_init_w_args(argc, argv);\n\n    /* Register components and systems */\n    ECS_COMPONENT(world, Position);\n    ECS_COMPONENT(world, Speed);\n    ECS_SYSTEM(world, Move, EcsOnUpdate, Position, Speed);\n    ECS_ENTITY(world, MyEntity, Position, Speed);\n\n    /* Limit application to 60 FPS */\n    ecs_set_target_fps(world, 60);\n\n    /* Progress world in main loop (invokes Move system) */\n    while (ecs_progress(world, 0));\n\n    return ecs_fini(world);\n}\n```\nFor more examples, go to [the flecs examples folder](https://github.com/SanderMertens/flecs/tree/master/examples) or the [flecs-hub organization](https://github.com/flecs-hub).\n\n## Manual\n[Click here](Manual.md) to view the Flecs manual.\n\n## Contents\n* [Building](#building)\n* [Getting started](#getting-started)\n* [Built with flecs](#built-with-flecs)\n* [Modules](#modules)\n* [Concepts](#concepts)\n  * [entity](#entity)\n  * [component](#component)\n  * [system](#system)\n  * [identifier](#identifier)\n  * [type](#type)\n  * [feature](#feature)\n  * [tag](#tag)\n  * [container](#container)\n  * [prefab](#prefab)\n  * [module](#module)\n\n## Building\nYou can build flecs with either CMake, Meson, [Bake](https://github.com/SanderMertens/bake) or embed the sources into your own project.\n\n### Embedding:\nFlecs can be easily embedded into projects, as it does not require complex build instructions. The following build instructions are enough to build a functioning Flecs library with gcc:\n\n```\ngcc src/*.c -Iinclude --shared -o libflecs.so\n```\n\n### CMake\n```\ngit clone https://github.com/SanderMertens/flecs\ncd flecs\nmkdir build\ncd build\ncmake ..\nmake\n```\n\n### Meson\n\n```\ngit clone https://github.com/SanderMertens/flecs\ncd flecs\nmeson build --default-library=both\ncd build\nninja\n```\n\n### Bake\nInstall bake first:\n```\ngit clone https://github.com/SanderMertens/bake\nmake -C bake/build-$(uname)\nbake/bake setup\n```\n\nTo then install Flecs, do:\n```\nbake clone https://github.com/SanderMertens/flecs\n```\n\n### Building notes\n\n#### Operating system abstraction API\nMost of Flecs can run without relying on operating system specific functionality. However, some features require threading and timing, amongst others. Out of the box, Flecs implements abstractions for these functions for common platforms. If you however want to run Flecs on a platform that is not implemented, you can easily provide Flecs with a platform specific set of functions through the OS API interface.\n\nThe OS API is an interface that contains function pointers for all the functions Flecs needs from the underlying platform which can be easily overridden by an application. These functions include support for:\n\n- Heap memory management\n- Threading\n- Timing\n- Logging\n- Exception handling\n\n[This section of the manual](Manual.md#operating-system-abstraction-api) describes how to override functions in OS API.\n\n#### Modules\nFlecs has optional [modules](#modules) which are created as bake packages. It is possible to use modules in a non-bake environment, but this is still a work in progress and likely requires manual labor. \n\nIf you want to use modules, but you do not want to use bake as the build tool for your own applications, the recommended way of accomplishing this is to first build Flecs and the modules with bake, and use the generated binaries with your own build system. \n\nAfter building with bake, you will have a folder called `bake` in your home directory which contains binaries and include files. Depending on your operating system, you may need to set `LD_LIBRARY_PATH` (Linux), `DYLD_LIBRARY_PATH` (MacOS) or `PATH` (Windows) to the path where the libraries are stored.\n\n## Getting started\nTo create a new flecs application, first create a new project:\n\n```\nbake new my_app -t flecs\n```\n\nYou now have a project which contains a simple flecs application! To run the project, do:\n\n```\nbake run my_app\n```\n\n### Getting started with the dashboard\nTo create an application that uses the flecs web dashboard, first install the `admin` and `civetweb` modules:\n\n```\nbake clone SanderMertens/flecs-systems-admin\nbake clone SanderMertens/flecs-systems-civetweb\n```\nCurrently this is only possible out of the box with [bake](https://github.com/SanderMertens/bake). Future versions may also support modules with CMake.\n\nAfter cloning the packages, create a new project like so:\n\n```\nbake new my_app -t flecs\n```\nThis creates a new flecs application. To now run your application with the dashboard, run it like this:\n\n```\nbake run my_app -a --admin 9090\n```\nThis runs the application, and passes `--admin 9090` as its arguments. You can now navigate to http://localhost:9090 to see the dashboard. Any systems that you add to your application will now show up in the dashboard, and can be turned on/off.\n\n## Built with flecs\n\n#### [ecs_graphics](https://github.com/SanderMertens/ecs_graphics)\nBasic rendering and user input. \n\n#### [ecs_nbody](https://github.com/SanderMertens/ecs_nbody)\nAn nbody simulation that uses flecs multithreading.\n\n#### [ecs_collisions](https://github.com/SanderMertens/ecs_collisions)\nA simple application demonstrating collision detection with flecs.\n\n#### [ecs_inheritance](https://github.com/SanderMertens/ecs_inheritance)\nA simple application demonstrating inheritance with flecs.\n\n#### [ecs_pong](https://github.com/SanderMertens/ecs_pong)\nAn implementation of pong in flecs.\n\n#### [ecs_solar](https://github.com/SanderMertens/ecs_solar)\nAn intermediate application that demonstrates hierarchies and particle effects\n\n#### [ecs_benchmark](https://github.com/SanderMertens/ecs_benchmark)\nECS performance benchmark that tests various operations and iterations.\n\n## Modules\nFlecs has a growing ecosystem of modules. The following modules are currently\navailable:\n\nModule      | Description      \n------------|------------------\n[flecs.components.transform](https://github.com/SanderMertens/flecs-components-transform) | Components for positioning, rotating and scaling entities\n[flecs.components.physics](https://github.com/SanderMertens/flecs-components-physics) | Components for moving entities\n[flecs.components.graphics](https://github.com/SanderMertens/flecs-components-graphics) | Components for describing a drawing canvas and camera\n[flecs.components.geometry](https://github.com/SanderMertens/flecs-components-geometry) | Components for describing geometry\n[flecs.components.input](https://github.com/SanderMertens/flecs-components-input) | Components for describing keyboard and mouse input\n[flecs.components.http](https://github.com/SanderMertens/flecs-components-http) | Components for describing an HTTP server with endpoints\n[flecs.components.meta](https://github.com/SanderMertens/flecs-components-meta) | Reflection components for flecs components\n[flecs.systems.transform](https://github.com/SanderMertens/flecs-systems-transform) | Compute transformation matrices from transform components\n[flecs.systems.physics](https://github.com/SanderMertens/flecs-systems-physics) | Simple 2D physics engine with limited 3D features\n[flecs.systems.civetweb](https://github.com/SanderMertens/flecs-systems-civetweb) | A civetweb-based implementation of components-http\n[flecs.systems.admin](https://github.com/SanderMertens/flecs-systems-admin) | A web-based dashboard for monitoring flecs performance\n[flecs.systems.sdl2](https://github.com/SanderMertens/flecs-systems-sdl2) | An SDL2-based renderer\n[flecs.math](https://github.com/SanderMertens/flecs-math) | Matrix and vector math functions\n[flecs.util](https://github.com/SanderMertens/flecs-util) | Utility functions and datastructures\n\n## Concepts\nThis section describes the high-level concepts used in flecs, and how they are represented in the API. Rather than providing an exhaustive overview of the API behavior, this section is intended as an introduction to the different API features of flecs.\n\n### World\nA world is a container in which entities, components and systems can be stored and evaluated. An application can create any number of worlds. Data between worlds is not shared. If the application wants to share data between worlds, this has to be done manually. A world in ECS can be created with the `ecs_init` function:\n\n```c\necs_world_t *world = ecs_init();\n```\n\n### Entity\nAn entity is an integer that uniquely identifies an "object" in a system. An entity may have `0..n` components, and each component can be added only once. Entities can be created in flecs with the `ecs_new` function:\n\n```c\necs_entity_t e = ecs_new(world, 0);\n```\n\n[Learn more](Manual.md#entities)\n\n### Component\nComponents are datatypes that can be added to an entity. Any C datatype can be registered as a component within flecs. To register a component, you can use the `ECS_COMPONENT` macro, which wraps around the `ecs_new_component` function:\n\n```c\ntypedef struct Point {\n   int x;\n   int y;\n} Point;\n\nECS_COMPONENT(world, Point);\n```\n\nAfter this macro, you are able to add the `Point` component using `ecs_add`:\n\n```c\necs_add(world, e, Point);\n```\n\nAdditionally, the component can be added and initialized with the `ecs_set` function:\n\n```c\necs_set(world, e, Point, {.x = 10, .y = 20});\n```\n\nFlecs components are stored internally as entities, which is why handles to components are of the `ecs_entity_t` type.\n\n[Learn more](Manual.md#components-and-types)\n\n### System\nA system is logic (a function) that is executed for every entity that has a set of components that match a system\'s interest. In flecs, systems specify their interest, and when they should run. To define a system, you can use the `ECS_SYSTEM` macro, which wraps around the `ecs_new_system` function:\n\n```c\nECS_SYSTEM(world, LogPoints, EcsOnUpdate, Point);\n```\n\nIn this statement, `LogPoints` refers to a C function that will be associated with the system. `EcsOnUpdate` identifies the stage in which the system is executed. The `Point` identifies the component interest expression. The system is implemented as a regular C function, like this:\n\n```c\nvoid LogPoints(ecs_rows_t *rows) {\n    Point *p = ecs_column(rows, Point, 1);\n    for (int i = 0; i < rows->count; i ++) {\n        printf("Log point (%d, %d)\\n", p[i].x, p[i].y);\n    }\n}\n```\n\nSystems can be enabled / disabled. By default a system is enabled. To enable or disable a system, you can use the `ecs_enable` function:\n\n```c\necs_enable(world, LogPoints, false);\n```\n\n[Learn more](Manual.md#systems)\n\n### Identifier\nEntities in flecs may have an optional string-based identifier. An identifier can be added to an entity by setting the `EcsId` component, like this:\n\n```c\necs_set(world, e, EcsId, {"MyEntity"});\n```\n\nAfter a string identifier is added, the entity can be looked up like this:\n\n```c\necs_entity_t e = ecs_lookup(world, "MyEntity");\n```\n\nAdditionally, applications can define entities with the `ECS_ENTITY` macro, which automatically adds `EcsId` and initializes it with the provided name:\n\n```c\nECS_ENTITY(world, MyEntity, Point);\n```\n\nComponents, systems, tasks, types and prefabs automatically register the `EcsId` component when they are created, and can thus be looked up with `ecs_lookup`.\n\n### Task\nA task is a system that has no interest expression. Tasks are run once every frame. Tasks are defined the same way as normal systems, but instead of an interest expression, you specify `0`:\n\n```c\nECS_SYSTEM(world, MyTask, EcsOnUpdate, 0);\n```\n\n### Type\nA type identifies a collection of `1..n` entities. In flecs, components and systems are assigned unique identifiers from the same pool as entities, and therefore a type may contain identifiers to entities, components and systems. Typical usecases for types are:\n\n- Group components so that they can be added to an entity with a single `ecs_add` call\n- Group systems so that they can be enabled or disabled with a single `ecs_enable` call\n\nTo define a type, you can use the `ECS_TYPE` macro, which wraps the `ecs_new_type` function:\n\n```c\nECS_TYPE(world, Circle, EcsCircle, EcsPosition2D);\n```\n\nThis defines a type called `Circle` that contains `EcsCircle` and `EcsPosition2D`. After this macro, you can use the `Circle` type with functions like `ecs_add` and `ecs_remove`:\n\n```c\necs_add(world, e, Circle);\n```\n\n[Learn more](Manual.md#components-and-types)\n\n### Feature\nA feature is a type that contains solely out of systems. To create features, use the `ECS_TYPE` macro or `ecs_new_type` function. This can be used to enable/disable multiple systems with a single API call, like so:\n\n```c\nECS_TYPE(world, MyFeature, SystemA, SystemB);\n\necs_enable(World, MyFeature, true);\n```\n\nA useful property of features (types) is that they can be nested, like so:\n\n```c\nECS_TYPE(world, MyNestedFeatureA, SystemA, SystemB);\nECS_TYPE(world, MyNestedFeatureB, SystemC);\nECS_TYPE(world, MyFeature, MyNestedFeatureA, MyNestedFeatureB);\n\necs_enable(World, MyFeature, true);\n```\n\n[Learn more](Manual.md#features)\n\n### Tag\nA tag is a component that does not contain any data. Internally it is represented as a component with data-size 0. Tags can be useful for subdividing entities into categories, without adding any data. A tag can be defined with the `ECS_TAG` macro:\n\n```c\nECS_TAG(world, MyTag);\n```\n\nTags can be added/removed like any other component:\n\n```c\necs_add(world, e, MyTag);\n```\n\n[Learn more](Manual.md#tags)\n\n### Container\nA container is an entity that can contain other entities. There are several methods to add a child entity to a container entity. The easiest way is with the `ecs_new_child` function:\n\n```c\necs_entity_t parent = ecs_new(world, 0);\necs_entity_t child = ecs_new_child(world, parent, 0);\n```\n\nAlternatively, you can add an entity to a container entity after its creation using `ecs_adopt`:\n\n```c\necs_entity_t parent = ecs_new(world, 0);\necs_entity_t child = ecs_new(world, 0);\necs_adopt(world, child, parent);\n```\n\nWith the `ecs_contains` function you can check whether an entity contains another entity:\n\n```c\nif (ecs_contains(world, parent, child) {\n    printf("entity %u is a child of %u\\n", child, parent);\n}\n```\n\nSystems can request components from containers. If a system requests component `EcsPosition2D` from a container, but an entity does not have a container, or the container does not have `EcsPosition2D`, the system will not match the entity. This system definition shows an example of how a system can access container components:\n\n```c\nECS_SYSTEM(world, MySystem, EcsOnUpdate, CONTAINER.Foo, Bar);\n```\n\n[Learn more](Manual.md#containers)\n\n### Prefab\nPrefabs are a special kind of entity that enable applications to reuse components values across entities. To create a prefab, you can use the `ECS_PREFAB` macro, or `ecs_new_prefab` function:\n\n```c\nECS_PREFAB(world, CirclePrefab, EcsCircle, EcsPosition2D);\n```\n\nThis defines a prefab with the `EcsCircle` and `EcsPosition2D` components. We can now add this prefab to regular entities:\n\n```c\necs_entity_t e1 = ecs_new(world, CirclePrefab);\necs_entity_t e2 = ecs_new(world, CirclePrefab);\n```\n\nThis will make the `EcsCircle` and `EcsPosition2D` components available on entities `e1` and `e2`, similar to a family. In contrast to types, component values of `EcsCircle` and `EcsPosition2D` are now shared between entities, and stored only once in memory. Since a prefab can be used as a regular entity, we can change the value of a prefab component with the `ecs_set` function:\n\n```c\necs_set(world, CirclePrefab, EcsCircle, {.radius = 10});\n```\n\nThis will change the value of `EcsCircle` across all entities that have the prefab. Entities can override component values from a prefab, by either adding or setting a component on themselves, using `ecs_add` or `ecs_set`. When a component is added using `ecs_add`, it will be initialized with the component value of the prefab.\n\n[Learn more](Manual.md#prefabs)\n\n### Module\nModules are used to group entities / components / systems. They can be imported with the `ECS_IMPORT` macro:\n\n```c\nECS_IMPORT(world, EcsComponentsTransform, 0);\n```\n\nThis will invoke the `EcsComponentsTransform` function, which will define the entities / components / systems. Furthermore, the macro will declare the variables to the entity / component / system handles to the local scope, so that they can be accessed by the code. \n\nIn large code bases modules can be used to organize code and limit exposure of internal systems to other parts of the code. Modules may be implemented in separate shared libraries, or within the same project. The only requirements for using the `ECS_IMPORT` macro is that the name of the module (`EcsComponentsTransform`) can be resolved as a C function with the right type. For an example on how to implement modules, see the implementation of one of the flecs modules (see above).\n\nModules can be imported multiple times without causing side effects.\n\n[Learn more](Manual.md#modules)\n\n'