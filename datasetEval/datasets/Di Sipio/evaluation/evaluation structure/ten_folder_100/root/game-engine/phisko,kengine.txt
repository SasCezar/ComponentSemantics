b'# Kengine \n\nThe Koala engine is a type-safe and self-documenting implementation of an Entity-Component-System (ECS), with a focus on runtime extensibility and compile-time type safety and clarity.\n\nThis new version features a greatly optimized memory architecture, better cache-efficiency, and a more advanced API.\n\n![koala](koala.png)\n\n## Installation\n\nThe engine uses Git submodules, and should therefore be cloned recursively with\n```\ngit clone https://github.com/phisko/kengine --recursive\n```\n\nAlternatively, the entire source code can be found in ZIP form in the latest release.\n\n## C++ version\n\nThe engine requires a **C++17** compiler.\n\n## Classes\n\n* [Entity](Entity.md): represents an in-game entity. Is simply a container of `Components`\n* [System](System.md): holds game logic. A `PhysicsSystem` might control the movement of `Entities`, for instance.\n* [EntityManager](EntityManager.md): manages `Entities`, `Components` and `Systems`\n\nNote that there is no `Component` class. Any type can be used as a `Component`, and dynamically attached/detached to `Entities`.\n\n### Reflection\n\nMany parts of the engine (such as the scripting systems or the OpenGL system) make use of `putils`\' [reflection API](https://github.com/phisko/putils/tree/master/reflection). Most of the components in the following samples are thus defined as reflectible.\n\n### Samples\n\nThese are pre-built, extensible and pluggable elements that can be used in any project, or to bootstrap a project.\n\n### Components\n\nGeneral purpose gamedev:\n* [TransformComponent](common/components/TransformComponent.md): defines a `Entity`\'s position and size\n* [PhysicsComponent](common/components/PhysicsComponent.md): defines a `Entity`\'s movement\n* [InputComponent](common/components/InputComponent.md): lets `Entities` receive keyboard and mouse events\n* [SelectedComponent](common/components/SelectedComponent.hpp): indicates that an `Entity` has been selected\n* [NameComponent](common/components/NameComponent.hpp): provides an `Entity`\'s name, e.g. for debug purposes\n\nBehaviors:\n* [BehaviorComponent](common/components/BehaviorComponent.md): defines a function to be called each frame for an `Entity`\n* [LuaComponent](common/components/LuaComponent.md): defines the lua scripts to be run by the `LuaSystem` for an `Entity`\n* [PyComponent](common/components/PyComponent.md): defines the Python scripts to be run by the `PySystem` for an `Entity`\n* [CollisionComponent](common/components/CollisionComponent.md): defines a function to be called when an `Entity` collides with another\n* [OnClickComponent](common/components/OnClickComponent.md): defines a function to be called when an `Entity` is clicked\n\nDebug tools:\n* [AdjustableComponent](common/components/AdjustableComponent.md): lets users modify variables through a GUI (such as the [ImGuiAdjustableManagerSystem](common/systems/ImGuiAdjustableSystem.md))\n* [ImGuiComponent](common/components/ImGuiComponent.md): lets `Entities` render debug elements using [ImGui](https://github.com/ocornut/imgui/)\n* [DebugGraphicsComponent](common/components/DebugGraphicsComponent.hpp): lets an `Entity` be used to draw debug information (such as lines, rectangles or spheres)\n\nGraphics:\n* [GraphicsComponent](common/components/GraphicsComponent.md): specifies the appearance of an `Entity`\n* [ModelComponent](common/components/ModelComponent.md): describes a model file (be it a 3D model, a 2D sprite or any other graphical asset)\n* [CameraComponent](common/components/CameraComponent.hpp): lets `Entities` be used as in-game cameras, to define a frustrum and position. Follows the same conventions as `TransformComponent`\n* [GUIComponent](common/components/GUIComponent.md): lets `Entities` be used as GUI elements such as buttons, lists...)\n\n3D Graphics:\n* [HighlightComponent](common/components/HighlightComponent.md): indicates that an `Entity` should be highlighted\n* [LightComponent](common/components/LightComponent.md): lets `Entities` be used as in-game light sources (directional lights, point lights or spot lights)\n* [ShaderComponent](common/components/ShaderComponent.md): lets `Entities` be used to introduce new OpenGL shaders\n* [PolyVoxComponent](common/components/PolyVoxComponent.md): lets `Entities` be used to generate voxel-based models, drawn by the `PolyVoxSystem`\n* [SkyBoxComponent](common/components/SkyBoxComponent.hpp): lets `Entities` be used to draw a skybox\n* [SpriteComponent](common/components/SpriteComponent.hpp): indicates that an `Entity`\'s `GraphicsComponent` describes a 2D or 3D sprite\n* [TextComponent](common/components/TextComponent.hpp): indicates that an `Entity`\'s `GraphicsComponent` describes a 2D or 3D text\n\nSkeletal animation:\n* [AnimationComponent](common/components/AnimationComponent.md): provides skeletal animation information for `Entities`.\n* [SkeletonComponent](common/components/SkeletonComponent.hpp): provides bone information for an `Entity`\'s skeletal animation\n\nPhysics:\n* [ModelColliderComponent](common/components/ModelColliderComponent.md): attached to an `Entity` with a [ModelComponent](common/components/ModelComponent.md). Describes the colliders associated with a given model.\n\n### Systems\n\nBehaviors:\n* [BehaviorSystem](common/systems/BehaviorSystem.md): executes behaviors attached to `Entities`\n* [LuaSystem](common/systems/LuaSystem.md): executes lua scripts attached to an entity\n* [PySystem](common/systems/PySystem.md): executes Python scripts attached to an entity\n* [CollisionSystem](common/systems/CollisionSystem.md): transfers collision notifications to `Entities`\n* [OnClickSystem](common/systems/OnClickSystem.md): transfers click notifications to `Entities`\n\nDebug tools:\n* [ImGuiAdjustableSystem](common/systems/ImGuiAdjustableSystem.md): displays an ImGui window to edit `AdjustableComponents`\n* [ImGuiEntityEditorSystem](common/systems/ImGuiEntityEditorSystem.md): displays ImGui windows to edit `Entities` with a `SelectedComponent`\n* [ImGuiEntitySelectorSystem](common/systems/ImGuiEntitySelectorSystem.md): displays an ImGui window that lets users search for and select `Entities`\n* [LogSystem](common/systems/LogSystem.md): logs messages\n\nGraphics:\n* [SfSystem](common/systems/sfml/SfSystem.md): displays entities in an SFML render window\n\n3D Graphics:\n* [OpenGLSystem](common/systems/opengl/OpenGLSystem.md): displays entities in an OpenGL render window\n* [OpenGLSpritesSystem](common/systems/opengl_sprites/OpenGLSpritesSystem.md): loads sprites and provides shaders to render them \n* [AssimpSystem](common/systems/assimp/AssimpSystem.md): loads 3D models using the assimp library, animates them and provides shaders to render them\n* [PolyVoxSystem](common/systems/polyvox/PolyVoxSystem.md): generates 3D models based on `PolyVoxComponents` and provides shaders to render them\n* [MagicaVoxelSystem](common/systems/polyvox/PolyVoxSystem.md): loads 3D models in the MagicaVoxel ".vox" format, which can then be drawn by the `PolyVoxSystem`\'s shader\n\nPhysics:\n* [BulletSystem](common/systems/bullet/BulletSystem.md): simulates physics using Bullet Physics\n\nSome of these systems make use of libraries which you may not want to compile, and are therefore optional. To enable them, set the corresponding CMake variable to `true` in your `CMakeLists.txt`:\n\n| System         | Variable        |\n|----------------|-----------------|\n| SfSystem       | KENGINE_SFML    |\n| OpenGLSystem   | KENGINE_OPENGL  |\n| AssimpSystem   | KENGINE_ASSIMP  |\n| PolyVoxSystem  | KENGINE_POLYVOX |\n| MagicaVoxelSystem | KENGINE_POLYVOX |\n| lua library    | KENGINE_LUA     |\n| python library | KENGINE_PYTHON  |\n\n### DataPackets\n\nThese are datapackets sent from one `System` to another to communicate.\n\n* [AddImGuiTool](common/packets/AddImGuiTool.hpp): received by the graphics system, adds an entry to the "Tools" section of the ImGui main menu bar\n* [ImGuiScale](common/packets/ImGuiScale.hpp): sent by some graphics systems, provides a reference to a `float` that should be used to scale all ImGui elements (for special DPI screens)\n* [Collision](common/packets/Collision.hpp): sent by the `BulletSystem`, indicates a collision between two `Entities`\n* [QueryPosition](common/packets/Collision.hpp): handled by the `BulletSystem`, provides a list of `Entities` found within an area\n* [EntityInPixel](common/packets/EntityInPixel.hpp): handled by the `OpenGLSystem`, returns the ID of the entity seen in the requested pixel\n* [GBuffer](common/packets/GBuffer.hpp): received by the `OpenGLSystem`, specifies the layout of the GBuffer (used in deferred shading)\n* [Log](common/packets/Log.hpp): received by the `LogSystem`, used to log a message\n* [RegisterAppearance](common/packets/RegisterAppearance.hpp): received by the `SfSystem`, maps an abstract appearance to a concrete texture file.\n\n### Helpers\n\n* [ShaderHelper](common/systems/opengl/ShaderHelper.hpp): provides helper functions and RAII structs for OpenGL shaders\n* [SkeletonHelper](common/helpers/SkeletonHelper.hpp): provides helper functions when manipulating `SkeletonComponents`\n* [RegisterComponentFunctions](common/helpers/RegisterComponentFunctions.hpp): registers `ComponentFunctions` for querying an `Entity`\'s components (`has`, `attach`, `detach`)\n* [RegisterComponentEditor](common/helpers/RegisterComponentEditor.hpp): registers `ComponentFunctions` for displaying and editing a `Component` in ImGui \n* [RegisterComponentMatcher](common/helpers/RegisterComponentMatcher.hpp): registers a `ComponentFunction` for matching a `Component`\'s attributes with a string\n\nThese are helper functions to factorize typical manipulations of `Components`.\n\n\n## ComponentFunctions\n\n```\nThis is an advanced feature and understanding this is absolutely not required to make use of the engine,\nalthough those of you looking to make the most of runtime extensibility and compile-time type-safety\nshould be interested in this.\n```\n\nOne of the main goals of this engine is to be as runtime-extensible as possible, while also allowing developers to perform type-based metaprogramming for things such as serialization or object inspection.\n\nTo make this possible, a "ComponentFunction" mechanism is in place. A `ComponentFunction` is a function pointer provided to the `EntityManager`, which matches a given `Component` for a given functionality. It will typically be a function template\'s specialization for that `Component`. `ComponentFunctions` are provided by calling `registerComponentFunction`, and can then be accessed through `getComponentFunctionMaps`.\n\nThe framework is a bit hard to wrap one\'s head around, so here is an example of a final use case:\n\n```cpp\n// This is a `ComponentFunction` with the `void(const putils::json &, kengine::Entity &)` prototype\n//                Think of this as a C++ function DECLARATION\nstruct LoadFromJSON : functions::BaseFunction<void(const putils::json &, kengine::Entity &)>;\n\nEntityManager em;\n\n// This is the implementation of the `ComponentFunction` that is going to be given to the `EntityManager`\n//                Think of this as a C++ function DEFINITION\ntemplate<typename Comp>\nvoid loaderImpl(const putils::json &, Entity & e) {\n    // really complicated loader code\n    e.attach<Comp>();\n}\n\nvoid registerComponentLoaders() {\n    // provide the `EntityManager` with the JSON loading implementation for the `Components` I\'ll use\n    // This says: for `TransformComponent3f`, people asking for `LoadFromJSON` will get `loaderImpl<TransformComponent3f>`\n    em.registerComponentFunction<TransformComponent3f>(LoadFromJSON{ loaderImpl<TransformComponent3f> });\n    em.registerComponentFunction<GraphicsComponent>(LoadFromJSON{ loaderImpl<GraphicsComponent> });\n}\n\nvoid loadEntityFromJSON(Entity & e, const putils::json & json) {\n    for (const auto comp : em.getComponentFunctionMaps()) { // For each known `Component` type\n        const auto loader = comp->getFunction<LoadFromJSON>(); // Try to get its `LoadFromJSON` implementation\n        if (loader != nullptr) // If an implementation was provided\n            loader(json, e); // I can call it!\n    }\n}\n```\n\n`ComponentFunctions` are identified by their type. This type must inherit from [BaseFunction](common/functions/BaseFunction.hpp), which takes as a template parameter the function signature. The type doesn\'t need to contain any implementation of the actual function, as it will only be used to __identify__ the function. Think of this as a C++ function __declaration__.\n\nTo register a `ComponentFunction`\'s implementation for a specific type, `registerComponentFunction` must be called, taking as parameter the `ComponentFunction`, constructed with the actual function template specialization. The `EntityManager` then stores these `typeid -> function pointer` pairings in a __ComponentFunctionMap__ for each `Component`.\n\nThe `ComponentFunctionMaps` can then be retrieved by calling `getComponentFunctionMaps()`, and have a `getFunction<ComponentFunction>()` member function that will return the registered function pointer, or `nullptr`.\n\nExample `ComponentFunctions` are provided in `common/functions`. They each come with a helper function that registers the `ComponentFunction`\'s implementation.\n\n| Name | Helper | Function |\n|------|--------|----------|\n| [Has, Attach, Detach](common/functions/Basic.hpp) | [registerComponentFunctions](common/helpers/RegisterComponentFunctions.hpp) | Call `Entity::has<Component>`, `Entity::attach<Component>` and `Entity::detach<Component>`|\n| [LoadFromJSON](common/functions/LoadFromJSON.hpp) | [registerComponentJSONLoader](common/helpers/RegisterComponentJSONLoader.hpp) | Unserializes the `Component` from JSON and adds it to the `Entity` |\n| [MatchString](common/functions/MatchString.hpp) | [registerComponentMatcher](common/helpers/RegisterComponentMatcher.hpp) | Returns whether any of the `Component`\'s attributes matches a given string |\n| [ImGuiEditor](common/functions/ImGuiEditor.hpp) | [registerComponentEditor](common/helpers/RegisterComponentEditor.hpp) | Displays the `Component` using ImGui |\n\nIf you wish to see concrete examples of this system in use, take a look at the [ImGuiEntityEditorSystem](common/systems/ImGuiEntityEditorSystem.hpp) or the [ImGuiEntitySelectorSystem](common/systems/ImGuiEntitySelectorSystem.hpp).\n\n## Example\n\nBelow is a commented main function that creates an entity and attaches some components to it, as well as a lua script. This should let you get an idea of what is possible using the kengine\'s support for reflection and runtime extensibility, as well as the compile-time clarity and type-safety that were the two motivations behind the project.\n\n##### main.cpp\n\n```cpp\n#include <iostream>\n\n#include "go_to_bin_dir.hpp"\n\n#include "EntityManager.hpp"\n#include "Entity.hpp"\n\n#include "systems/LuaSystem.hpp"\n#include "components/GraphicsComponent.hpp"\n#include "components/TransformComponent.hpp"\n\n// Simple system that outputs the transform and lua components of each entity that has them\nclass DebugSystem : public kengine::System<DebugSystem> {\npublic:\n    DebugSystem(kengine::EntityManager & em) : System<DebugSystem>(em), _em(em) {}\n\n    void execute() final {\n        for (const auto & [e, transform, lua] : _em.getEntities<kengine::TransformComponent3f, kengine::LuaComponent>()) {\n            std::cout << "Entity " << e.id << \'\\n\';\n\n            std::cout << "\\tTransform: " << transform.boundingBox << \'\\n\';\n\n            std::cout << "\\tScripts:" << \'\\n\';\n            for (const auto & script : lua.getScripts())\n                std::cout << "\\t\\t[" << script << "]\\n";\n\n            std::cout << \'\\n\';\n        }\n    }\n\nprivate:\n\tkengine::EntityManager & _em;\n};\n\nint main(int, char **av) {\n    // Go to the executable\'s directory to be next to resources and scripts\n    putils::goToBinDir(av[0]);\n\n    // Create an EntityManager\n    kengine::EntityManager em; // Optionally, pass a number of threads as parameter (kengine::EntityManager em(4);)\n\n    // Load the specified systems, and any plugin placed in the executable\'s directory\n    //      If you specify \'KENGINE_SFML\' as TRUE in your CMakeLists.txt, this will load the SfSystem\n    em.loadSystems<DebugSystem, kengine::LuaSystem>(".");\n\n    // To add a new system, simply add a DLL with a\n    //      `ISystem *getSystem(kengine::EntityManager &em)`\n    // To add a new system, simply add a DLL with a\n\n    // Create an Entity and attach Components to it\n    em += [](kengine::Entity e) {\n        e += kengine::TransformComponent3f({ 42.f, 0.f, 42.f }); // Parameter is a Point3f for position\n        e += kengine::LuaComponent({ "scripts/unit.lua" }); // Parameter is a vector of scripts\n    };\n\n\t// Register types to be used in lua\n    try {\n        auto &lua = em.getSystem<kengine::LuaSystem>();\n        lua.registerTypes<\n            kengine::TransformComponent3f, putils::Point<float, 3>, putils::Rect<float, 3>,\n            kengine::LuaComponent\n        >();\n    }\n    catch (const std::out_of_range &) {} // If the LuaSystem wasn\'t found, ignore\n\n    // Start game\n    while (em.running)\n        em.execute();\n\n    return (EXIT_SUCCESS);\n}\n```\n\n##### scripts/unit.lua\n\n```lua\n-- Simply modify component\n\nlocal transform = self:getTransformComponent()\nlocal pos = transform.boundingBox.position\npos.x = pos.x + 1\n```\n'