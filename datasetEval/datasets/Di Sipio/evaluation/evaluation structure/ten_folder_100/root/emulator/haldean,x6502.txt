b"+-------------------------------------------------------------+\n|                                                             |\n|                           x6502                             |\n|                 a simple 6502 CPU emulator                  |\n|                                                             |\n+-------------------------------------------------------------+\n\n    x6502 is an emulator for the 6502 class of processors.\n    It currently supports the full instruction set of the\n    6502 (plus a few extensions) and has a rudimentary\n    simulated I/O bus. It should be able to run arbitrary\n    x6502 bytecode with ``correct'' results, although most\n    binaries for common 6502 systems (Atari, C64, Apple II,\n    etc) won't function as expected, since they expect I/O\n    devices to be mapped into memory where there are\n    currently none.\n\n    x6502 is freely available under the original 4-clause\n    BSD license, the full text of which is included in the\n    LICENSE file.\n\nBuilding and running x6502\n\n    To build x6502, just run `make' in the project root. You\n    will need clang and Python installed. To use gcc, change\n    the $(CC) var in the Makefile. No libraries beyond POSIX\n    libc are used. This will produce the x6502 binary.\n\n    x6502 takes the compiled 6502 object file as an\n    argument, and runs it until it encounters an EXT\n    instruction (EXT instructions are an extension to 6502\n    bytecode, see below). You can use any 6502 assembler to\n    compile to 6502 bytecode; `xa' is one that is bundled\n    with Debian-based distros. Note that, by default, x6502\n    loads code in at address 0x1000; you therefore need to\n    either tell your assembler that that's the base address\n    for the text section of your binary or override the\n    default load address using the `-b' flag of x6502. Note\n    that 0x1000 is the default load address for the `xa'\n    assembler.\n\n    If you want to compile a version of x6502 that dumps\n    machine state after every instruction, run `make debug'\n    instead of `make'. This will also disable compiler\n    optimizations. This mode really does not play nice with\n    vterm mode, so be warned.\n\nExtensions to the 6502 instruction set\n\n    x6502 recognizes two instructions that are not in the\n    original 6502 instruction set. These are:\n\n        DEBUG (0xFC): prints debugging information about the\n                      current state of the emulator\n        EXT (0xFF):   stops the emulator and exits\n\n    Both of these are defined as macros in `stdlib/stdio.s'.\n    To disable these extensions, compile with\n    -DDISABLE_EXTENSIONS (right now, this can be done by\n    adding that flag to the Makefile).\n\n    This also implements a subset of the 65C02 and 65C816\n    instruction set, in particular the WAI (0xCB)\n    instruction. The WAI instruction pauses the emulator\n    until an I/O interrupt is thrown.\n\nI/O memory map:\n\n    There are four I/O devices right now: a character input\n    device, a character output device, a virtual terminal\n    and a block device. Convenience constants and macros for\n    the character I/O devices are defined in\n    `stdlib/stdio.s' for use in user programs. Add stdlib to\n    your include path and then add `#include <stdio.s>' to\n    your program to use these constants.\n\n    I/O options are controlled by setting bits on the I/O\n    flag byte at address 0xFF02. The current set of\n    supported flags are:\n\n        VTERM_ENABLE (0x01):\n            when set, activates vterm mode.\n        WAIT_HALT (0x02):\n            when set, waits for a keypress input before\n            terminating upon receiving an EXT instruction.\n            Non-vterm applications will probably want to set\n            this flag, as some implementations of ncurses\n            will clear the display when the emulator exits.\n\n    When outputting characters, you can control the\n    ``paint'' with which the characters are drawn. You can\n    do so by modifying the PAINT flag at location 0xFEE8.\n    Paints are an OR-ing of a color (bottom 4 bits) and a\n    style (top 4 bits). Supported colors are:\n\n                PAINT_BLACK         0x00\n                PAINT_RED           0x01\n                PAINT_GREEN         0x02\n                PAINT_YELLOW        0x03\n                PAINT_BLUE          0x04\n                PAINT_MAGENTA       0x05\n                PAINT_CYAN          0x06\n                PAINT_WHITE         0x07\n\n    Supported styles are:\n\n                PAINT_DIM           0x20\n                PAINT_UNDERLINE     0x40\n                PAINT_BOLD          0x80\n\n    Thus, as an example, an underlined, bold green character\n    would have paint 0xC2.\n\nI/O devices:\n\n    The character output device is mapped to 0xFF00. Any\n    character written to FF00 is immediately echoed to the\n    terminal.\n\n    The character input device is mapped to 0xFF01. When a\n    character is available on standard in, an interrupt is\n    raised and FF01 is set to the character that was\n    received. Note that one character is delivered per\n    interrupt; if the user types ``abc'', they will get\n    three interrupts one after the other.\n\n    The virtual terminal is activated by setting the\n    VTERM_ENABLE bit on the IO flag byte. After the flag is\n    set, the data in memory addresses 0xFB00 through 0xFEE7\n    are mapped to a 40x25 grid in the host terminal. Data in\n    this region is stored in row-major format, and any write\n    will trigger a refresh of the vterm.\n\n    Note that even in vterm-mode, the putchar-esque\n    character output device is still usable, and will put\n    the character at the position directly after the\n    position of the last write.\n\n    A commented example of how to use the character I/O\n    capabilities of x6502 is provided in\n    sample_programs/echo.s, and an example of a vterm\n    application is provided in sample_programs/spam.s\n\n    A block device can be mapped in with control addresses\n    at 0xFF03 through 0xFF07. To use the block device, you\n    must specify a binary disk image to back the device\n    using the -d flag. To read from the block device, write\n    an address in the disk image to 0xFF03 and 0xFF04, with\n    the low byte in 0xFF03. The value at that location in\n    the disk image will be written to 0xFF05, which your\n    program can then read. To write, set the memory address\n    to write to using the same method, then write the\n    desired byte to 0xFF06. If any of these operations\n    return an error, the byte at 0xFF07 will be nonzero.\n\nReading the source\n\n    x6502 was written to be easy to understand and read. A\n    good place to start is `cpu.h', which defines a few\n    constants used throughout the code (mostly around CPU\n    flags) as well as the `cpu' struct, which is used pretty\n    much everywhere.\n\n    `emu.c' is where the interesting stuff happens; this is\n    the main loop of the emulator where opcodes are decoded\n    as dispatched. It also handles interrupts and calls out\n    to I/O handlers.\n\n    The code for actual opcode interpretation is a little\n    strange; there are lots of ``header'' files in the\n    opcode_handlers directory that are not really header\n    files at all. These files all contain code for handling\n    opcode parsing and interpretation; with over 150\n    opcodes, having all of the code to handle these in one\n    file would be excessive and difficult to navigate, and\n    dispatching out to functions to handle each opcode\n    carries unnecessary overhead in what should be the\n    tightest loop in the project. Thus, each of these header\n    files is #included in emu.c in the middle of a switch\n    statement, and gets access to the local scope within the\n    main_loop function. It's weird but it gets the job done,\n    and is the least bad of all considered options.\n\n    The opcode handlers all use convenience functions\n    defined in `functions.h', most of which are for the\n    various addressing modes of the 6502 or for dealing with\n    CPU flags.\n\n    `io.c' is where the I/O bus lives; this is where we\n    check to see if the emulated character device has been\n    written to and where we raise an interrupt if we've\n    gotten input from stdin.\n\n    `generate_debug_names.py' reads the `opcodes.h' header\n    and generates `debug-names.h', which contains a mapping\n    from opcode to a string representation of that opcode.\n    It's only used when dumping CPU state, either because\n    the DEBUG flag was set at compile time or because a\n    DEBUG instruction was hit in the binary.\n\n    The rest of the files are pretty boring; `main.c' is\n    pretty much only responsible for loading bytecode into\n    memory and parsing command line arguments and `debug.c' is\n    used to provide the `dump_cpu' function, which is a\n    fascinating function consisting of almost nothing but\n    printfs.\n\nTODO:\n    - support buffered input, where the program can read\n      more than one input character at once.\n\nTHANKS:\n    - voltagex on Github for sending me a patch to improve\n      the sample_programs readme.\n    - anatoly on HN for suggesting I add a bit on source\n      code structure to the README.\n    - shalmanese for coffee and pie.\n    - daumiller for finding the subtraction bug.\n"