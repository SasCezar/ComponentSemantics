b'# Ethereum Ruby library - Ethereum.rb\n\n[![Build Status](https://travis-ci.org/EthWorks/ethereum.rb.svg?branch=master)](https://travis-ci.org/EthWorks/ethereum.rb) [![security](https://hakiri.io/github/NullVoxPopuli/MetaHash/master.svg)](https://hakiri.io/github/NullVoxPopuli/MetaHash/master) [![Dependency Status](https://gemnasium.com/marekkirejczyk/ethereum.rb.svg)](https://gemnasium.com/marekkirejczyk/ethereum.rb) [![Code Climate](https://codeclimate.com/github/marekkirejczyk/ethereum.rb/badges/gpa.svg)](https://codeclimate.com/github/marekkirejczyk/ethereum.rb)\n\nThe goal of ethereum.rb is to make interacting with ethereum blockchain from ruby as fast and easy as possible (but not easier!).\n\n## Looking for new maintainer\nAs we changed our technological stack away from ruby and we are not using ethereum.rb anymore. The gem suffered from neglect. We are looking for person/people who would like to take over developing and maintaining. Ideally, someone who uses it and who already worked with code quite a bit.\nIf you are interested send an email to marek@ethworks.io.\n\n## Highlights\n\n* Simple syntax, programmer friendly\n* Deploy and interact with contracts on the blockchain\n* Contract - ruby object mapping to solidity contract\n* Signing transactions with [ruby-eth](https://github.com/se3000/ruby-eth) gem.\n* Compile Solidity contracts with solc compiler from ruby\n* Receive events from contract\n* Make direct json rpc calls to node from ruby application\n* Connect to node via IPC or HTTP\n* Helpful rake tasks for common actions\n\n## Installation\n\nBefore installing gem make sure you meet all [prerequisites](https://github.com/marekkirejczyk/ethereum.rb/blob/master/PREREQUISITES.md), especially that you have:\n* compatible ethereum node installed\n* compatible solidity compiler installed\n* wallet with some ethereum on it\n\nBefore you run a program check that the node is running and accounts you want to spend from are unlocked.\n\nTo install gem simply add this line to your application\'s Gemfile:\n\n```ruby\ngem \'ethereum.rb\'\n```\n\nAnd then execute:\n\n    $ bundle\n\nOr install it yourself as:\n\n    $ gem install ethereum.rb\n\n## Basic Usage\n\nYou can create contract from solidity source and deploy it to the blockchain, with following code:\n\n```ruby\ncontract = Ethereum::Contract.create(file: "greeter.sol")\naddress = contract.deploy_and_wait("Hello from ethereum.rb!")\n```\n\nDeployment may take up to couple of minutes. Once deployed you can start interacting with contract, e.g. calling it\'s methods:\n\n```ruby\ncontract.call.greet # => "Hello from ethereum.rb!"\n```\n\nYou can see example contract [greeter here](https://github.com/marekkirejczyk/ruby_ethereum_example/blob/master/contracts/greeter.sol).\n\n## Smart contracts\n\n### Compile multiple contracts at once\n\nIf you want to complie multiple contracts at once, you can create new instances using newly declared ruby clasess:\n\n```ruby\nEthereum::Contract.create(file: "mycontracts.sol", client: client)\ncontract = MyContract1.new\ncontract = contract.deploy_and_wait\ncontract2 = MyContract2.new\ncontract2 = contract.deploy_and_wait\n```\n\nAll names used to name contract in solidity source will translate to name of classes in ruby (camelized).\n\nNote: If class of given name exist it will be undefined first to avoid name collision.\n\n### Get contract from blockchain\n\nThe other way to obtain contract instance is get one that already exist in the blockchain. To do so you need a contract name, contract address and ABI definition.\n\n```ruby\ncontract = Ethereum::Contract.create(name: "MyContract", address: "0x01a4d1A62F01ED966646acBfA8BB0b59960D06dd ", abi: abi)\n```\n\nNote that you need to specify contract name, that will be used to define new class in ruby, as it is not a part of ABI definition.\n\nAlternatively you can obtain abi definition and name from contract source file:\n\n```ruby\ncontract = Ethereum::Contract.create(file: "MyContract.sol", address: "0x01a4d1A62F01ED966646acBfA8BB0b59960D06dd ")\n```\n\nIf you want to create new contract, that is not yet deployed from ABI definition you will need also to supply binary code:\n\n```ruby\ncontract = Ethereum::Contract.create(name: "MyContract", abi: abi, code: "...")\n```\n\n### Simple Truffle integration\n\nIf you use Truffle to build and deploy contracts, you can pick up the Truffle artifacts to initialize\na contract. For example, if you have a MyContract in the Truffle directory at `/my/truffle/project`:\n\n```ruby\ncontract = Ethereum::Contract.create(name: "MyContract", truffle: { paths: [ \'/my/truffle/project\' ] }, client: client, address: \'0x01a4d1A62F01ED966646acBfA8BB0b59960D06dd\')\n```\n\nThe contract factory will attempt to load the deployed address from the Truffle artifacts if the client\'s network is present:\n\n```ruby\ncontract = Ethereum::Contract.create(name: "MyContract", truffle: { paths: [ \'/my/truffle/project\' ] }, client: client)\n```\n\n### Interacting with contract\n\nFunctions defined in a contract are exposed using the following conventions:\n\n```ruby\ncontract.transact.[function_name](params)\ncontract.transact_and_wait.[function_name](params)  \ncontract.call.[function_name](params)\n```\n\n**Example Contract in Solidity**\n```\ncontract SimpleRegistry {\n  event LogRegister(bytes32 key, string value);\n  mapping (bytes32 => string) public registry;\n\n  function register(bytes32 key, string value) {\n    registry[key] = value;\n    LogRegister(key, value);\n  }\n\n  function get(bytes32 key) public constant returns(string) {\n    return registry[key];\n  }\n\n}\n```\n\nFor contract above here is how to access it\'s methods:\n\n```ruby\ncontract.transact_and_wait.register("performer", "Beastie Boys")\n```\n\nWill send transaction to the blockchain and wait for it to be mined.\n\n```ruby\ncontract.transact.register("performer", "Black Eyed Peas")\n```\n\nWill send transaction to the blockchain return instantly.\n\n```ruby\ncontract.call.get("performer") # => "Black Eyed Peas"\n```\n\nWill call method of the contract and return result.\nNote that no transaction need to be send to the network as method is read-only.\nOn the other hand `register` method will change contract state, so you need to use `transact` or `transact_and_wait` to call it.\n\n### Receiving Contract Events\n\nUsing the example smart contract described above, one can listen for `LogRegister` events by using filters.\n\nYou can get a list of events from a certain block number to the latest:\n\n```ruby\nrequire \'ostruct\'\n\nevent_abi = contract.abi.find {|a| a[\'name\'] == \'LogRegister\'}\nevent_inputs = event_abi[\'inputs\'].map {|i| OpenStruct.new(i)}\ndecoder = Ethereum::Decoder.new\n\nfilter_id = contract.new_filter.log_register(\n  {\n    from_block: \'0x0\',\n    to_block: \'latest\',\n    address: \'0x....\',\n    topics: []\n  }\n)\n\nevents = contract.get_filter_logs.log_register(filter_id)\n\nevents.each do |event|\n  transaction_id = event[:transactionHash]\n  transaction = ethereum.eth_get_transaction_receipt(transaction_id)\n  args = decoder.decode_arguments(event_inputs, entry[\'data\'])\n  puts "#{transaction.inspect} with args: #{args}"\nend\n```\n\n### IPC Client Connection\n\nBy default methods interacting with contracts will use default Json RPC Client that will handle connection to ethereum node.\nDefault client communicate via IPC. If you want to create custom client or use multiple clients you can create them yourself.\n\nTo create IPC client instance of simply create Ethereum::IpcClient:\n\n```ruby\nclient = Ethereum::IpcClient.new\n```\n\nYou can also customize it with path to ipc file path and logging flag:\n\n```ruby\nclient = Ethereum::IpcClient.new("~/.parity/mycustom.ipc", false)\n```\n\nIf no ipc file path given, IpcClient looks for ipc file in default locations for parity and geth.\nThe second argument is optional. If it is true then logging is on.\n\nBy default logging is on and logs are saved in "/tmp/ethereum_ruby_http.log".\n\nTo create Http client use following:\n\n```ruby\nclient = Ethereum::HttpClient.new(\'http://localhost:8545\')\n```\n\nYou can supply client when creating a contract:\n\n```ruby\ncontract = Ethereum::Contract.create(client: client, ...)\n```\n\nYou can also obtain default client:\n\n```ruby\nclient = Ethereum::Singleton.instance\n```\n\n### Calling json rpc methods\n\nEthereum.rb allows you to interact directly with Ethereum node using json rpc api calls.\nApi calls translates directly to client methods. E.g. to call `eth_gasPrice` method:\n\n```ruby\nclient.eth_gas_price # => {"jsonrpc"=>"2.0", "result"=>"0x4a817c800", "id"=>1}\n```\n\nNote: methods are transated to underscore notation.\n\nFull list of json rpc methods is available [here](https://github.com/ethereum/wiki/wiki/JSON-RPC#user-content-json-rpc-methods)\n\n### Signed transactions\n\nEthereum.rb supports signing transactions with key using [ruby-eth gem](https://github.com/se3000/ruby-eth).\n\nTo create a new key simply do the following:\n\n```ruby\nkey = Eth::Key.new\n```\n\nThen you can use the key to deploy contracts and send transactions, i.e.:\n\n```ruby\ncontract = Ethereum::Contract.create(file: "...")\ncontract.key = key\ncontract.deploy_and_wait("Allo Allo!")\ncontract.transact_and_wait.set("greeting", "Aloha!")\n```\n\nYou can also transfer ether transfer using custom keys:\n\n```ruby\nclient.transfer(key, "0x342bcf27DCB234FAb8190e53E2d949d7b2C37411", amount)\nclient.transfer_and_wait(key, "0x949d7b2C37411eFB763fcDCB234FAb8190e53E2d", amount)\n```\n\n### Custom gas price and gas limit\n\nYou can change gas price or gas limit in the client:\n\n```ruby\nclient.gas_limit = 2_000_000_\nclient.gas_price = 24_000_000_000\n```\n\nor per contract:\n```ruby\ncontract.gas_limit = 2_000_000_\ncontract.gas_price = 24_000_000_000\n```\n\n## Utils\n\n### Url helpers for rails applications\n\nOften in the application you want to link to blockchain explorer. This can be problematic if you want links to work with different networks (ropsten, mainnet, kovan) depending on environment you\'re working on.\nFollowing helpers will generate link according to network connected:\n\n```ruby\nlink_to_tx("See the transaction", "0x3a4e53b01274b0ca9087750d96d8ba7f5b6b27bf93ac65f3174f48174469846d")\nlink_to_address("See the wallet", "0xE08cdFD4a1b2Ef5c0FC193877EC6A2Bb8f8Eb373")\n```\nThey use [etherscan.io](http://etherscan.io/) as a blockexplorer.\n\nNote: Helpers work in rails environment only, works with rails 5.0+.\n\n### Utils rake tasks\n\nThere are couple of rake tasks to help in wallet maintenance, i.e.:\n\n```ruby\nrake ethereum:contract:deploy[path]             # Compile and deploy contract\nrake ethereum:contract:compile[path]            # Compile a contract\nrake ethereum:transaction:byhash[id]            # Get info about transaction\nrake ethereum:transaction:send[address,amount]  # Send [amount of] ether to an account\n```\n\n## Debbuging\nLogs from communication between ruby app and node are available under following path:\n```\n/tmp/ethereum_ruby_http.log\n```\n\n## Roadmap\n\n* Rubydoc documentation\n\n## Development\n\nRun `bin/console` for an interactive prompt that will allow you to experiment.\n\nMake sure `rake ethereum:test:setup` passes before running tests.\n\nThen, run `rake spec` to run the tests.\n\nTest that do send transactions to blockchain are marked with `blockchain` tag. Good practice is to run first fast tests that use no ether and only if they pass, run slow tests that do spend ether. To do that  use the following line:\n\n```bash\n$ bundle exec rspec --tag ~blockchain && bundle exec rspec --tag blockchain\n```\n\nYou need ethereum node up and running for tests to pass and it needs to be working on testnet (Ropsten).\n\n## Acknowledgements and license\n\nThis library has been forked from [ethereum-ruby](https://github.com/DigixGlobal/ethereum-ruby) by DigixGlobal Pte Ltd (https://dgx.io).\n\nThe gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\n'