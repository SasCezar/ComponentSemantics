b'# DotNetCoreArchitecture\n\nThis project is an example of architecture using new technologies and best practices.\n\nThe goal is to share knowledge and use it as reference for new projects.\n\nThanks for enjoying!\n\n## Build\n\n[![Build status](https://dev.azure.com/rafaelfgx/DotNetCoreArchitecture/_apis/build/status/DotNetCoreArchitecture)](https://dev.azure.com/rafaelfgx/DotNetCoreArchitecture/_apis/build/status/DotNetCoreArchitecture)\n\n## Code Analysis\n\n[![Codacy Badge](https://api.codacy.com/project/badge/Grade/3d1ea5b1f4b745488384c744cb00d51e)](https://www.codacy.com/app/rafaelfgx/DotNetCoreArchitecture?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=rafaelfgx/DotNetCoreArchitecture&amp;utm_campaign=Badge_Grade)\n\n## Technologies\n\n* [.NET Core 3.0](https://dotnet.microsoft.com/download)\n* [ASP.NET Core 3.0](https://docs.microsoft.com/en-us/aspnet/core)\n* [Entity Framework Core 3.0](https://docs.microsoft.com/en-us/ef/core)\n* [C# 8.0](https://docs.microsoft.com/en-us/dotnet/csharp)\n* [Angular 8.2](https://angular.io/docs)\n* [Typescript 3.5.3](https://www.typescriptlang.org/docs/home.html)\n* [HTML](https://www.w3schools.com/html)\n* [CSS](https://www.w3schools.com/css)\n* [SASS](https://sass-lang.com)\n* [UIkit](https://getuikit.com/docs/introduction)\n* [JWT](https://jwt.io)\n* [FluentValidation](https://fluentvalidation.net)\n* [Scrutor](https://github.com/khellang/Scrutor)\n* [Serilog](https://serilog.net)\n* [Docker](https://docs.docker.com)\n* [Azure DevOps](https://dev.azure.com)\n\n## Practices\n\n* Clean Code\n* SOLID Principles\n* DDD (Domain-Driven Design)\n* Code Analysis\n* Inversion of Control\n* Unit of Work Pattern\n* Repository Pattern\n* Database Migrations\n* Authentication\n* Authorization\n* Performance\n* Logging\n* DevOps\n\n## Run\n\n<details>\n<summary>Command Line</summary>\n\n#### Prerequisites\n\n* [.NET Core SDK](https://aka.ms/dotnet-download)\n* [SQL Server](https://go.microsoft.com/fwlink/?linkid=853016)\n* [Node.js](https://nodejs.org)\n* [Angular CLI](https://cli.angular.io)\n\n#### Steps\n\n1. Open directory **source\\Web\\Frontend** in command line and execute **npm run restore**.\n2. Open directory **source\\Web** in command line and execute **dotnet run**.\n3. Open <https://localhost:8090>.\n\n</details>\n\n<details>\n<summary>Visual Studio Code</summary>\n\n#### Prerequisites\n\n* [.NET Core SDK](https://aka.ms/dotnet-download)\n* [SQL Server](https://go.microsoft.com/fwlink/?linkid=853016)\n* [Visual Studio Code](https://code.visualstudio.com)\n* [C# Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp)\n* [Node.js](https://nodejs.org)\n* [Angular CLI](https://cli.angular.io)\n\n#### Steps\n\n1. Open directory **source\\Web\\Frontend** in command line and execute **npm run restore**.\n2. Open **source** directory in Visual Studio Code.\n3. Press **F5**.\n\n</details>\n\n<details>\n<summary>Visual Studio</summary>\n\n#### Prerequisites\n\n* [Visual Studio](https://visualstudio.microsoft.com)\n* [Node.js](https://nodejs.org)\n* [Angular CLI](https://cli.angular.io)\n\n#### Steps\n\n1. Open directory **source\\Web\\Frontend** in command line and execute **npm run restore**.\n2. Open **source\\DotNetCoreArchitecture.sln** in Visual Studio.\n3. Set **DotNetCoreArchitecture.Web** as startup project.\n4. Press **F5**.\n\n</details>\n\n<details>\n<summary>Docker</summary>\n\n#### Prerequisites\n\n* [Docker](https://www.docker.com/get-started)\n\n#### Steps\n\n1. Execute **docker-compose up --build -d --force-recreate** in root directory.\n2. Open <http://localhost:8095>.\n\n</details>\n\n## Utils\n\n<details>\n<summary>Books</summary>\n\n* **Clean Code: A Handbook of Agile Software Craftsmanship** - Robert C. Martin (Uncle Bob)\n* **Clean Architecture: A Craftsman\'s Guide to Software Structure and Design** - Robert C. Martin (Uncle Bob)\n* **Domain-Driven Design: Tackling Complexity in the Heart of Software** - Eric Evans\n* **Domain-Driven Design Reference: Definitions and Pattern Summaries** - Eric Evans\n* **Implementing Domain-Driven Design** - Vaughn Vernon\n* **Domain-Driven Design Distilled** - Vaughn Vernon\n\n</details>\n\n<details>\n<summary>Tools</summary>\n\n* [Visual Studio](https://visualstudio.microsoft.com)\n* [Visual Studio Code](https://code.visualstudio.com)\n* [SQL Server](https://www.microsoft.com/sql-server)\n* [Node.js](https://nodejs.org)\n* [Angular CLI](https://cli.angular.io)\n* [Postman](https://www.getpostman.com)\n* [Codacy](https://codacy.com)\n* [StackBlitz](https://stackblitz.com)\n\n</details>\n\n<details>\n<summary>Visual Studio Extensions</summary>\n\n* [CodeMaid](https://marketplace.visualstudio.com/items?itemName=SteveCadwallader.CodeMaid)\n* [ReSharper](https://www.jetbrains.com/resharper)\n\n</details>\n\n<details>\n<summary>Visual Studio Code Extensions</summary>\n\n* [Angular Language Service](https://marketplace.visualstudio.com/items?itemName=Angular.ng-template)\n* [Angular v7 Snippets](https://marketplace.visualstudio.com/items?itemName=johnpapa.Angular2)\n* [Atom One Dark Theme](https://marketplace.visualstudio.com/items?itemName=akamud.vscode-theme-onedark)\n* [Bracket Pair Colorizer](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer)\n* [C#](https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp)\n* [Debugger for Chrome](https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome)\n* [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme)\n* [Sort lines](https://marketplace.visualstudio.com/items?itemName=Tyriar.sort-lines)\n* [TSLint](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-tslint-plugin)\n* [Visual Studio Keymap](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vs-keybindings)\n* [vscode-angular-html](https://marketplace.visualstudio.com/items?itemName=ghaschel.vscode-angular-html)\n\n</details>\n\n## Nuget Packages\n\nPackages were created to make this architecture clean of common features for any solution.\n\n**Source:** [https://github.com/rafaelfgx/DotNetCore](https://github.com/rafaelfgx/DotNetCore)\n\n**Published:** [https://www.nuget.org/profiles/rafaelfgx](https://www.nuget.org/profiles/rafaelfgx)\n\n## Layers\n\n**Web:** API (ASP.NET Core) and Frontend (Angular).\n\n**Application:** Application flow control.\n\n**Domain:** Business rules and domain logic.\n\n**Model:** Enums and models (view model, data transfer object).\n\n**Database:** Data persistence (context, entity configuration, repository).\n\n**Infra:** Technical features (services using frameworks and packages).\n\n**CrossCutting:** Generic features used by entire solution.\n\n## Web\n\n### Angular\n\n#### Component\n\nThe **Component** class is responsible for being a small part of the application.\n\nIt must be as simple and small as possible.\n\n```typescript\n@Component({ selector: "app-login", templateUrl: "./login.component.html" })\nexport class AppLoginComponent {\n    form = this.formBuilder.group({\n        login: ["", Validators.required],\n        password: ["", Validators.required]\n    });\n\n    constructor(\n        private readonly formBuilder: FormBuilder,\n        private readonly appUserService: AppUserService) {\n    }\n\n    signIn() {\n        this.appUserService.signIn(this.form.value);\n    }\n}\n```\n\n```html\n<form [formGroup]="form">\n    <fieldset>\n        <div>\n            <app-label for="login" text="Login"></app-label>\n            <app-input-text formControlName="login" text="Login" [autofocus]="true"></app-input-text>\n        </div>\n        <div>\n            <app-label for="password" text="Password"></app-label>\n            <app-input-password formControlName="password" text="Password"></app-input-password>\n        </div>\n        <div>\n            <app-button text="Sign in" [disabled]="form.invalid" (click)="signIn()"></app-button>\n        </div>\n    </fieldset>\n</form>\n```\n\n#### Model\n\nThe **Model** class is responsible for containing a set of data.\n\n```typescript\nexport class SignInModel {\n    login!: string;\n    password!: string;\n}\n```\n\n#### Service\n\nThe **Service** class is responsible for accessing the API or containing logic that does not belong to component.\n\n```typescript\n@Injectable({ providedIn: "root" })\nexport class AppUserService {\n    constructor(\n        private readonly http: HttpClient,\n        private readonly router: Router,\n        private readonly appTokenService: AppTokenService) { }\n\n    add(addUserModel: AddUserModel) {\n        return this.http.post<number>(`Users`, addUserModel);\n    }\n\n    delete(id: number) {\n        return this.http.delete(`Users/${id}`);\n    }\n\n    list() {\n        return this.http.get<UserModel[]>(`Users`);\n    }\n\n    select(id: number) {\n        return this.http.get<UserModel>(`Users/${id}`);\n    }\n\n    signIn(signInModel: SignInModel): void {\n        this.http\n            .post<TokenModel>(`Users/SignIn`, signInModel)\n            .subscribe((tokenModel) => {\n                if (!tokenModel || !tokenModel.token) { return; }\n                this.appTokenService.set(tokenModel.token);\n                this.router.navigate(["/main/home"]);\n            });\n    }\n\n    signOut() {\n        if (this.appTokenService.any()) {\n            this.http.post(`Users/SignOut`, {}).subscribe();\n        }\n\n        this.appTokenService.clear();\n        this.router.navigate(["/login"]);\n    }\n\n    update(updateUserModel: UpdateUserModel) {\n        return this.http.put(`Users/${updateUserModel.id}`, updateUserModel);\n    }\n}\n```\n\n#### Guard\n\nThe **Guard** class is responsible for route security.\n\n```typescript\n@Injectable({ providedIn: "root" })\nexport class AppRouteGuard implements CanActivate {\n    constructor(\n        private readonly router: Router,\n        private readonly appTokenService: AppTokenService) { }\n\n    canActivate() {\n        if (this.appTokenService.any()) { return true; }\n        this.router.navigate(["/login"]);\n        return false;\n    }\n}\n```\n\n#### Error Handler\n\nThe **ErrorHandler** class is responsible for centralizing the management of all errors and exceptions.\n\n```typescript\n@Injectable({ providedIn: "root" })\nexport class AppErrorHandler implements ErrorHandler {\n    constructor(private readonly injector: Injector) { }\n\n    handleError(error: any) {\n        if (error instanceof HttpErrorResponse) {\n            switch (error.status) {\n                case 401: {\n                    const router = this.injector.get<Router>(Router);\n                    router.navigate(["/login"]);\n                    return;\n                }\n                case 422: {\n                    const appModalService = this.injector.get<AppModalService>(AppModalService);\n                    appModalService.alert(error.error);\n                    return;\n                }\n            }\n        }\n\n        console.error(error);\n    }\n}\n```\n\n#### HTTP Interceptor\n\nThe **HttpInterceptor** class is responsible for intercepting request and response.\n\nThis interceptor adds JWT to header for every request.\n\n```typescript\n@Injectable({ providedIn: "root" })\nexport class AppHttpInterceptor implements HttpInterceptor {\n    constructor(private readonly appTokenService: AppTokenService) { }\n\n    intercept(request: HttpRequest<any>, next: HttpHandler) {\n        request = request.clone({\n            setHeaders: { Authorization: `Bearer ${this.appTokenService.get()}` }\n        });\n\n        return next.handle(request);\n    }\n}\n```\n\n#### Routes\n\nThe **Routes** constant is responsible for registering all lazy load routes.\n\n```typescript\nexport const routes: Routes = [\n    {\n        path: "",\n        component: AppParentComponent\n        children: [\n            { path: "view1", loadChildren: () => import("./views/view1/view1.module").then((module) => module.AppView1Module) },\n            { path: "view2", loadChildren: () => import("./views/view2/view2.module").then((module) => module.AppView2Module) },\n        ],\n    }\n];\n```\n\n### ASP.NET Core\n\n#### Postman\n\nImport "postman.json" file into Postman.\n\n#### Startup\n\nThe **Startup** class is responsible for configuring the API.\n\n```csharp\npublic class Startup\n{\n    public void Configure(IApplicationBuilder application)\n    {\n        application.UseException();\n        application.UseRouting();\n        application.UseCorsAllowAny();\n        application.UseHttps();\n        application.UseAuthentication();\n        application.UseAuthorization();\n        application.UseResponseCompression();\n        application.UseResponseCaching();\n        application.UseStaticFiles();\n        application.UseEndpoints(endpoints => endpoints.MapControllers());\n        application.UseSpa();\n    }\n\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddLog();\n        services.AddCors();\n        services.AddSecurity();\n        services.AddResponseCompression();\n        services.AddResponseCaching();\n        services.AddControllers();\n        services.AddMvcJson();\n        services.AddSpa();\n        services.AddFileService();\n        services.AddContext();\n        services.AddClassesMatchingInterfaces();\n    }\n}\n```\n\n#### Extensions\n\nThe **Extensions** class is responsible for adding and configuring services for dependency injection.\n\n```csharp\npublic static class Extensions\n{\n    public static void AddClassesMatchingInterfaces(this IServiceCollection services)\n    {\n        services.AddClassesMatchingInterfaces(typeof(IUserApplicationService).Assembly);\n        services.AddClassesMatchingInterfaces(typeof(IUnitOfWork).Assembly);\n        services.AddClassesMatchingInterfaces(typeof(ISignInService).Assembly);\n    }\n\n    public static void AddContext(this IServiceCollection services)\n    {\n        var configuration = services.BuildServiceProvider().GetRequiredService<IConfiguration>();\n\n        var connectionString = configuration.GetConnectionString(nameof(Context));\n\n        services.AddDbContextMigrate<Context>(options => options.UseSqlServer(connectionString));\n    }\n\n    public static void AddSecurity(this IServiceCollection services)\n    {\n        services.AddHash(10000, 128);\n        services.AddJsonWebToken(Guid.NewGuid().ToString(), TimeSpan.FromHours(12));\n        services.AddAuthenticationJwtBearer();\n    }\n\n    public static void AddSpa(this IServiceCollection services)\n    {\n        services.AddSpaStaticFiles("Frontend/dist");\n    }\n\n    public static void UseSpa(this IApplicationBuilder application)\n    {\n        application.UseSpaAngularServer("Frontend", "development");\n    }\n}\n```\n\n#### Controller\n\nThe **Controller** class is responsible for receiving, processing, and responding requests.\n\nIt must be as simple and small as possible, without any rule or logic.\n\n```csharp\n[ApiController]\n[RouteController]\npublic class UsersController : BaseController\n{\n    private readonly IUserApplicationService _userApplicationService;\n\n    public UsersController(IUserApplicationService userApplicationService)\n    {\n        _userApplicationService = userApplicationService;\n    }\n\n    [HttpPost]\n    public async Task<IActionResult> AddAsync(AddUserModel addUserModel)\n    {\n        return Result(await _userApplicationService.AddAsync(addUserModel));\n    }\n\n    [AuthorizeEnum(Roles.Admin)]\n    [HttpDelete("{id}")]\n    public async Task<IActionResult> DeleteAsync(long id)\n    {\n        return Result(await _userApplicationService.DeleteAsync(id));\n    }\n\n    [HttpGet("Grid")]\n    public async Task<IActionResult> GridAsync([FromQuery]PagedListParameters parameters)\n    {\n        return Result(await _userApplicationService.ListAsync(parameters));\n    }\n\n    [HttpPatch("{id}/Inactivate")]\n    public async Task InactivateAsync(long id)\n    {\n        await _userApplicationService.InactivateAsync(id);\n    }\n\n    [HttpGet]\n    public async Task<IActionResult> ListAsync()\n    {\n        return Result(await _userApplicationService.ListAsync());\n    }\n\n    [HttpGet("{id}")]\n    public async Task<IActionResult> SelectAsync(long id)\n    {\n        return Result(await _userApplicationService.SelectAsync(id));\n    }\n\n    [AllowAnonymous]\n    [HttpPost("SignIn")]\n    public async Task<IActionResult> SignInAsync(SignInModel signInModel)\n    {\n        return Result(await _userApplicationService.SignInAsync(signInModel));\n    }\n\n    [HttpPost("SignOut")]\n    public async Task SignOutAsync()\n    {\n        await _userApplicationService.SignOutAsync(new SignOutModel(UserModel.Id));\n    }\n\n    [HttpPut("{id}")]\n    public async Task<IActionResult> UpdateAsync(UpdateUserModel updateUserModel)\n    {\n        return Result(await _userApplicationService.UpdateAsync(updateUserModel));\n    }\n}\n```\n\n## Application\n\n#### Application Service\n\nThe **ApplicationService** class is responsible for flow control. It uses validator, factory, domain, repository and unit of work, but it does not contain business rules or domain logic.\n\n```csharp\npublic sealed class UserApplicationService : IUserApplicationService\n{\n    private readonly ISignInService _signInService;\n    private readonly IUnitOfWork _unitOfWork;\n    private readonly IUserLogApplicationService _userLogApplicationService;\n    private readonly IUserRepository _userRepository;\n\n    public UserApplicationService\n    (\n        ISignInService signInService,\n        IUnitOfWork unitOfWork,\n        IUserLogApplicationService userLogApplicationService,\n        IUserRepository userRepository\n    )\n    {\n        _signInService = signInService;\n        _unitOfWork = unitOfWork;\n        _userLogApplicationService = userLogApplicationService;\n        _userRepository = userRepository;\n    }\n\n    public async Task<IDataResult<long>> AddAsync(AddUserModel addUserModel)\n    {\n        var validation = new AddUserModelValidator().Validate(addUserModel);\n\n        if (validation.Failed)\n        {\n            return DataResult<long>.Fail(validation.Message);\n        }\n\n        addUserModel.SignIn = _signInService.CreateSignIn(addUserModel.SignIn);\n\n        var userEntity = UserFactory.Create(addUserModel);\n\n        userEntity.Add();\n\n        await _userRepository.AddAsync(userEntity);\n\n        await _unitOfWork.SaveChangesAsync();\n\n        return DataResult<long>.Success(userEntity.Id);\n    }\n\n    public async Task<IResult> DeleteAsync(long id)\n    {\n        await _userRepository.DeleteAsync(id);\n\n        await _unitOfWork.SaveChangesAsync();\n\n        return Result.Success();\n    }\n\n    public async Task InactivateAsync(long id)\n    {\n        var userEntity = UserFactory.Create(id);\n\n        userEntity.Inactivate();\n\n        await _userRepository.UpdateStatusAsync(userEntity);\n\n        await _unitOfWork.SaveChangesAsync();\n    }\n\n    public async Task<PagedList<UserModel>> ListAsync(PagedListParameters parameters)\n    {\n        return await _userRepository.ListAsync<UserModel>(parameters);\n    }\n\n    public async Task<IEnumerable<UserModel>> ListAsync()\n    {\n        return await _userRepository.ListAsync<UserModel>();\n    }\n\n    public async Task<UserModel> SelectAsync(long id)\n    {\n        return await _userRepository.SelectAsync<UserModel>(id);\n    }\n\n    public async Task<IDataResult<TokenModel>> SignInAsync(SignInModel signInModel)\n    {\n        var validation = new SignInModelValidator().Validate(signInModel);\n\n        if (validation.Failed)\n        {\n            return DataResult<TokenModel>.Fail(validation.Message);\n        }\n\n        var signedInModel = await _userRepository.SignInAsync(signInModel);\n\n        validation = _signInService.Validate(signedInModel, signInModel);\n\n        if (validation.Failed)\n        {\n            return DataResult<TokenModel>.Fail(validation.Message);\n        }\n\n        var userLogModel = new UserLogModel(signedInModel.Id, LogType.SignIn);\n\n        await _userLogApplicationService.AddAsync(userLogModel);\n\n        var tokenModel = _signInService.CreateToken(signedInModel);\n\n        return DataResult<TokenModel>.Success(tokenModel);\n    }\n\n    public async Task SignOutAsync(SignOutModel signOutModel)\n    {\n        var userLogModel = new UserLogModel(signOutModel.Id, LogType.SignOut);\n\n        await _userLogApplicationService.AddAsync(userLogModel);\n    }\n\n    public async Task<IResult> UpdateAsync(UpdateUserModel updateUserModel)\n    {\n        var validation = new UpdateUserModelValidator().Validate(updateUserModel);\n\n        if (validation.Failed)\n        {\n            return Result.Fail(validation.Message);\n        }\n\n        var userEntity = await _userRepository.SelectAsync(updateUserModel.Id);\n\n        if (userEntity == default)\n        {\n            return Result.Success();\n        }\n\n        userEntity.ChangeFullName(updateUserModel.FullName.Name, updateUserModel.FullName.Surname);\n\n        userEntity.ChangeEmail(updateUserModel.Email);\n\n        await _userRepository.UpdateAsync(userEntity.Id, userEntity);\n\n        await _unitOfWork.SaveChangesAsync();\n\n        return Result.Success();\n    }\n}\n```\n\n## Domain\n\n#### Entity\n\nThe **Entity** class is responsible for business rules and domain logic.\n\nIt must have an identity.\n\nProperty values must be assigned in the constructor and only be changed by methods.\n\n```csharp\npublic class UserEntity : Entity\n{\n    public UserEntity\n    (\n        long id,\n        FullName fullName,\n        Email email,\n        SignIn signIn,\n        Roles roles,\n        Status status\n    )\n    {\n        Id = id;\n        FullName = fullName;\n        Email = email;\n        SignIn = signIn;\n        Roles = roles;\n        Status = status;\n    }\n\n    public UserEntity(long id)\n    {\n        Id = id;\n    }\n\n    public FullName FullName { get; private set; }\n\n    public Email Email { get; private set; }\n\n    public SignIn SignIn { get; private set; }\n\n    public Roles Roles { get; private set; }\n\n    public Status Status { get; private set; }\n\n    public ICollection<UserLogEntity> UsersLogs { get; private set; }\n\n    public void Add()\n    {\n        Roles = Roles.User;\n        Status = Status.Active;\n    }\n\n    public void ChangeEmail(string address)\n    {\n        Email = new Email(address);\n    }\n\n    public void ChangeFullName(string name, string surname)\n    {\n        FullName = new FullName(name, surname);\n    }\n\n    public void Inactivate()\n    {\n        Status = Status.Inactive;\n    }\n}\n```\n\n#### Factory\n\nThe **Factory** class is responsible for creating a object.\n\n```csharp\npublic static class UserFactory\n{\n    public static UserEntity Create(long id)\n    {\n        return new UserEntity(id);\n    }\n\n    public static UserEntity Create(AddUserModel addUserModel)\n    {\n        return new UserEntity\n        (\n            addUserModel.Id,\n            new FullName\n            (\n                addUserModel.FullName.Name,\n                addUserModel.FullName.Surname\n            ),\n            new Email(addUserModel.Email),\n            new SignIn\n            (\n                addUserModel.SignIn.Login,\n                addUserModel.SignIn.Password,\n                addUserModel.SignIn.Salt\n            ),\n            addUserModel.Roles,\n            default\n        );\n    }\n}\n```\n\n#### Value Object\n\nThe **ValueObject** class is responsible for grouping data that adds value to domain or an entity.\n\nIt must have no identity.\n\nProperty values must be assigned in the constructor.\n\n```csharp\npublic sealed class SignIn : ValueObject\n{\n    public SignIn(string login, string password, string salt)\n    {\n        Login = login;\n        Password = password;\n        Salt = salt;\n    }\n\n    public string Login { get; }\n\n    public string Password { get; }\n\n    public string Salt { get; }\n\n    protected override IEnumerable<object> GetEquals()\n    {\n        yield return Login;\n        yield return Password;\n        yield return Salt;\n    }\n}\n```\n\n## Model\n\n#### Model\n\nThe **Model** class is responsible for containing a set of data.\n\n```csharp\npublic class SignInModel\n{\n    public string Login { get; set; }\n\n    public string Password { get; set; }\n\n    public string Salt { get; set; }\n}\n```\n\n#### Model Validator\n\nThe **ModelValidator** class is responsible for validating the model with defined rules and messages.\n\n```csharp\npublic sealed class SignInModelValidator : Validator<SignInModel>\n{\n    public SignInModelValidator()\n    {\n        WithMessage(Texts.LoginPasswordInvalid);\n        RuleFor(x => x.Login).NotEmpty();\n        RuleFor(x => x.Password).NotEmpty();\n    }\n}\n```\n\n#### Enum\n\nThe **Enum** is responsible for being a set of named integer constants.\n\n```csharp\npublic enum Status\n{\n    None = 0,\n    Active = 1,\n    Inactive = 2\n}\n```\n\n## Database\n\n#### Context\n\nThe **Context** class is responsible for configuring and mapping the database.\n\n```csharp\npublic sealed class Context : DbContext\n{\n    public Context(DbContextOptions options) : base(options) { }\n\n    protected override void OnModelCreating(ModelBuilder builder)\n    {\n        builder.ApplyConfigurationsFromAssembly();\n        builder.Seed();\n    }\n}\n```\n\n#### Context Factory\n\nThe **ContextFactory** class is responsible for generating [Entity Framework Core Migrations](https://docs.microsoft.com/ef/core/managing-schemas/migrations).\n\n```csharp\npublic sealed class ContextFactory : IDesignTimeDbContextFactory<Context>\n{\n    public Context CreateDbContext(string[] args)\n    {\n        var builder = new DbContextOptionsBuilder<Context>();\n\n        builder.UseSqlServer("Server=(localdb)\\\\MSSQLLocalDB;Database=Database;");\n\n        return new Context(builder.Options);\n    }\n}\n```\n\n#### Context Seed\n\nThe **ContextSeed** class is responsible for seeding initial data.\n\n```csharp\npublic static class ContextSeed\n{\n    public static void Seed(this ModelBuilder builder)\n    {\n        builder.SeedUsers();\n    }\n\n    private static void SeedUsers(this ModelBuilder builder)\n    {\n        builder.Entity<UserEntity>(x =>\n        {\n            x.HasData(new\n            {\n                Id = 1L,\n                Roles = Roles.User | Roles.Admin,\n                Status = Status.Active\n            });\n\n            x.OwnsOne(y => y.FullName).HasData(new\n            {\n                UserEntityId = 1L,\n                Name = "Administrator",\n                Surname = "Administrator"\n            });\n\n            x.OwnsOne(y => y.Email).HasData(new\n            {\n                UserEntityId = 1L,\n                Address = "administrator@administrator.com"\n            });\n        });\n    }\n}\n```\n\n#### Unit of Work\n\nThe **UnitOfWork** class is responsible for managing database transactions.\n\n```csharp\npublic sealed class UnitOfWork : IUnitOfWork\n{\n    private readonly Context _context;\n\n    public UnitOfWork(Context context)\n    {\n        _context = context;\n    }\n\n    public Task<int> SaveChangesAsync()\n    {\n        return _context.SaveChangesAsync();\n    }\n}\n```\n\n#### Configuration\n\nThe **Configuration** class is responsible for configuring and mapping an entity to a table.\n\n```csharp\npublic sealed class UserConfiguration : IEntityTypeConfiguration<UserEntity>\n{\n    public void Configure(EntityTypeBuilder<UserEntity> builder)\n    {\n        builder.ToTable("Users", "User");\n\n        builder.HasKey(x => x.Id);\n\n        builder.Property(x => x.Id).IsRequired().ValueGeneratedOnAdd();\n        builder.Property(x => x.Roles).IsRequired();\n        builder.Property(x => x.Status).IsRequired();\n\n        builder.OwnsOne(x => x.FullName, y =>\n        {\n            y.Property(x => x.Name).HasColumnName(nameof(UserEntity.FullName.Name)).IsRequired().HasMaxLength(100);\n            y.Property(x => x.Surname).HasColumnName(nameof(UserEntity.FullName.Surname)).IsRequired().HasMaxLength(200);\n        });\n\n        builder.OwnsOne(x => x.Email, y =>\n        {\n            y.Property(x => x.Address).HasColumnName(nameof(UserEntity.Email)).IsRequired().HasMaxLength(300);\n            y.HasIndex(x => x.Address).IsUnique();\n        });\n\n        builder.OwnsOne(x => x.SignIn, y =>\n        {\n            y.Property(x => x.Login).HasColumnName(nameof(UserEntity.SignIn.Login)).IsRequired().HasMaxLength(100);\n            y.Property(x => x.Password).HasColumnName(nameof(UserEntity.SignIn.Password)).IsRequired().HasMaxLength(500);\n            y.Property(x => x.Salt).HasColumnName(nameof(UserEntity.SignIn.Salt)).IsRequired().HasMaxLength(500);\n            y.HasIndex(x => x.Login).IsUnique();\n        });\n\n        builder.HasMany(x => x.UsersLogs).WithOne(x => x.User).HasForeignKey(x => x.UserId);\n    }\n}\n```\n\n#### Repository\n\nThe **Repository** class is responsible for abstracting and isolating data persistence.\n\n```csharp\npublic sealed class UserRepository : EntityFrameworkCoreRelationalRepository<UserEntity>, IUserRepository\n{\n    public UserRepository(Context context) : base(context) { }\n\n    public Task<SignedInModel> SignInAsync(SignInModel signInModel)\n    {\n        return SingleOrDefaultAsync<SignedInModel>\n        (\n            userEntity =>\n            userEntity.SignIn.Login == signInModel.Login &&\n            userEntity.Status == Status.Active\n        );\n    }\n\n    public Task UpdateStatusAsync(UserEntity userEntity)\n    {\n        return UpdatePartialAsync(userEntity.Id, new { userEntity.Status });\n    }\n}\n```\n\n## Infra\n\n#### Service\n\nThe **Service** class is responsible for providing technical functionality.\n\n```csharp\npublic class SignInService : ISignInService\n{\n    private readonly IHashService _hashService;\n    private readonly IJsonWebTokenService _jsonWebTokenService;\n\n    public SignInService\n    (\n        IHashService hashService,\n        IJsonWebTokenService jsonWebTokenService\n    )\n    {\n        _hashService = hashService;\n        _jsonWebTokenService = jsonWebTokenService;\n    }\n\n    public SignInModel CreateSignIn(SignInModel signInModel)\n    {\n        var salt = Guid.NewGuid().ToString();\n\n        var password = _hashService.Create(signInModel.Password, salt);\n\n        return new SignInModel\n        {\n            Login = signInModel.Login,\n            Password = password,\n            Salt = salt\n        };\n    }\n\n    public TokenModel CreateToken(SignedInModel signedInModel)\n    {\n        var claims = new List<Claim>();\n\n        claims.AddSub(signedInModel.Id.ToString());\n\n        claims.AddRoles(signedInModel.Roles.ToString().Split(", "));\n\n        var token = _jsonWebTokenService.Encode(claims);\n\n        return new TokenModel(token);\n    }\n\n    public IResult Validate(SignedInModel signedInModel, SignInModel signInModel)\n    {\n        if (signedInModel == default || signInModel == default)\n        {\n            return Result.Fail(Texts.LoginPasswordInvalid);\n        }\n\n        var password = _hashService.Create(signInModel.Password, signedInModel.SignIn.Salt);\n\n        if (signedInModel.SignIn.Password != password)\n        {\n            return Result.Fail(Texts.LoginPasswordInvalid);\n        }\n\n        return Result.Success();\n    }\n}\n```\n'