b'\n# Rendora\n\n<p align="center">\n<img src="docs/pics/logo_200.png" alt="Rendora" title="Rendora" />\n</p>\n\n[![Go Report Card](https://goreportcard.com/badge/rendora/rendora)](http://goreportcard.com/report/rendora/rendora)\n[![CircleCI](https://circleci.com/gh/rendora/rendora/tree/master.svg?style=svg)](https://circleci.com/gh/rendora/rendora/tree/master)\n[![GoDoc](https://godoc.org/github.com/rendora/rendora?status.svg)](https://godoc.org/github.com/rendora/rendora)\n[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://github.com/rendora/rendora/blob/master/LICENSE)\n[![Join the chat at https://discord.gg/6yyErk8](https://img.shields.io/badge/chat-on%20discord-7289da.svg)](https://discord.gg/6yyErk8)\n\nRendora is a dynamic renderer to provide zero-configuration server-side rendering mainly to web crawlers in order to effortlessly improve SEO for websites developed in modern Javascript frameworks such as React.js, Vue.js, Angular.js, etc... Rendora works totally independently of your frontend and backend stacks\n\n<p align="center">\n<img src="docs/pics/diagram.png" alt="Rendora\'s Diagram" title="Rendora\'s Diagram" />\n</p>\n\n## Main Features\n* Zero change needed in frontend and backend code\n* Filters based on user agents and paths\n* Single fast binary written in Golang\n* Multiple Caching strategies\n* Support for asynchronous pages\n* Prometheus metrics\n* Choose your configuration system (YAML, TOML or JSON)\n* Container ready\n\n\n## What is Rendora?\n\nRendora can be seen as a reverse HTTP proxy server sitting between your backend server (e.g. Node.js/Express.js, Python/Django, etc...)\nand potentially your frontend proxy server (e.g. nginx, traefik, apache, etc...) or even directly to the outside world that does actually nothing but transporting requests and responses as they are **except** when it detects whitelisted requests according to the config. In that case, Rendora instructs a headless Chrome instance to request and render the corresponding page and then return the server-side rendered page back to the client (i.e. the frontend proxy server or the outside world). This simple functionality makes Rendora a powerful dynamic renderer\nwithout actually changing anything in both frontend and backend code.\n\n\n## What is Dynamic Rendering?\nDynamic rendering means that the server provides server-side rendered HTML to web crawlers such as GoogleBot and BingBot and at the same time provides the typical initial HTML to normal users in order to be rendered at the client side. Dynamic rendering is meant to improve SEO for websites written in modern javascript frameworks like React, Vue, Angular, etc... \n\n\n**Read more about dynamic rendering from these articles by\n[Google](https://developers.google.com/search/docs/guides/dynamic-rendering) and \n[Bing](https://blogs.bing.com/webmaster/october-2018/bingbot-Series-JavaScript,-Dynamic-Rendering,-and-Cloaking-Oh-My). Also you might want to watch this interesting talk at\n[Google I/O 2018](https://youtu.be/PFwUbgvpdaQ)**\n\n\n\n## How does Rendora work?\n\nRendora is listening by default to the port `3001` but can be changed using the config file; for every request coming from the frontend server or the outside world, there are some checks or filters that are tested against the headers and/or paths according to Rendora\'s configuration file to determine whether Rendora should just pass the initial HTML returned from the backend server or use headless Chrome to provide a server-side rendered HTML. To be more specific, for every request there are 2 paths:\n\n1. If the request is whitelisted as a candidate for SSR (i.e. a GET request that passes all user agent and path filters), Rendora instructs the headless Chrome instance to request the corresponding page, render it and return the response which contains the final server-side rendered HTML. You usually want to whitelist only web crawlers like GoogleBot, BingBot, etc...\n\n2. If the request isn\'t whitelisted (i.e. the request is not a GET request or doesn\'t pass any of the filters), Rendora will simply act as a transparent reverse HTTP proxy and just conveys requests and responses as they are. You usually want to blacklist real users in order to return the usual client-side rendered HTML coming from the backend server back to them.\n\n\n\n## Install and run Rendora\n\n### First, run a headless Chrome instance\nIf Chrome/Chromium is installed in your system, you can run it using\n\n``` bash\ngoogle-chrome --headless --remote-debugging-port=9222\n```\n\n_note:_ Mac users may have a `google-chrome: command not found` error. If that\'s the case, run the following command and repeat the previous step:\n\n```bash\nalias google-chrome="/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome"\n```\n\nor simply using docker\n\n``` bash\ndocker run --tmpfs /tmp --net=host rendora/chrome-headless\n```\n\n*note:* the `tmpfs` flag is optional but it\'s recommended for performance reasons since `rendora/chrome-headless` runs with flag `--user-data-dir=/tmp`\n\n### Then, run Rendora\n\nyou can build and run Rendora from source code, (**NOTE**: please read the [configuration manual](docs/configuration/) before running Rendora)\n\n``` bash\ngit clone https://github.com/rendora/rendora\ncd rendora\n# MAKE SURE YOU HAVE GO V1.11+ INSTALLED\nmake build\nsudo make install\nrendora --config CONFIG_FILE.yaml\n```\n\nor simply using docker\n\n``` bash\ndocker run --net=host -v ./CONFIG_FILE.yaml:/etc/rendora/config.yaml rendora/rendora\n```\n\n## Documentation\nYou can read the docs [here](https://rendora.co/docs/) or [here](docs)\n\n## Configuration\nConfiguration is discussed in detail in docs [here](https://rendora.co/docs/configuration/) or [here](docs/configuration)\n\n### A minimal config file example\n```yaml\ntarget:\n    url: "http://127.0.0.1" # this is the base url addressed by the headless Chrome instance, it can be simply your website url\nbackend:\n    url: "http://127.0.0.1:8000" # your backend server url\n\nfilters:\n    userAgent: # .i.e. only whitelist useragents containing the keywords "bot", "slurp", "bing" or "crawler"\n        defaultPolicy: blacklist\n        exceptions:\n            keywords:\n                - bot\n                - slurp\n                - bing\n                - crawler\n```\n\n### A more customized config file\n\n```yaml\nlisten:\n    address: 0.0.0.0\n    port: 3001\ncache:\n    type: redis\n    timeout: 6000\n    redis:\n        address: localhost:6379\ntarget:\n    url: "http://127.0.0.1" \nbackend:\n    url: "http://127.0.0.1:8000"\nheadless:\n    waitAfterDOMLoad: 0\n    internal:\n      url: http://localhost:9222\noutput:\n    minify: true\nfilters:\n    userAgent:\n        defaultPolicy: blacklist\n        exceptions:\n            keywords:\n                - bot\n                - slurp\n                - bing\n                - crawler\n    paths:\n        defaultPolicy: whitelist\n        exceptions:\n            prefix:\n             - /users/\n```\n\n\n## FAQs\n\n### What is the difference between Rendora and Puppeteer?\n\n[Puppeteer](https://github.com/GoogleChrome/puppeteer) is a great Node.js library which provides a generic high-level API to control headless Chrome. On the other hand, Rendora is a dynamic renderer that acts as a reverse HTTP proxy placed in front of your backend server to provide server-side rendering mainly to web crawlers in order to effortlessly improve SEO.\n\n\n### What is the difference between Rendora and Rendertron?\n[Rendertron](https://github.com/GoogleChrome/rendertron) is comparable to Rendora in the sense that they both aim to provide SSR using headless Chrome; however there are various differences that can make Rendora a much better choice:\n\n\n1. **Architecture**: Rendertron is a HTTP server that returns SSR\'ed HTML back to the client. That means that your server must contain the necessary code to filter requests and asks rendertron to provide the SSR\'ed HTML and then return it back to the original client. Rendora does all that automatically by acting as a reverse HTTP proxy in front of your backend.\n\n\n2. **Caching**: Rendora can be configured to use internal local store or Redis to cache SSR\'ed HTML.\n3. **Performance**: In addition to caching, Rendora is able to skip fetching and rendering unnecessary content CSS, fonts, images, etc... which can substantially reduce the intial DOM load latency.\n4. **Development**: Rendertron is developed in Node.js while Rendora is a single binary written in Golang.\n5. **API and Metrics**: Rendora provides Prometheus metrics about SSR latencies and number of SSR\'ed and total requests. Furthermore, Rendora provides a JSON rendering endpoint that contains body, status and headers of the SSR response by the headless Chrome instance.\n\n\n## Acknowledgements\n\nMany thanks to [@mafredri](https://github.com/mafredri) for his effort to create [cdp](https://github.com/mafredri/cdp), a great Chrome DevTools Protocols client in Golang.\n\n\n\nFollow rendora news and releases on [Twitter](https://twitter.com/_rendora)\n\nGeorge Badawi - 2018\n'