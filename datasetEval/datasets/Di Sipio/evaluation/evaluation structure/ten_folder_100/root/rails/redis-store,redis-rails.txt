b'# Redis stores for Ruby on Rails\n\n__`redis-rails`__ provides a full set of stores (*Cache*, *Session*, *HTTP Cache*) for __Ruby on Rails__. See the main [redis-store readme](https://github.com/redis-store/redis-store) for general guidelines.\n\n## A quick note about Rails 5.2\n\nRails 5.2.0 [includes a Redis cache store out of the\nbox](https://github.com/rails/rails/pull/31134), so you don\'t really\nneed this gem anymore if you just need to store the fragment cache in\nRedis. Maintenance on the [redis-activesupport](https://github.com/redis-store/redis-activesupport)\ngem will continue for security and compatibility issues, but we are no longer accepting new\nfeatures. We are still actively maintaining all other gems in the redis-store\nfamily.\n\n## Installation\n\nAdd the following to your Gemfile:\n\n```ruby\ngem \'redis-rails\'\n```\n\n## Usage\n\n`redis-rails` packages storage drivers for Redis which implement the\nActiveSupport fragment caching and ActionDispatch / Rack session\nstorage APIs. The following section(s) explain how to configure each\nstore:\n\n### Rails Fragment Cache\n\nConfigure the fragment cache store in **config/environments/production.rb** like so:\n\n```ruby\nconfig.cache_store = :redis_store, "redis://localhost:6379/0/cache", { expires_in: 90.minutes }\n```\n\nThe `ActiveSupport::Cache::Store` implementation assumes that your\nbackend store (Redis, Memcached, etc) will be available at boot time. If\nyou cannot guarantee this, you can use the `raise_errors: false` option\nto rescue connection errors.\n\nYou can also provide a hash instead of a URL:\n\n```ruby\nconfig.cache_store = :redis_store, {\n  host: "localhost",\n  port: 6379,\n  db: 0,\n  password: "mysecret",\n  namespace: "cache"\n}, {\n  expires_in: 90.minutes\n}\n```\n\n### Session Storage\n\nYou can also store your session data in Redis, keeping user-specific\ndata isolated, shared, and highly available. Built upon [redis-rack](https://github.com/redis-store/redis-rack),\nwe present the session data to the user as a signed/encrypted cookie,\nbut we persist the data in Redis.\n\nAdd the following to your **config/initializers/session_store.rb** to\nuse Redis as the session store.\n\n```ruby\nMyApplication::Application.config.session_store :redis_store,\n  servers: ["redis://localhost:6379/0/session"],\n  expire_after: 90.minutes,\n  key: "_#{Rails.application.class.parent_name.downcase}_session",\n  threadsafe: true,\n  signed: true,\n  secure: true\n```\n\nA brief run-down of these options...\n\n- **servers** is an Array of Redis servers that we will attempt to find\n  data from. This uses the same syntax as `:redis_store`\n- **expire_after** is the default TTL of session keys. This is also set\n  as the expiry time of any cookies generated by the session store.\n- **key** is the name of the cookie on the client side\n- **threadsafe** is for applications that run on multiple instances. Set\n  this to `false` if you want to disable the global mutex lock on\n  session data. It\'s `true` by default, meaning the mutex will be\n  enabled.\n- **signed** uses signed/encrypted cookies to store the local session on\n  a client machine, preventing a malicious user from tampering with its\n  contents.\n- **secure** ensures HTTP cookies are transferred from server to client\n  on a secure (HTTPS) connection\n- **httponly** ensures that all cookies have the HttpOnly flag set to true\n\n### HTTP Caching\n\nWe also provide [an adapter](https://github.com/redis-store/redis-rack-cache) for\n[Rack::Cache](http://rtomayko.github.io/rack-cache/) that lets you store HTTP\ncaching data in Redis. To take advantage of this, add the following to\nGemfile:\n\n```ruby\ngroup :production do\n  gem \'redis-rack-cache\'\nend\n```\n\nThen, add the following to **config/environments/production.rb**:\n\n```ruby\n# config/environments/production.rb\nconfig.action_dispatch.rack_cache = {\n  metastore: "redis://localhost:6379/1/metastore",\n  entitystore: "redis://localhost:6379/1/entitystore"\n}\n```\n\n### Usage with Redis Sentinel\n\nYou can also use [Redis Sentinel](https://redis.io/topics/sentinel) to manage a cluster of Redis servers\nfor high-availability data access. To do so, configure the sentinel\nservers like so:\n\n```ruby\nsentinel_config = {\n  url: "redis://mymaster/0",\n  role: "master",\n  sentinels: [{\n    host: "127.0.0.1",\n    port: 26379\n  },{\n    host: "127.0.0.1",\n    port: 26380\n  },{\n    host: "127.0.0.1",\n    port: 26381\n  }]\n}\n```\n\nYou can then include this in your cache store configuration within\n**config/environments/production.rb**:\n\n```ruby\nconfig.cache_store = :redis_store, sentinel_config.merge(\n  namespace: "cache",\n  expires_in: 1.days\n)\nconfig.session_store :redis_store, {\n  servers: [\n    sentinel_config.merge(\n      namespace: "sessions"\n    )\n  ],\n  expire_after: 2.days\n}\n```\n\n## Usage with Redis Cluster\n\nYou can also specify only a subset of the nodes, and the client will discover the missing ones using the [CLUSTER NODES](https://redis.io/commands/cluster-nodes) command.\n\n```ruby\nconfig.cache_store = :redis_store, { cluster: %w[redis://127.0.0.1:6379/0/] }\n```\n\n## Running tests\n\n```shell\ngem install bundler\ngit clone git://github.com/redis-store/redis-rails.git\ncd redis-rails\nRAILS_VERSION=5.0.1 bundle install\nRAILS_VERSION=5.0.1 bundle exec rake\n```\n\nIf you are on **Snow Leopard**, run `env ARCHFLAGS="-arch x86_64" bundle exec rake`\n\n## Status\n\n[![Gem Version](https://badge.fury.io/rb/redis-rails.svg)](http://badge.fury.io/rb/redis-rails)\n[![Build Status](https://secure.travis-ci.org/redis-store/redis-rails.svg?branch=master)](http://travis-ci.org/redis-store/redis-rails?branch=master)\n[![Code Climate](https://codeclimate.com/github/redis-store/redis-rails.svg)](https://codeclimate.com/github/redis-store/redis-rails)\n\n## Copyright\n\n2009 - 2018 Luca Guidi - [http://lucaguidi.com](http://lucaguidi.com), released under the MIT license\n'