b'# Responders\n\n[![Gem Version](https://fury-badge.herokuapp.com/rb/responders.svg)](http://badge.fury.io/rb/responders)\n[![Build Status](https://api.travis-ci.org/plataformatec/responders.svg?branch=master)](http://travis-ci.org/plataformatec/responders)\n[![Code Climate](https://codeclimate.com/github/plataformatec/responders.svg)](https://codeclimate.com/github/plataformatec/responders)\n\nA set of responders modules to dry up your Rails app.\n\n## Installation\n\nAdd the responders gem to your Gemfile:\n\n    gem "responders"\n\nUpdate your bundle and run the install generator:\n\n    $ bundle install\n    $ rails g responders:install\n\nIf you are including this gem to support backwards compatibilty for responders in previous releases of Rails, you only need to include the gem and bundle.\n\n    $ bundle install\n\n## Responders Types\n\n### FlashResponder\n\nSets the flash based on the controller action and resource status.\nFor instance, if you do: `respond_with(@post)` on a POST request and the resource `@post`\ndoes not contain errors, it will automatically set the flash message to\n`"Post was successfully created"` as long as you configure your I18n file:\n\n```yaml\n  flash:\n    actions:\n      create:\n        notice: "%{resource_name} was successfully created."\n      update:\n        notice: "%{resource_name} was successfully updated."\n      destroy:\n        notice: "%{resource_name} was successfully destroyed."\n        alert: "%{resource_name} could not be destroyed."\n```\n\nIn case the resource contains errors, you should use the failure key on I18n. This is\nuseful to dry up flash messages from your controllers. Note: by default alerts for `update`\nand `destroy` actions are commented in generated I18n file. If you need a specific message\nfor a controller, let\'s say, for `PostsController`, you can also do:\n\n```yaml\n  flash:\n    posts:\n      create:\n        notice: "Your post was created and will be published soon"\n```\n\nThis responder is activated in all non get requests. By default it will use the keys\n`:notice` and `:alert`, but they can be changed in your application:\n\n```ruby\nconfig.responders.flash_keys = [ :success, :failure ]\n```\n\nYou can also have embedded HTML. Just create a `_html` scope.\n\n```yaml\n  flash:\n    actions:\n      create:\n        alert_html: "<strong>OH NOES!</strong> You did it wrong!"\n    posts:\n      create:\n        notice_html: "<strong>Yay!</strong> You did it!"\n```\n\nSee also the `namespace_lookup` option to search the full hierarchy of possible keys.\n\n### HttpCacheResponder\n\nAutomatically adds Last-Modified headers to API requests. This\nallows clients to easily query the server if a resource changed and if the client tries\nto retrieve a resource that has not been modified, it returns not_modified status.\n\n### CollectionResponder\n\nMakes your create and update action redirect to the collection on success.\n\n### LocationResponder\n\nThis responder allows you to use callable objects as the redirect location.\nUseful when you want to use the `respond_with` method with\na custom route that requires persisted objects, but the validation may fail.\n\nNote: this responder is included by default, and doesn\'t need to be included\non the top of your controller (including it will issue a deprecation warning).\n\n```ruby\nclass ThingsController < ApplicationController\n  respond_to :html\n\n  def create\n    @thing = Thing.create(params[:thing])\n    respond_with @thing, location: -> { thing_path(@thing) }\n  end\nend\n```\n\n**Dealing with namespaced routes**\n\nIn order for the LocationResponder to find the correct route helper for namespaced routes you need to pass the namespaces to `respond_with`:\n\n```ruby\nclass Api::V1::ThingsController < ApplicationController\n  respond_to :json\n\n  # POST /api/v1/things\n  def create\n    @thing = Thing.create(thing_params)\n    respond_with :api, :v1, @thing\n  end\nend\n```\n\n## Configuring your own responder\n\nResponders only provides a set of modules and to use them you have to create your own\nresponder. After you run the install command, the following responder will be\ngenerated in your application:\n\n```ruby\n# lib/application_responder.rb\nclass ApplicationResponder < ActionController::Responder\n  include Responders::FlashResponder\n  include Responders::HttpCacheResponder\nend\n```\n\nYour application also needs to be configured to use it:\n\n```ruby\n# app/controllers/application_controller.rb\nrequire "application_responder"\n\nclass ApplicationController < ActionController::Base\n  self.responder = ApplicationResponder\n  respond_to :html\nend\n```\n\n## Controller method\n\nThis gem also includes the controller method `responders`, which allows you to cherry-pick which\nresponders you want included in your controller.\n\n```ruby\nclass InvitationsController < ApplicationController\n  responders :flash, :http_cache\nend\n```\n\n## Interpolation Options\n\nYou can pass in extra interpolation options for the translation by adding an `flash_interpolation_options` method to your controller:\n\n```ruby\nclass InvitationsController < ApplicationController\n  responders :flash, :http_cache\n\n  def create\n    @invitation = Invitation.create(params[:invitation])\n    respond_with @invitation\n  end\n\n  private\n\n  def flash_interpolation_options\n    { resource_name: @invitation.email }\n  end\nend\n```\n\nNow you would see the message `"name@example.com was successfully created"` instead of the default `"Invitation was successfully created."`\n\n## Generator\n\nThis gem also includes a responders controller generator, so your scaffold can be customized\nto use `respond_with` instead of default `respond_to` blocks. From 2.1, you need to explicitly opt-in to use this generator by adding the following to your `config/application.rb`:\n\n```ruby\nconfig.app_generators.scaffold_controller :responders_controller\n```\n\n## Failure handling\n\nResponders don\'t use `valid?` to check for errors in models to figure out if\nthe request was successful or not, and relies on your controllers to call\n`save` or `create` to trigger the validations.\n\n```ruby\ndef create\n  @widget = Widget.new(widget_params)\n  # @widget will be a valid record for responders, as we haven\'t called `save`\n  # on it, and will always redirect to the `widgets_path`.\n  respond_with @widget, location: -> { widgets_path }\nend\n```\n\nResponders will check if the `errors` object in your model is empty or not. Take\nthis in consideration when implementing different actions or writing test\nassertions on this behavior for your controllers.\n\n```ruby\ndef create\n  @widget = Widget.new(widget_params)\n  @widget.errors.add(:base, :invalid)\n  # `respond_with` will render the `new` template again.\n  respond_with @widget\nend\n```\n\n## Verifying request formats\n\n`respond_with` will raise an `ActionController::UnknownFormat` if the request\nMIME type was not configured through the class level `respond_to`, but the\naction will still be executed and any side effects (like creating a new record)\nwill still occur. To raise the `UnknownFormat` exception before your action\nis invoked you can set the `verify_requested_format!` method as a `before_action`\non your controller.\n\n```ruby\nclass WidgetsController < ApplicationController\n  respond_to :json\n  before_action :verify_requested_format!\n\n  # POST /widgets.html won\'t reach the `create` action.\n  def create\n    widget = Widget.create(widget_params)\n    respond_with widget\n  end\nend\n\n```\n\n## Examples\n\nWant more examples ? Check out these blog posts:\n\n* [Embracing REST with mind, body and soul](http://blog.plataformatec.com.br/2009/08/embracing-rest-with-mind-body-and-soul/)\n* [Three reasons to love ActionController::Responder](http://weblog.rubyonrails.org/2009/8/31/three-reasons-love-responder/)\n* [My five favorite things about Rails 3](http://www.engineyard.com/blog/2009/my-five-favorite-things-about-rails-3)\n\n## Bugs and Feedback\n\nIf you discover any bugs or want to drop a line, feel free to create an issue on GitHub.\n\nhttp://github.com/plataformatec/responders/issues\n\nMIT License. Copyright 2009-2019 Plataformatec. http://plataformatec.com.br\n'