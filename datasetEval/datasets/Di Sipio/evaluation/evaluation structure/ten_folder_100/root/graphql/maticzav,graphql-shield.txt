b'<p align="center"><img src="https://imgur.com/DX1VKtn.png" width="150" /></p>\n\n# graphql-shield\n\n[![CircleCI](https://circleci.com/gh/maticzav/graphql-shield/tree/master.svg?style=shield)](https://circleci.com/gh/maticzav/graphql-shield/tree/master)\n[![codecov](https://codecov.io/gh/maticzav/graphql-shield/branch/master/graph/badge.svg)](https://codecov.io/gh/maticzav/graphql-shield)\n[![npm version](https://badge.fury.io/js/graphql-shield.svg)](https://badge.fury.io/js/graphql-shield)\n[![Backers on Open Collective](https://opencollective.com/graphql-shield/backers/badge.svg)](#backers)[![Sponsors on Open Collective](https://opencollective.com/graphql-shield/sponsors/badge.svg)](#sponsors)\n\n> GraphQL Server permissions as another layer of abstraction!\n\n## Overview\n\nGraphQL Shield helps you create a permission layer for your application. Using an intuitive rule-API, you\'ll gain the power of the shield engine on every request and reduce the load time of every request with smart caching. This way you can make sure your application will remain quick, and no internal data will be exposed.\n\n[![Sponsored By GraphCMS](https://github.com/maticzav/graphql-shield/raw/master/media/graphcms.svg?sanitize=true)](https://graphcms.com/?ref=maticzav)\n\nTry building a groceries shop to better understand the benefits of GraphQL Shield! [Banana &Co.](https://medium.com/@maticzavadlal/graphql-shield-9d1e02520e35) \xf0\x9f\x8d\x8f\xf0\x9f\x8d\x8c\xf0\x9f\x8d\x93.\n\nExplore common receipts and learn about advanced GraphQL! [GraphQL Shield 3.0](https://medium.com/@maticzavadlal/graphql-shield-9d1e02520e35) \xe2\x9a\x94\xef\xb8\x8f\xf0\x9f\x9b\xa1\xf0\x9f\x90\xb4.\n\n## Features\n\n- \xe2\x9c\x82\xef\xb8\x8f **Flexible:** Based on [GraphQL Middleware](https://github.com/prismagraphql/graphql-middleware).\n- \xf0\x9f\x98\x8c **Easy to use:** Just add permissions to your [Yoga](https://github.com/prismagraphql/graphql-yoga) `middlewares` set, and you are ready to go!\n- \xf0\x9f\xa4\x9d **Compatible:** Works with all GraphQL Servers.\n- \xf0\x9f\x9a\x80 **Smart:** Intelligent V8 Shield engine caches all your request to prevent any unnecessary load.\n- \xf0\x9f\x8e\xaf **Per-Type or Per-Field:** Write permissions for your schema, types or specific fields (check the example below).\n\n## Install\n\n```bash\nyarn add graphql-shield\n```\n\n## Example\n\n### GraphQL Yoga\n\n```ts\nimport { GraphQLServer } from \'graphql-yoga\'\nimport { rule, shield, and, or, not } from \'graphql-shield\'\n\nconst typeDefs = `\n  type Query {\n    frontPage: [Fruit!]!\n    fruits: [Fruit!]!\n    customers: [Customer!]!\n  }\n\n  type Mutation {\n    addFruitToBasket: Boolean!\n  }\n\n  type Fruit {\n    name: String!\n    count: Int!\n  }\n\n  type Customer {\n    id: ID!\n    basket: [Fruit!]!\n  }\n`\n\nconst resolvers = {\n  Query: {\n    frontPage: () => [\n      { name: \'orange\', count: 10 },\n      { name: \'apple\', count: 1 },\n    ],\n  },\n}\n\n// Auth\n\nconst users = {\n  mathew: {\n    id: 1,\n    name: \'Mathew\',\n    role: \'admin\',\n  },\n  george: {\n    id: 2,\n    name: \'George\',\n    role: \'editor\',\n  },\n  johnny: {\n    id: 3,\n    name: \'Johnny\',\n    role: \'customer\',\n  },\n}\n\nfunction getUser(req) {\n  const auth = req.get(\'Authorization\')\n  if (users[auth]) {\n    return users[auth]\n  } else {\n    return null\n  }\n}\n\n// Rules\n\n/* Read more about cache options down in the `rules/cache` section. */\n\nconst isAuthenticated = rule({ cache: \'contextual\' })(\n  async (parent, args, ctx, info) => {\n    return ctx.user !== null\n  },\n)\n\nconst isAdmin = rule({ cache: \'contextual\' })(\n  async (parent, args, ctx, info) => {\n    return ctx.user.role === \'admin\'\n  },\n)\n\nconst isEditor = rule({ cache: \'contextual\' })(\n  async (parent, args, ctx, info) => {\n    return ctx.user.role === \'editor\'\n  },\n)\n\n// Permissions\n\nconst permissions = shield({\n  Query: {\n    frontPage: not(isAuthenticated),\n    fruits: and(isAuthenticated, or(isAdmin, isEditor)),\n    customers: and(isAuthenticated, isAdmin),\n  },\n  Mutation: {\n    addFruitToBasket: isAuthenticated,\n  },\n  Fruit: isAuthenticated,\n  Customer: isAdmin,\n})\n\nconst server = new GraphQLServer({\n  typeDefs,\n  resolvers,\n  middlewares: [permissions],\n  context: req => ({\n    ...req,\n    user: getUser(req),\n  }),\n})\n\nserver.start(() => console.log(\'Server is running on http://localhost:4000\'))\n```\n\n### Others, using `graphql-middleware`\n\n```ts\n// Permissions...\n\n// Apply permissions middleware with applyMiddleware\n// Giving any schema (instance of GraphQLSchema)\n\nimport { applyMiddleware } from \'graphql-middleware\'\n// schema definition...\nschema = applyMiddleware(schema, permissions)\n```\n\n## API\n\n### Types\n\n```ts\n/* Rule */\nfunction rule(\n  name?: string,\n  options?: IRuleOptions,\n): (func: IRuleFunction) => Rule\n\ntype IFragment = string\ntype ICacheOptions = \'strict\' | \'contextual\' | \'no_cache\' | boolean\ntype IRuleResult = boolean | string | Error\n\ntype IRuleFunction = (\n  parent?: any,\n  args?: any,\n  context?: any,\n  info?: GraphQLResolveInfo,\n) => IRuleResult | Promise<IRuleResult>\n\ninterface IRuleOptions {\n  cache?: ICacheOptions\n  fragment?: IFragment\n}\n\n/* Input */\nfunction inputRule(name?: string): (yup: Yup => Yup.Schema) => Rule\n\n/* Logic */\nfunction and(...rules: IRule[]): LogicRule\nfunction or(...rules: IRule[]): LogicRule\nfunction not(rule: IRule): LogicRule\nconst allow: LogicRule\nconst deny: LogicRule\n\nimport { GraphQLResolveInfo } from \'graphql\'\nimport { IMiddlewareGenerator } from \'graphql-middleware\'\n\n// Rule\n\nexport type IFragment = string\nexport type ICache = \'strict\' | \'contextual\' | \'no_cache\'\nexport type IRuleResult = boolean | string | Error\nexport type IRuleFunction = (\n  parent?: any,\n  args?: any,\n  context?: any,\n  info?: GraphQLResolveInfo,\n) => IRuleResult | Promise<IRuleResult>\n\n// Rule Constructor Options\n\ntype ICacheOptions = \'strict\' | \'contextual\' | \'no_cache\' | boolean\n\ninterface IRuleOptions {\n  cache?: ICacheOptions\n  fragment?: IFragment\n}\n\n// Rules Definition Tree\n\nexport type ShieldRule = IRule | ILogicRule\n\ninterface IRuleFieldMap {\n  [key: string]: ShieldRule\n}\n\ninterface IRuleTypeMap {\n  [key: string]: ShieldRule | IRuleFieldMap\n}\n\ntype IRules = ShieldRule | IRuleTypeMap\n\ntype IHashFunction = (arg: { parent: any; args: any }) => string\n\n// Generator Options\n\ninterface IOptions {\n  debug?: boolean\n  allowExternalErrors?: boolean\n  fallbackRule?: ShieldRule\n  fallbackError?: string | Error\n  hashFunction?: IHashFunction\n}\n\ndeclare function shield(\n  ruleTree: IRules,\n  options: IOptions,\n): IMiddlewareGenerator\n```\n\n### `shield(rules?, options?)`\n\n> Generates GraphQL Middleware layer from your rules.\n\n#### `rules`\n\nA rule map must match your schema definition. All rules must be created using the `rule` function to ensure caches are made correctly. You can apply your `rule` across entire schema, Type scoped, or field specific.\n\n##### Limitations\n\n- All rules must have a distinct name. Usually, you won\'t have to care about this as all names are by default automatically generated to prevent such problems. In case your function needs additional variables from other parts of the code and is defined as a function, you\'ll set a specific name to your rule to avoid name generation.\n\n```jsx\n// Normal\nconst admin = rule({ cache: \'contextual\' })(\n  async (parent, args, ctx, info) => true,\n)\n\n// With external data\nconst admin = bool =>\n  rule(`name-${bool}`, { cache: \'contextual\' })(\n    async (parent, args, ctx, info) => bool,\n  )\n```\n\n- Cache is disabled by default. To enable `cache` generation, set cache option when generating a rule.\n\n##### Cache\n\nYou can choose from three different cache options.\n\n1.  `no_cache` - prevents rules from being cached.\n1.  `contextual` - use when rule only relies on `context` parameter (useful for authentication).\n1.  `strict` - use when rule relies on `parent` or `args` parameter as well (field specific modifications).\n\n```ts\n// Contextual\nconst isAdmin = rule({ cache: \'contextual\' })(\n  async (parent, args, ctx, info) => {\n    return ctx.user.isAdmin\n  },\n)\n\n// Strict\nconst canSeeUserSensitiveData = rule({ cache: \'strict\' })(\n  async (parent, args, ctx, info) => {\n    /* The id of observed User matches the id of authenticated viewer. */\n    return ctx.viewer.id === parent.id\n  },\n)\n\n// No-cache (default)\nconst admin = rule({ cache: \'no_cache\' })(async (parent, args, ctx, info) => {\n  return ctx.user.isAdmin || args.code === \'secret\' || parent.id === \'theone\'\n})\n```\n\n> Backward compatibility: `{ cache: false }` converts to `no_cache`, and `{ cache: true }` converts to `strict`.\n\n##### Custom Errors\n\nShield, by default, catches all errors thrown during resolver execution. This way we can be 100% sure none of your internal logic can be exposed to the client if it was not meant to be.\n\nTo return custom error messages to your client, you can return error instead of throwing it. This way, Shield knows it\'s not a bug but rather a design decision under control. Besides returning an error you can also return a `string` representing a custom error message.\n\nYou can return custom error from resolver or from rule itself. Rules that return error are treated as failing, therefore not processing any further resolvers.\n\n```tsx\nconst typeDefs = `\n  type Query {\n    customErrorInResolver: String\n    customErrorInRule: String\n  }\n`\n\nconst resolvers = {\n  Query: {\n    customErrorInResolver: () => {\n      return new Error(\'Custom error message from resolver.\')\n    },\n    customErrorMessageInRule: () => {\n      // Querying is stopped because rule returns an error\n      console.log("This won\'t be logged.")\n      return "you won\'t see me!"\n    },\n    customErrorInRule: () => {\n      // Querying is stopped because rule returns an error\n      console.log("This won\'t be logged.")\n      return "you won\'t see me!"\n    },\n  },\n}\n\nconst ruleWithCustomError = rule()(async (parent, args, ctx, info) => {\n  return new Error(\'Custom error from rule.\')\n})\n\nconst ruleWithCustomErrorMessage = rule()(async (parent, args, ctx, info) => {\n  return \'Custom error message from rule.\'\n})\n\nconst permissions = shield({\n  Query: {\n    customErrorInRule: ruleWithCustomError,\n    customErrorMessageInRule: ruleWithCustomErrorMessage,\n  },\n})\n\nconst server = GraphQLServer({\n  typeDefs,\n  resolvers,\n  middlewares: [permissions],\n})\n```\n\n> Errors thrown in resolvers can be tracked using `debug` option. This way Shield ensures your code is production ready at all times.\n\n> If you wish to see errors thrown inside resolvers, you can set `allowExternalErrors` option to `true`. This way, Shield won\'t hide custom errors thrown during query resolving.\n\n#### `options`\n\n| Property            | Required | Default                                              | Description                                        |\n| ------------------- | -------- | ---------------------------------------------------- | -------------------------------------------------- |\n| allowExternalErrors | false    | false                                                | Toggle catching internal errors.                   |\n| debug               | false    | false                                                | Toggle debug mode.                                 |\n| fallbackRule        | false    | allow                                                | The default rule for every "rule-undefined" field. |\n| fallbackError       | false    | Error(\'Not Authorised!\')                             | Error Permission system fallbacks to.              |\n| hashFunction        | false    | [object-hash](https://github.com/puleos/object-hash) | Hashing function to use for `strict` cache         |\n\nBy default `shield` ensures no internal data is exposed to client if it was not meant to be. Therefore, all thrown errors during execution resolve in `Not Authorised!` error message if not otherwise specified using `error` wrapper. This can be turned off by setting `allowExternalErrors` option to true.\n\n### Per Type Wildcard Rule\n\nThere is an option to specify a rule that will be applied to all fields of a type (`Query`, `Mutation`, ...) that do not specify a rule.\nIt is similar to the `options.fallbackRule` but allows you to specify a `fallbackRule` per type.\n\n```ts\n// this will only allow query1 and query2.\n// query3 for instance will be denied\n// it will also deny every mutation\n// (you can still use `fallbackRule` option with it)\nconst permissions = shield({\n  Query: {\n    "*": deny\n    query1: allow,\n    query2: allow,\n  },\n  Mutation: {\n    "*": deny\n  },\n}, {\n  fallbackRule: allow\n})\n```\n\n### Basic rules\n\n> `allow`, `deny` are GraphQL Shield predefined rules.\n\n`allow` and `deny` rules do exactly what their names describe.\n\n### Rules on Input Types or Arguments\n\n> Validate arguments using [Yup](https://github.com/jquense/yup).\n\n```ts\nfunction inputRule(name?: string)(yup: Yup => Yup.Schema, options?: Yup.ValidationOptions): Rule\n```\n\nInput rule works exactly as any other rule would work. Instead of providing a complex validation rule you can simply provide a Yup validation schema which will be mached against provided arguments.\nThis can be especially useful when limiting optional fields such as `create` and `connect` with Prisma, for example.\n\n**Example:**\n\n```graphql\ntype Mutation {\n  login(email: String): LoginPayload\n}\n```\n\nNote that Yup receives entire `args` object, therefore, you should start composing schema with an object.\n\n```ts\nconst isEmailEmail = inputRule()(\n  yup =>\n    yup.object({\n      email: yup\n        .string()\n        .email(\'It has to be an email!\')\n        .required(),\n    }),\n  {\n    abortEarly: false,\n  },\n)\n```\n\n### Logic Rules\n\n#### `and`, `or`, `not`, `chain`\n\n> `and`, `or` and `not` allow you to nest rules in logic operations.\n\n##### `and` rule\n\n`And` rule allows access only if all sub rules used return `true`.\n\n##### `chain` rule\n\n`Chain` rule allows you to chain the rules, meaning that rules won\'t be executed all at once, but one by one until one fails or all pass.\n\n> The left-most rule is executed first.\n\n##### `or` rule\n\n`Or` rule allows access if at least one sub rule returns `true` and no rule throws an error.\n\n##### not\n\n`Not` works as usual not in code works.\n\n```tsx\nimport { shield, rule, and, or } from \'graphql-shield\'\n\nconst isAdmin = rule()(async (parent, args, ctx, info) => {\n  return ctx.user.role === \'admin\'\n})\n\nconst isEditor = rule()(async (parent, args, ctx, info) => {\n  return ctx.user.role === \'editor\'\n})\n\nconst isOwner = rule()(async (parent, args, ctx, info) => {\n  return ctx.user.items.some(id => id === parent.id)\n})\n\nconst permissions = shield({\n  Query: {\n    users: or(isAdmin, isEditor),\n  },\n  Mutation: {\n    createBlogPost: or(isAdmin, and(isOwner, isEditor)),\n  },\n  User: {\n    secret: isOwner,\n  },\n})\n```\n\n### Global Fallback Error\n\nGraphQL Shield allows you to set a globally defined fallback error that is used instead of `Not Authorised!` default response. This might be particularly useful for localization. You can use `string` or even custom `Error` to define it.\n\n```ts\nconst permissions = shield(\n  {\n    Query: {\n      items: allow,\n    },\n  },\n  {\n    fallbackError: \'To je napaka!\', // meaning "This is a mistake" in Slovene.\n  },\n)\n\nconst permissions = shield(\n  {\n    Query: {\n      items: allow,\n    },\n  },\n  {\n    fallbackError: new CustomError(\'You are something special!\'),\n  },\n)\n```\n\n### Fragments\n\nFragments allow you to define which fields your rule requires to work correctly. This comes in extremely handy when your rules rely on data from database. You can use fragments to define which data your rule relies on.\n\n```ts\nconst isItemOwner = rule({\n  cache: \'strict\',\n  fragment: \'fragment ItemID on Item { id }\',\n})(async ({ id }, args, ctx, info) => {\n  return ctx.db.exists.Item({\n    id,\n    owner: { id: ctx.user.id },\n  })\n})\n\nconst permissions = shield(\n  {\n    Query: {\n      items: allow,\n    },\n    Item: {\n      id: allow,\n      name: allow,\n      secret: isItemOwner,\n    },\n  },\n  {\n    fallbackRule: deny,\n  },\n)\n\n// GraphQL Yoga\n\nconst server = new GraphQLServer({\n  typeDefs: \'./src/schema.graphql\',\n  resolvers,\n  middlewares: [permissions],\n  context: ({\n    request,\n    response,\n    fragmentReplacements: middlewareFragmentReplacements,\n  }) => {\n    return {\n      request,\n      response,\n      db: new Prisma({\n        fragmentReplacements: [\n          ...middlewareFragmentReplacements,\n          ...resolverFragmentReplacements,\n        ],\n        endpoint: process.env.PRISMA_ENDPOINT,\n        secret: process.env.PRISMA_SECRET,\n        debug: true,\n      }),\n    }\n  },\n})\n\n// GraphQL Middleware\n\nconst { schema, fragmentReplacements } = applyMiddleware(schema, permissions)\n```\n\n### Whitelisting vs Blacklisting\n\n> Whitelisting/Blacklisting is no longer available in versions after `3.x.x`, and has been replaced in favor of `fallbackRule`.\n\nShield allows you to lock-in your schema. This way, you can seamlessly develop and publish your work without worrying about exposing your data. To lock in your service simply set `fallbackRule` to `deny` like this;\n\n```ts\nconst typeDefs = `\n  type Query {\n    users: [User!]!\n    newFeatures: FeaturesConnection!\n  }\n\n  type User {\n    id: ID!\n    name: String!\n    author: Author!\n  }\n\n  type Author {\n    id: ID!\n    name: String!\n    secret: String\n  }\n`\n\nconst permissions = shield(\n  {\n    Query: {\n      users: allow,\n    },\n    User: allow,\n    Author: {\n      id: allow,\n      name: allow,\n    },\n  },\n  { fallbackRule: deny },\n)\n```\n\n> You can achieve same functionality by setting every "rule-undefined" field to `deny` the request.\n\n## Troubleshooting\n\n#### When a single field is "Not Authorised!" the entire parent object returns null.\n\nThis occurs when a non-nullable field (specified in the schema) returns a null value (due to GraphQL Shield blocking the field\'s value). GraphQL is a strongly typed language - the schema serves as a contract between client and server - which requires that the server response follow the schema definition.\n\nSee [#126](https://github.com/maticzav/graphql-shield/issues/126#issuecomment-416524581) and [#97](https://github.com/maticzav/graphql-shield/issues/97#issuecomment-404867307) for more detailed explanations.\n\n#### A rule is executed only once even though the dataset contains multiple values (and thus should execute the rule multiple times)\n\nThis occurs because of caching. When the cache is set to `contextual` only the contextual variable of the rule is expected to be evaluated. Setting the cache to `strict` allows the rule to rely on parent and args parameters as well, while setting the cache to `no_cache` won\'t cache result at all.\n\n## Contributors\n\nThis project exists thanks to all the people who contribute. [[Contribute](https://github.com/maticzav/graphql-shield/graphs/contributors)].\n<a href="https://github.com/maticzav/graphql-shield/graphs/contributors"><img src="https://opencollective.com/graphql-shield/contributors.svg?width=890&button=false" /></a>\n\n## Backers\n\nThank you to all our backers! \xf0\x9f\x99\x8f [[Become a backer](https://opencollective.com/graphql-shield#backer)]\n\n<a href="https://opencollective.com/graphql-shield#backers" target="_blank"><img src="https://opencollective.com/graphql-shield/backers.svg?width=890"></a>\n\n## Sponsors\n\nSupport this project by becoming a sponsor. Your logo will show up here with a link to your website. [[Become a sponsor](https://opencollective.com/graphql-shield#sponsor)]\n\n<a href="https://opencollective.com/graphql-shield/sponsor/0/website" target="_blank"><img src="https://opencollective.com/graphql-shield/sponsor/0/avatar.svg"></a>\n<a href="https://opencollective.com/graphql-shield/sponsor/1/website" target="_blank"><img src="https://opencollective.com/graphql-shield/sponsor/1/avatar.svg"></a>\n<a href="https://opencollective.com/graphql-shield/sponsor/2/website" target="_blank"><img src="https://opencollective.com/graphql-shield/sponsor/2/avatar.svg"></a>\n<a href="https://opencollective.com/graphql-shield/sponsor/3/website" target="_blank"><img src="https://opencollective.com/graphql-shield/sponsor/3/avatar.svg"></a>\n<a href="https://opencollective.com/graphql-shield/sponsor/4/website" target="_blank"><img src="https://opencollective.com/graphql-shield/sponsor/4/avatar.svg"></a>\n<a href="https://opencollective.com/graphql-shield/sponsor/5/website" target="_blank"><img src="https://opencollective.com/graphql-shield/sponsor/5/avatar.svg"></a>\n<a href="https://opencollective.com/graphql-shield/sponsor/6/website" target="_blank"><img src="https://opencollective.com/graphql-shield/sponsor/6/avatar.svg"></a>\n<a href="https://opencollective.com/graphql-shield/sponsor/7/website" target="_blank"><img src="https://opencollective.com/graphql-shield/sponsor/7/avatar.svg"></a>\n<a href="https://opencollective.com/graphql-shield/sponsor/8/website" target="_blank"><img src="https://opencollective.com/graphql-shield/sponsor/8/avatar.svg"></a>\n<a href="https://opencollective.com/graphql-shield/sponsor/9/website" target="_blank"><img src="https://opencollective.com/graphql-shield/sponsor/9/avatar.svg"></a>\n\n## Contributing\n\nWe are always looking for people to help us grow `graphql-shield`! If you have an issue, feature request, or pull request, let us know!\n\n## License\n\nMIT @ Matic Zavadlal\n'