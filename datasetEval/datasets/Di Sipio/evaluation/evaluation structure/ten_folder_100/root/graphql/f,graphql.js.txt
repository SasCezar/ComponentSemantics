b'<p align="center">\n<img src="./resources/logotype.png" width="400">\n</p>\n<h2 align="center">graphql.js: lightweight graphql client</h2>\n<p align="center">\n Lightest GraphQL client with intelligent features.\n</p>\n\n<hr/>\n\n[![Bower version](https://badge.fury.io/bo/graphql.js.svg)](http://badge.fury.io/bo/graphql.js)\n[![NPM version](https://badge.fury.io/js/graphql.js.svg)](http://badge.fury.io/js/graphql.js)\n[![Build Status](https://travis-ci.org/f/graphql.js.svg?branch=master)](https://travis-ci.org/f/graphql.js)\n\n> Originally inspired by [Robert Mosolgo\'s blog post](http://rmosolgo.github.io/blog/2016/03/03/using-graphql-without-relay/)\n\n### Features\n\n- Too small, 4k gzipped.\n- No dependencies, plain vanilla JavaScript.\n- Plug & Play.\n- Isomorphic.\n- Runs on most browsers.\n- You don\'t need to install Node.js ecosystem on your computer.\n- Query merging to reduce request number.\n\n## Overview\n\nGraphQL is based on a very simple HTTP transaction, which sends a request to an endpoint\nwith `query` and `variables`.\n\nMany libraries require _complex stacks_ to make that simple request.\nIn any project you don\'t use **React**, **Relay**, you\'ll need a simpler\nclient which manages your query and makes a simple request.\n\n```js\n// Connect...\nvar graph = graphql("/graphql")\n\n// Prepare...\ngraph.fragment({\n  user: `on User {\n    id,\n    name\n  }`\n})\n\nconst allUsers = graph(`query { allUsers { ...user } }`)\n\nconst createUser = graph(`mutation (@autodeclare) {\n  createUser($firstName, $lastName) { ...user }\n}`)\n\nawait createUser({\n  firstName: "John",\n  lastName: "Doe"\n})\n\nconst users = await allUsers()\n\nconsole.log(users)\n// {\n//   "allUsers": [{ "id": 1, "name": "John Doe" }]\n// }\n```\n\n## Installation\n\nYou can download `graphql.js` directly, or you can use **Bower** or **NPM**.\n\n#### Download for Browser\n\n- [Development Version - 12kb](https://raw.githubusercontent.com/f/graphql.js/master/graphql.js)\n- [Production Version - 6kb](https://raw.githubusercontent.com/f/graphql.js/master/graphql.min.js)\n\n#### Using Bower\n```bash\nbower install graphql.js --save\n```\n\n#### Using NPM\n```bash\nnpm install graphql.js --save\n\n# or\n\nyarn add graphql.js\n```\n\n#### Using with Rails Asset Pipeline\n\nYou can use GraphQL.js with Rails Asset Pipeline using [graphqljs-rails](https://github.com/f/graphqljs-rails).\n\n## Using\n\nGraphQL.js is **isomorphic**. You can use it in both **browser and Node.js**.\n\n#### Use in Browser\n\n```html\n<script src="/path/to/graphql.js"></script>\n```\n\n#### Use in Node.js\n\n```js\nvar graphql = require(\'graphql.js\')\n```\n\nOr using `import`\n```js\nimport graphql from \'graphql.js\'\n```\n\n## Connection\n\nCreate a simple connection to your GraphQL endpoint.\n\n```js\nvar graph = graphql("http://localhost:3000/graphql", {\n  method: "POST", // POST by default.\n  headers: {\n    // headers\n    "Access-Token": "some-access-token"\n    // OR "Access-Token": () => "some-access-token"\n  },\n  fragments: {\n    // fragments, you don\'t need to say `fragment name`.\n    auth: "on User { token }",\n    error: "on Error { messages }"\n  }\n})\n```\n\n## Executing Queries and Mutations\n\n`graph` will be a simple function that accepts `query` and `variables` as parameters.\n\n```js\ngraph(`query ($email: String!, $password: String!) {\n  auth(email: $email, password: $password) {\n    ... auth # if you use any fragment, it will be added to the query.\n    ... error\n  }\n}`, {\n  email: "john@doe.com",\n  password: "my-super-password"\n}).then(function (response) {\n  // response is originally response.data of query result\n  console.log(response)\n}).catch(function (error) {\n  // response is originally response.errors of query result\n  console.log(error)\n})\n```\n\n### Prepare Query for Lazy Execution\n\nYou can prepare queries for lazy execution. This will allow you to reuse your queries with\ndifferent variables without any hassle.\n\n```js\nvar login = graph(`query ($email: String!, $password: String!) {\n  auth(email: $email, password: $password) {\n    ... on User {\n      token\n    }\n  }\n}`)\n\n// Call it later...\nlogin({\n  email: "john@doe.com",\n  password: "my-super-password"\n})\n```\n\n#### Direct Execution with `.run` and ES6 Template Tag\n\nIf your query doesn\'t need any variables, it will generate a lazy execution query by default.\nIf you want to run your query immediately, you have three following options:\n\n```js\n// 1st option. create and run function.\ngraph(`...`)()\ngraph.query(`...`)()\ngraph.mutate(`...`)()\n//...\n\n// 2nd option. create and run function with `run` method.\ngraph.run(`...`)\ngraph.query.run(`...`)\ngraph.mutate.run(`...`)\n\n// 3rd option. create and run function with template tag.\ngraph`...`\ngraph.query`...`\ngraph.mutate`...`\n```\n\n> **I don\'t recommend** using this. Using it too much may break DRY. Use lazy execution as much as possible.\n\n### Prefix Helpers\n\nYou can prefix your queries by simply calling helper methods: `.query`, `.mutate` or `.subscribe`\n\n```js\nvar login = graph.query(`($email: String!, $password: String!) {\n  auth(email: $email, password: $password) {\n    ... on User {\n      token\n    }\n  }\n}`)\n\nvar increment = graph.mutate`increment { state }`\nvar onIncrement = graph.subscribe`onIncrement { state }`\n```\n\n### Automatic Declaring with `@autodeclare` or `{declare: true}`\n\nDeclaring primitive-typed (`String`, `Int`, `Float`, `Boolean`) variables in query were a\nlittle bothering to me. That\'s why I added an `@autodeclare` keyword or `{declare: true}` setting to the processor.\nIt detects types from the variables and declares them in query automatically.\n\n```js\nvar login = graph.query(`(@autodeclare) {\n  auth(email: $email, password: $password) {\n    ... on User {\n      token\n    }\n  }\n}`)\n\nlogin({\n  email: "john@doe.com", // It\'s String! obviously.\n  password: "my-super-password" // It is, too.\n})\n```\n\nThis will create following query:\n\n```graphql\nquery ($email: String!, $password: String!) {\n  auth(email: $email, password: $password) {\n    ... on User {\n      token\n    }\n  }\n}\n```\n\nYou can also pass `{declare: true}` option to the `.query`, `.mutate` and `.subscribe` helper:\n\n```js\nvar login = graph.query(`auth(email: $email, password: $password) {\n  ... on User {\n    token\n  }\n}`, {declare: true})\n```\n\nThis will also create the same query above.\n\n#### Detecting IDs\n\nVariable names with matching `/_id/i` pattern will be declared as `ID` type. Following examples will be declared as IDs:\n\n- `id: 1` will be declared as `$id: ID!`\n- `post_id: "123af"` will be declared as `$post_id: ID!`\n- `postID: 3` will be declared as `$postID: ID!`\n- `postId: 4` will be declared as `$postId: ID!`\n\nYou can disable auto ID declaration by adding an `!` to the end of the variable name:\n\n- `id!: 1` will be declared as `$id: Int!`\n- `post_id!: "123af"` will be declared as `$post_id: String!`\n\nAnd, explicitly given types are prioritized.\n\n- `postID!CustomId: 3` will be declared as `$postID: CustomId!`\n- `postId!UUID: 4` will be declared as `$postId: UUID!`\n\n```js\nvar userById = graph.query(`(@autodeclare) {\n  user(id: $id) {\n    email\n  }\n}`)\n\nuserById({\n  id: 15\n})\n```\n\nThe example above will generate following query:\n\n```graphql\nquery ($id: ID!) {\n  user(id: $id) {\n    email\n  }\n}\n```\n\n#### Solving `Integer` and `Float` Problem\n\nLet\'s say you have a `rating` query that accepts an argument with a `Float` argument named `rating`.\nGraphQL.js will declare `10` value as `Integer` since it casts using `value % 1 === 0 ? \'Int\' : \'Float\'` check.\n\n```js\nvar rate = graph.query(`(@autodeclare) {\n  rating(rating: $rating) {\n    rating\n  }\n}`)\n\nrate({\n  rating: 10\n})\n```\n\nIn this case, you must use `!` mark to force your type to be `Float` as below:\n\n```js\nrate({\n  "rating!Float": 10\n})\n```\n\nThis will bypass the casting and declare `rating` as `Float`.\n\n### Advanced Auto Declaring\n\nBeside you can pass `{declare: true}` to helpers:\n\n```js\ngraph.query("auth(email: $email, password: $password) { token }", {declare: true})\n```\n\nAlso you can enable auto declaration to run by default using `alwaysAutodeclare` setting.\n\n```js\nvar graph = graphql("http://localhost:3000/graphql", {\n  alwaysAutodeclare: true\n})\n```\n\nAfter you enable `alwaysAutodeclare` option, your methods will try to detect types of variables and declare them.\n\n```js\n// When alwaysAutodeclare is true, you don\'t have to pass {declare: true} option.\n\ngraph.query("auth(email: $email, password: $password) { token }")\n```\n\n#### Auto Declaring Custom Types\n\nYou can define custom types when defining variables by using a simple `"variable!Type"` notation.\nIt will help you to make more complex variables:\n\n```js\nvar register = graph.mutate(`(@autodeclare) {\n  userRegister(input: $input) { ... }\n}`)\n\nregister({\n  // variable name and type.\n  "input!UserRegisterInput": { ... }\n})\n```\n\nThis will generate following query:\n\n```graphql\nmutation ($input: UserRegisterInput!) {\n  userRegister(input: $input) { ... }\n}\n```\n\n## Fragments\n\nFragments make your GraphQL more DRY and improves reusability. With `.fragment` method, you\'ll\nmanage your fragments easily.\n\n### Simple Fragments\n\nWhile constructing your endpoint, you can predefine all of your fragments.\n\n```js\nvar graph = graphql("/graphql", {\n  fragments: {\n    userInfo: `on User { id, name, surname, avatar }`\n  }\n})\n```\n\nAnd you can use your fragments in your queries. The query will pick your fragments and\nwill add them to the bottom of your query.\n\n```js\ngraph.query(`{ allUsers { ...userInfo } }`)\n```\n\n### Nested Fragments\n\nYou can nest your fragments to keep them organized/namespaced.\n\n```js\nvar graph = graphql("/graphql", {\n  fragments: {\n    user: {\n      info: `on User { id, name, surname, avatar }`\n    }\n  }\n})\n```\n\nAccessing them is also intuitive:\n\n```js\ngraph.query(`{ allUsers { ...user.info } }`)\n```\n\n### Using Fragments in Fragments\n\nYou can reuse fragments in your fragments.\n\n```js\ngraph.fragment({\n  user: "on User {name, surname}",\n  login: {\n    auth: "on User {token, ...user}"\n  }\n})\n```\n\n### Lazy Fragments\n\nYou can also add fragments lazily. So you can use your fragments more modular.\n\n```js\n// Adds a profile fragment\ngraph.fragment({\n  profile: `on User {\n    id\n    name(full: true)\n    avatar\n  }`\n})\n\nvar allUsers = graph.query(`{\n  allUsers {\n    ... profile\n  }\n}`)\n\nallUsers().then(...)\n```\n\nAlso you can add **nested fragments** lazily, too:\n\n```js\ngraph.fragment({\n  login: {\n    error: `on LoginError {\n      reason\n    }`\n  }\n})\n\ngraph.fragment({\n  something: {\n    error: `on SomeError {\n      messages\n    }`\n  }\n})\n\ngraph.query(`{ login {... login.error } }`)\ngraph.query(`{ something {... something.error } }`)\n```\n\n### Getting Fragments by Path\n\nYou can call fragment string by using `.fragment` method. You have to pass path string to get the fragment.\n\n```js\ngraph.fragment(\'login.error\')\n```\n\nThis will give you the matching fragment code:\n\n```graphql\nfragment login_error on LoginError {\n  reason\n}\n```\n\n### Using Fragments in Tag Query\n\nYou can use fragments lazily using ES6 template tag queries.\n\n```js\nvar userProfileToShow = graph.fragment(\'user.profile\')\n\ngraph`query { ... ${userProfileToShow} }`\n```\n\n### Query Building\n\nYou can create queries using `.ql` **ES6 template tag**.\n\n```js\n// Add some fragments...\ngraph.fragment({\n  username: {\n    user: `on User {\n      username\n    }`,\n    admin: `on AdminUser {\n      username,\n      administrationLevel\n    }`\n  }\n})\n\n// Get any fragment with its path...\nvar admin = graph.fragment(\'username.admin\')\n\n// Build your query with using fragment paths or dynamic template variables.\nvar query = graph.ql`query {\n  ...username.user\n  ...${admin}\n}`\n\n// Use query anywhere...\n$.post("/graphql", {query: query}, function (response) { ... })\n```\n\n`graph.ql` will generate this query string:\n\n```graphql\nquery {\n  ... username_user\n  ... username_admin\n}\n\nfragment username_user on User {\n  username\n}\n\nfragment username_admin on AdminUser {\n  username,\n  administrationLevel\n}\n```\n\n### Query Merging: Merge Multiple Queries into One Request\n\n![merge](./resources/graphql-merge.gif)\n\n> This GIF shows a **before/after** case to make an example how query merging changes the performance.\n\n`graphql.js` supports **query merging** that allows you to collect all the requests into one request.\n\nAssume we\'ve these queries on server, define them just like before we do:\n```js\nvar fetchPost = graph.query(`{\n  post(id: $id) {\n    id\n    title\n    text\n  }\n}`)\n\nvar fetchComments = graph.query(`{\n  commentsOfPost: comments(postId: $postId) {\n    comment\n    owner {\n      name\n    }\n  }\n}`)\n```\n\nNormally, we make requests as following:\n\n```js\nvar postId = 123\n\n// This will send a request.\nfetchPost({ id: postId }).then(function (response) {\n  console.log(response.post)\n})\n\n// This also will send a request.\nfetchComments({ postId: postId }).then(function (response) {\n  console.log(response.commentsOfPost)\n})\n```\n\nThis will make two requests:\n\n![ss1](./resources/ss1.png)\n\nUse **`.merge(mergeName, variables)`** command to put them into a merge buffer:\n\n```js\nvar postId = 123\n\n// This won\'t send a request.\nfetchPost.merge(\'buildPage\', { id: postId }).then(function (response) {\n  console.log(response.post)\n})\n\n// This also won\'t send a request.\nfetchComments.merge(\'buildPage\', { postId: postId }).then(function (response) {\n  console.log(response.commentsOfPost)\n})\n```\n\nThese will create a buffer with *buildPage* name, and append the queries to that buffer. You need to use **`commit(mergeName)`** to merge the buffer and send to the server, the response will be consolidated:\n\n```js\n// This will send a merged request:\ngraph.commit(\'buildPage\').then(function (response) {\n  // All base fields will be in response return.\n  console.log(response.post)\n  console.log(response.commentsOfPost)\n})\n```\n\nAnd this will create only one request:\n\n![ss2](./resources/ss2.png)\n\nThis will create the following merged query generated by **graphql.js**:\n\n```graphql\nquery ($merge024533__id: ID!, $merge141499__postId: ID!) {\n  merge024533_post: {\n    post(id: $merge024533__id) {\n      id\n      title\n      text\n    }\n  }\n  merge141499_commentsOfPost: {\n    comments(postId: $merge141499__postId) {\n      comment\n      owner {\n        name\n      }\n    }\n  }\n}\n```\n\nAnd variables will be generated, too:\n\n```js\n{\n  "merge024533__id": 123,\n  "merge141499__postId": 123\n}\n```\n\n> The `merge{number}` aliases won\'t be passed into your responses, since they will be used for initial seperation.\n\n> \xe2\x9a\xa0\xef\xb8\x8f **Important Restriction**: You cannot use multiple root fields using query merging.\n> \xe2\x9a\xa0\xef\xb8\x8f **Important Restriction**: Autodeclaration is on by default, do not use `alwaysAutodeclare: true`.\n\n## Debugging\n\nYou can pass `debug: true` to options parameter to get a console output looks like following:\n\n```\n[graphql]: POST http://localhost:3000/graphql\n  QUERY: query ($email: String!, $password: String!) {\n    auth(email: $email, password: $password) {\n      .. login_auth\n    }\n  }\n\n  fragment info on User { hasPin }\n  fragment login_auth on User { token, ...info }\n\n  VARIABLES: {\n    "email": "john@doe.com",\n    "password": "123123"\n  }\n\n  sending as form url-data\n```\n\n## Advanced\n### Using with Vue.js\n\nCreate a `GraphQLProvider.js`.\n\n```js\nimport graphql from \'graphql.js\';\n\n/* eslint-disable no-underscore-dangle */\nexport default {\n  install(Vue, url, options) {\n    Vue.mixin({\n      created() {\n        this._graph = graphql(url, options);\n      },\n    });\n    Object.defineProperty(Vue.prototype, \'$graph\', {\n      get() {\n        return this._graph;\n      },\n    });\n  },\n};\n```\n\nAnd then you can use this with your Vue app:\n\n```js\nimport Vue from \'vue\';\nimport GraphQLProvider from \'./GraphQLProvider\';\n\nVue.use(GraphQLProvider, \'http://localhost:3000/graphql\', {\n  headers: {\n    // headers...\n  },\n});\n\n// ... in your Vue VM\ndata() {\n  return {\n    hello: \'\',\n  };\n},\nmethods: {\n  makeSomeQuery() {\n    this.$graph.query(`{hello}`).then(response => {\n      this.hello = response.hello;\n    });\n  },\n}\n```\n\n### Change POST Method\n\nAs default, GraphQL.js makes a POST request. But you can change the behavior by setting `asJSON`.\n\n```js\nvar graph = graphql("http://localhost:3000/graphql", {\n  asJSON: true\n});\n```\n### Using with `graphql-tag`\n\n[`graphql-tag`](https://github.com/apollographql/graphql-tag) converts GraphQL query strings to AST. You can use `graphql-tag` with GraphQL.js\n\n```js\ngraph.query(gql`query { name }`)\n```\n\n> Using `graphql-tag` will not allow you to use _auto declaration_ and _nested fragments_ syntaxes since these are not valid query syntax for GraphQL but only for this library.\n\n### Change Url Anywhere\n\nYou can change url anywhere with `setUrl` method.\n\n```js\nvar graph = graphql("http://localhost:3000/graphql", {\n  asJSON: true\n});\n\n// Change url\ngraph.setUrl(\'http://www.example.com\')\n\n// Run query\ngraph.query(`{ name }`)\n```\n\n---\n\n## Todo App Example\n\nA CRUD ToDo app example code to show how to use GraphQL.js. An implementation can be found at [**f/graphql.js-demo**](https://github.com/f/graphql.js-demo)\n\n```js\nvar graph = graphql("/graphql", {\n  alwaysAutodeclare: true,\n  fragments: {\n    todo: `on Todo {\n      id\n      text\n      isCompleted\n    }`\n  }\n})\n\nfunction getTodos() {\n  return graph.query.run(`allTodos {\n    ...todo\n  }`)\n}\n\nfunction addTodo(text) {\n  return graph.mutate(`todoAdd(text: $text) {\n    ...todo\n  }`, {\n    text: text\n  })\n}\n\nfunction setTodo(id, isCompleted) {\n  return graph.mutate(`todoComplete(\n    id: $id,\n    status: $isCompleted\n  ) {\n    ...todo\n  }`, {\n    id: id,\n    isCompleted: isCompleted\n  })\n}\n\nfunction removeTodo(id) {\n  return graph.mutate(`todoRemove(\n    id: $id\n  ) {\n    ...todo\n  }`, {\n    id: id\n  })\n}\n```\n\n## License\n\nMIT License\n\nCopyright (c) 2018 Fatih Kadir Ak\xc4\xb1n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n'