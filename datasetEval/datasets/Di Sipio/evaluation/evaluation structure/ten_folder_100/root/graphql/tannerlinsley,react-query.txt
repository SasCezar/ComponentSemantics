b'![React Query Header](https://github.com/tannerlinsley/react-query/raw/master/media/header.png)\n\n<img src=\'https://github.com/tannerlinsley/react-query/raw/master/media/logo.png\' width=\'300\'/>\n\nHooks for fetching, caching and updating asynchronous data in React\n\n<!-- <a href="https://travis-ci.org/tannerlinsley/react-query" target="\\_parent">\n  <img alt="" src="https://travis-ci.org/tannerlinsley/react-query.svg?branch=master" />\n</a> -->\n<a href="https://twitter.com/intent/tweet?button_hashtag=TanStack" target="\\_parent">\n  <img alt="#TanStack" src="https://img.shields.io/twitter/url?color=%2308a0e9&label=%23TanStack&style=social&url=https%3A%2F%2Ftwitter.com%2Fintent%2Ftweet%3Fbutton_hashtag%3DTanStack">\n</a>\n<a href="https://npmjs.com/package/react-query" target="\\_parent">\n  <img alt="" src="https://img.shields.io/npm/dm/react-query.svg" />\n</a>\n<a href="https://bundlephobia.com/result?p=react-query@latest" target="\\_parent">\n  <img alt="" src="https://badgen.net/bundlephobia/minzip/react-query@latest" />\n</a>\n<a href="https://spectrum.chat/react-query">\n  <img alt="Join the community on Spectrum" src="https://withspectrum.github.io/badge/badge.svg" />\n</a>\n<a href="https://github.com/tannerlinsley/react-query" target="\\_parent">\n  <img alt="" src="https://img.shields.io/github/stars/tannerlinsley/react-query.svg?style=social&label=Star" />\n</a>\n<a href="https://twitter.com/tannerlinsley" target="\\_parent">\n  <img alt="" src="https://img.shields.io/twitter/follow/tannerlinsley.svg?style=social&label=Follow" />\n</a>\n\nEnjoy this library? Try them all! [React Table](https://github.com/tannerlinsley/react-table), [React Form](https://github.com/tannerlinsley/react-form), [React Charts](https://github.com/tannerlinsley/react-charts)\n\n## Quick Features\n\n- Transport, protocol & backend agnostic data fetching\n- Auto Caching + Refetching (stale-while-revalidate, Window Refocus, Polling/Realtime)\n- Parallel + Dependent Queries\n- Mutations + Automatic Query Refetching\n- Multi-layer Cache + Garbage Collection\n- Load-More Pagination + Scroll Recovery\n- Request Cancellation\n- [React Suspense](https://reactjs.org/docs/concurrent-mode-suspense.html) Support\n- <a href="https://bundlephobia.com/result?p=react-query@latest" target="\\_parent">\n    <img alt="" src="https://badgen.net/bundlephobia/minzip/react-query@latest" />\n  </a>\n\n<details>\n<summary>Core Issues and Solution</summary>\n\n## The Challenge\n\nTools for managing async data and client stores/caches are plentiful these days, but most of these tools:\n\n- Duplicate unnecessary network operations\n- Force normalized or object/id-based caching strategies on your data\n- Do not automatically manage stale-ness or caching\n- Do not offer robust API\'s around mutation events, invalidation or query management\n- Are built for highly-opinionated systems like Redux, GraphQL, [insert proprietary tools] etc.\n\n## The Solution\n\nReact Query exports a set of hooks that attempt to address these issues. Out of the box, React Query:\n\n- Flexibly dedupes simultaneous requests to assets\n- Automatically caches data\n- Automatically invalidates stale cache data\n- Optimistically updates stale requests in the background\n- Automatically manages garbage collection\n- Supports automatic retries and exponential or custom back-off delays\n- Provides both declarative and imperative API\'s for:\n  - Mutations and automatic query syncing\n  - Query Refetching\n  - Atomic and Optimistic query manipulation\n\n</details>\n\n<details>\n<summary>Inspiration & Hat-Tipping</summary>\n<br />\nA big thanks to both [Draqula](https://github.com/vadimdemedes/draqula) for inspiring a lot of React Query\'s original API and documentation and also [Zeit\'s SWR](https://github.com/zeit/swr) and its creators for inspiring even further customizations and examples. You all rock!\n\n</details>\n\n## Examples\n\n- [Basic](./examples/basic)\n- [Custom Hooks](./examples/custom-hooks)\n- [Auto Refetching / Polling / Realtime](./examples/auto-refetching)\n- [Window Refocus Refetching](./examples/focus-refetching)\n- [Optimistic Updates](./examples/optimistic-updates)\n- [Load-More Pagination](./examples/load-more-pagination)\n- [Suspense CodeSandbox](https://codesandbox.io/s/github/tannerlinsley/react-query/tree/master/examples/suspense)\n- [Playground CodeSandbox](https://codesandbox.io/s/github/tannerlinsley/react-query/tree/master/examples/sandbox)\n\n## Sponsors\n\nThis library is being built and maintained by me, @tannerlinsley and I am always in need of more support to keep projects like this afloat. If you would like to get premium support, add your logo or name on this README, or simply just contribute to my open source Sponsorship goal, [visit my Github Sponsors page!](https://github.com/sponsors/tannerlinsley/)\n\n<table>\n  <tbody>\n    <tr>\n      <td align="center" valign="middle">\n        <a href="https://github.com/sponsors/tannerlinsley" target="_blank">\n          <img width=\'150\' src="https://raw.githubusercontent.com/tannerlinsley/files/master/images/patreon/diamond.png">\n        </a>\n      </td>\n      <td align="center" valign="middle">\n        <a href="https://github.com/sponsors/tannerlinsley" target="_blank">\n          Become a Sponsor!\n        </a>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<table>\n  <tbody>\n    <tr>\n      <td align="center" valign="middle">\n        <a href="https://github.com/sponsors/tannerlinsley/" target="_blank">\n          <img width=\'150\' src="https://raw.githubusercontent.com/tannerlinsley/files/master/images/patreon/platinum.png">\n        </a>\n      </td>\n      <td align="center" valign="middle">\n       <a href="https://github.com/sponsors/tannerlinsley" target="_blank">\n          Become a Sponsor!\n        </a>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<table>\n  <tbody>\n    <tr>\n      <td align="center" valign="middle">\n        <a href="https://github.com/sponsors/tannerlinsley/" target="_blank">\n          <img width=\'150\' src="https://raw.githubusercontent.com/tannerlinsley/files/master/images/patreon/gold.png">\n        </a>\n      </td>\n      <td align="center" valign="middle">\n        <a href="https://github.com/sponsors/tannerlinsley" target="_blank">\n          Become a Sponsor!\n        </a>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<table>\n  <tbody>\n    <tr>\n      <td align="center" valign="middle">\n        <a href="https://github.com/sponsors/tannerlinsley/" target="_blank">\n          <img width=\'150\' src="https://raw.githubusercontent.com/tannerlinsley/files/master/images/patreon/silver.png">\n        </a>\n      </td>\n      <td align="center" valign="middle">\n        <a href="https://github.com/sponsors/tannerlinsley" target="_blank">\n          Become a Sponsor!\n        </a>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<table>\n  <tbody>\n    <tr>\n      <td valign="top">\n        <a href="https://github.com/sponsors/tannerlinsley/">\n          <img width=\'150\' src="https://raw.githubusercontent.com/tannerlinsley/files/master/images/patreon/supporters.png" />\n        </a>\n      </td>\n      <td>\n        <ul>\n          <li><a href="https://github.com/bgazzera">@bgazzera<a></li>\n        </ul>\n      </td>\n      <td>\n        <a href="https://github.com/sponsors/tannerlinsley" target="_blank">\n          Become a Supporter!\n        </a>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<table>\n  <tbody>\n    <tr>\n      <td valign="top">\n        <a href="https://github.com/sponsors/tannerlinsley/">\n          <img width=\'150\' src="https://raw.githubusercontent.com/tannerlinsley/files/master/images/patreon/fans.png" />\n        </a>\n      </td>\n      <!-- <td>\n        <ul>\n        <li></li>\n        </ul>\n      </td> -->\n      <td>\n        <a href="https://github.com/sponsors/tannerlinsley" target="_blank">\n          Become a Fan!\n        </a>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n# Documentation\n\n- [Installation](#installation)\n- [Queries](#queries)\n  - [Query Keys](#query-keys)\n  - [Query Variables](#query-variables)\n  - [Dependent Queries](#dependent-queries)\n  - [Caching & Invalidation](#caching--invalidation)\n  - [Load-More & Infinite-Scroll Pagination](#load-more--infinite-scroll-pagination)\n  - [Scroll Restoration](#scroll-restoration)\n  - [Manual Querying](#manual-querying)\n  - [Retries](#retries)\n  - [Retry Delay](#retry-delay)\n  - [Prefetching](#prefetching)\n  - [Suspense Mode](#suspense-mode)\n  - [Fetch-on-render vs Fetch-as-you-render](#fetch-on-render-vs-fetch-as-you-render)\n  - [Cancelling Query Requests](#cancelling-query-requests)\n- [Mutations](#mutations)\n  - [Basic Mutations](#basic-mutations)\n  - [Mutation Variables](#mutation-variables)\n  - [Invalidate and Refetch Queries from Mutations](#invalidate-and-refetch-queries-from-mutations)\n  - [Query Updates from Mutations](#query-updates-from-mutations)\n- [Manually or Optimistically Setting Query Data](#manually-or-optimistically-setting-query-data)\n- [Displaying Background Fetching Loading States](#displaying-background-fetching-loading-states)\n- [Displaying Global Background Fetching Loading State](#displaying-global-background-fetching-loading-state)\n- [Window-Focus Refetching](#window-focus-refetching)\n- [Custom Query Key Serializers (Experimental)](#custom-query-key-serializers-experimental)\n- [API](#api)\n  - [`useQuery`](#usequery)\n  - [`useMutation`](#usemutation)\n  - [`setQueryData`](#setquerydata)\n  - [`refetchQuery`](#refetchquery)\n  - [`prefetchQuery`](#prefetchQuery)\n  - [`refetchAllQueries`](#refetchallqueries)\n  - [`useIsFetching`](#useisfetching)\n  - [`clearQueryCache`](#clearquerycache)\n  - [`ReactQueryConfigProvider`](#reactqueryconfigprovider)\n\n## Installation\n\n```bash\n$ npm i --save react-query\n# or\n$ yarn add react-query\n```\n\n## Queries\n\nTo make a new query, call the `useQuery` hook with:\n\n- A **unique key for the query**\n- An **asynchronous function (or similar then-able)** to resolve the data\n\n```js\nconst info = useQuery(\'todos\', fetchTodoList)\n```\n\nThe **unique key** you provide is used internally for refetching, caching, deduping related queries.\n\nThis key can be whatever you\'d like it to be as long as:\n\n- It changes when your query should be requested again\n- It is consistent across all instances of that specific query in your application\n\nThe query `info` returned contains all information about the query and can be easily destructured and used in your component:\n\n```js\nfunction Todos() {\n  const { data, isLoading, error } = useQuery(\'todos\', fetchTodoList)\n\n  return (\n    <div>\n      {isLoading ? (\n        <span>Loading...</span>\n      ) : error ? (\n        <span>Error: {error.message}</span>\n      ) : data ? (\n        <ul>\n          {data.map(todo => (\n            <li key={todo.id}>{todo.title}</li>\n          ))}\n        </ul>\n      ) : null}\n    </div>\n  )\n}\n```\n\n### Query Keys\n\nSince React Query uses a query\'s **unique key** for essentially everything, it\'s important to tailor them so that will change with your query requirements. In other libraries like Zeit\'s SWR, you\'ll see the use of URL\'s and GraphQL query template strings to achieve this, but we believe at scale, this becomes prone to typos and errors. To relieve this issue, you can pass a **tuple key** with a `string` and `object` of variables to deterministically get the the same key.\n\n> Pro Tip: Variables passed in the key are automatically passed to your query function!\n\nAll of the following queries would result in using the same key:\n\n```js\nuseQuery([\'todos\', { status, page }])\nuseQuery([\'todos\', { page, status }])\nuseQuery([\'todos\', { page, status, other: undefined }])\n```\n\n### Query Variables\n\nTo use external props, state, or variables in a query function, pass them as a variables in your query key! They will be passed through to your query function as the first parameter.\n\n```js\nfunction Todos({ status }) {\n  const { data, isLoading, error } = useQuery(\n    [\'todos\', { status, page }],\n    fetchTodoList // This is the same as `fetchTodoList({ status, page })`\n  )\n}\n```\n\nWhenever a query\'s key changes, the query will automatically update:\n\n```js\nfunction Todos() {\n  const [page, setPage] = useState(0)\n\n  const { data, isLoading, error } = useQuery(\n    [\'todos\', { page }],\n    fetchTodoList\n  )\n\n  const onNextPage = () => {\n    setPage(page => page + 1)\n  }\n\n  return (\n    <>\n      {/* ... */}\n      <button onClick={onNextPage}>Load next page</button>\n    </>\n  )\n}\n```\n\n### Dependent Queries\n\nReact Query makes it easy to make queries that depend on other queries for both:\n\n- Parallel Queries (avoiding waterfalls) and\n- Serial Queries (when a piece of data is required for the next query to happen.\n\nTo do this, you can use the following 2 approaches:\n\n#### Pass a falsey query key\n\nIf a query isn\'t ready to be requested yet, just pass a falsey value as the query key:\n\n```js\nconst { data: user } = useQuery([\'user\', { userId }])\nconst { data: projects } = useQuery(user && [\'projects\', { userId: user.id }]) // User is `null`, so the query key will be falsey\n```\n\n#### Use a query key function\n\nIf a function is passed, the query will not execute until the function can be called without throwing:\n\n```js\nconst { data: user } = useQuery([\'user\', { userId }])\nconst { data: projects } = useQuery(() => [\'projects\', { userId: user.id }]) // This will throw until `user` is available\n```\n\n#### Mix them together!\n\n```js\nconst [ready, setReady] = React.useState(false)\nconst { data: user } = useQuery(ready && [\'user\', { userId }]) // Wait for ready to be truthy\nconst { data: projects } = useQuery(\n  () => [\'projects\', { userId: user.id }] // Wait for user.id to become available (and not throw)\n```\n\n### Caching & Invalidation\n\nReact Query caching is automatic out of the box. It uses a `stale-while-revalidate` in-memory caching strategy together with robust query deduping to to always ensure a query\'s data is only cached when it\'s needed and only cached once even if that query is used multiple times across your application.\n\nAt a glance:\n\n- The cache is keyed on unique `query + variables` combinations.\n- By default query results become **stale** immediately after a successful fetch. This can be configured using the `staleTime` option at both the global and query-level)\n- Stale queries are automatically refetched whenever their **query keys change (this includes variables used in query key tuples)** or when **new usages/instances** of a query are mounted.\n- By default query results are **always** cached **when in use**.\n- If and when a query is no longer being used, it becomes **inactive** and by default is cached in the background for **5 minutes**. This time can be configured using the `cacheTime` option at both the global and query-level\n- After a query is inactive for the `cacheTime` specified (defaults to 5 minutes), the query is deleted and garbage collected.\n\n<details>\n <summary>A more detailed example of the caching lifecycle</summary>\n\nLet\'s assume we are using the default `cacheTime` of **5 minutes** and the default `staleTime` of `0`.\n\n- A new instance of `useQuery(\'todos\', fetchTodos)` mounts\n  - Since no other queries have been made with this query + variable combination, this query will show a hard loading state and make a network request to fetch the data.\n  - It will then cache the data using `\'todos\'` and `` as the unique identifiers for that cache.\n  - A stale invalidation is scheduled using the `staleTime` option as a delay (defaults to `0`, or immediately).\n- A second instance of `useQuery(\'todos\', fetchTodos)` mounts elsewhere\n  - Because this exact data exist in the cache from the first instance of this query, that data is immediately returned from the cache\n  - Since the query is stale, it is refetched in the background automatically\n- Both instances of the `useQuery(\'todos\', fetchTodos)` query are unmount and no longer in use.\n  - Since there are no more active instances to this query, a cache timeout is set using `cacheTime` to delete and garbage collect the query (defaults to **5 minutes**).\n- No more instances of `useQuery(\'todos\', fetchTodos)` appear within **5 minutes**\n  - This query and its data is deleted and garbage collected.\n\n</details>\n\n### Load-More & Infinite-Scroll Pagination\n\nRendering paginated lists that can "load more" data or "infinite scroll" is a common UI pattern. React Query supports some useful features for querying these types of lists. Let\'s assume we have an API that returns pages of `todos` 3 at a time based on a `cursor` index:\n\n```js\nfetch(\'/api/projects?cursor=0\'\n// { data: [...], nextId: 3}\nfetch(\'/api/projects?cursor=3\'\n// { data: [...], nextId: 6}\nfetch(\'/api/projects?cursor=6\'\n// { data: [...], nextId: 9}\n```\n\nUsing the `nextId` value in each page\'s response, we can configure `useQuery` to fetch more pages as needed:\n\n- Configure your query function to use optional pagination variables. We\'ll send through the `nextId` as the `cursor` for the next page request\n- Set the `paginated` option to `true`\n- Define a `getCanFetchMore` option to know if there is more data to load (it receives the `lastPage` and `allPages` as parameters)\n\n```js\nimport { useQuery } from \'react-query\'\n\nfunction Todos() {\n  const {\n    data: pages,\n    isLoading,\n    isFetching,\n    isFetchingMore,\n    fetchMore,\n    canFetchMore,\n  } = useQuery(\n    \'todos\',\n    ({ nextId } = {}) => fetch(\'/api/projects?cursor=\' + (nextId || 0)),\n    {\n      paginated: true,\n      getCanFetchMore: (lastPage, allPages) => lastPage.nextId,\n    }\n  )\n\n  // ...\n}\n```\n\nYou\'ll notice a few new things now:\n\n- `data` is now an array of pages that contain query results, instead of the query results themselves\n- A `fetchMore` function is now available\n- A `canFetchMore` boolean is now available\n- An `isFetchingMore` boolean is now available\n\nThese can now be used to render a "load more" list (this example uses an `offset` key):\n\n```js\nimport { useQuery } from \'react-query\'\n\nfunction Todos() {\n  const {\n    data: pages,\n    isLoading,\n    isFetching,\n    isFetchingMore,\n    fetchMore,\n    canFetchMore,\n  } = useQuery(\n    \'projects\',\n    ({ offset } = {}) => fetch(\'/api/projects?offset=\' + (offset || 0)),\n    {\n      paginated: true,\n      getCanFetchMore: (lastPage, allPages) => lastPage.nextId,\n    }\n  )\n\n  const loadMore = async () => {\n    try {\n      // Get the last page\n      const lastPage = pages[pages.length - 1]\n      // Get the last item\'s ID\n      const lastItemId = lastPage[lastPage.length - 1].id\n      // Fetch more with the offset ID + 1\n      await fetchMore({\n        offset: lastItemId + 1,\n      })\n    } catch {}\n  }\n\n  return isLoading ? (\n    <p>Loading...</p>\n  ) : data ? (\n    <>\n      {data.map((page, i) => (\n        <React.Fragment key={i}>\n          {page.data.map(project => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </React.Fragment>\n      ))}\n      <div>\n        {canFetchMore ? (\n          <button onClick={loadMore} disabled={isFetchingMore}>\n            {isFetchingMore ? \'Loading more...\' : \'Load More\'}\n          </button>\n        ) : (\n          \'Nothing more to fetch.\'\n        )}\n      </div>\n      <div>\n        {isFetching && !isFetchingMore ? \'Background Updating...\' : null}\n      </div>\n    </>\n  ) : null\n}\n```\n\n#### What happens when a paginated query needs to be refetched?\\*\\*\n\nWhen a paginated query becomes `stale` and needs to be refetched, each page is fetched `individually` with the same variables that were used to request it originally. If a paginated query\'s results are ever removed from the cache, the pagination restarts at the initial state with a single page being requested.\n\n### Scroll Restoration\n\nOut of the box, "scroll restoration" Just Works\xe2\x84\xa2\xef\xb8\x8f in React Query. The reason for this is that query results are cached and retrieved synchronously when rendered. As long as a query is cached and has not been garbage collected, you should never experience problems with scroll restoration.\n\n### Manual Querying\n\nIf you ever want to disable a query from automatically running, you can use the `manual = true` option. When `manual` is set to true:\n\n- The query will not automatically refetch due to changes to their query function or variables.\n- The query will not automatically refetch due to `refetchQueries` options in other queries or via `refetchQuery` calls.\n\n```js\nfunction Todos() {\n  const { data, isLoading, error, refetch, isFetching } = useQuery(\n    \'todos\',\n    fetchTodoList,\n    {\n      manual: true,\n    }\n  )\n\n  return (\n    <>\n      <button onClick={() => refetch()}>Fetch Todos</button>\n\n      {isLoading ? (\n        <span>Loading...</span>\n      ) : error ? (\n        <span>Error: {error.message}</span>\n      ) : data ? (\n        <>\n          <ul>\n            {data.map(todo => (\n              <li key={todo.id}>{todo.title}</li>\n            ))}\n          </ul>\n        </>\n      ) : null}\n    </>\n  )\n}\n```\n\n> Pro Tip: Don\'t use `manual` for dependent queries. Use [Dependent Queries](#dependent-queries) instead!\n\n### Retries\n\nWhen a `useQuery` query fails (the function throws an error), React Query will automatically retry the query if that query\'s request has not reached the max number of consecutive retries (defaults to `3`).\n\nYou can configure retries both on a global level and an individual query level.\n\n- Setting `retry = false` will disable retries\n- Setting `retry = 6` will retry failing requests 6 times before showing the final error thrown by the function\n- Setting `retry = true` will infinitely retry failing requests.\n\n```js\nimport { useQuery } from \'react-query\'\n\n// Make specific query retry a certain number of times\nconst { data, isLoading, error } = useQuery(\n  [\'todos\', { page: 1 }],\n  fetchTodoList,\n  {\n    retry: 10, // Will retry failed requests 10 times before displaying an error\n  }\n)\n```\n\n### Retry Delay\n\nBy default, retries in React Query do not happen immediately after a request fails. As is standard, a back-off delay is gradually applied to each retry attempt.\n\nThe default `retryDelay` is set to double (starting at `1000`ms) with each attempt, but not exceed 30 seconds:\n\n```js\n// Configure for all queries\nimport { ReactQueryConfigProvider } from \'react-query\'\n\nconst queryConfig = {\n  retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n}\n\nfunction App() {\n  return (\n    <ReactQueryConfigProvider config={queryConfig}>\n      ...\n    </ReactQueryConfigProvider>\n  )\n}\n```\n\nThough it is not recommended, you can obviously override the `retryDelay` function/integer in both the Provider and individual query options. If set to an integer instead of a function the delay will always be the same amount of time:\n\n```js\nconst { data, isLoading, error } = useQuery(\'todos\', fetchTodoList, {\n  retryDelay: 10000, // Will always wait 1000ms to retry, regardless of how many retries\n})\n```\n\n### Prefetching\n\nIf you\'re lucky enough, you may know enough about what your users will do to be able to prefetch the data they need before it\'s needed! If this is the case, then you\'re in luck. You can use the `prefetchQuery` function to prefetch the results of a query to be placed into the cache:\n\n```js\nimport { prefetchQuery } from \'react-query\'\n\nconst prefetchTodos = async () => {\n  const queryData = await prefetchQuery(\'todos\', () => fetch(\'/todos\'))\n  // The results of this query will be cached like a normal query\n}\n```\n\nThe next time a `useQuery` instance is used for a prefetched query, it will use the cached data! If no instances of `useQuery` appear for a prefetched query, it will be deleted and garbage collected after the time specified in `cacheTime`.\n\n### Suspense Mode\n\nReact Query can also be used with React\'s new Suspense for Data Fetching API\'s. To enable this mode, you can set either the global or query level config\'s `suspense` option to `true`.\n\nGlobal configuration:\n\n```js\n// Configure for all queries\nimport { ReactQueryConfigProvider } from \'react-query\'\n\nconst queryConfig = {\n  suspense: true,\n}\n\nfunction App() {\n  return (\n    <ReactQueryConfigProvider config={queryConfig}>\n      ...\n    </ReactQueryConfigProvider>\n  )\n}\n```\n\nQuery configuration:\n\n```js\nconst { useQuery } from \'react-query\'\n\n// Enable for an individual query\nuseQuery(queryKey, queryFn, { suspense: true })\n```\n\nWhen using suspense mode, `isLoading` and `error` states will be replaced by usage of the `React.Suspense` component (including the use of the `fallback` prop and React error boundaries for catching errors. Please see the [Suspense Example](https://codesandbox.io/s/github/tannerlinsley/react-query/tree/master/examples/sandbox) for more information on how to set up suspense mode.\n\n### Fetch-on-render vs Fetch-as-you-render\n\nOut of the box, React Query in `suspense` mode works really well as a **Fetch-on-render** solution with no additional configuration. However, if you want to take it to the next level and implement a `Fetch-as-you-render` model, we recommend implementing [Prefetching](#prefetching) on routing and/or user interactions events to initialize queries before they are needed.\n\n### Cancelling Query Requests\n\nBy default, queries that become inactive before their promises are resolved are simply ignored instead of cancelled. Why is this?\n\n- For most applications, ignoring out-of-date queries is sufficient\n- Cancellation APIs may not be available for every query function\n- If cancellation APIs are available, they typically vary in implementation between utilities/libraries (eg. Fetch vs Axios vs XMLHttpRequest).\n\nBut don\'t worry! If your queries are high-bandwidth or potentially very expensive to download, React Query exposes a generic way to **cancel** query requests using a cancellation token or other related API. To integrate with this feature, attach a `cancel` function to the promise returned by your query that implements your request cancellation. When a query becomes out-of-date or inactive, this `promise.cancel` function will called (if available):\n\nUsing `axios`:\n\n```js\nimport { CancelToken } from \'axios\'\n\nconst query = useQuery(\'todos\', () => {\n  // Create a new CancelToken source for this request\n  const source = CancelToken.source()\n\n  const promise = axios.get(\'/todos\', {\n    // Pass the source token to your request\n    cancelToken: source.token,\n  })\n\n  // Cancel the request if React Query calls the `promise.cancel` method\n  promise.cancel = () => {\n    source.cancel(\'Query was cancelled by React Query\')\n  }\n\n  return promise\n})\n```\n\nUsing `fetch`:\n\n```js\nconst query = useQuery(\'todos\', () => {\n  // Create a new AbortController instance for this request\n  const controller = new AbortController()\n  // Get the abortController\'s signal\n  const signal = controller.signal\n\n  const promise = fetch(\'/todos\', {\n    method: \'get\',\n    // Pass the signal to your request\n    signal,\n  })\n\n  // Cancel the request if React Query calls the `promise.cancel` method\n  promise.cancel = controller.abort\n\n  return promise\n})\n```\n\n## Mutations\n\nUnlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, React Query exports a `useMutation` hook.\n\n### Basic Mutations\n\nAssuming the server implements a ping mutation, that returns "pong" string, here\'s an example of the most basic mutation:\n\n```js\nconst PingPong = () => {\n  const [mutate, { data, isLoading, error }] = useMutation(pingMutation)\n\n  const onPing = async () => {\n    try {\n      const data = await mutate()\n      console.log(data)\n      // { ping: \'pong\' }\n    } catch {\n      // Uh oh, something went wrong\n    }\n  }\n  return <button onClick={onPing}>Ping</button>\n}\n```\n\nMutations without variables are not that useful, so let\'s add some variables to closer match reality.\n\n### Mutation Variables\n\nTo pass `variables` to your `mutate` function, call `mutate` with an object.\n\n```js\nconst CreateTodo = () => {\n  const [title, setTitle] = useState(\'\')\n  const [mutate] = useMutation(createTodo)\n\n  const onCreateTodo = async e => {\n    // Prevent the form from refreshing the page\n    e.preventDefault()\n\n    try {\n      await mutate({ title })\n      // Todo was successfully created\n    } catch (error) {\n      // Uh oh, something went wrong\n    }\n  }\n\n  return (\n    <form onSubmit={onCreateTodo}>\n      <input\n        type="text"\n        value={title}\n        onChange={e => setTitle(e.target.value)}\n      />\n      <br />\n      <button type="submit">Create Todo</button>\n    </form>\n  )\n}\n```\n\nEven with just variables, mutations aren\'t all that special, but when used with the `refetchQueries` and `updateQuery` options, they become a very powerful tool.\n\n### Invalidate and Refetch Queries from Mutations\n\nWhen a mutation succeeds, it\'s likely that other queries in your application need to update. Where other libraries that use normalized caches would attempt to update locale queries with the new data imperatively, React Query avoids the pitfalls that come with normalized caches and prescribes **atomic updates** instead of partial cache manipulation.\n\nFor example, assume we have a mutation to post a new todo:\n\n```js\nconst [mutate] = useMutation(postTodo)\n```\n\nWhen a successful `postTodo` mutation happens, we likely want all `todos` queries to get refetched to show the new todo item. To do this, you can use the `refetchQueries` option when calling a mutation\'s `mutate` function.\n\n```js\n// When this mutation succeeds, any queries with the `todos` or `reminders` query key will be refetched\nmutate(newTodo, { refetchQueries: [\'todos\', \'reminders\'], })\n\n// The 3 queries below will be refetched when the mutation above succeeds\nconst todoListQuery = useQuery(\'todos\', fetchTodoList)\nconst todoListQuery = useQuery([\'todos\', { page: 1 }, fetchTodoList)\nconst remindersQuery = useQuery(\'reminders\', fetchReminders)\n```\n\nYou can even refetch queries with specific variables by passing a query key tuple to `refetchQueries`:\n\n```js\nmutate(newTodo, { refetchQueries: [[\'todos\', { status: \'done\' }]] })\n\n// The query below will be refetched when the mutation above succeeds\nconst todoListQuery = useQuery([\'todos\', { status: \'done\' }], fetchTodoList)\n// However, the following query below will NOT be refetched\nconst todoListQuery = useQuery(\'todos\', fetchTodoList)\n```\n\nIf you want to **only** refetch `todos` queries that don\'t have variables, you can pass a tuple with `variables` set to `false`:\n\n```js\nmutate(newTodo, { refetchQueries: [[\'todos\', false]] })\n\n// The query below will be refetched when the mutation above succeeds\nconst todoListQuery = useQuery([\'todos\'], fetchTodoList)\n// However, the following query below will NOT be refetched\nconst todoListQuery = useQuery([\'todos\', { status: \'done\' }], fetchTodoList)\n```\n\nIf you prefer that the promise returned from `mutate()` only resolves **after** any `refetchQueries` have been refetched, you can pass the `waitForRefetchQueries = true` option to `mutate`:\n\n```js\nconst [mutate] = useMutation(addTodo, { refetchQueries: [\'todos\'] })\n\nconst run = async () => {\n  try {\n    await mutate(todo, { waitForRefetchQueries: true })\n    console.log(\'I will only log after all refetchQueries are done refetching!\')\n  } catch {}\n}\n```\n\nIt\'s important to note that `refetchQueries` by default will only happen after a successful mutation (the mutation function doesn\'t throw an error). If you would like to refetch the `refetchQueries` regardless of this, you can set `refetchQueriesOnFailure` to `true` in your `mutate` options:\n\n```js\nconst [mutate] = useMutation(addTodo, { refetchQueries: [\'todos\'] })\n\nconst run = async () => {\n  try {\n    await mutate(todo, { refetchQueriesOnFailure: true })\n    // Even if the above mutation fails, any `todos` queries will still be refetched.\n  } catch {}\n}\n```\n\n### Query Updates from Mutations\n\nWhen dealing with mutations that **update** objects on the server, it\'s common for the new object to be automatically returned in the response of the mutation. Instead of invalidating any queries for that item and wasting a network call to refetch them again, we can take advantage of the object returned by the mutation function and update any query responses with that data that match that query using the `updateQuery` option:\n\n```js\nconst [mutate] = useMutation(editTodo)\n\nmutate(\n  {\n    id: 5,\n    name: \'Do the laundry\',\n  },\n  {\n    updateQuery: [\'todo\', { id: 5 }],\n  }\n)\n\n// The query below will be updated with the response from the mutation above when it succeeds\nconst { data, isLoading, error } = useQuery([\'todo\', { id: 5 }], fetchTodoByID)\n```\n\n## Manually or Optimistically Setting Query Data\n\nIn rare circumstances, you may want to manually update a query\'s response before it has been refetched. To do this, you can use the exported `setQueryData` function:\n\n```js\nimport { setQueryData } from \'react-query\'\n\n// Full replacement\nsetQueryData([\'todo\', { id: 5 }], newTodo)\n\n// or functional update\nsetQueryData([\'todo\', { id: 5 }], previous => ({ ...previous, status: \'done\' }))\n```\n\n**Most importantly**, when manually setting a query response, it naturally becomes out-of-sync with it\'s original source. To ease this issue, `setQueryData` automatically triggers a background refresh of the query after it\'s called to ensure it eventually synchronizes with the original source.\n\nShould you choose that you do _not_ want to refetch the query automatically, you can set the `shouldRefetch` option to `false`:\n\n```js\nimport { setQueryData } from \'react-query\'\n\n// Mutate, but do not automatically refetch the query in the background\nsetQueryData([\'todo\', { id: 5 }], newTodo, {\n  shouldRefetch: false,\n})\n```\n\n## Displaying Background Fetching Loading States\n\nA query\'s `isLoading` boolean is usually sufficient to show the initial hard-loading state for a query, but sometimes you may want to display a more subtle indicator that a query is refetching in the background. To do this, queries also supply you with an `isFetching` boolean that you can use to show that it\'s in a fetching state:\n\n```js\nfunction Todos() {\n  const { data: todos, isLoading, isFetching } = useQuery(\'todos\', fetchTodos)\n\n  return isLoading ? (\n    <span>Loading...</span>\n  ) : todos ? (\n    <>\n      {isFetching ? <div>Refreshing...</div> : null}\n\n      <div>\n        {todos.map(todo => (\n          <Todo todo={todo} />\n        ))}\n      </div>\n    </>\n  ) : null\n}\n```\n\n## Displaying Global Background Fetching Loading State\n\nIn addition to individual query loading states, if you would like to show a global loading indicator when **any** queries are fetching (including in the background), you can use the `useIsFetching` hook:\n\n```js\nimport { useIsFetching } from \'react-query\'\n\nfunction GlobalLoadingIndicator() {\n  const isFetching = useIsFetching()\n\n  return isFetching ? (\n    <div>Queries are fetching in the background...</div>\n  ) : null\n}\n```\n\n## Window-Focus Refetching\n\nIf a user leaves your application and returns to stale data, you may want to trigger an update in the background to update any stale queries. Thankfully, **React Query does this automatically for you**, but if you choose to disable it, you can use the `ReactQueryConfigProvider`\'s `refetchAllOnWindowFocus` option to disable it:\n\n```js\nconst queryConfig = { refetchAllOnWindowFocus: false }\n\nfunction App() {\n  return (\n    <ReactQueryConfigProvider config={queryConfig}>\n      ...\n    </ReactQueryConfigProvider>\n  )\n}\n```\n\n## Custom Query Key Serializers (Experimental)\n\n> **WARNING:** This is an advanced and experimental feature. There be dragons here. Do not change the Query Key Serializer unless you know what you are doing and are fine with encountering edge cases in the React Query API\n\nIf you absolutely despise the default query key and variable syntax, you can replace the default query key serializer with your own by using the `ReactQueryConfigProvider` hook\'s `queryKeySerializerFn` option:\n\n```js\nconst queryConfig = {\n  queryKeySerializerFn: userQueryKey => {\n    // Your custom logic here...\n\n    return [fullQueryHash, queryGroupId, variablesHash, variables]\n  },\n}\n\nfunction App() {\n  return (\n    <ReactQueryConfigProvider config={queryConfig}>\n      ...\n    </ReactQueryConfigProvider>\n  )\n}\n```\n\n- `userQueryKey: any`\n  - This is the queryKey passed in `useQuery` and all other public methods and utilities exported by React Query.\n- `fullQueryHash: string`\n  - This must be a unique `string` representing the query and variables.\n  - It must be stable and deterministic and should not change if things like the order of variables is changed or shuffled.\n- `queryGroupId: string`\n  - This must be a unique `string` representing only the query type without any variables\n  - It must be stable and deterministic and should not change if the variables of the query change\n- `variablesHash: string`\n  - This must be a unique `string` representing only the variables of the query\n  - It must be stable and deterministic and should not change if things like the order of variables is changed or shuffled.\n- `variables: any`\n  - This is the object that will be passed to the `queryFn` when using `useQuery`.\n\n> An additional `stableStringify` utility is also exported to help with stringifying objects to have sorted keys.\n\n#### URL Query Key Serializer Example\n\nThe example below shows how to build your own serializer for use with urls and use it with React Query:\n\n```js\nimport { ReactQueryConfigProvider, stableStringify } from \'react-query\'\n\nfunction urlQueryKeySerializer(queryKey) {\n  // Deconstruct the url\n  let [url, params = \'\'] = queryKey.split(\'?\')\n\n  // Build the variables object\n  let variables = {}\n  params\n    .split(\'&\')\n    .filter(Boolean)\n    .forEach(param => {\n      const [key, value] = param.split(\'=\')\n      variables[key] = value\n    })\n\n  // Use stableStringify to turn variables into a stable string\n  const variablesHash = Object.keys(variables).length\n    ? stableStringify(variables)\n    : \'\'\n\n  // Remove trailing slashes from the url to make an ID\n  const queryGroupId = url.replace(/\\/{1,}$/, \'\')\n\n  const queryHash = `${id}_${variablesHash}`\n\n  return [queryHash, queryGroupId, variablesHash, variables]\n}\n\nconst queryConfig = {\n  queryKeySerializerFn: urlQueryKeySerializer,\n}\n\nfunction App() {\n  return (\n    <ReactQueryConfigProvider config={queryConfig}>\n      ...\n    </ReactQueryConfigProvider>\n  )\n}\n\n// Heck, you can even make your own custom useQueryHook!\n\nfunction useUrlQuery(url, options) {\n  return useQuery(url, () => axios.get(url).then(res => res.data))\n}\n\n// Use it in your app!\n\nfunction Todos() {\n  const todosQuery = useUrlQuery(`/todos`)\n}\n\nfunction FilteredTodos({ status = \'pending\' }) {\n  const todosQuery = useFunctionQuery([getTodos, { status }])\n}\n\nfunction Todo({ id }) {\n  const todoQuery = useUrlQuery(`/todos/${id}`)\n}\n\nrefetchQuery(\'/todos\')\nrefetchQuery(\'/todos?status=pending\')\nrefetchQuery(\'/todos/5\')\n```\n\n#### Function Query Key Serializer Example\n\nThe example below shows how to you build your own functional serializer and use it with React Query:\n\n```js\nimport { ReactQueryConfigProvider, stableStringify } from \'react-query\'\n\n// A map to keep track of our function pointers\nconst functionSerializerMap = new Map()\n\nfunction functionQueryKeySerializer(queryKey) {\n  if (!queryKey) {\n    return []\n  }\n\n  let queryFn = queryKey\n  let variables\n\n  if (Array.isArray(queryKey)) {\n    queryFn = queryKey[0]\n    variables = queryKey[1]\n  }\n\n  // Get or create an ID for the function pointer\n  const queryGroupId =\n    functionSerializerMap.get(queryFn) ||\n    (() => {\n      const id = Date.now()\n      functionSerializerMap.set(queryFn, id)\n      return id\n    })()\n\n  const variablesIsObject = isObject(variables)\n\n  const variablesHash = variablesIsObject ? stableStringify(variables) : \'\'\n\n  const queryHash = `${queryGroupId}_${variablesHash}`\n\n  return [queryHash, queryGroupId, variablesHash, variables]\n}\n\nconst queryConfig = {\n  queryKeySerializerFn: functionQueryKeySerializer,\n}\n\nfunction App() {\n  return (\n    <ReactQueryConfigProvider config={queryConfig}>\n      ...\n    </ReactQueryConfigProvider>\n  )\n}\n// Heck, you can even make your own custom useQueryHook!\n\nfunction useFunctionQuery(functionTuple, options) {\n  const [queryFn, variables] = Array.isArray(functionTuple)\n    ? functionTuple\n    : [functionTuple]\n  return useQuery(functionTuple, queryFn, options)\n}\n\n// Use it in your app!\n\nfunction Todos() {\n  const todosQuery = useFunctionQuery(getTodos)\n}\n\nfunction FilteredTodos({ status = \'pending\' }) {\n  const todosQuery = useFunctionQuery([getTodos, { status }])\n}\n\nfunction Todo({ id }) {\n  const todoQuery = useFunctionQuery([getTodo, { id }])\n}\n\nrefetchQuery(getTodos)\nrefetchQuery([getTodos, { status: \'pending\' }])\nrefetchQuery([getTodo, { id: 5 }])\n```\n\n# API\n\n## `useQuery`\n\n```js\nconst {\n  data,\n  error,\n  isFetching,\n  isCached,\n  failureCount,\n  isLoading,\n  refetch,\n  // with paginated mode enabled\n  isFetchingMore,\n  canFetchMore,\n  fetchMore,\n} = useQuery(queryKey, queryFn, {\n  manual,\n  paginated,\n  getCanFetchMore,\n  staleTime,\n  retry,\n  retryDelay,\n  onSuccess,\n  onError,\n  suspense,\n})\n```\n\n### Options\n\n- `queryKey: String | [String, Variables: Object] | falsey | Function => queryKey`\n  - **Required**\n  - The query key to use for this query.\n  - If a string is passed, it will be used as the query key\n  - If a `[String, Object]` tuple is passed, they will be serialized into a stable query key. See [Query Keys](#query-keys) for more information.\n  - If a falsey value is passed, the query will be disabled and not run automatically.\n  - If a function is passed, it should resolve to any other valid query key type. If the function throws, the query will be disabled and not run automatically.\n  - The query will automatically update when this key changes (if the key is not falsey and if `manual` is not set to `true`)\n  - `Variables: Object`\n    - If a tuple with variables is passed, this object should be **serializable**.\n    - Nested arrays and objects are supported\n    - The order of object keys is sorted to be stable before being serialized into the query key\n- `queryFn: Function(variables) => Promise(data/error)`\n  - **Required**\n  - The function that the query will use to request data\n  - Optionally receives the `variables` object passed from either the query key tuple (`useQuery([\'todos\', variables], queryFn)`) or the `refetch` method\'s `variables` option, eg. `refetch({ variables })`\n  - Must return a promise that will either resolves data or throws an error.\n- `paginated: Boolean`\n  - Set this to `true` to enable `paginated` mode\n  - In this mode, new pagination utilities are returned from `useQuery` and `data` becomes an array of page results\n- `manual: Boolean`\n  - Set this to `true` to disable automatic refetching when the query mounts or changes query keys.\n  - To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n- `getCanFetchMore: Function(lastPage, allPages) => Boolean`\n  - **Required if using `paginated` mode**\n  - When using `paginated` mode, this function should return `true` if there is more data than can be fetched.\n- `retry: Boolean | Int`\n  - If `false`, failed queries will not retry by default\n  - If `true`, failed queries will retry infinitely\n  - If set to an `Int`, eg. `3`, failed queries will retry until the failed query count meets that number\n- `retryDelay: Function(retryAttempt: Int) => Int`\n  - This function receives a `retryAttempt` integer and returns the delay to apply before the next attempt in milliseconds\n  - A function like `attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)` applies exponential backoff\n  - A function like `attempt => attempt * 1000` applies linear backoff.\n- `staleTime: Int`\n  - The time in milliseconds that cache data remains fresh. After a successful cache update, that cache data will become stale after this duration\n- `cacheTime: Int`\n  - The time in milliseconds that unused/inactive cache data remains in memory. When a query\'s cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n- `refetchInterval: false | Integer`\n  - Optional\n  - If set to a number, all queries will continuously refetch at this frequency in milliseconds\n- `onError: Function(err) => void`\n  - Optional\n  - This function will fire if the query encounters an error (after all retries have happened) and will be passed the error.\n- `onSuccess: Function(data) => data`\n  - Optional\n  - This function will fire any time the query successfully fetches new data.\n- `suspense: Boolean`\n  - Optional\n  - Set this to `true` to enable suspense mode.\n  - When `true`, `useQuery` will suspend when `isLoading` would normally be `true`\n  - When `true`, `useQuery` will throw runtime errors when `error` would normally be truthy\n\n### Returns\n\n- `data: null | Any`\n  - Defaults to `null`\n  - The last successfully resolved data for the query.\n- `error: null | Error`\n  - The error object for the query, if an error was thrown.\n- `isLoading: Boolean`\n  - Will be `true` if the query is both fetching and does not have any cached data to display.\n- `isFetching: Boolean`\n  - Will be `true` if the query is currently fetching, including background fetching.\n- `isCached: Boolean`\n  - Will be `true` if the query\'s response is currently cached.\n- `failureCount: Integer`\n  - The failure count for the query.\n  - Incremented every time the query fails.\n  - Reset to `0` when the query succeeds.\n- `refetch: Function({ variables: Object, merge: Function, disableThrow: Boolean })`\n  - A function to manually refetch the query.\n  - Supports custom variables (useful for "fetch more" calls)\n  - Supports custom data merging (useful for "fetch more" calls)\n  - Set `disableThrow` to true to disable this function from throwing if an error is encountered.\n- `isFetchingMore: Boolean`\n  - If using `paginated` mode, this will be `true` when fetching more results using the `fetchMore` function.\n- `canFetchMore: Boolean`\n  - If using `paginated` mode, this will be `true` if there is more data to be fetched (known via the required `getCanFetchMore` option function)\n- `fetchMore: Function(variables) => Promise`\n  - If using `paginated` mode, this function allows you to fetch the next "page" of results.\n  - `variables` should be an object that is passed to your query function to retrieve the next page of results\n\n## `useMutation`\n\n```js\nconst [mutate, { data, isLoading, error }] = useMutation(mutationFn, {\n  refetchQueries,\n  refetchQueriesOnFailure,\n})\n\nconst promise = mutate(variables, { updateQuery, waitForRefetchQueries })\n```\n\n### Options\n\n- `mutationFn: Function(variables) => Promise`\n  - **Required**\n  - A function that performs an asynchronous task and returns a promise\n- `refetchQueries: Array<QueryKey>`\n  - Optional\n  - When the mutation succeeds, these queries will be automatically refetched\n  - Must be an array of query keys, eg. `[\'todos\', [\'todo\', { id: 5 }], \'reminders\']`\n- `refetchQueriesOnFailure: Boolean`\n  - Defaults to `false`\n  - Set this to `true` if you want `refetchQueries` to be refetched regardless of the mutation succeeding.\n- `variables: any`\n  - Optional\n  - The variables object to pass tot he `mutationFn`\n- `updateQuery: QueryKey`\n  - Optional\n  - The query key for the individual query to update with the response from this mutation.\n  - Suggested use is for `update` mutations that regularly return the updated data with the mutation. This saves you from making another unnecessary network call to refetch the data.\n- `waitForRefetchQueries: Boolean`\n  - Optional\n  - If set to `true`, the promise returned by `mutate()` will not resolve until refetched queries are resolved as well.\n\n### Returns\n\n- `mutate: Function(variables, { updateQuery })`\n  - The mutation function you can call with variables to trigger the mutation and optionally update a query with its response.\n- `data: null | Any`\n  - Defaults to `null`\n  - The last successfully resolved data for the query.\n- `error: null | Error`\n  - The error object for the query, if an error was thrown.\n- `isLoading: Boolean`\n  - Will be `true` if the query is both fetching and does not have any cached data\n- `promise: Promise`\n  - The promise that is returned by the `mutationFn`\n\n## `setQueryData`\n\n`setQueryData` is a function for imperatively updating the response of a query. By default, this function also triggers a background refetch to ensure that the data is eventually consistent with the remote source, but this can be disabled.\n\n```js\nimport { setQueryData } from \'react-query\'\n\nconst maybePromise = setQueryData(queryKey, data, { shouldRefetch })\n```\n\n### Options\n\n- `queryKey: QueryKey`\n  - **Required**\n  - The query key for the individual query to update with new data.\n- `data: any | Function(old) => any`\n  - **Required**\n  - Must either be the new data or a function that receives the old data and returns the new data\n- `shouldRefetch: Boolean`\n  - Optional\n  - Defaults to `true`\n  - Set this to `false` to disable the automatic background refetch from happening\n\n### Returns\n\n- `maybePromise: undefined | Promise`\n  - If `shouldRefetch` is `true`, a promise is returned that will either resolve when the query refetch is complete or will reject if the refetch fails (after its respective retry configurations is done).\n\n## `refetchQuery`\n\n`refetchQuery` is a function that can be used to trigger a refetch of\n\n- A group of active queries\n- A single, specific query\n\nBy default, `refetchQuery` will only refetch stale queries, but the `force` option can be used to include non-stale ones.\n\n```js\nimport { refetchQuery } from \'react-query\'\n\nconst promise = refetchQuery(queryKey, { force })\n```\n\n### Options\n\n- `queryKey: QueryKey`\n  - **Required**\n  - The query key for the query or query group to refetch.\n  - If a single `string` is passed, any queries using that `string` or any tuple key queries that include that `string` (eg. passing `todos` would refetch both `todos` and `[\'todos\', { status: \'done\' }]`).\n  - If a tuple key is passed, only the exact query with that key will be refetched (eg. `[\'todos\', { status: \'done\' }]` will only refetch queries with that exact key)\n  - If a tuple key is passed with the `variables` slot set to `false`, then only queries that match the `string` key and have no variables will be refetched (eg. `[\'todos\', false]` would only refetch `todos` and not `[\'todos\', { status: \'done\' }]`)\n- `force: Boolean`\n  - Optional\n  - Set this to true to force all queries to refetch instead of only stale ones.\n\n### Returns\n\n- `promise: Promise`\n  - A promise is returned that will either resolve when all refetch queries are complete or will reject if any refetch queries fail (after their respective retry configurations are done).\n\n## `refetchAllQueries`\n\n`refetchAllQueries` is a function for imperatively triggering a refetch of all queries. By default, it will only refetch stale queries, but the `force` option can be used to refetch all queries, including non-stale ones.\n\n```js\nimport { refetchAllQueries } from \'react-query\'\n\nconst promise = refetchAllQueries({ force, includeInactive })\n```\n\n### Options\n\n- `force: Boolean`\n  - Optional\n  - Set this to `true` to force all queries to refetch instead of only stale ones.\n- `includeInactive: Boolean`\n  - Optional\n  - Set this to `true` to also refetch inactive queries.\n  - Overrides the `force` option to be `true`, regardless of it\'s value.\n\n### Returns\n\n- `promise: Promise`\n  - A promise is returned that will either resolve when all refetch queries are complete or will reject if any refetch queries fail (after their respective retry configurations are done).\n\n## `useIsFetching`\n\n`useIsFetching` is an optional hook that returns true if any query in your application is loading for fetching in the background (useful for app-wide loading indicators)\n\n```js\nimport { useIsFetching } from \'react-query\'\n\nconst isFetching = useIsFetching()\n```\n\n### Returns\n\n- `isFetching: Boolean`\n  - Will be `true` if any query in your application is loading or fetching in the background\n\n## `prefetchQuery`\n\n`prefetchQuery` is a function that can be used to fetch and cache a query response for later before it is needed or rendered with `useQuery`. **Please note** that `prefetch` will not trigger a query fetch if the query is already cached. If you wish, you can force a prefetch for non-stale queries by using the `force` option:\n\n```js\nimport { prefetchQuery } from \'react-query\'\n\nconst data = await prefetchQuery(queryKey, queryFn, { force, ...config })\n```\n\n### Options\n\nThe options for `prefetchQuery` are exactly the same as those of [`useQuery`](#usequery), with the exception of a `force` option:\n\n- `force: Boolean`\n  - Optional\n  - Set this to true to prefetch a query **even if it is stale**\n\n### Returns\n\n- `promise: Promise`\n  - A promise is returned that will either resolve with the **query\'s response data**, or throw with an **error**.\n\n## `clearQueryCache`\n\n`clearQueryCache` does exactly what it sounds like, it clears all query caches. It does this by:\n\n- Immediately deleting any queries that no not have active subscriptions\n- Immediately setting `data` to `null` for all queries with active subscriptions\n\n```js\nimport { clearQueryCache } from \'react-query\'\n\nclearQueryCache()\n```\n\n## `ReactQueryConfigProvider`\n\n`ReactQueryConfigProvider` is an optional provider component and can be used to define defaults for all instances of `useQuery` within it\'s sub-tree:\n\n```js\nimport { ReactQueryConfigProvider } from \'react-query\'\n\nconst queryConfig = {\n  retry: 3,\n  retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n  staleTime: 0,\n  cacheTime: 5 * 60 * 1000,\n  refetchAllOnWindowFocus: true,\n  refetchInterval: false,\n  suspense: false,\n}\n\nfunction App() {\n  return (\n    <ReactQueryConfigProvider config={queryConfig}>\n      ...\n    </ReactQueryConfigProvider>\n  )\n}\n```\n\n### Options\n\n- `config: Object`\n  - Must be **stable** or **memoized**. Do not create an inline object!\n  - For a description of all config options, please see the [`useQuery` hook](#usequery).\n'