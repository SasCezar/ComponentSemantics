b'<div align="center">\n  <img width="540" alt="urql" src="https://raw.githubusercontent.com/FormidableLabs/urql/master/docs/urql-banner.gif" />\n\n  <br />\n  <br />\n\n  <strong>\n    A highly customisable and versatile GraphQL client for React\n  </strong>\n\n  <br />\n  <br />\n  <a href="https://npmjs.com/package/urql">\n    <img alt="NPM Version" src="https://img.shields.io/npm/v/urql.svg" />\n  </a>\n  <a href="https://travis-ci.org/FormidableLabs/urql">\n    <img alt="Test Status" src="https://api.travis-ci.org/FormidableLabs/urql.svg?branch=master" />\n  </a>\n  <a href="https://codecov.io/gh/FormidableLabs/urql">\n    <img alt="Test Coverage" src="https://codecov.io/gh/FormidableLabs/urql/branch/master/graph/badge.svg" />\n  </a>\n  <a href="https://bundlephobia.com/result?p=urql">\n    <img alt="Minified gzip size" src="https://img.shields.io/bundlephobia/minzip/urql.svg?label=gzip%20size" />\n  </a>\n  <a href="https://github.com/FormidableLabs/urql#maintenance-status">\n    <img alt="Maintenance Status" src="https://img.shields.io/badge/maintenance-active-green.svg" />\n  </a>\n  <a href="https://spectrum.chat/urql">\n    <img alt="Spectrum badge" src="https://withspectrum.github.io/badge/badge.svg" />\n  </a>\n\n  <br />\n  <br />\n</div>\n\n## \xe2\x9c\xa8 Features\n\n- \xf0\x9f\x93\xa6 **One package** to get a working GraphQL client in React\n- \xe2\x9a\x99\xef\xb8\x8f Fully **customisable** behaviour [via "exchanges"](#-add-on-exchanges)\n- \xf0\x9f\x97\x82 Logical but simple default behaviour and document caching\n- \xe2\x9a\x9b\xef\xb8\x8f Minimal React components and hooks\n- \xf0\x9f\x8c\xb1 Normalized caching via [`@urql/exchange-graphcache`](https://github.com/FormidableLabs/urql-exchange-graphcache)\n\n`urql` is a GraphQL client that exposes a set of React components and hooks. It\'s built to be highly customisable and versatile so you can take it from getting started with your first GraphQL project all the way to building complex apps and experimenting with GraphQL clients.\n\nWhile GraphQL is an elegant protocol and schema language, client libraries today typically come with large API footprints. We aim to create something more lightweight instead.\n\nSome of the available exchanges that extend `urql` are listed below in the ["Add on Exchanges" list](https://github.com/FormidableLabs/urql#-add-on-exchanges) including a normalized cache and a Chrome devtools extension.\n\n## \xf0\x9f\x93\x83 [Documentation](https://formidable.com/open-source/urql/docs)\n\n[The documentation contains everything you need to know about `urql`](https://formidable.com/open-source/urql/docs)\n\n- [Getting Started guide](https://formidable.com/open-source/urql/docs/getting-started/)\n- [Architecture](https://formidable.com/open-source/urql/docs/architecture/)\n- [Basics](https://formidable.com/open-source/urql/docs/basics/)\n- [Extending & Experimenting](https://formidable.com/open-source/urql/docs/extending-&-experimenting/)\n- [API](https://formidable.com/open-source/urql/docs/api/)\n- [Guides](./docs/guides.md)\n\n_You can find the raw markdown files inside this repository\'s `docs` folder._\n\n## \xf0\x9f\x8f\x8e\xef\xb8\x8f Intro & Showcase\n\n### Installation\n\n```sh\nyarn add urql graphql\n# or\nnpm install --save urql graphql\n```\n\n### Queries\n\nThere are three hooks, one for each possible GraphQL operation.\n\nThe [`useQuery` hook](https://formidable.com/open-source/urql/docs/api/#usequery-hook) is\nused to send GraphQL queries and will provide GraphQL results from your API.\n\nWhen you\'re using `useQuery` it\'ll accept a configuration object that may contain keys for `query` and `variables`.\nThe `query` can either be your GraphQL query as a string or as a `DocumentNode`, which may be\nparsed using [`graphql-tag`](https://github.com/apollographql/graphql-tag) for instance.\n\n```js\nimport { useQuery } from \'urql\';\n\nconst YourComponent = () => {\n  const [result] = useQuery({\n    query: `{ todos { id } }`,\n  });\n\n  if (result.error) return <Error message={result.error.message} />;\n  if (result.fetching) return <Loading />;\n\n  return <List data={result.data.todos} />;\n};\n```\n\nInternally, `urql` will create a unique `key` for any operation it starts which is a hash of `query` and\n`variables`. The internal "Exchange pipeline" is then responsible for fulfilling the operation.\n\n<img width="606" src="docs/urql-operation-keys.png" alt="Diagram: An Operation key is computed by hashing the combination of the stringified query and the stabily stringified variables. DocumentNodes may either be stringified fully or just by using their operation names. Properties of any variables object need to be stabily sorted." />\n\nThe result\'s error is a [`CombinedError`](https://formidable.com/open-source/urql/docs/api/#combinederror-class), which\nnormalises GraphQL errors and Network errors by combining them into one wrapping class.\n\n<img width="693" src="docs/urql-combined-error.png" alt="Diagram: A CombinedError has two states. It can either have a property \'networkError\', or it can have multiple, rehydrated GraphQL errors on the \'graphQLErrors\' property. The message of the CombinedError will always be a summary of the errors it contains." />\n\n[Learn more about `useQuery` in the Getting Started guide](https://formidable.com/open-source/urql/docs/getting-started/#writing-queries)\n\n### Mutations\n\nThe [`useMutation` hook](https://formidable.com/open-source/urql/docs/api/#usemutation-hook) is very similar to the `useQuery` hook,\nbut instead of sending queries it sends mutations whenever the `executeMutation` method is called with the variables for the mutation.\n\n```js\nimport { useMutation } from \'urql\';\n\nconst YourComponent = () => {\n  const [result, executeMutation] = useMutation(\n    `mutation AddTodo($text: String!) { addTodo(text: $text) { id } }`\n  );\n\n  const add = () =>\n    executeMutation({ text: \'New todo!\' }).then(result => {\n      /* ... */\n    });\n\n  return <button onClick={add}>Go!</button>;\n};\n```\n\nThe `useMutation` hook provides a result, just like `useQuery` does, but it doesn\'t execute the mutation automatically.\nInstead it starts once the `executeMutation` function is called with some variables. This also returns a promise that\nresolves to the result as well.\n\n[Learn more about `useMutation` in the Getting Started guide](https://formidable.com/open-source/urql/docs/getting-started/#writing-mutations)\n\n### Pausing and Request Policies\n\nThe `useQuery` hook and `useMutation` hook differ by when their operations execute by default.\nMutations will only execute once the `executeMutation` method is called with some variables.\nThe `useQuery` hook can actually be used similarly. The hook also provides an `executeQuery`\nfunction that can be called imperatively to change what query the hook is running.\n\nUnlike the `useMutation` hook, the `useQuery`\'s `executeQuery` function accepts an `OperationContext` as the argument, this allows you to for example override the `requestPolicy` or even the `fetchOptions`.\n\n```js\nconst [result, executeQuery] = useQuery({\n  query: \'query ($sort: Sorting!) { todos(sort: $sort) { text } }\',\n  variables: { sort: \'by-date\' },\n});\n\n// executeQuery can trigger queries and override options\nconst update = () => executeQuery({ requestPolicy: \'network-only\' });\n```\n\nInstead of running the `useQuery` operation eagerly you may also pass `pause: true`, which causes the\nhook not to run your query automatically until `pause` becomes `false` or until `executeQuery` is called\nmanually.\n\n```js\n// This won\'t execute automatically...\nconst [result, executeQuery] = useQuery({\n  query: \'{ todos { text } }\',\n  pause: true,\n});\n\n// ...but it can still be triggered programmatically\nconst execute = () => executeQuery();\n```\n\nApart from `pause` you may also pass a `requestPolicy` option that changes how the cache treats your data.\nBy default this option will be set to `"cache-first"` which will give you cached data when it\'s available,\nbut it can also be set to `"network-only"` which skips the cache entirely and refetches. Another option is\n`"cache-and-network"` which may give you cached data but then refetches in the background.\n\n```js\nconst [result, executeQuery] = useQuery({\n  query: \'{ todos { text } }\',\n  // Refetch up-to-date data in the background\n  requestPolicy: \'cache-and-network\',\n});\n\n// this will tell you whether something is fetching in the background\nresult.stale; // true\n```\n\nTherefore to [refetch data for your `useQuery` hook](https://formidable.com/open-source/urql/docs/getting-started/#refetching-data),\nyou can call `executeQuery` with the `network-only` request policy.\n\n```js\nconst [result, executeQuery] = useQuery({\n  query: \'{ todos { text } }\',\n});\n\n// We change the requestPolicy to bypass the cache just this once\nconst refetch = () => executeQuery({ requestPolicy: \'network-only\' });\n```\n\n[Learn more about request policies in our Getting Started section!](https://formidable.com/open-source/urql/docs/getting-started/#refetching-data)\n\n### Client and Exchanges\n\nIn `urql` all operations are controlled by a central [`Client`](https://formidable.com/open-source/urql/docs/api/#client-class).\nThis client is responsible for managing GraphQL operations and sending requests.\n\n<img width="787" src="docs/urql-client-architecture.png" alt="Diagram: The Client is an event hub on which operations may be dispatched by hooks. This creates an input stream (displayed as operations A, B, and C). Each Operation Result that then comes back from the client corresponds to one operation that has been sent to the client. This is the output stream of results (displayed as results A, B, and C)" />\n\nAny hook in `urql` dispatches its operation on the client (A, B, C) which will be handled by the client on a\nsingle stream of inputs. As responses come back from the cache or your GraphQL API one or more results are\ndispatched on an output stream that correspond to the operations, which update the hooks.\n\n<img width="709" src="docs/urql-event-hub.png" alt="Diagram: The \'useQuery\' hook dispatches an operation on the client when it mounts or updates. When it unmounts it dispatches a \'teardown\' operation that cancels the original operation. Results that come back from the client update the hook and are filtered by the operation\'s original key."/>\n\nHence the client can be seen as an event hub. Operations are sent to the client, which executes them and\nsends back a result. A special teardown-event is issued when a hook unmounts or updates to a different\noperation.\n\n<img width="700" src="docs/urql-signals.png" alt="Diagram: Operations can be seen as signals. Operations with an \'operationName\' of query, mutation, or subscription start a query of the given DocumentNode operation. The same operation with an \'operationName\' of \'teardown\' instructs the client to stop or cancel an ongoing operation of the same key. Operation Results carry the original operation on an \'operation\' property, which means they can be identified by reading the key of this operation."/>\n\n[Learn more about the shape of operations and results in our Architecture section!](https://formidable.com/open-source/urql/docs/architecture/)\n\n_Exchanges_ are separate middleware-like extensions that determine how operations flow through the client\nand how they\'re fulfilled. All functionality in `urql` can be customised by changing the client\'s exchanges\nor by writing a custom one.\n\n_Exchanges_ are named as such because middleware are often associated with a single stream of inputs,\nlike Express\' per-request handlers and middleware, which imperatively send results, or Redux\'s middleware,\nwhich only deal with actions.\n\nInstead _Exchanges_ are nested and deal with two streams, the input stream of operations and the output stream of results,\nwhere the stream of operations go through a pipeline like an intersection in an arbitrary order.\n\n<img width="634" src="docs/urql-exchanges.png" alt="Diagram: By default the client has three exchanges. Operations flow through a \'dedup\', \'cache\', and \'fetch\' exchange in this exact order. Their results are flowing backwards through this same chain of exchanges. The \'dedupExchange\' deduplicates ongoing operations by their key. The \'cacheExchange\' caches results and retrieves them by the operations\' keys. The \'fetchExchange\' sends operations to a GraphQL API and supports cancellation." />\n\nBy default there are three exchanges. The `dedupExchange` deduplicates operations with the same key, the\ncache exchange handles caching and has a "document" strategy by default, and the `fetchExchange` is typically\nthe last exchange and sends operations to a GraphQL API.\n\nThere are also other exchanges, both built into `urql` and as separate packages, that can be used to add\nmore functionality, like the `subscriptionExchange` for instance.\n\n[Learn more about Exchanges and how to write them in our Guides section!](https://formidable.com/open-source/urql/docs/guides/)\n\n### Document Caching\n\nThe default cache in `urql` works like a document or page cache, for example like a browser would cache pages.\nWith this default `cacheExchange` results are cached by the operation key that requested them. This means that\neach unique operation can have exactly one cached result.\n\nThese results are aggressively invalidated. Whenever you send a mutation, each result that contains `__typename`s\nthat also occur in the mutation result is invalidated.\n\n<img width="736" src="docs/urql-document-caching.png" alt="Diagram: First, a query is made that gets a type, in this example a \'Book\'. The result contains the \'__typename\' field that says \'Book\'. This is stored in a mapping of all types to the operations that contained this type. Later a mutation may change some data and will have overlapping types, in this example a \'Book\' is liked. The mutation also contains a \'Book\' so it retrieves the original operation that was getting a \'Book\' and reexecutes and invalidates it." />\n\n### Normalized Caching\n\nYou can opt into having a fully normalized cache by using the [`@urql/exchange-graphcache`](https://github.com/FormidableLabs/urql-exchange-graphcache)\npackage. The normalized cache is a cache that stores every separate entity in a big graph. Therefore multiple separate queries, subscriptions, and mutations\ncan update each other, if they contain overlapping data with the same type and ID.\n\n<img width="466" src="docs/urql-normalized-cache.png" alt="Diagram: A normalized cache contains a graph of different nodes. Queries point to different nodes, which point to other nodes, and so on and so forth. Nodes may be reused and are called \'entities\'. Each entity corresponds to an object that came back from the API." />\n\nGetting started with Graphcache is easy and is as simple as installing it and adding it to your client.\nAfterwards it comes with a lot of ways to configure it so that less requests need to be sent to your API.\nFor instance, you can set up mutations to update unrelated queries in your cache or have optimistic updates.\n\n```js\nimport { createClient, dedupExchange, fetchExchange } from \'urql\';\nimport { cacheExchange } from \'@urql/exchange-graphcache\';\n\nconst client = createClient({\n  url: \'http://localhost:1234/graphql\',\n  exchanges: [\n    dedupExchange,\n    // Replace the default cacheExchange with the new one\n    cacheExchange({\n      /* config */\n    }),\n    fetchExchange,\n  ],\n});\n```\n\n`urql`\'s normalized cache is a little different than ones that you may find in other GraphQL client libraries.\nIt focuses on doing the right thing and being intuitive whenever possible, hence it has a lot of warnings that\nmay be logged during development that tell you what may be going wrong at any given point in time.\n\nIt also supports "schema awareness". By adding introspected schema data it becomes able to deliver safe, partial\nGraphQL results entirely from cache and to match fragments to interfaces deterministically.\n\n[Read more about _Graphcache_ on its repository!](https://github.com/FormidableLabs/urql-exchange-graphcache)\n\n### Server-side Rendering\n\n`urql` supports server-side rendering via its **suspense mode** and its `ssrExchange`.\nWhen setting up SSR you will need to set `suspense: true` on the `Client` for the server-side\nand add an `ssrExchange`.\n\n```js\nimport {\n  Client,\n  dedupExchange,\n  cacheExchange,\n  fetchExchange,\n  ssrExchange,\n} from \'urql\';\n\n// Depending on your build process you may want to use one of these checks:\nconst isServer = typeof window !== \'object\' || process.browser;\n\nconst ssrCache = ssrExchange({ isClient: !isServer });\n\nconst client = new Client({\n  suspense: isServer\n  exchanges: [\n    dedupExchange,\n    cacheExchange,\n    // Add this after the cacheExchange but before fetchExchange:\n    ssrCache,\n    fetchExchange\n  ]\n});\n```\n\nThe `ssrExchange` is another small cache that stores full results temporarily.\nOn the server you may call `ssrCache.extractData()` to get the serialisable data\nfor the server\'s SSR data, while on the client you can call `ssrCache.restoreData(...)`\nto restore the server\'s SSR data.\n\n[Read more about SSR in our Basics\' SSR section!](https://formidable.com/open-source/urql/docs/basics/#server-side-rendering)\n\n### Client-side Suspense\n\nYou may also activate the Client\'s suspense mode on the client-side and use React Suspense for\ndata loading in your entire app! This requires you to use the [`@urql/exchange-suspense`](https://github.com/FormidableLabs/urql-exchange-suspense)\npackage.\n\n```js\nimport { Client, dedupExchange, cacheExchange, fetchExchange } from \'urql\';\n\nimport { suspenseExchange } from \'@urql/exchange-suspense\';\n\nconst client = new Client({\n  url: \'http://localhost:1234/graphql\',\n  suspense: true, // Enable suspense mode\n  exchanges: [\n    dedupExchange,\n    suspenseExchange, // Add suspenseExchange to your urql exchanges\n    cacheExchange,\n    fetchExchange,\n  ],\n});\n```\n\n## \xf0\x9f\x93\xa6 Ecosystem\n\n`urql` has an extended ecosystem of additional packages that either are ["Exchanges" which extend\n`urql`\'s core functionality](https://formidable.com/open-source/urql/docs/architecture/#exchanges)\nor are built to make certain tasks easier.\n\n- [`@urql/devtools`](https://github.com/FormidableLabs/urql-devtools): A Chrome extension for monitoring and debugging\n- [`@urql/exchange-graphcache`](https://github.com/FormidableLabs/urql-exchange-graphcache): A full normalized cache implementation\n- [`@urql/exchange-suspense`](https://github.com/FormidableLabs/urql-exchange-suspense): An experimental exchange for using `<React.Suspense>`\n- [`next-urql`](https://github.com/FormidableLabs/next-urql): Helpers for adding `urql` to [Next.js](https://github.com/zeit/next.js/) with SSR support\n- [`reason-urql`](https://github.com/FormidableLabs/reason-urql): Reason bindings for `urql`\n- [`urql-persisted-queries`](https://github.com/Daniel15/urql-persisted-queries): An exchange for adding persisted query support\n\n[You can find the full list of exchanges in the docs.](./docs/exchanges.md)\n\n## \xf0\x9f\x92\xa1 Examples\n\nThere are currently three examples included in this repository:\n\n- [Getting Started: A basic app with queries and mutations](examples/1-getting-started/)\n- [Using Subscriptions: An app that demos subscriptions](examples/2-using-subscriptions/)\n- [SSR with Next: A Next.js app showing server-side-rendering support](examples/3-ssr-with-nextjs/)\n\n## Maintenance Status\n\n**Active:** Formidable is actively working on this project, and we expect to continue for work for the foreseeable future. Bug reports, feature requests and pull requests are welcome.\n\n<img width="100%" src="docs/urql-spoiler.png" />\n'