b'# TOC\n\n* [Introduction](#introduction)\n* [Linux network queues overview](#linux-network-queues-overview)\n* [Fitting the sysctl variables into the Linux network flow](#fitting-the-sysctl-variables-into-the-linux-network-flow)\n  * Ingress - they\'re coming\n  * Egress - they\'re leaving\n* [What, Why and How - network and sysctl parameters](#what-why-and-how---network-and-sysctl-parameters)\n  * Ring Buffer - rx,tx\n  * Interrupt Coalescence (IC) - rx-usecs, tx-usecs, rx-frames, tx-frames (hardware IRQ)\n  * Interrupt Coalescing (soft IRQ) and Ingress QDisc\n  * Egress QDisc - txqueuelen and default_qdisc\n  * TCP Read and Write Buffers/Queues\n  * Honorable mentions - TCP FSM and congestion algorithm\n* [Network tools](#network-tools-for-testing-and-monitoring)\n* [References](#references)\n\n# Introduction\n\nSometimes people are looking for [sysctl](https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt) cargo cult values that bring high throughput and low latency with no trade-off and that works on every occasion. That\'s not realistic, although we can say that the **newer kernel versions are very well tuned by default**. In fact, you might [hurt performance if you mess with the defaults](https://medium.com/@duhroach/the-bandwidth-delay-problem-c6a2a578b211).\n\nThis brief tutorial shows **where some of the most used and quoted sysctl/network parameters are located into the Linux network flow**, it was heavily inspired by [the illustrated guide to Linux networking stack](https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/) and many of [Marek Majkowski\'s posts](https://blog.cloudflare.com/how-to-achieve-low-latency/). \n\n> #### Feel free to send corrections and suggestions! :)\n\n# Linux network queues overview\n\n![linux network queues](/img/linux_network_flow.png "A graphic representation of linux/kernel network main buffer / queues")\n\n# Fitting the sysctl variables into the Linux network flow\n\n## Ingress - they\'re coming\n1. Packets arrive at the NIC\n1. NIC will verify `MAC` (if not on promiscuous mode) and `FCS` and decide to drop or to continue\n1. NIC will [DMA packets at RAM](https://en.wikipedia.org/wiki/Direct_memory_access), in a region previously prepared (mapped) by the driver\n1. NIC will enqueue references to the packets at receive [ring buffer](https://en.wikipedia.org/wiki/Circular_buffer) queue `rx` until `rx-usecs` timeout or `rx-frames`\n1. NIC will raise a `hard IRQ`\n1. CPU will run the `IRQ handler` that runs the driver\'s code\n1. Driver will `schedule a NAPI`, clear the `hard IRQ` and return\n1. Driver raise a `soft IRQ (NET_RX_SOFTIRQ)`\n1. NAPI will poll data from the receive ring buffer until `netdev_budget_usecs` timeout or `netdev_budget` and `dev_weight` packets\n1. Linux will also allocate memory to `sk_buff`\n1. Linux fills the metadata: protocol, interface, setmacheader, removes ethernet\n1. Linux will pass the skb to the kernel stack (`netif_receive_skb`)\n1. It will set the network header, clone `skb` to taps (i.e. tcpdump) and pass it to tc ingress\n1. Packets are handled to a qdisc sized `netdev_max_backlog` with its algorithm defined by `default_qdisc`\n1. It calls `ip_rcv` and packets are handled to IP\n1. It calls netfilter (`PREROUTING`)\n1. It looks at the routing table, if forwarding or local\n1. If it\'s local it calls netfilter (`LOCAL_IN`)\n1. It calls the L4 protocol (for instance `tcp_v4_rcv`)\n1. It finds the right socket\n1. It goes to the tcp finite state machine\n1. Enqueue the packet to  the receive buffer and sized as `tcp_rmem` rules\n    1. If `tcp_moderate_rcvbuf` is enabled kernel will auto-tune the receive buffer\n1. Kernel will signalize that there is data available to apps (epoll or any polling system)\n1. Application wakes up and reads the data\n\n## Egress - they\'re leaving\n1. Application sends message (`sendmsg` or other)\n1. TCP send message allocates skb_buff\n1. It enqueues skb to the socket write buffer of `tcp_wmem` size\n1. Builds the TCP header (src and dst port, checksum)\n1. Calls L3 handler (in this case `ipv4` on `tcp_write_xmit` and `tcp_transmit_skb`)\n1. L3 (`ip_queue_xmit`) does its work: build ip header and call netfilter (`LOCAL_OUT`)\n1. Calls output route action\n1. Calls netfilter (`POST_ROUTING`)\n1. Fragment the packet (`ip_output`)\n1. Calls L2 send function (`dev_queue_xmit`)\n1. Feeds the output (QDisc) queue of `txqueuelen` length with its algorithm `default_qdisc`\n1. The driver code enqueue the packets at the `ring buffer tx`\n1. The driver will do a `soft IRQ (NET_TX_SOFTIRQ)` after `tx-usecs` timeout or `tx-frames`\n1. Re-enable hard IRQ to NIC\n1. Driver will map all the packets (to be sent) to some DMA\'ed region\n1. NIC fetches the packets (via DMA) from RAM to transmit\n1. After the transmission NIC will raise a `hard IRQ` to signal its completion\n1. The driver will handle this IRQ (turn it off)\n1. And schedule (`soft IRQ`) the NAPI poll system \n1. NAPI will handle the receive packets signaling and free the RAM\n\n# What, Why and How - network and sysctl parameters\n\n## Ring Buffer - rx,tx\n* **What** - the driver receive/send queue a single or multiple queues with a fixed size, usually implemented as FIFO, it is located at RAM\n* **Why** - buffer to smoothly accept bursts of connections without dropping them, you might need to increase these queues when you see drops or overrun, aka there are more packets coming than the kernel is able to consume them, the side effect might be increased latency.\n* **How:**\n  * **Check command:** `ethtool -g ethX`\n  * **Change command:** `ethtool -G ethX rx value tx value`\n  * **How to monitor:** `ethtool -S ethX | grep -e "err" -e "drop" -e "over" -e "miss" -e "timeout" -e "reset" -e "restar" -e "collis" -e "over" | grep -v "\\: 0"`\n \n## Interrupt Coalescence (IC) - rx-usecs, tx-usecs, rx-frames, tx-frames (hardware IRQ)\n* **What** - number of microseconds/frames to wait before raising a hardIRQ, from the NIC perspective it\'ll DMA data packets until this timeout/number of frames\n* **Why** - reduce CPUs usage, hard IRQ, might increase throughput at cost of latency.\n* **How:**\n  * **Check command:** `ethtool -c ethX`\n  * **Change command:** `ethtool -C ethX rx-usecs value tx-usecs value`\n  * **How to monitor:** `cat /proc/interrupts` \n  \n## Interrupt Coalescing (soft IRQ) and Ingress QDisc\n* **What** - maximum number of microseconds in one [NAPI](https://en.wikipedia.org/wiki/New_API) polling cycle. Polling will exit when either `netdev_budget_usecs` have elapsed during the poll cycle or the number of packets processed reaches  `netdev_budget`.\n* **Why** - instead of reacting to tons of softIRQ, the driver keeps polling data; keep an eye on `dropped` (# of packets that were dropped because `netdev_max_backlog` was exceeded) and `squeezed` (# of times ksoftirq ran out of `netdev_budget` or time slice with work remaining).\n* **How:**\n  * **Check command:** `sysctl net.core.netdev_budget_usecs`\n  * **Change command:** `sysctl -w net.core.netdev_budget_usecs value`\n  * **How to monitor:** `cat /proc/net/softnet_stat`; or a [better tool](https://raw.githubusercontent.com/majek/dump/master/how-to-receive-a-packet/softnet.sh)\n* **What** - `netdev_budget` is the maximum number of packets taken from all interfaces in one polling cycle (NAPI poll). In one polling cycle interfaces which are registered to polling are probed in a round-robin manner. Also, a polling cycle may not exceed `netdev_budget_usecs` microseconds, even if `netdev_budget` has not been exhausted.\n* **How:**\n  * **Check command:** `sysctl net.core.netdev_budget`\n  * **Change command:** `sysctl -w net.core.netdev_budget value`\n  * **How to monitor:** `cat /proc/net/softnet_stat`; or a [better tool](https://raw.githubusercontent.com/majek/dump/master/how-to-receive-a-packet/softnet.sh)\n* **What** - `dev_weight` is the maximum number of packets that kernel can handle on a NAPI interrupt, it\'s a Per-CPU variable. For drivers that support LRO or GRO_HW, a hardware aggregated packet is counted as one packet in this.\n* **How:**\n  * **Check command:** `sysctl net.core.dev_weight`\n  * **Change command:** `sysctl -w net.core.dev_weight value`\n  * **How to monitor:** `cat /proc/net/softnet_stat`; or a [better tool](https://raw.githubusercontent.com/majek/dump/master/how-to-receive-a-packet/softnet.sh)\n* **What** - `netdev_max_backlog` is the maximum number  of  packets,  queued  on  the  INPUT side (_the ingress qdisc_), when the interface receives packets faster than kernel can process them.\n* **How:**\n  * **Check command:** `sysctl net.core.netdev_max_backlog`\n  * **Change command:** `sysctl -w net.core.netdev_max_backlog value`\n  * **How to monitor:** `cat /proc/net/softnet_stat`; or a [better tool](https://raw.githubusercontent.com/majek/dump/master/how-to-receive-a-packet/softnet.sh)\n  \n## Egress QDisc - txqueuelen and default_qdisc\n* **What** - `txqueuelen` is the maximum number of packets, queued on the OUTPUT side.\n* **Why** - a buffer/queue to face connection burst and also to apply [tc (traffic control).](http://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html)\n* **How:**\n  * **Check command:** `ifconfig ethX`\n  * **Change command:** `ifconfig ethX txqueuelen value`\n  * **How to monitor:** `ip -s link` \n* **What** - `default_qdisc` is the default queuing discipline to use for network devices.\n* **Why** - each application has different load and need to traffic control and it is used also to fight against [bufferbloat](https://www.bufferbloat.net/projects/codel/wiki/)\n* **How:**\n  * **Check command:** `sysctl net.core.default_qdisc`\n  * **Change command:** `sysctl -w net.core.default_qdisc value`\n  * **How to monitor:**   `tc -s qdisc ls dev ethX`\n\n## TCP Read and Write Buffers/Queues\n* **What** - `tcp_rmem` - min (size used under memory pressure), default (initial size), max (maximum size) - size of receive buffer used by TCP sockets.\n* **Why** - the application buffer/queue to the write/send data, [understand its consequences can help a lot](https://blog.cloudflare.com/the-story-of-one-latency-spike/).\n* **How:**\n  * **Check command:** `sysctl net.ipv4.tcp_rmem`\n  * **Change command:** `sysctl -w net.ipv4.tcp_rmem="min default max"`; when changing default value, remember to restart your user space app (i.e. your web server, nginx, etc)\n  * **How to monitor:** `cat /proc/net/sockstat`\n* **What** - `tcp_wmem` - min (size used under memory pressure), default (initial size), max (maximum size) - size of send buffer used by TCP sockets.\n* **How:**\n  * **Check command:** `sysctl net.ipv4.tcp_wmem`\n  * **Change command:** `sysctl -w net.ipv4.tcp_wmem="min default max"`; when changing default value, remember to restart your user space app (i.e. your web server, nginx, etc)\n  * **How to monitor:** `cat /proc/net/sockstat`\n* **What** `tcp_moderate_rcvbuf` - If set, TCP performs receive buffer auto-tuning, attempting to automatically size the buffer.\n* **How:**\n  * **Check command:** `sysctl net.ipv4.tcp_moderate_rcvbuf`\n  * **Change command:** `sysctl -w net.ipv4.tcp_moderate_rcvbuf value`\n  * **How to monitor:** `cat /proc/net/sockstat`\n\n## Honorable mentions - TCP FSM and congestion algorithm\n* `sysctl net.core.somaxconn` - provides an upper limit on the value of the backlog parameter passed to the [`listen()` function](https://eklitzke.org/how-tcp-sockets-work), known in userspace as `SOMAXCONN`. If you change this value, you should also change your application to a compatible value (i.e. [nginx backlog](http://nginx.org/en/docs/http/ngx_http_core_module.html#listen)).\n* `cat /proc/sys/net/ipv4/tcp_fin_timeout` - this specifies the number of seconds to wait for a final FIN packet before the socket is forcibly closed.  This is strictly a violation of the TCP specification but required to prevent denial-of-service attacks.\n* `cat /proc/sys/net/ipv4/tcp_available_congestion_control` - shows the available congestion control choices that are registered.\n* `cat /proc/sys/net/ipv4/tcp_congestion_control` - sets the congestion control algorithm to be used for new connections.\n* `cat /proc/sys/net/ipv4/tcp_max_syn_backlog` - sets the maximum number of queued connection requests which have still not received an acknowledgment from the connecting client; if this number is exceeded, the kernel will begin dropping requests.\n* `cat /proc/sys/net/ipv4/tcp_syncookies` - enables/disables [syn cookies](https://en.wikipedia.org/wiki/SYN_cookies), useful for protecting against [syn flood attacks](https://www.cloudflare.com/learning/ddos/syn-flood-ddos-attack/).\n* `cat /proc/sys/net/ipv4/tcp_slow_start_after_idle` - enables/disables tcp slow start.\n\n**How to monitor:** \n* `netstat -atn | awk \'/tcp/ {print $6}\' | sort | uniq -c` - summary by state\n* `ss -neopt state time-wait | wc -l` - counters by a specific state: `established`, `syn-sent`, `syn-recv`, `fin-wait-1`, `fin-wait-2`, `time-wait`, `closed`, `close-wait`, `last-ack`, `listening`, `closing`\n* `netstat -st` - tcp stats summary\n* `nstat -a` - human-friendly tcp stats summary\n* `cat /proc/net/sockstat` - summarized socket stats\n* `cat /proc/net/tcp` - detailed stats, see each field meaning at the [kernel docs](https://www.kernel.org/doc/Documentation/networking/proc_net_tcp.txt)\n* `cat /proc/net/netstat` - `ListenOverflows` and `ListenDrops` are important fields to keep an eye on\n  * `cat /proc/net/netstat | awk \'(f==0) { i=1; while ( i<=NF) {n[i] = $i; i++ }; f=1; next} \\\n(f==1){ i=2; while ( i<=NF){ printf "%s = %d\\n", n[i], $i; i++}; f=0} \' | grep -v "= 0`; a [human readable `/proc/net/netstat`](https://sa-chernomor.livejournal.com/9858.html)\n\n![tcp finite state machine](https://upload.wikimedia.org/wikipedia/commons/a/a2/Tcp_state_diagram_fixed.svg "A graphic representation of tcp tcp finite state machine")\nSource: https://commons.wikimedia.org/wiki/File:Tcp_state_diagram_fixed_new.svg\n\n# Network tools for testing and monitoring\n\n* [iperf3](https://iperf.fr/) - network throughput\n* [vegeta](https://github.com/tsenart/vegeta) - HTTP load testing tool\n* [netdata](https://github.com/firehol/netdata) - system for distributed real-time performance and health monitoring\n\n# References\n\n* https://www.kernel.org/doc/Documentation/sysctl/net.txt\n* https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt\n* https://www.kernel.org/doc/Documentation/networking/scaling.txt\n* https://www.kernel.org/doc/Documentation/networking/proc_net_tcp.txt\n* https://www.kernel.org/doc/Documentation/networking/multiqueue.txt\n* http://man7.org/linux/man-pages/man7/tcp.7.html\n* http://man7.org/linux/man-pages/man8/tc.8.html\n* http://www.ece.virginia.edu/cheetah/documents/papers/TCPlinux.pdf\n* https://netdevconf.org/1.2/papers/bbr-netdev-1.2.new.new.pdf\n* https://blog.cloudflare.com/how-to-receive-a-million-packets/\n* https://blog.cloudflare.com/how-to-achieve-low-latency/\n* https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/\n* https://www.youtube.com/watch?v=6Fl1rsxk4JQ\n* https://oxnz.github.io/2016/05/03/performance-tuning-networking/\n* https://www.intel.com/content/dam/www/public/us/en/documents/reference-guides/xl710-x710-performance-tuning-linux-guide.pdf\n* https://access.redhat.com/sites/default/files/attachments/20150325_network_performance_tuning.pdf\n* https://medium.com/@matteocroce/linux-and-freebsd-networking-cbadcdb15ddd\n* https://blogs.technet.microsoft.com/networking/2009/08/12/where-do-resets-come-from-no-the-stork-does-not-bring-them/\n* https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/multi-core-processor-based-linux-paper.pdf\n* http://syuu.dokukino.com/2013/05/linux-kernel-features-for-high-speed.html\n* https://www.bufferbloat.net/projects/codel/wiki/Best_practices_for_benchmarking_Codel_and_FQ_Codel/\n* https://software.intel.com/en-us/articles/setting-up-intel-ethernet-flow-director\n* https://courses.engr.illinois.edu/cs423/sp2014/Lectures/LinuxDriver.pdf\n* https://www.coverfire.com/articles/queueing-in-the-linux-network-stack/\n* http://vger.kernel.org/~davem/skb.html\n* https://www.missoulapubliclibrary.org/ftp/LinuxJournal/LJ13-07.pdf\n* https://opensourceforu.com/2016/10/network-performance-monitoring/\n* https://www.yumpu.com/en/document/view/55400902/an-adventure-of-analysis-and-optimisation-of-the-linux-networking-stack\n* https://lwn.net/Articles/616241/\n* https://medium.com/@duhroach/tools-to-profile-networking-performance-3141870d5233\n* https://www.lmax.com/blog/staff-blogs/2016/05/06/navigating-linux-kernel-network-stack-receive-path/\n* https://es.net/host-tuning/100g-tuning/\n* http://tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm\n* http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html\n* https://people.cs.clemson.edu/~westall/853/tcpperf.pdf\n* http://tldp.org/HOWTO/Traffic-Control-HOWTO/classless-qdiscs.html\n* https://es.net/assets/Papers-and-Publications/100G-Tuning-TechEx2016.tierney.pdf\n* https://www.kernel.org/doc/ols/2009/ols2009-pages-169-184.pdf\n* https://devcentral.f5.com/articles/the-send-buffer-in-depth-21845\n* http://packetbomb.com/understanding-throughput-and-tcp-windows/\n* https://www.speedguide.net/bdp.php\n* https://www.switch.ch/network/tools/tcp_throughput/\n* https://www.ibm.com/support/knowledgecenter/en/SSQPD3_2.6.0/com.ibm.wllm.doc/usingethtoolrates.html\n* https://blog.tsunanet.net/2011/03/out-of-socket-memory.html\n* https://unix.stackexchange.com/questions/12985/how-to-check-rx-ring-max-backlog-and-max-syn-backlog-size\n* https://serverfault.com/questions/498245/how-to-reduce-number-of-time-wait-processes\n* https://unix.stackexchange.com/questions/419518/how-to-tell-how-much-memory-tcp-buffers-are-actually-using\n* https://eklitzke.org/how-tcp-sockets-work\n* https://www.linux.com/learn/intro-to-linux/2017/7/introduction-ss-command\n* https://staaldraad.github.io/2017/12/20/netstat-without-netstat/\n* https://loicpefferkorn.net/2016/03/linux-network-metrics-why-you-should-use-nstat-instead-of-netstat/\n* http://assimilationsystems.com/2015/12/29/bufferbloat-network-best-practice/\n'