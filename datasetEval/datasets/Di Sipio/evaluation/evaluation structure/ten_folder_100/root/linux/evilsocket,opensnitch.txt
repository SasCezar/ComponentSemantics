b'<p align="center">\n  <img alt="opensnitch" src="https://raw.githubusercontent.com/evilsocket/opensnitch/master/ui/opensnitch/res/icon.png" height="160" />\n  <p align="center">\n    <a href="https://github.com/evilsocket/opensnitch/releases/latest"><img alt="Release" src="https://img.shields.io/github/release/evilsocket/opensnitch.svg?style=flat-square"></a>\n    <a href="https://github.com/evilsocket/opensnitch/blob/master/LICENSE.md"><img alt="Software License" src="https://img.shields.io/badge/license-GPL3-brightgreen.svg?style=flat-square"></a>\n    <a href="https://goreportcard.com/report/github.com/evilsocket/opensnitch/daemon"><img alt="Go Report Card" src="https://goreportcard.com/badge/github.com/evilsocket/opensnitch/daemon?style=flat-square"></a>\n  </p>\n</p>\n\n**OpenSnitch** is a GNU/Linux port of the Little Snitch application firewall.\n\n<p align="center">\n  <img src="https://raw.githubusercontent.com/evilsocket/opensnitch/master/screenshot.png" alt="OpenSnitch"/>\n</p>\n\n**THIS SOFTWARE IS WORK IN PROGRESS, DO NOT EXPECT IT TO BE BUG FREE AND DO NOT RELY ON IT FOR ANY TYPE OF SECURITY.**\n\n### TL;DR\n\nMake sure you have a correctly configured **Go >= 1.8** environment, that the `$GOPATH` environment variable is defined and then:\n\n```bash\n# install dependencies\nsudo apt-get install git libnetfilter-queue-dev libpcap-dev protobuf-compiler python3-pip\ngo get github.com/golang/protobuf/protoc-gen-go\ngo get -u github.com/golang/dep/cmd/dep\ncd $GOPATH/src/github.com/golang/dep\n./install.sh\nexport PATH=$PATH:$GOPATH/bin\npython3 -m pip install --user grpcio-tools\n# clone the repository (ignore the message about no Go files being found)\ngo get github.com/evilsocket/opensnitch\ncd $GOPATH/src/github.com/evilsocket/opensnitch\n# compile && install\nmake\nsudo make install\n# enable opensnitchd as a systemd service and start the UI\nsudo systemctl enable opensnitchd\nsudo service opensnitchd start\nopensnitch-ui\n```\n\n### Daemon\n\nThe `daemon` is implemented in Go and needs to run as root in order to interact with the Netfilter packet queue, edit \niptables rules and so on, in order to compile it you will need to install the `protobuf-compiler`, `libpcap-dev` and `libnetfilter-queue-dev`\npackages on your system, then just:\n\n    cd daemon\n    make\n\nYou can then install it as a systemd service by doing:\n\n    sudo make install\n\nThe new `opensnitchd` service will log to `/var/log/opensnitchd.log`, save the rules inside `/etc/opensnitchd/rules` and connect to the default UI service socket `unix:///tmp/osui.sock`.\n\n### UI\n\nThe user interface is a Python 3 software running as a `gRPC` server on a unix socket, to order to install its dependencies:\n\n    cd ui\n    sudo pip3 install -r requirements.txt\n\nYou will also need to install the package `python-pyqt5` for your system (if anyone finds a way to make this work from \nthe `requirements.txt` file feel free to send a PR).\n\nThe UI is pip installable itself:\n\n    sudo pip3 install .\n\nThis will install the `opensnitch-ui` command on your system (you can auto startup it by `cp opensnitch_ui.desktop ~/.config/autostart/`).\n  \n#### UI Configuration\n\nBy default the UI will load its configuration from `~/.opensnitch/ui-config.json` (customizable with the `--config` argument), the \ndefault contents of this file are:\n\n```json\n{\n\t"default_timeout": 15,\n\t"default_action": "allow",\n\t"default_duration": "until restart"\n}\n```\n\nThe `default_timeout` is the number of seconds after which the UI will take its default action, the `default_action` can be `allow` or `deny`\nand the `default_duration`, which indicates for how long the default action should be taken, can be `once`, `until restart` or `always` to\npersist the action as a new rule on disk.\n\n### Running\n\nOnce you installed both the daemon and the UI, you can enable the `opensnitchd` service to run at boot time:\n\n    sudo systemctl enable opensnitchd\n\nAnd run it with:\n\n    sudo service opensnitchd start\n\nWhile the UI can be started just by executing the `opensnitch-ui` command.\n\n#### Single UI with many computers\n\nYou can also use `--socket "[::]:50051"` to have the UI use TCP instead of a unix socket and run the daemon on another\ncomputer with `-ui-socket "x.x.x.x:50051"` (where `x.x.x.x` is the IP of the computer running the UI service).\n\n### Rules\n\nRules are stored as JSON files inside the `-rule-path` folder, in the simplest cast a rule looks like this:\n\n```json\n{\n   "created": "2018-04-07T14:13:27.903996051+02:00",\n   "updated": "2018-04-07T14:13:27.904060088+02:00",\n   "name": "deny-simple-www-google-analytics-l-google-com",\n   "enabled": true,\n   "action": "deny",\n   "duration": "always",\n   "operator": {\n     "type": "simple",\n     "operand": "dest.host",\n     "data": "www-google-analytics.l.google.com"\n   }\n}\n```\n\n| Field            | Description   |\n| -----------------|---------------|\n| created          | UTC date and time of creation. |\n| update           | UTC date and time of the last update. |\n| name             | The name of the rule. |\n| enabled          | Use to temporarily disable and enable rules without moving their files. |\n| action           | Can be `deny` or `allow`. |\n| duration         | For rules persisting on disk, this value is default to `always`. |\n| operator.type    | Can be `simple`, in which case a simple `==` comparison will be performed, or `regexp` if the `data` field is a regular expression to match. |\n| operator.operand | What element of the connection to compare, can be one of: `true` (will always match), `process.path` (the path of the executable), `process.command` (full command line, including path and arguments), `provess.env.ENV_VAR_NAME` (use the value of an environment variable of the process given its name), `user.id`, `dest.ip`, `dest.host` or `dest.port`. |\n| operator.data    | The data to compare the `operand` to, can be a regular expression if `type` is `regexp`. |\n\nAn example with a regular expression:\n\n```json\n{\n   "created": "2018-04-07T14:13:27.903996051+02:00",\n   "updated": "2018-04-07T14:13:27.904060088+02:00",\n   "name": "deny-any-google-analytics",\n   "enabled": true,\n   "action": "deny",\n   "duration": "always",\n   "operator": {\n     "type": "regexp",\n     "operand": "dest.host",\n     "data": "(?i).*analytics.*\\\\.google\\\\.com"\n   }\n}\n```\n\nAn example whitelisting a whole process:\n\n```json\n{\n   "created": "2018-04-07T15:00:48.156737519+02:00",\n   "updated": "2018-04-07T15:00:48.156772601+02:00",\n   "name": "allow-simple-opt-google-chrome-chrome",\n   "enabled": true,\n   "action": "allow",\n   "duration": "always",\n   "operator": {\n     "type": "simple",\n     "operand": "process.path",\n     "data": "/opt/google/chrome/chrome"\n   }\n }\n```\n\n### FAQ\n\n##### Why Qt and not GTK?\n\nI tried, but for very fast updates it failed bad on my configuration (failed bad = SIGSEGV), moreover I find Qt5 layout system superior and easier to use.\n\n##### Why gRPC and not DBUS?\n\nThe UI service is able to use a TCP listener instead of a UNIX socket, that means the UI service itself can be executed on any \noperating system, while receiving messages from a single local daemon instance or multiple instances from remote computers in the network,\ntherefore DBUS would have made the protocol and logic uselessly GNU/Linux specific.\n'