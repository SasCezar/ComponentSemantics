b'jquery.serializeJSON\n====================\n\nAdds the method `.serializeJSON()` to [jQuery](http://jquery.com/) (or [Zepto](http://zeptojs.com/)) that serializes a form into a JavaScript Object, using the same format as the default Ruby on Rails request params.\n\nInstall\n-------\n\nInstall with [bower](http://bower.io/) `bower install jquery.serializeJSON`, or [npm](https://www.npmjs.com/) `npm install jquery-serializejson`, or just download the [jquery.serializejson.js](https://raw.githubusercontent.com/marioizquierdo/jquery.serializeJSON/master/jquery.serializejson.js) script.\n\nAnd make sure it is included after jQuery, for example:\n```html\n<script type="text/javascript" src="jquery.js"></script>\n<script type="text/javascript" src="jquery.serializejson.js"></script>\n```\n\nUsage Example\n-------------\n\nHTML form:\n```html\n<form>\n  <input type="text" name="title" value="Finding Loot"/>\n  <input type="text" name="author[name]" value="John Smith"/>\n  <input type="text" name="author[job]"  value="Legendary Pirate"/>\n</form>\n```\n\nJavaScript:\n```javascript\n$(\'form\').serializeJSON();\n\n// returns =>\n{\n  title: "Finding Loot",\n  author: {\n    name: "John Smith",\n    job: "Legendary Pirate"\n  }\n}\n```\n\nForm input, textarea and select tags are supported. Nested attributes and arrays can be specified by using the `attr[nested][nested]` syntax.\n\nHTML form:\n```html\n<form id="my-profile">\n  <!-- simple attribute -->\n  <input type="text" name="fullName"              value="Mario Izquierdo" />\n\n  <!-- nested attributes -->\n  <input type="text" name="address[city]"         value="San Francisco" />\n  <input type="text" name="address[state][name]"  value="California" />\n  <input type="text" name="address[state][abbr]"  value="CA" />\n\n  <!-- array -->\n  <input type="text" name="jobbies[]"             value="code" />\n  <input type="text" name="jobbies[]"             value="climbing" />\n\n  <!-- nested arrays, textareas, checkboxes ... -->\n  <textarea              name="projects[0][name]">serializeJSON</textarea>\n  <textarea              name="projects[0][language]">javascript</textarea>\n  <input type="hidden"   name="projects[0][popular]" value="0" />\n  <input type="checkbox" name="projects[0][popular]" value="1" checked />\n\n  <textarea              name="projects[1][name]">tinytest.js</textarea>\n  <textarea              name="projects[1][language]">javascript</textarea>\n  <input type="hidden"   name="projects[1][popular]" value="0" />\n  <input type="checkbox" name="projects[1][popular]" value="1"/>\n\n  <!-- select -->\n  <select name="selectOne">\n    <option value="paper">Paper</option>\n    <option value="rock" selected>Rock</option>\n    <option value="scissors">Scissors</option>\n  </select>\n\n  <!-- select multiple options, just name it as an array[] -->\n  <select multiple name="selectMultiple[]">\n    <option value="red"  selected>Red</option>\n    <option value="blue" selected>Blue</option>\n    <option value="yellow">Yellow</option>\n\t</select>\n</form>\n\n```\n\nJavaScript:\n\n```javascript\n$(\'#my-profile\').serializeJSON();\n\n// returns =>\n{\n  fullName: "Mario Izquierdo",\n\n  address: {\n    city: "San Francisco",\n    state: {\n      name: "California",\n      abbr: "CA"\n    }\n  },\n\n  jobbies: ["code", "climbing"],\n\n  projects: {\n    \'0\': { name: "serializeJSON", language: "javascript", popular: "1" },\n    \'1\': { name: "tinytest.js",   language: "javascript", popular: "0" }\n  },\n\n  selectOne: "rock",\n  selectMultiple: ["red", "blue"]\n}\n```\n\nThe `serializeJSON` function returns a JavaScript object, not a JSON String. The plugin should probably have been called `serializeObject` or similar, but those plugins already existed.\n\nTo convert into a JSON String, use the `JSON.stringify` method, that is available on all major [new browsers](http://caniuse.com/json).\nIf you need to support very old browsers, just include the [json2.js](https://github.com/douglascrockford/JSON-js) polyfill (as described on [stackoverfow](http://stackoverflow.com/questions/191881/serializing-to-json-in-jquery)).\n\n```javascript\nvar obj = $(\'form\').serializeJSON();\nvar jsonString = JSON.stringify(obj);\n```\n\nThe plugin implememtation relies on jQuery\'s [.serializeArray()](https://api.jquery.com/serializeArray/) method.\nThis means that it only serializes the inputs supported by `.serializeArray()`, which follows the standard W3C rules for [successful controls](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2). In particular, the included elements **cannot be disabled** and must contain a **name attribute**. No submit button value is serialized since the form was not submitted using a button. And data from file select elements is not serialized.\n\n\nParse values with :types\n------------------------\n\nAll attribute values are **strings** by default. But you can force values to be parsed with specific types by appending the type with a colon.\n\n```html\n<form>\n  <input type="text" name="strbydefault"     value=":string is the default (implicit) type"/>\n  <input type="text" name="text:string"      value=":string type can still be used to overrid other parsing options"/>\n  <input type="text" name="excluded:skip"    value="Use :skip to not include this field in the result"/>\n\n  <input type="text" name="numbers[1]:number"           value="1"/>\n  <input type="text" name="numbers[1.1]:number"         value="1.1"/>\n  <input type="text" name="numbers[other stuff]:number" value="other stuff"/>\n\n  <input type="text" name="bools[true]:boolean"      value="true"/>\n  <input type="text" name="bools[false]:boolean"     value="false"/>\n  <input type="text" name="bools[0]:boolean"         value="0"/>\n\n  <input type="text" name="nulls[null]:null"            value="null"/>\n  <input type="text" name="nulls[other stuff]:null"     value="other stuff"/>\n\n  <input type="text" name="autos[string]:auto"          value="text with stuff"/>\n  <input type="text" name="autos[0]:auto"               value="0"/>\n  <input type="text" name="autos[1]:auto"               value="1"/>\n  <input type="text" name="autos[true]:auto"            value="true"/>\n  <input type="text" name="autos[false]:auto"           value="false"/>\n  <input type="text" name="autos[null]:auto"            value="null"/>\n  <input type="text" name="autos[list]:auto"            value="[1, 2, 3]"/>\n\n  <input type="text" name="arrays[empty]:array"         value="[]"/>\n  <input type="text" name="arrays[list]:array"          value="[1, 2, 3]"/>\n\n  <input type="text" name="objects[empty]:object"       value="{}"/>\n  <input type="text" name="objects[dict]:object"        value=\'{"my": "stuff"}\'/>\n</form>\n```\n\n```javascript\n$(\'form\').serializeJSON();\n\n// returns =>\n{\n  "strbydefault": ":string is the default (implicit) type",\n  "text": ":string type can still be used to overrid other parsing options",\n  // excluded:skip is not included in the output\n  "numbers": {\n    "1": 1,\n    "1.1": 1.1,\n    "other stuff": NaN, // <-- Not a Number\n  },\n  "bools": {\n    "true": true,\n    "false": false,\n    "0": false, // <-- "false", "null", "undefined", "", "0" parse as false\n  },\n  "nulls": {\n    "null": null, // <-- "false", "null", "undefined", "", "0" parse as null\n    "other stuff": "other stuff"\n  },\n  "autos": { // <-- works like the parseAll option\n    "string": "text with stuff",\n    "0": 0,         // <-- parsed as number\n    "1": 1,         // <-- parsed as number\n    "true": true,   // <-- parsed as boolean\n    "false": false, // <-- parsed as boolean\n    "null": null,   // <-- parsed as null\n    "list": "[1, 2, 3]" // <-- array and object types are not auto-parsed\n  },\n  "arrays": { // <-- uses JSON.parse\n    "empty": [],\n    "not empty": [1,2,3]\n  },\n  "objects": { // <-- uses JSON.parse\n    "empty": {},\n    "not empty": {"my": "stuff"}\n  }\n}\n```\n\nTypes can also be specified with the attribute `data-value-type`, instead of having to add the ":type" suffix:\n```html\n<form>\n  <input type="text" name="anumb"   data-value-type="number"  value="1"/>\n  <input type="text" name="abool"   data-value-type="boolean" value="true"/>\n  <input type="text" name="anull"   data-value-type="null"    value="null"/>\n  <input type="text" name="anauto"  data-value-type="auto"    value="0"/>\n</form>\n```\n\n\nOptions\n-------\n\nBy default `.serializeJSON()` with no options has this behavior:\n\n  * Values are always **strings** (unless appending :types to the input names)\n  * Unchecked checkboxes are ignored (as defined in the W3C rules for [successful controls](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2)).\n  * Disabled elements are ignored (W3C rules)\n  * Keys (input names) are always **strings** (nested params are objects by default)\n\nThis is because `serializeJSON` is designed to return exactly the same as a regular HTML form submission when serialized as Rack/Rails params, which ensures maximun compatibility and stability.\n\nAllowed options to change the default behavior:\n\n  * **checkboxUncheckedValue: string**, string value used on unchecked checkboxes (otherwise those values are ignored). For example `{checkboxUncheckedValue: ""}`. If the value needs to be parsed (i.e. to a Boolean or Null) use a parse option (i.e. `parseBooleans: true`) or define the input with the `:boolean` or `:null` types.\n  * **parseBooleans: true**, automatically detect and convert strings `"true"` and `"false"` to booleans `true` and `false`.\n  * **parseNumbers: true**, automatically detect and convert strings like `"1"`, `"33.33"`, `"-44"` to numbers like `1`, `33.33`, `-44`.\n  * **parseNulls: true**, automatically detect and convert the string `"null"` to the null value `null`.\n  * **parseAll: true**, all of the above. This is the same as if the default :type was `:auto` instead of `:string`.\n  * **parseWithFunction: function**, define your own parse `function(inputValue, inputName) { return parsedValue }`.\n  * **skipFalsyValuesForFields: []**, skip given fields (by name) with falsy values. You can use `data-skip-falsy="true"` input attribute as well. Falsy values are determined after converting to a given type, note that `"0"` as :string is truthy, but `0` as :number is falsy.\n  * **skipFalsyValuesForTypes: []**, skip given fields (by :type) with falsy values (i.e. `skipFalsyValuesForTypes: ["string", "number"]` would skip `""` for `:string` fields, and `0` for `:number` fields).\n  * **customTypes: {}**, define your own :types or override the default types. Defined as an object like `{ type: function(value){...} }`. For example: `{customTypes: {nullable: function(str){ return str || null; }}`.\n  * **defaultTypes: {defaultTypes}**, in case you want to re-define all the :types. Defined as an object like `{ type: function(value){...} }`\n  * **useIntKeysAsArrayIndex: true**, when using integers as keys (i.e. `<input name="foods[0]" value="banana">`), serialize as an array (`{"foods": ["banana"]}`) instead of an object (`{"foods": {"0": "banana"}`).\n\nMore info about options usage in the sections below.\n\n## Include unchecked checkboxes ##\n\nIn my opinion, the most confusing detail when serializing a form is the input type checkbox, that will include the value if checked, and nothing if unchecked.\n\nTo deal with this, it is a common practice to use hidden fields for the "unchecked" values:\n\n```html\n<!-- Only one booleanAttr will be serialized, being "true" or "false" depending if the checkbox is selected or not -->\n<input type="hidden"   name="booleanAttr" value="false" />\n<input type="checkbox" name="booleanAttr" value="true" />\n```\n\nThis solution is somehow verbose, but it is unobtrusive and ensures progressive enhancement, because it is the standard HTML behavior (also works without JavaScript).\n\nBut, to make things easier, `serializeJSON` includes the option `checkboxUncheckedValue` and the possibility to add the attribute `data-unchecked-value` to the checkboxes.\n\nFor example:\n\n```html\n<form>\n  <input type="checkbox" name="check1" value="true" checked/>\n  <input type="checkbox" name="check2" value="true"/>\n  <input type="checkbox" name="check3" value="true"/>\n</form>\n```\n\nSerializes like this by default:\n\n```javascript\n$(\'form\').serializeJSON();\n\n// returns =>\n{\'check1\': \'true\'} // Note that check2 and check3 are not included because they are not checked\n```\n\nWhich ignores any unchecked checkboxes.\nTo include all checkboxes, use the `checkboxUncheckedValue` option like this:\n\n```javascript\n$(\'form\').serializeJSON({checkboxUncheckedValue: "false"});\n\n// returns =>\n{\'check1\': \'true\', check2: \'false\', check3: \'false\'}\n```\n\nThe "unchecked" value can also be specified via the HTML attribute `data-unchecked-value` (Note this attribute is only recognized by the plugin):\n\n```html\n<form id="checkboxes">\n  <input type="checkbox" name="checked[bool]"  value="true" data-unchecked-value="false" checked/>\n  <input type="checkbox" name="checked[bin]"   value="1"    data-unchecked-value="0"     checked/>\n  <input type="checkbox" name="checked[cool]"  value="YUP"                               checked/>\n\n  <input type="checkbox" name="unchecked[bool]"  value="true" data-unchecked-value="false" />\n  <input type="checkbox" name="unchecked[bin]"   value="1"    data-unchecked-value="0" />\n  <input type="checkbox" name="unchecked[cool]"  value="YUP" /> <!-- No unchecked value specified -->\n</form>\n```\n\nSerializes like this by default:\n\n```javascript\n$(\'form#checkboxes\').serializeJSON(); // Note no option is used\n\n// returns =>\n{\n  \'checked\': {\n    \'bool\':  \'true\',\n    \'bin\':   \'1\',\n    \'cool\':  \'YUP\'\n  },\n  \'unchecked\': {\n    \'bool\': \'false\',\n    \'bin\':  \'0\'\n    // Note that unchecked cool does not appear, because it doesn\'t use data-unchecked-value\n  }\n}\n```\n\nYou can use both the option `checkboxUncheckedValue` and the attribute `data-unchecked-value` at the same time, in which case the attribute has precedence over the option.\nAnd remember that you can combine it with other options to parse values as well.\n\n```javascript\n$(\'form#checkboxes\').serializeJSON({checkboxUncheckedValue: \'NOPE\', parseBooleans: true, parseNumbers: true});\n\n// returns =>\n{\n  \'checked\': {\n    \'bool\':  true,\n    \'bin\':   1,\n    \'cool\':  \'YUP\'\n  },\n  \'unchecked\': {\n    \'bool\': false, // value from data-unchecked-value attribute, and parsed with parseBooleans\n    \'bin\':  0,     // value from data-unchecked-value attribute, and parsed with parseNumbers\n    \'cool\': \'NOPE\' // value from checkboxUncheckedValue option\n  }\n}\n```\n\n\n## Automatically Detect Types With Parse Options ##\n\nThe default type is :string, so all values are Strings by default, even if they look like booleans, numbers or nulls. For example:\n\n```html\n<form>\n  <input type="text" name="bool[true]"    value="true"/>\n  <input type="text" name="bool[false]"   value="false"/>\n  <input type="text" name="number[0]"     value="0"/>\n  <input type="text" name="number[1]"     value="1"/>\n  <input type="text" name="number[2.2]"   value="2.2"/>\n  <input type="text" name="number[-2.25]" value="-2.25"/>\n  <input type="text" name="null"          value="null"/>\n  <input type="text" name="string"        value="text is always string"/>\n  <input type="text" name="empty"         value=""/>\n</form>\n```\n\n```javascript\n$(\'form\').serializeJSON();\n\n// returns =>\n{\n  "bool": {\n    "true": "true",\n    "false": "false",\n  }\n  "number": {\n    "0": "0",\n    "1": "1",\n    "2.2": "2.2",\n    "-2.25": "-2.25",\n  }\n  "null": "null",\n  "string": "text is always string",\n  "empty": ""\n}\n```\n\nNote that all values are **strings**.\n\nTo auto-detect types, you could use the :auto type (append :auto to input name).\nOr, you could use the parse options. For example, to parse nulls and numbers:\n\n\n```javascript\n$(\'form\').serializeJSON({parseNulls: true, parseNumbers: true});\n\n// returns =>\n{\n  "bool": {\n    "true": "true", // booleans are still strings, because parseBooleans was not set\n    "false": "false",\n  }\n  "number": {\n    "0": 0, // numbers are parsed because parseNumbers: true\n    "1": 1,\n    "2.2": 2.2,\n    "-2.25": -2.25,\n  }\n  "null": null, // "null" strings are converted to null becase parseNulls: true\n  "string": "text is always string",\n  "empty": ""\n}\n```\n\n\nFor rare cases, a custom parser can be defined with a function:\n\n```javascript\nvar emptyStringsAndZerosToNulls = function(val, inputName) {\n  if (val === "") return null; // parse empty strings as nulls\n  if (val === 0)  return null; // parse 0 as null\n  return val;\n}\n\n$(\'form\').serializeJSON({parseWithFunction: emptyStringsAndZerosToNulls, parseNumbers: true});\n\n// returns =>\n{\n  "bool": {\n    "true": "true",\n    "false": "false",\n  }\n  "number": {\n    "0": null, // <-- parsed with custom function\n    "1": 1,\n    "2.2": 2.2,\n    "-2.25": -2.25,\n  }\n  "null": "null",\n  "string": "text is always string",\n  "empty": null // <-- parsed with custom function\n}\n```\n\n## Custom Types ##\n\nYou can define your own types or override the defaults with the `customTypes` option. For example:\n\n```html\n<form>\n  <input type="text" name="scary:alwaysBoo" value="not boo"/>\n  <input type="text" name="str:string"      value="str"/>\n  <input type="text" name="number:number"   value="5"/>\n</form>\n```\n\n```javascript\n$(\'form\').serializeJSON({\n  customTypes: {\n    alwaysBoo: function(str) { // value is always a string\n      return "boo";\n    },\n    string: function(str) { // all strings will now end with " override"\n      return str + " override";\n    }\n  }\n});\n\n// returns =>\n{\n  "scary": "boo",        // <-- parsed with type :alwaysBoo\n  "str": "str override", // <-- parsed with new type :string (instead of the default)\n  "number": 5,           // <-- the default :number still works\n}\n```\n\nThe default types are defined in `$.serializeJSON.defaultOptions.defaultTypes`. If you want to define your own set of types, you could also re-define that option (it will not override the types, but define a new set of types).\n\n\n## Ignore Empty Form Fields ##\n\nYou can use the option `.serializeJSON(skipFalsyValuesForTypes: ["string"])`, which ignores any string field with an empty value (default type is :string, and empty strings are falsy).\n\nAnother option, since `serializeJSON()` is called on a jQuery object, is to just use the proper jQuery selector to skip empty values (see [Issue #28](https://github.com/marioizquierdo/jquery.serializeJSON/issues/28) for more info):\n\n```javascript\n// Select only imputs that have a non-empty value\n$(\'form :input[value!=""]\').serializeJSON();\n\n// Or filter them from the form\nobj = $(\'form\').find(\'input\').not(\'[value=""]\').serializeJSON();\n\n// For more complicated filtering, you can use a function\nobj = $form.find(\':input\').filter(function () {\n          return $.trim(this.value).length > 0\n      }).serializeJSON();\n```\n\n\n## Ignore Fields With Falsy Values ##\n\nWhen using :types, you can also skip falsy values (`false, "", 0, null, undefined, NaN`) by using the option `skipFalsyValuesForFields: ["fullName", "address[city]"]` or `skipFalsyValuesForTypes: ["string", "null"]`.\n\nOr setting a data attribute `data-skip-falsy="true"` on the inputs that should be ignored. Note that `data-skip-falsy` is aware of field :types, so it knows how to skip a non-empty input like this `<input name="foo" value="0" data-value-type="number" data-skip-falsy="true">` (Note that `"0"` as a string is not falsy, but `0` as number is falsy)).\n\n\n## Use integer keys as array indexes ##\n\nBy default, all serialized keys are **strings**, this includes keys that look like numbers like this:\n\n```html\n<form>\n  <input type="text" name="arr[0]" value="foo"/>\n  <input type="text" name="arr[1]" value="var"/>\n  <input type="text" name="arr[5]" value="inn"/>\n</form>\n```\n\n```javascript\n$(\'form\').serializeJSON();\n\n// arr is an object =>\n{\'arr\': {\'0\': \'foo\', \'1\': \'var\', \'5\': \'inn\' }}\n```\n\nWhich is how Rack [parse_nested_query](http://codefol.io/posts/How-Does-Rack-Parse-Query-Params-With-parse-nested-query) behaves. Remember that serializeJSON input name format is fully compatible with Rails parameters, that are parsed using this Rack method.\n\nUse the option `useIntKeysAsArrayIndex` to interpret integers as array indexes:\n\n```javascript\n$(\'form\').serializeJSON({useIntKeysAsArrayIndex: true});\n\n// arr is an array =>\n{\'arr\': [\'foo\', \'var\', undefined, undefined, undefined, \'inn\']}\n```\n\n**Note**: this was the default behavior of serializeJSON before version 2. You can use this option for backwards compatibility.\n\n\n## Defaults ##\n\nAll options defaults are defined in `$.serializeJSON.defaultOptions`. You can just modify it to avoid setting the option on every call to `serializeJSON`.\n\nFor example:\n\n```javascript\n$.serializeJSON.defaultOptions.parseAll = true; // parse booleans, numbers and nulls by default\n\n$(\'form\').serializeJSON(); // No options => then use $.serializeJSON.defaultOptions\n\n// returns =>\n{\n  "bool": {\n    "true": true,\n    "false": false,\n  }\n  "number": {\n    "0": 0,\n    "1": 1,\n    "2.2": 2.2,\n    "-2.25": -2.25,\n  }\n  "null": null,\n  "string": "text is always string",\n  "empty": ""\n}\n```\n\n\nAlternatives\n------------\n\nI found others solving the same problem:\n\n * https://github.com/macek/jquery-serialize-object\n * https://github.com/hongymagic/jQuery.serializeObject\n * https://github.com/danheberden/jquery-serializeForm\n * https://github.com/maxatwork/form2js (plain js, no jQuery)\n * https://github.com/serbanghita/formToObject.js (plain js, no jQuery)\n * https://gist.github.com/shiawuen/2634143 (simpler but small)\n\nBut none of them checked what I needed at the time `serializeJSON` was created. Factors that differentiate `serializeJSON` from most of the alternatives:\n\n * Simple and small code base. The minimified version is 1Kb.\n * Yet flexible enough with features like nested objects, unchecked-checkboxes and custom types.\n * Implemented on top of jQuery (or Zepto) `serializeArray`, that creates a JavaScript array of objects, ready to be encoded as a JSON string. It takes into account the W3C rules for [successful controls](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2), making `serializeJSON` as standard and stable as it can be.\n * The format for the input field names is the same used by Rails (from [Rack::Utils.parse_nested_query](http://codefol.io/posts/How-Does-Rack-Parse-Query-Params-With-parse-nested-query)), that is successfully used by many backend systems and already well understood by many front end developers.\n * Exaustive test suite helps iterate on new releases and bugfixes with confidence.\n * Compatible with [bower](https://github.com/bower/bower), [zepto.js](http://zeptojs.com/) and pretty much every version of [jQuery](https://jquery.com/).\n\n\nContributions\n-------------\n\nContributions are awesome. Feature branch *pull requests* are the preferred method. Just make sure to add tests for it. To run the jasmine specs, just open `spec/spec_runner_jquery.html` in your browser.\n\nChangelog\n---------\n * *2.9.0* (Jan 12, 2018): Overrides to `customTypes.string` function now also apply to fields with no type, because `:string` is the default implicit type. Thanks [JocaPC](https://github.com/JocaPC) for reporting the [issue #83](https://github.com/marioizquierdo/jquery.serializeJSON/issues/83).\n * *2.8.1* (Dec 09, 2016): Identify issue #67 and throw a descriptive error with a link to the issue, that explains why nested arrays of objects with checkboxes with unchecked values are not supported.\n * *2.8.0* (Dec 09, 2016): Add options `skipFalsyValuesForFields`, `skipFalsyValuesForTypes` and attr `data-skip-falsy` to easily skip falsy values (which includes empty strings). Thanks to [milkaknap](https://github.com/milkaknap).\n * *2.7.2* (Dec 19, 2015): Bugfix #55 (Allow data types with the `data-value-type` attribute to use brackets in names). Thanks to [stricte](https://github.com/stricte).\n * *2.7.1* (Dec 12, 2015): Bugfix #54 (`data-value-type` attribute only works with input elements). Thanks to [madrabaz](https://github.com/madrabaz).\n * *2.7.0* (Nov 28, 2015): Allow to define custom types with the `data-value-type` attribute. Thanks to [madrabaz](https://github.com/madrabaz).\n * *2.6.2* (Oct 24, 2015): Add support for AMD/CommonJS/Browserify modules. Thanks to [jisaacks](https://github.com/jisaacks).\n * *2.6.1* (May 13, 2015): Bugfix #43 (Fix IE 8 compatibility). Thanks to [rywall](https://github.com/rywall).\n * *2.6.0* (Apr 24, 2015): Allow to define custom types with the option `customTypes` and inspect/override default types with the option `defaultTypes`. Thanks to [tygriffin](https://github.com/tygriffin) for the [pull request](https://github.com/marioizquierdo/jquery.serializeJSON/pull/40).\n * *2.5.0* (Mar 11, 2015): Override serialized properties if using the same name, even for nested values, instead of crashing the script, fixing issue#29. Also fix a crash when using Zepto and the data-unchecked-value option.\n * *2.4.2* (Feb 04, 2015): Ignore disabled checkboxes with "data-unchecked-value". Thanks to [skarr](https://github.com/skarr) for the [pull request](https://github.com/marioizquierdo/jquery.serializeJSON/pull/33).\n * *2.4.1* (Oct 12, 2014): Add `:auto` type, that works like the `parseAll` option, but targeted to a single input.\n * *2.4.0* (Oct 12, 2014): Implement :types. Types allow to easily specify how to parse each input.\n * *2.3.2* (Oct 11, 2014): Bugfix #27 (parsing error on nested keys like name="foo[inn[bar]]"). Thanks to [danlo](https://github.com/danlo) for finding the issue.\n * *2.3.1* (Oct 06, 2014): Bugfix #22 (ignore checkboxes with no name when doing `checkboxUncheckedValue`). Thanks to [KATT](https://github.com/KATT) for finding and fixing the issue.\n * *2.3.0* (Sep 25, 2014): Properly spell "data-unckecked-value", change for "data-unchecked-value"\n * *2.2.0* (Sep 17, 2014): Add option `checkboxUncheckedValue` and attribute `data-unckecked-value` to allow parsing unchecked checkboxes.\n * *2.1.0* (Jun 08, 2014): Add option `parseWithFunction` to allow custom parsers. And fix issue #14: empty strings were parsed as a zero when `parseNumbers` option was true.\n * *2.0.0* (May 04, 2014): Nested keys are always object attributes by default (discussed on issue #12). Set option `$.serializeJSON.defaultOptions.useIntKeysAsArrayIndex = true;` for backwards compatibility (see **Options** section). Thanks to [joshuajabbour](https://github.com/joshuajabbour) for finding the issue.\n * *1.3.0* (May 03, 2014): Accept options {parseBooleans, parseNumbers, parseNulls, parseAll} to modify what type to values are interpreted from the strings. Thanks to [diaswrd](https://github.com/diaswrd) for finding the issue.\n * *1.2.3* (Apr 12, 2014): Lowercase filenames.\n * *1.2.2* (Apr 03, 2014): Now also works with [Zepto.js](http://zeptojs.com/).\n * *1.2.1* (Mar 17, 2014): Refactor, cleanup, lint code and improve test coverage.\n * *1.2.0* (Mar 11, 2014): Arrays with empty index and objects with empty values are added and not overriden. Thanks to [kotas](https://github.com/kotas).\n * *1.1.1* (Feb 16, 2014): Only unsigned integers are used to create arrays. Alphanumeric keys are always for objects. Thanks to [Nicocin](https://github.com/Nicocin).\n * *1.0.2* (Jan 07, 2014): Tag to be on the jQuery plugin registry.\n * *1.0.1* (Aug 20, 2012): Bugfix: ensure that generated arrays are being displayed when parsed with JSON.stringify\n * *1.0.0* (Aug 20, 2012): Initial release\n\nAuthor\n-------\n\nWritten and maintained by [Mario Izquierdo](https://github.com/marioizquierdo)\n'