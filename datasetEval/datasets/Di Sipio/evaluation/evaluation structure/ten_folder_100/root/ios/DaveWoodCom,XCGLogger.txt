b'![XCGLogger][xcglogger-logo]\n\n[![badge-language]][swift.org]\n[![badge-platforms]][swift.org]\n[![badge-license]][license]\n\n[![badge-travis]][travis]\n[![badge-swiftpm]][swiftpm]\n[![badge-cocoapods]][cocoapods-xcglogger]\n[![badge-carthage]][carthage]\n\n[![badge-mastodon]][mastodon-davewoodx]\n[![badge-twitter]][twitter-davewoodx]\n\n[![badge-sponsors]][cerebral-gardens]\n[![badge-patreon]][patreon-davewoodx]\n\n## tl;dr\nXCGLogger is the original debug log module for use in Swift projects. \n\nSwift does not include a C preprocessor so developers are unable to use the debug log `#define` macros they would use in Objective-C. This means our traditional way of generating nice debug logs no longer works. Resorting to just plain old `print` calls means you lose a lot of helpful information, or requires you to type a lot more code.\n\nXCGLogger allows you to log details to the console (and optionally a file, or other custom destinations), just like you would have with `NSLog()` or `print()`, but with additional information, such as the date, function name, filename and line number.\n\nGo from this:\n\n```Simple message```\n\nto this:\n\n```2014-06-09 06:44:43.600 [Debug] [AppDelegate.swift:40] application(_:didFinishLaunchingWithOptions:): Simple message```\n\n#### Example\n<img src="https://raw.githubusercontent.com/DaveWoodCom/XCGLogger/master/ReadMeImages/SampleLog.png" alt="Example" style="width: 690px;" />\n\n### Communication _(Hat Tip AlamoFire)_\n\n* If you need help, use [Stack Overflow][stackoverflow] (Tag \'[xcglogger][stackoverflow]\').\n* If you\'d like to ask a general question, use [Stack Overflow][stackoverflow].\n* If you\'ve found a bug, open an issue.\n* If you have a feature request, open an issue.\n* If you want to contribute, submit a pull request.\n* If you use XCGLogger, please Star the project on [GitHub][github-xcglogger]\n\n## Installation\n\n### Git Submodule\n\nExecute:\n\n```git submodule add https://github.com/DaveWoodCom/XCGLogger.git```\n\t\nin your repository folder.\n\n### [Carthage][carthage]\n\nAdd the following line to your `Cartfile`.\n\n```github "DaveWoodCom/XCGLogger" ~> 7.0.0```\n\nThen run `carthage update --no-use-binaries` or just `carthage update`. For details of the installation and usage of Carthage, visit [its project page][carthage].\n\nDevelopers running 5.0 and above in Swift will need to add `$(SRCROOT)/Carthage/Build/iOS/ObjcExceptionBridging.framework` to their Input Files in the Copy Carthage Frameworks Build Phase. \n\n### [CocoaPods][cocoapods]\n\nAdd something similar to the following lines to your `Podfile`. You may need to adjust based on your platform, version/branch etc.\n\n```\nsource \'https://github.com/CocoaPods/Specs.git\'\nplatform :ios, \'8.0\'\nuse_frameworks!\n\npod \'XCGLogger\', \'~> 7.0.0\'\n```\n\nSpecifying the pod `XCGLogger` on its own will include the core framework. We\'re starting to add subspecs to allow you to include optional components as well:\n\n`pod \'XCGLogger/UserInfoHelpers\', \'~> 7.0.0\'`: Include some experimental code to help deal with using UserInfo dictionaries to tag log messages.\n\nThen run `pod install`. For details of the installation and usage of CocoaPods, visit [its official web site][cocoapods].\n\nNote: Before CocoaPods 1.4.0 it was not possible to use multiple pods with a mixture of Swift versions. You may need to ensure each pod is configured for the correct Swift version (check the targets in the pod project of your workspace). If you manually adjust the Swift version for a project, it\'ll reset the next time you run `pod install`. You can add a `post_install` hook into your podfile to automate setting the correct Swift versions. This is largely untested, and I\'m not sure it\'s a good solution, but it seems to work:\n\n```\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        if [\'SomeTarget-iOS\', \'SomeTarget-watchOS\'].include? "#{target}"\n            print "Setting #{target}\'s SWIFT_VERSION to 4.2\\n"\n            target.build_configurations.each do |config|\n                config.build_settings[\'SWIFT_VERSION\'] = \'4.2\'\n            end\n        else\n            print "Setting #{target}\'s SWIFT_VERSION to Undefined (Xcode will automatically resolve)\\n"\n            target.build_configurations.each do |config|\n                config.build_settings.delete(\'SWIFT_VERSION\')\n            end\n        end\n    end\n\n    print "Setting the default SWIFT_VERSION to 3.2\\n"\n    installer.pods_project.build_configurations.each do |config|\n        config.build_settings[\'SWIFT_VERSION\'] = \'3.2\'\n    end\nend\n```\n\nYou can adjust that to suit your needs of course.\n\n### [Swift Package Manager][swiftpm]\n\nAdd the following entry to your package\'s dependencies:\n\n```\n.Package(url: "https://github.com/DaveWoodCom/XCGLogger.git", majorVersion: 7)\n```\t\n\n### Backwards Compatibility\n\nUse:\n* XCGLogger version [7.0.0][xcglogger-7.0.0] for Swift 5.0\n* XCGLogger version [6.1.0][xcglogger-6.1.0] for Swift 4.2\n* XCGLogger version [6.0.4][xcglogger-6.0.4] for Swift 4.1\n* XCGLogger version [6.0.2][xcglogger-6.0.2] for Swift 4.0\n* XCGLogger version [5.0.5][xcglogger-5.0.5] for Swift 3.0-3.2\n* XCGLogger version [3.6.0][xcglogger-3.6.0] for Swift 2.3\n* XCGLogger version [3.5.3][xcglogger-3.5.3] for Swift 2.2\n* XCGLogger version [3.2][xcglogger-3.2] for Swift 2.0-2.1\n* XCGLogger version [2.x][xcglogger-2.x] for Swift 1.2\n* XCGLogger version [1.x][xcglogger-1.x] for Swift 1.1 and below.\n\n## Basic Usage (Quick Start)\n\n_This quick start method is intended just to get you up and running with the logger. You should however use the [advanced usage below](#advanced-usage-recommended) to get the most out of this library._\n\nAdd the XCGLogger project as a subproject to your project, and add the appropriate library as a dependency of your target(s).\nUnder the `General` tab of your target, add `XCGLogger.framework` and `ObjcExceptionBridging.framework` to the `Embedded Binaries` section.\n\nThen, in each source file:\n\n```Swift\nimport XCGLogger\n```\n\nIn your AppDelegate (or other global file), declare a global constant to the default XCGLogger instance.\n\n```Swift\nlet log = XCGLogger.default\n```\n\nIn the\n```Swift\napplication(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]? = nil) // iOS, tvOS\n```\n\nor\n\n```Swift\napplicationDidFinishLaunching(_ notification: Notification) // macOS\n```\n\nfunction, configure the options you need:\n\n```Swift\nlog.setup(level: .debug, showThreadName: true, showLevel: true, showFileNames: true, showLineNumbers: true, writeToFile: "path/to/file", fileLevel: .debug)\n```\n\nThe value for `writeToFile:` can be a `String` or `URL`. If the file already exists, it will be cleared before we use it. Omit the parameter or set it to `nil` to log to the console only. You can optionally set a different log level for the file output using the `fileLevel:` parameter. Set it to `nil` or omit it to use the same log level as the console.\n\nThen, whenever you\'d like to log something, use one of the convenience methods:\n\n```Swift\nlog.verbose("A verbose message, usually useful when working on a specific problem")\nlog.debug("A debug message")\nlog.info("An info message, probably useful to power users looking in console.app")\nlog.notice("A notice message")\nlog.warning("A warning message, may indicate a possible error")\nlog.error("An error occurred, but it\'s recoverable, just info about what happened")\nlog.severe("A severe error occurred, we are likely about to crash now")\nlog.alert("An alert error occurred, a log destination could be made to email someone")\nlog.emergency("An emergency error occurred, a log destination could be made to text someone")\n```\n\nThe different methods set the log level of the message. XCGLogger will only print messages with a log level that is greater to or equal to its current log level setting. So a logger with a level of `.error` will only output log messages with a level of `.error`, `.severe`, `.alert`, or `.emergency`.\n\n## Advanced Usage (Recommended)\n\nXCGLogger aims to be simple to use and get you up and running quickly with as few as 2 lines of code above. But it allows for much greater control and flexibility. \n\nA logger can be configured to deliver log messages to a variety of destinations. Using the basic setup above, the logger will output log messages to the standard Xcode debug console, and optionally a file if a path is provided. It\'s quite likely you\'ll want to send logs to more interesting places, such as the Apple System Console, a database, third party server, or another application such as [NSLogger][NSLogger]. This is accomplished by adding the destination to the logger.\n\nHere\'s an example of configuring the logger to output to the Apple System Log as well as a file.\n\n```Swift\n// Create a logger object with no destinations\nlet log = XCGLogger(identifier: "advancedLogger", includeDefaultDestinations: false)\n\n// Create a destination for the system console log (via NSLog)\nlet systemDestination = AppleSystemLogDestination(identifier: "advancedLogger.systemDestination")\n\n// Optionally set some configuration options\nsystemDestination.outputLevel = .debug\nsystemDestination.showLogIdentifier = false\nsystemDestination.showFunctionName = true\nsystemDestination.showThreadName = true\nsystemDestination.showLevel = true\nsystemDestination.showFileName = true\nsystemDestination.showLineNumber = true\nsystemDestination.showDate = true\n\n// Add the destination to the logger\nlog.add(destination: systemDestination)\n\n// Create a file log destination\nlet fileDestination = FileDestination(writeToFile: "/path/to/file", identifier: "advancedLogger.fileDestination")\n\n// Optionally set some configuration options\nfileDestination.outputLevel = .debug\nfileDestination.showLogIdentifier = false\nfileDestination.showFunctionName = true\nfileDestination.showThreadName = true\nfileDestination.showLevel = true\nfileDestination.showFileName = true\nfileDestination.showLineNumber = true\nfileDestination.showDate = true\n\n// Process this destination in the background\nfileDestination.logQueue = XCGLogger.logQueue\n\n// Add the destination to the logger\nlog.add(destination: fileDestination)\n\n// Add basic app info, version info etc, to the start of the logs\nlog.logAppDetails()\n```\n\nYou can configure each log destination with different options depending on your needs.\n\nAnother common usage pattern is to have multiple loggers, perhaps one for UI issues, one for networking, and another for data issues.\n\nEach log destination can have its own log level. As a convenience, you can set the log level on the log object itself and it will pass that level to each destination. Then set the destinations that need to be different.\n\n**Note**: A destination object can only be added to one logger object, adding it to a second will remove it from the first.\n\n### Initialization Using A Closure\n\nAlternatively you can use a closure to initialize your global variable, so that all initialization is done in one place\n```Swift\nlet log: XCGLogger = {\n    let log = XCGLogger(identifier: "advancedLogger", includeDefaultDestinations: false)\n\n\t// Customize as needed\n    \n    return log\n}()\n```\n\n**Note**: This creates the log object lazily, which means it\'s not created until it\'s actually needed. This delays the initial output of the app information details. Because of this, I recommend forcing the log object to be created at app launch by adding the line `let _ = log` at the top of your `didFinishLaunching` method if you don\'t already log something on app launch.\n\n### Log Anything\n\nYou can log strings:\n\n```Swift\nlog.debug("Hi there!")\n```\n\nor pretty much anything you want:\n\n```Swift\nlog.debug(true)\nlog.debug(CGPoint(x: 1.1, y: 2.2))\nlog.debug(MyEnum.Option)\nlog.debug((4, 2))\nlog.debug(["Device": "iPhone", "Version": 7])\n```\n\n### Filtering Log Messages\n\nNew to XCGLogger 4, you can now create filters to apply to your logger (or to specific destinations). Create and configure your filters (examples below), and then add them to the logger or destination objects by setting the optional `filters` property to an array containing the filters. Filters are applied in the order they exist in the array. During processing, each filter is asked if the log message should be excluded from the log. If any filter excludes the log message, it\'s excluded. Filters have no way to reverse the exclusion of another filter.\n\nIf a destination\'s `filters` property is `nil`, the log\'s `filters` property is used instead. To have one destination log everything, while having all other destinations filter something, add the filters to the log object and set the one destination\'s `filters` property to an empty array `[]`. \n\n**Note**: Unlike destinations, you can add the same filter object to multiple loggers and/or multiple destinations.\n\n#### Filter by Filename\n\nTo exclude all log messages from a specific file, create an exclusion filter like so:\n\n```Swift\nlog.filters = [FileNameFilter(excludeFrom: ["AppDelegate.swift"], excludePathWhenMatching: true)]\n```\n\n`excludeFrom:` takes an `Array<String>` or `Set<String>` so you can specify multiple files at the same time.\n\n`excludePathWhenMatching:` defaults to `true` so you can omit it unless you want to match path\'s as well.\n\nTo include log messages only for a specific set to files, create the filter using the `includeFrom:` initializer. It\'s also possible to just toggle the `inverse` property to flip the exclusion filter to an inclusion filter.\n\t\n#### Filter by Tag\n\nIn order to filter log messages by tag, you must of course be able to set a tag on the log messages. Each log message can now have additional, user defined data attached to them, to be used by filters (and/or formatters etc). This is handled with a `userInfo: Dictionary<String, Any>` object. The dictionary key should be a namespaced string to avoid collisions with future additions. Official keys will begin with `com.cerebralgardens.xcglogger`. The tag key can be accessed by `XCGLogger.Constants.userInfoKeyTags`. You definitely don\'t want to be typing that, so feel free to create a global shortcut: `let tags = XCGLogger.Constants.userInfoKeyTags`. Now you can easily tag your logs:\n\n```Swift\nlet sensitiveTag = "Sensitive"\nlog.debug("A tagged log message", userInfo: [tags: sensitiveTag])\n```\n\nThe value for tags can be an `Array<String>`, `Set<String>`, or just a `String`, depending on your needs. They\'ll all work the same way when filtered.\n\nDepending on your workflow and usage, you\'ll probably create faster methods to set up the `userInfo` dictionary. See [below](#mixing-and-matching) for other possible shortcuts.\n\nNow that you have your logs tagged, you can filter easily:\n\n```Swift\nlog.filters = [TagFilter(excludeFrom: [sensitiveTag])]\n```\n\nJust like the `FileNameFilter`, you can use `includeFrom:` or toggle `inverse` to include only log messages that have the specified tags.\n\n#### Filter by Developer\n\nFiltering by developer is exactly like filtering by tag, only using the `userInfo` key of `XCGLogger.Constants.userInfoKeyDevs`. In fact, both filters are subclasses of the `UserInfoFilter` class that you can use to create additional filters. See [Extending XCGLogger](#extending-xcglogger) below.\n\n#### Mixing and Matching\n\nIn large projects with multiple developers, you\'ll probably want to start tagging log messages, as well as indicate the developer that added the message.\n\nWhile extremely flexible, the `userInfo` dictionary can be a little cumbersome to use. There are a few possible methods you can use to simply things. I\'m still testing these out myself so they\'re not officially part of the library yet (I\'d love feedback or other suggestions).\n\nI have created some experimental code to help create the UserInfo dictionaries. (Include the optional `UserInfoHelpers` subspec if using CocoaPods). Check the iOS Demo app to see it in use.\n\nThere are two structs that conform to the `UserInfoTaggingProtocol` protocol. `Tag` and `Dev`.\n\nYou can create an extension on each of these that suit your project. For example:\n\n```Swift\nextension Tag {\n    static let sensitive = Tag("sensitive")\n    static let ui = Tag("ui")\n    static let data = Tag("data")\n}\n\nextension Dev {\n    static let dave = Dev("dave")\n    static let sabby = Dev("sabby")\n}\n```\n\nAlong with these types, there\'s an overloaded operator `|` that can be used to merge them together into a dictionary compatible with the `UserInfo:` parameter of the logging calls.\n\nThen you can log messages like this:\n\n```Swift\nlog.debug("A tagged log message", userInfo: Dev.dave | Tag.sensitive)\n```\n\nThere are some current issues I see with these `UserInfoHelpers`, which is why I\'ve made it optional/experimental for now. I\'d love to hear comments/suggestions for improvements.\n\n1. The overloaded operator `|` merges dictionaries so long as there are no `Set`s. If one of the dictionaries contains a `Set`, it\'ll use one of them, without merging them. Preferring the left hand side if both sides have a set for the same key.\n2. Since the `userInfo:` parameter needs a dictionary, you can\'t pass in a single Dev or Tag object. You need to use at least two with the `|` operator to have it automatically convert to a compatible dictionary. If you only want one Tag for example, you must access the `.dictionary` parameter manually: `userInfo: Tag("Blah").dictionary`.\n\n### Selectively Executing Code\n\nAll log methods operate on closures. Using the same syntactic sugar as Swift\'s `assert()` function, this approach ensures we don\'t waste resources building log messages that won\'t be output anyway, while at the same time preserving a clean call site.\n\nFor example, the following log statement won\'t waste resources if the debug log level is suppressed:\n\n```Swift\nlog.debug("The description of \\(thisObject) is really expensive to create")\n```\n\nSimilarly, let\'s say you have to iterate through a loop in order to do some calculation before logging the result. In Objective-C, you could put that code block between `#if` `#endif`, and prevent the code from running. But in Swift, previously you would need to still process that loop, wasting resources. With `XCGLogger` it\'s as simple as:\n\n```Swift\nlog.debug {\n    var total = 0.0\n    for receipt in receipts {\n        total += receipt.total\n    }\n\n    return "Total of all receipts: \\(total)"\n}\n```\n\nIn cases where you wish to selectively execute code without generating a log line, return `nil`, or use one of the methods: `verboseExec`, `debugExec`, `infoExec`, `warningExec`, `errorExec`, and `severeExec`.\n\n### Custom Date Formats\n\nYou can create your own `DateFormatter` object and assign it to the logger.\n\n```Swift\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = "MM/dd/yyyy hh:mma"\ndateFormatter.locale = Locale.current\nlog.dateFormatter = dateFormatter\n```\n\n### Enhancing Log Messages With Colour\n\nXCGLogger supports adding formatting codes to your log messages to enable colour in various places. The original option was to use the [XcodeColors plug-in][XcodeColors]. However, Xcode (as of version 8) no longer officially supports plug-ins. You can still view your logs in colour, just not in Xcode at the moment. You can use the ANSI colour support to add colour to your fileDestination objects and view your logs via a terminal window. This gives you some extra options such as adding Bold, Italics, or (please don\'t) Blinking!\n\nOnce enabled, each log level can have its own colour. These colours can be customized as desired. If using multiple loggers, you could alternatively set each logger to its own colour.\n\nAn example of setting up the ANSI formatter:\n\n```Swift\nif let fileDestination: FileDestination = log.destination(withIdentifier: XCGLogger.Constants.fileDestinationIdentifier) as? FileDestination {\n    let ansiColorLogFormatter: ANSIColorLogFormatter = ANSIColorLogFormatter()\n    ansiColorLogFormatter.colorize(level: .verbose, with: .colorIndex(number: 244), options: [.faint])\n    ansiColorLogFormatter.colorize(level: .debug, with: .black)\n    ansiColorLogFormatter.colorize(level: .info, with: .blue, options: [.underline])\n    ansiColorLogFormatter.colorize(level: .notice, with: .green, options: [.italic])\n    ansiColorLogFormatter.colorize(level: .warning, with: .red, options: [.faint])\n    ansiColorLogFormatter.colorize(level: .error, with: .red, options: [.bold])\n    ansiColorLogFormatter.colorize(level: .severe, with: .white, on: .red)\n    ansiColorLogFormatter.colorize(level: .alert, with: .white, on: .red, options: [.bold])\n    ansiColorLogFormatter.colorize(level: .emergency, with: .white, on: .red, options: [.bold, .blink])\n    fileDestination.formatters = [ansiColorLogFormatter]\n}\n```\n\nAs with filters, you can use the same formatter objects for multiple loggers and/or multiple destinations. If a destination\'s `formatters` property is `nil`, the logger\'s `formatters` property will be used instead.\n\nSee [Extending XCGLogger](#extending-xcglogger) below for info on creating your own custom formatters.\n\n### Alternate Configurations\n\nBy using Swift build flags, different log levels can be used in debugging versus staging/production.\nGo to Build Settings -> Swift Compiler - Custom Flags -> Other Swift Flags and add `-DDEBUG` to the Debug entry.\n\n```Swift\n#if DEBUG\n    log.setup(level: .debug, showThreadName: true, showLevel: true, showFileNames: true, showLineNumbers: true)\n#else\n    log.setup(level: .severe, showThreadName: true, showLevel: true, showFileNames: true, showLineNumbers: true)\n#endif\n```\n\nYou can set any number of options up in a similar fashion. See the updated iOSDemo app for an example of using different log destinations based on options, search for `USE_NSLOG`.\n\n### Background Log Processing\n\nBy default, the supplied log destinations will process the logs on the thread they\'re called on. This is to ensure the log message is displayed immediately when debugging an application. You can add a breakpoint immediately after a log call and see the results when the breakpoint hits.\n\nHowever, if you\'re not actively debugging the application, processing the logs on the current thread can introduce a performance hit. You can now specify a destination process its logs on a dispatch queue of your choice (or even use a default supplied one).\n\n```Swift\nfileDestination.logQueue = XCGLogger.logQueue\n```\t\n\nor even\n\n```Swift\nfileDestination.logQueue = DispatchQueue.global(qos: .background)\n```\n\nThis works extremely well when combined with the [Alternate Configurations](#alternate-configurations) method above.\n\n```Swift\n#if DEBUG\n    log.setup(level: .debug, showThreadName: true, showLevel: true, showFileNames: true, showLineNumbers: true)\n#else\n    log.setup(level: .severe, showThreadName: true, showLevel: true, showFileNames: true, showLineNumbers: true)\n    if let consoleLog = log.logDestination(XCGLogger.Constants.baseConsoleDestinationIdentifier) as? ConsoleDestination {\n        consoleLog.logQueue = XCGLogger.logQueue\n    }\n#endif\n```\n\n### Append To Existing Log File\n\nWhen using the advanced configuration of the logger (see [Advanced Usage above](#advanced-usage-recommended)), you can now specify that the logger append to an existing log file, instead of automatically overwriting it.\n\nAdd the optional `shouldAppend:` parameter when initializing the `FileDestination` object. You can also add the `appendMarker:` parameter to add a marker to the log file indicating where a new instance of your app started appending. By default we\'ll add `-- ** ** ** --` if the parameter is omitted. Set it to `nil` to skip appending the marker.\n\n```let fileDestination = FileDestination(writeToFile: "/path/to/file", identifier: "advancedLogger.fileDestination", shouldAppend: true, appendMarker: "-- Relauched App --")```\n\n\n### Automatic Log File Rotation\n\nWhen logging to a file, you have the option to automatically rotate the log file to an archived destination, and have the logger automatically create a new log file in place of the old one.\n\nCreate a destination using the `AutoRotatingFileDestination` class and set the following properties:\n\n`targetMaxFileSize`: Auto rotate once the file is larger than this\n\n`targetMaxTimeInterval`: Auto rotate after this many seconds\n\n`targetMaxLogFiles`: Number of archived log files to keep, older ones are automatically deleted\n\nThose are all guidelines for the logger, not hard limits.\n\n### Extending XCGLogger\n\nYou can create alternate log destinations (besides the built in ones). Your custom log destination must implement the `DestinationProtocol` protocol. Instantiate your object, configure it, and then add it to the `XCGLogger` object with `add(destination:)`. There are two base destination classes (`BaseDestination` and `BaseQueuedDestination`) you can inherit from to handle most of the process for you, requiring you to only implement one additional method in your custom class. Take a look at `ConsoleDestination` and `FileDestination` for examples.\n\nYou can also create custom filters or formatters. Take a look at the provided versions as a starting point. Note that filters and formatters have the ability to alter the log messages as they\'re processed. This means you can create a filter that strips passwords, highlights specific words, encrypts messages, etc.\n\n## Contributing\n\nXCGLogger is the best logger available for Swift because of the contributions from the community like you. There are many ways you can help continue to make it great.\n\n1. Star the project on [GitHub][github-xcglogger].\n2. Report issues/bugs you find.\n3. Suggest features.\n4. Submit pull requests.\n5. Download and install one of my apps: [https://www.cerebralgardens.com/apps/][cerebral-gardens-apps] Try my newest app: [All the Rings][all-the-rings].\n6. You can visit my [Patreon][patreon-davewoodx] and contribute financially.\n\n**Note**: when submitting a pull request, please use lots of small commits verses one huge commit. It makes it much easier to merge in when there are several pull requests that need to be combined for a new version.\n\n<!-- Removed these since plug-ins seem to be gone for good now\n## Third Party Tools That Work With XCGLogger\n\n**Note**: These plug-ins no longer \'officially\' work in Xcode. File a [bug report](https://openradar.appspot.com/27447585) if you\'d like to see plug-ins return to Xcode.\n\n[**XcodeColors:**][XcodeColors] Enable colour in the Xcode console\n<br />\n[**KZLinkedConsole:**][KZLinkedConsole] Link from a log line directly to the code that produced it\n\n**Note**: These may not yet work with the Swift 4 version of XCGLogger.\n\n[**XCGLoggerNSLoggerConnector:**][XCGLoggerNSLoggerConnector] Send your logs to [NSLogger][NSLogger]\n-->\n\n## To Do\n\n- Add more examples of some advanced use cases\n- Add additional log destination types\n- Add Objective-C support\n- Add Linux support\n\n## More\n\nIf you find this library helpful, you\'ll definitely find this other tool helpful:\n\nWatchdog: https://watchdogforxcode.com/\n\nAlso, please check out some of my other projects:\n\n- All the Rings: [App Store](https://itunes.apple.com/app/all-the-rings/id1186956966?pt=17255&ct=github&mt=8&at=11lMGu)\n- Rudoku: [App Store](https://itunes.apple.com/app/rudoku/id965105321?pt=17255&ct=github&mt=8&at=11lMGu)\n- TV Tune Up: https://www.cerebralgardens.com/tvtuneup\n\n### Change Log\n\nThe change log is now in its own file: [CHANGELOG.md](CHANGELOG.md)\n\n[xcglogger-logo]: https://github.com/DaveWoodCom/XCGLogger/raw/master/ReadMeImages/XCGLoggerLogo_326x150.png\n[swift.org]: https://swift.org/\n[license]: https://github.com/DaveWoodCom/XCGLogger/blob/master/LICENSE.txt\n[travis]: https://travis-ci.org/DaveWoodCom/XCGLogger\n[swiftpm]: https://swift.org/package-manager/\n[cocoapods]: https://cocoapods.org/\n[cocoapods-xcglogger]: https://cocoapods.org/pods/XCGLogger\n[carthage]: https://github.com/Carthage/Carthage\n[cerebral-gardens]: https://www.cerebralgardens.com/\n[cerebral-gardens-apps]: https://www.cerebralgardens.com/apps/\n[all-the-rings]: https://alltherings.fit/?s=GH3\n[mastodon-davewoodx]: https://mastodon.social/@davewoodx\n[twitter-davewoodx]: https://twitter.com/davewoodx\n[github-xcglogger]: https://github.com/DaveWoodCom/XCGLogger\n[stackoverflow]: https://stackoverflow.com/questions/tagged/xcglogger\n[patreon-davewoodx]: https://www.patreon.com/DaveWoodX\n\n[badge-language]: https://img.shields.io/badge/Swift-1.x%20%7C%202.x%20%7C%203.x%20%7C%204.x%20%7C%205.x-orange.svg?style=flat\n[badge-platforms]: https://img.shields.io/badge/Platforms-macOS%20%7C%20iOS%20%7C%20tvOS%20%7C%20watchOS-lightgray.svg?style=flat\n[badge-license]: https://img.shields.io/badge/License-MIT-lightgrey.svg?style=flat\n[badge-travis]: https://img.shields.io/travis/DaveWoodCom/XCGLogger/master.svg?style=flat\n[badge-swiftpm]: https://img.shields.io/badge/Swift_Package_Manager-v7.0.0-64a6dd.svg?style=flat\n[badge-cocoapods]: https://img.shields.io/cocoapods/v/XCGLogger.svg?style=flat\n[badge-carthage]: https://img.shields.io/badge/Carthage-v7.0.0-64a6dd.svg?style=flat\n\n[badge-sponsors]: https://img.shields.io/badge/Sponsors-Cerebral%20Gardens-orange.svg?style=flat\n[badge-mastodon]: https://img.shields.io/badge/Mastodon-DaveWoodX-606A84.svg?style=flat\n[badge-twitter]: https://img.shields.io/twitter/follow/DaveWoodX.svg?style=social\n[badge-patreon]: https://img.shields.io/badge/Patreon-DaveWoodX-F96854.svg?style=flat\n\n[XcodeColors]: https://github.com/robbiehanson/XcodeColors\n[KZLinkedConsole]: https://github.com/krzysztofzablocki/KZLinkedConsole\n[NSLogger]: https://github.com/fpillet/NSLogger\n[XCGLoggerNSLoggerConnector]: https://github.com/markuswinkler/XCGLoggerNSLoggerConnector\n[Firelog]: http://jogabo.github.io/firelog/\n[Firebase]: https://www.firebase.com/\n\n[xcglogger-7.0.0]: https://github.com/DaveWoodCom/XCGLogger/releases/tag/7.0.0\n[xcglogger-6.1.0]: https://github.com/DaveWoodCom/XCGLogger/releases/tag/6.1.0\n[xcglogger-6.0.4]: https://github.com/DaveWoodCom/XCGLogger/releases/tag/6.0.4\n[xcglogger-6.0.2]: https://github.com/DaveWoodCom/XCGLogger/releases/tag/6.0.2\n[xcglogger-5.0.5]: https://github.com/DaveWoodCom/XCGLogger/releases/tag/5.0.5\n[xcglogger-3.6.0]: https://github.com/DaveWoodCom/XCGLogger/releases/tag/3.6.0\n[xcglogger-3.5.3]: https://github.com/DaveWoodCom/XCGLogger/releases/tag/3.5.3\n[xcglogger-3.2]: https://github.com/DaveWoodCom/XCGLogger/releases/tag/3.2.0\n[xcglogger-2.x]: https://github.com/DaveWoodCom/XCGLogger/releases/tag/2.4.0\n[xcglogger-1.x]: https://github.com/DaveWoodCom/XCGLogger/releases/tag/1.8.1\n'