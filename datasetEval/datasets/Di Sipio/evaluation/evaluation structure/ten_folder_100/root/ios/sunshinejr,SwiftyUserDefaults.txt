b'# SwiftyUserDefaults\n\n![Platforms](https://img.shields.io/badge/platforms-ios%20%7C%20osx%20%7C%20watchos%20%7C%20tvos-lightgrey.svg)\n[![CI Status](https://api.travis-ci.org/sunshinejr/SwiftyUserDefaults.svg?branch=master)](https://travis-ci.org/sunshinejr/SwiftyUserDefaults)\n[![CocoaPods compatible](https://img.shields.io/badge/CocoaPods-compatible-4BC51D.svg?style=flat)](#cocoapods)\n[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](#carthage)\n[![SPM compatible](https://img.shields.io/badge/SPM-compatible-4BC51D.svg?style=flat)](#swift-package-manager)\n![Swift version](https://img.shields.io/badge/swift-4.1-orange.svg)\n![Swift version](https://img.shields.io/badge/swift-4.2-orange.svg)\n![Swift version](https://img.shields.io/badge/swift-5.0-orange.svg)\n![Swift version](https://img.shields.io/badge/swift-5.1-orange.svg)\n\n#### Modern Swift API for `NSUserDefaults`\n###### SwiftyUserDefaults makes user defaults enjoyable to use by combining expressive Swifty API with the benefits of static typing. Define your keys in one place, use value types easily, and get extra safety and convenient compile-time checks for free.\n\nPrevious versions\' documentation: [Version 4.0.0](https://github.com/sunshinejr/SwiftyUserDefaults/blob/566ace16ee91242b61e2e9da6cdbe7dfdadd926c/README.md), [Version 3.0.1](https://github.com/sunshinejr/SwiftyUserDefaults/blob/14b629b035bf6355b46ece22c3851068a488a895/README.md)<br />\nMigration guides: [from 4.x to 5.x](MigrationGuides/migration_4_to_5.md), [from 4.0.0-alpha.1 to 4.0.0-alpha.3](MigrationGuides/migration_4_alpha_1_to_4_alpha_2.md), [from 3.x to 4.x](MigrationGuides/migration_3_to_4.md)\n\n# Version 5.0.0-beta.5\n\n<p align="center">\n    <a href="#features">Features</a> &bull;\n    <a href="#usage">Usage</a> &bull;\n    <a href="#codable">Codable</a> &bull;\n    <a href="#nscoding">NSCoding</a> &bull;\n    <a href="#rawrepresentable">RawRepresentable</a> &bull;\n    <a href="#extending-existing-types">Extending existing types</a> &bull;\n    <a href="#custom-types">Custom types</a>\n</p>\n<p align="center">\n    <a href="#property-wrappers">Property wrappers</a> &bull;\n    <a href="#kvo">KVO</a> &bull;\n    <a href="#keypath-dynamicMemberLookup">dynamicMemberLookup</a> &bull;\n    <a href="#launch-arguments">Launch arguments</a> &bull;\n    <a href="#utils">Utils</a> &bull;\n    <a href="#installation">Installation</a>\n</p>\n\n## Features\n\n**There\'s only one step to start using SwiftyUserDefaults:**\n\nDefine your keys!\n\n```swift\nextension DefaultsKeys {\n    var username: DefaultsKey<String?> { return .init("username") }\n    var launchCount: DefaultsKey<Int> { return .init("launchCount", defaultValue: 0) }\n}\n```\n\nAnd just use it ;-)\n\n```swift\n// Get and set user defaults easily\nlet username = Defaults[\\.username]\nDefaults[\\.hotkeyEnabled] = true\n\n// Modify value types in place\nDefaults[\\.launchCount] += 1\nDefaults[\\.volume] -= 0.1\nDefaults[\\.strings] += "\xe2\x80\xa6 can easily be extended!"\n\n// Use and modify typed arrays\nDefaults[\\.libraries].append("SwiftyUserDefaults")\nDefaults[\\.libraries][0] += " 2.0"\n\n// Easily work with custom serialized types\nDefaults[\\.color] = NSColor.white\nDefaults[\\.color]?.whiteComponent // => 1.0\n```\n\nIf you use Swift 5.1 - good news! You can also use keyPath `dynamicMemberLookup`:\n```swift\nDefaults.color = NSColor.white\n```\n\nSee more at the <a href="#keypath-dynamicMemberLookup">KeyPath dynamicMemberLookup</a> section.\n\n## Usage\n\n### Define your keys\n\nTo get the most out of SwiftyUserDefaults, define your user defaults keys ahead of time:\n\n```swift\nlet colorKey = DefaultsKey<String>("color", defaultValue: "")\n```\n\nJust create a `DefaultsKey` object, put the type of the value you want to store in angle brackets, the key name in parentheses, and you\'re good to go. If you want to have a non-optional value, just provide a `defaultValue` in the key (look at the example above).\n\nYou can now use the `Defaults` shortcut to access those values:\n\n```swift\nDefaults[key: colorKey] = "red"\nDefaults[key: colorKey] // => "red", typed as String\n```\n\nThe compiler won\'t let you set a wrong value type, and fetching conveniently returns `String`.\n\n### Take shortcuts\n\nFor extra convenience, define your keys by extending magic `DefaultsKeys` class and adding static properties:\n\n```swift\nextension DefaultsKeys {\n    var username: DefaultsKey<String?> { return .init("username") }\n    var launchCount: DefaultsKey<Int> { return .init("launchCount", defaultValue: 0) }\n}\n```\n\nAnd use the shortcut dot syntax:\n\n```swift\nDefaults[\\.username] = "joe"\nDefaults[\\.launchCount] += 1\n```\n\n### Supported types\n\nSwiftyUserDefaults supports all of the standard `NSUserDefaults` types, like strings, numbers, booleans, arrays and dictionaries.\n\nHere\'s a full table of built-in single value defaults:\n\n| Single value     | Array                |\n| ---------------- | -------------------- |\n| `String`         | `[String]`           |\n| `Int`            | `[Int]`              |\n| `Double`         | `[Double]`           |\n| `Bool`           | `[Bool]`             |\n| `Data`           | `[Data]`             |\n| `Date`           | `[Date]`             |\n| `URL`            | `[URL]`              |\n| `[String: Any]`  | `[[String: Any]]`    |\n\nBut that\'s not all!\n\n## Codable\n\nSince version 4, `SwiftyUserDefaults` support `Codable`! Just conform to `DefaultsSerializable` in your type:\n```swift\nfinal class FrogCodable: Codable, DefaultsSerializable {\n    let name: String\n }\n```\n\nNo implementation needed! By doing this you will get an option to specify an optional `DefaultsKey`:\n```swift\nlet frog = DefaultsKey<FrogCodable?>("frog")\n```\n\nAdditionally, you\'ve got an array support for free:\n```swift\nlet froggies = DefaultsKey<[FrogCodable]?>("froggies")\n```\n\n## NSCoding\n\n`NSCoding` was supported before version 4, but in this version we take the support on another level. No need for custom subscripts anymore!\nSupport your custom `NSCoding` type the same way as with `Codable` support:\n```\nfinal class FrogSerializable: NSObject, NSCoding, DefaultsSerializable { ... }\n```\n\nNo implementation needed as well! By doing this you will get an option to specify an optional `DefaultsKey`:\n```swift\nlet frog = DefaultsKey<FrogSerializable?>("frog")\n```\n\nAdditionally, you\'ve got an array support also for free:\n```swift\nlet froggies = DefaultsKey<[FrogSerializable]?>("froggies")\n```\n\n## RawRepresentable\n\nAnd the last but not least, `RawRepresentable` support! Again, the same situation like with `NSCoding` and `Codable`:\n```swift\nenum BestFroggiesEnum: String, DefaultsSerializable {\n    case Andy\n    case Dandy\n}\n```\n\nNo implementation needed as well! By doing this you will get an option to specify an optional `DefaultsKey`:\n```swift\nlet frog = DefaultsKey<BestFroggiesEnum?>("frog")\n```\n\nAdditionally, you\'ve got an array support also for free:\n```swift\nlet froggies = DefaultsKey<[BestFroggiesEnum]?>("froggies")\n```\n\n## Extending existing types\n\nLet\'s say you want to extend a support `UIColor` or any other type that is `NSCoding`, `Codable` or `RawRepresentable`.\nExtending it to be `SwiftyUserDefaults`-friendly should be as easy as:\n```swift\nextension UIColor: DefaultsSerializable {}\n```\n\nIf it\'s not, we have two options:<br />\na) It\'s a custom type that we don\'t know how to serialize, in this case at [Custom types](#custom-types)<br />\nb) It\'s a bug and it should be supported, in this case please file an issue (+ you can use [custom types](#custom-types) method as a workaround in the meantime)<br />\n\n## Custom types\n\nIf you want to add your own custom type that we don\'t support yet, we\'ve got you covered. We use `DefaultsBridge`s of many kinds to specify how you get/set values and arrays of values. When you look at `DefaultsSerializable` protocol, it expects two properties in each type: `_defaults` and `_defaultsArray`, where both are of type `DefaultsBridge`.\n\nFor instance, this is a bridge for single value data storing/retrieving using `NSKeyedArchiver`/`NSKeyedUnarchiver`:\n```swift\npublic struct DefaultsKeyedArchiverBridge<T>: DefaultsBridge {\n\n    public func get(key: String, userDefaults: UserDefaults) -> T? {\n        return userDefaults.data(forKey: key).flatMap(NSKeyedUnarchiver.unarchiveObject) as? T\n    }\n\n    public func save(key: String, value: T?, userDefaults: UserDefaults) {\n        userDefaults.set(NSKeyedArchiver.archivedData(withRootObject: value), forKey: key)\n    }\n\n    public func deserialize(_ object: Any) -> T? {\n        guard let data = object as? Data else { return nil }\n        return NSKeyedUnarchiver.unarchiveObject(with: data) as? T\n    }    \n}\n```\n\nBridge for default storing/retrieving array values:\n```swift\npublic struct DefaultsArrayBridge<T: Collection>: DefaultsBridge {\n    public func save(key: String, value: T?, userDefaults: UserDefaults) {\n        userDefaults.set(value, forKey: key)\n    }\n\n    public func get(key: String, userDefaults: UserDefaults) -> T? {\n        return userDefaults.array(forKey: key) as? T\n    }\n\n    public func deserialize(_ object: Any) -> T? {\n        return nil\n    }\n}\n```\n\nNow, to use these bridges in our type we simply declare it as follows:\n```swift\nstruct FrogCustomSerializable: DefaultsSerializable {\n\n    static var _defaults: DefaultsBridge<FrogCustomSerializable> { return DefaultsKeyedArchiverBridge() }\n    static var _defaultsArray: DefaultsBridge<[FrogCustomSerializable]> { return DefaultsKeyedArchiverBridge() }\n\n    let name: String\n}\n```\n\nUnfortunately, if you find yourself in a situation where you need a custom bridge, you\'ll probably need to write your own:\n```swift\nfinal class DefaultsFrogBridge: DefaultsBridge {\n    func get(key: String, userDefaults: UserDefaults) -> FrogCustomSerializable? {\n        let name = userDefaults.string(forKey: key)\n        return name.map(FrogCustomSerializable.init)\n    }\n\n    func save(key: String, value: FrogCustomSerializable?, userDefaults: UserDefaults) {\n        userDefaults.set(value?.name, forKey: key)\n    }\n\n    func deserialize(_ object: Any) -> FrogCustomSerializable? {\n        guard let name = object as? String else { return nil }\n\n        return FrogCustomSerializable(name: name)\n    }\n}\n\nfinal class DefaultsFrogArrayBridge: DefaultsBridge {\n    func get(key: String, userDefaults: UserDefaults) -> [FrogCustomSerializable]? {\n        return userDefaults.array(forKey: key)?\n            .compactMap { $0 as? String }\n            .map(FrogCustomSerializable.init)\n    }\n\n    func save(key: String, value: [FrogCustomSerializable]?, userDefaults: UserDefaults) {\n        let values = value?.map { $0.name }\n        userDefaults.set(values, forKey: key)\n    }\n\n    func deserialize(_ object: Any) -> [FrogCustomSerializable]? {\n        guard let names = object as? [String] else { return nil }\n\n        return names.map(FrogCustomSerializable.init)\n    }\n}\n\nstruct FrogCustomSerializable: DefaultsSerializable, Equatable {\n\n    static var _defaults: DefaultsFrogBridge { return DefaultsFrogBridge() }\n    static var _defaultsArray: DefaultsFrogArrayBridge { return DefaultsFrogArrayBridge() }\n\n    let name: String\n}\n```\n\nTo support existing types with different bridges, you can extend it similarly:\n```swift\nextension Data: DefaultsSerializable {\n    public static var _defaultsArray: DefaultsArrayBridge<[T]> { return DefaultsArrayBridge() }\n    public static var _defaults: DefaultsDataBridge { return DefaultsDataBridge() }\n}\n```\n\nAlso, take a look at our source code (or tests) to see more examples of bridges. If you find yourself confused with all these bridges, please [create an issue](https://github.com/sunshinejr/SwiftyUserDefaults/issues/new) and we will figure something out.\n\n## Property wrappers\n\nSwiftyUserDefaults provides property wrappers for Swift 5.1! The property wrapper, `@SwiftyUserDefault`, provides an option to use it with key path and options: caching or observing.\n\n*Caching* means that we will store the value for you and do not hit the `UserDefaults` for value almost never, only for the first value fetch.\n\n*Observing* means we will observe, via KVO, your property so you don\'t have to worry if it was saved somewhere else and you use caching.\n\nNow usage! Given keys:\n```swift\nextension DefaultsKeys {\n    var userColorScheme: DefaultsKey<String> { .init("userColorScheme", defaultValue: "default") }\n    var userThemeName: DefaultsKey<String?> { .init("userThemeName") }\n    var userLastLoginDate: DefaultsKey<Date?> { .init("userLastLoginDate") }\n}\n```\n\nYou can declare a `Test` struct:\n```swift\nstruct Settings {\n    @SwiftyUserDefault(keyPath: \\.userColorScheme)\n    var userColorScheme: String\n\n    @SwiftyUserDefault(keyPath: \\.userThemeName, options: .cached)\n    var userThemeName: String?\n\n    @SwiftyUserDefault(keyPath: \\.userLastLoginDate, options: [.cached, .observed])\n    var userLastLoginDate: Date?\n}\n```\n\n## KVO\n\nKVO is supported for all the types that are `DefaultsSerializable`. However, if you have a custom type, it needs to have correctly defined bridges and serialization in them.\n\nTo observe a value:\n```swift\nlet nameKey = DefaultsKey<String>("name", defaultValue: "")\nDefaults.observe(key: nameKey) { update in\n\t// here you can access `oldValue`/`newValue` and few other properties\n}\n```\n\nBy default we are using `[.old, .new]` options for observing, but you can provide your own:\n```swift\nDefaults.observe(key: nameKey, options: [.initial, .old, .new]) { _ in }\n```\n\n## KeyPath dynamicMemberLookup\n\nSwiftyUserDefaults makes KeyPath dynamicMemberLookup usable in Swift 5.1!\n\n```swift\nextension DefaultsKeys {\n    var username: DefaultsKey<String?> { return .init("username") }\n    var launchCount: DefaultsKey<Int> { return .init("launchCount", defaultValue: 0) }\n}\n```\n\nAnd just use it ;-)\n\n```swift\n// Get and set user defaults easily\nlet username = Defaults.username\nDefaults.hotkeyEnabled = true\n\n// Modify value types in place\nDefaults.launchCount += 1\nDefaults.volume -= 0.1\nDefaults.strings += "\xe2\x80\xa6 can easily be extended!"\n\n// Use and modify typed arrays\nDefaults.libraries.append("SwiftyUserDefaults")\nDefaults.libraries[0] += " 2.0"\n\n// Easily work with custom serialized types\nDefaults.color = NSColor.white\nDefaults.color?.whiteComponent // => 1.0\n```\n\n## Launch arguments\n\nDo you like to customize your app/script/tests by UserDefaults? Now it\'s fully supported on our side, statically typed of course.\n\n_Note: for now we support only `Bool`, `Double`, `Int`, `String` values, but if you have any other requests for that feature, please open an issue or PR and we can talk about implementing it in new versions._\n\n### You can pass your arguments in your schema:\n<img src="https://i.imgur.com/SDpOBpK.png" alt="Pass launch arguments in Xcode Schema editor." />\n\n### Or you can use launch arguments in XCUIApplication:\n```swift\nfunc testExample() {\n    let app = XCUIApplication()\n    app.launchArguments = ["-skipLogin", "true", "-loginTries", "3", "-lastGameTime", "61.3", "-nickname", "sunshinejr"]\n    app.launch()\n}\n```\n### Or pass them as command line arguments!\n```bash\n./script -skipLogin true -loginTries 3 -lastGameTime 61.3 -nickname sunshinejr\n```\n\n## Utils\n\n### Remove all keys\n\nTo reset user defaults, use `removeAll` method.\n\n```swift\nDefaults.removeAll()\n```\n\n### Shared user defaults\n\nIf you\'re sharing your user defaults between different apps or an app and its extensions, you can use SwiftyUserDefaults by overriding the `Defaults` shortcut with your own. Just add in your app:\n\n```swift\nvar Defaults = DefaultsAdapter<DefaultsKeys>(defaults: UserDefaults(suiteName: "com.my.app")!, keyStore: .init())\n```\n\n### Check key\n\nIf you want to check if we\'ve got a value for `DefaultsKey`:\n```swift\nlet hasKey = Defaults.hasKey(\\.skipLogin)\n```\n\n## Installation\n\n### Requirements\n**Swift** version **>= 4.1**<br />\n**iOS** version **>= 8.0**<br />\n**macOS** version **>= 10.11**<br />\n**tvOS** version **>= 9.0**<br />\n**watchOS** version **>= 2.0**\n\n### CocoaPods\n\nIf you\'re using CocoaPods, just add this line to your Podfile:\n\n```ruby\npod \'SwiftyUserDefaults\', \'5.0.0-beta.5\'\n```\n\nInstall by running this command in your terminal:\n\n```sh\npod install\n```\n\nThen import the library in all files where you use it:\n\n```swift\nimport SwiftyUserDefaults\n```\n\n### Carthage\n\nJust add to your Cartfile:\n\n```ruby\ngithub "sunshinejr/SwiftyUserDefaults" "5.0.0-beta.5"\n```\n\n### Swift Package Manager\n\nJust add to your `Package.swift` under dependencies:\n```swift\nlet package = Package(\n    name: "MyPackage",\n    products: [...],\n    dependencies: [\n        .package(url: "https://github.com/sunshinejr/SwiftyUserDefaults.git", .exact("5.0.0-beta.5"),\n    ],\n    targets: [...]\n)\n```\n\n## More like this\n\nIf you like SwiftyUserDefaults, check out [SwiftyTimer](https://github.com/radex/SwiftyTimer), which applies the same swifty approach to `NSTimer`.\n\nYou might also be interested in my blog posts which explain the design process behind those libraries:\n- [Swifty APIs: NSUserDefaults](http://radex.io/swift/nsuserdefaults/)\n- [Statically-typed NSUserDefaults](http://radex.io/swift/nsuserdefaults/static)\n- [Swifty APIs: NSTimer](http://radex.io/swift/nstimer/)\n- [Swifty methods](http://radex.io/swift/methods/)\n\n## Contributing\n\nIf you have comments, complaints or ideas for improvements, feel free to open an issue or a pull request.\n\n## Authors and license\n\n*Maintainer:* \xc5\x81ukasz Mr\xc3\xb3z\n* [github.com/sunshinejr](http://github.com/sunshinejr)\n* [twitter.com/thesunshinejr](http://twitter.com/thesunshinejr)\n* [sunshinejr.com](https://sunshinejr.com)\n\n*Created by:* Radek Pietruszewski\n\n* [github.com/radex](http://github.com/radex)\n* [twitter.com/radexp](http://twitter.com/radexp)\n* [radex.io](http://radex.io)\n* this.is@radex.io\n\nSwiftyUserDefaults is available under the MIT license. See the LICENSE file for more info.\n'