b'![](https://github.com/bizz84/SwiftyStoreKit/raw/master/SwiftyStoreKit-logo.png)\n\n[![License](https://img.shields.io/badge/license-MIT-blue.svg?style=flat)](http://mit-license.org)\n[![Platform](http://img.shields.io/badge/platform-ios%20%7C%20macos%20%7C%20tvos-lightgrey.svg?style=flat)](https://developer.apple.com/resources/)\n[![Language](https://img.shields.io/badge/swift-5.0-orange.svg)](https://developer.apple.com/swift)\n[![Build](https://img.shields.io/travis/bizz84/SwiftyStoreKit.svg?style=flat)](https://travis-ci.org/bizz84/SwiftyStoreKit)\n[![Issues](https://img.shields.io/github/issues/bizz84/SwiftyStoreKit.svg?style=flat)](https://github.com/bizz84/SwiftyStoreKit/issues)\n[![Slack](https://img.shields.io/badge/Slack-Join-green.svg?style=flat)](https://join.slack.com/t/swiftystorekit/shared_invite/enQtNjkzNTg5NTMyMTgwLTcyZGIzMTg0MWFmMTQyMDYxNDcyYWNhOTlmNjUyM2E0OTllNjE2ZDJiNDI0ZDAzMWU2Mzc3Nzk1YzJmMTE2NjI)\n[![Cocoapod](http://img.shields.io/cocoapods/v/SwiftyStoreKit.svg?style=flat)](http://cocoadocs.org/docsets/SwiftyStoreKit/)\n[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)\n[![Accio supported](https://img.shields.io/badge/Accio-supported-0A7CF5.svg?style=flat)](https://github.com/JamitLabs/Accio)\n[![Twitter](https://img.shields.io/badge/twitter-@biz84-blue.svg?maxAge=2592000)](http://twitter.com/biz84)\n\nSwiftyStoreKit is a lightweight In App Purchases framework for iOS 8.0+, tvOS 9.0+ and macOS 10.10+.\n\n### Preview\n\n<img src="https://github.com/bizz84/SwiftyStoreKit/raw/master/Screenshots/Preview.jpg" width="320">\n\n### Join on Slack \n\nSwiftyStoreKit is on Slack. [Join here](https://join.slack.com/t/swiftystorekit/shared_invite/enQtNjkzNTg5NTMyMTgwLTcyZGIzMTg0MWFmMTQyMDYxNDcyYWNhOTlmNjUyM2E0OTllNjE2ZDJiNDI0ZDAzMWU2Mzc3Nzk1YzJmMTE2NjI).\n\n### Maintainers Wanted\n\n- The author no longer maintaining this project actively. If you\'d like to become a maintainer, [join the Slack workspace](https://join.slack.com/t/swiftystorekit/shared_invite/enQtNjkzNTg5NTMyMTgwLTcyZGIzMTg0MWFmMTQyMDYxNDcyYWNhOTlmNjUyM2E0OTllNjE2ZDJiNDI0ZDAzMWU2Mzc3Nzk1YzJmMTE2NjI\n) and enter the [#maintainers](https://app.slack.com/client/TL2JYQ458/CLG62K26A/details/) channel.\n- Going forward, SwiftyStoreKit should be made for the community, by the community. \n\nMore info here:\n\n- [The Future of SwiftyStoreKit: Maintainers Wanted](https://medium.com/@biz84/the-future-of-swiftystorekit-maintainers-needed-f60d01572c91)\n\n## Content\n\n- [Installation](#installation)\n\t- [CocoaPods](#cocoapods)\n\t- [Carthage](#carthage)\n- [Features](#features)\n- [Contributing](#contributing)\n- [App startup](#app-startup)\n\t- [Complete Transactions](#complete-transactions)\n- [Purchases](#purchases)\n\t- [Retrieve products info](#retrieve-products-info)\n\t- [Purchase a product (given a product id)](#purchase-a-product-given-a-product-id)\n\t- [Purchase a product (given a SKProduct)](#purchase-a-product-given-a-skproduct)\n\t- [Handle purchases started on the App Store (iOS 11)](#handle-purchases-started-on-the-app-store-ios-11)\n\t- [Restore previous purchases](#restore-previous-purchases)\n\t- [Downloading content hosted with Apple](#downloading-content-hosted-with-apple)\n- [Receipt verification](#receipt-verification)\n\t- [Retrieve local receipt (encrypted)](#retrieve-local-receipt-encrypted)\n\t- [Fetch receipt (encrypted)](#fetch-receipt-encrypted)\n\t- [Verify Receipt](#verify-receipt)\n- [Verifying purchases and subscriptions](#verifying-purchases-and-subscriptions)\n\t- [Verify Purchase](#verify-purchase)\n\t- [Verify Subscription](#verify-subscription)\n\t- [Subscription Groups](#subscription-groups)\n- [Notes](#notes)\n- [Change Log](#change-log)\n- [Sample Code](#sample-code)\n- [Essential Reading](#essential-reading)\n\t- [Troubleshooting](#troubleshooting)\n- [Video Tutorials](#video-tutorials)\n- [Payment flows: implementation details](#payment-flows-implementation-details)\n- [Credits](#credits)\n- [Apps using SwiftyStoreKit](#apps-using-swiftystorekit)\n- [License](#license)\n\t\n## Installation\n\n### CocoaPods\n\nSwiftyStoreKit can be installed as a [CocoaPod](https://cocoapods.org/) and builds as a Swift framework. To install, include this in your Podfile.\n\n```ruby\nuse_frameworks!\n\npod \'SwiftyStoreKit\'\n```\nOnce installed, just ```import SwiftyStoreKit``` in your classes and you\'re good to go.\n\n### Carthage\n\nTo integrate SwiftyStoreKit into your Xcode project using [Carthage](https://github.com/Carthage/Carthage), specify it in your Cartfile:\n\n```ogdl\ngithub "bizz84/SwiftyStoreKit"\n```\n\n**NOTE**: Please ensure that you have the [latest](https://github.com/Carthage/Carthage/releases) Carthage installed.\n\n### Swift Package Manager\n\nYou can add SwiftyStoreKit as an SPM dependency using this URL: `https://github.com/bizz84/SwiftyStoreKit.git`.\n\nIf you are using Xcode 11 or later, click `File`, `Swift Packages`, `Add Package Dependency...` and specify the URL there.\n\n## Features\n\n- Super easy to use block based API\n- Support for consumable, non-consumable in-app purchases\n- Support for free, auto-renewable and non-renewing subscriptions\n- Support for in-app purchases started in the App Store (iOS 11)\n- Remote receipt verification\n- Verify purchases, subscriptions, subscription groups\n- Downloading content hosted with Apple\n- iOS, tvOS and macOS compatible\n\n## Contributing\n\n#### Got issues / pull requests / want to contribute? [Read here](CONTRIBUTING.md).\n\n\n## App startup\n\n### Complete Transactions\n\nApple recommends to register a transaction observer [as soon as the app starts](https://developer.apple.com/library/ios/technotes/tn2387/_index.html):\n> Adding your app\'s observer at launch ensures that it will persist during all launches of your app, thus allowing your app to receive all the payment queue notifications.\n\nSwiftyStoreKit supports this by calling `completeTransactions()` when the app starts:\n\n```swift\nfunc application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {\n\t// see notes below for the meaning of Atomic / Non-Atomic\n\tSwiftyStoreKit.completeTransactions(atomically: true) { purchases in\n\t    for purchase in purchases {\n\t        switch purchase.transaction.transactionState {\n\t        case .purchased, .restored:\n\t            if purchase.needsFinishTransaction {\n\t                // Deliver content from server, then:\n\t                SwiftyStoreKit.finishTransaction(purchase.transaction)\n\t            }\n\t            // Unlock content\n\t        case .failed, .purchasing, .deferred:\n\t            break // do nothing\n\t        }\n\t    }\n\t}\n    return true\n}\n```\n\nIf there are any pending transactions at this point, these will be reported by the completion block so that the app state and UI can be updated.\n\nIf there are no pending transactions, the completion block will **not** be called.\n\nNote that `completeTransactions()` **should only be called once** in your code, in `application(:didFinishLaunchingWithOptions:)`.\n\n## Purchases\n\n### Retrieve products info\n```swift\nSwiftyStoreKit.retrieveProductsInfo(["com.musevisions.SwiftyStoreKit.Purchase1"]) { result in\n    if let product = result.retrievedProducts.first {\n        let priceString = product.localizedPrice!\n        print("Product: \\(product.localizedDescription), price: \\(priceString)")\n    }\n    else if let invalidProductId = result.invalidProductIDs.first {\n        print("Invalid product identifier: \\(invalidProductId)")\n    }\n    else {\n        print("Error: \\(result.error)")\n    }\n}\n```\n\n### Purchase a product (given a product id)\n\n* **Atomic**: to be used when the content is delivered immediately.\n\n```swift\nSwiftyStoreKit.purchaseProduct("com.musevisions.SwiftyStoreKit.Purchase1", quantity: 1, atomically: true) { result in\n    switch result {\n    case .success(let purchase):\n        print("Purchase Success: \\(purchase.productId)")\n    case .error(let error):\n        switch error.code {\n        case .unknown: print("Unknown error. Please contact support")\n        case .clientInvalid: print("Not allowed to make the payment")\n        case .paymentCancelled: break\n        case .paymentInvalid: print("The purchase identifier was invalid")\n        case .paymentNotAllowed: print("The device is not allowed to make the payment")\n        case .storeProductNotAvailable: print("The product is not available in the current storefront")\n        case .cloudServicePermissionDenied: print("Access to cloud service information is not allowed")\n        case .cloudServiceNetworkConnectionFailed: print("Could not connect to the network")\n        case .cloudServiceRevoked: print("User has revoked permission to use this cloud service")\n        default: print((error as NSError).localizedDescription)\n        }\n    }\n}\n```\n\n* **Non-Atomic**: to be used when the content is delivered by the server.\n\n```swift\nSwiftyStoreKit.purchaseProduct("com.musevisions.SwiftyStoreKit.Purchase1", quantity: 1, atomically: false) { result in\n    switch result {\n    case .success(let product):\n        // fetch content from your server, then:\n        if product.needsFinishTransaction {\n            SwiftyStoreKit.finishTransaction(product.transaction)\n        }\n        print("Purchase Success: \\(product.productId)")\n    case .error(let error):\n        switch error.code {\n        case .unknown: print("Unknown error. Please contact support")\n        case .clientInvalid: print("Not allowed to make the payment")\n        case .paymentCancelled: break\n        case .paymentInvalid: print("The purchase identifier was invalid")\n        case .paymentNotAllowed: print("The device is not allowed to make the payment")\n        case .storeProductNotAvailable: print("The product is not available in the current storefront")\n        case .cloudServicePermissionDenied: print("Access to cloud service information is not allowed")\n        case .cloudServiceNetworkConnectionFailed: print("Could not connect to the network")\n        case .cloudServiceRevoked: print("User has revoked permission to use this cloud service")\n        default: print((error as NSError).localizedDescription)\n        }\n    }\n}\n```\n\n### Purchase a product (given a SKProduct)\n\nThis is a variant of the method above that can be used to purchase a product when the corresponding `SKProduct` has already been retrieved with `retrieveProductsInfo`: \n\n```swift\nSwiftyStoreKit.retrieveProductsInfo(["com.musevisions.SwiftyStoreKit.Purchase1"]) { result in\n    if let product = result.retrievedProducts.first {\n        SwiftyStoreKit.purchaseProduct(product, quantity: 1, atomically: true) { result in\n            // handle result (same as above)\n        }\n    }\n}\n```\n\nUsing this `purchaseProduct` method guarantees that only one network call is made to StoreKit to perform the purchase, as opposed to one call to get the product and another to perform the purchase.\n\n### Handle purchases started on the App Store (iOS 11)\n\niOS 11 adds a new delegate method on `SKPaymentTransactionObserver`:\n\n```swift\n@available(iOS 11.0, *)\noptional public func paymentQueue(_ queue: SKPaymentQueue, shouldAddStorePayment payment: SKPayment, for product: SKProduct) -> Bool\n```\n\nFrom [Apple Docs](https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/2877502-paymentqueue):\n\n> This delegate method is called when the user has started an in-app purchase in the App Store, and is continuing the transaction in your app. Specifically, if your app is already installed, the method is called automatically.\nIf your app is not yet installed when the user starts the in-app purchase in the App Store, the user gets a notification when the app installation is complete. This method is called when the user taps the notification. Otherwise, if the user opens the app manually, this method is called only if the app is opened soon after the purchase was started.\n\nSwiftyStoreKit supports this with a new handler, called like this:\n\n```swift\nSwiftyStoreKit.shouldAddStorePaymentHandler = { payment, product in\n    // return true if the content can be delivered by your app\n    // return false otherwise\n}\n```\n\nTo test this in sandbox mode, open this URL in Safari:\n\n```\nitms-services://?action=purchaseIntent&bundleId=com.example.app&productIdentifier=product_name\n```\n\nMore information on the [WWDC17 session What\'s New in StoreKit](https://developer.apple.com/videos/play/wwdc2017/303)\n([slide number 165](https://devstreaming-cdn.apple.com/videos/wwdc/2017/303f0u5froddl13/303/303_whats_new_in_storekit.pdf) shows the link above).\n\n### Restore previous purchases\n\nAccording to [Apple - Restoring Purchased Products](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Chapters/Restoring.html#//apple_ref/doc/uid/TP40008267-CH8-SW9):\n\n> In most cases, all your app needs to do is refresh its receipt and deliver the products in its receipt. The refreshed receipt contains a record of the user\xe2\x80\x99s purchases in this app, on this device or any other device.\n\n> Restoring completed transactions creates a new transaction for every completed transaction the user made, essentially replaying history for your transaction queue observer.\n\nSee the **Receipt Verification** section below for how to restore previous purchases using the receipt.\n\nThis section shows how to restore completed transactions with the `restorePurchases` method instead. When successful, the method returns all non-consumable purchases, as well as all auto-renewable subscription purchases, **regardless of whether they are expired or not**.\n\n* **Atomic**: to be used when the content is delivered immediately.\n\n```swift\nSwiftyStoreKit.restorePurchases(atomically: true) { results in\n    if results.restoreFailedPurchases.count > 0 {\n        print("Restore Failed: \\(results.restoreFailedPurchases)")\n    }\n    else if results.restoredPurchases.count > 0 {\n        print("Restore Success: \\(results.restoredPurchases)")\n    }\n    else {\n        print("Nothing to Restore")\n    }\n}\n```\n\n* **Non-Atomic**: to be used when the content is delivered by the server.\n\n```swift\nSwiftyStoreKit.restorePurchases(atomically: false) { results in\n    if results.restoreFailedPurchases.count > 0 {\n        print("Restore Failed: \\(results.restoreFailedPurchases)")\n    }\n    else if results.restoredPurchases.count > 0 {\n        for purchase in results.restoredPurchases {\n            // fetch content from your server, then:\n            if purchase.needsFinishTransaction {\n                SwiftyStoreKit.finishTransaction(purchase.transaction)\n            }\n        }\n        print("Restore Success: \\(results.restoredPurchases)")\n    }\n    else {\n        print("Nothing to Restore")\n    }\n}\n```\n\n#### What does atomic / non-atomic mean?\n\nWhen you purchase a product the following things happen:\n\n* A payment is added to the payment queue for your IAP.\n* When the payment has been processed with Apple, the payment queue is updated so that the appropriate transaction can be handled.\n* If the transaction state is **purchased** or **restored**, the app can unlock the functionality purchased by the user.\n* The app should call `finishTransaction(_:)` to complete the purchase.\n\nThis is what is [recommended by Apple](https://developer.apple.com/reference/storekit/skpaymentqueue/1506003-finishtransaction):\n\n> Your application should call `finishTransaction(_:)` only after it has successfully processed the transaction and unlocked the functionality purchased by the user.\n\n* A purchase is **atomic** when the app unlocks the functionality purchased by the user immediately and call `finishTransaction(_:)` at the same time. This is desirable if you\'re unlocking functionality that is already inside the app.\n\n* In cases when you need to make a request to your own server in order to unlock the functionality, you can use a **non-atomic** purchase instead.\n\n* **Note**: SwiftyStoreKit doesn\'t yet support downloading content hosted by Apple for non-consumable products. See [this feature request](https://github.com/bizz84/SwiftyStoreKit/issues/128).\n\nSwiftyStoreKit provides three operations that can be performed **atomically** or **non-atomically**:\n\n* Making a purchase\n* Restoring purchases\n* Completing transactions on app launch\n\n### Downloading content hosted with Apple\n\nQuoting Apple Docs:\n\n> When you create a product in iTunes Connect, you can associate one or more pieces of downloadable content with it. At runtime, when a product is purchased by a user, your app uses SKDownload objects to download the content from the App Store.\n\n> Your app never directly creates a SKDownload object. Instead, after a payment is processed, your app reads the transaction object\xe2\x80\x99s downloads property to retrieve an array of SKDownload objects associated with the transaction.\n\n> To download the content, you queue a download object on the payment queue and wait for the content to be downloaded. After a download completes, read the download object\xe2\x80\x99s contentURL property to get a URL to the downloaded content. Your app must process the downloaded file before completing the transaction. For example, it might copy the file into a directory whose contents are persistent. When all downloads are complete, you finish the transaction. After the transaction is finished, the download objects cannot be queued to the payment queue and any URLs to the downloaded content are invalid.\n\nTo start the downloads (this can be done in `purchaseProduct()`, `completeTransactions()` or `restorePurchases()`):\n\n```swift\nSwiftyStoreKit.purchaseProduct("com.musevisions.SwiftyStoreKit.Purchase1", quantity: 1, atomically: false) { result in\n    switch result {\n    case .success(let product):\n        let downloads = purchase.transaction.downloads\n        if !downloads.isEmpty {\n            SwiftyStoreKit.start(downloads)\n        }\n    case .error(let error):\n        print("\\(error)")\n    }\n}\n```\n\nTo check the updated downloads, setup a `updatedDownloadsHandler` block in your AppDelegate:\n\n```swift\nSwiftyStoreKit.updatedDownloadsHandler = { downloads in\n\n    // contentURL is not nil if downloadState == .finished\n    let contentURLs = downloads.flatMap { $0.contentURL }\n    if contentURLs.count == downloads.count {\n        // process all downloaded files, then finish the transaction\n        SwiftyStoreKit.finishTransaction(downloads[0].transaction)\n    }\n}\n```\n\nTo control the state of the downloads, SwiftyStoreKit offers `start()`, `pause()`, `resume()`, `cancel()` methods.\n\n## Receipt verification\n\nAccording to [Apple - Delivering Products](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Chapters/DeliverProduct.html#//apple_ref/doc/uid/TP40008267-CH5-SW4):\n\n> The app receipt contains a record of the user\xe2\x80\x99s purchases, cryptographically signed by Apple. For more information, see [Receipt Validation Programming Guide](https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Introduction.html#//apple_ref/doc/uid/TP40010573).\n\n> Information about consumable products is added to the receipt when they\xe2\x80\x99re paid for and remains in the receipt until you finish the transaction. After you finish the transaction, this information is removed the next time the receipt is updated\xe2\x80\x94for example, the next time the user makes a purchase.\n\n> Information about all other kinds of purchases is added to the receipt when they\xe2\x80\x99re paid for and remains in the receipt indefinitely.\n\nWhen an app is first installed, the app receipt is missing.\n\nAs soon as a user completes a purchase or restores purchases, StoreKit creates and stores the receipt locally as a file, located by `Bundle.main.appStoreReceiptURL`.\n\n### Retrieve local receipt (encrypted)\n\nThis helper can be used to retrieve the (encrypted) local receipt data:\n\n```swift\nlet receiptData = SwiftyStoreKit.localReceiptData\nlet receiptString = receiptData.base64EncodedString(options: [])\n// do your receipt validation here\n```\n\nHowever, the receipt file may be missing or outdated.\n\n### Fetch receipt (encrypted)\n\nUse this method to get the updated receipt:\n\n```swift\nSwiftyStoreKit.fetchReceipt(forceRefresh: true) { result in\n    switch result {\n    case .success(let receiptData):\n        let encryptedReceipt = receiptData.base64EncodedString(options: [])\n        print("Fetch receipt success:\\n\\(encryptedReceipt)")\n    case .error(let error):\n        print("Fetch receipt failed: \\(error)")\n    }\n}\n```\n\nThis method works as follows:\n\n* If `forceRefresh = false`, it returns the local receipt from file, or refreshes it if missing.\n* If `forceRefresh = true`, it always refreshes the receipt regardless.\n\n**Notes**\n\n* If the local receipt is missing or `forceRefresh = true` when calling `fetchReceipt`, a network call is made to refresh it.\n* If the user is not logged to the App Store, StoreKit will present a popup asking to **Sign In to the iTunes Store**.\n* If the user enters valid credentials, the receipt will be refreshed.\n* If the user cancels, receipt refresh will fail with a **Cannot connect to iTunes Store** error.\n\nIf `fetchReceipt` is successful, it will return the **encrypted** receipt as a string. For this reason, a **validation** step is needed to get all the receipt fields in readable form. This can be done in various ways:\n\n1. Validate with Apple via the `AppleReceiptValidator` (see [`verifyReceipt`](#verify-receipt) below).\n2. Perform local receipt validation (see [#101](https://github.com/bizz84/SwiftyStoreKit/issues/101)).\n3. Post the receipt data and validate on server.\n\n### Verify Receipt\n\nUse this method to (optionally) refresh the receipt and perform validation in one step.\n\n```swift\nlet appleValidator = AppleReceiptValidator(service: .production, sharedSecret: "your-shared-secret")\nSwiftyStoreKit.verifyReceipt(using: appleValidator, forceRefresh: false) { result in\n    switch result {\n    case .success(let receipt):\n        print("Verify receipt success: \\(receipt)")\n    case .error(let error):\n        print("Verify receipt failed: \\(error)")\n    }\n}\n```\n\n**Notes**\n\n* This method is based on `fetchReceipt`, and the same refresh logic discussed above applies. \n* `AppleReceiptValidator` is a **reference implementation** that validates the receipt with Apple and results in a network call. _This is prone to man-in-the-middle attacks._\n* You should implement your secure logic by validating your receipt locally, or sending the encrypted receipt data and validating it in your server.\n* Local receipt validation is not implemented (see [issue #101](https://github.com/bizz84/SwiftyStoreKit/issues/101) for details).\n* You can implement your own receipt validator by conforming to the `ReceiptValidator` protocol and passing it to `verifyReceipt`.\n\n## Verifying purchases and subscriptions\n\nOnce you have retrieved the receipt using the `verifyReceipt` method, you can verify your purchases and subscriptions by product identifier.\n\nVerifying multiple purchases and subscriptions in one call is not yet supported (see [issue #194](https://github.com/bizz84/SwiftyStoreKit/issues/194) for more details).\n\nIf you need to verify multiple purchases / subscriptions, you can either:\n\n* manually parse the receipt dictionary returned by `verifyReceipt`\n* call `verifyPurchase` or `verifySubscription` multiple times with different product identifiers\n\n### Verify Purchase\n\n```swift\nlet appleValidator = AppleReceiptValidator(service: .production, sharedSecret: "your-shared-secret")\nSwiftyStoreKit.verifyReceipt(using: appleValidator) { result in\n    switch result {\n    case .success(let receipt):\n        let productId = "com.musevisions.SwiftyStoreKit.Purchase1"\n        // Verify the purchase of Consumable or NonConsumable\n        let purchaseResult = SwiftyStoreKit.verifyPurchase(\n            productId: productId,\n            inReceipt: receipt)\n            \n        switch purchaseResult {\n        case .purchased(let receiptItem):\n            print("\\(productId) is purchased: \\(receiptItem)")\n        case .notPurchased:\n            print("The user has never purchased \\(productId)")\n        }\n    case .error(let error):\n        print("Receipt verification failed: \\(error)")\n    }\n}\n```\n\nNote that for consumable products, the receipt will only include the information for a couple of minutes after the purchase.\n\n### Verify Subscription\n\nThis can be used to check if a subscription was previously purchased, and whether it is still active or if it\'s expired.\n\nFrom [Apple - Working with Subscriptions](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Chapters/Subscriptions.html#//apple_ref/doc/uid/TP40008267-CH7-SW6):\n\n> keep a record of the date that each piece of content is published. Read the Original Purchase Date and Subscription Expiration Date field from each receipt entry to determine the start and end dates of the subscription.\n\nWhen one or more subscriptions are found for a given product id, they are returned as a `ReceiptItem` array ordered by `expiryDate`, with the first one being the newest.\n\n```swift\nlet appleValidator = AppleReceiptValidator(service: .production, sharedSecret: "your-shared-secret")\nSwiftyStoreKit.verifyReceipt(using: appleValidator) { result in\n    switch result {\n    case .success(let receipt):\n        let productId = "com.musevisions.SwiftyStoreKit.Subscription"\n        // Verify the purchase of a Subscription\n        let purchaseResult = SwiftyStoreKit.verifySubscription(\n            ofType: .autoRenewable, // or .nonRenewing (see below)\n            productId: productId,\n            inReceipt: receipt)\n            \n        switch purchaseResult {\n        case .purchased(let expiryDate, let items):\n            print("\\(productId) is valid until \\(expiryDate)\\n\\(items)\\n")\n        case .expired(let expiryDate, let items):\n            print("\\(productId) is expired since \\(expiryDate)\\n\\(items)\\n")\n        case .notPurchased:\n            print("The user has never purchased \\(productId)")\n        }\n\n    case .error(let error):\n        print("Receipt verification failed: \\(error)")\n    }\n}\n```\n\n#### Auto-Renewable\n```swift\nlet purchaseResult = SwiftyStoreKit.verifySubscription(\n            ofType: .autoRenewable,\n            productId: "com.musevisions.SwiftyStoreKit.Subscription",\n            inReceipt: receipt)\n```\n\n#### Non-Renewing\n```swift\n// validDuration: time interval in seconds\nlet purchaseResult = SwiftyStoreKit.verifySubscription(\n            ofType: .nonRenewing(validDuration: 3600 * 24 * 30),\n            productId: "com.musevisions.SwiftyStoreKit.Subscription",\n            inReceipt: receipt)\n```\n\n**Notes**\n\n* The expiration dates are calculated against the receipt date. This is the date of the last successful call to `verifyReceipt`.\n* When purchasing subscriptions in sandbox mode, the expiry dates are set just minutes after the purchase date for testing purposes.\n\n#### Purchasing and verifying a subscription \n\nThe `verifySubscription` method can be used together with the `purchaseProduct` method to purchase a subscription and check its expiration date, like so:\n\n```swift\nlet productId = "your-product-id"\nSwiftyStoreKit.purchaseProduct(productId, atomically: true) { result in\n    \n    if case .success(let purchase) = result {\n        // Deliver content from server, then:\n        if purchase.needsFinishTransaction {\n            SwiftyStoreKit.finishTransaction(purchase.transaction)\n        }\n        \n        let appleValidator = AppleReceiptValidator(service: .production, sharedSecret: "your-shared-secret")\n        SwiftyStoreKit.verifyReceipt(using: appleValidator) { result in\n            \n            if case .success(let receipt) = result {\n                let purchaseResult = SwiftyStoreKit.verifySubscription(\n                    ofType: .autoRenewable,\n                    productId: productId,\n                    inReceipt: receipt)\n                \n                switch purchaseResult {\n                case .purchased(let expiryDate, let receiptItems):\n                    print("Product is valid until \\(expiryDate)")\n                case .expired(let expiryDate, let receiptItems):\n                    print("Product is expired since \\(expiryDate)")\n                case .notPurchased:\n                    print("This product has never been purchased")\n                }\n\n            } else {\n                // receipt verification error\n            }\n        }\n    } else {\n        // purchase error\n    }\n}\n```\n\n### Subscription Groups\n\nFrom [Apple Docs - Offering Subscriptions](https://developer.apple.com/app-store/subscriptions/):\n\n> A subscription group is a set of in-app purchases that you can create to provide users with a range of content offerings, service levels, or durations to best meet their needs. Users can only buy one subscription within a subscription group at a time. If users would want to buy more that one type of subscription \xe2\x80\x94 for example, to subscribe to more than one channel in a streaming app \xe2\x80\x94 you can put these in-app purchases in different subscription groups.\n\nYou can verify all subscriptions within the same group with the `verifySubscriptions` method:\n\n```swift\nlet appleValidator = AppleReceiptValidator(service: .production, sharedSecret: "your-shared-secret")\nSwiftyStoreKit.verifyReceipt(using: appleValidator) { result in\n    switch result {\n    case .success(let receipt):\n        let productIds = Set([ "com.musevisions.SwiftyStoreKit.Weekly",\n                               "com.musevisions.SwiftyStoreKit.Monthly",\n                               "com.musevisions.SwiftyStoreKit.Yearly" ])\n        let purchaseResult = SwiftyStoreKit.verifySubscriptions(productIds: productIds, inReceipt: receipt)\n        switch purchaseResult {\n        case .purchased(let expiryDate, let items):\n            print("\\(productIds) are valid until \\(expiryDate)\\n\\(items)\\n")\n        case .expired(let expiryDate, let items):\n            print("\\(productIds) are expired since \\(expiryDate)\\n\\(items)\\n")\n        case .notPurchased:\n            print("The user has never purchased \\(productIds)")\n        }\n    case .error(let error):\n        print("Receipt verification failed: \\(error)")\n    }\n}\n```\n\n## Notes\nThe framework provides a simple block based API with robust error handling on top of the existing StoreKit framework. It does **NOT** persist in app purchases data locally. It is up to clients to do this with a storage solution of choice (i.e. NSUserDefaults, CoreData, Keychain).\n\n#### Swift 2.x / 3.x / 4.x / 5.x\n\n| Language  | Branch | Pod version | Xcode version |\n| --------- | ------ | ----------- | ------------- |\n| Swift 5.x | [master](https://github.com/bizz84/SwiftyStoreKit/tree/master) | >= 0.15.0 | Xcode 10.2 or greater|\n| Swift 4.x | [master](https://github.com/bizz84/SwiftyStoreKit/tree/master) | >= 0.10.4 | Xcode 9 or greater|\n| Swift 3.x | [master](https://github.com/bizz84/SwiftyStoreKit/tree/master) | >= 0.5.x | Xcode 8.x |\n| Swift 2.3 | [swift-2.3](https://github.com/bizz84/SwiftyStoreKit/tree/swift-2.3) | 0.4.x | Xcode 8, Xcode 7.3.x |\n| Swift 2.2 | [swift-2.2](https://github.com/bizz84/SwiftyStoreKit/tree/swift-2.2) | 0.3.x | Xcode 7.3.x |\n\n\n## Change Log\n\nSee the [Releases Page](https://github.com/bizz84/SwiftyStoreKit/releases).\n\n## Sample Code\nThe project includes demo apps [for iOS](https://github.com/bizz84/SwiftyStoreKit/blob/master/SwiftyStoreKit-iOS-Demo/ViewController.swift) [and macOS](https://github.com/bizz84/SwiftyStoreKit/blob/master/SwiftyStoreKit-macOS-Demo/ViewController.swift) showing how to use SwiftyStoreKit.\nNote that the pre-registered in app purchases in the demo apps are for illustration purposes only and may not work as iTunes Connect may invalidate them.\n\n## Essential Reading\n* [Apple - WWDC16, Session 702: Using Store Kit for In-app Purchases with Swift 3](https://developer.apple.com/videos/play/wwdc2016/702/)\n* [Apple - TN2387: In-App Purchase Best Practices](https://developer.apple.com/library/content/technotes/tn2387/_index.html)\n* [Apple - TN2413: In-App Purchase FAQ](https://developer.apple.com/library/content/technotes/tn2413/_index.html) (also see [Cannot connect to iTunes Store](https://developer.apple.com/library/content/technotes/tn2413/_index.html#//apple_ref/doc/uid/DTS40016228-CH1-ERROR_MESSAGES-CANNOT_CONNECT_TO_ITUNES_STORE))\n* [Apple - TN2259: Adding In-App Purchase to Your Applications](https://developer.apple.com/library/content/technotes/tn2259/_index.html)\n* [iTunes Connect Developer Help - Workflow for configuring in-app purchases](https://help.apple.com/itunes-connect/developer/#/devb57be10e7)\n* [Apple - About Receipt Validation](https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Introduction.html)\n* [Apple - Receipt Validation Programming Guide](https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW1)\n* [Apple - Validating Receipts Locally](https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateLocally.html)\n* [Apple - Working with Subscriptions](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Chapters/Subscriptions.html#//apple_ref/doc/uid/TP40008267-CH7-SW6)\n* [Apple - Offering Subscriptions](https://developer.apple.com/app-store/subscriptions/)\n* [Apple - Restoring Purchased Products](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Chapters/Restoring.html#//apple_ref/doc/uid/TP40008267-CH8-SW9)\n* [Apple - Testing In-App Purchase Products](https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnectInAppPurchase_Guide/Chapters/TestingInAppPurchases.html): includes info on duration of subscriptions in sandbox mode\n* [objc.io - Receipt Validation](https://www.objc.io/issues/17-security/receipt-validation/)\n\nI have also written about building SwiftyStoreKit on Medium:\n\n* [How I got 1000 \xe2\xad\x90\xef\xb8\x8f on my GitHub Project](https://medium.com/ios-os-x-development/how-i-got-1000-%EF%B8%8F-on-my-github-project-654d3d394ca6#.1idp27olf)\n* [Maintaining a Growing Open Source Project](https://medium.com/@biz84/maintaining-a-growing-open-source-project-1d385ca84c5#.4cv2g7tdc)\n\n### Troubleshooting \n\n* [Apple TN 2413 - Why are my product identifiers being returned in the invalidProductIdentifiers array?](https://developer.apple.com/library/content/technotes/tn2413/_index.html#//apple_ref/doc/uid/DTS40016228-CH1-TROUBLESHOOTING-WHY_ARE_MY_PRODUCT_IDENTIFIERS_BEING_RETURNED_IN_THE_INVALIDPRODUCTIDENTIFIERS_ARRAY_)\n* [Invalid Product IDs](http://troybrant.net/blog/2010/01/invalid-product-ids/): Checklist of common mistakes\n* [Testing Auto-Renewable Subscriptions on iOS](http://davidbarnard.com/post/164337147440/testing-auto-renewable-subscriptions-on-ios)\n* [Apple forums - iOS 11 beta sandbox - cannot connect to App Store](https://forums.developer.apple.com/message/261428#261428)\n\n## Video Tutorials\n\n#### Jared Davidson: In App Purchases! (Swift 3 in Xcode : Swifty Store Kit)\n\n<a href="https://www.youtube.com/watch?v=dwPFtwDJ7tcb"><img src="https://raw.githubusercontent.com/bizz84/SwiftyStoreKit/master/Screenshots/VideoTutorial-JaredDavidson.jpg" width="854" /></a>\n\n#### [@rebeloper](https://github.com/rebeloper): Ultimate In-app Purchases Guide\n\n<a href="https://www.youtube.com/watch?v=bIyj6BZ1-Qw&list=PL_csAAO9PQ8b9kqrltk2_SpYslTwyrwjb"><img src="https://raw.githubusercontent.com/bizz84/SwiftyStoreKit/master/Screenshots/VideoTutorial-Rebeloper.jpg" width="854" /></a>\n\n## Payment flows: implementation details\nIn order to make a purchase, two operations are needed:\n\n- Perform a `SKProductRequest` to obtain the `SKProduct` corresponding to the product identifier.\n\n- Submit the payment and listen for updated transactions on the `SKPaymentQueue`.\n\nThe framework takes care of caching SKProducts so that future requests for the same `SKProduct` don\'t need to perform a new `SKProductRequest`.\n\n#### Payment queue\n\nThe following list outlines how requests are processed by SwiftyStoreKit.\n\n* `SKPaymentQueue` is used to queue payments or restore purchases requests.\n* Payments are processed serially and in-order and require user interaction.\n* Restore purchases requests don\'t require user interaction and can jump ahead of the queue.\n* `SKPaymentQueue` rejects multiple restore purchases calls.\n* Failed transactions only ever belong to queued payment requests.\n* `restoreCompletedTransactionsFailedWithError` is always called when a restore purchases request fails.\n* `paymentQueueRestoreCompletedTransactionsFinished` is always called following 0 or more update transactions when a restore purchases request succeeds.\n* A complete transactions handler is require to catch any transactions that are updated when the app is not running.\n* Registering a complete transactions handler when the app launches ensures that any pending transactions can be cleared.\n* If a complete transactions handler is missing, pending transactions can be mis-attributed to any new incoming payments or restore purchases.\n\nThe order in which transaction updates are processed is:\n\n1. payments (transactionState: `.purchased` and `.failed` for matching product identifiers)\n2. restore purchases (transactionState: `.restored`, or `restoreCompletedTransactionsFailedWithError`, or `paymentQueueRestoreCompletedTransactionsFinished`)\n3. complete transactions (transactionState: `.purchased`, `.failed`, `.restored`, `.deferred`)\n\nAny transactions where state is `.purchasing` are ignored.\n\nSee [this pull request](https://github.com/bizz84/SwiftyStoreKit/pull/131) for full details about how the payment flows have been implemented.\n\n## Credits\nMany thanks to [phimage](https://github.com/phimage) for adding macOS support and receipt verification.\n\n## Apps using SwiftyStoreKit\n\nIt would be great to showcase apps using SwiftyStoreKit here. Pull requests welcome :)\n\n* [Every Plant, Ever](https://itunes.apple.com/us/app/every-plant-ever/id1433967019) - The sticker pack of every plant, ever.\n* [Countdown](https://countdowns.download/ssk) - Countdown the days until your next vacation, deadline, or event\n* [MDacne](https://itunes.apple.com/app/id1044050208) - Acne analysis and treatment\n* [Pixel Picker](https://itunes.apple.com/app/id930804327) - Image Color Picker\n* [KType](https://itunes.apple.com/app/id1037000234) - Space shooter game\n* [iPic](https://itunes.apple.com/app/id1101244278) - Automatically upload images and save Markdown links\n* [iHosts](https://itunes.apple.com/app/id1102004240) - Perfect for editing /etc/hosts\n* [Arise](http://www.abnehm-app.de/) - Calorie counter\n* [Truth Truth Lie](https://itunes.apple.com/app/id1130832864) - iMessage game, featured by Apple\n* [Tactus Music Player](https://itunes.apple.com/app/id557446352) - Alternative music player app\n* [Drops](https://itunes.apple.com/app/id939540371) - Language learning app\n* [Fresh Snow](https://itunes.apple.com/app/id1063000470) - Colorado Ski Report\n* [Zmeu Grand Canyon](http://grandcanyon.zmeu.guide/) - Interactive hiking map & planner\n* [OB Monitor](https://itunes.apple.com/app/id1073398446) - The app for Texas Longhorns athletics fans\n* [Talk Dim Sum](https://itunes.apple.com/us/app/talk-dim-sum/id953929066) - Your dim sum companion\n* [Sluggard](https://itunes.apple.com/app/id1160131071) - Perform simple exercises to reduce the risks of sedentary lifestyle\n\nA full list of apps is published [on AppSight](https://www.appsight.io/sdk/574154).\n\n## License\n\nCopyright (c) 2015-2018 Andrea Bizzotto bizz84@gmail.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n'