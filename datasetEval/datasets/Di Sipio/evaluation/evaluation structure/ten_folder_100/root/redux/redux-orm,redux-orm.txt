b'<h1 align="center">Redux-ORM</h1>\n\n<div align="center">\n\n[![Build Status](https://img.shields.io/travis/redux-orm/redux-orm.svg?style=flat-square)](https://travis-ci.org/redux-orm/redux-orm)\n[![Codacy Grade](https://img.shields.io/codacy/grade/d3ad7e3bd8264012953df9d1967bedaa.svg?style=flat-square)](https://www.codacy.com/app/redux-orm/redux-orm?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=redux-orm/redux-orm&amp;utm_campaign=Badge_Grade)\n[![Coverage Status](https://img.shields.io/codecov/c/github/redux-orm/redux-orm/master.svg?style=flat-square)](https://codecov.io/gh/redux-orm/redux-orm/branch/master)\n[![NPM package](https://img.shields.io/npm/v/redux-orm.svg?style=flat-square)](https://www.npmjs.com/package/redux-orm)\n![GitHub Release Date](https://img.shields.io/github/release-date/redux-orm/redux-orm.svg?style=flat-square)\n[![NPM downloads](https://img.shields.io/npm/dm/redux-orm.svg?style=flat-square)](https://www.npmjs.com/package/redux-orm)\n[![Gitter](https://badges.gitter.im/redux-orm/Lobby.svg?style=flat-square)](https://gitter.im/redux-orm/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n![NPM license](https://img.shields.io/npm/l/redux-orm.svg?style=flat-square)\n</div>\n\n## Installation\n\n```bash\nnpm install redux-orm --save\n```\n\nOr with a script tag exposing a global called `ReduxOrm`:\n\n```html\n<script src="https://unpkg.com/redux-orm/dist/redux-orm.min.js"></script>\n```\n\n* [Latest browser build (minimized)](https://unpkg.com/redux-orm/dist/redux-orm.min.js)\n  * [Source Map](https://unpkg.com/redux-orm/dist/redux-orm.min.js.map)\n\n* [Latest browser build](https://unpkg.com/redux-orm/dist/redux-orm.js) (only use if size does not matter)\n\n### Polyfill\n\nRedux-ORM uses some ES2015+ features, such as `Set`. If you are using Redux-ORM in a pre-ES2015+ environment, you should load a polyfill like [`babel-polyfill`](https://babeljs.io/docs/usage/polyfill/) before using Redux-ORM.\n\n### Extensions\n\n* [`redux-orm-proptypes`](https://github.com/tommikaikkonen/redux-orm-proptypes): React PropTypes validation and defaultProps mixin for Redux-ORM Models\n\n## Usage\n\nFor a detailed walkthrough see [a guide to creating a simple app with Redux-ORM](https://github.com/tommikaikkonen/redux-orm-primer). Its not up-to-date yet but the [code has a branch for version 0.9](https://github.com/tommikaikkonen/redux-orm-primer/tree/migrate_to_0_9). The Redux docs have a [short section](https://redux.js.org/recipes/structuring-reducers/updating-normalized-data#redux-orm) on Redux-ORM as well.\n\n### Declare Your Models\n\nYou can declare your models with the ES6 class syntax, extending from `Model`. You need to declare all your non-relational fields on the Model, and declaring all data fields is recommended as the library doesn\'t have to redefine getters and setters when instantiating Models. Redux-ORM supports one-to-one and many-to-many relations in addition to foreign keys (`oneToOne`, `many` and `fk` imports respectively). Non-related properties can be accessed like in normal JavaScript objects.\n\n```javascript\n// models.js\nimport { Model, fk, many, attr } from \'redux-orm\';\n\nclass Book extends Model {\n    toString() {\n        return `Book: ${this.name}`;\n    }\n    // Declare any static or instance methods you need.\n}\nBook.modelName = \'Book\';\n\n// Declare your related fields.\nBook.fields = {\n    id: attr(), // non-relational field for any value; optional but highly recommended\n    name: attr(),\n    // foreign key field\n    publisherId: fk({\n        to: \'Publisher\',\n        as: \'publisher\',\n        relatedName: \'books\',\n    }),\n    authors: many(\'Author\', \'books\'),\n};\n\nexport default Book;\n```\n\n### Register Models and Generate an Empty Database State\n\nDefining fields on a Model specifies the table structure in the database for that Model. In order to generate a description of the whole database\'s structure, we need a central place to register all Models we want to use.\n\nAn instance of the ORM class registers Models and handles generating a full schema from all the models and passing that information to the database. Often you\'ll want to have a file where you can import a single ORM instance across the app, like this:\n\n```javascript\n// orm.js\nimport { ORM } from \'redux-orm\';\nimport { Book, Author, Publisher } from \'./models\';\n\nconst orm = new ORM({\n  stateSelector: state => state.orm,\n});\norm.register(Book, Author, Publisher);\n\nexport default orm;\n```\n\nYou could also define *and* register the models to an ORM instance in the same file, and export them all.\n\nNow that we\'ve registered Models, we can generate an empty database state. Currently that\'s a plain, nested JavaScript object that is structured similarly to relational databases.\n\n```javascript\n// index.js\n\nimport orm from \'./orm\';\n\nconst emptyDBState = orm.getEmptyState();\n```\n\n### Applying Updates to the Database\n\nWhen we have a database state, we can start an ORM session on that to apply updates. The ORM instance provides a `session` method that accepts a database state as it\'s sole argument, and returns a Session instance.\n\n```javascript\nconst session = orm.session(emptyDBState);\n```\n\nSession-specific classes of registered Models are available as properties of the session object.\n\n```javascript\nconst Book = session.Book;\n```\n\nModels provide an interface to query and update the database state.\n\n```javascript\nBook.withId(1).update({ name: \'Clean Code\' });\nBook.all().filter(book => book.name === \'Clean Code\').delete();\nBook.idExists(1)\n// false\n```\n\nThe initial database state is not mutated. A new database state with the updates applied can be found on the `state` property of the Session instance.\n\n```javascript\nconst updatedDBState = session.state;\n```\n\n## Redux Integration\n\nTo integrate Redux-ORM with Redux at the most basic level, you can define a reducer that instantiates a session from the database state held in the Redux state slice, then when you\'ve applied all of your updates, you can return the next state from the session.\n\n```javascript\nimport orm from \'./orm\';\n\nfunction ormReducer(dbState, action) {\n    const sess = orm.session(dbState);\n\n    // Session-specific Models are available\n    // as properties on the Session instance.\n    const { Book } = sess;\n\n    switch (action.type) {\n    case \'CREATE_BOOK\':\n        Book.create(action.payload);\n        break;\n    case \'UPDATE_BOOK\':\n        Book.withId(action.payload.id).update(action.payload);\n        break;\n    case \'REMOVE_BOOK\':\n        Book.withId(action.payload.id).delete();\n        break;\n    case \'ADD_AUTHOR_TO_BOOK\':\n        Book.withId(action.payload.bookId).authors.add(action.payload.author);\n        break;\n    case \'REMOVE_AUTHOR_FROM_BOOK\':\n        Book.withId(action.payload.bookId).authors.remove(action.payload.authorId);\n        break;\n    case \'ASSIGN_PUBLISHER\':\n        Book.withId(action.payload.bookId).publisherId = action.payload.publisherId;\n        break;\n    }\n\n    // the state property of Session always points to the current database.\n    // Updates don\'t mutate the original state, so this reference is not\n    // equal to `dbState` that was an argument to this reducer.\n    return sess.state;\n}\n```\n\nPreviously we advocated for reducers specific to Models by attaching a static `reducer` function on the Model class. If you want to define your update logic on the Model classes, you can specify a `reducer` static method on your model which accepts the action as the first argument, the session-specific Model as the second, and the whole session as the third.\n\n```javascript\nclass Book extends Model {\n    static reducer(action, Book, session) {\n        switch (action.type) {\n        case \'CREATE_BOOK\':\n            Book.create(action.payload);\n            break;\n        case \'UPDATE_BOOK\':\n            Book.withId(action.payload.id).update(action.payload);\n            break;\n        case \'REMOVE_BOOK\':\n            const book = Book.withId(action.payload);\n            book.delete();\n            break;\n        case \'ADD_AUTHOR_TO_BOOK\':\n            Book.withId(action.payload.bookId).authors.add(action.payload.author);\n            break;\n        case \'REMOVE_AUTHOR_FROM_BOOK\':\n            Book.withId(action.payload.bookId).authors.remove(action.payload.authorId);\n            break;\n        case \'ASSIGN_PUBLISHER\':\n            Book.withId(action.payload.bookId).publisherId = action.payload.publisherId;\n            break;\n        }\n        // Return value is ignored.\n        return undefined;\n    }\n\n    toString() {\n        return `Book: ${this.name}`;\n    }\n}\n```\n\nTo get a reducer for Redux that calls these `reducer` methods:\n\n```javascript\nimport { createReducer } from \'redux-orm\';\nimport orm from \'./orm\';\n\nconst reducer = createReducer(orm);\n```\n\nThis reducer needs to be hooked into your Redux store. Make sure that the key under which you store it is also the key that you use to retrieve the ORM\'s state in its `stateSelector`. Otherwise selectors won\'t work properly.\n\n`createReducer` is really simple, so we\'ll just paste the source here.\n\n```javascript\nfunction createReducer(orm, updater = defaultUpdater) {\n    return (state, action) => {\n        const session = orm.session(state || orm.getEmptyState());\n        updater(session, action);\n        return session.state;\n    };\n}\n\nfunction defaultUpdater(session, action) {\n    session.sessionBoundModels.forEach(modelClass => {\n        if (typeof modelClass.reducer === \'function\') {\n            modelClass.reducer(action, modelClass, session);\n        }\n    });\n}\n```\n\nAs you can see, it just instantiates a new Session, loops through all the Models in the session, and calls the `reducer` method if it exists. Then it returns the new database state that has all the updates applied.\n\n### Use with React\n\nUse memoized selectors to make queries into the state. Redux-ORM uses smart memoization: the below selector accesses `Author` and `AuthorBooks` branches (`AuthorBooks` is a many-to-many branch generated from the model field declarations), and the selector will be recomputed only if those branches change. The accessed branches are resolved on the first run.\n\n```javascript\n// selectors.js\nimport { createSelector } from \'redux-orm\';\nimport orm from \'./orm\';\n\nconst authorSelector = createSelector(\n    orm,\n    session => {\n        return session.Author.all().toModelArray().map(author => {\n            /**\n             * author is a model instance and exposes relationship accessors\n             * such as author.books \xe2\x80\xa6\n             *\n             * This gets a reference to the model\'s underlying object\n             * which has no such accessors, containing only raw attributes.\n             */\n            const { ref } = author;\n            // Object.keys(ref) === [\'id\', \'name\']\n\n            return {\n                ...ref,\n                books: author.books.toRefArray().map(book => book.name),\n            };\n        });\n    }\n);\n\n// Will result in something like this when run:\n// [\n//   {\n//     id: 0,\n//     name: \'Tommi Kaikkonen\',\n//     books: [\'Introduction to Redux-ORM\', \'Developing Redux applications\'],\n//   },\n//   {\n//     id: 1,\n//     name: \'John Doe\',\n//     books: [\'John Doe: an Autobiography\']\n//   }\n// ]\n```\n\nSelectors created with `createSelector` can be used as input to any additional `reselect` selectors you want to use. They are also great to use with `redux-thunk`: get the whole state with `getState()`, pass the ORM branch to the selector, and get your results. A good use case is serializing data to a custom format for a 3rd party API call.\n\nBecause selectors are memoized, you can use pure rendering in React for performance gains.\n\n```jsx\n// components.js\nimport React from \'react\';\nimport { authorSelector } from \'./selectors\';\nimport { connect } from \'react-redux\';\n\nfunction AuthorList({ authors }) {\n    const items = authors.map(author => (\n        <li key={author.id}>\n            {author.name} has written {author.books.join(\', \')}\n        </li>\n    ));\n\n    return (\n        <ul>{items}</ul>\n    );\n}\n\nfunction mapStateToProps(state) {\n    return {\n        authors: authorSelector(state),\n    };\n}\n\nexport default connect(mapStateToProps)(AuthorList);\n```\n\n## Understanding Redux-ORM\n\n### An ORM?\n\nWell, yeah. Redux-ORM deals with related data, structured similar to a relational database. The database in this case is a simple JavaScript object database.\n\n### Why?\n\nFor simple apps, writing reducers by hand is alright, but when the number of object types you have increases and you need to maintain relations between them, things get hairy. ImmutableJS goes a long way to reduce complexity in your reducers, but Redux-ORM is specialized for relational data.\n\n### Immutability\n\nSay we start a session from an initial database state situated in the Redux atom, update the name of a certain book.\n\nFirst, a new session:\n\n```javascript\nimport { orm } from \'./models\';\n\nconst dbState = store.getState().orm; // getState() returns the Redux state\nconst sess = orm.session(dbState);\n```\n\nThe session maintains a reference to a database state. We haven\'t\nupdated the database state, therefore it is still equal to the original\nstate.\n\n```javascript\nsess.state === dbState\n// true\n```\n\nLet\'s apply an update.\n\n```javascript\nconst book = sess.Book.withId(1)\n\nbook.name // \'Refactoring\'\nbook.name = \'Clean Code\'\nbook.name // \'Clean Code\'\n\nsess.state === dbState\n// false\n```\n\nThe update was applied, and because the session does not mutate the original state, it created a new one and swapped `sess.state` to point to the new one.\n\nLet\'s update the database state again through the ORM.\n\n```javascript\n// Save this reference so we can compare.\nconst updatedState = sess.state;\n\nbook.name = \'Patterns of Enterprise Application Architecture\';\n\nsess.state === updatedState\n// true. If possible, future updates are applied with mutations. If you want\n// to avoid making mutations to a session state, take the session state\n// and start a new session with that state.\n```\n\nIf possible, future updates are applied with mutations. In this case, the database was already mutated, so the pointer doesn\'t need to change. If you want to avoid making mutations to a session state, take the session state and start a new session with that state.\n\n### Customizability\n\nJust like you can extend `Model`, you can do the same for `QuerySet` (customize methods on Model instance collections). You can also specify the whole database implementation yourself (documentation pending).\n\n### Caveats\n\n![gzip size](https://img.shields.io/bundlephobia/minzip/redux-orm.svg?style=flat-square)\n\nThe ORM abstraction will never be as performant compared to writing reducers by hand, and adds to the build size of your project. If you have very simple data without relations, Redux-ORM may be overkill. The development convenience benefit is considerable though.\n\n## API\n\n### ORM\n\nSee the full documentation for ORM [here](http://redux-orm.github.io/redux-orm/global.html#ORM)\n\n#### Instantiation:\n\n```javascript\nconst orm = new ORM({\n  stateSelector: state => state.orm, // wherever the reducer is put during createStore\n});\n```\n\n#### Instance methods:\n\n* `register(...models: Array<Model>)`: registers Model classes to the `ORM` instance.\n* `session(state: any)`: begins a new `Session` with `state`.\n\n### Redux Integration\n\n* `createReducer(orm: ORM)`: returns a reducer function that can be plugged into Redux. The reducer will return the next state of the database given the provided action. You need to register your models before calling this.\n* `createSelector(orm: ORM, [...inputSelectors], selectorFunc)`: returns a memoized selector function for `selectorFunc`. `selectorFunc` receives `session` as the first argument, followed by any inputs from `inputSelectors`. Note that the first inputSelector must return the db-state to create a session from. Read the full documentation for details.\n\n### Model\n\nSee the full documentation for `Model` [here](http://redux-orm.github.io/redux-orm/Model.html).\n\n**Instantiation**: Don\'t instantiate directly; use the class methods `create` and `upsert` as documented below.\n\n**Class Methods**:\n\n* `withId(id)`: gets the Model instance with id `id`.\n* `idExists(id)`: returns a boolean indicating if an entity with id `id` exists in the state.\n* `exists(matchObj)`: returns a boolean indicating if an entity whose properties match `matchObj` exists in the state.\n* `get(matchObj)`: gets a Model instance based on matching properties in `matchObj` (if you are sure there is only one matching instance).\n* `create(props)`: creates a new Model instance with `props`. If you don\'t supply an id, the new `id` will be `Math.max(...allOtherIds) + 1`.\n* `upsert(props)`: either creates a new Model instance with `props` or, in case an instance with the same id already exists, updates that one - in other words it\'s **create or update** behaviour.\n\nYou will also have access to almost all [QuerySet instance methods](http://redux-orm.github.io/redux-orm/QuerySet.html) from the class object for convenience, including `where` and the like.\n\n#### Instance Attributes:\n* `ref`: returns a direct reference to the plain JavaScript object representing the Model instance in the store.\n\n#### Instance methods:\n\n* `equals(otherModel)`: returns a boolean indicating equality with `otherModel`. Equality is determined by shallow comparison of both model\'s attributes.\n* `set(propertyName, value)`: updates `propertyName` to `value`. Returns `undefined`. Is equivalent to normal assignment.\n* `update(mergeObj)`: merges `mergeObj` with the Model instance properties. Returns `undefined`.\n* `delete()`: deletes the record for this Model instance in the database. Returns `undefined`.\n\n#### Subclassing:\n\nUse the ES6 syntax to subclass from `Model`. Any instance methods you declare will be available on Model instances. Any static methods you declare will be available on the Model class in Sessions.\n\nFor the related fields declarations, either set the `fields` property on the class or declare a static getter that returns the field declarations like this:\n\n#### Declaring `fields`:\n```javascript\nclass Book extends Model {\n    static get fields() {\n        return {\n            id: attr(),\n            name: attr(),\n            author: fk(\'Author\'),\n        };\n    }\n}\n// alternative:\nBook.fields = {\n    id: attr(),\n    name: attr(),\n    author: fk(\'Author\'),\n}\n```\n\nAll the fields `fk`, `oneToOne` and `many` accept a single argument, the related model name. The fields will be available as properties on each `Model` instance. You can set related fields with the id value of the related instance, or the related instance itself.\n\nFor `fk`, you can access the reverse relation through `author.bookSet`, where the related name is `${modelName}Set`. Same goes for `many`. For `oneToOne`, the reverse relation can be accessed by just the model name the field was declared on: `author.book`.\n\nFor `many` field declarations, accessing the field on a Model instance will return a `QuerySet` with two additional methods: `add` and `remove`. They take 1 or more arguments, where the arguments are either Model instances or their id\'s. Calling these methods records updates that will be reflected in the next state.\n\nRelations support more configuration options like accessors, related names, etc. by passing an object:\n\n```javascript\nclass Book extends Model {\n    static get fields() {\n        return {\n            id: attr(),\n            name: attr(),\n            authorId: fk({ to: \'Author\', as: \'author\', relatedName: \'writtenBooks\' }),\n            reviewerIds: many({ to: \'Author\', as: \'reviewers\', relatedName: \'reviewedBooks\' })\n        };\n    }\n}\n```\n\nSee [fk](https://redux-orm.github.io/redux-orm/global.html#fk), [oneToOne](https://redux-orm.github.io/redux-orm/global.html#oneToOne), and [many](https://redux-orm.github.io/redux-orm/global.html#many) in the documentation for more information.\n\nWhen declaring model classes, always remember to set the `modelName` property. It needs to be set explicitly, because running your code through a mangler would otherwise break functionality. The `modelName` will be used to resolve all related fields.\n\n#### Declaring `modelName`:\n```javascript\nclass Book extends Model {\n    static get modelName() {\n        return \'Book\';\n    }\n}\n// alternative:\nBook.modelName = \'Book\';\n```\n\n#### Declaring `options`:\n\nIf you need to specify options to the Redux-ORM database, you can declare a static `options` property on the Model class with an object key.\n\n```javascript\n// These are the default values.\nBook.options = {\n    idAttribute: \'id\',\n    mapName: \'itemsById\',\n    arrName: \'items\',\n};\n```\n\n### QuerySet\n\nSee the full documentation for `QuerySet` [here](http://redux-orm.github.io/redux-orm/QuerySet.html).\n\nYou can access all of these methods straight from a `Model` class, as if they were class methods on `Model`. In this case the functions will operate on a QuerySet that includes all the Model instances.\n\n#### Instance methods:\n\n* `toRefArray()`: returns the objects represented by the `QuerySet` as an array of plain JavaScript objects. The objects are direct references to the store.\n* `toModelArray()`: returns the objects represented by the `QuerySet` as an array of `Model` instances objects.\n* `count()`: returns the number of `Model` instances in the `QuerySet`.\n* `exists()`: return `true` if number of entities is more than 0, else `false`.\n* `filter(filterArg)`: returns a new `QuerySet` representing the records from the parent QuerySet that pass the filter. For `filterArg`, you can either pass an object that Redux-ORM tries to match to the entities, or a function that returns `true` if you want to have it in the new `QuerySet`, `false` if not. The function receives a model instance as its sole argument.\n* `exclude` returns a new `QuerySet` represeting entities in the parent QuerySet that do not pass the filter. Similarly to `filter`, you may pass an object for matching (all entities that match will not be in the new `QuerySet`) or a function. The function receives a model instance as its sole argument.\n* `all()` returns a new `QuerySet` with the same entities.\n* `at(index)` returns an `Model` instance at the supplied `index` in the `QuerySet`.\n* `first()` returns an `Model` instance at the `0` index.\n* `last()` returns an `Model` instance at the `querySet.count() - 1` index.\n* `delete()` deleted all entities represented by the `QuerySet`.\n* `update(mergeObj)` updates all entities represented by the `QuerySet` based on the supplied object. The object will be merged with each entity.\n\n### Session\n\nSee the full documentation for Session [here](http://redux-orm.github.io/redux-orm/Session.html)\n\n#### Instantiation:\n\nYou don\'t need to do this yourself. Use `orm.session` (usually what you want) or `orm.mutableSession`.\n\n#### Instance properties:\n\n* `state`: the current database state in the session.\n\nAdditionally, you can access all the registered Models in the schema for querying and updates as properties of this instance. For example, given a schema with `Book` and `Author` models,\n\n```javascript\nconst session = orm.session(state);\nsession.Book // Model class: Book\nsession.Author // Model class: Author\nsession.Book.create({ id: 5, name: \'Refactoring\', release_year: 1999 });\n```\n\n## Changelog\n\nAPI is still unstable. Minor changes before v1.0.0 can and will include breaking changes, adhering to Semantic Versioning.\n\nSee [`CHANGELOG.md`](https://github.com/redux-orm/redux-orm/blob/master/CHANGELOG.md).\n\nThe 0.9.x versions brought big breaking changes to the API. Please look at the [migration guide](https://github.com/redux-orm/redux-orm/wiki/0.9-Migration-Guide) if you\'re migrating from earlier versions.\n\nLooking for the 0.8 docs? Read the [old README.md in the repo](https://github.com/redux-orm/redux-orm/tree/3c36fa804d2810b2aaaad89ff1d99534b847ea35). For the API reference, clone the repo, `npm install`, `make build` and open up `index.html` in your browser. Sorry for the inconvenience.\n\n## License\n\nMIT. See [`LICENSE`](https://github.com/redux-orm/redux-orm/blob/master/LICENSE).\n'