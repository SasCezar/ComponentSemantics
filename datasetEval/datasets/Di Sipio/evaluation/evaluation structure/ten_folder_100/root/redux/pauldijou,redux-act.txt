b'# redux-act\n\nAn opinionated lib to create actions and reducers for [Redux](https://github.com/rackt/redux). The main goal is to use actions themselves as references inside the reducers rather than string constants.\n\n## Install\n\n```bash\n# NPM\nnpm install redux-act --save\n# Yarn\nyarn add redux-act\n```\n\nYou can also use a [browser friendly compiled file](https://unpkg.com/redux-act@latest/dist/redux-act.js) or the [minified version](https://unpkg.com/redux-act@latest/dist/redux-act.min.js) from NPM CDN (mostly for online demo / snippets).\n\n**Browser support**: this lib uses `String.prototype.startsWith` which is not supported by IE11. Be sure to add a polyfill if you are targeting this browser. [Learn more](https://github.com/pauldijou/redux-act/pull/77).\n\n## Content\n\n- [Usage](#usage)\n- [FAQ](#faq)\n- [Advanced usage](#advanced-usage)\n- [API](#api)\n  - [createAction](#createactiondescription-payloadreducer-metareducer)\n  - [action creator](#action-creator)\n  - [createReducer](#createreducerhandlers-defaultstate)\n  - [reducer](#reducer)\n  - [assignAll](#assignallactioncreators-stores)\n  - [bindAll](#bindallactioncreators-stores)\n  - [batch](#batchactions)\n  - [disbatch](#disbatchstore--dispatch-actions)\n  - [asError](#aserroraction)\n  - [types](#types)\n- [Cookbook](#cookbook)\n  - [Compatibility](#compatibility)\n  - [Adding and removing actions](#adding-and-removing-actions)\n  - [Async actions](#async-actions)\n  - [Enable or disable batch](#enable-or-disable-batch)\n  - [TypeScript](#typescript)\n- [Loggers](#loggers)\n  - [Redux Logger](#redux-logger)\n\n## Usage\n\nEven if there is a function named `createAction`, it actually creates an `action creator` according to Redux glossary. It was just a bit overkill to name the function `createActionCreator`. If you are not sure if something is an action or an action creator, just remember that actions are plain objects while action creators are functions.\n\n```javascript\n// Import functions\nimport { createStore } from \'redux\';\nimport { createAction, createReducer } from \'redux-act\';\n\n// Create an action creator (description is optional)\nconst add = createAction(\'add some stuff\');\nconst increment = createAction(\'increment the state\');\nconst decrement = createAction(\'decrement the state\');\n\n// Create a reducer\n// (ES6 syntax, see Advanced usage below for an alternative for ES5)\nconst counterReducer = createReducer({\n  [increment]: (state) => state + 1,\n  [decrement]: (state) => state - 1,\n  [add]: (state, payload) => state + payload,\n}, 0); // <-- This is the default state\n\n// Create the store\nconst counterStore = createStore(counterReducer);\n\n// Dispatch actions\ncounterStore.dispatch(increment()); // counterStore.getState() === 1\ncounterStore.dispatch(increment()); // counterStore.getState() === 2\ncounterStore.dispatch(decrement()); // counterStore.getState() === 1\ncounterStore.dispatch(add(5)); // counterStore.getState() === 6\n```\n\n## FAQ\n\n- **Does it work with Redux devtools?** Yes.\n\n- **Do reducers work with combineReducers?** Of course, they are just normal reducers after all. Remember that according to the `combineReducers` checks, you will need to provide a default state when creating each reducer before combining them.\n\n- **How does it work?** There is not much magic. A generated id is prepended to each action type and will be used inside reducers instead of the string constants used inside Redux by default.\n\n- **Can you show how different it is from writing classic Redux?** Sure, you can check both commits to update [counter example](https://github.com/pauldijou/redux-act/commit/9e020137fb1b3e1e37d37c434032bec3c4e0873a) and [todomvc example](https://github.com/pauldijou/redux-act/commit/66a07913fdb36c9206e9bcbd5fa5577d1e6eceb7). You can also run both examples with `npm install && npm start` inside each folder.\n\n- **Why having two syntax to create reducers?** The one with only a map of `action => reduce function` doesn\'t allow much. This is why the other one is here, in case you would need a small state inside the reducer, having something similar as an actor, or whatever you feel like. Also, one of the syntax is ES6 only.\n\n- **Inside a reducer, why is it `(state, payload) => newState` rather than `(state, action) => newState`?** You can find more info about that on the `createReducer` API below, but basically, that\'s because an action is composed of metadata handled by the lib and your payload. Since you only care about that part, better to have it directly. You can switch back to the full action if necessary of course.\n\n- **Why have you done that? Aren\'t string constants good enough?** I know that the Redux doc states that such magic isn\'t really good, that saving a few lines of code isn\'t worth hiding such logic. I can understand that. And don\'t get me wrong, the main goal of this lib isn\'t to reduce boilerplate (even if I like that it does) but to use the actions themselves as keys for the reducers rather than strings which are error prone. You never know what the new dev on your project might do... Maybe (s)he will not realize that the new constant (s)he just introduced was already existing and now everything is broken and a wormhole will appear and it will be the end of mankind. Let\'s prevent that!\n\n## Advanced usage\n\n```javascript\nimport { createStore } from \'redux\';\nimport { createAction, createReducer } from \'redux-act\';\n\n// You can create several action creators at once\n// (but that\'s probably not the best way to do it)\nconst [increment, decrement] = [\'inc\', \'dec\'].map(createAction);\n\n// When creating action creators, the description is optional\n// it will only be used for devtools and logging stuff.\n// It\'s better to put something but feel free to leave it empty if you want to.\nconst replace = createAction();\n\n// By default, the payload of the action is the first argument\n// when you call the action. If you need to support several arguments,\n// you can specify a function on how to merge all arguments into\n// an unique payload.\nlet append = createAction(\'optional description\', (...args) => args.join(\'\'));\n\n// There is another pattern to create reducers\n// and it works fine with ES5! (maybe even ES3 \\o/)\nconst stringReducer = createReducer(function (on) {\n  on(replace, (state, payload) => payload);\n  on(append, (state, payload) => state += payload);\n  // Warning! If you use the same action twice,\n  // the second one will override the previous one.\n}, \'missing a lette\'); // <-- Default state\n\n// Rather than binding the action creators each time you want to use them,\n// you can do it once and for all as soon as you have the targeted store\n// assignTo: mutates the action creator itself\n// bindTo: returns a new action creator assigned to the store\nconst stringStore = createStore(stringReducer);\nreplace.assignTo(stringStore);\nappend = append.bindTo(stringStore);\n\n// Now, when calling actions, they will be automatically dispatched\nappend(\'r\'); // stringStore.getState() === \'missing a letter\'\nreplace(\'a\'); // stringStore.getState() === \'a\'\nappend(\'b\', \'c\', \'d\'); // stringStore.getState() === \'abcd\'\n\n// If you really need serializable actions, using string constant rather\n// than runtime generated id, just use a uppercase description (with eventually some underscores)\n// and it will be use as the id of the action\nconst doSomething = createAction(\'STRING_CONSTANT\');\ndoSomething(1); // { type: \'STRING_CONSTANT\', payload: 1}\n\n// Little bonus, if you need to support metadata around your action,\n// like needed data but not really part of the payload, you add a second function\nconst metaAction = createAction(\'desc\', arg => arg, arg => \'so meta!\');\n\n// Metadata will be the third argument of the reduce function\ncreateReducer({\n  [metaAction]: (state, payload, meta) => payload\n});\n```\n\n## API\n\n### createAction([description], [payloadReducer], [metaReducer])\n\n**Parameters**\n\n- **description** (string, optional): used by logging and devtools when displaying the action. If this parameter is uppercase only, with underscores and numbers, it will be used as the action type without any generated id. You can use this feature to have serializable actions you can share between client and server.\n- **payloadReducer** (function, optional): transform multiple arguments as a unique payload.\n- **metaReducer** (function, optional): transform multiple arguments as a unique metadata object.\n\n**Usage**\n\nReturns a new [action creator](#action-creator). If you specify a description, it will be used by devtools. By default, `createAction` will return a function and its first argument will be used as the payload when dispatching the action. If you need to support multiple arguments, you need to specify a **payload reducer** in order to merge all arguments into one unique payload.\n\n```javascript\n// Super simple action\nconst simpleAction = createAction();\n// Better to add a description\nconst betterAction = createAction(\'This is better!\');\n// Support multiple arguments by merging them\nconst multipleAction = createAction((text, checked) => ({text, checked}))\n// Again, better to add a description\nconst bestAction = createAction(\'Best. Action. Ever.\', (text, checked) => ({text, checked}))\n// Serializable action (the description will be used as the unique identifier)\nconst serializableAction = createAction(\'SERIALIZABLE_ACTION_42\');\n```\n\n### action creator\n\nAn action creator is basically a function that takes arguments and return an action which has the following format:\n\n- `type`: generated id + your description.\n- `payload`: the data passed when calling the action creator. Will be the first argument of the function except if you specified a payload reducer when creating the action.\n- `meta`: if you have provided a **metaReducer**, it will be used to create a metadata object assigned to this key. Otherwise, it\'s `undefined`.\n- `error`: a boolean indicating if the action is an error according to [FSA](https://github.com/acdlite/flux-standard-action#error).\n\n```javascript\nconst addTodo = createAction(\'Add todo\');\naddTodo(\'content\');\n// return { type: \'[1] Add todo\', payload: \'content\' }\n\nconst editTodo = createAction(\'Edit todo\', (id, content) => ({id, content}));\neditTodo(42, \'the answer\');\n// return { type: \'[2] Edit todo\', payload: {id: 42, content: \'the answer\'} }\n\nconst serializeTodo = createAction(\'SERIALIZE_TODO\');\nserializeTodo(1);\n// return { type: \'SERIALIZE_TODO\', payload: 1 }\n```\n\nAn action creator has the following methods:\n\n**getType()**\n\nReturn the generated type that will be used by all actions from this action creator. Useful for [compatibility](#compatibility) purposes.\n\n**assignTo(store | dispatch)**\n\nRemember that you still need to dispatch those actions. If you already have one or more stores, you can assign the action using the `assignTo` function. This will mutate the action creator itself. You can pass one store or one dispatch function or an array of any of both.\n\n```javascript\nlet action = createAction();\nlet action2 = createAction();\nconst reducer = createReducer({\n  [action]: (state) => state * 2,\n  [action2]: (state) => state / 2,\n});\nconst store = createStore(reducer, 1);\nconst store2 = createStore(reducer, -1);\n\n// Automatically dispatch the action to the store when called\naction.assignTo(store);\naction(); // store.getState() === 2\naction(); // store.getState() === 4\naction(); // store.getState() === 8\n\n// You can assign the action to several stores using an array\naction.assignTo([store, store2]);\naction();\n// store.getState() === 16\n// store2.getState() === -2\n```\n\n**bindTo(store | dispatch)**\n\nIf you need immutability, you can use `bindTo`, it will return a new action creator which will automatically dispatch its action.\n\n```javascript\n// If you need more immutability, you can bind them, creating a new action creator\nconst boundAction = action2.bindTo(store);\naction2(); // Not doing anything since not assigned nor bound\n// store.getState() === 16\n// store2.getState() === -2\nboundAction(); // store.getState() === 8\n```\n\n**assigned() / bound() / dispatched()**\n\nTest the current status of the action creator.\n\n```javascript\nconst action = createAction();\naction.assigned(); // false, not assigned\naction.bound(); // false, not bound\naction.dispatched(); // false, test if either assigned or bound\n\nconst boundAction = action.bindTo(store);\nboundAction.assigned(); // false\nboundAction.bound(); // true\nboundAction.dispatched(); // true\n\naction.assignTo(store);\naction.assigned(); // true\naction.bound(); // false\naction.dispatched(); // true\n```\n\n**raw(...args)**\n\nWhen an action creator is either assigned or bound, it will no longer only return the action object but also dispatch it. In some cases, you will need the action without dispatching it (when batching actions for example). In order to achieve that, you can use the `raw` method which will return the bare action. You could say that it is exactly the same as the action creator would behave it if wasn\'t assigned nor bound.\n\n```javascript\nconst action = createAction().bindTo(store);\naction(1); // store has been updated\naction.raw(1); // return the action, store hasn\'t been updated\n```\n\n**asError(...args)***\n\nBy default, if your payload is an instance of `Error`, the action will be tagged as an error. But if you need to use any other kind of payload as an error payload, you can always use this method. It will apply the same payload reducer by setting the `error` to `true`.\n\n```javascript\nconst actionCreator = createAction(value => {\n  if (value > 10) { return new Error(\'Must be less than 10\') }\n  return { value: value }\n})\n\nconst goodAction = actionCreator(5)\ngoodAction.error // false\n\nconst badAction = actionCreator(20)\nbadAction.error // true\n\nconst forcedBadAction = actionCreator.asError(1)\nforcedBadAction.error // true\n```\n\n### createReducer(handlers, [defaultState])\n\n**Parameters**\n\n- **handlers** (object or function): if `object`, a map of action to the reduce function. If `function`, take two attributes: a function to register actions and another one to unregister them. See below.\n- **defaultState** (anything, optional): the initial state of the reducer. Must not be empty if you plan to use this reducer inside a `combineReducers`.\n\n**Usage**\n\nReturns a new [reducer](#reducer). It\'s kind of the same syntax as the `Array.prototype.reduce` function. You can specify how to reduce as the first argument and the accumulator, or default state, as the second one. The default state is optional since you can retrieve it from the store when creating it but you should consider always having a default state inside a reducer, especially if you want to use it with `combineReducers` which make such default state mandatory.\n\nThere are two patterns to create a reducer. One is passing an object as a map of `action creators` to `reduce functions`. Such functions have the following signature: `(previousState, payload) => newState`. The other one is using a function factory. Rather than trying to explaining it, just read the following examples.\n\n```javascript\nconst increment = createAction();\nconst add = createAction();\n\n// First pattern\nconst reducerMap = createReducer({\n  [increment]: (state) => state + 1,\n  [add]: (state, payload) => state + payload\n}, 0);\n\n// Second pattern\nconst reducerFactory = createReducer(function (on, off) {\n  on(increment, (state) => state + 1);\n  on(add, (state, payload) => state + payload);\n  // \'off\' remove support for a specific action\n  // See \'Adding and removing actions\' section\n}, 0);\n```\n\n### reducer\n\nLike everything, a reducer is just a function. It takes the current state and an action payload and return the new state. It has the following methods.\n\n**options({ payload: boolean, fallback: [handler] })**\n\nSince an action is an object with a `type`, a `payload` (which is your actual data) and eventually some `metadata`, all reduce functions directly take the payload as their 2nd argument and the metadata as the 3rd by default rather than the whole action since all other properties are handled by the lib and you shouldn\'t care about them anyway. If you really need to use the full action, you can change the behavior of a reducer. Returns the reducer itself for chaining.\n\n```javascript\nconst add = createAction();\nconst sub = createAction();\nconst reducer = createReducer({\n  [add]: (state, action) => state + action.payload,\n  [sub]: (state, action) => state - action.payload\n}, 0);\n\nreducer.options({\n  payload: false\n});\n```\n\nYou can read [a more detailed explanation here](https://github.com/pauldijou/redux-act/issues/49).\n\nIf you specify a `fallback` handler, which has the exact same signature as any action handler inside the reducer, it will be called anytime you dispatch an action which is not handled by the reducer.\n\n```javascript\nconst action = createAction();\nconst reducer = createReducer({}, 0);\nreducer.options({\n  // action is not handled, so fallback will be called\n  fallback: (state, payload) => state + payload,\n});\nconst store = createStore(reducer);\nstore.getState(); // 0\nstore.dispatch(action(5));\nstore.getState(); // 5\nstore.dispatch(action(-10));\nstore.getState(); // -5\n```\n\n**has(action creator)**\n\nTest if the reducer has a reduce function for a particular action creator or a string type.\n\n```javascript\nconst add = createAction();\nconst sub = createAction();\nconst reducer = createReducer({\n  [add]: (state, action) => state + action.payload\n}, 0);\n\nreducer.has(add); // true\nreducer.has(sub); // false\nreducer.has(add.getType()); // true\n```\n\n**on(action creator | action creator[], reduce function)**\n**off(action creator | action creator[])**\n\nYou can dynamically add and remove actions. See the [adding and removing actions](#adding-and-removing-actions) section for more infos. You can use either a `redux-act` action creator or a raw string type. You can also use array of those, it will apply the `on` or `off` function to all elements.\n\nThey both return the reducer itself so you can chain them.\n\n### assignAll(actionCreators, stores)\n\n**Parameters**\n\n- **actionCreators** (object or array): which action creators to assign. If it\'s an object, it\'s a map of name -> action creator, useful when importing several actions at once.\n- **stores** (object or array): the target store(s) when dispatching actions. Can be only one or several inside an array.\n\n**Usage**\n\nA common pattern is to export a set of action creators as an object. If you want to bind all of them to a store, there is this super small helper. You can also use an array of action creators. And since you can bind to one or several stores, you can specify either one store or an array of stores.\n\n```javascript\n// actions.js\nexport const add = createAction(\'Add\');\nexport const sub = createAction(\'Sub\');\n\n// reducer.js\nimport * as actions from \'./actions\';\nexport default createReducer({\n  [actions.add]: (state, payload) => state + payload,\n  [actions.sub]: (state, payload) => state - payload\n}, 0);\n\n// store.js\nimport * as actions from \'./actions\';\nimport reducer from \'./reducer\';\n\nconst store = createStore(reducer);\nassignAll(actions, store);\n\nexport default store;\n```\n\n### bindAll(actionCreators, stores)\n\n**Parameters**\n\n- **actionCreators** (object or array): which action creators to bind. If it\'s an object, it\'s a map of name -> action creator, useful when importing several actions at once.\n- **stores** (object or array): the target store(s) when dispatching actions. Can be only one or several inside an array.\n\n**Usage**\n\nJust like `assignAll`, you can bind several action creators at once.\n\n```javascript\nimport { bindAll } from \'redux-act\';\nimport store from \'./store\';\nimport * as actions from \'./actions\';\n\nexport bindAll(actions, store);\n```\n\n### batch(actions)\n\n**Parameters**\n\n- **actions** (objects | array): wrap an array of actions inside another action and will reduce them all at once when dispatching it. You can also call this function with several actions as arguments.\n\n:warning: **Warning** Does not work with assigned and bound actions by default since those will be dispatched immediately when called. You will need to use the `raw` method for such actions. See usage below.\n\n**Usage**\n\nUseful when you need to run a sequence of actions without impacting your whole application after each one but rather after all of them are done. For example, if you are using `@connect` from `react-redux`, it is called after each action by default. Using `batch`, it will be called only when all actions in the array have been reduced.\n\n`batch` is an action creator like any other created using `createAction`. You can assign or bind it if you want, especially if you only have one store. You can even use it inside reducers. It is enabled by default, but you can remove it and put it back.\n\n```javascript\nimport { createAction, createReducer, batch } from \'redux-act\';\n\n// Basic actions\nconst inc = createAction();\nconst dec = createAction();\n\nconst reducer = createReducer({\n  [inc]: state => state + 1,\n  [dec]: state => state - 1,\n}, 0);\n\nconst store = createStore(reducer);\n// actions as arguments\nstore.dispatch(batch(inc(), inc(), dec(), inc()));\n// actions as an array\nstore.dispatch(batch([inc(), inc(), dec(), inc()]));\nstore.getState(); // 4\n\n// Assigned actions\ninc.assignTo(store);\ndec.assignTo(store);\n\n// You still need to dispatch the batch action\n// You will need to use the \'raw\' function on the action creators to prevent\n// the auto-dipatch from the assigned action creators\nstore.dispatch(batch(inc.raw(), dec.raw(), dec.raw()));\nstore.dispatch(batch([inc.raw(), dec.raw(), dec.raw()]));\nstore.getState(); // 2\n\n// Let\'s de-assign our actions\ninc.assignTo(undefined);\ndec.assignTo(undefined);\n\n// You can bind batch\nconst boundBatch = batch.bindTo(store);\nboundBatch(inc(), inc());\nstore.getState(); // 4\n\n// You can assign batch\nbatch.assignTo(store);\nbatch(dec(), dec(), dec());\nstore.getState(); // 1\n\n// You can remove batch from a reducer\nreducer.off(batch);\nbatch(dec(), dec());\nstore.getState(); // 1\n\n// You can put it back\nreducer.on(batch, (state, payload) => payload.reduce(reducer, state));\nbatch(dec(), dec());\nstore.getState(); // -1\n```\n\n### disbatch(store | dispatch, [actions])\n\n**Parameters**\n\n- **store | dispatch** (object, which is a Redux store, or a dispatch function): add a `disbatch` function to the store if it is the only parameter. Just like `dispatch` but for several actions which will be batched as a single one.\n- **actions** (array, optional): the array of actions to dispatch as a batch of actions.\n\n**Usage**\n\n```javascript\n// All samples will display both syntax with and without an array\n// They are exactly the same\nimport { disbatch } from \'redux-act\';\nimport { inc, dec } from \'./actions\';\n\n// Add \'disbatch\' directly to the store\ndisbatch(store);\nstore.disbatch(inc(), dec(), inc());\nstore.disbatch([inc(), dec(), inc()]);\n\n// Disbatch immediately from store\ndisbatch(store, inc(), dec(), inc());\ndisbatch(store, [inc(), dec(), inc()]);\n\n// Disbatch immediately from dispatch\ndisbatch(store.dispatch, inc(), dec(), inc());\ndisbatch(store.dispatch, [inc(), dec(), inc()]);\n```\n\n### asError(action)\n\n**Parameters**\n\n- **action** (object): a standard Redux action (with a `type` property)\n\nSet the `error` property to `true`.\n\n```javascript\nimport { createAction, asError } from \'redux-act\';\n\nconst goodAction = createAction();\ngoodAction.error; // false\n\nconst badAction = asError(goodAction);\nbadAction.error; // true\n```\n\n### types\n\n**This is mostly internal stuff and is exposed only to help during development and testing.**\n\nAs you know it, each action has a type. `redux-act` will ensure that each action creator type is unique. If you are not using serializable actions, you are good to go as all types will be dynamically generated and unique. But if you do use them, by default, nothing prevent you from creating two action creators with the same type. `redux-act` will throw if you call `createAction` with an already used type, and that is good, except when running tests.\n\nDuring testing, you might need to reset all types, start as fresh, to prevent `redux-act` to throw between tests. To do so, you have a small API to manage types stored by `redux-act`.\n\n```javascript\nimport { types } from \'redux-act\';\n\n// Add a type and prevent any action creator from using it from now on\ntypes.add(\'MY_TYPE\');\ntypes.add(\'MY_TYPE_BIS\');\n\n// Remove a type, you can use it again in an action creator\ntypes.remove(\'MY_TYPE_BIS\');\n\n// Test if a type is already used\ntypes.has(\'MY_TYPE\'); // true\ntypes.has(\'MY_TYPE_BIS\'); // false\n\n// Check if a type is already used,\n// will throw TypeError if so\ntypes.check(\'MY_TYPE\') // throw TypeError\ntypes.check(\'MY_TYPE_BIS\') // do nothing (return undefined)\n\n// Return all used types\ntypes.all(); // [ \'MY_TYPE\' ]\n\n// Remove all types\ntypes.clear();\n\n// Disable all type checking meaning you can now have several actions\n// with the same type. This is needed for HMR (Hot Module Replacement)\n// but never never never enable it in production\ntypes.disableChecking();\n\n// Set back type checking\ntypes.enableChecking();\n```\n\n## Cookbook\n\n### Compatibility\n\n`redux-act` is fully compatible with any other Redux library, it just uses `type` string after all.\n\n:warning: **Warning** It\'s important to remember that all `redux-act` actions will store data inside the `payload` property and that reducers will automatically extract it by default.\n\n```javascript\n// Mixing basic and redux-act actions inside a reducer\nimport { createAction, createReducer } from \'redux-act\';\n\n// Standard Redux action using a string constant\nconst INCREMENT_TYPE = \'INCREMENT\';\nconst increment = () => ({ type: INCREMENT_TYPE });\n\nconst decrement = createAction(\'decrement\');\n\nconst reducer = createReducer({\n  [INCREMENT_TYPE]: (state) => state + 1,\n  [decrement]: (state) => state - 1,\n}, 0);\n\nreducer.has(INCREMENT_TYPE); // true\nreducer.has(decrement); // true\n```\n\n```javascript\n// Using redux-act actions inside a basic reducer\nimport { createAction } from \'redux-act\';\n\n// Standard Redux action using a string constant\nconst INCREMENT_TYPE = \'INCREMENT\';\nconst increment = () => ({ type: INCREMENT_TYPE });\n\nconst decrement = createAction(\'decrement\');\n\nfunction reducer(state = 0, action) {\n  switch (action.type) {\n  case INCREMENT_TYPE:\n    return state + 1;\n    break;\n  case decrement.getType():\n    return state - 1;\n    break;\n  default:\n    return state;\n  }\n};\n```\n\n### Adding and removing actions\n\nUsing the handlers object.\n\n```javascript\nconst handlers = {};\nconst reducer = createReducer(handlers, 0);\nconst store = createStore(reducer);\nconst increment = createAction().assignTo(store);\n\nhandlers[increment] = (state) => state + 1;\n\nincrement(); // store.getState() === 1\nincrement(); // store.getState() === 2\n\ndelete(handlers[increment]);\n\nincrement(); // store.getState() === 2\nincrement(); // store.getState() === 2\n```\n\nUsing the `on` and `off` functions of the reducer. Those functions will be available whatever pattern you used to create the reducer.\n\n```javascript\nconst reducer = createReducer({}, 0);\nconst store = createStore(reducer);\nconst increment = createAction().assignTo(store);\n\nreducer.on(increment, (state) => state + 1);\n\nincrement(); // store.getState() === 1\nincrement(); // store.getState() === 2\n\nreducer.off(increment);\n\nincrement(); // store.getState() === 2\nincrement(); // store.getState() === 2\n```\n\nUsing the `on` and `off` functions of the function factory when creating the reducer.\n\n```javascript\nconst store = createStore(()=> 0));\nconst increment = createAction().assignTo(store);\nconst reducer = createReducer(function (on, off) {\n  on(increment, state => {\n    // Just for fun, we will disable increment when reaching 2\n    // (but we will still increment one last time)\n    if (state === 2) {\n      off(increment);\n    }\n    return state + 1;\n  });\n}, 0);\n\nstore.replaceReducer(reducer);\n\nincrement(); // store.getState() === 1\nincrement(); // store.getState() === 2\nincrement(); // store.getState() === 3\nincrement(); // store.getState() === 3\nincrement(); // store.getState() === 3\n```\n\n### Async actions\n\n```javascript\nimport {createStore, applyMiddleware} from \'redux\';\nimport thunkMiddleware from \'redux-thunk\';\nimport {createAction, createReducer} from \'redux-act\';\n\nconst start = createAction();\nconst success = createAction();\n\nconst reducer = createReducer({\n  [start]: (state) => ({ ...state, running: true }),\n  [success]: (state, result) => ({ running: false, result })\n}, {\n  running: false,\n  result: false\n});\n\n// 1) You can use the same way as the Redux samples\n// using thunk middleware\nconst createStoreWithMiddleware = applyMiddleware(\n  thunkMiddleware\n)(createStore);\n\nconst store = createStoreWithMiddleware(reducer);\n\nfunction fetch() {\n  // We don\'t really need the dispatch\n  // but here it is if you don\'t bind your actions\n  return function (dispatch) {\n    // state: { running: false, result: false }\n    dispatch(start());\n    // state: { running: true, result: false }\n    return new Promise(resolve => {\n      // Here, you should probably do a real async call,\n      // like, you know, XMLHttpRequest or Global.fetch stuff\n      setTimeout(() =>\n        resolve(1)\n      , 5);\n    }).then(result=>\n      dispatch(success(result))\n      // state: { running: false, result: 1 }\n    );\n  };\n}\n\nstore.dispatch(fetch()).then(() => {\n  // state: { running: false, result: 1 }\n});\n\n// 2) You can enjoy the redux-act binding\n// and directly call the actions\nconst store = createStore(reducer);\n\nstart.assignTo(store);\nsuccess.assignTo(store);\n\nfunction fetch() {\n  // state: { running: false, result: false }\n  start();\n  // state: { running: true, result: false }\n  return new Promise(resolve => {\n    // Here, you should probably do a real async call,\n    // like, you know, XMLHttpRequest or Global.fetch stuff\n    setTimeout(() =>\n      resolve(1)\n    , 5);\n  }).then(result=>\n    success(result)\n    // state: { running: false, result: 1 }\n  );\n}\n\nfetch().then(() => {\n  // state: { running: false, result: 1 }\n});\n```\n\n### Enable or disable batch\n\nSince `batch` is an action creator like any other, you can add and remove it from any reducer.\n\n```javascript\nimport { createReducer, batch } from \'redux-act\';\nconst reducer = createReducer({});\n\n// Reducer no longer support batched actions\nreducer.off(batch);\n\n// Put it back using the reducer itself as the reduce function\nreducer.on(batch, (state, payload) => payload.reduce(reducer, state));\n\n// Be careful if \'payload\' option is false\nreducer.options({ payload: false });\nreducer.on(batch, (state, action) => action.payload.reduce(reducer, state));\n```\n\n### TypeScript\n\nWe\'ve built some basic typings around this API that will help TypeScript identify potential issues in your code.\n\nYou can use any of the existing methods to create reducers and TypeScript will work (as a superset of Javascript) but that kind of defeats some of the benefits of TypeScript. For this reason, the following is the recommended way to create a reducer.\n\n```typescript\nimport { createReducer, createAction } from \'redux-act\';\n\nconst defaultState = {\n\tcount: 0,\n  otherProperties: any,\n  ...\n};\n\nconst add = createAction<number>(\'Increase count\');\n\nconst reducer = createReducer<typeof defaultState>({}, defaultState);\n\nreducer.on(add, (state, payload) => ({\n\t...state,\n\tcount: state.count + payload\n}));\n```\n\nUsing the `reducer.on()` API, TypeScript will identify the payload set on `add` and provide that type as payload. This can be really handy once your code starts scaling up.\n\n#### Caveats\n\nDue to some limitations on TypeScript typings, action creators have some limitations but you can create typed action creators assuming you have no payload reducer.\n\n```typescript\nimport { createAction } from \'redux-act\';\n\nconst action = createAction<boolean>(\'Some type\');\nconst emptyAction = createAction(\'Another type\');\nconst otherAction = createAction<boolean>(\'Other action\', (arg1, arg2) => ({ arg1, arg2 }));\n```\n\n`action` and `emptyAction` will provide typing support, making sure `action` is provided a boolean as first and only argument, or `emptyAction` is not provided any argument at all.\n\n`otherAction`, on the otherhand, will be able to be called with any arguments, regardless of what the payload reducer expects.\n\n\n## Loggers\n\n`redux-act` provides improved logging with some loggers, mostly for batched actions.\n\nMissing your favorite one? Please open an issue or a pull request, it will be added as soon as possible.\n\n### [Redux Logger](https://github.com/fcomb/redux-logger)\n\n```javascript\nimport { applyMiddleware, createStore } from \'redux\';\nimport createLogger from \'redux-logger\';\nimport { loggers } from \'redux-act\';\n\n// Init logger\nconst logger = createLogger({\n  ...loggers.reduxLogger,\n  // You can  add you own options after that\n});\n\n// Same as\nconst logger = createLogger({\n  actionTransformer: loggers.reduxLogger.actionTransformer,\n  logger: loggers.reduxLogger.logger,\n  // You can  add you own options after that\n});\n\n// Create the store\nconst store = applyMiddleware(logger)(createStore)(/* reducer */);\n```\n\n## Thanks\n\nA big thank to both [@gaearon](https://github.com/gaearon) for creating [Redux](https://github.com/rackt/redux) and [@AlexGalays](https://github.com/AlexGalays) for creating [fluxx](https://github.com/AlexGalays/fluxx) which I took a lot of inspiration from.\n\n## Tests\n\nIf you need to run the tests, just use `npm test` or `npm run coverage` if you want to generate the coverage report.\n\n## License\n\nThis software is licensed under the Apache 2 license, quoted below.\n\nCopyright 2015 Paul Dijou ([http://pauldijou.fr](http://pauldijou.fr)).\n\nLicensed under the Apache License, Version 2.0 (the "License"); you may not use this project except in compliance with the License. You may obtain a copy of the License at [http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0).\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n'