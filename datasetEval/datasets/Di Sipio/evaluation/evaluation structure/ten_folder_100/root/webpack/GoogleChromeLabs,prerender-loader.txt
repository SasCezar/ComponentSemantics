b'<p align="center">\n  <img src="https://i.imgur.com/BL0lf5F.png" width="240" height="240" alt="prerender-loader">\n  <h1 align="center">\n    prerender-loader\n    <a href="https://www.npmjs.org/package/prerender-loader"><img src="https://img.shields.io/npm/v/prerender-loader.svg?style=flat" alt="npm"></a>\n  </h1>\n</p>\n\nPainless universal prerendering for Webpack. Works great with\n[html-webpack-plugin].\n\n> \xf0\x9f\xa7\x90 **What is Prerendering?**\n>\n>Pre-rendering describes the process of rendering a client-side application at\n>build time, producing useful static HTML that can be sent to the browser\n>instead of an empty bootstrapping page.\n>\n>Pre-rendering is like Server-Side Rendering, just done at build time to produce\n>static files. Both techniques help get meaningful content onto the user\'s\n>screen faster.\n\n## Features\n\n-   Works entirely within Webpack\n-   Integrates with [html-webpack-plugin]\n-   Works with `webpack-dev-server` / `webpack serve`\n-   Supports both DOM and String prerendering\n-   Asynchronous rendering via async/await or Promises\n\n---\n\n<!-- TOC depthFrom:2 -->\n\n- [Features](#features)\n- [How does it work?](#how-does-it-work)\n- [Installation](#installation)\n- [Usage](#usage)\n  - [DOM Prerendering](#dom-prerendering)\n  - [String Prerendering](#string-prerendering)\n  - [Injecting content into the HTML](#injecting-content-into-the-html)\n  - [Prerendering JavaScript Files](#prerendering-javascript-files)\n- [Options](#options)\n- [License](#license)\n\n<!-- /TOC -->\n\n## How does it work?\n\n`prerender-loader` renders your web application within Webpack during builds,\nproducing static HTML. When the loader is applied to an HTML file, it creates a\nDOM structure from that HTML, compiles the application, runs it within the DOM\nand serializes the result back to HTML.\n\n---\n\n## Installation\n\nFirst, install `prerender-loader` as a development dependency:\n\n```sh\nnpm i -D prerender-loader\n```\n\n---\n\n## Usage\n\nIn most cases, you\'ll want to apply the loader to your `html-webpack-plugin`\ntemplate option:\n\n```diff\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n-     template: \'index.html\',\n+     template: \'!!prerender-loader?string!index.html\',\n\n      // any other options you\'d normally set are still supported:\n      compile: false,\n      inject: true\n    })\n  ]\n}\n```\n\nWhat does all that punctuation mean? Let\'s break the whole loader string\ndown:\n\n> In Webpack, a module identifier beginning with `!!` will bypass any configured\n>loaders from `module.rules` - here we\'re saying "don\'t do anything to\n>`index.html` except what I\'ve defined here\n>\n>The `?string` parameter tells `prerender-loader` to output an ES module\n>exporting the prerendered HTML string, rather than returning the HTML directly.\n>\n>Finally, everything up to the last `!` in a module identifier is the inline\n>loader definition (the transforms to apply to a given module).  The filename of\n>the module to load comes after the `!`.\n>\n>**Note:** If you\'ve already set up `html-loader` or `raw-loader` to handle\n>`.html` files, you can skip both options and simply pass a `template` value of\n>`"prerender-loader!index.html"`!\n\nAs with any loader, it is also possible to apply `prerender-loader` on-the-fly\n:\n\n```js\nconst html = require(\'prerender-loader?!./app.html\');\n```\n\n... or in your Webpack configuration\'s `module.rules` section:\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: \'src/index.html\',\n        loader: \'prerender-loader?string\'\n      }\n    ]\n  }\n}\n```\n\n\nOnce you have `prerender-loader` in-place, prerendering is now turned on. During\nyour build, the app will be executed, with any modifications it makes to\n`index.html` will be saved to disk.  This is fine for the needs of many apps,\nbut you can also take more explicit control over your prerendering: either using\nthe DOM or by rendering to a String.\n\n### DOM Prerendering\n\nDuring prerendering, your application gets compiled and run directly under\nNodeJS, but within a [JSDOM] container so that you can use the familiar browser\nglobals like `document` and `window`.\n\nHere\'s an example `entry` module that uses DOM prerendering:\n\n```js\nimport { render } from \'fancy-dom-library\';\nimport App from \'./app\';\n\nexport default () => {\n  render(<App />, document.body);\n};\n```\n\nIn all cases, asynchronous functions and callbacks are supported:\n\n```js\nimport { mount } from \'other-fancy-library\';\nimport app from \'./app\';\n\nexport default async function prerender() {\n  let res = await fetch(\'https://example.com\');\n  let data = await res.json();\n  mount(app(data), document.getElementById(\'app\'));\n}\n```\n\n### String Prerendering\n\nIt\'s also possible to export a function from your Webpack entry module, which\ngives you full control over prerendering: `prerender-loader` will call the\nfunction and its return value will be used as the static HTML.  If the exported\nfunction returns a Promise, it will be awaited and the resolved value will be\nused.\n\n```js\nimport { renderToString } from \'react-dom\';\nimport App from \'./app\';\n\nexport default () => {\n  const html = renderToString(<App />);\n  // returned HTML will be injected into <body>:\n  return html;\n};\n```\n\nIn addition to DOM and String prerendering, it\'s also possible to use a\ncombination of the two.  If an application\'s Webpack entry exports a prerender\nfunction that doesn\'t return a value, the default DOM serialization will kick\nin, just like in DOM prerendering. This means you can use your exported\nprerender function to trigger DOM manipulation ("client-side" rendering), and\nthen just let `prerender-loader` handle generating the static HTML for whatever\ngot rendered.\n\nHere\'s an example that renders a [Preact] application and waits for DOM\nrendering to settle down before allowing prerender-loader to serialize the\ndocument to static HTML:\n\n```js\nimport { h, options } from \'preact\';\nimport { renderToString } from \'preact\';\nimport App from \'./app\';\n\n// we\'re done when there are no renders for 50ms:\nconst IDLE_TIMEOUT = 50;\n\nexport default () => new Promise(resolve => {\n  let timer;\n  // each time preact re-renders, reset our idle timer:\n  options.debounceRendering = commit => {\n    clearTimeout(timer);\n    timer = setTimeout(resolve, IDLE_TIMEOUT);\n    commit();\n  };\n\n  // render into <body> using normal client-side rendering:\n  render(<App />, document.body);\n});\n```\n\n### Injecting content into the HTML\n\nWhen applied to a `.html` file, `prerender-loader` will inject prerendered\ncontent at the end of `<body>` by default.  If you want to place the content\nsomewhere else, you can add a `{{prerender}}` field:\n\n```html\n<html>\n  <body>\n    <div id="app_root">\n      <!-- Inject any pre-rendered HTML here: -->\n      {{prerender}}\n    </div>\n  </body>\n</html>\n```\n\nThis works well if you intend to provide a prerender function that only returns\nyour application\'s HTML structure, not the full document\'s HTML.\n\n### Prerendering JavaScript Files\n\nIn addition to processing `.html` files, the loader can also directly pre-render\n`.js` scripts. The only difference is that the DOM used for prerender will be\ninitially empty:\n\n```js\nconst prerenderedHtml = require(\'!prerender-loader?string!./app.js\');\n```\n\n---\n\n## Options\n\nAll options are ... optional.\n\n| Option        | Type    | Default            | Description                                                            |\n| ------------- | ------- | ------------------ | ---------------------------------------------------------------------- |\n| `string`      | boolean | false              | Output a JS module exporting an HTML String instead of the HTML itself |\n| `disabled`    | boolean | false              | Bypass the loader entirely (but still respect `options.string`)        |\n| `documentUrl` | string  | \'http://localhost\' | Change the jsdom\'s URL (affects `window.location`, `document.URL`...)  |\n| `params`      | object  | null               | Options to pass to your prerender function                             |\n\n\n---\n\n## License\n\n[Apache 2.0](LICENSE)\n\nThis is not an official Google product.\n\n[html-webpack-plugin]: https://github.com/jantimon/html-webpack-plugin\n[JSDOM]: https://github.com/jsdom/jsdom\n[Preact]: https://preactjs.com\n'