b'![repo-banner](https://user-images.githubusercontent.com/4060187/34948491-454de294-f9db-11e7-8fc5-86985ba05be8.png)\n\n# After.js\n\n[![Known Vulnerabilities](https://snyk.io/test/github/jaredpalmer/after.js/badge.svg?targetFile=package.json)](https://snyk.io/test/github/jaredpalmer/after.js?targetFile=package.json)\n\nIf [Next.js](https://github.com/zeit/next.js) and [React Router](https://github.com/reacttraining/react-router) had a baby...\n\n## Project Goals / Philosophy / Requirements\n\nNext.js is awesome. However, its routing system isn\'t for me. IMHO React Router 4 is a better foundation upon which such a framework should be built....and that\'s the goal here:\n\n* Routes are just components and don\'t / should not have anything to do with folder structure. Static route configs are fine.\n* Next.js\'s `getInitialProps` was/is a brilliant idea.\n* Route-based code-splitting should come for free or be easy to opt into.\n* Route-based transitions / analytics / data loading / preloading etc. , should either come for free or be trivial to implement on your own.\n\n**Table of Contents**\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n- [After.js](#afterjs)\n\t- [Project Goals / Philosophy / Requirements](#project-goals--philosophy--requirements)\n\t- [Getting Started with After.js](#getting-started-with-afterjs)\n\t\t- [Razzle Quickstart](#razzle-quickstart)\n\t- [Data Fetching](#data-fetching)\n\t\t- [`getInitialProps: (ctx) => Data`](#getinitialprops-ctx--data)\n\t\t- [Injected Page Props](#injected-page-props)\n\t- [Routing](#routing)\n\t\t- [Parameterized Routing](#parameterized-routing)\n\t\t- [Client Only Data and Routing](#client-only-data-and-routing)\n\t\t- [Dynamic 404 and Redirects](#dynamic-404-and-redirects)\n\t\t- [Dynamic 404](#dynamic-404)\n\t\t- [Redirect](#redirect)\n\t- [Code Splitting](#code-splitting)\n\t- [Custom `<Document>`](#custom-document)\n\t- [Custom/Async Rendering](#customasync-rendering)\n\t- [Author](#author)\n\t- [Inspiration](#inspiration)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n## Getting Started with After.js\n\nAfter.js enables Next.js-like data fetching with any React SSR app that uses React Router 4.\n\n### Razzle Quickstart\n\nYou can quickly bootstrap an SSR React app with After.js using Razzle. While Razzle is not required, this documentation assumes you have the tooling setup for an isomorphic React application.\n\n```bash\nyarn global add create-razzle-app\ncreate-razzle-app --example with-afterjs myapp\ncd myapp\nyarn start\n```\n\nRefer to [Razzle\'s](https://github.com/jaredpalmer/razzle) docs for tooling, babel, and webpack customization.\n\n## Data Fetching\n\nFor page components, you can add a `static async getInitialProps` function.\nThis will be called on both initial server render, and then client mounts.\nResults are made available on `this.props`.\n\n```js\n// ./src/About.js\nimport React from \'react\';\nimport { NavLink } from \'react-router-dom\';\n\nclass About extends React.Component {\n  static async getInitialProps({ req, res, match }) {\n    const stuff = await CallMyApi();\n    return { stuff };\n  }\n\n  render() {\n    return (\n      <div>\n        <NavLink to="/">Home</NavLink>\n        <NavLink to="/about">About</NavLink>\n        <h1>About</h1>\n        {this.props.stuff ? this.props.stuff : \'Loading...\'}\n      </div>\n    );\n  }\n}\n\nexport default About;\n```\n\n### `getInitialProps: (ctx) => Data`\n\nWithin `getInitialProps`, you have access to all you need to fetch data on both\nthe client and the server:\n\n* `req?: Request`: (server-only) An Express.js request object\n* `res?: Request`: (server-only) An Express.js response object\n* `match`: React Router 4\'s `match` object.\n* `history`: React Router 4\'s `history` object.\n* `location`: (client-only) React Router 4\'s `location` object.\n\n### Injected Page Props\n\n* Whatever you have returned in `getInitialProps`\n* `prefetch: (pathname: string) => void` - Imperatively prefetch _and cache_ data for a path. Under the hood this will map through your route tree, call the matching route\'s `getInitialProps`, store it, and then provide it to your page component. If the user ultimately navigates to that path, the data and component will be ready ahead of time. In the future, there may be more options to control cache behavior in the form of a function or time in milliseconds to keep that data around.\n* `refetch: (nextCtx?: any) => void` - Imperatively call `getInitialProps` again\n\n## Routing\n\nAs you have probably figured out, React Router 4 powers all of After.js\'s\nrouting. You can use any and all parts of RR4.\n\n### Parameterized Routing\n\n```js\n// ./src/routes.js\nimport Home from \'./Home\';\nimport About from \'./About\';\nimport Detail from \'./Detail\';\n\n// Internally these will become:\n// <Route path={path} exact={exact} render={props => <component {...props} data={data} />} />\nconst routes = [\n  {\n    path: \'/\',\n    exact: true,\n    component: Home,\n  },\n  {\n    path: \'/about\',\n    component: About,\n  },\n  {\n    path: \'/detail/:id\',\n    component: Detail,\n  },\n];\n\nexport default routes;\n```\n\n```js\n// ./src/Detail.js\nimport React from \'react\';\nimport { Route } from \'react-router-dom\';\n\nclass Detail extends React.Component {\n  // Notice that this will be called for\n  // /detail/:id\n  // /detail/:id/more\n  // /detail/:id/other\n  static async getInitialProps({ req, res, match }) {\n    const item = await CallMyApi(`/v1/item${match.params.id}`);\n    return { item };\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Detail</h1>\n        {this.props.item ? this.props.item : \'Loading...\'}\n        <Route\n          path="/detail/:id/more"\n          exact\n          render={() => <div>{this.props.item.more}</div>}\n        />\n        <Route\n          path="/detail/:id/other"\n          exact\n          render={() => <div>{this.props.item.other}</div>}\n        />\n      </div>\n    );\n  }\n}\n\nexport default Detail;\n```\n\n### Client Only Data and Routing\n\nIn some parts of your application, you may not need server data fetching at all\n(e.g. settings). With After.js, you just use React Router 4 as you normally\nwould in client land: You can fetch data (in componentDidMount) and do routing\nthe same exact way.\n\n### Dynamic 404 and Redirects\n\nReact Router 4 can detect No Match (404) Routes and show a fallback component, you can define your custom fallback component in `routes.js` file.\n\n```js\n// ./src/routes.js\nimport React from \'react\';\nimport Home from \'./Home\';\nimport Notfound  from \'./Notfound\';\nimport { asyncComponent } from \'@jaredpalmer/after\';\n\nexport default [\n  // normal route\n  {\n    path: \'/\',\n    exact: true,\n    component: Home,\n\t},\n\t// 404 route\n\t{\n\t\t// there is no need to declare path variable \n\t\t// react router will pick this component as fallback\n\t\tcomponent: Notfound\n\t}\n];\n```\n\nNotfound component must set `staticContext.statusCode` to 404 so express can set response status code [more info](https://reacttraining.com/react-router/web/guides/server-rendering/404-401-or-any-other-status).\n\n```js\n// ./src/Notfound.js\nimport React from \'react\';\nimport { Route } from "react-router-dom"\n\nfunction NotFound() {\n  return (\n    <Route\n      render={({ staticContext }) => {\n        if (staticContext) staticContext.statusCode = 404;\n        return <div>The Page You Were Looking For Was Not Found</div>;\n      }}\n    />\n  )\n}\n\nexport default NotFound;\n```\n\nif you don\'t declare 404 component in `routes.js` After.js will use it\'s default fallback.\n\n### Dynamic 404\n\nSometimes you may need to send 404 response based on some api response, in this case react router don\'t show fallback and you have to check for that in your component.\n\n```js\nimport Notfound from "./Notfound"\n\nfunction ProductPage({ product, error }) {\n\n  if (error) {\n    if (error.response.status === 404) {\n      return <Notfound />\n    }\n\n    return <p>Something went Wrong !</p>\n  }\n  {/* if there was no errors we have our data */}\n  return <h1>{product.name}</h1>\n}\n\nProductPage.getInitialProps = async ({ match }) => {\n  try {\n    const { data } = await fetchProduct(match.params.slug)\n    return { product: data }\n  } catch (error) {\n    return { error }\n  }\n}\n```\n\nthis makes code unreadable and hard to maintain. after.js makes this easy by providing an api for handling Dynamic 404 pages. you can return `{ statusCode: 404 }` from `getInitialProps` and after.js will show 404 fallback component that you defined in `routes.js` for you.\n\n```js\nfunction ProductPage({ product }) {\n  if (error) {\n\t\t{/* you can ignore error and catch it in ComponentDidCatch too ! */}\n    return <p>Something went Wrong !</p>\n  }\n\n  return <h1>{product.name}</h1>\n}\n\nProductPage.getInitialProps = async ({ match }) => {\n  try {\n    const { data } = await fetchProduct(match.params.slug)\n    return { product: data }\n  } catch (error) {\n    if (error.response.status === 404) return { statusCode: 404 }\n    return { error }\n  }\n}\n```\n\n### Redirect\n\nYou can redirect user to other route by using `Redirect` from react router, but it can make your code unreadable and hard to maintain. \nwith after.js you can redirect client to other route by returning `{ redirectTo: "/new-location" }` from `getInitialProps`.\nthis can become handy for authorization, when user dose not have premissions to access specific route and you can redirect him/her to login page.\n\n```js\nDashboard.getInitialProps = async ({ match }) => {\n  try {\n    const { data } = await fetchProfile()\n    return { data }\n  } catch (error) {\n    if (error.response.status === 401) return { statusCode: 401, redirectTo: "/login" }\n    return { error }\n  }\n}\n```\nRedirect will happen before after.js start render react to string soo it\'s fast.\nwhen using `redirectTo` default value for `statusCode` is 301, but you can use any numeric value you want. \n\n## Code Splitting\n\nAfter.js lets you easily define lazy-loaded or code-split routes in your `_routes.js` file. To do this, you\'ll need to modify the relevant route\'s `component` definition like so:\n\n```js\n// ./src/_routes.js\nimport React from \'react\';\nimport Home from \'./Home\';\nimport { asyncComponent } from \'@jaredpalmer/after\';\n\nexport default [\n  // normal route\n  {\n    path: \'/\',\n    exact: true,\n    component: Home,\n  },\n  // codesplit route\n  {\n    path: \'/about\',\n    exact: true,\n    component: asyncComponent({\n      loader: () => import(\'./About\'), // required\n      Placeholder: () => <div>...LOADING...</div>, // this is optional, just returns null by default\n    }),\n  },\n];\n```\n\n## Custom `<Document>`\n\nAfter.js works similarly to Next.js with respect to overriding HTML document structure. This comes in handy if you are using a CSS-in-JS library or just want to collect data out of react context before or after render. To do this, create a file in `./src/Document.js` like so:\n\n```js\n// ./src/Document.js\nimport React from \'react\';\nimport { AfterRoot, AfterData } from \'@jaredpalmer/after\';\n\nclass Document extends React.Component {\n  static async getInitialProps({ assets, data, renderPage }) {\n    const page = await renderPage();\n    return { assets, data, ...page };\n  }\n\n  render() {\n    const { helmet, assets, data } = this.props;\n    // get attributes from React Helmet\n    const htmlAttrs = helmet.htmlAttributes.toComponent();\n    const bodyAttrs = helmet.bodyAttributes.toComponent();\n\n    return (\n      <html {...htmlAttrs}>\n        <head>\n          <meta httpEquiv="X-UA-Compatible" content="IE=edge" />\n          <meta charSet="utf-8" />\n          <title>Welcome to the Afterparty</title>\n          <meta name="viewport" content="width=device-width, initial-scale=1" />\n          {helmet.title.toComponent()}\n          {helmet.meta.toComponent()}\n          {helmet.link.toComponent()}\n          {assets.client.css && (\n            <link rel="stylesheet" href={assets.client.css} />\n          )}\n        </head>\n        <body {...bodyAttrs}>\n          <AfterRoot />\n          <AfterData data={data} />\n          <script\n            type="text/javascript"\n            src={assets.client.js}\n            defer\n            crossOrigin="anonymous"\n          />\n        </body>\n      </html>\n    );\n  }\n}\n\nexport default Document;\n```\n\nIf you were using something like `styled-components`, and you need to wrap you entire app with some sort of additional provider or function, you can do this with `renderPage()`.\n\n```js\n// ./src/Document.js\nimport React from \'react\';\nimport { ServerStyleSheet } from \'styled-components\'\nimport { AfterRoot, AfterData } from \'@jaredpalmer/after\';\n\nexport default class Document extends React.Component {\n  static async getInitialProps({ assets, data, renderPage }) {\n    const sheet = new ServerStyleSheet()\n    const page = await renderPage(App => props => sheet.collectStyles(<App {...props} />))\n    const styleTags = sheet.getStyleElement()\n    return { assets, data, ...page, styleTags};\n  }\n\n render() {\n    const { helmet, assets, data, styleTags } = this.props;\n    // get attributes from React Helmet\n    const htmlAttrs = helmet.htmlAttributes.toComponent();\n    const bodyAttrs = helmet.bodyAttributes.toComponent();\n\n    return (\n      <html {...htmlAttrs}>\n        <head>\n          <meta httpEquiv="X-UA-Compatible" content="IE=edge" />\n          <meta charSet="utf-8" />\n          <title>Welcome to the Afterparty</title>\n          <meta name="viewport" content="width=device-width, initial-scale=1" />\n          {helmet.title.toComponent()}\n          {helmet.meta.toComponent()}\n          {helmet.link.toComponent()}\n          {/** here is where we put our Styled Components styleTags... */}\n          {styleTags}\n        </head>\n        <body {...bodyAttrs}>\n          <AfterRoot />\n          <AfterData data={data}/>\n          <script\n            type="text/javascript"\n            src={assets.client.js}\n            defer\n            crossOrigin="anonymous"\n          />\n        </body>\n      </html>\n    );\n  }\n}\n```\n\nTo use your custom `<Document>`, pass it to the `Document` option of your After.js `render` function.\n\n```js\n// ./src/server.js\nimport express from \'express\';\nimport { render } from \'@jaredpalmer/after\';\nimport routes from \'./routes\';\nimport MyDocument from \'./Document\';\n\nconst assets = require(process.env.RAZZLE_ASSETS_MANIFEST);\n\nconst server = express();\nserver\n  .disable(\'x-powered-by\')\n  .use(express.static(process.env.RAZZLE_PUBLIC_DIR))\n  .get(\'/*\', async (req, res) => {\n    try {\n      // Pass document in here.\n      const html = await render({\n        req,\n        res,\n        document: MyDocument,\n        routes,\n        assets,\n      });\n      res.send(html);\n    } catch (error) {\n      console.log(error);\n      res.json(error);\n    }\n  });\n\nexport default server;\n```\n\n## Custom/Async Rendering\n\nYou can provide a custom (potentially async) rendering function as an option to After.js `render` function.\n\nIf present, it will be used instead of the default ReactDOMServer renderToString function.\n\nIt has to return an object of shape `{ html : string!, ...otherProps }`, in which `html` will be used as the rendered string\n\nThus, setting `customRenderer = (node) => ({ html: ReactDOMServer.renderToString(node) })` is the the same as default option.\n\n`otherProps` will be passed as props to the rendered Document\n\nExample :\n\n```js\n// ./src/server.js\nimport React from \'react\';\nimport express from \'express\';\nimport { render } from \'@jaredpalmer/after\';\nimport { renderToString } from \'react-dom/server\';\nimport { ApolloProvider, getDataFromTree } from \'react-apollo\';\nimport routes from \'./routes\';\nimport createApolloClient from \'./createApolloClient\';\nimport Document from \'./Document\';\n\nconst assets = require(process.env.RAZZLE_ASSETS_MANIFEST);\n\nconst server = express();\nserver\n  .disable(\'x-powered-by\')\n  .use(express.static(process.env.RAZZLE_PUBLIC_DIR))\n  .get(\'/*\', async (req, res) => {\n    const client = createApolloClient({ ssrMode: true });\n\n    const customRenderer = node => {\n      const App = <ApolloProvider client={client}>{node}</ApolloProvider>;\n      return getDataFromTree(App).then(() => {\n        const initialApolloState = client.extract();\n        const html = renderToString(App);\n        return { html, initialApolloState };\n      });\n    };\n\n    try {\n      const html = await render({\n        req,\n        res,\n        routes,\n        assets,\n        customRenderer,\n        document: Document,\n      });\n      res.send(html);\n    } catch (error) {\n      res.json(error);\n    }\n  });\n\nexport default server;\n```\n\n## Author\n\n* Jared Palmer [@jaredpalmer](https://twitter.com/jaredpalmer)\n\n## Inspiration\n\n* [Razzle](https://github.com/jaredpalmer/razzle)\n* [Next.js](https://github.com/zeit/next.js)\n\n---\n\n> MIT License\n'