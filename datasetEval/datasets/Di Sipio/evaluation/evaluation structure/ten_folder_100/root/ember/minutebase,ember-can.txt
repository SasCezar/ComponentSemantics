b'# Ember-can\n\n<p align="center">\n  <a href="http://badge.fury.io/js/ember-can" title="Package version">\n    <img src="https://badge.fury.io/js/ember-can.svg"/>\n  </a>\n\n  <a href="https://emberobserver.com/addons/ember-can" title="Ember Observer">\n    <img src="http://emberobserver.com/badges/ember-can.svg" alt="Ember Observer"/>\n  </a>\n\n  <a href="https://travis-ci.org/minutebase/ember-can" title="Travis CI status">\n    <img src="https://travis-ci.org/minutebase/ember-can.svg?branch=master" alt="Travis CI Status"/>\n  </a>\n\n  <a href="https://david-dm.org/minutebase/ember-can" title="dependencies status">\n    <img src="https://david-dm.org/minutebase/ember-can/status.svg"/>\n  </a>\n</p>\n\n___\n\nSimple authorisation addon for Ember.\n\n## Installation\n\nInstall this addon via ember-cli:\n\n```\nember install ember-can\n```\n\n## Compatibility\n\n* Ember.js v3.4 or above\n* Ember CLI v2.13 or above\n* Node.js v8 or above\n\n## Quick Example\n\nYou want to conditionally allow creating a new blog post:\n\n```hbs\n{{#if (can "create post")}}\n  Type post content here...\n{{else}}\n  You can\'t write a new post!\n{{/if}}\n```\n\nWe define an ability for the `Post` model in `/app/abilities/post.js`:\n\n```js\n// app/abilities/post.js\n\nimport { readOnly } from \'@ember/object/computed\';\nimport { Ability } from \'ember-can\';\n\nexport default Ability.extend({\n  session: service(),\n\n  user: readOnly(\'session.currentUser\'),\n\n  canCreate: readOnly(\'user.isAdmin\')\n});\n```\n\nWe can also re-use the same ability to check if a user has access to a route:\n\n```js\n// app/routes/posts/new.js\n\nimport Route from \'@ember/routing/route\';\nimport { inject as service } from \'@ember/service\';\n\nexport default Route.extend({\n  can: service(),\n\n  beforeModel(transition) {\n    let result = this._super(...arguments);\n\n    if (this.can.cannot(\'create post\')) {\n      transition.abort();\n      return this.transitionTo(\'index\');\n    }\n\n    return result;\n  }\n});\n```\n\nAnd we can also check the permission before firing action:\n\n```js\nimport Component from \'@ember/component\';\n\nexport default Component.extend({\n  can: service(),\n\n  actions: {\n    createPost() {\n      if (this.can.can(\'create post\', this.post)) {\n        // create post!\n      }\n    }\n  }\n});\n```\n\n## Helpers\n\n### `can`\n\nThe `can` helper is meant to be used with `{{if}}` and `{{unless}}` to protect a block (but can be used anywhere in the template).\n\n```hbs\n{{can "doSth in myModel" model extraProperties}}\n```\n- `"doSth in myModel" ` - The first parameter is a string which is used to find the ability class call the appropriate property (see [Looking up abilities](#looking-up-abilities)).\n\n- `model` - The second parameter is an optional model object which will be given to the ability to check permissions.\n\n- `extraProperties` - The third parameter are extra properties which will be assigned to the ability\n\n**As activities are standard Ember objects and computed properties if anything changes then the view will\nautomatically update accordingly.**\n\n#### Example\n```hbs\n{{#if (can "edit post" post)}}\n  ...\n{{else}}\n  ...\n{{/if}}\n```\n\nAs it\'s a sub-expression, you can use it anywhere a helper can be used.\nFor example to give a div a class based on an ability you can use an inline if:\n\n```hbs\n<div class={{if (can "edit post" post) "is-editable"}}>\n\n</div>\n```\n\n### `cannot`\n\nCannot helper is a negation of `can` helper with the same API.\n\n```hbs\n{{cannot "doSth in myModel" model extraProperties}}\n```\n\n\n## Abilities\n\nAn ability class protects an individual model which is available in the ability as `model`.\n\n**Please note that all abilites names have to be in singular form**\n\n```js\n// app/abilities/post.js\n\nimport { computed } from \'@ember/object\';\nimport { Ability } from \'ember-can\';\n\nexport default Ability.extend({\n  // only admins can write a post\n  canWrite: computed(\'user.isAdmin\', function() {\n    return this.get(\'user.isAdmin\');\n  }),\n\n  // only the person who wrote a post can edit it\n  canEdit: computed(\'user.id\', \'model.author\', function() {\n    return this.get(\'user.id\') === this.get(\'model.author\');\n  })\n});\n\n// Usage:\n// {{if (can "write post" post) "true" "false"}}\n// {{if (can "edit post" post user=author) "true" "false"}}\n```\n\n## Additional attributes\n\nIf you need more than a single resource in an ability, you can pass them additional attributes.\n\nYou can do this in the helpers, for example this will set the `model` to `project` as usual,\nbut also `member` as a bound property.\n\n```hbs\n{{#if (can "remove member from project" project member=member)}}\n  ...\n{{/if}}\n```\n\nSimilarly using `can` service you can pass additional attributes after or instead of the resource:\n\n```js\nthis.get(\'can\').can(\'edit post\', post, { author: bob });\nthis.get(\'can\').cannot(\'write post\', null, { project: project });\n```\n\nThese will set `author` and `project` on the ability respectively so you can use them in the checks.\n\n## Looking up abilities\n\nIn the example above we said `{{#if (can "write post")}}`, how do we find the ability class & know which property to use for that?\n\nFirst we chop off the last word as the resource type which is looked up via the container.\n\nThe ability file can either be looked up in the top level `/app/abilities` directory, or via pod structure.\n\nThen for the ability name we remove some basic stopwords (of, for in) at the end, prepend with "can" and camelCase it all.\n\nFor example:\n\n| String                      | property           | resource                | pod                            |\n|-----------------------------|--------------------|-------------------------|--------------------------------|\n| write post                  | `canWrite`         | `/abilities/post.js`    | `app/pods/post/ability.js`     |\n| manage members in project  | `canManageMembers` | `/abilities/project.js`| `app/pods/project/ability.js` |\n| view profile for user       | `canViewProfile`   | `/abilities/user.js`    | `app/pods/user/ability.js`     |\n\nCurrent stopwords which are ignored are:\n\n* for\n* from\n* in\n* of\n* to\n* on\n\n## Custom Ability Lookup\n\nThe default lookup is a bit "clever"/"cute" for some people\'s tastes, so you can override this if you choose.\n\nSimply extend the default `CanService` in `app/services/can.js` and override `parse`.\n\n`parse` takes the ability string eg "manage members in projects" and should return an object with `propertyName` and `abilityName`.\n\nFor example, to use the format "person.canEdit" instead of the default "edit person" you could do the following:\n\n```js\n// app/services/can.js\nimport Service from \'ember-can/services/can\';\n\nexport default CanService.extend({\n  parse(str) {\n    let [abilityName, propertyName] = str.split(\'.\');\n    return { propertyName, abilityName };\n  }\n});\n```\n\nYou can also modify the property prefix by overriding `parseProperty` in our ability file:\n\n```js\n// app/abilities/feature.js\nimport { Ability } from \'ember-can\';\nimport { camelize } from \'@ember/string\';\n\nexport default Ability.extend({\n  parseProperty(propertyName) {\n    return camelize(`is-${propertyName}`);\n  },\n});\n```\n\n\n\n## Injecting the user\n\nHow does the ability know who\'s logged in? This depends on how you implement it in your app!\n\nIf you\'re using an `Ember.Service` as your session, you can just inject it into the ability:\n\n```js\n// app/abilities/foo.js\nimport { Ability } from \'ember-can\';\nimport { inject as service } from \'@ember/service\';\n\nexport default Ability.extend({\n  session: service()\n});\n```\n\nThe ability classes will now have access to `session` which can then be used to check if the user is logged in etc...\n\n## Components & computed properties\n\nIn a  component, you may want to expose abilities as computed properties\nso that you can bind to them in your templates.\n\n```js\nimport Component from \'@ember/component\';\nimport { computed } from \'@ember/object\';\n\nexport default Component.extend({\n  can: service(), // inject can service\n\n  post: null, // received from higher template\n\n  ability: computed(\'post\', function() {\n    return this.get(\'can\').abilityFor(\'post\', this.get(\'post\') /*, customProperties */);\n  }),\n});\n\n// Template:\n// {{if ability.canWrite "true" "false"}}\n```\n\n#### Optional way\n\nOptionally you can use `ability` computed to simplify the syntax:\n```js\nimport Component from \'@ember/component\';\nimport { ability } from \'ember-can/computed\';\n\nexport default Component.extend({\n  can: service(), // inject can service\n\n  post: null, // received from higher template\n\n  ability: ability(\'post\')\n});\n```\n\nIf the model property is not the same as ability name you can pass a second argument:\n```js\nability: ability(\'post\', \'myModelProperty\')\n```\n\n## Accessing abilities within an Ember engine\n\nIf you\'re using [engines](http://ember-engines.com/) and you want to access an *ability* within it, you will need it to be present in your Engine\xe2\x80\x99s namespace. This is accomplished by doing what is called a "re-export":\n\n```javascript\n//my-engine/addon/abilities/foo-bar.js\nexport { default } from \'my-app/abilities/foo-bar\';\n```\n\n## Upgrade guide\n\nSee [UPGRADING.md](https://github.com/minutebase/ember-can/blob/master/UPGRADING.md) for more details.\n\n## Testing\n\nMake sure that you\'ve either `ember install`-ed this addon, or run the addon\nblueprint via `ember g ember-can`. This is an important step that teaches the\ntest resolver how to resolve abilities from the file structure.\n\n### Unit testing abilities\n\nAn ability unit test will be created each time you generate a new ability via\n`ember g ability <name>`. The package currently supports generating QUnit and\nMocha style tests.\n\n### Unit testing in your app\n\nTo unit test modules that use the `can` helper, you\'ll need to explicitly add `needs` for the\nability and helper file like this:\n``` needs: [\'helper:can\', \'ability:foo\'] ```\n\n### Integration testing in your app\n\nFor integration testing components, you should not need to specify anything explicitly. The\nhelper and your abilities should be available to your components automatically.\n\n## Development\n\n### Installation\n\n* `git clone https://github.com/minutebase/ember-can.git`\n* `cd ember-can`\n* `npm install`\n\n### Linting\n\n* `npm run lint:hbs`\n* `npm run lint:js`\n* `npm run lint:js -- --fix`\n\n### Running tests\n\n* `ember test` \xe2\x80\x93 Runs the test suite on the current Ember version\n* `ember test --server` \xe2\x80\x93 Runs the test suite in "watch mode"\n* `ember try:each` \xe2\x80\x93 Runs the test suite against multiple Ember versions\n\n### Running the dummy application\n\n* `ember serve`\n* Visit the dummy application at [http://localhost:4200](http://localhost:4200).\n\nFor more information on using ember-cli, visit [https://ember-cli.com/](https://ember-cli.com/).\n\n## Contributing\n\nSee the [Contributing](CONTRIBUTING.md) guide for details.\n\n## License\n\nThis version of the package is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\n'