b'# ember-in-viewport\n*Detect if an Ember View or Component is in the viewport @ 60FPS*\n\n**[ember-in-viewport is built and maintained by DockYard, contact us for expert Ember.js consulting](https://dockyard.com/ember-consulting)**.\n\n[Read the blogpost](https://medium.com/delightful-ui-for-ember-apps/creating-an-ember-cli-addon-detecting-ember-js-components-entering-or-leaving-the-viewport-7d95ceb4f5ed)\n\n![Download count all time](https://img.shields.io/npm/dt/ember-in-viewport.svg) [![npm version](https://badge.fury.io/js/ember-in-viewport.svg)](http://badge.fury.io/js/ember-in-viewport) [![Build Status](https://travis-ci.org/DockYard/ember-in-viewport.svg)](https://travis-ci.org/DockYard/ember-in-viewport) [![Ember Observer Score](http://emberobserver.com/badges/ember-in-viewport.svg)](http://emberobserver.com/addons/ember-in-viewport)\n\nThis Ember addon adds a simple, highly performant Service or Mixin to your app. This library will allow you to check if that `Component` has entered the browser\'s viewport. By default, the this uses the `IntersectionObserver` API if it detects it in your user\'s browser \xe2\x80\x93 failing which, it falls back to using `requestAnimationFrame`, then if not available, the Ember run loop and event listeners.\n\nWe utilize pooling techniques to reuse Intersection Observers and rAF observers in order to make your app as performant as possible and do as little works as possible.\n\n## Demo or examples\n- Lazy loading responsive images (see `dummy-artwork` for an example artwork component).  Visit `http://localhost:4200/infinity-modifier` to see it in action\n- Dummy app (`ember serve`): https://github.com/DockYard/ember-in-viewport/tree/master/tests/dummy\n- Use with Ember [Modifiers](#modifiers) and [@ember/render-modifiers](https://github.com/emberjs/ember-render-modifiers)\n- Use with [Native Classes](#classes)\n- [ember-infinity](https://github.com/ember-infinity/ember-infinity)\n- [ember-light-table](https://github.com/offirgolan/ember-light-table)\n- Tracking advertisement impressions\n- Occlusion culling\n\n\n# Table of Contents\n\n- [Installation](#installation)\n  * [Usage](#usage)\n    + [Basic usage](#basic-usage)\n      - [Available hooks](#available-hooks)\n        * [`didEnterViewport`, `didExitViewport`](#didenterviewport-didexitviewport)\n        * [`didScroll(up,down,left,right)`](#didscrollupdownleftright)\n        * [`viewportEntered`](#viewportentered)\n        * [`viewportExited`](#viewportexited)\n    + [Advanced usage (options)](#advanced-usage-options)\n    + [Global options](#global-options)\n    + [Modifiers](#modifiers)\n    + [Classes](#classes)\n  * [**IntersectionObserver**\'s Browser Support](#intersectionobservers-browser-support)\n    + [Out of the box](#out-of-the-box)\n  * [Running](#running)\n  * [Running Tests](#running-tests)\n  * [Building](#building)\n  * [Legal](#legal)\n\n\n\n# Installation\n\n```\nember install ember-in-viewport\n```\n\n## Usage\nUsage is simple. First, add the Mixin to your `Component`:\n\n```js\nimport Component from \'@ember/component\';\nimport InViewportMixin from \'ember-in-viewport\';\n\nexport default Component.extend(InViewportMixin, {\n  // ...\n});\n```\n\n### Basic usage\n#### Available hooks\n##### `didEnterViewport`, `didExitViewport`\nThese hooks fire once whenever the `Component` enters or exits the viewport. You can handle them the same way you would handle any other native Ember hook:\n\n```js\nimport Component from \'@ember/component\';\nimport InViewportMixin from \'ember-in-viewport\';\n\nexport default Component.extend(InViewportMixin, {\n  didEnterViewport() {\n    console.log(\'entered\');\n  },\n\n  didExitViewport() {\n    console.log(\'exited\');\n  }\n});\n```\n\n##### `didScroll(up,down,left,right)`\nThe `didScroll` hook fires when an element enters the viewport. For example, if you scrolled down in order to move the element in the viewport, the `didScroll` hook would fire and also receive the direction as a string. You can then handle it like another hook as in the above example.\n\n```js\nimport Component from \'@ember/component\';\nimport InViewportMixin from \'ember-in-viewport\';\n\nexport default Component.extend(InViewportMixin, {\n  didScroll(direction) {\n    console.log(direction); // \'up\' || \'down\' || \'left\' || \'right\'\n  }\n});\n```\n\n##### `viewportEntered`\nTo apply an `.active` class to your `Component` when it enters the viewport, you can simply bind the `active` class to the mixed in property `viewportEntered`, like so:\n\n```js\nimport Component from \'@ember/component\';\nimport InViewportMixin from \'ember-in-viewport\';\n\nexport default Component.extend(InViewportMixin, {\n  classNameBindings: [ \'viewportEntered:active\' ]\n});\n```\n\n##### `viewportExited`\nThis hook fires whenever the `Component` leaves the viewport.\n\n### Advanced usage (options)\nThe mixin comes with some options. Due to the way listeners and `IntersectionObserver API` or `requestAnimationFrame` is setup, you\'ll have to override the options this way:\n\n```js\nimport Component from \'@ember/component\';\nimport InViewportMixin from \'ember-in-viewport\';\nimport { setProperties }  from \'@ember/object\';\n\nexport default Component.extend(InViewportMixin, {\n  init() {\n    this._super(...arguments);\n\n    setProperties(this, {\n      viewportEnabled                 : true,\n      viewportUseRAF                  : true,\n      viewportSpy                     : false,\n      viewportScrollSensitivity       : 1,\n      viewportRefreshRate             : 150,\n      intersectionThreshold           : 0,\n      scrollableArea                  : null,\n      viewportTolerance: {\n        top    : 50,\n        bottom : 50,\n        left   : 20,\n        right  : 20\n      }\n    });\n  }\n});\n```\n\n- `viewportEnabled: boolean`\n\n  Default: `true`\n\n  Set to false to have no listeners registered. Useful if you have components that function with either viewport listening on or off.\n\n- `viewportUseIntersectionObserver: boolean`\n\n  Default: Depends on browser\n\n  Read-only\n\n  The Mixin by default will use the IntersectionObserver API. If IntersectionObserver is not supported in the target browser, ember-in-viewport will fallback to rAF.  We prevent users from explicitly setting this to `true` as browsers lacking support for IntersectionObserver will throw an error.\n\n  (https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)\n  (https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/thresholds#Browser_compatibility)\n\n- `intersectionThreshold: decimal or array`\n\n  Default: 0\n\n  A single number or array of numbers between 0.0 and 1.0.  A value of 0.0 means the target will be visible when the first pixel enters the viewport.  A value of 1.0 means the entire target must be visible to fire the didEnterViewport hook.\n  Similarily, [0, .25, .5, .75, 1] will fire didEnterViewport every 25% of the target that is visible.\n  (https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Thresholds)\n\n  Some notes:\n    - If the target is offscreen, you will get a notification via `didExitViewport` that the target is initially offscreen.  Similarily, this is possible to notify if onscreen when your site loads.\n    - If intersectionThreshold is set to anything greater than 0, you will not see `didExitViewport` hook fired due to our use of the `isIntersecting` property.  See last comment here: https://bugs.chromium.org/p/chromium/issues/detail?id=713819 for purpose of `isIntersecting`\n    - To get around the above issue and have `didExitViewport` fire, set your `intersectionThreshold` to `[0, 1.0]`.  When set to just `1.0`, when the element is 99% visible and still has isIntersecting as true, when the element leaves the viewport, the element isn\'t applicable to the observer anymore, so the callback isn\'t called again.\n    - If your intersectionThreshold is set to 0 you will get notified if the target `didEnterViewport` and `didExitViewport` at the appropriate time.\n\n- `scrollableArea: string | HTMLElement`\n\n  Default: null\n\n  A CSS selector for the scrollable area.  e.g. `".my-list"`\n\n- `viewportUseRAF: boolean`\n\n  Default: Depends on browser\n\n  As its name suggests, if this is `true` and the IntersectionObserver API is not available in the target browser, the Mixin will use `requestAnimationFrame`. Unless you want to force enabling or disabling this, you won\'t need to override this option.\n\n- `viewportSpy: boolean`\n\n  Default: `false`\n\n  When `true`, the Mixin will continually watch the `Component` and re-fire hooks whenever it enters or leaves the viewport. Because this is expensive, this behaviour is opt-in. When false, the Mixin will only watch the `Component` until it enters the viewport once, and then it sets `viewportEntered` to `true` (permanently), and unbinds listeners. This reduces the load on the Ember run loop and your application.\n\n  NOTE: If using IntersectionObserver (default), viewportSpy wont put too much of a tax on your application.  However, for browsers (Safari) that don\'t currently support IntersectionObserver, we fallback to rAF.  Depending on your use case, the default of `false` may be acceptable.\n\n- `viewportDidScroll: boolean`\n\n  Default: `true`\n\n  When `true`, the Mixin enables listening to the `didScroll` hook.  This will become by default false in a future major release\n\n- `viewportScrollSensitivity: number`\n\n  Default: `1`\n\n  This value determines the degree of sensitivity (in `px`) in which a DOM element is considered to have scrolled into the viewport. For example, if you set `viewportScrollSensitivity` to `10`, the `didScroll{...}` hooks would only fire if the scroll was greater than `10px`.  Only applicable if IntersectionObserver and rAF are not applied.\n\n- `viewportRefreshRate: number`\n\n  Default: `100`\n\n  If `IntersectionObserver` and `requestAnimationFrame` is not present, this value determines how often the Mixin checks your component to determine whether or not it has entered or left the viewport. The lower this number, the more often it checks, and the more load is placed on your application. Generally, you\'ll want this value between `100` to `300`, which is about the range at which people consider things to be "real-time".\n\n  This value also affects how often the Mixin checks scroll direction.\n\n- `viewportTolerance: object`\n\n  Default: `{ top: 0, left: 0, bottom: 0, right: 0 }`\n\n  This option determines how accurately the `Component` needs to be within the viewport for it to be considered as entered.  Add bottom margin to preemptively trigger didEnterViewport.\n\n  For IntersectionObserver, this property interpolates to [rootMargin](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/rootMargin).\n  For rAF, this property will use `bottom` tolerance and measure against the height of the container to determine when to trigger didEnterViewport.\n\n  Also, if your sentinel (component that uses this mixin) is a zero-height element, ensure that the sentinel actually is able to enter the viewport.\n\n### Global options\n\nYou can set application wide defaults for `ember-in-viewport` in your app (they are still manually overridable inside of a Component). To set new defaults, just add a config object to `config/environment.js`, like so:\n\n```js\nmodule.exports = function(environment) {\n  var ENV = {\n    // ...\n    viewportConfig: {\n      viewportEnabled                 : false,\n      viewportUseRAF                  : true,\n      viewportSpy                     : false,\n      viewportScrollSensitivity       : 1,\n      viewportRefreshRate             : 100,\n      viewportListeners               : [],\n      intersectionThreshold           : 0,\n      scrollableArea                  : null,\n      viewportTolerance: {\n        top    : 0,\n        left   : 0,\n        bottom : 0,\n        right  : 0\n      }\n    }\n  };\n};\n\nNote if you want to disable right and left in-viewport triggers, set these values to `Infinity`.\n```\n\n### Modifiers\n\nUsing with [Modifiers](https://blog.emberjs.com/2019/03/06/coming-soon-in-ember-octane-part-4.html) is easy.  Note, modifiers currently only works to watch entering the viewport.\n\n1.  Install [@ember/render-modifiers](https://github.com/emberjs/ember-render-modifiers)\n2.  Use the `did-insert` hook inside a component\n3.  Wire up the component like so\n\nNote - This is in lieu of a `did-enter-viewport` modifier, which we plan on adding in the future.  Compared to the solution below, `did-enter-viewport` won\'t need a container (`this`) passed to it.  But for now, to start using modifiers, this is the easy path.\n\n```js\nimport Component from \'@ember/component\';\nimport { set } from \'@ember/object\';\nimport InViewportMixin from \'ember-in-viewport\';\n\nexport default Component.extend(InViewportMixin, {\n  tagName: \'\',\n\n  didInsertNode(element, [instance]) {\n    instance.watchElement(element);\n  },\n\n  didInsertElement() {\n    this._super(...arguments);\n    set(this, \'viewportSpy\', true);\n    set(this, \'viewportTolerance\', {\n      bottom: 300\n    });\n\n    this._super(...arguments);\n  },\n\n  didEnterViewport() {\n    // this will only work with one element being watched in the container. This is still a TODO to enable\n    this.infinityLoad();\n  }\n});\n```\n\n```hbs\n<div {{did-insert this.didInsertNode this}}>\n  {{yield}}\n</div>\n```\n\n### Classes\n\nThis allows you to absolve yourself from using a mixin in native classes!\n\n```js\nimport Component from \'@ember/component\';\nimport { tagName } from \'@ember-decorators/component\';\nimport { inject as service } from \'@ember/service\'; // with polyfill\n\n@tagName(\'\')\nexport default class MyClass extends Component {\n  @service inViewport\n\n  didInsertElement() {\n    super();\n    const loader = document.getElementById(\'loader\');\n    const viewportTolerance = { bottom: 200 };\n    const { onEnter, onExit } = this.inViewport.watchElement(loader, { viewportTolerance });\n    onEnter(this.didEnterViewport.bind(this));\n  }\n\n  didEnterViewport() {\n    // do some other stuff\n    this.infinityLoad();\n  },\n\n  willDestroyElement() {\n    // need to manage cache yourself if you don\'t use the mixin\n    const loader = document.getElementById(\'loader\');\n    this.inViewport.stopWatching(loader);\n  }\n}\n```\n\nAnd with Classes + Modifiers!\n\n```js\nimport Component from \'@ember/component\';\nimport { tagName } from \'@ember-decorators/component\';\nimport { inject as service } from \'@ember/service\'; // with polyfill\n\n@tagName(\'\')\nexport default class MyClass extends Component {\n  @service inViewport\n\n  didInsertNode(element, [instance]) {\n    const viewportTolerance = { bottom: 200 };\n    const { onEnter, onExit } = instance.inViewport.watchElement(element, { viewportTolerance });\n    onEnter(instance.didEnterViewport.bind(instance));\n  }\n\n  didEnterViewport() {\n    // do some other stuff\n    this.infinityLoad();\n  },\n\n  willDestroyElement() {\n    // need to manage cache yourself if you don\'t use the mixin\n    const loader = document.getElementById(\'loader\');\n    this.inViewport.stopWatching(loader);\n  }\n}\n```\n\n```hbs\n<div {{did-insert this.didInsertNode this}}>\n  {{yield}}\n</div>\n```\n\nOptions as the second argument to `inViewport.watchElement` include `intersectionThreshold`, `scrollableArea`, `viewportSpy` && `viewportTolerance`\n\n## [**IntersectionObserver**\'s Browser Support](https://platform-status.mozilla.org/)\n\n### Out of the box\n\n<table>\n    <tr>\n        <td>Chrome</td>\n        <td>51 <sup>[1]</sup></td>\n    </tr>\n    <tr>\n        <td>Firefox (Gecko)</td>\n        <td>55 <sup>[2]</sup></td>\n    </tr>\n    <tr>\n        <td>MS Edge</td>\n        <td>15</td>\n    </tr>\n    <tr>\n        <td>Internet Explorer</td>\n        <td>Not supported</td>\n    </tr>\n    <tr>\n        <td>Opera <sup>[1]</sup></td>\n        <td>38</td>\n    </tr>\n    <tr>\n        <td>Safari</td>\n        <td>Safari Technology Preview</td>\n    </tr>\n    <tr>\n        <td>Chrome for Android</td>\n        <td>59</td>\n    </tr>\n    <tr>\n        <td>Android Browser</td>\n        <td>56</td>\n    </tr>\n    <tr>\n        <td>Opera Mobile</td>\n        <td>37</td>\n    </tr>\n</table>\n\n* [1] [Reportedly available](https://www.chromestatus.com/features/5695342691483648), it didn\'t trigger the events on initial load and lacks `isIntersecting` until later versions.\n* [2] This feature was implemented in Gecko 53.0 (Firefox 53.0 / Thunderbird 53.0 / SeaMonkey 2.50) behind the preference `dom.IntersectionObserver.enabled`.\n\n## Running\n\n* `ember serve`\n* Visit your app at http://localhost:4200.\n\n## Running Tests\n\n* `ember test`\n* `ember test --serve`\n\n## Building\n\n* `ember build`\n\nFor more information on using ember-cli, visit [http://www.ember-cli.com/](http://www.ember-cli.com/).\n\n## Legal\n\n[DockYard](http://dockyard.com/ember-consulting), Inc &copy; 2015\n\n[@dockyard](http://twitter.com/dockyard)\n\n[Licensed under the MIT license](http://www.opensource.org/licenses/mit-license.php)\n'