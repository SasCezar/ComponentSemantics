b'![\xe6\x95\x88\xe6\x9e\x9c\xe5\x9b\xbe](https://github.com/Jasonchenlijian/FastBle/raw/master/preview/fastble_poster.png)\n\nThanks to the logo designed by [anharismail](https://github.com/anharismail)\n\n\n# FastBle\nAndroid Bluetooth Low Energy\n\n- Filtering, scanning, linking, reading, writing, notification subscription and cancellation in a simple way.\n- Supports acquiring signal strength and setting the maximum transmission unit.\n- Support custom scan rules  \n- Support multi device connections  \n- Support reconnection  \n- Support configuration timeout for conncet or operation  \n\n\n# Preview\n![Preview_1](https://github.com/Jasonchenlijian/FastBle/raw/master/preview/new_1.png) \n![Preview_2](https://github.com/Jasonchenlijian/FastBle/raw/master/preview/new_2.png) \n![Preview_3](https://github.com/Jasonchenlijian/FastBle/raw/master/preview/new_3.png)\n![Preview_4](https://github.com/Jasonchenlijian/FastBle/raw/master/preview/new_4.png)\n\n\n### APK\nIf you want to quickly preview all the functions, you can download APK as a test tool directly.\n\n [FastBLE.apk](https://github.com/Jasonchenlijian/FastBle/raw/master/FastBLE.apk) \n\n\n### Maven\n\n\t<dependency>\n       <groupId>com.clj.fastble</groupId>\n       <artifactId>FastBleLib</artifactId>\n       <version>2.3.4</version>\n\t   <type>pom</type>\n\t</dependency>\n\n### Gradle\n\n\tcompile \'com.clj.fastble:FastBleLib:2.3.4\'\n\n### Jar\n\n[FastBLE-2.3.4.jar](https://github.com/Jasonchenlijian/FastBle/raw/master/FastBLE-2.3.4.jar) \n\n\n## Wiki\n\n[\xe4\xb8\xad\xe6\x96\x87\xe6\x96\x87\xe6\xa1\xa3](https://github.com/Jasonchenlijian/FastBle/wiki)\n\n[Android BLE\xe5\xbc\x80\xe5\x8f\x91\xe8\xaf\xa6\xe8\xa7\xa3\xe5\x92\x8cFastBle\xe6\xba\x90\xe7\xa0\x81\xe8\xa7\xa3\xe6\x9e\x90](https://www.jianshu.com/p/795bb0a08beb)\n\n\n\n# Usage\n\n- #### Init\n    \n        BleManager.getInstance().init(getApplication());\n\n- #### Determine whether the current Android system supports BLE\n\n        boolean isSupportBle()\n\n- #### Open or close Bluetooth\n\n\t\tvoid enableBluetooth()\n\t\tvoid disableBluetooth()\n\n- #### Initialization configuration\n\n        BleManager.getInstance()\n                .enableLog(true)\n                .setReConnectCount(1, 5000)\n\t            .setSplitWriteNum(20)\n\t            .setConnectOverTime(10000)\n                .setOperateTimeout(5000);\n\n- #### Configuration scan rules\n\n\t`void initScanRule(BleScanRuleConfig scanRuleConfig)`\n\n        BleScanRuleConfig scanRuleConfig = new BleScanRuleConfig.Builder()\n                .setServiceUuids(serviceUuids)\n                .setDeviceName(true, names)\n                .setDeviceMac(mac)\n                .setAutoConnect(isAutoConnect)\n                .setScanTimeOut(10000)\n                .build();\n        BleManager.getInstance().initScanRule(scanRuleConfig);\n\n\tTips\xef\xbc\x9a\n\t- Before scanning the device, scan rules can be configured to filter out the equipment matching the program.\n\t- What is not configured is the default parameter\n\n- #### Scan\n\n\t`void scan(BleScanCallback callback)`\n\n        BleManager.getInstance().scan(new BleScanCallback() {\n            @Override\n            public void onScanStarted(boolean success) {\n\n            }\n\n            @Override\n            public void onScanning(BleDevice bleDevice) {\n\n            }\n\n            @Override\n            public void onScanFinished(List<BleDevice> scanResultList) {\n\n            }\n        });\n\n\tTips:\n\t- The scanning and filtering process is carried out in the worker thread, so it will not affect the UI operation of the main thread. Eventually, every callback result will return to the main thread.\xe3\x80\x82\n\n- #### Connect with device\n\n\n\t`BluetoothGatt connect(BleDevice bleDevice, BleGattCallback bleGattCallback)`\n\n        BleManager.getInstance().connect(bleDevice, new BleGattCallback() {\n            @Override\n            public void onStartConnect() {\n\n            }\n\n            @Override\n            public void onConnectFail(BleDevice bleDevice, BleException exception) {\n\n            }\n\n            @Override\n            public void onConnectSuccess(BleDevice bleDevice, BluetoothGatt gatt, int status) {\n\n            }\n\n            @Override\n            public void onDisConnected(boolean isActiveDisConnected, BleDevice bleDevice, BluetoothGatt gatt, int status) {\n\n            }\n        });\n\n\tTips:\n\t- On some types of phones, connectGatt must be effective on the main thread. It is very recommended that the connection process be placed in the main thread.\n\t- After connection failure, reconnect: the framework contains reconnection mechanism after connection failure, which can configure reconnection times and intervals. Of course, you can also call the `connect` method in `onConnectFail` callback automatically.\n\t- The connection is disconnected and reconnected: you can call the `connect` method again in the `onDisConnected` callback method.\n\t- In order to ensure the success rate of reconnection, it is recommended to reconnect after a period of interval.\n\t- When some models fail, they will be unable to scan devices for a short time. They can be connected directly through device objects or devices MAC without scanning.\n\n- #### Connect with Mac\n\n\t`BluetoothGatt connect(String mac, BleGattCallback bleGattCallback)`\n\n        BleManager.getInstance().connect(mac, new BleGattCallback() {\n            @Override\n            public void onStartConnect() {\n\n            }\n\n            @Override\n            public void onConnectFail(BleDevice bleDevice, BleException exception) {\n\n            }\n\n            @Override\n            public void onConnectSuccess(BleDevice bleDevice, BluetoothGatt gatt, int status) {\n\n            }\n\n            @Override\n            public void onDisConnected(boolean isActiveDisConnected, BleDevice bleDevice, BluetoothGatt gatt, int status) {\n\n            }\n        });\n\n\tTips:\n\t- This method can attempt to connect directly to the BLE device around the Mac without scanning.\n\t- In many usage scenarios, I suggest that APP save the Mac of the user\'s customary device, then use this method to connect, which will greatly improve the connection efficiency.\n\n- #### Scan and connect\n\n\tAfter scanning the first equipment that meets the scanning rules, it will stop scanning and connect to the device.\n\n\t`void scanAndConnect(BleScanAndConnectCallback callback)`\n\n        BleManager.getInstance().scanAndConnect(new BleScanAndConnectCallback() {\n            @Override\n            public void onScanStarted(boolean success) {\n\n            }\n\n            @Override\n            public void onScanFinished(BleDevice scanResult) {\n\n            }\n\n            @Override\n            public void onStartConnect() {\n\n            }\n\n            @Override\n            public void onConnectFail(BleDevice bleDevice,BleException exception) {\n\n            }\n\n            @Override\n            public void onConnectSuccess(BleDevice bleDevice, BluetoothGatt gatt, int status) {\n\n            }\n\n            @Override\n            public void onDisConnected(boolean isActiveDisConnected, BleDevice device, BluetoothGatt gatt, int status) {\n\n            }\n        }); \n\n\n- #### Cancel scan\n\n\t`void cancelScan()`\n\n\t\tBleManager.getInstance().cancelScan();\n\n\tTips:\n\t- If this method is called, if it is still in the scan state, it will end immediately, and callback the `onScanFinished` method.\n\n\n- #### Notify\n\t`void notify(BleDevice bleDevice,\n                       String uuid_service,\n                       String uuid_notify,\n                       BleNotifyCallback callback)`\n\t`void notify(BleDevice bleDevice,\n                       String uuid_service,\n                       String uuid_notify,\n                       boolean useCharacteristicDescriptor,\n                       BleNotifyCallback callback)`\n                        \n        BleManager.getInstance().notify(\n                bleDevice,\n                uuid_service,\n                uuid_characteristic_notify,\n                new BleNotifyCallback() {\n                    @Override\n                    public void onNotifySuccess() {\n\n                    }\n\n                    @Override\n                    public void onNotifyFailure(BleException exception) {\n\n                    }\n\n                    @Override\n                    public void onCharacteristicChanged(byte[] data) {\n\n                    }\n                });\n\t\n\n- #### Stop Notify\n\n\t`boolean stopNotify(BleDevice bleDevice,\n                              String uuid_service,\n                              String uuid_notify)`\n\t`boolean stopNotify(BleDevice bleDevice,\n                              String uuid_service,\n                              String uuid_notify,\n                              boolean useCharacteristicDescriptor)`\n\n\t\tBleManager.getInstance().stopNotify(uuid_service, uuid_characteristic_notify);\n\n- #### Indicate\n\n\t`void indicate(BleDevice bleDevice,\n                         String uuid_service,\n                         String uuid_indicate,\n                         BleIndicateCallback callback)`\n\t`void indicate(BleDevice bleDevice,\n                         String uuid_service,\n                         String uuid_indicate,\n                         boolean useCharacteristicDescriptor,\n                         BleIndicateCallback callback)`\n\n        BleManager.getInstance().indicate(\n                bleDevice,\n                uuid_service,\n                uuid_characteristic_indicate,\n                new BleIndicateCallback() {\n                    @Override\n                    public void onIndicateSuccess() {\n\n                    }\n\n                    @Override\n                    public void onIndicateFailure(BleException exception) {\n\n                    }\n\n                    @Override\n                    public void onCharacteristicChanged(byte[] data) {\n\n                    }\n                });\n\n\n- #### Stop Indicate\n\n    `boolean stopIndicate(BleDevice bleDevice,\n                                String uuid_service,\n                                String uuid_indicate)`\n\t`boolean stopIndicate(BleDevice bleDevice,\n                                String uuid_service,\n                                String uuid_indicate,\n                                boolean useCharacteristicDescriptor)`\n    \n\t\tBleManager.getInstance().stopIndicate(uuid_service, uuid_characteristic_indicate);\n\n- #### Write\n\n\t`void write(BleDevice bleDevice,\n                      String uuid_service,\n                      String uuid_write,\n                      byte[] data,\n                      BleWriteCallback callback)`\n\t`void write(BleDevice bleDevice,\n                      String uuid_service,\n                      String uuid_write,\n                      byte[] data,\n                      boolean split,\n                      BleWriteCallback callback)`\n\t`void write(BleDevice bleDevice,\n                      String uuid_service,\n                      String uuid_write,\n                      byte[] data,\n                      boolean split,\n                      boolean sendNextWhenLastSuccess,\n                      long intervalBetweenTwoPackage,\n                      BleWriteCallback callback)`\n\n        BleManager.getInstance().write(\n                bleDevice,\n                uuid_service,\n                uuid_characteristic_write,\n                data,\n                new BleWriteCallback() {\n                    @Override\n                    public void onWriteSuccess(int current, int total, byte[] justWrite) {\n\n                    }\n\n                    @Override\n                    public void onWriteFailure(BleException exception) {\n\n                    }\n                });\n\n\tTips:\n\t- Without expanding MTU and expanding MTU\'s ineffectiveness, subcontracting is required when long data with more than 20 bytes are to be sent. The parameter `boolean split` indicates whether to use packet delivery; the `write` method without the `boolean split` parameter is subcontracted to the data by more than 20 bytes by default.\n\t- On the `onWriteSuccess` callback method: `current` represents the number of packets that are currently sent, and `total` represents the total packet data this time, and `justWrite` represents the successful packet that has just been sent.\n\n- #### Read\n\n\t`void read(BleDevice bleDevice,\n                     String uuid_service,\n                     String uuid_read,\n                     BleReadCallback callback)`\n\n        BleManager.getInstance().read(\n                bleDevice,\n                uuid_service,\n                uuid_characteristic_read,\n                new BleReadCallback() {\n                    @Override\n                    public void onReadSuccess(byte[] data) {\n\n                    }\n\n                    @Override\n                    public void onReadFailure(BleException exception) {\n\n                    }\n                });\n\n\n- #### Get Rssi\n\n\t`void readRssi(BleDevice bleDevice, BleRssiCallback callback)`\n\n        BleManager.getInstance().readRssi(\n                bleDevice,\n                new BleRssiCallback() {\n\n                    @Override\n                    public void onRssiFailure(BleException exception) {\n\n                    }\n\n                    @Override\n                    public void onRssiSuccess(int rssi) {\n\n                    }\n                });\n\n\tTips\xef\xbc\x9a\n\t- Obtaining the signal strength of the device must be carried out after the device is connected.\n\t- Some devices may not be able to read Rssi, do not callback onRssiSuccess (), and callback onRssiFailure () because of timeout.\n\n- #### set Mtu\n\n\t`void setMtu(BleDevice bleDevice,\n                       int mtu,\n                       BleMtuChangedCallback callback)`\n\n        BleManager.getInstance().setMtu(bleDevice, mtu, new BleMtuChangedCallback() {\n            @Override\n            public void onSetMTUFailure(BleException exception) {\n\n            }\n\n            @Override\n            public void onMtuChanged(int mtu) {\n\n            }\n        });\n\n\tTips\xef\xbc\x9a\n\t- Setting up MTU requires operation after the device is connected.\n\t- There is no such restriction in the Android Version (API-17 to API-20). Therefore, only the equipment above API21 will expand the demand for MTU.\n\t- The parameter MTU of the method is set to 23, and the maximum setting is 512.\n\t- Not every device supports the expansion of MTU, which requires both sides of the communication, that is to say, the need for the device hardware also supports the expansion of the MTU method. After calling this method, you can see through onMtuChanged (int MTU) how much the maximum transmission unit of the device is expanded to after the final setup. If the device does not support, no matter how many settings, the final MTU will be 23.\n\n- #### requestConnectionPriority\n\n\t`boolean requestConnectionPriority(BleDevice bleDevice,int connectionPriority)`\n\n\tTips:\n\t- Request a specific connection priority. Must be one of{@link BluetoothGatt#CONNECTION_PRIORITY_BALANCED}, {@link BluetoothGatt#CONNECTION_PRIORITY_HIGH} or {@link BluetoothGatt#CONNECTION_PRIORITY_LOW_POWER}.\n\n- #### Converte BleDevice object\n\n\t`BleDevice convertBleDevice(BluetoothDevice bluetoothDevice)`\n\n\t`BleDevice convertBleDevice(ScanResult scanResult)`\n\n\tTips\xef\xbc\x9a\n\t- The completed BleDevice object is still unconnected, if necessary, advanced connection.\n\n- #### Get all connected devices\n\n\t`List<BleDevice> getAllConnectedDevice()`\n\n        BleManager.getInstance().getAllConnectedDevice();\n\n- #### Get a BluetoothGatt of a connected device\n\n\t`BluetoothGatt getBluetoothGatt(BleDevice bleDevice)`\n\n- #### Get all Service of a connected device\n\n\t`List<BluetoothGattService> getBluetoothGattServices(BleDevice bleDevice)`\n\n- #### Get all the Characteristic of a Service\n\n\t`List<BluetoothGattCharacteristic> getBluetoothGattCharacteristics(BluetoothGattService service)`\n\t\t\n- #### Determine whether a device has been connected\n\n\t`boolean isConnected(BleDevice bleDevice)`\n\n        BleManager.getInstance().isConnected(bleDevice);\n\n\t`boolean isConnected(String mac)`\n\n\t\tBleManager.getInstance().isConnected(mac);\n\n- #### Determine the current connection state of a device\n\n\t`int getConnectState(BleDevice bleDevice)`\n\n\t\tBleManager.getInstance().getConnectState(bleDevice);\n\n- #### Disconnect a device\n\n\t`void disconnect(BleDevice bleDevice)`\n\n        BleManager.getInstance().disconnect(bleDevice);\n\n- #### Disconnect all devices\n\n\t`void disconnectAllDevice()`\n\n        BleManager.getInstance().disconnectAllDevice();\n\n- #### Out of use, clean up resources\n\n\t`void destroy()`\n\n        BleManager.getInstance().destroy();\n\n\n- #### HexUtil\n\n    Data operation tool class\n\n    `String formatHexString(byte[] data, boolean addSpace)`\n\n\t`byte[] hexStringToBytes(String hexString)`\n\n\t`char[] encodeHex(byte[] data, boolean toLowerCase)`\n\n\n- #### BleDevice\n\n    BLE device object is the smallest unit object of scanning, connection and operation in this framework.\n\n    `String getName()` Bluetooth broadcast name\n\n    `String getMac()` Bluetooth MAC\n\n    `byte[] getScanRecord()` Broadcast data\n\n    `int getRssi()` Initial signal intensity\n\n\n\n## Contact\nIf you have problems and ideas to communicate with me, you can contact me in the following ways.\n\nQQ\xef\xbc\x9a 1033526540\n\nEmail\xef\xbc\x9a jasonchenlijian@gmail.com\n\n\n## License\n\n\t   Copyright 2016 chenlijian\n\n\t   Licensed under the Apache License, Version 2.0 (the "License");\n\t   you may not use this file except in compliance with the License.\n\t   You may obtain a copy of the License at\n\n   \t\t   http://www.apache.org/licenses/LICENSE-2.0\n\n\t   Unless required by applicable law or agreed to in writing, software\n\t   distributed under the License is distributed on an "AS IS" BASIS,\n\t   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t   See the License for the specific language governing permissions and\n\t   limitations under the License.\n\n\n\n\n'