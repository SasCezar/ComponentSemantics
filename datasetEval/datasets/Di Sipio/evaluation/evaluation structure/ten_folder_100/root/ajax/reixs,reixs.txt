b'<p align="center">\n    <a target="_blank" rel="noopener noreferrer">\n        <img width="200" src="https://raw.githubusercontent.com/reixs/reixs/master/docs/reixs.jpg" alt="Reixs logo">\n    </a>\n</p>\n<p align="center">\n    <a href="https://travis-ci.org/reixs/reixs">\n        <img src="https://travis-ci.org/reixs/reixs.svg?branch=master" alt="Build Status">\n    </a>\n    <a href="https://coveralls.io/github/reixs/reixs?branch=master">\n        <img src="https://coveralls.io/repos/github/reixs/reixs/badge.svg?branch=master" alt="Coverage Status"/>\n    </a>\n    <a href="https://npmcharts.com/compare/reixs?minimal=true">\n        <img src="https://img.shields.io/npm/dm/reixs.svg" alt="Downloads">\n    </a>\n    <a href="https://www.npmjs.com/package/reixs">\n        <img src="https://img.shields.io/npm/v/reixs.svg" alt="Version">\n    </a>\n    <a href="https://www.npmjs.com/package/reixs">\n        <img src="https://img.shields.io/npm/l/reixs.svg" alt="License">\n    </a>\n    <a href="https://gitter.im/reixs/community">\n        <img src="https://img.shields.io/gitter/room/reixs/community.svg" alt="Chat">\n    </a>\n</p>\n\nEnglish | [\xe7\xae\x80\xe4\xbd\x93\xe4\xb8\xad\xe6\x96\x87](https://github.com/reixs/reixs/blob/master/docs/README-zh.md)   \nReixs is a modern HTTP request library running in a browser environment that enables flexible and controllable HTTP request management.\n\n## Overview\nReixs works by predeclaring the callback content of an HTTP request and processing the server response in the form of a registration task. When the reixs-initiated request completes, the registered tasks are incrementally executed.\n  \nAsynchronous processing of network requests has always been a headache for developers. Reixs can effectively solve Callback Hell and other asynchronous processing problems by splitting the request and response. Unlike other modern HTTP request libraries, reixs is not dependent on [promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Web API  Interface reference | MDN") implementations. Reixs can do more flexible operation on HTTP request through dynamic binding and unbinding request task.\n\n## Features \n- Make [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API "Web API  Interface reference | MDN") from the browse\n- Intercept request and response\n- Transform request and response data\n- Automatic transforms for [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON) data\n- Register and cancel response tasks\n- Request throttling operation\n\n## Installation\n```bash\nnpm install reixs --save\n```\nThe bottom layer of reixs USES the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API "Web API Interface reference | MDN") to send requests. If fetch is not supported, please manually introduce [polyfill](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill "Web API Interface reference | MDN")  of fetch.\n```bash\nnpm install fetch-polyfill --save\n\nnpm install node-fetch-polyfill --save\n```\n\n## Start\n```javascript\nimport reixs from \'reixs\'\n\n// Create a reixs scheduler and register tasks\nlet scheduler = reixs(\'http://api...\')\n    .task(data => {\n        console.log(`data:${data}`)\n    })\n\n// Send requests, default to GET requests\nscheduler.request()\n```\nThis is a simple example of a reixs request. reixs encourages the separation of requests and callbacks, allowing for better functional deconstruction.  \n  \nThe \'request API\' takes the request data and the request type as parameters\n```javascript\nscheduler.request(\n    {\n        id:12,\n        name:"lili"\n    },\n    \'get\'\n)\n```\n## Instance methods\n\nFor convenience, dedicated methods are provided for all supported request types.\n\n```javascript\n// Query String Parameters\nscheduler.get()\n// Path\nscheduler.push()\n// Request Plyload\nscheduler.post()\n// FormData\nscheduler.form()\n```\nWhen using proprietary methods, there is no need to specify the request type.\n\n## Operation\nReixs USES chain call API design.\n```javascript\nlet scheduler = reixs(\'http://api...\')\n    // Sets the request header\n    .setHeader({\n        \'Accept-Encoding\':\'gzip\'\n    })\n    // Set the default request parameters and do not enable deep copy\n    .setParams({id:12}, false)\n    // Sets no cookies\n    .setCookie(false)\n    // Set 500ms throttling \n    .throttle(500)\n    // Set 300ms debounce\n    .debounce(300)\n\nscheduler.get()\n```\n\n## Lifecycle\nReixs provides the full Lifecycle for a single reques\n```javascript\nlet scheduler = reixs(\'http://api...\')\n    // When the \'request API\' is invoked\n    .prepare(() => {\n        console.log(\'Request pending\')\n    })\n    // When the HTTP request is sent\n    .start(() => {\n        console.log(\'Request start\')\n    })\n    // End of HTTP request\n    .end(() => {\n        console.log(\'Request closed\')\n    })\n    // Error time\n    .error(error => {\n        throw error\n    })\n\nscheduler.get()\n```\n\n## Task\nBind multiple tasks.\n```javascript\nlet task1 = function(){\n    console.log(\'task1\')\n}\nlet task2 = function(){\n    console.log(\'task2\')\n}\nlet task3 = function(){\n    console.log(\'task3\')\n}\nlet scheduler = reixs(\'http://api...\')\n    .task(task1)\n    .task(task2)\n    .task(task3)\n\nscheduler.get()\n```\n  \ncancel the task.\n```javascript\n// Cancel task\nscheduler.removeTask(tesk1)\n// Cancel all tasks\nscheduler.removeAllTask()\n```\nNote that the cancel task operation does not support chain calls.\n\n## Data Processing\n```javascript\nlet scheduler = reixs(\'http://api...\')\n    // Request interceptor before filtering\n    .reqInterceptor(data => {\n        if(data === 1){\n            return false\n        }\n    })\n    // Request filter\n    .reqPipes( data => {\n        return data + 1\n    })\n    // Request interceptor after filtering\n    .reqInterceptor(data => {\n        if(data === 3){\n            return false\n        }\n    })\n    // Response interceptor before filtering\n    .resInterceptor(data => {\n        if(!data){\n            return false\n        }\n    })\n    // Response filter\n    .resPipes( data => {\n        return data - 1\n    })\n    // Response interceptor after filtering\n    .resInterceptor(data => {\n        if(data <= 0){\n            return false\n        }\n    })\n\nscheduler.get(0)\n```\n\n## Global Config\n```javascript\nimport reixs from \'reixs\'\n\n// Set global request headers\nreixs.globalHeader = {\n    \'Accept-Encoding\':\'gzip\'\n}\n// Global carry parameter when the request parameter is a {key:value} structure\nreixs.globalParams = {\n    id:12\n}\n\n// Global request filter\nreixs.reqPipes(fn)\n// Global response filter\nreixs.resPipes(fn)\n// Request interceptors before global filtering\nreixs.beforeReq(fn)\n// Request interceptors after global filtering\nreixs.afterReq(fn)\n// Response interceptors before global filtering\nreixs.beforeRes(fn)\n// Response interceptors after global filtering\nreixs.afterRes(fn)\n```\n\n## Scheduler replication\nFor scenarios where we need to reuse a scheduler configuration, we can use the copy function.\n```javascript\nlet scheduler = reixs(\'http://api...\')\nlet newScheduler = reixs.copy(scheduler)\n```\nThe new scheduler inherits all the properties of the original scheduler, and operations on the new scheduler do not apply to the original scheduler.\n\n## Scheduler Group\n```javascript\nlet scheduler1 = reixs(\'http://api1...\')\nlet scheduler2 = reixs(\'http://api2...\')\n\n// The task is invoked after all request responses are complete\nlet allScheduler = reixs.all(scheduler1, scheduler2)\n    .test((data1, data2) => {\n        console.log(data1, data2)\n    })\n\nallScheduler.request()\n\n// The first request to respond invokes the task\nlet raceScheduler = reixs.race(scheduler1, scheduler2)\n    .test((data) => {\n        console.log(data)\n    })\n\nraceScheduler.request()\n\n// Requests are processed in tandem\nlet successionScheduler = reixs.succession(scheduler1, scheduler2)\n    .test((data) => {\n        console.log(data)\n    })\n\nsuccessionScheduler.request()\n```\nThe scheduler group passes through the scheduler\'s filters and interceptors within the group as it processes the data.\n\n```javascript\nlet scheduler1 = reixs(\'http://api1...\')\n    .resPipes(data => data + 1)\n\nlet scheduler2 = reixs(\'http://api2...\')\n    \n// After requesting api1, the data is filtered as a parameter to the request api2.\nlet successionScheduler = reixs.succession(scheduler1, scheduler2)\n    .test((data) => {\n        console.log(data)\n    })\n```\nThe scheduler group inherits the life cycle of the reixs scheduler and the throttling operations\n\n```javascript\nlet allScheduler = reixs.all(scheduler1, scheduler2)\n    // Set 500ms throttling\n    .throttle(500)\n    // Request sending starts\n    .start(() => {\n        console.log(\'Request start\')\n    })\n    // Error time\n    .error(error => {\n        throw error\n    })\n    .test((data1, data2) => {\n        console.log(data1, data2)\n    })\n\nallScheduler.request()\n```\nBecause a scheduler group is itself a scheduler, it can be nested freely.\n\n```javascript\nlet scheduler1 = reixs(\'http://api1...\')\nlet scheduler2 = reixs(\'http://api2...\')\n\nlet raceScheduler = reixs.race(scheduler1, scheduler2)\n\nlet allScheduler = reixs.all(raceScheduler, scheduler2)\n\nlet successionScheduler = reixs.succession(allScheduler, raceScheduler)\n```\n\n## Contributors\nThanks to everyone who contributed to the source code, comments, scripts, documentation, and test cases.\n<a href="https://github.com/reixs/reixs/graphs/contributors"><img src="https://opencollective.com/reixs/contributors.svg?width=890" /></a>\n\n'