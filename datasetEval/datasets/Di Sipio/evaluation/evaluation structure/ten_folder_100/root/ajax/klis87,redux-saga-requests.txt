b'# redux-saga-requests\n\n[![npm version](https://badge.fury.io/js/redux-saga-requests.svg)](https://badge.fury.io/js/redux-saga-requests)\n[![gzip size](http://img.badgesize.io/https://unpkg.com/redux-saga-requests/dist/redux-saga-requests.min.js?compression=gzip)](https://unpkg.com/redux-saga-requests)\n[![dependencies](https://david-dm.org/klis87/redux-saga-requests.svg?path=packages/redux-saga-requests)](https://david-dm.org/klis87/redux-saga-requests?path=packages/redux-saga-requests)\n[![dev dependencies](https://david-dm.org/klis87/redux-saga-requests/dev-status.svg?path=packages/redux-saga-requests)](https://david-dm.org/klis87/redux-saga-requests?path=packages/redux-saga-requests&type=dev)\n[![peer dependencies](https://david-dm.org/klis87/redux-saga-requests/peer-status.svg?path=packages/redux-saga-requests)](https://david-dm.org/klis87/redux-saga-requests?path=packages/redux-saga-requests&type=peer)\n[![Build Status](https://travis-ci.org/klis87/redux-saga-requests.svg?branch=master)](https://travis-ci.org/klis87/redux-saga-requests)\n[![Coverage Status](https://coveralls.io/repos/github/klis87/redux-saga-requests/badge.svg?branch=master)](https://coveralls.io/github/klis87/redux-saga-requests?branch=master)\n[![Known Vulnerabilities](https://snyk.io/test/github/klis87/redux-saga-requests/badge.svg)](https://snyk.io/test/github/klis87/redux-saga-requests)\n[![lerna](https://img.shields.io/badge/maintained%20with-lerna-cc00ff.svg)](https://lernajs.io/)\n[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n\nRedux-Saga addon to simplify handling of AJAX requests. It supports Axios, Fetch API and GraphQL, but different\nintegrations could be added, as they are implemented in a plugin fashion.\n\n## Table of content\n\n- [Motivation](#motivation-arrow_up)\n- [Installation](#installation-arrow_up)\n- [Usage](#usage-arrow_up)\n- [Actions](#actions-arrow_up)\n- [Reducers](#reducers-arrow_up)\n- [Selectors](#selectors-arrow_up)\n- [Interceptors](#interceptors-arrow_up)\n- [FSA](#fsa-arrow_up)\n- [Promise middleware](#promise-middleware-arrow_up)\n- [Cache middleware](#cache-middleware-arrow_up)\n- [Usage with Fetch API](#usage-with-fetch-api-arrow_up)\n- [Usage with GraphQL](#usage-with-graphql-arrow_up)\n- [Mocking](#mocking-arrow_up)\n- [Multiple drivers](#multiple-drivers-arrow_up)\n- [React bindings](#react-bindings-arrow_up)\n- [Server side rendering](#react-bindings-arrow_up)\n- [Examples](#examples-arrow_up)\n\n## Motivation [:arrow_up:](#table-of-content)\n\nWith `redux-saga-requests`, assuming you use `axios` you could refactor a code in the following way:\n```diff\n  import axios from \'axios\';\n- import { takeEvery, put, call } from \'redux-saga/effects\';\n+ import { createRequestInstance, watchRequests, requestsReducer } from \'redux-saga-requests\';\n+ import { createDriver } from \'redux-saga-requests-axios\';\n\n  const FETCH_BOOKS = \'FETCH_BOOKS\';\n- const FETCH_BOOKS_SUCCESS = \'FETCH_BOOKS_SUCCESS\';\n- const FETCH_BOOKS_ERROR = \'FETCH_BOOKS_ERROR\';\n\n- const fetchBooks = () => ({ type: FETCH_BOOKS });\n- const fetchBooksSuccess = data => ({ type: FETCH_BOOKS_SUCCESS, data });\n- const fetchBooksError = error => ({ type: FETCH_BOOKS_ERROR, error });\n+ const fetchBooks = () => ({\n+   type: FETCH_BOOKS,\n+   request: {\n+     url: \'/books\',\n+     // you can put here other Axios config attributes, like method, data, headers etc.\n+   },\n+ });\n\n- const defaultState = {\n-   data: null,\n-   pending: 0, // number of pending FETCH_BOOKS requests\n-   error: null,\n- };\n-\n- const booksReducer = (state = defaultState, action) => {\n-   switch (action.type) {\n-     case FETCH_BOOKS:\n-       return { ...defaultState, pending: state.pending + 1 };\n-     case FETCH_BOOKS_SUCCESS:\n-       return { ...defaultState, data: action.data, pending: state.pending - 1 };\n-     case FETCH_BOOKS_ERROR:\n-       return { ...defaultState, error: action.error, pending: state.pending - 1 };\n-     default:\n-       return state;\n-   }\n- };\n+ const booksReducer = requestsReducer({ actionType: FETCH_BOOKS });\n\n- const fetchBooksApi = () => axios.get(\'/books\');\n-\n- function* fetchBooksSaga() {\n-   try {\n-     const response = yield call(fetchBooksApi);\n-     yield put(fetchBooksSuccess(response.data));\n-   } catch (e) {\n-     yield put(fetchBooksError(e));\n-   }\n- }\n-\n  function* rootSaga() {\n-   yield takeEvery(FETCH_BOOKS, fetchBooksSaga);\n+   yield createRequestInstance({ driver: createDriver(axios) });\n+   yield watchRequests();\n  }\n```\nWith `redux-saga-requests`, you no longer need to define error and success actions to do things like error handling\nor showing loading spinners. You don\'t need to write requests related repetitive sagas and reducers either.\n\nHere you can see the list of features this library provides:\n- you define your AJAX requests as simple actions, like `{ type: FETCH_BOOKS, request: { url: \'/books\' } }` and `success`,\n`error` (`abort` is also supported, see below) actions will be dispatched automatically for you\n- `success`, `error` and `abort` functions, which add correct and consistent suffixes to your request action types\n(check [low-level-reducers example](https://github.com/klis87/redux-saga-requests/tree/master/examples/low-level-reducers)\nto see how to use those functions in your reducers)\n- `requestsReducer` higher order reducer, which takes requests related state management burden from your shoulders\n- automatic request abort - when a saga is cancelled, a request made by it is automatically aborted and an abort action\nis dispatched (especially handy with `takeLatest` and `race` Redux-Saga effects)\n- sending multiple requests in one action - `{ type: FETCH_BOOKS_AND_AUTHORS, request: [{ url: \'/books\' }, { url: \'/authors}\'] }`\nwill send two requests and wrap them in `Promise.all`\n- flexibility - you can use "auto mode" `watchRequests`\n(see [basic example](https://github.com/klis87/redux-saga-requests/tree/master/examples/basic)),\nor lower level `sendRequest`\n(see [advanced example](https://github.com/klis87/redux-saga-requests/tree/master/examples/advanced)),\nor... you could even access your request instance with `getRequestInstance`\n- support for Axios, Fetch API and GraphQL - additional clients could be added, you could even write your own client\nintegration as a `driver` (see [./packages/redux-saga-requests-axios/src/axios-driver.js](https://github.com/klis87/redux-saga-requests/blob/master/packages/redux-saga-requests-axios/src/axios-driver.js)\nfor the example)\n- optimistic updates support, so your views can be updated even before requests are finished, while you still keep consistency in case of errors by reverting optimistic updates\n- cache support with optional `requestsCacheMiddleware`\n- mocking - mock driver, which use can use for test purposes or when you would like to integrate with API not yet implemented (and once API is finished, you could just change driver to Axios or Fetch and magicaly everything will work!)\n- multiple driver support - for example you can use Axios for one part of your requests and Fetch Api for another part\n- compatible with FSA, `redux-act` and `redux-actions` libraries (see [redux-act example](https://github.com/klis87/redux-saga-requests/tree/master/examples/redux-act-integration))\n- simple to use with server side rendering - you can structure your code however you want and `countServerRequests` will let you\nknow when all requests are done on the server side and when you can render your app\n- `onRequest`, `onSuccess`, `onError` and `onAbort` interceptors, you can attach your sagas (or simple functions)\nto them to define a global behaviour for a given event type\n- optional `requestsPromiseMiddleware`, which promisifies requests actions dispatch, so you can wait in your react components to get request response, the same way like you can do this with `redux-thunk`\n- React bindings in `redux-saga-requests-react` package\n\n## Installation [:arrow_up:](#table-of-content)\n\nTo install the package, just run:\n```\n$ yarn add redux-saga-requests\n```\nor...\n```\n$ npm install redux-saga-requests\n```\nor you can just use CDN: `https://unpkg.com/redux-saga-requests`.\n\nAlso, you need to install a driver:\n- if you use Axios, install `axios` and `redux-saga-requests-axios`:\n\n  ```\n  $ yarn add axios redux-saga-requests-axios\n  ```\n  or...\n  ```\n  $ npm install axios redux-saga-requests-axios\n  ```\n  or CDN: `https://unpkg.com/redux-saga-requests-axios`.\n- if you use Fetch API, install `isomorphic-fetch` (or a different Fetch polyfill) and `redux-saga-requests-fetch`:\n\n  ```\n  $ yarn add isomorphic-fetch redux-saga-requests-fetch\n  ```\n  or...\n  ```\n  $ npm install isomorphic-fetch redux-saga-requests-fetch\n  ```\n  or CDN: `https://unpkg.com/redux-saga-requests-fetch`.\n\nOf course, because this is Redux-Saga addon, you also need to install `redux-saga`.\nAlso, it requires to install `reselect`.\n\n## Usage [:arrow_up:](#table-of-content)\n\nFor a basic usage, see [Motivation](#motivation-arrow_up) paragraph.\n\n### `watchRequests`\n\nAs you probably guessed, the most job is done by `watchRequests`, which is like a manager to your request actions - it sends\nrequests you define in your actions and dispatches success, error and abort actions, depending on the outcome. It can also\nautomatically abort requests. Aborting requests is a very important, but often neglected topic. Lets say you have a\npaginated list and a user asked for 1st page, then 2nd and lets assume response for 1st one will come later. Or... lets say a private\ndata are being fetched and before this request is finished a user logged out. You could introduce many race condition bugs like\nthis, without even realizing - they won\'t happen on your local machine (without throthling in your browser), but they could happen\non a production system, especially on a slow mobile internet, with a high latency. Because aborting is so important, you can pass\na config to `watchRequests` to adjust, how different actions will be aborted. This config has following attributes:\n- `abortOn: string | string[] | action => boolean`: allows you to define actions, on which requests should be aborted, has the\nsame form which you can pass to `redux-saga` `take` effect, for example `\'LOGOUT\'`, `[\'LOGOUT\']`,\n`action => action.type === \'LOGOUT\'`, default is `null`\n- `takeLatest: boolean | action => boolean`: if `true`, when a new request will be dispatched while a pending of the same type is still running,\nthe previous one will be automatically aborted, default is `true` for `GET` requests and `false` for the rest ones, or,\nfor GraphQL, `true` for queries and `false` for mutations\n- `getLastActionKey: action => string`: a key generator to match actions of the same type, typically you won\'t need to adjust it,\nbut it might come in handy when you want some actions with the same `type` to be treated as a different one,\ndefault is `action => action.type`.\n\nSo, for instance, you could do this:\n```js\nyield watchRequests({\n  takeLatest: false,\n  abortOn: \'LOGOUT\',\n});\n```\n\nAbove defines a global behaviour, but what if you want to have different settings for different actions?\nJust define `takeLatest` or `abortOn` in action `meta`, for example:\n```js\nconst fetchBooks = () => ({\n  type: FETCH_BOOKS,\n  request: {\n    url: \'/books\',\n  },\n  meta: {\n    takeLatest: false,\n    abortOn: \'LOGOUT\',\n  },\n});\n```\n\nMoreover, remember that `watchRequests` is a blocking effect, so if you have more sagas, use\n`yield fork(watchRequests)`, or wrap it with something else in `all`:\n```js\nimport { all, takeLatest, put } from \'redux-saga/effects\';\nimport { createRequestInstance, watchRequests, success } from \'redux-saga-requests\';\nimport { createDriver } from \'redux-saga-requests-axios\';\n\nfunction* fetchBooksSuccessSaga() {\n  yield put(addMessage(\'Books have been loaded\');\n}\n\nfunction* rootSaga() {\n  yield createRequestInstance({ driver: createDriver(axios) });\n  yield all([\n    // put it before other sagas which handle requests, otherwise watchRequests might miss some requests...\n    // or your sagas might miss requests actions, like success\n    watchRequests(),\n    takeLatest(success(\'FETCH_BOOK\'), fetchBooksSuccessSaga),\n  ]);\n}\n```\n\nLast, but not least, if for some reason you don\'t want your request action to be handled by `watchRequests`,\nyou can use `meta.runByWatcher`, like:\n```js\nconst fetchBooks = () => ({\n  type: FETCH_BOOKS,\n  request: {\n    url: \'/books\',\n  },\n  meta: {\n    runByWatcher: false,\n  },\n});\n```\n\n### `sendRequest`\n\nUnder the hood, `watchRequests` uses a lower level `sendRequest`. `watchRequests` should be flexible enough, so you won\'t need\nto worry about `sendRequest`, but it is useful to know about it, it is handy in [Interceptors](#interceptors-arrow_up). Also, if you don\'t\nlike the magic of `watchRequests`, you might use it everywhere, or... you could write your own `watchRequests`! This is how it\nworks:\n```js\nimport axios from \'axios\';\nimport { takeLatest } from \'redux-saga/effects\';\nimport { createRequestInstance, sendRequest } from \'redux-saga-requests\';\nimport { createDriver } from \'redux-saga-requests-axios\'; // or a different driver\n\nconst FETCH_BOOKS = \'FETCH_BOOKS\';\n\nconst fetchBooks = () => ({\n  type: FETCH_BOOKS,\n  request: { url: \'/books\' },\n});\n\nfunction* rootSaga() {\n  yield createRequestInstance({ driver: createDriver(axios) });\n  yield takeLatest(FETCH_BOOKS, sendRequest);\n}\n```\nNow, if `/books` request is pending and another `fetchBooks` action is triggered, the previous request will be aborted\nand `FETCH_BOOKS_ABORT` will be dispatched.\n\nYou could also use `race` effect:\n```js\nimport axios from \'axios\';\nimport { call, race, take, takeLatest } from \'redux-saga/effects\';\nimport { createRequestInstance, sendRequest } from \'redux-saga-requests\';\nimport { createDriver } from \'redux-saga-requests-axios\'; // or a different driver\n\nconst FETCH_BOOKS = \'FETCH_BOOKS\';\nconst CANCEL_REQUEST = \'CANCEL_REQUEST\';\n\nconst fetchBooks = () => ({\n  type: FETCH_BOOKS,\n  request: { url: \'/books\' },\n});\n\nconst cancelRequest = () => ({ type: CANCEL_REQUEST });\n\nfunction* fetchBookSaga(fetchBookAction) {\n  yield race([\n    call(sendRequest, fetchBookAction),\n    take(CANCEL_REQUEST),\n  ]);\n}\n\nfunction* rootSaga() {\n  yield createRequestInstance({ driver: createDriver(axios) });\n  yield takeLatest(FETCH_BOOKS, fetchBookSaga);\n}\n```\nIn above case, not only the last `/books` request could be successful, but also it could be aborted with `cancelRequest`\naction, as `sendRequest` would be aborted as it would lose with `take(CANCEL_REQUEST)` effect.\n\nOf course, you can send requests directly also from your sagas:\n```js\nfunction* fetchBookSaga() {\n  const { response, error } = yield call(\n    sendRequest,\n    fetchBooks(),\n    { dispatchRequestAction: true },\n  );\n\n  if (response) {\n    // do sth with response\n  } else {\n    // do sth with error\n  }\n}\n```\nThe key here is, that you need to pass `{ dispatchRequestAction: true }` as second argument to `sendRequest`, so that `fetchBooks` action will be\ndispatched - usually it is already dispatched somewhere else (from your React components `onClick` for instance),\nbut here not, so we must explicitely tell `sendRequest` to dispatch it. Also, setting `dispatchRequestAction` as `true`\nwill set your request action meta `runByWatcher` as `false`, so if you happen to use `watchRequests`, you won\'t end up with\nduplicated requests.\n\n### `getRequestInstance`\n\nAlso, it is possible to get access to your request instance (like Axios) in your Saga:\n```js\nimport { getRequestInstance } from \'redux-saga-requests\';\n\nfunction* fetchBookSaga() {\n  const requestInstance = yield getRequestInstance();\n  /* now you can do whatever you want, for example, if u use axios:\n  const response = yield call(requestInstance.get, \'/some-url\') */\n}\n```\nYou can do whatever you want with it, which gives you maximum flexibility. Typically it is useful in [Interceptors](#interceptors-arrow_up),\nwhen you want to make some request directly, without using redux action - for redux action you would use `sendRequest`.\n\n## Actions [:arrow_up:](#table-of-content)\n\nNo matter whether you use `watchRequests` or `sendRequest`, you only need to define request actions, which will trigger AJAX\ncalls for you, as well as dispatch success, error or abort actions. Lets say you defined a following request\naction:\n```js\nconst deleteBook = id => ({\n  type: \'DELETE_BOOK\',\n  request: {\n    url: `/books/${id}`,\n    method: \'delete\'\n  },\n  meta: { // meta is optional, it will be added to success, error or abort action when defined\n    id,\n  },\n});\n```\n\nWith this request action, assuming `id = 1`, following actions will be dispatched, depending on the request outcome:\n\n### Successful response\n\n```js\n{\n  type: \'DELETE_BOOK_SUCCESS\',\n  response: { data: \'some data\' },\n  data: \'some data\',\n  meta: {\n    id: 1, // got from request action meta\n    requestAction: {\n      type: \'DELETE_BOOK\',\n      request: {\n        url: \'/books/1\',\n        method: \'delete\'\n      },\n      meta: {\n        id: 1,\n      },\n    },\n  },\n}\n```\n\n### Error response\n\n```js\n{\n  type: \'DELETE_BOOK_ERROR\',\n  error: \'a server error\',\n  meta: {\n    id: 1, // got from request action meta\n    requestAction: {\n      type: \'DELETE_BOOK\',\n      request: {\n        url: \'/books/1\',\n        method: \'delete\'\n      },\n      meta: {\n        id: 1,\n      },\n    },\n  },\n}\n```\n\n### Aborted request\n\n```js\n{\n  type: \'DELETE_BOOK_ABORT\',\n  meta: {\n    id: 1, // got from request action meta\n    requestAction: {\n      type: \'DELETE_BOOK\',\n      request: {\n        url: \'/books/1\',\n        method: \'delete\'\n      },\n      meta: {\n        id: 1,\n      },\n    },\n  },\n}\n```\n\n## Reducers [:arrow_up:](#table-of-content)\n\nExcept for `watchRequests` and `sendRequest`, which can simplify your actions and sagas a lot, you can also use\n`requestsReducer` or `networkReducer`, higher order reducers, which are responsible for a portion of your state related to given requests.\n\n### requestsReducer\n\nFor a general idea how it works, see [Motivation](#motivation-arrow_up) paragraph. This is just a minimal example, where with simple:\n```javascript\nconst reducer = requestsReducer({ actionType: `FETCH_SOMETHING` });\n```\nyou already have a working reducer which will handle `FETCH_SOMETHING`, `FETCH_SOMETHING_SUCCESS`,\n`FETCH_SOMETHING_ERROR` and `FETCH_SOMETHING_ABORT` actions, updating a following state attributes for you:\n- `data`: here a data from your API will be kept, updated after `FETCH_SOMETHING_SUCCESS` is dispatched, initially\nset to `null` (default) or `[]`, depending on `multiple` config attribute (see below)\n- `error`: initially `null`, updated to a HTTP error after `FETCH_SOMETHING_ERROR` is dispatched\n- `pending`: number of pending `FETCH_SOMETHING` requests, initially `0`, incremented by `1` for each `FETCH_SOMETHING`,\nand decremented by `1` for each of `FETCH_SOMETHING_SUCCESS`, `FETCH_SOMETHING_ERROR`, `FETCH_SOMETHING_ABORT`\n(implemeted as `integer`, not `boolean` due to possibility of multiple pending requests of the same type -\nfor example in a sequence `FETCH_SOMETHING`, `FETCH_SOMETHING`, `FETCH_SOMETHING_SUCCESS` we would set `pending`\nto `false`, despite the fact 2nd `FETCH_SOMETHING` is still running, with `integer` `pending` will be set to `1`,\nwhich for example allows you to easily write a selector like `showSpinner = pending => pending > 0`)\n\nIn order to be flexible, apart from `actionType` passed in `requestsReducer` config, optionally you can pass any of\nfollowing attributes:\n- `multiple: boolean`: default to `false`, change it to `true` if you want your not loaded data to be stored as `[]`\ninstead of `null`\n- `getDefaultData: (multiple: boolean) => any`: use instead of `multiple`, if you want your initial data to be\nsomething else than `null` or `[]`, for instance `() => ({ value: null })`, `multiple => (multiple ? [] : null)`\nby default\n- `getData: (state, action, config) => data`: describes how to get data from `action` object, by default returns `action.data` or `action.payload.data` when action is FSA compliant\n- `updateData: (state, action, config) => data`: optional, useful together with operations to overwrite `getData` default, see more\ninformation in `mutations`\n- `getError: (state, action, config) => data`: describes how to get error from `action` object, by default returns `action.error` or `action.payload` when action is FSA compliant\n- `onRequest: (state, action, config) => nextState`: here you can adjust how `requestReducers` handles request actions\n- `onSuccess: (state, action, config) => nextState`: here you can adjust how `requestReducers` handles success actions\n- `onError: (state, action, config) => nextState`: here you can adjust how `requestReducers` handles error actions\n- `onAbort: (state, action, config) => nextState`: here you can adjust how `requestReducers` handles abort actions\n- `resetOn: action => boolean or string[]`: callback or array of action types on which reducer will reset its state to initial one, for instance `[\'LOGOUT\']` or `action => action.type === \'LOGOUT\'`, `[]` by default\n- `mutations`: optional object which you can use to map write actions like update/delete to `data` update, which also adds pending\nstate and errors for each defined mutation and allows optimistic updates, see more details below\n\nFor example:\n```js\nconst reducer = requestsReducer({ actionType: `FETCH_SOMETHING`, multiple: true });\n```\nwhich will keep your empty data as `[]`, not `null`.\n\nFor inspiration how you could override any of those attributes, see default config\n[source](https://github.com/klis87/redux-saga-requests/blob/master/packages/redux-saga-requests/src/reducers.js#L43).\n\nYou might also want to adjust any configuration for all your requests reducers globally. Here is how you can do this:\n```js\nimport { requestsReducer } from \'redux-saga-requests\';\n\nconst myRequestsReducer = config => requestsReducer({ multiple: true ...config });\n```\nNow, instead of built-in `requestsReducer`, you can use your own one, and from now on all reducers will have `multiple` set as `true` by default.\n\nAnother big feature of reducers are mutations. They allow you to add additional actions to update `data`, with extra\ninformation kept in state useful to render button spinners or error messages. For example, lets say you have following request\nactions:\n```js\nconst fetchBooks = () => ({\n  type: \'FETCH_BOOKS\',\n  request: { url: \'/books\' },\n})\n\nconst deleteAllBooks = () => ({\n  type: \'DELETE_ALL_BOOKS\',\n  request: { url: \'/books\', method: \'delete\' },\n})\n```\n\nYou can create a following reducer:\n```js\nconst booksReducer = requestsReducer({\n  actionType: \'FETCH_BOOKS\',\n  multiple: true,\n  mutations: {\n    DELETE_ALL_BOOKS: { updateData: (state, action) => [] } // or just (state, action) => []\n  },\n});\n```\nwhich will give you the following initial state:\n```js\n{\n  data: [],\n  error: null,\n  pending: 0,\n  mutations: {\n    DELETE_ALL_BOOKS: {\n      error: null,\n      pending: 0,\n    },\n  },\n};\n```\n\nNotice that `mutations` structure resembles the one from config we just passed, giving you\nuseful `error` and `pending` state per mutation. You can use them for example to show spinner or to disable `DELETE` button\nor to show a request error. Also, after a successful delete mutation, `data` will be set to `[]` as defined in `updateData`.\n\nIt is also good to know, that you can set `updateData` to `false`, which would disable `data` manipulation and such a mutation\nwould be responsible only for `pending` and `error` state. Moreover, you can set `updateData` as `true`, which is useful to avoid\nduplication, as often your server responses are the same for multiple mutations. Setting to `true` will fallback to top level\n`updateData` defined in `requestsReducer` config, and if `updateData` is not defined, global `getData` will be used.\n\nThere is one more case to cover in mutations. Imagine we need another action:\n```js\nconst deleteBook = id => ({\n  type: \'DELETE_BOOK\',\n  request: { url: `/book/${id}`, method: \'delete\' },\n})\n```\n\nNow, lets say we have a view with multiple books on one page and we want to show independent spinners for each\ncorresponding `DELETE` button. Can you see the problem? If we just add `DELETE_BOOK` operation like `DELETE_ALL_BOOKS`,\n`pending` counter would be aggregated and all buttons would spin. We need to divide `DELETE_BOOK` per id, here is how we can\nachieve this:\n```js\nconst deleteBook = id => ({\n  type: \'DELETE_BOOK\',\n  request: { url: `/book/${id}`, method: \'delete\' },\n  meta: {\n    id, // we will need this id in reducer\n  },\n})\n\nconst booksReducer = requestsReducer({\n  actionType: \'FETCH_BOOKS\',\n  multiple: true,\n  mutations: {\n    DELETE_ALL_BOOKS: (state, action) => [],\n    DELETE_BOOK: {\n      updateData: (state, action) => state.data.filter(book => book.id !== action.meta.id),\n      getRequestKey: requestAction => String(requestAction.meta.id), // you need to use string if id is an integer\n    }\n  }\n});\n```\nwhich will give you the following initial state:\n```js\n{\n  data: [],\n  error: null,\n  pending: 0,\n  mutations: {\n    DELETE_ALL_BOOKS: {\n      error: null,\n      pending: 0,\n    },\n    DELETE_BOOK: {},\n  },\n};\n```\n... and if a `deleteBook` with `id` `1` and `2` are running, state would be:\n```js\n{\n  data: [],\n  error: null,\n  pending: 0,\n  mutations: {\n    DELETE_ALL_BOOKS: {\n      error: null,\n      pending: 0,\n    },\n    DELETE_BOOK: {\n      1: {\n        error: null,\n        pending: 1,\n      },\n      2: {\n        error: null,\n        pending: 1,\n      },\n    },\n  },\n};\n```\n\nSo, `DELETE_BOOK` state is one lever deeper, with state divided per `id`. Be careful though to always check whether\nobject with a given `id` exists before reading `pending` or `error` state, even after successful response, as\nyou will never see below state:\n```js\nDELETE_BOOK: {\n  1: {\n    error: null,\n    pending: 0,\n  },\n  2: {\n    error: null,\n    pending: 0,\n  },\n},\n```\nas instead of resetting `pending` to `0`, a given object is just removed to release memory.\n\nAs a bonus, mutations come with optimistic updates support, so `data` can be updated even before requests are finished! Of course only if you can predict\nserver response. Let\'s update `DELETE_BOOK` mutation to support optimistic updates:\n```js\nconst deleteBook = book => ({\n  type: \'DELETE_BOOK\',\n  request: { url: `/book/${book.id}`, method: \'delete\' },\n  meta: {\n    book, // we will need the whole book\n  },\n})\n\nconst booksReducer = requestsReducer({\n  actionType: \'FETCH_BOOKS\',\n  multiple: true,\n  mutations: {\n    DELETE_ALL_BOOKS: (state, action) => [],\n    DELETE_BOOK: {\n      updateDataOptimistic: (state, action) => state.data.filter(book => book.id !== action.meta.book.id),\n      revertData: (state, action) => [action.meta.book, ...state.data],\n      getRequestKey: requestAction => String(requestAction.meta.book.id),\n    }\n  }\n});\n```\nSo what changed? We pass the whole `book` object, not only `id` to `deleteBook`, which is used in `revertData` later.\nWe replaced `updateData` with `updateDataOptimistic`, which updates `data` immediately after `DELETE_BOOK` request\nis fired, so even if this request was slow, your view would be updated at once anyway! What in case of errors though?\nWe need to revert the state by putting the cancelled book back to `data` array. So, in case of an error, `DELETE_BOOK_ERROR`\nwould be dispatched and `revertData` would be called. Optionally, it is possible to define `updateData` next to\n`updateDataOptimistic`, for example to replace a mocked id generated during an optimistic insert action with a server id. Also,\nnote that `revertData` would be also called for aborted requests, like `DELETE_BOOK_ABORT` in our example. Usually you won\'t get\naborted operations though, unless you use `takeLatest: true` for an operation. This is not recommended to use together with\noptimistic update though, because for an aborted request there is no way to tell whether an operation succedded or not, so\nit is impossible to tell whether we should revert or not.\n\nAlso, sometimes you might have a situation which requires to update `data` with a local action, not a remote mutation.\nFor this, you can use a local mutation, for instance:\n```js\nconst deleteAllBooks = () => ({ type: \'DELETE_ALL_BOOKS\' });\n\nconst booksReducer = requestsReducer({\n  actionType: \'FETCH_BOOKS\',\n  multiple: true,\n  mutations: {\n    DELETE_ALL_BOOKS: {\n      updateData: (state, action) => [],\n      local: true,\n    },\n  },\n});\n```\n\n### networkReducer\n\nThis is a manager of `requestsReducer` instances, so you don\'t need to write reducers for your remote state anymore!\nIt is recent additional to this library, but it is the recommended way to use it and probably `requestsReducer` will be removed\nfrom public API. The difference is that you define only one `networkReducer` and config you used in `requestsReducer` now\nyou need to move to action.meta. Also, because all remote state is kept in standardized form, not only you don\'t need to write\nreducers for remote data, but selectors also become redundant! Just use `getQuery`, `getMutation` and React helpers if you use\nReact.\n\nSo how does it work? Before going into that, lets divide all requests into queries and mutations. Queries have `data`, while mutations\ncan change it. By default, for REST drivers queries are requests with `GET` method, the rest are mutations. For graphql... not by coincidence... queries are queries and mutations are mutations. Actually this division is taken from graphql naming convention.\n\nThis division is necessary because `networkReducer` needs to know whether request is a query or a mutation, because it handles\nthem differently. You can adjust this distinction by providing `isRequestActionQuery` to `networkReducer`. Also, if the default behaviour\nis good for your use case, but sometimes you have an exception, you can use `action.meta.asMutation` `true` or `false`, for instance:\n```js\nconst fetchBooks = () => ({\n  type: \'FETCH_BOOKS\',\n  request: { url: \'/books\' },\n  meta: { asMutation: true },\n})\n```\nAbove action will be treated as mutation, not query.\n\nSo how to use `networkReducer`? Just put it as `network` key in your top reducer:\n```js\nimport { combineReducers } from \'redux\';\nimport { networkReducer } from \'redux-saga-requests\';\n\nconst reducer = combineReducers({\n  network: networkReducer({\n    // isRequestActionQuery\n    // getData,\n    // updateData,\n    // getError,\n    // onRequest,\n    // onSuccess,\n    // onError,\n    // onAbort,\n    // resetOn,\n  })\n})\n```\nAbove you can see additional optional settings which it supports, they work the same\nas in `requestsReducer` and actually here you can just provide defaults for dynamically created\n`requestsReducer` instances. Remember you still could override them in action.meta.\n\n`networkReducer` default state is `{ queries: {}, mutations: {} }` and it reacts on requests actions.\nFor example when you dispatch:\n```js\nconst fetchBooks = () => ({\n  type: \'FETCH_BOOKS\',\n  request: { url: \'/books\' },\n})\n```\nthe state will be updated to:\n```js\n{\n  queries: {\n    FETCH_BOOKS: {\n      data: null,\n      pending: 1,\n      error: null,\n    },\n  },\n  mutations: {},\n}\n```\nAs you can see, it groups your remote state by queries and mutations, and those by action types.\nThe rest works the same as with `requestsReducer`.\n\nNow, for queries you can use `resetOn`, `getData`, `updateData`, `getError` in the same way you did for `requestsReducer`, just put them in action.meta.\nNotice that `actionType` does not make sense as `action.type` defines it. Also, `multiple` and `getDefaultData` also cannot be supported\nas it could be used only after an initial dispatch of a query. You would get inconsistent results then. That\'s why it is\nrecommented to use `getQuery` and `getMutation` selectors. Regarding mutations, you need to revert the way it worked in `requestsReducer`.\nThere you defined all possible mutations inside `requestsReducer` config, so mutations where coupled with queries. With `networkReducer`\nyou put mutation config inside action.meta of mutation actions. For example:\n```js\nconst deleteBook = id => ({\n  type: \'DELETE_BOOK\',\n  meta: {\n    id,\n    mutations: {\n      getRequestKey: requestAction => String(requestAction.meta.book.id),\n      FETCH_BOOKS: {\n        updateDataOptimistic: (state, action) => state.data.filter(book => book.id !== action.meta.book.id),\n        revertData: (state, action) => [action.meta.book, ...state.data],\n      },\n    },\n  },\n});\n```\nSo, it is similar, but now keys inside mutations are actually queries types. Also, `getRequestKey`\ngoes directly into `mutation`. Additional change compared to `requestsReducer` is that\nall mutations state is handled, so you don\'t need to do things like `updateData: false`.\n\n### Custom reducers\nOf course can write your reducers in a standard way too, but you might consider using `success`, `error` and `abort` helpers, which can add proper suffixes for you:\n```js\nimport { success, error, abort } from \'redux-saga-requests\';\n\nconst initialState = {\n  data: null,\n  fetching: false,\n  error: false,\n};\n\nconst FETCH_BOOKS = \'FETCH_BOOKS\';\n\nconst booksReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case FETCH_BOOKS:\n      return { ...initialState, fetching: true };\n    case success(FETCH_BOOKS):\n      return {\n        ...initialState,\n        data: { ...action.data },\n      };\n    case error(FETCH_BOOKS):\n      return { ...initialState, error: true };\n    case abort(FETCH_BOOKS):\n      return { ...initialState, fetching: false };\n    default:\n      return state;\n  }\n};\n```\n\n## Selectors [:arrow_up:](#table-of-content)\n\n### getQuery\n\n`getQuery` returns `reselect` selector, which gets a query state from Redux store with\nconverted `pending` key into `boolean` `loading` as `loading: pending > 0` for convenience.\nReturned selector also returns fallback query when it does not exist yet in your reducer as\n`{ data: null, error: null, loading: false }` so you always have the same object\nstructure. Because it uses `reselect`, it is friendly\nwith `React` `memo`/`PureComponent` optimisations. To use it, pass object as argument\nwith the following keys:\n- `type: string`: just pass action type or action itself when using action creator library, possible only when using `networkReducer`,\n- `requestSelector`: for instance `state => state.request`, use only when you use `requestsReducer`\n- `multiple`: set to `true` if you prefer `data` to be `[]` instead of `null`, `false` by default\n- `defaultData`: use it to represent `data` as an orbitrary object instead of `null`\n\nFor example:\n```js\nimport { getQuery } from \'redux-saga-requests\';\n\n// when using networkReducer\nconst querySelector = getQuery({ type: QUERY_TYPE });\n\n// when using requestsReducer\nconst querySelector = getQuery({ requestSelector: state => state.request });\n\nconst queryState = querySelector(state);\n```\n\n### `getMutation`\n\n`getMutation` returns `reselect` selector, which gets a mutation state from Redux store and converts `pending` key into `boolean` `loading` as `loading: pending > 0` for convenience. Returned selector also returns fallback mutation when it does not exist yet in your reducer as\n`{ error: null, loading: false }` so you always have the same object structure.\nTo use it, pass object as argument with one of the following keys:\n- `type: string`: just pass action type or action itself when using action creator library\n- `requestSelector`: only when using `requestsReducer`, for instance `state => state.request`, the same as in `getQuery`\n- `requestKey: string`: only necessary if you defined `getRequestKey` in a mutation,\nusually it will be some kind of id\n\nFor example:\n```js\nimport { getMutation } from \'redux-saga-requests\';\n\n// when using networkReducer\nconst mutationSelector = getMutation({ type: MUTATION_TYPE });\n\n// when using networkReducer and getRequestKey\nconst mutationSelector = getMutation({ type: MUTATION_TYPE, requestKey: \'1\' });\n\n// when using requestsReducer\nconst mutationSelector = getMutation({\n  type: MUTATION_TYPE,\n  requestSelector: state => state.request,\n});\n\nconst mutationState = mutationSelector(state);\n```\n\n## Interceptors [:arrow_up:](#table-of-content)\n\nYou can add global handlers to `onRequest`, `onSuccess`, `onError` add `onAbort`, like so:\n```js\nimport { sendRequest, getRequestInstance } from \'redux-saga-requests\';\n\nfunction* onRequestSaga(request, action) {\n  // do sth with you request, like add token to header, or dispatch some action etc.\n  return request;\n}\n\nfunction* onSuccessSaga(response, action) {\n  // do sth with the response, dispatch some action etc\n  return response;\n}\n\nfunction* onErrorSaga(error, action) {\n  // do sth here, like dispatch some action\n\n  // you must return { error } in case you dont want to catch error\n  // or { error: anotherError }\n  // or { response: someRequestResponse } if you want to recover from error\n\n  if (tokenExpired(error)) {\n    // get driver instance, in our case Axios to make a request without Redux\n    const requestInstance = yield getRequestInstance();\n\n    try {\n      // trying to get a new token\n      const { data } = yield call(\n        requestInstance.post,\n        \'/refreshToken\',\n      );\n\n      saveNewToken(data.token); // for example to localStorage\n\n      // we fire the same request again:\n      // - with silent: true not to dispatch duplicated actions\n      return yield call(sendRequest, action, { silent: true });\n\n      /* above is a handy shortcut of doing\n      const { response, error } = yield call(\n        sendRequest,\n        action,\n        { silent: true },\n      );\n\n      if (response) {\n        return { response };\n      } else {\n        return { error };\n      } */\n    } catch(e) {\n      // we didnt manage to get a new token\n      return { error: e }\n    }\n  }\n\n  // not related token error, we pass it like nothing happened\n  return { error };\n}\n\nfunction* onAbortSaga(action) {\n  // do sth, for example an action dispatch\n}\n\nfunction* rootSaga() {\n  yield createRequestInstance({\n    driver: createDriver(axios),\n    onRequest: onRequestSaga,\n    onSuccess: onSuccessSaga,\n    onError: onErrorSaga,\n    onAbort: onAbortSaga,\n  });\n  yield watchRequest();\n}\n```\n\nIf you need to use `sendRequest` in an interceptor, be aware of an additional options you\ncan pass to it:\n```js\n  yield call(sendRequest, action, {\n    silent: true,\n    runOnRequest: false,\n    runOnSuccess: false,\n    runOnError: false,\n    runOnAbort: false,\n});\n```\nGenerally, use `silent` if you don\'t want to dispatch actions for a given request.\nThe rest options is to disable given interceptors for a given request. By default `silent` is `false`,\nwhich simply means that `sendRequests` will dispatch Redux actions. The rest is slightly more dynamic:\n- if a request is sent by `watchRequests` or a `sendRequests` not from an interceptor, all interceptors\nwill be run\n- if you use `sendRequest` in `onRequest` interceptor, `runOnRequest` is set to `false`\n- if you use `sendRequest` in `onSuccess` interceptor, `runOnSuccess` and `runOnError` are set to `false`\n- if you use `sendRequest` in `onError` interceptor, `runOnError` is set to `false`\n- if you use `sendRequest` in `onAbort` interceptor, `runOnAbort` is set to `false`\n\nThose defaults are set to meet most use cases without the need to worry about disabling proper interceptors manually.\nFor example, if you use `sendRequest` in `onRequest` interceptor, you might end up with inifinite loop when `runOnRequest` was true.\nIf your use case vary though, you can always overwrite this behaviour by `runOn...` options.\n\n## FSA [:arrow_up:](#table-of-content)\n\nIf you like your actions to be compatible with\n[Flux Standard Action](https://github.com/acdlite/flux-standard-action#flux-standard-action),\nthat\'s totally fine, you can define your request actions like:\n```js\nconst fetchBooks = () => ({\n  type: \'FETCH_BOOKS\',\n  payload: {\n    request: {\n      url: \'/books\',\n    },\n  },\n  meta: { // optional\n    someKey: \'someValue\',\n  },\n});\n```\nThen, success, error and abort actions will also be FSA compliant. Moreover, `requestsReducer` will also correctly handle FSA actions.\nFor details, see [redux-act example](https://github.com/klis87/redux-saga-requests/tree/master/examples/redux-act-integration).\n\n## Promise middleware [:arrow_up:](#table-of-content)\n\nOne disadvantage of using sagas is that there is no way to dispatch an action which triggers a saga from React component and\nwait for this saga to complete. Because of this, integration with libraries like `Formik` are sometimes harder - for example you\nare forced to push some callbacks to Redux actions for a saga to execute later, which is not convenient. Thats why this library gives\nan optional `requestsPromiseMiddleware`:\n```js\nimport { createStore, applyMiddleware } from \'redux\';\nimport createSagaMiddleware from \'redux-saga\';\nimport { requestsPromiseMiddleware } from \'redux-saga-requests\';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  app,\n  applyMiddleware(requestsPromiseMiddleware(), sagaMiddleware),\n);\n```\n\nNow, lets say you defined an action:\n```js\nconst fetchBooks = () => ({\n  type: FETCH_BOOKS,\n  request: { url: \'/books\'},\n  meta: {\n    asPromise: true,\n  },\n});\n```\n\nYou can dispatch the action from a component and wait for a response:\n```js\nclass Books extends Component {\n  fetch = () => {\n    this.props.fetchBooks().then(successAction => {\n      // handle successful response\n    }).catch(errorOrAbortAction => {\n      // handle error or aborted request\n    })\n  }\n\n  render() {\n    // ...\n  }\n}\n```\n\nAlso, you can pass an optional `auto` flag to `requestsPromiseMiddleware`:\n```js\nrequestsPromiseMiddleware({\n  auto: true // if you with to promisify all request actions without explicit meta.asPromise true\n})\n```\nNote auto mode `true` will NOT promisify action with explicit `meta.asPromise: false`.\n\n## Cache middleware [:arrow_up:](#table-of-content)\n\nSometimes you might want your responses to be cached for an amount of time or even forever (until the page is not reloaded at least).\nOr, putting it another way, you would like to send a given request no more often than once for an amount of time. You can easily\nachieve it with an optional `requestsCacheMiddleware`:\n```js\nimport { createStore, applyMiddleware } from \'redux\';\nimport createSagaMiddleware from \'redux-saga\';\nimport { requestsCacheMiddleware } from \'redux-saga-requests\';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  app,\n  applyMiddleware(requestsCacheMiddleware(), sagaMiddleware),\n);\n```\n... or together with `requestsPromiseMiddleware`:\n```js\nimport { createStore, applyMiddleware } from \'redux\';\nimport createSagaMiddleware from \'redux-saga\';\nimport { requestsCacheMiddleware, requestsPromiseMiddleware } from \'redux-saga-requests\';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  app,\n  applyMiddleware(\n    requestsCacheMiddleware(), // put before requestsPromiseMiddleware\n    requestsPromiseMiddleware(),\n    sagaMiddleware,\n  ),\n);\n```\n\nAfter this setup, you can use `meta.cache`:\n```js\nconst fetchBooks = () => ({\n  type: FETCH_BOOKS,\n  request: { url: \'/books\'},\n  meta: {\n    cache: 10, // in seconds\n  },\n});\n```\n\nWhat will happen now, is that after a succesfull book fetch (to be specific after `FETCH_BOOKS_SUCCESS` is dispatched),\nany `FETCH_BOOKS` actions for `10` seconds won\'t trigger any AJAX calls and the following `FETCH_BOOKS_SUCCESS` will contain\ncached previous server response. You could also use `cache: true` to cache forever.\n\nAnother use case is that you might want to keep a separate cache for the same request action based on a cache key. For example:\n```js\nconst fetchBook = id => ({\n  type: FETCH_BOOK,\n  request: { url: `/books/${id}`},\n  meta: {\n    cache: true,\n    cacheKey: id // must be string\n  },\n});\n\n/* then, you will achieve the following behaviour:\n- GET /books/1 - make request\n- GET /books/1 - cache hit\n- GET /books/1 - cache hit\n- GET /books/2 - make request\n- GET /books/2 - cache hit\n- GET /books/1 - cache hit\n*/\n```\n\nThe only problem with above is that if you happen to request with too many different cache keys,\nthen cache would take too much memory. The remedy to this problem is `cacheSize`:\n```js\nconst fetchBook = id => ({\n  type: FETCH_BOOK,\n  request: { url: `/books/${id}`},\n  meta: {\n    cache: true,\n    cacheKey: id // must be string\n    cacheSize: 2 // any integer bigger or equal 1\n  },\n});\n\n/* then, you will achieve the following behaviour:\n- GET /books/1 - make request\n- GET /books/1 - cache hit\n- GET /books/1 - cache hit\n- GET /books/2 - make request\n- GET /books/2 - cache hit\n- GET /books/1 - cache hit\n- GET /books/3 - make request\n- GET /books/3 - cache hit\n- GET /books/2 - cache hit\n- GET /books/1 - make request! because /books/3 invalidated /books/1 as\nit was the oldest cache and our cache size was set to 2\n*/\n```\n\nIf you need to clear the cache for some reason, you can use `clearRequestsCache` action:\n```js\nimport { put } from \'redux-saga/effects\';\nimport { clearRequestsCache } from \'redux-saga-requests\';\n\nfunction* cacheSaga() {\n  yield put(clearRequestsCache()) // clear the whole cache\n  yield put(clearRequestsCache(FETCH_BOOKS)) // clear only FETCH_BOOKS cache\n  yield put(clearRequestsCache(FETCH_BOOKS, FETCH_AUTHORS)) // clear only FETCH_BOOKS and FETCH_AUTHORS cache\n}\n```\n\nAdditionally, you can use `getRequestCache` action for debugging purposes:\n```js\nimport { put } from \'redux-saga/effects\';\nimport { getRequestCache } from \'redux-saga-requests\';\n\nfunction* cacheSaga() {\n  const currentCache = yield put(getRequestCache());\n}\n```\n\n\n## Usage with Fetch API [:arrow_up:](#table-of-content)\n\nAll of the above examples show Axios usage, in order to use Fetch API, use below snippet:\n```js\nimport \'isomorphic-fetch\'; // or a different fetch polyfill\nimport { createRequestInstance, watchRequests } from \'redux-saga-requests\';\nimport { createDriver } from \'redux-saga-requests-fetch\';\n\nfunction* rootSaga() {\n  yield createRequestInstance({\n    driver: createDriver(\n      window.fetch,\n      {\n        baseURL: \'https://my-domain.com\' // optional - it works like axios baseURL, prepending all relative urls\n        AbortController: window.AbortController, // optional, if your browser supports AbortController or you use a polyfill like https://github.com/mo/abortcontroller-polyfill\n      }\n    ),\n  });\n  yield watchRequests();\n}\n```\nAnd in order to create Fetch API requests, below:\n```js\nfetch(\'/users\', {\n  method: \'POST\',\n  body: JSON.stringify(data),\n  headers: {\n    \'Content-Type\': \'application/json\',\n  },\n});\n```\nshould be translated to this:\n```javascript\nconst fetchUsers = () => ({\n  type: \'FETCH_USERS\',\n  request: {\n    url: \'/users/\',\n    method: \'POST\',\n    body: JSON.stringify(data),\n    headers: {\n      \'Content-Type\': \'application/json\',\n    },\n  }\n});\n```\nThe point is, you can use the same request config like you do with pure Fetch API, but you need to pass `url` in the\nconfig itself. Also, one additional parameter you could provide in the config is `responseType`, which is set as `json`\nas the default. Available response types are: `\'arraybuffer\'`, `\'blob\'`, `\'formData\'`, `\'json\'`, `\'text\'`, or `null`\n(if you don\'t want a response stream to be read for the given response).\n\nAlso, this driver reads response streams automatically for you (depending on `responseType` you choose)\nand sets it as `response.data`, so instead of doing `response.json()`, just read `response.data`.\n\n## Usage with GraphQL [:arrow_up:](#table-of-content)\n\nJust install `redux-saga-requests-graphql` driver. See\n[docs](https://github.com/klis87/redux-saga-requests/tree/master/packages/redux-saga-requests-graphql)\nfor more info.\n\n## Mocking [:arrow_up:](#table-of-content)\n\nProbably you are sometimes in a situation when you would like to start working on a feature which needs some integration with\nan API. What you can do then? Probably you just wait or start writing some prototype which then you will polish once API is finished. You can do better with `redux-saga-requests-mock`, especially with multi driver support, which you can read about in the\nnext paragraph. With this driver, you can define expected responses and errors which you would get from server and write your app\nnormally. Then, after API is finished, you will just need to replace the driver with a real one, like Axios or Fetch API, without\nany additional refactoring necessary, which could save you a lot of time!\n\nYou can use it like this:\n```js\nimport { createRequestInstance, watchRequests } from \'redux-saga-requests\';\nimport { createDriver } from \'redux-saga-requests-mock\';\n\nconst FETCH_PHOTO = \'FETCH_PHOTO\';\n\nconst fetchPhoto = id => ({\n  type: FETCH_PHOTO,\n  request: { url: `/photos/${id}` },\n});\n\nfunction* rootSaga() {\n  yield createRequestInstance({\n    driver: createDriver(\n      {\n        [FETCH_PHOTO]: (requestConfig, requestAction) => {\n          // mock normal response for id 1 and 404 error fot the rest\n          const id = requestConfig.url.split(\'/\')[2];\n\n          if (id === \'1\') {\n            return {\n              data: {\n                albumId: 1,\n                id: 1,\n                title: \'accusamus beatae ad facilis cum similique qui sunt\',\n              },\n            };\n          }\n\n          throw { status: 404 };\n        },\n      },\n      {\n        timeout: 1000, // optional, in ms, defining how much time mock request would take, useful for testing spinners\n        getDataFromResponse: response => response.data // optional, if you mock Axios or Fetch API, you dont need to worry about it\n      },\n    ),\n  });\n  yield watchRequests();\n}\n```\n\n## Multiple drivers [:arrow_up:](#table-of-content)\n\nYou can use multiple drivers if you need it. For example, if you want to use Axios by default, but also Fetch API\nsometimes, you can do it like this:\n```js\nimport axios from \'axios\';\nimport \'isomorphic-fetch\';\nimport { createRequestInstance, watchRequests } from \'redux-saga-requests\';\nimport { createDriver as createAxiosDriver } from \'redux-saga-requests-axios\';\nimport { createDriver as createFetchDriver } from \'redux-saga-requests-fetch\';\n\nfunction* rootSaga() {\n  yield createRequestInstance({\n    driver: {\n      default: createAxiosDriver(axios),\n      fetch: createFetchDriver(\n        window.fetch,\n        {\n          baseURL: \'https://my-domain.com\',\n          AbortController: window.AbortController,\n        },\n      ),\n    },\n  });\n  yield watchRequests();\n}\n```\n\nAs you can see, the default driver is Axios, so how to mark a request to be run by Fetch driver?\nJust pass the key you assigned Fetch driver to (`fetch` in our case) in `action.meta.driver`, for instance:\n```js\nconst fetchUsers = () => ({\n  type: \'FETCH_USERS\',\n  request: {\n    url: \'/users/\',\n    method: \'POST\',\n    body: JSON.stringify(data),\n    headers: {\n      \'Content-Type\': \'application/json\',\n    },\n  },\n  meta: {\n    driver: \'fetch\',\n  },\n});\n```\n\nAlso, if you want to use `getRequestInstance` with Fetch driver, just pass a proper driver key to it:\n```js\nimport { getRequestInstance } from \'redux-saga-requests\';\n\nfunction* fetchBookSaga() {\n  const requestInstance = yield getRequestInstance(\'fetch\');\n}\n```\n\n## React bindings [:arrow_up:](#table-of-content)\n\nJust install `redux-saga-requests-react`. See\n[docs](https://github.com/klis87/redux-saga-requests/tree/master/packages/redux-saga-requests-react)\nfor more info.\n\n## Server side rendering [:arrow_up:](#table-of-content)\n\nServer side rendering is a very complex topic and there are many ways how to go about it.\nMany people use the strategy around React components, for instance they attach static methods to components which\nmake requests and return promises with responses, then they wrap them in `Promise.all`. I don\'t recommend this strategy\nwhen using Redux, because this requires additional code and potentially double rendering on server, but if you really want\nto do it, it is possible. Normally it wouldn\'t be possible with Redux-Saga, but thanks to `requestsPromiseMiddleware`, dispatched\nrequest actions return promises, just like with `redux-thunk`.\n\nHowever, I recommend using another approach. See [server-side-rendering-example](https://github.com/klis87/redux-saga-requests/tree/master/examples/server-side-rendering) with the complete setup, but in a nutshell you can write universal code like you would\nnormally write it without SSR, with just only minor additions. Here is how:\n\n1. Before we begin, be advised that this strategy requires to dispatch requests on Redux level, at least those which have to be\nfired on application load. So for instance you cannot dispatch them inside `componentDidMount`. The obvious place to dispatch them\nis in your sagas, like `yield put(fetchBooks())`. However, what if your app has multiple routes, and each route has to send\ndifferent requests? Well, you need to make Redux aware of current route. I recommend to use a router with first class support for\nRedux, namely [redux-first-router](https://github.com/faceyspacey/redux-first-router). If you use `react-router` though, it is\nfine too, you just need to integrate it with Redux with\n[connected-react-router](https://github.com/supasate/connected-react-router). Then, you can use `take` effect to listen to\nroutes changes and/or get current location with `select` effect. This would give you information which route is active to know\nwhich requests to dispatch.\n2. On the server use `countServerRequests`, which keeps track of all your requests and will let you know when all requests\nare finished. Here you can see a possible implementation:\n    ```js\n    import { createStore, applyMiddleware, combineReducers } from \'redux\';\n    import createSagaMiddleware from \'redux-saga\';\n    import { all, put, call } from \'redux-saga/effects\';\n    import axios from \'axios\';\n    import {\n      createRequestInstance,\n      watchRequests,\n      countServerRequests,\n      serverRequestsFilterMiddleware,\n    } from \'redux-saga-requests\';\n    import { createDriver } from \'redux-saga-requests-axios\';\n\n    import { booksReducer } from \'./reducers\';\n    import { fetchBooks } from \'./actions\';\n\n    function* bookSaga() {\n      yield put(fetchBooks());\n    }\n\n    function* rootSaga(ssr = false, serverRequestActions) {\n      yield createRequestInstance({\n        driver: createDriver(\n          axios.create({\n            baseURL: \'http://localhost:3000\',\n          }),\n        ),\n      });\n\n      yield all(\n        [\n          ssr && call(countServerRequests, {\n            serverRequestActions\n            finishOnFirstError: true // default, you can change it to false\n          }),\n          call(watchRequests),\n          call(bookSaga),\n        ].filter(Boolean),\n      );\n    }\n\n    export const configureStore = (initialState = undefined) => {\n      const ssr = !initialState; // if initiaState is not passed, it means we run it on server\n      const reducers = combineReducers({\n        books: booksReducer,\n      });\n\n      const sagaMiddleware = createSagaMiddleware();\n\n      const middlewares = [\n        !ssr &&\n          serverRequestsFilterMiddleware({\n            serverRequestActions: window.__SERVER_REQUEST_ACTIONS__,\n          }),\n        sagaMiddleware,\n      ].filter(Boolean);\n\n      const store = createStore(\n        reducers,\n        initialState,\n        applyMiddleware(...middlewares),\n      );\n\n      store.runSaga = serverRequestActions =>\n        sagaMiddleware.run(rootSaga, ssr, serverRequestActions);\n      return store;\n    };\n\n    // on the server\n    import React from \'react\';\n    import { renderToString } from \'react-dom/server\';\n    import { Provider } from \'react-redux\';\n\n    // in an express/other server handler\n    const store = configureStore();\n    const serverRequestActions = {};\n    store\n      .runSaga(serverRequestActions)\n      .toPromise().then(() => { // done instead of toPromise() if you use redux-saga older than 1.0.0\n        if (serverRequestActions.errorActions.length > 0) {\n          res.status(400).send(\'something went wrong\');\n        } else {\n          const html = renderToString(\n            <Provider store={store}>\n              <App />\n            </Provider>,\n          );\n\n          res.render(\'index\', {\n            html,\n            initialState: JSON.stringify(store.getState()),\n            serverRequestActions: JSON.stringify(\n              serverRequestActions.requestActionsToIgnore,\n            ),\n          });\n        }\n      })\n    ```\n    As you can see, you only need to use `countServerRequests`, which will let you know\n    when you are ready to render plus it will give you information about any errors which could happen\n    during requests by mutating `serverRequestActions` you pass to it.\n\n    How does it work? `countServerRequests` logic is based on an internal counter. Initially it is set to `0` and is\n    increased by `1` after each request is initialized. Then, after each response it is decreased by `1`. So, initially after a first\n    request it gets positive and after all requests are finished, its value is again set back to `0`. And this is the moment\n    which means that all requests are finished. To make this notification, `countServerRequests` dispatches a special\n    action from `redux-saga`, namely `END`, which stops all your sagas. After your sagas are stopped,\n    `store.runSaga(serverRequestActions).done` promise is resolved. Then, it is time to inspect `serverRequestActions`, but before\n    we go into that, lets cover three edge cases.\n\n    One scenario you could be worried with above algorythm is what to do in case of an error. Obviously errors can\n    always happen for network call and actually by default `contServerRequest` dispatches `END` no matter what counter is\n    on any first encountered error response. You can change this behaviour by option `finishOnFirstError: false` to it.\n\n    Another problem you might think of is what to do if you don\'t want to dispatch any request for a given route?\n    Then counter would never be increased, so it would also never be decreased, so `countServerRequests` would never\n    dispatch `END`. How to fix this? Simple, if you know there is no request, just dispatch `END` yourself!\n    Just `import { END } from \'redux-saga\'` and `yield put(END)`\n\n    There is also more complex case. Imagine you have a request `x`, after which you would like to dispatch\n    another `y`. You cannot do it immediately because `y` requires some information from `x` response.\n    Above algorythm would not wait for `y` to be finished, because on `x` response counter would be\n    already reset to `0`. There are two `action.meta` attributes to help here:\n    - `dependentRequestsNumber` - a positive integer, a number of requests which will be fired after this one,\n    in above example we would put `dependentRequestsNumber: 1` to `x` action, because only `y` depends on `x`\n    - `isDependentRequest` - mark a request as `isDependentRequest: true` when it depends on another request,\n    in our example we would put `isDependentRequest: true` to `y`, because it depends on `x`\n\n    You could even have a more complicated situation, in which you would need to dispatch `z` after `y`. Then\n    you would also add `dependentRequestsNumber: 1` to `y` and `isDependentRequest: true` to `z`. Yes, a request\n    can have both of those attibutes at the same time! Anyway, how does it work? Easy, just a request with\n    `dependentRequestsNumber: 2` would increase counter by `3` on request and decrease by `1` on response,\n    while an action with `isDependentRequest: true` would increase counter on request by `1` as usual but decrease\n    it on response by `2`. So, the counter will be reset to `0` after all requests are finished, also dependent ones.\n\n    Going back to `serverRequestActions` object, it has the following properties:\n    - `successActions` - array of `success` actions that were dispatched, exluding dependent actions\n    - `dependentSuccessActions` - array `success` actions that were dispatched with `meta.isDependentRequest: true`\n    - `errorActions` - array of `error` actions if there was an error request\n    - `requestActionsToIgnore` - actions you should pass to client during SSR, actually this is\n    just array of requests actions with just `type` got from `successActions` (to decrease payload size\n    sent to the client side)\n\n3. The last thing you need to do is to use `serverRequestsFilterMiddleware` on the client side,\nlike in the snippet from step `2`. What does it do? Well, it will ignore request actions which match\nthose already dispatched during SSR. Why? Because otherwise with universal code the same job done on the server\nwould be repeated on the client. If you think about it, that is also the reason why `requestActionsToIgnore`\ndon\'t include `dependentSuccessActions`. Dependent request actions won\'t be dispatched on the client side,\nbecause request they depend on also won\'t be dispatched. One thing worth mentioning here is that\n`sendRequest` for ignored request won\'t return object with `response` or `error` key, but `{ serverSide: true }`.\nOne last thing, put `serverRequestsFilterMiddleware` before promise and cache middlewares if you happen to use those.\n\n## Examples [:arrow_up:](#table-of-content)\n\nI highly recommend to try examples how this package could be used in real applications. You could play with those demos\nand see what actions are being sent with [redux-devtools](https://github.com/zalmoxisus/redux-devtools-extension).\n\nThere are following examples currently:\n- [basic](https://github.com/klis87/redux-saga-requests/tree/master/examples/basic)\n- [advanced](https://github.com/klis87/redux-saga-requests/tree/master/examples/advanced)\n- [mutations](https://github.com/klis87/redux-saga-requests/tree/master/examples/mutations)\n- [mutations with requests reducers](https://github.com/klis87/redux-saga-requests/tree/master/examples/mutations-with-requests-reducers)\n- [Fetch API](https://github.com/klis87/redux-saga-requests/tree/master/examples/fetch-api)\n- [GraphQL](https://github.com/klis87/redux-saga-requests/tree/master/examples/graphql)\n- [redux-act integration](https://github.com/klis87/redux-saga-requests/tree/master/examples/redux-act-integration)\n- [low-level-reducers](https://github.com/klis87/redux-saga-requests/tree/master/examples/low-level-reducers)\n- [mock-and-multiple-drivers](https://github.com/klis87/redux-saga-requests/tree/master/examples/mock-and-multiple-drivers)\n- [server-side-rendering](https://github.com/klis87/redux-saga-requests/tree/master/examples/server-side-rendering)\n\n## Credits [:arrow_up:](#table-of-content)\n\nThis library was inspired by [redux-axios-middleware](https://github.com/svrcekmichal/redux-axios-middleware)\n(I highly recommend this library if someone doesn\'t use Redux-Saga!)\nand [issue](https://github.com/redux-saga/redux-saga/issues/1117) in Redux-Saga, when it was recommended not to combine\nanother async middleware with sagas.\n\n## Licence [:arrow_up:](#table-of-content)\n\nMIT\n'