b'# Getting started with QCubed\n\n[![Build Status](https://travis-ci.org/qcubed/framework.png?branch=master)](https://travis-ci.org/qcubed/framework)\n[![Test Coverage](https://codeclimate.com/github/qcubed/framework/badges/coverage.svg)](https://codeclimate.com/github/qcubed/framework/coverage)\n[![Issue Count](https://codeclimate.com/github/qcubed/framework/badges/issue_count.svg)](https://codeclimate.com/github/qcubed/framework)\n\n## Releases\n**Newest stable release: [version 3.1.0, released on July 6, 2017].\n\nThe most recent stable version of version 2 can be found in the v2 branch.\n\n## Community\n\n*Join us on Slack on [qcubed.slack.com](http://qcubed.slack.com). Get your invite [here](https://docs.google.com/forms/d/e/1FAIpQLSe0YTPSbTIFdwyVMS1VqxPK6CnfOlOVJ6Q4OfO-im2IIem5NA/viewform)*. \n\n## What is QCubed?\n\nQCubed (pronounced \'Q\' - cubed) is a PHP Model-View-Controller Rapid Application Development framework with support for PHP5 (5.4 and above) and PHP7. The goal of the framework is to save development time around mundane, repetitive tasks - allowing you to concentrate on things that are useful AND fun. QCubed excels in situations where you have a large database structure that you quickly want to make available to users.\n\n## Stateful architecture\n\nWith QCubed, you don\'t have to deal with POSTs and GETs coming from the browser. QCubed automatically handles that for you and packages the information into object oriented forms and controls. Programming with QCubed feels very much like programming a desktop application. If you are familiar with ASP, it is similar.\n\n## The Code Generator\n\nThe Code Generator automatically creates object classes with matching forms and controls based on your database schema. It uses the concept of ORM, [object-relational mapping](http://en.wikipedia.org/wiki/Object-relational_mapping), to practically create your whole model layer for you.\n\nCodegen can take advantage of foreign key relationships and field constraints to generate ready-to-use data models complete with validation routines and powerful CRUD methods, allowing you to manipulate objects instead of constantly issuing SQL queries.\n\nMore info as well as examples are available online at <http://examples.qcu.be/>\n\n### Object-oriented querying\n\nUsing QQueries allows for simple yet powerful loading of models, all generated ORM classes have Query methods and QQNodes. By using these methods, getting a complex subset of data is pretty straightforward - and can be used on almost any relational database.\n\n## User Interface Library\n\nQCubed uses the concept of a QForm to keep form state between POST transactions. A QForm serves as the controller and can contain QControls which are UI components.\n\nAll QControls (including QForm itself) can use a template which is the view layer, completing the MVC structure.\n\nQControls can take advantage of the QForm\'s FormState to update themselves through Ajax callbacks as easily as synchronous server POSTs. All jQuery UI core widgets are available as QControls.\n\nSome QControls include:\n- QDialog\n- QTextBox\n- QListBox\n- QTabs\n- QAccordion\n\nThe easiest way to learn QCubed is to see the examples tutorial at <http://qcu.be/examples/>\n\n### Plugins\n\nThrough its plugin system, QCubed makes it easy to package and deliver enhancements and additions to the core codebase. Plugins for the currently active version of QCubed live in repositories that begin with _plugin_. \n\n## System Requirements\n* A development computer that you can set up so that the browser can write to a directory in your file system.\n* v3.0.x, requires PHP 5.4 and above. PHP 7 and HHVM are supported as well.\n* All html code is html5 compliant.\n* QCubed relies on jQuery for some of its ajax interactions. Also, many of the built-in controls beyond basic html controls require JQuery UI.\n* A SQL database engine. MySQL, SqlServer, Postgres, Oracle, PDO, SqlLite, Informix adapters are included. Creating another adapter is not hard if you have a different SQL.\n\n## Installation\n\nThe installation procedure is described in detail here: [Installation instructions](https://github.com/qcubed/qcubed/blob/master/INSTALL.md "Installation instructions").\n\n## Upgrading\n### 2.x -> 3.0\n3.0 was a major architectural change from 2.x. You should essentially start over by creating a new project, \ngenerating your models, using the ModelConnectorEditor to refine what is generated in the connectors(used to be called MetaControls),\nand then copying code from your old version to the new version. You will find that many of the things you had to do\nby hand are now done in generated code, so it might not take as long as you think. Lets hop :-)\n\n### 3.0 -> 3.1\nv3.1 Now has change tracking in the models. Instead of pushing an entire object to the database\nevery time you save an object, it only pushes the data that has changed. To do this, it makes the member variables\nin the generated model superclass private instead of protected, which may require you to change code in your\nmodel subclass. To help with the transition, the new private variable feature is turned off by default. You will\nneed to turn it on by editing the codegen_settings.xml file and adding a \'privateColumnVars="true"\' parameter to the createOptions tag.\nSee the codegen_settings.xml file in the qcubed/install/project/configuration directory for an example.\n\nThis will make all of the protected column variables that are in the Gen class private, so you will not be able to access them\ndirectly from your Model subclasses. For example, if you have a "Name" column in a table, you can do:\n ```php\n $strName = $this->Name;\n ```\n or better yet:\n```php\n$strName = $this->getName();\n```\nbut not:\n```php\n$strName = $this->strName;\n```\n\n```$this->Name``` routes to ```$this->getName()```\n\nAlso, instead of this:\n```php\n$this->strName = $strName;\n```\n\ndo:\n```php\n$this->setName($strName);\n```\nor\n```php\n$this->Name = $strName;\n```\n\nThe benefits of the new feature include better performance, reduced OptimisticLocking exceptions, and preventing you from accidentally\naccessing a value that was not loaded due to a QSelect clause. Also, QSelect can\nnow be used to control what is generated when you convert an object to other\nformats like JSON.\n\n### 3.1 -> 4.0\nv4.0 is another major architectural change, designed to support the PSR-1, PSR-2 and PSR-4 standards. v4 adds \nnamespaces to all the core and library files. Gone is the letter \'Q\' in front of all the core classes, since\nthat was essentially our way of doing namespacing before namespaces were available in PHP. \n\nIt includes tools to help automate changing your code from v3.x code to v4.0. See the Readme file in the \nqcubed/application repository for more information.\n\n\n## Latest commits\n\nA list of the latest changes is available at https://github.com/qcubed/qcubed/commits/master\n\n## Credits\n\nQCubed was branched out of QCodo, a project by Michael Ho. QCubed relies on JQuery and uses jQuery UI libraries for some of its core controls.\n'