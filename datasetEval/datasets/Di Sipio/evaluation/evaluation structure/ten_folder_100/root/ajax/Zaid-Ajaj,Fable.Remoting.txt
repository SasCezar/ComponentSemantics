b'# Fable.Remoting \n\n[![Build Status](https://travis-ci.org/Zaid-Ajaj/Fable.Remoting.svg?branch=master)](https://travis-ci.org/Zaid-Ajaj/Fable.Remoting) [![Build status](https://ci.appveyor.com/api/projects/status/euhwktyycm2wvvi4?svg=true)](https://ci.appveyor.com/project/Zaid-Ajaj/fable-remoting)\n\nFable.Remoting is a [RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) communication layer for Fable and .NET apps, it abstracts away Http and Json and lets you think of your client-server interactions only in terms of pure stateless functions that are statically checked at compile-time:\n\n### Define a shared interface\nThis interface is a record type where each field is either `Async<\'T>` or a function that returns `Async<\'T>`\n\n```fs\ntype IGreetingApi = {\n  greet : string -> Async<string>\n}\n```\n\n### Implement the interface on the *server*\n\n```fs\nlet greetinApi = {\n  greet = fun name ->\n    async {\n      let greeting = sprintf "Hello, %s" name\n      return greeting\n    }\n}\n\n// Expose the implementation as a HTTP service\nlet webApp = \n  Remoting.createApi()\n  |> Remoting.fromValue greetinApi\n```\n\n### Call the functions from the *client*\n```fs\n// get a typed-proxy for the service\nlet greetingApi = \n  Remoting.createApi()\n  |> Remoting.buildProxy<IGreetingApi>\n\n// Start using the service  \nasync {\n  let! message = greetingApi.greet "World"\n  printfn "%s" message // Hello, World\n}\n```\nThat\'s it, no HTTP, no JSON and it is all type-safe.\n\n### Applications using Remoting\n- [SAFE-TodoList](https://github.com/Zaid-Ajaj/SAFE-TodoList) A simple full-stack Todo list application (beginner)\n- [tabula-rasa](https://github.com/Zaid-Ajaj/tabula-rasa) a real-world-ish blogging platform (intermediate)\n- [Yobo](https://github.com/Dzoukr/Yobo) Yoga Class Booking System\nimplemented with Event Sourcing (advanced)\n\n### [Full Documentation](https://zaid-ajaj.github.io/Fable.Remoting/)\n\nThe library runs everywhere on the backend: As Suave `WebPart`, as Giraffe/Saturn `HttpHandler` or any other framework as Asp.NET Core middleware. Clients can be Fable or .NET application.\n\n> "Fable.Remoting solves the age-old problem of keeping your front-end code in sync with your backend code at compile time, and in a language as enjoyable to use as F#" - [David Falkner](https://twitter.com/ardave2002)\n\n## Quick Start\nUse the [SAFE Template](https://github.com/SAFE-Stack/SAFE-template) where Fable.Remoting is a scaffolding option:\n\n```sh\n# install the template\ndotnet new -i SAFE.Template\n\n# scaffold a new Fable/Saturn project with Fable.Remoting\ndotnet new SAFE --communication remoting\n\n# Or use Giraffe as your server\ndotnet new SAFE --server giraffe --communication remoting\n\n# Or use Suave as your server\ndotnet new SAFE --server suave --communication remoting\n```\n## Available Packages:\n\n| Library  | Version |\n| ------------- | ------------- |\n| Fable.Remoting.Client  | [![Nuget](https://img.shields.io/nuget/v/Fable.Remoting.Client.svg?colorB=green)](https://www.nuget.org/packages/Fable.Remoting.Client) |\n| Fable.Remoting.Suave  | [![Nuget](https://img.shields.io/nuget/v/Fable.Remoting.Suave.svg?colorB=green)](https://www.nuget.org/packages/Fable.Remoting.Suave)  |\n| Fable.Remoting.Giraffe  | [![Nuget](https://img.shields.io/nuget/v/Fable.Remoting.Giraffe.svg?colorB=green)](https://www.nuget.org/packages/Fable.Remoting.Giraffe)  |\n| Fable.Remoting.AspNetCore  | [![Nuget](https://img.shields.io/nuget/v/Fable.Remoting.AspNetCore.svg?colorB=green)](https://www.nuget.org/packages/Fable.Remoting.AspNetCore)  |\n| Fable.Remoting.DotnetClient  | [![Nuget](https://img.shields.io/nuget/v/Fable.Remoting.DotnetClient.svg?colorB=green)](https://www.nuget.org/packages/Fable.Remoting.DotnetClient)  |\n\n## Scaffold from scratch - Suave\nCreate a new F# console app:\n```\ndotnet new console -lang F#\n```\nDefine the types you want to share between client and server:\n```fs\n// SharedTypes.fs\nmodule SharedTypes\n\ntype Student = {\n    Name : string\n    Age : int\n}\n\n// Shared specs between Server and Client\ntype IStudentApi = {\n    studentByName : string -> Async<Student option>\n    allStudents : unit -> Async<list<Student>>\n}\n```\nThe type `IStudentApi` is very important, this is the specification of the protocol between your server and client. `Fable.Remoting` expects such type to only have functions returning `Async` on the final result:\n```fs\nAsync<A>\nA -> Async<B>\nA -> B -> Async<C>\n// etc...\n```\nTry to put such types in seperate files to reference these files later from the Client\n\nThen provide an implementation for `IStudentApi` on the server:\n```fs\nopen SharedTypes\n\nlet getStudents() = \n  async {\n    return [\n        { Name = "Mike";  Age = 23; }\n        { Name = "John";  Age = 22; }\n        { Name = "Diana"; Age = 22; }\n    ]\n  }\n\nlet findStudentByName name = \n  async {\n    let! students = getStudents() \n    let student = List.tryFind (fun student -> student.Name = name) students\n    return student \n  }\n\nlet studentApi : IStudentApi = {\n    studentByName = findStudentByName\n    allStudents = getStudents \n}\n```\nNow that we have the implementation `studentApi`, you can expose it as a web service from different web frameworks. We start with [Suave](https://github.com/SuaveIO/suave)  \n\n\nInstall the library from Nuget using Paket:\n\n```\npaket add Fable.Remoting.Suave --project /path/to/Project.fsproj\n```\nCreate a [WebPart](https://suave.io/composing.html) from the value `studentApi`\n```fs\nopen Suave\nopen Fable.Remotion.Server\nopen Fable.Remoting.Suave\n\nlet webApp : WebPart = \n    Remoting.createApi()\n    |> Remoting.fromValue studentApi\n    |> Remoting.buildWebPart \n\n// start the web server\nstartWebServer defaultConfig webApp\n```\nYes, it is that simple.\nYou can think of the `webApp` value as if it was the following in pseudo-code:\n```fs\nlet webApp =\n choose [\n  POST\n   >=> path "/IStudentApi/studentByName"\n   >=> (* deserialize request body (from json) *)\n   >=> (* invoke studentApi.getStudentByName with the deserialized input *)\n   >=> (* give client the output back serialized (to json) *)\n\n // other routes\n ]\n```\nYou can enable diagnostic logging from Fable.Remoting.Server (recommended) to see how the library is doing it\'s magic behind the scenes :)\n```fs\nlet webApp = \n    Remoting.createApi()\n    |> Remoting.fromValue studentApi\n    |> Remoting.withDiagnosticsLogger (printfn "%s")\n    |> Remoting.buildWebPart \n```\n### AspNetCore Middleware \nInstall the package from Nuget using paket\n```\npaket add Fable.Remoting.AspNetCore --project /path/to/Project.fsproj\n```\nNow you can configure your remote handler as AspNetCore middleware \n```fs\nlet webApp = \n    Remoting.createApi()\n    |> Remoting.fromValue studentApi\n\nlet configureApp (app : IApplicationBuilder) =\n    // Add Remoting handler to the ASP.NET Core pipeline\n    app.UseRemoting webApp\n\n[<EntryPoint>]\nlet main _ =\n    WebHostBuilder()\n        .UseKestrel()\n        .Configure(Action<IApplicationBuilder> configureApp)\n        .Build()\n        .Run()\n    0\n```\n\n### Giraffe\n\nYou can follow the Suave part up to the library installation, where it will become:\n```\npaket add Fable.Remoting.Giraffe --project /path/to/Project.fsproj\n```\n\nNow instead of a WebPart, by opening the `Fable.Remoting.Giraffe` namespace, you will get a [HttpHandler](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#httphandler) from the value `server`:\n```fs\nopen Giraffe\nopen Fable.Remoting.Server\nopen Fable.Remoting.Giraffe\n\nlet webApp : HttpHandler = \n    Remoting.createApi()\n    |> Remoting.fromValue studentApi\n    |> Remoting.buildHttpHandler \n\nlet configureApp (app : IApplicationBuilder) =\n    // Add Giraffe to the ASP.NET Core pipeline\n    app.UseGiraffe webApp\n\nlet configureServices (services : IServiceCollection) =\n    // Add Giraffe dependencies\n    services.AddGiraffe() |> ignore\n\n[<EntryPoint>]\nlet main _ =\n    WebHostBuilder()\n        .UseKestrel()\n        .Configure(Action<IApplicationBuilder> configureApp)\n        .ConfigureServices(configureServices)\n        .Build()\n        .Run()\n    0\n```\n\n### Saturn\n\nYou can use the same webApp generated by the Giraffe library.\n\n```fs\nopen Saturn\nopen Fable.Remoting.Server\nopen Fable.Remoting.Giraffe\n\nlet webApp : HttpHandler = \n    Remoting.createApi()\n    |> Remoting.fromValue studentApi\n    |> Remoting.buildHttpHandler \n\nlet app = application {\n    url "http://127.0.0.1:8083/"\n    use_router webApp\n}\n\nrun app\n```\n\n## Fable Client\nInstall `Fable.Remoting.Client` from nuget using Paket:\n```\npaket add Fable.Remoting.Client --project /path/to/Project.fsproj\n```\nReference the shared types to your client project\n```\n<Compile Include="path/to/SharedTypes.fs" />\n```\nStart using the library:\n```fs\nopen Fable.Remoting.Client\nopen SharedTypes\n\n// studentApi : IStudentApi\nlet studentApi =\n    Remoting.createApi()\n    |> Remoting.buildProxy<IStudentApi>\n\nasync {\n  // students : Student[]\n  let! students = studentApi.allStudents()\n  for student in students do\n    // student : Student\n    printfn "Student %s is %d years old" student.Name student.Age\n}\n|> Async.StartImmediate\n```\nFinally, when you are using `webpack-dev-server`, you have to change the config from this:\n```js\ndevServer: {\n  contentBase: resolve(\'./public\'),\n  port: 8080\n}\n```\nto this:\n```js\ndevServer: {\n  contentBase: resolve(\'./public\'),\n  port: 8080,\n  proxy: {\n    \'/*\': { // tell webpack-dev-server to re-route all requests from client to the server\n      target: "http://localhost:8083",// assuming the suave server is hosted op port 8083\n      changeOrigin: true\n    }\n}\n```\nThat\'s it!\n\n\n## Adding a new route\n - Add another record field function to `IStudentApi`\n - Implement that function\n - Restart server\n\nDone! You can now use that function from the client too.\n\n\nSee the following article if you are interested in how this library is implemented (a bit outdated but gives you an overview of the mechanism)\n[Statically Typed Client-Server Communication with F#: Proof of Concept](https://medium.com/@zaid.naom/statically-typed-client-server-communication-with-f-proof-of-concept-7e52cff4a625#.2ltqlajm4)\n\n### [In-depth Introduction (Blog)](https://medium.com/@zaid.naom/introducing-fable-remoting-automated-type-safe-client-server-communication-for-fable-apps-e567454d594c)\n'