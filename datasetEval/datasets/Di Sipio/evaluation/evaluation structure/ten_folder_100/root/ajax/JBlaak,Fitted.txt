b"Fitted\n====\n\n[![Build Status](https://travis-ci.org/JBlaak/Fitted.svg?branch=master)](https://travis-ci.org/JBlaak/Fitted)\n\nUse ECMAScript decorators ([currently a Stage 2 proposal](https://github.com/tc39/proposals)) to\nexecute HTTP requests and manage processing of responses, an easy and readable way of managing\nhow data flows through the networking layer of your application.\n\nExample\n----\n\nTwo main parts, the method decorators which will actually do the request, and the class decorators\nwhich will allow you to handle the way responses from the server are transformed and handled.\n\nThe simplest example is just a fetch of data from a JSON endpoint:\n\n```javascript\nimport {get} from 'fitted';\n\nclass HackerNews {\n    @get('https://hacker-news.firebaseio.com/v0/topstories.json')\n    topstories (request, response) {\n      return request({}, response);\n    }\n}\n```\n\nAnd fetch:\n\n```javascript\nconst hackerNews = new HackerNews();\nconst topstories = await hackerNews.topstories();\nconsole.log(topstories);\n```\n\nUsage\n-----\n\n__Basic request__\n\nUsing the `get` decorator you can trigger a `GET` request:\n\n```javascript\nimport {get} from 'fitted';\n\nclass HackerNews {\n    @get('https://hacker-news.firebaseio.com/v0/topstories.json')\n    topstories (request, response) {\n      return request({}, response);\n    }\n}\n```\n\n**Merging params**\n\nTo merge params with the url we use [url-template](https://github.com/bramstein/url-template),\nwhich uses curly brackets to encapsulate a to be merged variable.\n\n```javascript\nimport {get} from 'fitted';\n\nclass HackerNews {\n      @get('https://hacker-news.firebaseio.com/v0/item/{id}.json')\n      item (id, request, response) {\n          return request({\n                template: {\n                    id: 123\n                 }\n          }, response);\n      }\n}\n```\n\n**Base url**\n\nMost of the time your endpoints will share the same base url, so Fitted\nallows you to set a base url which will be prefixed to all paths \nset in your method decorators.\n\n```javascript\nimport {base, get} from 'fitted';\n\n@base('https://hacker-news.firebaseio.com/v0/')\nclass HackerNews {\n      @get('item/{id}.json')\n      item (id, request, response) {\n          return request({\n                template: {\n                    id: 123\n                 }\n          }, response);\n      }\n}\n```\n\n__Sending data__\n\nTo add data to your request for `post`, `put` and `destroy` requests and\nspecifying a query string for your `get` request you add a `data` object\nto your request definition.\n\n```javascript\nimport {put} from 'fitted';\n\nclass HackerNews {\n      @put('https://hacker-news.firebaseio.com/v0/item/{id}.json')\n      item (id, name, request, response) {\n          return request({\n                template: {\n                    id: 123\n                },\n                data: {\n                   name: name\n                }\n          }, response);\n      }\n}\n```\n\n__Request decorating__\n\nOften all endpoints will have the same request requirements, requiring,\nfor example, all to have some header set. For this the `@request` \ndecorator can be used. It will get the config of each request\npassed before handing it over to the driver.\n\n```javascript\nimport {get, request} from 'fitted';\n\nconst myRequestHandler = config => {\n    config.headers = {\n        'accept': 'application/json' \n    }\n    \n    return config;\n}\n\n@request(myRequestHandler)\nclass HackerNews {\n    @get('item/{id}.json')\n    item (id, request, response) {\n      return request({\n            template: {\n                id: id\n            }\n        }, response);\n    }\n}\n```\n\n__Response handling__\n\nWhen the server responds with a `Content-Type` header containing `application/json` \nFitted will automatically feed it to the `JSON.parse` function so that\nthe resulting Promise will output the corresponding object.\n\nAny other `Content-Type` will result in an Error being thrown and require\nyou to implement your own handler.\n\n**Custom response processor**\n\nWhen your endpoint returns something that requires some pre-processing you\ncan define a processor for all endpoints in your api definition. This\nconsists of a function that receives the response from the server and\npasses the parsed data to the response object.\n\n```javascript\nimport {get, processor} from 'fitted';\n\nconst myProcessor = response => {\n    const data = JSON.parse(response.getBody());\n    response.setBody(data);\n    \n    return data;\n}\n\n@processor(myProcessor)\nclass HackerNews {\n    @get('item/{id}.json')\n    item (id, request, response) {\n      return request({\n            template: {\n                id: id\n            }\n        }, response);\n    }\n}\n```\n"