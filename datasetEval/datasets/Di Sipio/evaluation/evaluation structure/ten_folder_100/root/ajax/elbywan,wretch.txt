b'<h1 align="center">\n\t<a href="https://elbywan.github.io/wretch"><img src="https://cdn.rawgit.com/elbywan/wretch/08831345/wretch.svg" alt="wretch-logo" width="220px"></a><br>\n\t<br>\n    <a href="https://elbywan.github.io/wretch">Wretch</a><br>\n\t<br>\n\n  <a href="https://travis-ci.org/elbywan/wretch"><img alt="travis-badge" src="https://travis-ci.org/elbywan/wretch.svg?branch=master"></a>\n  <a href="https://www.npmjs.com/package/wretch"><img alt="npm-badge" src="https://img.shields.io/npm/v/wretch.svg?colorB=ff733e" height="20"></a>\n  <a href="https://www.npmjs.com/package/wretch"><img alt="npm-downloads-badge" src="https://img.shields.io/npm/dm/wretch.svg?colorB=53aabb" height="20"></a>\n  <a href="https://coveralls.io/github/elbywan/wretch?branch=master"><img src="https://coveralls.io/repos/github/elbywan/wretch/badge.svg?branch=master" alt="Coverage Status"></a>\n  <a href="https://www.browserstack.com/automate/public-build/eVNpU3lNZUFuR1BTampDcXR4UnhQM0Zvb0ZTcTBBdDI0ZFdqazFHcENlWT0tLUdqM05PR0Y4OWZyR05IOUN1MWFFZ2c9PQ==--6af898b830d4bcdc3ba0ad3d4be45acdb273d96c"><img src=\'https://www.browserstack.com/automate/badge.svg?badge_key=eVNpU3lNZUFuR1BTampDcXR4UnhQM0Zvb0ZTcTBBdDI0ZFdqazFHcENlWT0tLUdqM05PR0Y4OWZyR05IOUN1MWFFZ2c9PQ==--6af898b830d4bcdc3ba0ad3d4be45acdb273d96c\'/></a>\n  <a href="https://bundlephobia.com/result?p=wretch"><img src=\'https://img.shields.io/bundlephobia/minzip/wretch.svg\'/></a>\n  <a href="https://github.com/elbywan/wretch/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="license-badge" height="20"></a>\n  <a href="https://www.paypal.me/elbywan"><img src="https://img.shields.io/badge/buy%20me%20a-coffee-yellow.svg" alt="coffee-badge" height="20"></a>\n</h1>\n<h4 align="center">\n\tA tiny (&lt; 2.7Kb g-zipped) wrapper built around fetch with an intuitive syntax.\n</h4>\n<h5 align="center">\n    <i>f[ETCH] [WR]apper</i>\n</h6>\n\n<br>\n\n##### Wretch 1.5 is now live \xf0\x9f\x8e\x89 ! Please check out the [changelog](https://github.com/elbywan/wretch/blob/master/CHANGELOG.md) after each update for new features and breaking changes. If you want to try out the hot stuff, please look into the [dev](https://github.com/elbywan/wretch/tree/dev) branch.\n\n##### A collection of middlewares is available through the [wretch-middlewares](https://github.com/elbywan/wretch-middlewares) package! \xf0\x9f\x93\xa6\n\n# Table of Contents\n\n* [Motivation](#motivation)\n* [Installation](#installation)\n* [Compatibility](#compatibility)\n* [Usage](#usage)\n* [Api](#api)\n* [License](#license)\n\n# Motivation\n\n#### Because having to write a second callback to process a response body feels awkward.\n\n```javascript\n// Fetch needs a second callback to process the response body\n\nfetch("examples/example.json")\n  .then(response => response.json())\n  .then(json => {\n    //Do stuff with the parsed json\n  })\n```\n\n```javascript\n// Wretch does it for you\n\n// Use .res for the raw response, .text for raw text, .json for json, .blob for a blob ...\nwretch("examples/example.json")\n  .get()\n  .json(json => {\n    // Do stuff with the parsed json\n  })\n```\n\n#### Because manually checking and throwing every request error code is tedious.\n\n```javascript\n// Fetch won\xe2\x80\x99t reject on HTTP error status\n\nfetch("anything")\n  .then(response => {\n    if(!response.ok) {\n      if(response.status === 404) throw new Error("Not found")\n      else if(response.status === 401) throw new Error("Unauthorized")\n      else if(response.status === 418) throw new Error("I\'m a teapot !")\n      else throw new Error("Other error")\n    }\n    else // ...\n  })\n  .then(data => /* ... */)\n  .catch(error => { /* ... */ })\n```\n\n```javascript\n// Wretch throws when the response is not successful and contains helper methods to handle common codes\n\nwretch("anything")\n  .get()\n  .notFound(error => { /* ... */ })\n  .unauthorized(error => { /* ... */ })\n  .error(418, error => {\xc2\xa0/* ... */ })\n  .res(response => /* ... */)\n  .catch(error => { /* uncaught errors */ })\n```\n\n#### Because sending a json object should be easy.\n\n```javascript\n// With fetch you have to set the header, the method and the body manually\n\nfetch("endpoint", {\n  method: "POST",\n  headers: { "Content-Type": "application/json" },\n  body: JSON.stringify({ "hello": "world" })\n}).then(response => /* ... */)\n// Omitting the data retrieval and error management parts\n```\n\n```javascript\n// With wretch, you have shorthands at your disposal\n\nwretch("endpoint")\n  .post({ "hello": "world" })\n  .res(response => /* ... */)\n```\n\n#### Because configuration should not rhyme with repetition.\n\n```javascript\n// Wretch object is immutable which means that you can configure, store and reuse instances\n\n// Cross origin authenticated requests on an external API\nconst externalApi = wretch()\n  // Set the base url\n  .url("http://external.api")\n  // Authorization header\n  .auth(`Bearer ${ token }`)\n  // Cors fetch options\n  .options({ credentials: "include", mode: "cors" })\n  // Handle 403 errors\n  .resolve(_ => _.forbidden(handle403))\n\n// Fetch a resource\nexternalApi\n  .url("/resource/1")\n  // Add a custom header for this request\n  .headers({ "If-Unmodified-Since": "Wed, 21 Oct 2015 07:28:00 GMT" })\n  .get()\n  .json(handleResource)\n// Post a resource\nexternalApi\n  .url("/resource")\n  .post({ "Shiny new": "resource object" })\n  .json(handleNewResourceResult)\n```\n\n# Installation\n\n## Npm\n\n```sh\nnpm i wretch\n```\n\n## Clone\n\n```sh\ngit clone https://github.com/elbywan/wretch\ncd wretch\nnpm install\nnpm start\n```\n\n# Compatibility\n\n## Browsers\n\nWretch is compatible with modern browsers out of the box.\n\nFor older environments without fetch support, you should get a [polyfill](https://github.com/github/fetch).\n\n## Node.js\n\nWorks with any [FormData](https://github.com/form-data/form-data) or [fetch](https://www.npmjs.com/package/node-fetch) polyfills.\n\n```javascript\n// The global way :\n\nglobal.fetch = require("node-fetch")\nglobal.FormData = require("form-data")\nglobal.URLSearchParams = require("url").URLSearchParams\n\n// Or the non-global way :\n\nwretch().polyfills({\n    fetch: require("node-fetch"),\n    FormData: require("form-data"),\n    URLSearchParams: require("url").URLSearchParams\n})\n```\n\n------\n\n*This project uses automated node.js & browser unit tests. The latter are a provided courtesy of:*\n\n<a href="https://www.browserstack.com/"><img src="assets/browserstack-logo.png" alt="browserstack-logo" height="50"></a>\n\n\n\n# Usage\n\n**Wretch is bundled using the UMD format (@`dist/bundle/wretch.js`) alongside es2015 modules (@`dist/index.js`) and typescript definitions.**\n\n## Import\n\n```html\n<!--- "wretch" will be attached to the global window object. -->\n<script src="https://unpkg.com/wretch"></script>\n```\n\n```typescript\n// es2015 modules\nimport wretch from "wretch"\n\n// commonjs\nvar wretch = require("wretch")\n```\n\n## Code\n\n**Wretcher objects are immutable.**\n\n```javascript\nwretch(url, options)\n\n  /* The "request" chain. */\n\n .[helper method(s)]()\n     // [ Optional ]\n     // A set of helper methods to set the default options, set accept header, change the current url ...\n .[body type]()\n     // [ Optional ]\n     // Serialize an object to json or FormData formats and sets the body & header field if needed\n .[http method]()\n     // [ Required, ends the request chain ]\n     // Performs the get/put/post/delete/patch request\n\n  /* Fetch is called at this time. */\n  /* The request is sent, and from this point on you can chain catchers and call a response type handler. */\n\n  /* The "response" chain. */\n\n .[catcher(s)]()\n    // [ Optional ]\n    // You can chain error handlers here\n .[response type]()\n    // [ Required, ends the response chain ]\n    // Specify the data type you need, which will be parsed and handed to you\n\n  /* From this point wretch returns a standard Promise, so you can continue chaining actions afterwards. */\n\n  .then(/* ... */)\n  .catch(/* ... */)\n```\n\n# API\n\n* [Helper Methods](#helper-methods)\n* [Body Types](#body-types)\n* [Http Methods](#http-methods)\n* [Catchers](#catchers)\n* [Response Types](#response-types)\n* [Extras](#extras)\n\n------\n\n#### wretch(url = "", opts = {})\n\nCreates a new Wretcher object with an url and [vanilla fetch options](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch).\n\n## Helper Methods\n\n*Helper methods are optional and can be chained.*\n\n| [url](#urlurl-string-replace-boolean--false) | [query](#queryqp-object--string-replace-boolean) | [options](#optionsoptions-object-mixin-boolean--true) | [headers](#headersheadervalues-object) | [accept](#acceptheadervalue-string) | [content](#contentheadervalue-string) | [auth](#authheadervalue-string) | [catcher](#catchererrorid-number--string-catcher-error-wretchererror-originalrequest-wretcher--void) | [resolve](#resolvedoresolve-chain-responsechain-originalrequest-wretcher--responsechain--promise-clear--false) | [defer](#defercallback-originalrequest-wretcher-url-string-options-object--wretcher-clear--false) | [defaults](#defaultsopts-object-mixin-boolean--false) | [errorType](#errortypemethod-text--json--text) | [polyfills](#polyfillspolyfills-object) |\n|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n\n#### url(url: string, replace: boolean = false)\n\nAppends or replaces the url.\n\n```js\nwretch().url("...").get().json(/* ... */)\n\n// Can be used to set a base url\n\n// Subsequent requests made using the \'blogs\' object will be prefixed with "http://mywebsite.org/api/blogs"\nconst blogs = wretch("http://mywebsite.org/api/blogs")\n\n// Perfect for CRUD apis\nconst id = await blogs.post({ name: "my blog" }).json(_ => _.id)\nconst blog = await blogs.url(`/${id}`).get().json()\nconsole.log(blog.name)\n\nawait blogs.url(`/${id}`).delete().res()\n\n// And to replace the base url if needed :\nconst noMoreBlogs = blogs.url("http://mywebsite.org/", true)\n```\n\n#### query(qp: object | string, replace: boolean)\n\nConverts a javascript object to query parameters, then appends this query string to the current url.\nString values are used as the query string verbatim.\n\nPass `true` as the second argument to replace existing query parameters.\n\n```js\nlet w = wretch("http://example.com")\n// url is http://example.com\nw = w.query({ a: 1, b: 2 })\n// url is now http://example.com?a=1&b=2\nw = w.query({ c: 3, d: [4, 5] })\n// url is now http://example.com?a=1&b=2c=3&d=4&d=5\nw = w.query("five&six&seven=eight")\n// url is now http://example.com?a=1&b=2c=3&d=4&d=5&five&six&seven=eight\nw = w.query({ reset: true }, true)\n// url is now  http://example.com?reset=true\n```\n\n##### **Note that .query is not meant to handle complex cases with nested objects.**\n\nFor this kind of usage, you can use `wretch` in conjunction with other libraries (like [`qs`](https://github.com/ljharb/qs)).\n\n```js\n/* Using wretch with qs */\n\nconst queryObject = { some: { nested: \'objects\' }}\n\n// Use .qs inside .query :\n\n wretch("https://example.com/").query(qs.stringify(queryObject))\n\n// Use .defer :\n\nconst qsWretch = wretch().defer((w, url, { qsQuery, qsOptions }) => (\n    qsQuery ? w.query(qs.stringify(qsQuery, qsOptions)) : w\n))\n\nqsWretch\n  .url("https://example.com/")\n  .options({ qs: {\xc2\xa0query: queryObject }})\n  /* ... */\n```\n\n#### options(options: Object, mixin: boolean = true)\n\nSets the fetch options.\n\n```js\nwretch("...").options({ credentials: "same-origin" })\n```\n\nWretch being immutable, you can store the object for later use.\n\n```js\nconst corsWretch = wretch().options({ credentials: "include", mode: "cors" })\n\ncorsWretch.url("http://endpoint1").get()\ncorsWretch.url("http://endpoint2").get()\n```\n\nYou can override instead of mixing in the existing options by passing a boolean flag.\n\n```js\n// By default options mixed in :\n\nwretch()\n  .options({ headers: { "Accept": "application/json" }})\n  .options({ encoding: "same-origin", headers: { "X-Custom": "Header" }})\n\n/*\n{\n  headers: { "Accept": "application/json", "X-Custom": "Header" },\n  encoding: "same-origin"\n}\n*/\n\n// With the flag, options are overridden :\n\nwretch()\n  .options({ headers: { "Accept": "application/json" }})\n  .options({ encoding: "same-origin", headers: { "X-Custom": "Header" }}, false)\n\n/*\n{\n  headers: { "X-Custom": "Header" },\n  encoding: "same-origin"\n}\n*/\n```\n\n#### headers(headerValues: Object)\n\nSets the request headers.\n\n```js\nwretch("...")\n  .headers({ "Content-Type": "text/plain", Accept: "application/json" })\n  .post("my text")\n  .json()\n```\n\n#### accept(headerValue: string)\n\nShortcut to set the "Accept" header.\n\n```js\nwretch("...").accept("application/json")\n```\n\n#### content(headerValue: string)\n\nShortcut to set the "Content-Type" header.\n\n```js\nwretch("...").content("application/json")\n```\n\n#### auth(headerValue: string)\n\nShortcut to set the "Authorization" header.\n\n```js\nwretch("...").auth("Basic d3JldGNoOnJvY2tz")\n```\n\n#### catcher(errorId: number | string, catcher: (error: WretcherError, originalRequest: Wretcher) => void)\n\nAdds a [catcher](https://github.com/elbywan/wretch#catchers) which will be called on every subsequent request error.\n\nVery useful when you need to perform a repetitive action on a specific error code.\n\n```js\nconst w = wretch()\n  .catcher(404, err => redirect("/routes/notfound", err.message))\n  .catcher(500, err => flashMessage("internal.server.error"))\n\n// No need to catch the 404 or 500 codes, they are already taken care of.\nw.url("http://myapi.com/get/something").get().json(json => /* ... */)\n\n// Default catchers can be overridden if needed.\nw\n  .url("http://myapi.com/get/something")\n  .get()\n  .notFound(err => /* overrides the default \'redirect\' catcher */)\n  .json(json => /* ... */)\n```\n\nThe original request is passed along the error and can be used in order to perform an additional request.\n\n```js\nconst reAuthOn401 = wretch()\n  .catcher(401, async (error, request) => {\n    // Renew credentials\n    const token = await wretch("/renewtoken").get().text()\n    storeToken(token)\n    // Replay the original request with new credentials\n    return request.auth(token).replay().unauthorized(err => {\xc2\xa0throw err }).json()\n  })\n\nreAuthOn401.url("/resource")\n  .get()\n  .json() // <- Will only be called for the original promise\n  .then(callback) // <- Will be called for the original OR the replayed promise result\n```\n\n#### defer(callback: (originalRequest: Wretcher, url: string, options: Object) => Wretcher, clear = false)\n\nDefer wretcher methods that will be chained and called just before the request is performed.\n\n```js\n/* Small fictional example: deferred authentication */\n\n// If you cannot retrieve the auth token while configuring the wretch object you can use .defer to postpone the call\nconst api = wretch("...").defer((w, url, options)  => {\n  // If we are hitting the route /user\xe2\x80\xa6\n  if(/\\/user/.test(url)) {\n    const { token } = options.context\n    return w.auth(token)\n  }\n  return w\n})\n\n// ... //\n\nconst token = await getToken(request.session.user)\n\n// .auth gets called here automatically\napi.options({\n  context: { token }\n}).get().res()\n```\n\n#### resolve(doResolve: (chain: ResponseChain, originalRequest: Wretcher) => ResponseChain | Promise<any>, clear = false)\n\nPrograms a resolver which will automatically be injected to perform response chain tasks.\n\nVery useful when you need to perform repetitive actions on the wretch response.\n\n*The clear argument, if set to true, removes previously defined resolvers.*\n\n```js\n// Program "response" chain actions early on\nconst w = wretch()\n  .resolve(resolver => resolver\n    .perfs(_ =>  /* monitor every request */)\n    .json(_ => _ /* automatically parse and return json */))\n\nconst myJson = await w.url("http://a.com").get()\n// Equivalent to wretch()\n//  .url("http://a.com")\n//  .get()\n//     <- the resolver chain is automatically injected here !\n//  .perfs(_ =>  /* ... */)\n//  .json(_ => _)\n```\n\n#### defaults(opts: Object, mixin: boolean = false)\n\nSets default fetch options which will be used for every subsequent requests.\n\n```js\n// Interestingly enough, default options are mixed in :\n\nwretch().defaults({ headers: { "Accept": "application/json" }})\n\n// The fetch request is sent with both headers.\nwretch("...", { headers: {\xc2\xa0"X-Custom": "Header" }}).get()\n```\n\n```js\n// You can mix in with the existing options instead of overriding them by passing a boolean flag :\n\nwretch().defaults({ headers: { "Accept": "application/json" }})\nwretch().defaults({ encoding: "same-origin", headers: { "X-Custom": "Header" }}, true)\n\n/* The new options are :\n{\n  headers: { "Accept": "application/json", "X-Custom": "Header" },\n  encoding: "same-origin"\n}\n*/\n```\n\n#### errorType(method: "text" | "json" = "text")\n\nSets the method (text, json ...) used to parse the data contained in the response body in case of an HTTP error.\n\nPersists for every subsequent requests.\n\n```js\nwretch().errorType("json")\n\nwretch("http://server/which/returns/an/error/with/a/json/body")\n  .get()\n  .res()\n  .catch(error => {\n    // error[errorType] (here, json) contains the parsed body\n    console.log(error.json))\n  }\n```\n\n#### polyfills(polyfills: Object)\n\nSets the non-global polyfills which will be used for every subsequent calls.\n\n```javascript\nconst fetch = require("node-fetch")\nconst FormData = require("form-data")\n\nwretch().polyfills({\n    fetch: fetch,\n    FormData: FormData,\n    URLSearchParams: require("url").URLSearchParams\n})\n```\n\n## Body Types\n\n*A body type is only needed when performing put/patch/post requests with a body.*\n\n| [body](#bodycontents-any) | [json](#jsonjsobject-object) | [formData](#formdataformobject-object) | [formUrl](#formurlinput--object--string) |\n|-----|-----|-----|-----|\n\n#### body(contents: any)\n\nSets the request body with any content.\n\n```js\nwretch("...").body("hello").put()\n// Note that calling an \'http verb\' method with the body as an argument is equivalent:\nwretch("...").put("hello")\n```\n\n#### json(jsObject: Object)\n\nSets the content type header, stringifies an object and sets the request body.\n\n```js\nconst jsonObject = { a: 1, b: 2, c: 3 }\nwretch("...").json(jsonObject).post()\n// Note that calling an \'http verb\' method with the object body as an argument is equivalent:\nwretch("...").post(jsonObject)\n\n```\n\n#### formData(formObject: Object)\n\nConverts the javascript object to a FormData and sets the request body.\n\n```js\nconst form = {\n  hello: "world",\n  duck: "Muscovy"\n}\nwretch("...").formData(form).post()\n```\n\n#### formUrl(input: Object | string)\n\nConverts the input parameter to an url encoded string and sets the content-type header and body.\nIf the input argument is already a string, skips the conversion part.\n\n```js\nconst form = { a: 1, b: { c: 2 }}\nconst alreadyEncodedForm = "a=1&b=%7B%22c%22%3A2%7D"\n\n// Automatically sets the content-type header to "application/x-www-form-urlencoded"\nwretch("...").formUrl(form).post()\nwretch("...").formUrl(alreadyEncodedForm).post()\n```\n\n## Http Methods\n\n**Required**\n\n*You can pass optional fetch options and body arguments to these methods as a shorthand.*\n\n```js\n// This shorthand:\nwretch().post({ json: \'body\' }, { credentials: "same-origin" })\n// Is equivalent to:\nwretch().json({\xc2\xa0json: \'body\'}).options({ credentials: "same-origin" }).post()\n```\n\n| [get](#getoptions) | [delete](#deleteoptions) | [put](#putbody-options) | [patch](#patchbody-options) | [post](#postbody-options) | [head](#headoptions) | [opts](#optsoptions) |\n|-----|-----|-----|-----|-----|-----|-----|\n\n#### get(options)\n\nPerforms a get request.\n\n```js\nwretch("...").get()\n```\n\n#### delete(options)\n\nPerforms a delete request.\n\n```js\nwretch("...").delete()\n```\n\n#### put(body, options)\n\nPerforms a put request.\n\n```js\nwretch("...").json({...}).put()\n```\n\n#### patch(body, options)\n\nPerforms a patch request.\n\n```js\nwretch("...").json({...}).patch()\n```\n\n#### post(body, options)\n\nPerforms a post request.\n\n```js\nwretch("...").json({...}).post()\n```\n\n#### head(options)\n\nPerforms a head request.\n\n```js\nwretch("...").head()\n```\n#### opts(options)\n\nPerforms an options request.\n\n```js\nwretch("...").opts()\n```\n\n## Catchers\n\n*Catchers are optional, but if you do not provide them an error will still be thrown in case of an http error code received.*\n\n*Catchers can be chained.*\n\n| [badRequest](#badrequestcb-error-wretchererror-originalrequest-wretcher--any) | [unauthorized](#unauthorizedcb-error-wretchererror-originalrequest-wretcher--any) | [forbidden](#forbiddencb-error-wretchererror-originalrequest-wretcher--any) | [notFound](#notfoundcb-error-wretchererror-originalrequest-wretcher--any) | [timeout](#timeoutcb-error-wretchererror-originalrequest-wretcher--any) | [internalError](#internalerrorcb-error-wretchererror-originalrequest-wretcher--any) | [error](#errorerrorid-number--string-cb-error-wretchererror-originalrequest-wretcher--any) |\n|-----|-----|-----|-----|-----|-----|-----|\n\n```ts\ntype WretcherError = Error & { status: number, response: WretcherResponse, text?: string, json?: Object }\n```\n\n```js\nwretch("...")\n  .get()\n  .badRequest(err => console.log(err.status))\n  .unauthorized(err => console.log(err.status))\n  .forbidden(err => console.log(err.status))\n  .notFound(err => console.log(err.status))\n  .timeout(err => console.log(err.status))\n  .internalError(err => console.log(err.status))\n  .error(418, err => console.log(err.status))\n  .res()\n```\n\n#### badRequest(cb: (error: WretcherError, originalRequest: Wretcher) => any)\n\nSyntactic sugar for `error(400, cb)`.\n\n#### unauthorized(cb: (error: WretcherError, originalRequest: Wretcher) => any)\n\nSyntactic sugar for `error(401, cb)`.\n\n#### forbidden(cb: (error: WretcherError, originalRequest: Wretcher) => any)\n\nSyntactic sugar for `error(403, cb)`.\n\n#### notFound(cb: (error: WretcherError, originalRequest: Wretcher) => any)\n\nSyntactic sugar for `error(404, cb)`.\n\n#### timeout(cb: (error: WretcherError, originalRequest: Wretcher) => any)\n\nSyntactic sugar for `error(408, cb)`.\n\n#### internalError(cb: (error: WretcherError, originalRequest: Wretcher) => any)\n\nSyntactic sugar for `error(500, cb)`.\n\n#### error(errorId: number | string, cb: (error: WretcherError, originalRequest: Wretcher) => any)\n\nCatches a specific error given its code or name and perform the callback.\n\n---------\n\nThe original request is passed along the error and can be used in order to perform an additional request.\n\n```js\nwretch("/resource")\n  .get()\n  .unauthorized(async (error, req) => {\n    // Renew credentials\n    const token = await wretch("/renewtoken").get().text()\n    storeToken(token)\n    // Replay the original request with new credentials\n    return req.auth(token).get().unauthorized(err => {\xc2\xa0throw err }).json()\n  })\n  .json()\n  // The promise chain is preserved as expected\n  // ".then" will be performed on the result of the original request\n  // or the replayed one (if a 401 error was thrown)\n  .then(callback)\n```\n\n## Response Types\n\n**Required**\n\nAll these methods accept an optional callback, and will return a Promise resolved with either the return value of the provided callback or the expected type.\n\n```js\n// Without a callback\nwretch("...").get().json().then(json => /* json is the parsed json of the response body */)\n// Without a callback using await\nconst json = await wretch("...").get().json()\n//With a callback the value returned is passsed to the Promise\nwretch("...").get().json(() => "Hello world!").then(console.log) // Hello world!\n```\n\n*If an error is caught by catchers, the response type handler will not be called.*\n\n| [res](#rescb-response--response--any) | [json](#jsoncb-json--object--any) | [blob](#blobcb-blob--blob--any) | [formData](#formdatacb-fd--formdata--any) | [arrayBuffer](#arraybuffercb-ab--arraybuffer--any) | [text](#textcb-text--string--any) |\n|-----|-----|-----|-----|-----|-----|\n\n#### res(cb?: (response : Response) => T) : Promise<Response | T>\n\nRaw Response handler.\n\n```js\nwretch("...").get().res(response => console.log(response.url))\n```\n\n#### json(cb?: (json : Object) => T) : Promise<Object | T>\n\nJson handler.\n\n```js\nwretch("...").get().json(json => console.log(Object.keys(json)))\n```\n\n#### blob(cb?: (blob : Blob) => T) : Promise<Blob | T>\n\nBlob handler.\n\n```js\nwretch("...").get().blob(blob => /* ... */)\n```\n\n#### formData(cb: (fd : FormData) => T) : Promise<FormData | T>\n\nFormData handler.\n\n```js\nwretch("...").get().formData(formData => /* ... */)\n```\n\n#### arrayBuffer(cb: (ab : ArrayBuffer) => T) : Promise<ArrayBuffer |\xc2\xa0T>\n\nArrayBuffer handler.\n\n```js\nwretch("...").get().arrayBuffer(arrayBuffer => /* ... */)\n```\n\n#### text(cb: (text : string) => T)  : Promise<string |\xc2\xa0T>\n\nText handler.\n\n```js\nwretch("...").get().text(txt => console.log(txt))\n```\n\n## Extras\n\n*A set of extra features.*\n\n| [Abortable requests](#abortable-requests) | [Performance API](#performance-api) | [Middlewares](#middlewares) |\n|-----|-----|-----|\n\n### Abortable requests\n\n*Only compatible with browsers that support [AbortControllers](https://developer.mozilla.org/en-US/docs/Web/API/AbortController). Otherwise, you could use a (partial) [polyfill](https://www.npmjs.com/package/abortcontroller-polyfill).*\n\nUse case :\n\n```js\nconst [c, w] = wretch("...")\n  .get()\n  .onAbort(_ => console.log("Aborted !"))\n  .controller()\n\nw.text(_ => console.log("should never be called"))\nc.abort()\n\n// Or :\n\nconst controller = new AbortController()\n\nwretch("...")\n  .signal(controller)\n  .get()\n  .onAbort(_ => console.log("Aborted !"))\n  .text(_ => console.log("should never be called"))\n\nc.abort()\n```\n\n### signal(controller: AbortController)\n\n*Used at "request time", like an helper.*\n\nAssociates a custom controller with the request.\nUseful when you need to use your own AbortController, otherwise wretch will create a new controller itself.\n\n```js\nconst controller = new AbortController()\n\n// Associates the same controller with multiple requests\n\nwretch("url1")\n  .signal(controller)\n  .get()\n  .json(_ => /* ... */)\nwretch("url2")\n  .signal(controller)\n  .get()\n  .json(_ => /* ... */)\n\n// Aborts both requests\n\ncontroller.abort()\n```\n\n#### setTimeout(time: number, controller?: AbortController)\n\n*Used at "response time".*\n\nAborts the request after a fixed time. If you use a custom AbortController associated with the request, pass it as the second argument.\n\n```js\n// 1 second timeout\nwretch("...").get().setTimeout(1000).json(_ => /* will not be called in case of a timeout */)\n```\n\n#### controller()\n\n*Used at "response time".*\n\nReturns the automatically generated AbortController alongside the current wretch response as a pair.\n\n```js\n// We need the controller outside the chain\nconst [c, w] = wretch("url")\n  .get()\n  .controller()\n\n// Resume with the chain\nw.onAbort(_ => console.log("ouch")).json(_ => /* ... */)\n\n/* Later on ... */\nc.abort()\n```\n\n#### onAbort(cb: (error: AbortError) => any)\n\n*Used at "response time" like a catcher.*\n\nCatches an AbortError and performs the callback.\n\n### Performance API\n\n#### perfs(cb: (timings: PerformanceTiming) => void)\n\nTakes advantage of the Performance API ([browsers](https://developer.mozilla.org/en-US/docs/Web/API/Performance_API) & [node.js](https://nodejs.org/api/perf_hooks.html)) to expose timings related to the underlying request.\n\nBrowser timings are very accurate, node.js only contains raw measures.\n\n```js\n// Use perfs() before the response types (text, json, ...)\nwretch("...")\n  .get()\n  .perfs(timings => {\n    /* Will be called when the timings are ready. */\n    console.log(timings.startTime)\n  })\n  .res()\n  /* ... */\n```\n\nFor node.js, there is a little extra work to do :\n\n```js\n// Node.js 8.5+ only\nconst { performance, PerformanceObserver } = require("perf_hooks")\n\nwretch().polyfills({\n  fetch: function(url, opts) {\n    performance.mark(url + " - begin")\n    return fetch(url, opts).then(_ => {\n      performance.mark(url + " - end")\n      performance.measure(_.url, url + " - begin", url + " - end")\n    })\n  },\n  /* other polyfills ... */\n  performance: performance,\n  PerformanceObserver: PerformanceObserver\n})\n```\n\n### Middlewares\n\nMiddlewares are functions that can intercept requests before being processed by Fetch.\nWretch includes a helper to help replicate the [middleware](http://expressjs.com/en/guide/using-middleware.html) style.\n\n\n#### Middlewares package\n\nCheck out [wretch-middlewares](https://github.com/elbywan/wretch-middlewares), the official collection of middlewares.\n\n#### Signature\n\nBasically a Middleware is a function having the following signature :\n\n```ts\n// A middleware accepts options and returns a configured version\ntype Middleware = (options?: {[key: string]: any}) => ConfiguredMiddleware\n// A configured middleware (with options curried)\ntype ConfiguredMiddleware = (next: FetchLike) => FetchLike\n// A "fetch like" function, accepting an url and fetch options and returning a response promise\ntype FetchLike = (url: string, opts: WretcherOptions) => Promise<WretcherResponse>\n```\n\n#### middlewares(middlewares: ConfiguredMiddleware[], clear = false)\n\nAdd middlewares to intercept a request before being sent.\n\n```javascript\n/* A simple delay middleware. */\nconst delayMiddleware = delay => next => (url, opts) => {\n  return new Promise(res => setTimeout(() => res(next(url, opts)), delay))\n}\n\n// The request will be delayed by 1 second.\nwretch("...").middlewares([\n  delayMiddleware(1000)\n]).get().res(_ => /* ... */)\n```\n\n#### Context\n\nIf you need to manipulate data within your middleware and expose it for later consumption, a solution could be to pass a named property to the wretch options (*suggested name: `context`*).\n\nYour middleware can then take advantage of that by mutating the object reference.\n\n```js\nconst contextMiddleware = next => (url, opts) => {\n  if(opts.context) {\n    // Mutate "context"\n    opts.context.property = "anything"\n  }\n  return next(url, opts)\n}\n\n// Provide the reference to a "context" object\nconst context = {}\nconst res = await wretch("...")\n  // Pass "context" by reference as an option\n  .options({ context })\n  .middlewares([ contextMiddleware ])\n  .get()\n  .res()\n\nconsole.log(context.property) // prints "anything"\n```\n\n#### Middleware examples\n\n```javascript\n/* A simple delay middleware. */\nconst delayMiddleware = delay => next => (url, opts) => {\n  return new Promise(res => setTimeout(() => res(next(url, opts)), delay))\n}\n\n/* Returns the url and method without performing an actual request. */\nconst shortCircuitMiddleware = () => next => (url, opts) => {\n  // We create a new Response object to comply because wretch expects that from fetch.\n  const response = new Response()\n  response.text = () => Promise.resolve(opts.method + "@" + url)\n  response.json = () => Promise.resolve({ url, method: opts.method })\n  // Instead of calling next(), returning a Response Promise bypasses the rest of the chain.\n  return Promise.resolve(response)\n}\n\n/* Logs all requests passing through. */\nconst logMiddleware = () => next => (url, opts) => {\n  console.log(opts.method + "@" + url)\n  return next(url, opts)\n}\n\n/* A throttling cache. */\nconst cacheMiddleware = (throttle = 0) => {\n\n  const cache = new Map()\n  const inflight = new Map()\n  const throttling = new Set()\n\n  return next => (url, opts) => {\n    const key = opts.method + "@" + url\n\n    if(!opts.noCache && throttling.has(key)) {\n      // If the cache contains a previous response and we are throttling, serve it and bypass the chain.\n      if(cache.has(key))\n        return Promise.resolve(cache.get(key).clone())\n      // If the request in already in-flight, wait until it is resolved\n      else if(inflight.has(key)) {\n        return new Promise((resolve, reject) => {\n          inflight.get(key).push([resolve, reject])\n        })\n      }\n    }\n\n    // Init. the pending promises Map\n    if(!inflight.has(key))\n      inflight.set(key, [])\n\n    // If we are not throttling, activate the throttle for X milliseconds\n    if(throttle && !throttling.has(key)) {\n      throttling.add(key)\n      setTimeout(() => { throttling.delete(key) }, throttle)\n    }\n\n    // We call the next middleware in the chain.\n    return next(url, opts)\n      .then(_ => {\n        // Add a cloned response to the cache\n        cache.set(key, _.clone())\n        // Resolve pending promises\n        inflight.get(key).forEach((([resolve, reject]) => resolve(_.clone()))\n        // Remove the inflight pending promises\n        inflight.delete(key)\n        // Return the original response\n        return _\n      })\n      .catch(_ => {\n        // Reject pending promises on error\n        inflight.get(key).forEach(([resolve, reject]) => reject(_))\n        inflight.delete(key)\n        throw _\n      })\n  }\n}\n\n// To call a single middleware\nconst cache = cacheMiddleware(1000)\nwretch("...").middlewares([cache]).get()\n\n// To chain middlewares\nwretch("...").middlewares([\n  logMiddleware(),\n  delayMiddleware(1000),\n  shortCircuitMiddleware()\n}).get().text(_ => console.log(text))\n\n// To test the cache middleware more thoroughly\nconst wretchCache = wretch().middlewares([cacheMiddleware(1000)])\nconst printResource = (url, timeout = 0) =>\n  setTimeout(_ => wretchCache.url(url).get().notFound(console.error).text(console.log), timeout)\n// The resource url, change it to an invalid route to check the error handling\nconst resourceUrl = "/"\n// Only two actual requests are made here even though there are 30 calls\nfor(let i = 0; i < 10; i++) {\n  printResource(resourceUrl)\n  printResource(resourceUrl, 500)\n  printResource(resourceUrl, 1500)\n}\n```\n\n# License\n\nMIT\n'