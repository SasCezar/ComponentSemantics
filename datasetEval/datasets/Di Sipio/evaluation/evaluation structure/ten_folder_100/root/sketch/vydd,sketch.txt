b'* Sketch\n\n[[http://quickdocs.org/sketch/][file:http://quickdocs.org/badge/sketch.svg]]\n\nSketch is a Common Lisp environment for the creation of electronic art, visual design, game prototyping, game making, computer graphics, exploration of human-computer interaction and more. It is inspired by [[https://processing.org][Processing Language]] and shares some of the API.\n\n[[http://i.imgur.com/MNZUwz8.png]]\n\n** Installation\n\nSince April 2016, Sketch is available in [[https://www.quicklisp.org/beta/][Quicklisp]], Common Lisp\'s de facto package manager. This makes getting and running Sketch as easy as\n\n#+BEGIN_SRC lisp\n(ql:quickload :sketch)\n#+END_SRC\n\nTo make Sketch run correctly, though, a few requirements must be met.\n\n*** Requirements\n**** Common Lisp Implementation\nSketch should be compatible with all major Common Lisp implementations and all major operating systems - more specifically, all CL implementations and operating systems that [[https://github.com/lispgames/cl-sdl2][cl-sdl2]] runs on. Incompatibility with any of those is considered a bug.\n\nSketch is known to work with:\n\n- CCL 1.11 on Mac OS X El Capitan\n- CCL SVN 1.12.dev.r16617 on Arch Linux\n- CCL 1.11 on Windows 10 64bit\n- SBCL on Debian Unstable\n- SBCL 1.2.16 on Arch Linux\n- SBCL 1.3.1 on Linux Mint 17\n- SBCL 1.3.6 on Windows 10 64bit\n\nSketch is known to *not* work with:\n\n- SBCL 1.2.15 on Mac OS X\n/Sketch can\'t handle input and the window\'s titlebar is black. These kinds of issues are a known problem with Mac OS X, because it needs its GUI threads to be main, and CCL is the only lisp that accounts for that out of the box. There are ways to counter this, but until a solution finds its way into this repository, SBCL on Mac OS X will stay on this list. In the meantime, use CCL./\n\nIf you test Sketch on other systems, please send a pull request to include your results.\n\n**** Foreign dependencies\n***** SDL2\nSDL2 is currently Sketch\'s only backend. It is a C library which you will need to download manually from [[https://www.libsdl.org][libsdl webpage]]. Select the release compatible with your operating system, or compile from the source code.\n\n***** SDL2 Image & SDL2 TTF\nFor loading image and font files, Sketch relies on SDL2 Image and SDL2 TTF, respectively, both part of the SDL project.\n\n***** libffi\nSome users have reported that [[https://sourceware.org/libffi/][libffi]] needed to be installed to make Sketch work.\n\n***** OpenGL\nSketch requires graphics hardware and drivers with support for GL version 3.3.\n\n**** Installing and running Sketch on Windows\nSketch works on both CCL and SBCL, but installing all prerequisites might not be as straightforward as it is on the other platforms.\n\n***** Libraries\nDownload SDL2, SDL2_IMAGE and SDL2_TTF dlls from [[https://www.libsdl.org][libsdl webpage]] and copy them somewhere Windows can find them - =\\Windows\\System32= will work. When copying SDL2_TTF, make sure to copy all of the dlls provided in the archive, and not just the TTF one.\n\nNow you will need to get a libffi dll. One of the ways of doing this is compiling from the source, but for a quick and easy solution, you can just find a trusted source and use their version. For example, if you are using Emacs on Windows, you can find =libffi-6.dll= in =emacs\\bin=. Copy it to the same directory you copied sdl2 dlls to earlier.\n\n***** GCC\nTo bootstrap cffi-libffi, you are going to need a C compiler, more specifically the one from the GNU Compiler Collection. Also, libffi headers and pkg-config are needed. Luckily, you can get all these things (and more) with MSYS2. Go to [[https://msys2.github.io]] and follow the instructions for installing the 64bit version.\n\nFrom its console, install gcc, libffi headers and pkg-config by running =pacman -S gcc libffi libffi-devel pkg-config=.\n\n***** Environment variables\nFrom the Control Panel, open System properties, go to the Advanced tab, and click "Environment Variables..." - or click the Start button, start typing "environment" and select "Edit the system environment variables".\n\nDouble click "Path" from the list of System variables and make sure that both your lisp implementation\'s path (something like =C:\\Program Files\\Steel Bank Common Lisp\\1.3.6\\=) and MSYS path (probably =C:\\msys64\\usr\\bin=) are listed. If not, click "New" and add them now.\n\nIf you needed to change anything here, restart the computer now.\n\n***** SLIME\nIf you are using SLIME, you won\'t be able to load or run Sketch if you start SWANK from emacs (by running =M-x slime=). Instead, you should open the Command Prompt (the regular one, not MSYS), start your lisp and eval =(ql:quickload :swank)= =(swank:create-server)=. From Emacs, type =M-x slime-connect=, and finally, press enter twice (for localhost and port 4005).\n\nIf you did everything correctly, you should be able to =(ql:quickload :sketch)= and move on to the tutorial.\n\n**** If you are obtaining Sketch from this repository, instead of using Quicklisp releases\nPlease make sure to also get the following libraries to your =local-projects= directory. This is not necessary otherwise.\n\n- [[https://github.com/lispgames/cl-sdl2]]\n- [[https://github.com/lispgames/sdl2kit]]\n\n*** Running provided examples\n To get a feel for what Sketch can do, and also to make sure that everything has been installed correctly, you can look at the examples. The code below will run all four currently provided examples at once. Note that on older machines running four sketches at once might result in a small degradation in performance, so you might want to run sketches separately.\n\n#+BEGIN_SRC lisp\nCL-USER> (ql:quickload :sketch-examples)\nCL-USER> (make-instance \'sketch-examples:hello-world)\nCL-USER> (make-instance \'sketch-examples:sinewave)\nCL-USER> (make-instance \'sketch-examples:brownian)\nCL-USER> (make-instance \'sketch-examples:life) ; Click to toggle cells,\n\t                                           ; any key to toggle iteration\n#+END_SRC\n\n*** Running example code from this page\nIn all the following examples, we\'re going to assume that Sketch is loaded with =(ql:quickload :sketch)=, and that we\'re in package =:TUTORIAL=, which is set to use =:SKETCH=.\n\n#+BEGIN_SRC lisp\nCL-USER> (ql:quickload :sketch)\nCL-USER> (defpackage :tutorial (:use :cl :sketch))\nCL-USER> (in-package :tutorial)\nTUTORIAL> ;; ready\n#+END_SRC\n\n** Tutorial\n/NOTE: This tutorial is using the revised/ =DEFSKETCH= /macro, introduced in May 2016. Until this release hits Quicklisp, you\'ll have to install Sketch manually to your/ =local-projects= /directory, along with https://github.com/lispgames/cl-sdl2 and\nhttps://github.com/lispgames/sdl2kit. More about this [[https://github.com/vydd/sketch/issues/12][here]]./\n\nDefining sketches is done with the =DEFSKETCH= macro, that wraps =DEFCLASS=. Using =DEFCLASS= is still possible, but =DEFSKETCH= makes everything so much easier, and in these examples, we\'re going to pretend that\'s the only way.\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ())\n  (make-instance \'tutorial)\n#+END_SRC\n\nIf all goes well, this should give you an unremarkable gray window.\n\n*** Shapes\nLet\'s draw something!\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (rect 100 100 200 200))\n#+END_SRC\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (dotimes (i 10)\n      (rect (* i 40) (* i 40) 40 40)))\n#+END_SRC\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (dotimes (i 10)\n      (rect 0 (* i 40) (* (+ i 1) 40) 40)))\n#+END_SRC\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (dotimes (i 10)\n      (rect 0 (* i 40) (* (+ i 1) 40) 40))\n    (circle 300 100 50))\n#+END_SRC\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (line 0 0 400 400)\n    (line 400 0 0 400))\n#+END_SRC\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (polyline 100 100 200 150 300 100\n              200 200 100 100))\n#+END_SRC\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (polygon 100 100 200 150 300 100 200 200))\n#+END_SRC\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (dotimes (i 4)\n      (ngon (+ i 3) (+ 50 (* i 100)) 200 20 20 (* i 20))))\n#+END_SRC\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (bezier 0 400 100 100 300 100 400 400))\n#+END_SRC\n\n*** Colors\nGrayscale imagery is nice, but let\'s add color and make our sketch more vibrant. Assuming that you\'re using Emacs + SLIME, or a similarly capable environment, you can just re-evaluate with the following code:\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (background +yellow+))\n#+END_SRC\n\nThe window becomes yellow. There are a couple of things to note. Drawing code doesn\'t need to go into a special function or method, or be binded to a sketch explicitly. =DEFSKETCH= is defined as =(defsketch sketch-name bindings &body body)=: that body is your drawing code. We will get to =BINDINGS= later. The other thing is that Sketch comes with its own color library.\n\n**** Predefined colors\nThere are constants for commonly used colors: =+RED+=, =+GREEN+=, =+BLUE+=, =+YELLOW+=, =+MAGENTA+=, =+CYAN+=, =+ORANGE+= =+WHITE+=, and =+BLACK+=.\n\n**** RGB, HSB, GRAY\nIf you want to be more specific about the colors you want, you are welcome to use =(rgb red green blue &optional (alpha 1.0))=, =(hsb hue saturation brightness &optional (alpha 1.0))= or =(gray amount &optional (alpha 1.0))=. The arguments to these functions are values from 0 to 1. You can use these functions in the same way you just used =+YELLOW+=. Hopefully the function names and their arguments are self-explanatory, but if not, you can learn about the RGB color model [[https://en.wikipedia.org/wiki/RGB_color_model][here]] and about HSB (also called HSV) [[https://en.wikipedia.org/wiki/HSL_and_HSV][here]]. =(gray amount &optional (alpha 1.0))= is really just a convenient alias for =(rgb amount amount amount &optional (alpha 1.0))=, and can be used for brevity when a shade of gray needs to be defined.\n\n/This might be a good place to note that function names in Sketch use the American English spellings, like "gray" and "color". It\'s just a choice that needed to be made, in pursue of uniformity and good style./\n\n#+BEGIN_SRC lisp\n  (defsketch tutorial ()\n    (background (rgb 1 1 0.5)))\n#+END_SRC\n\nThis will give you a lighter yellow.\n\nAll functions have an additional, =ALPHA= parameter. It determines the amount of transparency that the color should have.\n\n**** RGB-255, HSB-360, GRAY-255\nSometimes it\'s easier to think about color values in non-normalized ranges. That\'s why Sketch offers =RGB-255=, =HSB-360=, and =GRAY-255=.\n\nThis is how these functions map to their normalized variants.\n\n| (rgb-255 r g b a) | (rgb (/ r 255) (/ g 255) (/ b 255) (/ a 255)) |\n| (hsb-360 h s b a) | (hsb (/ h 360) (/ s 100) (/ b 100) (/ a 255)) |\n| (gray-255 g a)    | (gray (/ g 255) (/ a 255))                    |\n\n=HSB-360= is using different ranges, because hue is represented in degrees (0-360), and saturation and brightness are represented as percentages (0-100).\n\n**** HEX-TO-COLOR\nIf you are used to working with colors in hex, like in CSS, you can use =(hex-to-color string)=, where =STRING= is the color in one of the following formats: "4bc", "#4bc", "4bcdef", and "#4bcdef".\n\n**** Generating colors\nIf you don\'t care about fiddling with the exact values, but still need different colors, you can use one of the following functions.\n\n***** =(lerp-color (start-color end-color amount &key (mode :hsb)))=\nLerping is a fancy way of saying [[https://en.wikipedia.org/wiki/Linear_interpolation][linear interpolation]]. This function takes the starting color and the ending color, and returns the color between them, which is an =AMOUNT= away from the starting color. When =AMOUNT= equals zero, the returned color equals the starting color, and when =AMOUNT= equals one, the ending color is returned. Amounts between zero and one give colors that are "in-between". These colors are calculated according to the specified =MODE=, which is =:HSB= by default, meaning that the resulting color\'s hue is between the starting and ending hue, as is the case with its saturation and brightness.\n\n#+BEGIN_SRC lisp\n  (defsketch lerp-test ((title "lerp-color") (width 400) (height 100))\n    (dotimes (i 4)\n      (with-pen (make-pen :fill (lerp-color +red+ +yellow+ (/ i 4)))\n        (rect (* i 100) 0 100 100))))\n#+END_SRC\n\n***** =(random-color (&optional (alpha 1.0)))=\nReturns a random color. You probably don\'t want to use this, because much of the returned colors are either too dark, or too light. You do get to choose the =ALPHA= value, though.\n\n#+BEGIN_SRC lisp\n  (defparameter *colors* (loop for i below 16 collect (random-color)))\n\n  (defsketch random-color-test ((title "random-color") (width 400) (height 100))\n    (dotimes (x 8)\n      (dotimes (y 2)\n        (with-pen (make-pen :fill (elt *colors* (+ x (* y 8))))\n          (rect (* x 50) (* y 50) 50 50)))))\n#+END_SRC\n\n***** =(hash-color (n &optional (alpha 1.0)))=\nThis is probably the function you\'re looking for, if you just want to create a non-repeating set of colors quickly. It maps all numbers to "interesting" (not too dark, not too light) colors. You can use this for coloring procedurally generated objects, when prototyping and just trying to make things look different quickly, when making palettes, looking for "the right" color, and many other things.\n\n#+BEGIN_SRC lisp\n  (defsketch hash-color-test ((title "hash-color") (width 400) (height 100))\n    (dotimes (i 128)\n      (with-pen (make-pen :fill (hash-color i))\n        (rect (* i (/ 400 128)) 0 (/ 400 128) 100))))\n#+END_SRC\n\n**** Color filters\nSometimes you have a color, and would like to transform it in some way. That\'s what color filters are for.\n\n***** Grayscale\nTo convert colors to grayscale, you can use =color-filter-grayscale=. Two modes of grayscale conversion are implemented:\n\n- =:luminosity=, the default, which is [[https://en.wikipedia.org/wiki/Grayscale#Colorimetric_.28luminance-preserving.29_conversion_to_grayscale][luminance-preserving]]\n- =:average=, which sets all color channels to their average\n\n#+BEGIN_SRC lisp\n  (defsketch grayscale-test ((title "grayscale") (width 400) (height 300))\n    (dotimes (i 10)\n      (let ((color (hash-color i)))\n        (with-pen (make-pen :fill (color-filter-grayscale color))\n          (rect (* i 40) 0 40 100))\n        (with-pen (make-pen :fill color)\n          (rect (* i 40) 100 40 100))\n        (with-pen (make-pen :fill (color-filter-grayscale color :average))\n          (rect (* i 40) 200 40 100)))))\n#+END_SRC\n\n***** Invert\nTo invert a color, use =color-filter-invert=:\n\n#+BEGIN_SRC lisp\n  (defsketch invert-test\n      ((title "invert") (width 300) (height 300) (i 0))\n    (background +white+)\n    (incf i 0.01)\n    (let ((color (rgb (abs (sin i)) (abs (cos i)) 0)))\n      (with-pen (make-pen :fill color)\n        (circle 100 150 50))\n      (with-pen (make-pen :fill (color-filter-invert color))\n        (circle 200 150 50))))\n#+END_SRC\n\n***** Rotate\nRotating a color in Sketch using =color-filter-rotate= sets the value of its red channel to the\nprevious value of the green channel; green to blue, and blue to\nred. The operation is intended to be used in palette generation,\nbecause the rotated colors usually work pretty well together.\n\n#+BEGIN_SRC lisp\n  (defsketch rotate-test\n      ((title "rotate") (width 300) (height 300)\n       (i 0) (color (rgb 0.2 0.8 1.0)))\n    (background +white+)\n    (incf i 1)\n    (when (zerop (mod i 60))\n      (setf color (color-filter-rotate color)))\n    (with-pen (make-pen :fill color)\n      (rect 100 100 100 100)))\n#+END_SRC\n\n***** HSB\n[[https://en.wikipedia.org/wiki/HSL_and_HSV][HSB]] stands for Hue/Saturation/Brightness. You can use\n=color-filter-hsb= to adjust hue, saturation and brightness of an existing color.\n\n#+BEGIN_SRC lisp\n  (defsketch hsb-test\n      ((title "hsb") (width 400) (height 300) (color (rgb 0.2 0.5 0.6)))\n    (dotimes (i 4)\n      (with-pen (make-pen :fill (color-filter-hsb color :hue (* 0.1 (+ i 1))))\n        (rect (* i 100) 0 100 100))\n      (with-pen (make-pen :fill (color-filter-hsb color :saturation (* 0.1 (+ i 1))))\n        (rect (* i 100) 100 100 100))\n      (with-pen (make-pen :fill (color-filter-hsb color :brightness (* 0.1 (+ i 1))))\n        (rect (* i 100) 200 100 100))))\n#+END_SRC\n\n*** Pens\nPens are used to draw shapes. If no pen is specified, the default pen sets =:fill= to white, =:stroke= to black, and =weight= to 1.\n\n***** Creating and Using Pens\nSay you want to draw a red square and a blue circle. You would need to use two different pens.\n#+BEGIN_SRC lisp\n  (defsketch pen-test\n      ((title "pens"))\n    (with-pen (make-pen :fill +red+)\n      (rect 100 100 100 100)) ; this rect will be red\n    (with-pen (make-pen :fill +blue+)\n      (circle 315 315 50))) ; this rect will be blue\n#+END_SRC\n\n***** Fill/Stroke\nThe squares in the previous example were filled because we specified the =:fill= property in =make-pen=.\nIf we wanted to just draw the outline of the square, we would use =:stroke= like this:\n#+BEGIN_SRC lisp\n  (defsketch outline-square\n      ((title "Outline Square"))\n    (with-pen (make-pen :stroke +red+)\n      (rect 100 100 100 100)))\n#+END_SRC\n#+BEGIN_SRC lisp\n  (defsketch fill-stroke\n      ((title "Fill and Stroke"))\n    (background +white+)\n    (with-pen (make-pen :stroke (rgb .5 0 .6) :fill (rgb 0 .8 .8))\n      (rect 50 50 100 75)\n      (circle 300 220 100)))\n#+END_SRC\n\n***** Weight\nWe can also change the thickness of the lines and shapes that we draw by changing the pen =:weight=.\n#+BEGIN_SRC lisp\n  (defsketch weight-test\n      ((title "Weight Test"))\n    (dotimes (i 10)\n      (with-pen (make-pen :stroke +white+ :weight (+ i 1)) ; pen weight can\'t be zero\n        (line 50 (* i 20) 350 (* i 20)))))\n#+END_SRC\n\n**** Curve-steps\n=:curve-steps= is used to change the smoothness (resolution) of curves like =#\'bezier=.\n#+BEGIN_SRC lisp\n  (defsketch curve-test\n     ((title "Curve-steps"))\n    (dotimes (i 99)\n      (with-pen (make-pen :stroke +red+ :curve-step (+ i 1)) ; as curve-step increases, curve becomes "smoother"\n        (bezier 0 400 100 100 300 100 400 400))))\n#+END_SRC\n\n*** Transforms\nTODO\n\n*** Text\nTODO\n\n*** Images\nTODO\n\n*** Bindings\nTODO\n\n*** Input\nTODO\n\n** Made with Sketch\n- [[https://vydd.itch.io/qelt][QELT]]\n- [[https://bitbucket.org/sjl/coding-math][sjl\'s implementation of coding math videos]]\n- [[http://git.axity.net/axion/crawler2][Visual examples for axion\'s crawler2 library]]\n\n** FAQ\n*** I\'m trying to compile my defsketch definition, but it keeps telling me that :TITLE (or :WIDTH, :HEIGHT, etc.) is not of the expected type LIST. Why is this happening?\nYou\'re probably trying to use the old way of defining sketches - =(defsketch name window-parameters slot-bindings &body body)=. =DEFSKETCH= has been changed to =(defsketch name bindings &body body)=. It\'s still possible to define the title and other window parameters, though.\n\nExample:\n\n#+BEGIN_SRC lisp\n  (defsketch foo (:title "Foo" :width 400)\n      ((a 3))\n    (rect 100 100 200 200))\n\n  ;;; Becomes\n\n  (defsketch foo\n      ((title "Foo")\n       (width 400)\n       (a 3))\n    (rect 100 100 200 200))\n#+END_SRC\n\nFor more, read about "Bindings" in the tutorial above.\n\n** Outro\nFor everything else, read the code or ask vydd at #lispgames.\n\nGo make something pretty!\n\n** License\n\nCopyright (c) 2015, 2016, 2017 Danilo Vidovic (vydd)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n'