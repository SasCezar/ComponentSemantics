b'# Morse\n\n[![Circle CI](https://circleci.com/gh/Otann/morse.svg?style=shield&no-cache=5)](https://circleci.com/gh/Otann/morse)\n[![Clojars](https://img.shields.io/clojars/v/morse.svg)](https://clojars.org/morse)\n[![codecov](https://codecov.io/gh/Otann/morse/branch/master/graph/badge.svg)](https://codecov.io/gh/Otann/morse)\n\n<img width="30%"\n     align="right" padding="5px"\n     alt=":)"\n     src="http://otann.github.io/media/projects/morse/signature.gif"/>\n\nMorse is a client for [Telegram](https://telegram.org) [Bot API](https://core.telegram.org/bots/api) for the [Clojure](http://clojure.org) programming language.\n\n\n## Installation\n\nAdd `[morse "0.4.3"]` to the dependency section in your project.clj file.\n\nThere is also a template which you can use to bootstrap your project:\n\n    lein new morse my-project\n    cd my-project\n    export TELEGRAM_TOKEN=...\n    lein run\n\n## Detecting user\'s actions\n\nTelegram sends updates about events in chats in form of\n[Update](https://core.telegram.org/bots/api#update) objects.\n\nInside those there could be commands, inline queries and many more.\nTo help you with these Morse provides you helpers and some macros in\n`morse.handlers` namespace.\n\nIf you are familiar with building web-service with Compojure,\nyou\'ll find similarities here:\n\n```clojure\n(ns user\n  (:require [morse.handlers :as h]\n            [morse.api :as t]))\n\n(def token "YOUR-BIG-SECRET")          \n\n; This will define bot-api function, which later could be\n; used to start your bot\n(h/defhandler bot-api\n  ; Each bot has to handle /start and /help commands.\n  ; This could be done in form of a function:\n  (h/command-fn "start" (fn [{{id :id :as chat} :chat}]\n                          (println "Bot joined new chat: " chat)\n                          (t/send-text token id "Welcome!")))\n\n  ; You can use short syntax for same purposes\n  ; Destructuring works same way as in function above\n  (h/command "help" {{id :id :as chat} :chat}\n    (println "Help was requested in " chat)\n    (t/send-text token id "Help is on the way"))\n\n  ; Handlers will be applied until there are any of those\n  ; returns non-nil result processing update.\n\n  ; Note that sending stuff to the user returns non-nil\n  ; response from Telegram API.     \n\n  ; So match-all catch-through case would look something like this:\n  (h/message message (println "Intercepted message:" message)))\n\n```\n\n### Messages\n\nReceives [Message](https://core.telegram.org/bots/api#message) object as\nfirst parameter in a function or target of binding:\n\n```clojure\n(command-fn "start" (fn [msg] (println "Received command: " msg)))\n; or in a macro form\n(command "start" msg (println "Received command: " msg))\n```\n\nIf you wish to process messages that are not prefixed by a command,\nthere is also a helper:\n\n```clojure\n(message-fn (fn [msg] (println "Received message: " msg)))\n; or in a macro form\n(message msg (println "Received message: " msg))\n```\n\n### Inline requests\n\nThere is also a helper to define handlers for [InlineQueries](https://core.telegram.org/bots/api#inlinequery)\nin a similar form:\n\n```clojure\n(inline-fn (fn [inline] (println "Received inline: " inline)))\n; or in a macro form\n(inline inline (println "Received inline: " inline))\n```\n\n### Callbacks\n\nYou can provide handlers for [Callbacks](https://core.telegram.org/bots/api#answercallbackquery)\nwhich are sent from [inline keyboards](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating)\n\n```clojure\n(callback-fn (fn [data] (println "Received callback: " inline)))\n; or in a macro form\n(callback data (println "Received callback: " inline))\n```\n\n\n## Starting your bot\n\nAs Telegram documentation says, there are two ways of getting updates\nfrom the bot: webhook and long-polling.\n\n#### Webhook\n\nIf you develop a web application, you can use api call to\n[register](https://core.telegram.org/bots/api#setwebhook) one of your endpoints in Telegram:\n\n```clojure\n(require \'[morse.api :as api])\n\n(api/set-webhook "abc:XXX" "http://example.com/handler")\n```\n\nTelegram will use this url to `POST` messages to it.\nYou can also use handler to react on these messages.\nHere is quick example if you use [`compojure`](https://github.com/weavejester/compojure):\n\n```clojure\n(defhandler bot-api\n  (command "help" {{id :id} :chat}\n    (api/send-text token id "Help is on the way")))\n\n(defroutes app-routes\n  (POST "/handler" {{updates :result} :body} (map bot-api updates))\n  (route/not-found "Not Found"))\n```\n\n#### Long-polling\n\nThis solution works perfectly if you don\'t plan on having a webserver\nor want to test your bot from a local machine.\n\nStart the process by simply calling `start` function and pass it token and your handler:\n\n```clojure\n(require \'[morse.polling :as p])\n\n(def channel (p/start token handler))\n```\n\nThen if you want to stop created background processes, call stop on returned channel:\n\n```clojure\n(p/stop channel)\n```\n\n\n## Sending messages\n\nUse `morse.api` to interact with Telegram chats:\n\n```clojure\n(require \'[morse.api :as api])\n```\n\nFollowing methods from the API are implemented at the moment. All of them may use the advanced options by providing an additional option map argument. For all functions sending files File, ByteArray and InputStream are supported as arguments.\n\n### [`sendMessage`](https://core.telegram.org/bots/api#sendmessage)\n\n```clojure\n(api/send-text token chat-id "Hello, fellows")\n```\n\nYou can use advanced options:\n\n```clojure\n(api/send-text token chat-id\n               {:parse_mode "Markdown"}\n               "**Hello**, fellows")\n```\n\n### [`sendPhoto`](https://core.telegram.org/bots/api#sendphoto)\n\nThis sends a photo that will be displayed using the embedded image viewer where available.\n\n```clojure\n(require \'[clojure.java.io :as io])\n\n(api/send-photo token chat-id\n                (io/file (io/resource "photo.png")))\n```\n\nYou can use advanced options:\n\n```clojure\n(api/send-photo token chat-id\n                {:caption "Here is a map:"}\n                (io/file (io/resource "map.png")))\n```\n\n### [`sendVideo`](https://core.telegram.org/bots/api#sendvideo)\n\nSends the given mp4 file as a video to the chat which will be shown using the embedded player where available.\n\n```clojure\n(api/send-video token chat-id\n                (io/file (io/resource "video.mp4")))\n```\n\n\n### [`sendAudio`](https://core.telegram.org/bots/api#sendaudio)\n\nSends the given mp3 file as an audio message to the chat.\n\n```clojure\n(api/send-audio token chat-id\n                (io/file (io/resource "audio.mp3")))\n```\n\n### [`sendSticker`](https://core.telegram.org/bots/api#sendsticker)\n\nSends the given WebP image as a sticker to the chat.\n\n```clojure\n(api/send-sticker token chat-id\n                  (io/file (io/resource "sticker.webp")))\n```\n\n### [`sendDocument`](https://core.telegram.org/bots/api#senddocument)\n\nThis method can be used for any other kind of file not supported by the other methods, or if you don\'t want telegram to make a special handling of your file (i.e. sending music as a voice message).\n\n```clojure\n(api/send-document token chat-id\n                   (io/file (io/resource "document.pdf")))\n```\n\n### [`answerInlineQuery`](https://core.telegram.org/bots/api#answerinlinequery)\n\nSends an answer to an inline query.\n\n```clojure\n(api/answer-inline token inline-query-id options\n                   [{:type "gif"\n                     :id "gif1"\n                     :gif_url "http://funnygifs/gif.gif"}])\n```\n\n### [`answerCallbackQuery`](https://core.telegram.org/bots/api#answercallbackquery)\n\nSends an answer to an callback query sent from inline keyboards.\n\n```clojure\n(api/answer-callback token\n                     callback-query-id\n                     text\n                     show-alert)\n```\n\n## License\n\nCopyright \xc2\xa9 2017 Anton Chebotaev\n\nDistributed under the Eclipse Public License either version 1.0.\n'