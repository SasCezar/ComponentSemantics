b'<p align="center">\n    <a href="https://swift.org"><img src="https://img.shields.io/badge/Swift-5.0-orange.svg" alt="Swift" /></a>\n    <a href="https://telegram.me/swiftsdkchat"><img src="https://img.shields.io/badge/Chat-Telegram-lightgrey.svg" alt="Chat" /></a>\n    <a href="https://swift.org"><img src="https://img.shields.io/badge/OS-OS%20X%2C%20Linux-lightgrey.svg" alt="Platform" /></a>\n    <a href="https://tldrlegal.com/license/mit-license"><img src="https://img.shields.io/badge/License-Apache%202.0-blue.svg" alt="License" /></a>\n    <a href="https://travis-ci.org/rapierorg/telegram-bot-swift"><img src="https://travis-ci.org/rapierorg/telegram-bot-swift.svg?branch=master" alt="Build Status" /></a>\n\n</p>\n\n<p align="center">\n    <a href="#telegram-chat">Chat</a>\n  \xe2\x80\xa2 <a href="#whats-new">Changelog</a>    \n  \xe2\x80\xa2 <a href="#prerequisites">Prerequisites</a>\n  \xe2\x80\xa2 <a href="#getting-started">Getting started</a>\n  \xe2\x80\xa2 <a href="#creating-a-new-bot">Creating a new bot</a>\n  \xe2\x80\xa2 <a href="#generating-xcode-project">Generating Xcode project</a>\n  \xe2\x80\xa2 <a href="#api-overview">API overview</a>\n  \xe2\x80\xa2 <a href="#debugging-notes">Debugging notes</a>\n  \xe2\x80\xa2 <a href="#examples">Examples</a>\n  \xe2\x80\xa2 <a href="#documentation">Documentation</a>\n  \xe2\x80\xa2 <a href="#need-help">Support</a>\n  \xe2\x80\xa2 <a href="#license">License</a>\n</p>\n\n# SDK for creating Telegram Bots in Swift.\n\n*Sample projects:*\n\nShopping list bot.\n\n<img src="https://github.com/zmeyc/telegram-bot-swift/wiki/img/shopster_bot.jpg" width=300>\n\nWord reverse bot.\n\n<img src="https://github.com/zmeyc/telegram-bot-swift/wiki/img/word_reverse_bot.jpg" width=300>\n\nTrivial bot:\n\n```swift\nimport TelegramBotSDK\n\nlet bot = TelegramBot(token: "my token")\nlet router = Router(bot: bot)\n\nrouter["greet"] = { context in\n    guard let from = context.message?.from else { return false }\n    context.respondAsync("Hello, \\(from.firstName)!")\n    return true\n}\n\nrouter[.newChatMembers] = { context in\n    guard let users = context.message?.newChatMembers else { return false }\n    for user in users {\n        guard user.id != bot.user.id else { return false }\n        context.respondAsync("Welcome, \\(user.firstName)!")\n    }\n    return true\n}\n\nwhile let update = bot.nextUpdateSync() {\n\ttry router.process(update: update)\n}\n\nfatalError("Server stopped due to error: \\(bot.lastError)")\n```\n\n## Telegram chat\n\nJoin our chat in Telegram: [swiftsdkchat](https://telegram.me/swiftsdkchat).\n\n## What\'s new\n\n[Release notes](https://github.com/zmeyc/telegram-bot-swift/blob/master/CHANGELOG.md) contain the significant changes in each release with migration notes.\n\n## Prerequisites\n\nOn OS X, use the latest Xcode 9 release.\n\nOn Linux, install `Swift 4.2` or newer and `libcurl4-openssl-dev` package. Note that `shopster-bot` example won\'t build on Linux because GRDB doesn\'t support Linux yet, but otherwise the library should be functional.\n\n## Getting started\n\nPlease get familiar with the documentation on Telegram website:\n\n* [Bots: An introduction for developers](https://core.telegram.org/bots)\n\n* [Telegram Bot API](https://core.telegram.org/bots/api)\n\n\n## Creating a new bot\n\nIn Telegram, add `BotFather`. Send him these commands:\n\n```\n/newbot\nBotName\nusername_of_my_bot\n```\n\nBotFather will return a token.\n\nCreate a project for your bot:\n\n```\nmkdir hello-bot\ncd hello-bot\nswift package init --type executable\n\n```\n\nCreate `Package.swift`:\n\n```swift\n// swift-tools-version:5.1\nimport PackageDescription\n\nlet package = Package(\n    name: "hello-bot",\n    products: [\n        // Products define the executables and libraries produced by a package, and make them visible to other packages.\n        .executable(\n            name: "hello-bot",\n            targets: ["hello-bot"]\n        ),\n    ],\n    dependencies: [\n        // Dependencies declare other packages that this package depends on.\n        // .package(url: /* package url */, from: "1.0.0"),\n        .package(url: "https://github.com/zmeyc/telegram-bot-swift.git", from: "1.1.0"),\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        // Targets can depend on other targets in this package, and on products in packages which this package depends on.\n        .target(\n            name: "hello-bot",\n            dependencies: ["TelegramBotSDK"]),\n    ]\n)\n```\n\nCreate `Sources/main.swift`:\n\n```swift\nimport Foundation\nimport TelegramBotSDK\n\nlet token = readToken(from: "HELLO_BOT_TOKEN")\nlet bot = TelegramBot(token: token)\n\nwhile let update = bot.nextUpdateSync() {\n    if let message = update.message, let from = message.from, let text = message.text {\n        bot.sendMessageAsync(chatId: from.id,\n                             text: "Hi \\(from.firstName)! You said: \\(text).\\n")\n    }\n}\n\nfatalError("Server stopped due to error: \\(bot.lastError)")\n```\n\n> Do not commit your token to git!\n\n`readToken` reads token from environment variable or from a file. So, either create an environment variable:\n\n```\nexport HELLO_BOT_TOKEN=\'token\'\n```\n\nOr save the token to a file and add the file to .gitignore:\n\n```\necho token > HELLO_BOT_TOKEN\n```\n\nBuild your bot:\n\n```\nswift build\n```\n\nAnd run it:\n\n```\n./.build/x86_64-apple-macosx10.10/debug/hello-bot\n```\n\nMore details are available on Wiki: [New Bot](https://github.com/zmeyc/telegram-bot-swift/wiki/New-Bot).\n\n## Generating Xcode project\n\nIt\'s easy:\n\n```\nswift package generate-xcodeproj\n```\n\nOpen generated `hello-bot.xcodeproj` and switch the active scheme to the bottom one:\n\n<img src="https://github.com/zmeyc/telegram-bot-swift/wiki/img/scheme.jpg" width=419>\n\nDon\'t forget to add your token to environment variables in Xcode (Scheme settings -> Run).\n\nPress CMD-R to start the bot.\n\n## API overview\n\n### Type and request names\n\nSDK type and request names closely mirror [original Telegram ones](https://core.telegram.org/bots/api).\n\nSwift types and enums were added where appropriate:\n \n\n```swift\nif entity.type == .botCommand { ... }\n```\n\nIn most cases raw methods accepting strings are also available. They can be used as fallbacks if required enum case is not added yet:\n\n```swift\nif entity.typeString == "bot_command" { ... }\n```\n\nTo allow accessing fields which are still missing in SDK, every data type has `json` member with original json structure:\n\n```swift\nif entity.json["type"].stringValue == "bot_command" { ... }\n```\n\nAll types conform to `JsonConvertible` protocol and can be created from json or serialized back to json. Use `debugDescription` method for human-readable json or `description` for json which can be sent to server.\n\n### Requests\n\n**Sync and Async**\n\nRequest names closely mirror Telegram ones, but have two versions: `synchronous` and `asynchronous` with method suffixes `Sync` and `Async` correspondingly.\n\n* Synchronous methods block until the operation is completed.\n\n```swift\nlet fromId: Int64 = 12345678 // your user id\nbot.sendMessageSync(fromId, "Hello!") // blocks until the message is sent\nbot.sendMessageSync(fromId, "Bye.")\n```\n\nThese methods return a server response or `nil` in case of error. If `nil` is returned, details can be obtained by querying `bot.lastError`.\n\n```swift\nguard let sentMessage = bot.sendMessageSync(fromId, "Hello") else {\n    fatalError("Unable to send message: \\(bot.lastError.unwrapOptional)")\n}\n```\n\nDo not use synchronous methods in real apps because they\'re slow. Use them when debugging or for experimenting in `REPL`. More details: [Using Swift REPL for calling API methods](https://github.com/zmeyc/telegram-bot-swift/wiki/Using-Swift-REPL-for-calling-API-methods)\n\n* Asynchronous methods accept an optional completion handler which will be called when operation is completed.\n\nCompletion handler is called on main thread by default.\n\n```swift\nbot.sendMessageAsync(fromId, "Hello!") { result, error in\n  // message sent!\n  bot.sendMessageAsync(fromId, "Bye.")\n}\n// execution continues immediately\n```\n\nIn completion handler `result` contains the server response or `nil` in case of error. Details can be obtained by querying `error`.\n\nFor simplicity, it\'s possible to synchronously process messages, but respond asynchronously to avoid blocking the processing of the next message. So, a typical bot\'s main loop can look like this:\n\n```swift\nwhile let update = bot.nextUpdateSync() {\n  // process the message and call Async methods\n}\n```\n\n**Request parameters**\n\nParameter names should be specified explicitly in most cases:\n\n```swift\nbot.sendLocationAsync(chat_id: chatId, latitude: 50.4501, longitude: 30.5234)\n```\n\nException to this are `sendMessageSync/Async` and `respondSync/Async` functions which are used very often. Parameter names can be omitted in them:\n\n```swift\nbot.sendMessageAsync(chatId: chatId, text: "Text")\nbot.sendMessageAsync(chatId, "Text") // will also work\n```\n\n`Optional` parameters can also be passed:\n\n```swift\nlet markup = ForceReply()\nbot.sendMessageAsync(chatId: chatId, text: "Force reply",\n    reply_markup: markup, disable_notification: true)\n```\n\nIf you ever encounter a situation when parameter hasn\'t been added to method signature yet, you can pass a dictionary with any parameters at the end of parameter list:\n\n```swift\nlet markup = ForceReply()\nbot.sendMessageAsync(chatId: chatId, text: "Force reply",\n    ["reply_markup": markup, "disable_notification": true])\n```\n\nIt\'s also possible to set default parameter values for a request:\n\n```swift\nbot.defaultParameters["sendMessage"] = ["disable_notification": true]\n```\n\nIn dictionaries `nil` values will be treated as `no value` and won\'t be sent to Telegram server.\n\n**Available requests**\n\nCheck `TelegramBot/Requests` subdirectory for a list of available requests.\n\nIf you find a missing request, please create a ticket and it will be added. Until then, an arbitrary unsupported endpoint can be called like this:\n\n```swift\nlet user: User? = requestSync("sendMessage", ["chat_id": chatId, "text": text])\n```\n\nOr async version:\n\n```swift\nrequestAsync("sendMessage", ["chat_id": chatId, "text": text]) { (result: User?, error: DataTaskError?) -> () in\n    ...\n}\n```\n\nThese methods automatically deserialize the json response.\n\nExplicitly specifying result type is important. Result type should conform to `JsonConvertible` protocol. `Bool` and `Int` already conform to `JsonConvertible`.\n\nJSON class itself also conforms to `JsonConvertible`, so you can request a raw json if needed:\n\n```swift\nlet user: JSON? = requestSync("sendMessage", ["chat_id": chatId, "text": text])\n```\n\n### Routing\n\nRouter maps text commands and other events to their handler functions and helps parsing command arguments.\n\n```swift\nlet router = Router(bot)\nrouter["command1"] = handler1\nrouter["command2"] = handler2\nrouter[.event] = handler3\n...\nrouter.process(update: update)\n```\n\nMultiple commands can be specified in a single rule:\n\n```swift\nrouter["Full Command Name", "command"] = handler\n```\n\nMultiword commands are also supported:\n\n```swift\nrouter["list add"] = onListAdd\nrouter["list remove"] = onListRemove\n```\n\nRouters can be chained. This helps creating a context-sensitive routers with fallback to a global router.\n\n```swift\nrouter1.unmatched = router2.handler\n```\n\n**Handlers**\n\nHandlers take `Context` argument and return `Bool`.\n\n * If handler returns `true`, command matching stops.\n * If handler returns `false`, other paths will be matched.\n \nSo, in handler check preconditions and return false if they aren\'t satisfied:\n\n```swift\nrouter["reboot"] = { context in\n    guard let fromId = context.fromId where isAdmin(fromId) else { return false }\n    \n    context.respondAsync("I will now reboot the PC.") { _ in\n        reboot()\n    }\n    \n    return true\n}\n```\n\nHandler functions can be marked as `throws` and throw exceptions. Router won\'t process them and will simply pass the exceptions to caller.\n\n`Context` is a request context, it contains:\n \n * `bot` - a reference to the bot.\n * `update` - current `Update` structure.\n * `message` - convenience method for accessing `update.message`. If `update.message` is nil, fallbacks to `update.edited_message`, then to `update.callback_query?.message`.\n * `command` - command without slash.\n * `slash` - true, if command was prefixed with a slash. Useful if you want to skip commands not starting with slash in group chats.\n * `args` - command arguments scanner.\n * `properties` - context sensitive properties. Pass them to `process` method:\n\n```swift\nvar properties = [String: AnyObject]()\nproperties["myField"] = myValue\ntry router.process(update: update, properties: properties)\n```\n\nAnd use them in handlers:\n\n```swift\nfunc myHandler(context: Context) -> Bool {\n    let myValue = context.properties["myField"] as? MyValueType\n    // ...\n}\n```\n\nOr make a `Context` category for easier access to your properties, for example:\n\n```swift\nextension Context {\n    var session: Session { return properties["session"] as! Session }\n}\n```\n \n`Context` also contains a few helper methods and variables:\n \n * `privateChat` - true, if this is a private chat with bot, false for all group chat types.\n * `chatId` - shortcut for message?.chat.id. If message is nil, tries to retrieve chatId from other `Update` fields.\n * `fromId` - shortcut for message?.from?.id. If message is nil, tries to retrieve fromId from other `Update` fields.\n * `respondAsync`, `respondSync` - works as `sendMessage(chatId, ...)`\n * `respondPrivatelyAsync/Sync("text", groupText: "text")` - respond to user privately, sending a short message to the group if this was a group chat. For example:\n \n```swift\ncontext.respondPrivatelyAsync("Command list: ...",\n    groupText: "Please find a list of commands in a private message.")\n```\n\n * `reportErrorAsync/Sync(text: "User text", errorDescription: "Detailed error description for administrator")` - sends a short message to user and prints detailed error description to a console. `text` parameter can be omitted, in which case user will receive a generic error message. \n\n**Text commands**\n\nRouter can match text commands:\n\n```swift\nrouter["start"] = onStart\n```\n\nCommand name is processed differently in private and group chats:\n\n* In private chats slash is optional. `start` matches `/start` as well as `start`.\n* It group chats \'start\' only matches `/start`.\n\nThis can be overridden. The following line will require slash even in private chats:\n\n```swift\nrouter["start", .slashRequired] = onStart\n```\n\nRouter is case-insensitive by default. To make it case-sensitive, pass `.caseSensitive` option:\n\n```swift\nrouter["command", .caseSensitive] = handler\n```\n\nMultiple options can be passed:\n\n```swift\nrouter["command", [.slashRequired, .caseSensitive]] = handler\n```\n\nIn Telegram group chats, user can append bot name to a command, for example: `/greet@hello_bot`. Router takes care of removing the `@hello_bot` part from command name automatically.\n\n**Text commands with arguments**\n\nWords can be captured and then processed by using `scanWord` method.\n\n```swift\nrouter["two_words"] = { context in\n    let word1 = context.args.scanWord()\n    let word2 = context.args.scanWord()\n}\n```\n\nArray of words can be captured using `scanWords`:\n\n```swift\nrouter["words"] = { context in\n    let words = context.args.scanWords() // returns [String] array\n}\n```\n\nNumbers can be captured using `scanInt`, `scanInt64` and `scanDouble`. `restOfString` captures the remainder as a single string.\n\n```swift\nrouter["command"] = { context in\n    let value1 = context.args.scanInt()\n    let value2 = context.args.scanDouble()\n    let text = context.args.scanRestOfString()\n}\n```\n\nIt\'s also possible to directly access `NSScanner` used for scanning arguments: `context.args.scanner`.\n\nHandler is expected to read all the arguments, otherwise user will see a warning: _Part of your input was ignored: text_\n\nSo, for example, if there\'s a command `swap` which expects two arguments but user types: `/swap aaa bbb ccc`, he will see:\n\n```\nbbb aaa\nPart of your input was ignored: ccc\n```\n\nA possible way to avoid the warning is to skip unneeded arguments by calling `context.args.skipRestOfString()`.\n\nAlso, the warning can be overridden:\n\n```swift\nrouter.partialMatch = { context in\n    context.respondAsync("Part of your input was ignored: \\(context.args.scanRestOfString())")\n    return true\n}\n```\n\n**Other events**\n\nRouter can handle other event types as well. For example, when new user joins the chat, `.new_chat_member` path will be triggered:\n\n```swift\nrouter[.new_chat_member] = { context in\n    guard let users = context.message?.newChatMembers else { return false }\n    for user in users {\n        guard user.id != bot.user.id else { return false }\n        context.respondAsync("Welcome, \\(user.firstName)!")\n    }\n    return true\n}\n```\n\nCheck `TelegramBot/Router/ContentType.swift` file for a complete list of events supported by Router.\n\n**Handling unmatched paths**\n\nIf no paths were matched, router will call it\'s `unmatched` handler, which will print "Command not found" by default.\nThis can be overridden by setting an explicit handler:\n\n```swift\nrouter.unmatched = { context in\n    // Do something else with context.args\n    return true\n}\n```\n\n### Debugging notes\n\nIn debugger you may want to dump the contents of a json structure, but `debugDescription` loses it\'s formatting.\n\n`prettyPrint` helper function allows printing any `JsonConvertible` with indentation:\n\n```swift\nlet user: User\nuser.prettyPrint()\n\nbot.sendMessageSync(fromId, "Hello!")?.prettyPrint()\n```\n\n## Examples\n\nThere are 3 example projects available:\n\n* `Examples/hello-bot` - a trivial bot which responds to `/greet` command and greets users who join the chat.\n\n* `Examples/word-reverse-bot` - demonstrates how to handle start and stop requests, keep session state and parse command arguments. Behaves differently in private and group chats. Uses a router and a controller.\n\n* `Examples/shopster-bot` - maintains a shopping list using sqlite3 database. Allows creating shared shopping lists in group chats. [GRDB library](https://github.com/groue/GRDB.swift) is used for working with database.\n\nDetails on compiling and running the bots are available on Wiki: [Building and running the example projects](https://github.com/zmeyc/telegram-bot-swift/wiki).\n\n## Documentation\n\nAdditional documentation is available on [Telegram Bot Swift SDK Wiki](https://github.com/zmeyc/telegram-bot-swift/wiki).\n\nCheck `Examples/` for sample bot projects.\n\nThis SDK is a work in progress, expect the API to change very often.\n\n## Need help?\n\nPlease [submit an issue](https://github.com/zmeyc/telegram-bot-swift/issues) on Github.\n\nIf you miss a specific feature, please create an issue and it will be prioritized. Pull Requests are also welcome.\n\nTalk with other developers in our Telegram chat: [swiftsdkchat](https://telegram.me/swiftsdkchat).\n\nHappy coding!\n\n## License\n\nApache License Version 2.0 with Runtime Library Exception. Please see LICENSE.txt for more information.\n\n'