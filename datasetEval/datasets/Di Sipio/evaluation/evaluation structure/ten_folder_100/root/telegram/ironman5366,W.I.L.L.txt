b'# W.I.L.L 3.1\n\n# The W.I.L.L Project has been retired and development has stopped. Read more here: https://willbeddow.com/page/wheres-w-i-l-l\n\n## Welcome to W.I.L.L\nW.I.L.L is an open source personal assistant that aims to be free, easy to use, and expandable by the user.\nIt runs on a python based plugin framework accessible by a JSON API that let\'s you access it from a variety of different platforms.\nWe\'ve provided some platforms for you, but if you don\'t like any of those, you can easily create your own, or, if you want to change W.I.L.L, setup your own version\n\nDocs: http://will.readthedocs.io\n\n## Quickstart\n\n### Use a provided platform\n\n#### Signup\nBefore you can use W.I.L.L, you need to sign up.\nYou can sign up for free at https://willbeddow.com/signup\n\n#### Android\nW.I.L.L is now available as an android app, complete with voice commands and app hookins for services like spotify and netflix! Download it now from https://play.google.com/store/apps/details?id=com.willbeddow.will\n\n##### Telegram\nAll you have to do to use W.I.L.L on telegram is go @WillAssistantBot and click start!\n\n### Use the json api\nThe main W.I.L.L server, as well as the web app, is at https://willbeddow.com\nIt runs on a flask server that provides a JSON API\n\n### Quickstart\n#### Send a request with python\n```python\nimport requests\nimport json\n#Assume that the user has already signed up\nserver_url = "https://willbeddow.com"\npayload = dict(username="myusername", password="mypassword")\n#Start the session and generate a session token. This session token will endure until you go to /end_session or the server reboots\nresponse = requests.post(url="{0}/api/start_session".format(server_url), data=payload).json()\n#{"type": "success", "text": "Authentication successful", "data": {"session_id": "aaaa-bbbb-cccc-dddd"}\nsession_id = response["data"]["session_id"]\n#Submit a command\ncommand_data = dict(session_id=session_id, command="What is the meaning of life?")\nanswer = requests.post(url="{0}/api/command".format(server_url), data=command_data).json()\n#{"type": "success", "text", "42 (according to the book The Hitchhiker\'s Guide to the Galaxy, by Douglas Adams)", "data": {"command_id": "aaaa-bbbb-cccc-dddd_1", "command_response": "42 (according to the book The Hitchhiker\'s Guide to the Galaxy, by Douglas Adams)"}}\nprint answer["text"]\n#42 (according to the book The Hitchhiker\'s Guide to the Galaxy, by Douglas Adams)\n#End your session\nrequests.post(url="{0}/api/end_session".format(server_url), data={"session_id": session_id})\n```\n\n### API Docs:\nThe core of the JSON API is a response object. A response object looks like this:\n```json\n{"type": "success", "text": "Request successful!", "data": {}}\n```\nAs you can see, each response object has three objects.\n- Type\n    - The type of the response. This will be either `success`, `error`, or `response`\n    - `success` indicates that a request completed successfully\n    - `error` indicates that a request encountered an error\n    - `response`indicates that the request requires a response or a callback. The information for this will usually be in data\n-  Text\n    - The message to the user\n- Data\n    - A dictionary that contains any request specific data the user should interpret\n\nAPI Methods:\n- `/api/new_user`\n    - Requires the following parameters in the request\n    - `first_name`\n    - `last_name`\n    - `username`\n    - `password` (the password will laster be encrypted by bcrypt in the databsae)\n    - `email`\n    - `default_plugin` (It\'s usually best just to submit search for this)\n- `/api/start_session`\n    - Takes `username` and `password` and returns a `session_id` in `data`\n- `/api/command`\n    - Takes `session_id` and `command` and returns `command_response` in `data`\n- `/api/end_session`\n    Takes a `session_id` and ends it\n- `/api/get_updates`\n   - Takes a `session_id` and returns all pending updates and notifications\n- `/api/get_sessions`\n   - Takes a `username` and `password` and returns all active sessions\n- `/api/check_session`\n    - Takes a `session_id` and returns a boolean\n\n\n### Events framework\nW.I.L.L has a customizable events framework that allows you to pass events and notifications that will be asynchronously\npushed to the user. \nAt the moment W.I.L.L offers three classes of events, two of which endure between reboots of the server\n- `notification`\n    - A pending notification to the user. Unlike the rest of the notifications, as well as being available from \n    `/api/get_updates`, a notification is also pushed to the user in various ways, including email, telegram, and text.\n    Information about which of these the user has enabled is stored in a JSON array in the database\n    - Endures between server updates\n- `url`\n    - A url that will be opened, the contents of the page pushed to the updates for `/api/get_updates`\n    - Endures between server updates\n- `function`\n    - A function object that will be run, the result pushed to the updates for `/api/get_updates`\n    - Does not endure between server updates, as a python `func` object cannot be stored between runs\n\nAn event object is defined by 5 keys:\n- `type`\n    - The type of the event, `notification`, `url`, or `function`\n- `username`\n    - The username of the user who the event belongs to\n- `value`\n    - The data of the event. In a `notification` event it\'s the notification text, it\'s the url in a `url` event, \n    and the `func` object in a `function` event\n- `time`\n    - The time when the event should be run in Unix epoch time.\n    - Can be generated with the builtin `time` module like so:\n ```python\n    import time\n    #The current epoch time\n    current_time = time.time()\n    #Set the time for a minute\n    event_activation_time = current_time+60\n```\n- `uid`\n    - A modified `uuid` object providing a unique identifier for the event\n    - Generated with `tools.get_event_uid(type)` where `type` is the `type` key explained above\n'