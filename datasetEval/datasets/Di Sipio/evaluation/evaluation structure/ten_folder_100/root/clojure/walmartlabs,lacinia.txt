b'# Lacinia\n\n\n[![Clojars Project](https://img.shields.io/clojars/v/com.walmartlabs/lacinia.svg)](https://clojars.org/com.walmartlabs/lacinia)\n\n[![CircleCI](https://circleci.com/gh/walmartlabs/lacinia/tree/master.svg?style=svg)](https://circleci.com/gh/walmartlabs/lacinia/tree/master)\n\n[Lacinia Manual](http://lacinia.readthedocs.io/en/latest/) |\n[Lacinia Tutorial](http://lacinia.readthedocs.io/en/latest/tutorial) |\n[API Documentation](http://walmartlabs.github.io/apidocs/lacinia/)\n\nThis library is a full implementation of\nFacebook\'s [GraphQL specification](https://facebook.github.io/graphql).\n\nLacinia should be viewed as roughly analogous to the\n[official reference JavaScript implementation](https://github.com/graphql/graphql-js/).\nIn other words, it is a backend-agnostic GraphQL query execution engine.\nLacinia is not an Object Relational Mapper ... it\'s simply the implementation of a contract\nsitting between the GraphQL client and your data.\n\nLacinia features:\n\n- An [EDN](https://github.com/edn-format/edn)-based schema language.\n\n- High performance parser for GraphQL queries, built on [Antlr4](http://www.antlr.org/).\n\n- Efficient and asynchronous query execution.\n\n- Full support for GraphQL types, interfaces, unions, enums, input objects, and custom scalars.\n\n- Full support for GraphQL subscriptions.\n\n- Full support of inline and named query fragments.\n\n- Full support for GraphQL Schema Introspection.\n\nLacinia has been developed with a set of core philosophies:\n\n- Prefer data over macros and other tricks. Compose your schema in whatever mix of data and code works for you.\n\n- Embrace Clojure: Use EDN data, keywords, functions, and persistent data structures.\n\n- Keep it simple: You provide the schema and a handful of functions to resolve data, and Lacinia does the rest.\n\n- Do the right thing: apply reasonable defaults without a lot of "magic".\n\nThis library can be plugged into any Clojure HTTP pipeline.\nThe companion library [lacinia-pedestal](https://github.com/walmartlabs/lacinia-pedestal) provides\nfull HTTP support, including GraphQL subscriptions, for [Pedestal](https://github.com/pedestal/pedestal).\n\nAn externally developed library, [duct-lacinia](https://github.com/kakao/duct-lacinia), provides similar capability\nfor [Duct](https://github.com/duct-framework/duct).\n\n## Getting Started\n\nFor more detailed documentation, [read the manual](http://lacinia.readthedocs.io/en/latest/).\n\nGraphQL starts with a schema definition of exposed types.\n\nA schema starts as an EDN file; the example below demonstrates a small subset\nof the available options:\n\n```clojure\n{:enums\n {:episode\n  {:description "The episodes of the original Star Wars trilogy."\n   :values [:NEWHOPE :EMPIRE :JEDI]}}\n\n :objects\n {:droid\n  {:fields {:primary_functions {:type (list String)}\n            :id {:type Int}\n            :name {:type String}\n            :appears_in {:type (list :episode)}}}\n\n  :human\n  {:fields {:id {:type Int}\n            :name {:type String}\n            :home_planet {:type String}\n            :appears_in {:type (list :episode)}}}}\n\n :queries\n {:hero {:type (non-null :human)\n         :args {:episode {:type :episode}}\n         :resolve :get-hero}\n  :droid {:type :droid\n          :args {:id {:type String :default-value "2001"}}\n          :resolve :get-droid}}}\n```\n\n\nA schema alone describes what data is available to clients, but doesn\'t identify where\nthe data comes from; that\'s the job of a field resolver, provided by the\n:resolve key inside fields such as the :hero and :droid query.\n\nThe values here, :get-hero and :get-droid, are placeholders; the startup code\nof the application will use\n`com.walmartlabs.lacinia.util/attach-resolvers` to attach the actual\nfield resolver function.\n\nA field resolver is just a function which is passed the application context,\na map of arguments values, and a resolved value from a\nparent field.\nThe field resolver returns a value. If it\'s a scalar type, it should return a value\nthat conforms to the defined type in the schema.\nIf not, it\'s a type error.\n\nThe field resolver is totally responsible for obtaining the data from whatever\nexternal store you use: whether it is a database, a web service, or something\nelse.\n\nIt\'s important to understand that _every_ field has a field resolver, even if\nyou don\'t define it explicitly.  If you don\'t supply a field resolver,\nLacinia provides a default field resolver, customized to the field.\n\nHere\'s what the `get-hero` field resolver might look like:\n\n```clojure\n(defn get-hero [context arguments value]\n  (let [{:keys [episode]} arguments]\n    (if (= episode :NEWHOPE)\n      {:id 1000\n       :name "Luke"\n       :home_planet "Tatooine"\n       :appears_in ["NEWHOPE" "EMPIRE" "JEDI"]}\n      {:id 2000\n       :name "Lando Calrissian"\n       :home_planet "Socorro"\n       :appears_in ["EMPIRE" "JEDI"]})))\n```\n\nIn this greatly simplified example, the field resolver can simply return the resolved value.\nField resolvers that return multiple values return a list, vector, or set of values.\n\nIn real applications, a field resolver might execute a query against a database,\nor send a request to another web service.\n\nAfter attaching resolvers, it is necessary to compile the schema; this\nstep performs validations, provide defaults, and organizes the schema\nfor efficient execution of queries.\n\nThis needs only be done once, in application startup code:\n\n\n```clojure\n(require \'[clojure.edn :as edn]\n         \'[com.walmartlabs.lacinia.util :refer [attach-resolvers]]\n         \'[com.walmartlabs.lacinia.schema :as schema])\n\n(def star-wars-schema\n  (-> "schema.edn"\n      slurp\n      edn/read-string\n      (attach-resolvers {:get-hero get-hero\n                         :get-droid (constantly {})})\n      schema/compile))\n```\n\nWith the compiled application available, it can be used to execute\nrequests; this typically occurs inside a Ring handler function:\n\n```clojure\n(require \'[com.walmartlabs.lacinia :refer [execute]]\n         \'[clojure.data.json :as json])\n\n(defn handler [request]\n  {:status 200\n   :headers {"Content-Type" "application/json"}\n   :body (let [query (get-in request [:query-params :query])\n               result (execute star-wars-schema query nil nil)]\n           (json/write-str result)})\n```\n\nLacinia doesn\'t know about the web tier at all, it just knows about\nparsing and executing queries against a compiled schema.\nA companion library, [lacinia-pedestal](https://github.com/walmartlabs/lacinia-pedestal),\nis one way to expose your schema on the web.\n\nUser queries are provided as the body of a request with the content type `application/graphql`.\nThe GraphQL query language is designed to look familiar to someone who is versant in JSON.\n\n```\n{\n  hero {\n    id\n    name\n  }\n}\n```\n\n\nThe `execute` function returns EDN data that can be easily converted to JSON.\nThe :data key contains the value requested for the `hero` query in the request.\n\n```clojure\n{:data\n  {:hero {:id 2000\n          :name "Lando Calrissian"}}}\n```\n\nThis example request has no errors, and contained only a single query.\nGraphQL supports multiple queries in a single request.\nThere may be errors executing the query, Lacinia will process as much as\nit can, and will report errors in the :errors key.\n\nOne of the benefits of GraphQL is that the client has the power to rename\nfields in the response:\n\n```\n{\n  hero(episode: NEWHOPE) {\n    movies: appears_in\n  }\n}\n```\n\n```clojure\n{:data {:hero {:movies [:NEWHOPE :EMPIRE :JEDI]}}}\n```\n\nThis is just an overview, far more detail is available\nin [the manual](http://lacinia.readthedocs.io/en/latest/).\n\n## Status\n\nAlthough this library is used in production at Walmart, it is\nstill considered alpha software - subject to change.\nWe expect to stabilize it in the near future.\n\nTo use this library with Clojure 1.8, you must include \na dependency on [clojure-future-spec](https://github.com/tonsky/clojure-future-spec).\n\nMore details are [in the manual](http://lacinia.readthedocs.io/en/latest/clojure.html).\n\n## License\n\nCopyright \xc2\xa9 2017-2019 WalmartLabs\n\nDistributed under the Apache License, Version 2.0.\n\nPortions of the code are derived from\nthe [ordered](https://github.com/amalloy/ordered)\nand [useful](https://github.com/amalloy/useful) libraries, which are released under the terms\nof the [Eclipse Public License - v 1.0](LICENSE.ordered.txt).\n'