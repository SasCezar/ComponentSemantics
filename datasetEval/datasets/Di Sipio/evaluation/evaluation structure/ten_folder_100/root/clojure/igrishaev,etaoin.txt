b'[url-webdriver]: https://www.w3.org/TR/webdriver/\n[url-wiki]: https://en.wikipedia.org/wiki/Etaoin_shrdlu#Literature\n[url-tests]: https://github.com/igrishaev/etaoin/blob/master/test/etaoin/api_test.clj\n[url-doc]: http://grishaev.me/etaoin/\n[url-slack]: https://clojurians.slack.com/messages/C7KDM0EKW/\n\n# Etaoin\n\n[![CircleCI](https://circleci.com/gh/igrishaev/etaoin.svg?style=svg)](https://circleci.com/gh/igrishaev/etaoin)\n\nPure Clojure implementation of [Webdriver][url-webdriver] protocol. Use that\nlibrary to automate a browser, test your frontend behaviour, simulate human\nactions or whatever you want.\n\nIt\'s named after [Etaoin Shrdlu][url-wiki] -- a typing machine that became alive\nafter a mysteries note was produced on it.\n\n# Table of Contents\n\n<!-- toc -->\n\n- [Benefits](#benefits)\n- [Capabilities](#capabilities)\n- [Who uses it?](#who-uses-it)\n- [Documentation](#documentation)\n- [Installation](#installation)\n- [Getting stated](#getting-stated)\n- [Querying elements](#querying-elements)\n  * [Simple queries, XPath, CSS](#simple-queries-xpath-css)\n  * [Map syntax for querying](#map-syntax-for-querying)\n  * [Vector syntax for querying](#vector-syntax-for-querying)\n  * [Advanced queries](#advanced-queries)\n    + [Querying the *nth* element matched](#querying-the-nth-element-matched)\n  * [Interacting with queried elements](#interacting-with-queried-elements)\n- [Mouse clicks](#mouse-clicks)\n- [File uploading](#file-uploading)\n- [Screenshots](#screenshots)\n  * [Screening elements](#screening-elements)\n- [Using headless drivers](#using-headless-drivers)\n- [Devtools: tracking HTTP requests, XHR (Ajax)](#devtools-tracking-http-requests-xhr-ajax)\n- [Postmortem: auto-save artifacts in case of exception](#postmortem-auto-save-artifacts-in-case-of-exception)\n- [Reading browser\'s logs](#reading-browsers-logs)\n- [Additional parameters](#additional-parameters)\n- [Eager page load](#eager-page-load)\n- [Keyboard chords](#keyboard-chords)\n- [File download directory](#file-download-directory)\n- [Setting browser profile](#setting-browser-profile)\n  * [Create and find a profile in Chrome](#create-and-find-a-profile-in-chrome)\n  * [Create and find a profile in Firefox](#create-and-find-a-profile-in-firefox)\n  * [Running a driver with a profile](#running-a-driver-with-a-profile)\n- [Scrolling](#scrolling)\n- [Working with frames and iframes](#working-with-frames-and-iframes)\n- [Executing Javascript](#executing-javascript)\n  * [Asynchronous scripts](#asynchronous-scripts)\n- [Wait functions](#wait-functions)\n- [Writing Integration Tests For Your Application](#writing-integration-tests-for-your-application)\n  * [Basic fixture](#basic-fixture)\n  * [Multi-Driver Fixtures](#multi-driver-fixtures)\n  * [Postmortem Handler To Collect Artifacts](#postmortem-handler-to-collect-artifacts)\n  * [Running Tests By Tag](#running-tests-by-tag)\n  * [Check whether a file has been downloaded](#check-whether-a-file-has-been-downloaded)\n- [Installing Drivers](#installing-drivers)\n- [Troubleshooting](#troubleshooting)\n  * [Calling maximize function throws an error](#calling-maximize-function-throws-an-error)\n  * [Querying wrong elements with XPath expressions](#querying-wrong-elements-with-xpath-expressions)\n  * [Clicking On Non-Visible Element](#clicking-on-non-visible-element)\n  * [Unpredictable errors in Chrome when window is not active](#unpredictable-errors-in-chrome-when-window-is-not-active)\n- [Contributors](#contributors)\n- [Other materials](#other-materials)\n- [License](#license)\n\n<!-- tocstop -->\n\n## Benefits\n\n- Selenium-free: no long dependencies, no tons of downloaded jars, etc.\n- Lightweight, fast. Simple, easy to understand.\n- Compact: just one main module with a couple of helpers.\n- Declarative: the code is just a list of actions.\n\n## Capabilities\n\n- Currently supports Chrome, Firefox, Phantom.js and Safari (partially).\n- May either connect to a remote driver or run it on your local machine.\n- Run your unit tests directly from Emacs pressing `C-t t` as usual.\n- Can imitate human-like behaviour (delays, typos, etc).\n\n## Who uses it?\n\n- [Exoscale](https://www.exoscale.com/)\n- [Flyerbee](https://www.flyerbee.com/)\n- [Roomkey](https://www.roomkey.com/)\n- [Barrick Gold](http://www.barrick.com/)\n- [Doctor Evidence](http://drevidence.com/)\n- [Adzerk](https://adzerk.com/)\n\nYou are welcome to submit your company into that list.\n\n## Documentation\n\n- [API docs][url-doc]\n- [Slack channel][url-slack]\n- [Unit tests][url-tests]\n\n## Installation\n\nAdd the following into `:dependencies` vector in your `project.clj` file:\n\n```\n[etaoin "0.3.6"]\n```\n\nWorks with Clojure 1.7 and above.\n\n## Getting stated\n\nThe good news you may automate your browser directly from the REPL:\n\n```clojure\n(use \'etaoin.api)\n(require \'[etaoin.keys :as k])\n\n(def driver (firefox)) ;; here, a Firefox window should appear\n\n;; let\'s perform a quick Wiki session\n(go driver "https://en.wikipedia.org/")\n(wait-visible driver [{:id :simpleSearch} {:tag :input :name :search}])\n\n;; search for something\n(fill driver {:tag :input :name :search} "Clojure programming language")\n(fill driver {:tag :input :name :search} k/enter)\n(wait-visible driver {:class :mw-search-results})\n\n;; I\'m sure the first link is what I was looking for\n(click driver [{:class :mw-search-results} {:class :mw-search-result-heading} {:tag :a}])\n(wait-visible driver {:id :firstHeading})\n\n;; let\'s ensure\n(get-url driver) ;; "https://en.wikipedia.org/wiki/Clojure"\n\n(get-title driver) ;; "Clojure - Wikipedia"\n\n(has-text? driver "Clojure") ;; true\n\n;; navigate on history\n(back driver)\n(forward driver)\n(refresh driver)\n(get-title driver) ;; "Clojure - Wikipedia"\n\n;; stops Firefox and HTTP server\n(quit driver)\n```\n\nYou see, any function requires a driver instance as the first argument. So you\nmay simplify it using `doto` macros:\n\n```clojure\n(def driver (firefox))\n(doto driver\n  (go "https://en.wikipedia.org/")\n  (wait-visible [{:id :simpleSearch} {:tag :input :name :search}])\n  ;; ...\n  (fill {:tag :input :name :search} k/enter)\n  (wait-visible {:class :mw-search-results})\n  (click :some-button)\n  ;; ...\n  (wait-visible {:id :firstHeading})\n  ;; ...\n  (quit))\n```\n\nIn that case, your code looks like a DSL designed just for such purposes.\n\nIf any exception occurs during a browser session, the external process might\nhang forever until you kill it manually. To prevent it, use `with-<browser>`\nmacros as follows:\n\n```clojure\n(with-firefox {} ff ;; additional options first, then bind name\n  (doto ff\n    (go "https://google.com")\n    ...))\n```\n\nWhatever happens during a session, the process will be stopped anyway.\n\n## Querying elements\n\nMost of the functions like `click`, `fill`, etc require a query term to discover\nan element on a page. For example:\n\n```clojure\n(click driver {:tag :button})\n(fill driver {:id "searchInput"} "Clojure")\n```\n\n[xpath-sel]:https://www.w3schools.com/xml/xpath_syntax.asp\n[css-sel]:https://www.w3schools.com/cssref/css_selectors.asp\n\nThe library supports the following query types and values.\n\n### Simple queries, XPath, CSS\n\n- `:active` stands for the current active element. When opening Google page for\n  example, it focuses the cursor on the main search input. So there is no need\n  to click on in manually. Example:\n\n  ```clojure\n  (fill driver :active "Let\'s search for something" keys/enter)\n  ```\n\n- any other keyword that indicates an element\'s ID. For Google page, it is\n  `:lst-ib` or `"lst-ib"` (strings are also supported). The registry\n  matters. Example:\n\n  ```clojure\n  (fill driver :lst-ib "What is the Matrix?" keys/enter)\n  ```\n- a string with an [XPath][xpath-sel] expression. Be careful when writing them\n  manually. Check the `Troubleshooting` section below. Example:\n\n  ```clojure\n  (fill driver ".//input[@id=\'lst-ib\'][@name=\'q\']" "XPath in action!" keys/enter)\n  ```\n\n- a map with either `:xpath` or `:css` key with a string expression of\n  corresponding syntax. Example:\n\n  ```clojure\n  (fill driver {:xpath ".//input[@id=\'lst-ib\']"} "XPath selector" keys/enter)\n  (fill driver {:css "input#lst-ib[name=\'q\']"} "CSS selector" keys/enter)\n  ```\n\n  See the [CSS selector][css-sel] manual for more info.\n\n\n### Map syntax for querying\n\nA query might be any other map that represents an XPath expression as data. The\nrules are:\n\n- A `:tag` key represents a tag\'s name. It becomes `*` when not passed.\n- An `:index` key expands into the trailing `[x]` clause. Useful when you need\n  to select a third row from a table for example.\n- Any non-special key represents an attribute and its value.\n- A special key has `:fn/` namespace and expands into something specific.\n\nExamples:\n\n- find a form by its attributes:\n\n  ```clojure\n  (query driver {:tag :form :method :GET :class :message})\n  ;; expands into .//form[@method="GET"][@class="message"]\n  ```\n\n- find a button by its text (exact match):\n\n  ```clojure\n  (query driver {:tag :button :fn/text "Press Me"})\n  ;; .//button[text()="Press Me"]\n  ```\n\n- find an nth element (`p`, `a`, whatever) with "download" text:\n\n  ```clojure\n  (query driver {:fn/has-text "download" :index 3})\n  ;; .//*[contains(text(), "download")][3]\n  ```\n\n- find an element that has the following class:\n\n  ```clojure\n  (query driver {:tag :div :fn/has-class "overlay"})\n  ;; .//div[contains(@class, "overlay")]\n  ```\n\n- find an element that has the following classes at once:\n\n  ```clojure\n  (query driver {:fn/has-classes [:active :sticky :marked]})\n  ;; .//*[contains(@class, "active")][contains(@class, "sticky")][contains(@class, "marked")]\n  ```\n\n- find all the disabled input widgets:\n\n  ```clojure\n  (query driver {:tag :input :fn/disabled true})\n  ;; .//input[@disabled=true()]\n  ```\n\n### Vector syntax for querying\n\nA query might be a vector that consists from any expressions mentioned above. In\nsuch a query, every next term searches from a previous one recursively.\n\nA simple example:\n\n```clojure\n(click driver [{:tag :html} {:tag :body} {:tag :a}])\n```\n\nYou may combine both XPath and CSS expressions as well (pay attention at a\nleading dot in XPath expression:\n\n```clojure\n(click driver [{:tag :html} {:css "div.class"} ".//a[@class=\'download\']"])\n```\n\n### Advanced queries\n\n#### Querying the *nth* element matched\n\nSometimes you may need to interact with the *nth* element of a query, for\ninstance when wanting to click on the second link in this example:\n\n```html\n<ul>\n    <li class="search-result">\n        <a href="a">a</a>\n    </li>\n    <li class="search-result">\n        <a href="b">b</a>\n    </li>\n    <li class="search-result">\n        <a href="c">c</a>\n    </li>\n</ul>\n```\n\nIn this case you may either use the `:index` directive that is supported for\nXPath expressions like this:\n\n```clojure\n(click driver [{:tag :li :class :search-result :index 2} {:tag :a}])\n```\n\n[nth-child]: https://www.w3schools.com/CSSref/sel_nth-child.asp\n\nor you can use the [nth-child trick][nth-child] with the CSS expression like\nthis:\n\n```clojure\n(click driver {:css "li.search-result:nth-child(2) a"})\n```\n\nFinally it is also possible to obtain the *nth* element directly by using\n`query-all`:\n\n```clojure\n(click-el driver (nth (query-all driver {:css "li.search-result a"}) 2))\n```\n\nNote the use of `click-el` here, as `query-all` returns an element, not a\nselector that can be passed to `click` directly.\n\n### Interacting with queried elements\n\nTo interact with elements found via a query you have to pass the query result to\neither `click-el` or `fill-el`:\n\n```clojure\n(click-el driver (first (query-all driver {:tag :a})))\n```\n\nSo you may collect elements into a vector and arbitrarily interact with them\nat any time:\n\n```clojure\n(def elements (query-all driver {:tag :input :type :text})\n\n(fill-el driver (first elements) "This is a test")\n(fill-el driver (rand-nth elements) "I like tests!")\n```\n\n## Mouse clicks\n\nThe `click` function triggers the left mouse click on an element found by a\nquery term:\n\n```clojure\n(click driver {:tag :button})\n```\n\nThe `click` function uses only the first element found by the query, which\nsometimes leads to clicking on the wrong items. To ensure there is one and only\none element found, use the `click-single` function. It acts the same but raises\nan exception when querying the page returns multiple elements:\n\n```clojure\n(click-single driver {:tag :button :name "search"})\n```\n\nA double click is used rarely in web yet is possible with the `double-click`\nfunction (Chrome, Phantom.js):\n\n```clojure\n(double-click driver {:tag :dbl-click-btn})\n```\n\nThere is also a bunch of "blind" clicking functions. They trigger mouse clicks\non the current mouse position:\n\n```clojure\n(left-click driver)\n(middle-click driver)\n(right-click driver)\n```\n\nAnother bunch of functions do the same but move the mouse pointer to a specified\nelement before clicking on them:\n\n```clojure\n(left-click-on driver {:tag :img})\n(middle-click-on driver {:tag :img})\n(right-click-on driver {:tag :img})\n```\n\nA middle mouse click is useful when opening a link in a new background tab. The\nright click sometimes is used to imitate a context menu in web applications.\n\n\n## File uploading\n\nClicking on a file input button opens an OS-specific dialog that you are not\nallowed to interact with using WebDriver protocol. Use the `upload-file`\nfunction to attach a local file to a file input widget. The function takes a\nselector that points to a file input and either a full path as a string or a\nnative `java.io.File` instance. The file should exist or you\'ll get an exception\notherwise. Usage example:\n\n```clojure\n(def driver (chrome))\n\n;; open a web page that serves uploaded files\n(go driver "http://nervgh.github.io/pages/angular-file-upload/examples/simple/")\n\n;; bound selector to variable; you may also specify an id, class, etc\n(def input {:tag :input :type :file})\n\n;; upload an image with the first one file input\n(def my-file "/Users/ivan/Downloads/sample.png")\n(upload-file driver input my-file)\n\n;; or pass a native Java object:\n(require \'[clojure.java.io :as io])\n(def my-file (io/file "/Users/ivan/Downloads/sample.png"))\n(upload-file driver input my-file)\n```\n\n## Screenshots\n\nCalling a `screenshot` function dumps the current page into a PNG image on your\ndisk:\n\n```clojure\n(screenshot driver "page.png")             ;; relative path\n(screenshot driver "/Users/ivan/page.png") ;; absolute path\n```\n\nA native Java File object is also supported:\n\n```clojure\n;; when imported as `[clojure.java.io :as io]`\n(screenshot driver (io/file "test.png"))\n\n;; native object\n(screenshot driver (java.io.File. "test-native.png"))\n```\n\n### Screening elements\n\nWith Firefox and Chrome, you may capture not the whole page but a single element,\nsay a div, an input widget or whatever. It doesn\'t work with other browsers for\nnow. Example:\n\n```clojure\n(screenshot-element driver {:tag :div :class :smart-widget} "smart_widget.png")\n```\n\n## Using headless drivers\n\nRecently, Google Chrome and later Firefox started support a feature named\nheadless mode. When being headless, none of UI windows occur on the screen, only\nthe stdout output goes into console. This feature allows you to run integration\ntests on servers that do not have graphical output device.\n\nEnsure your browser supports headless mode by checking if it accepts `--headles`\ncommand line argument when running it from the terminal. Phantom.js driver is\nheadless by its nature (it has never been developed for rendering UI).\n\nWhen starting a driver, pass `:headless` boolean flag to switch into headless\nmode. Note, only latest version of Chrome and Firefox are supported. For other\ndrivers, the flag will be ignored.\n\n```clojure\n(def driver (chrome {:headless true})) ;; runs headless Chrome\n```\n\nor\n\n```clojure\n(def driver (firefox {:headless true})) ;; runs headless Firefox\n```\n\nTo check of any driver has been run in headless mode, use `headless?` predicate:\n\n```clojure\n(headless? driver) ;; true\n```\n\nNote, it will always return true for Phantom.js instances.\n\nThere are several shortcuts to run Chrome or Firefox in headless mode by\ndefault:\n\n```clojure\n(def driver (chrome-headless))\n\n;; or\n\n(def driver (firefox-headless {...})) ;; with extra settings\n\n;; or\n\n(with-chrome-headless nil driver\n  (go driver "http://example.com"))\n\n(with-firefox-headless {...} driver ;; extra settings\n  (go driver "http://example.com"))\n```\n\nThere are also `when-headless` and `when-not-headless` macroses that allow to\nperform a bunch of commands only if a browser is in headless mode or not\nrespectively:\n\n```clojure\n(with-chrome nil driver\n  ...\n  (when-not-headless driver\n    ... some actions that might be not available in headless mode)\n  ... common actions for both versions)\n```\n\n## Devtools: tracking HTTP requests, XHR (Ajax)\n\nWith recent updates, the library brings a great feature. Now you can trace\nevents which come from the DevTools panel. It means, everything you see in the\ndeveloper console now is available through API. That works only with Google\nChrome now.\n\nTo start a driver with special development settings specified, just pass an\nempty map to the `:dev` field when running a driver:\n\n```clojure\n(def c (chrome {:dev {}}))\n```\n\nThe value must not be `nil`. When it\'s an empty map, a special function takes\ndefaults. Here is a full version of dev settings with all the possible values\nspecified.\n\n```clojure\n(def c (chrome {:dev\n                {:perf\n                 {:level :all\n                  :network? true\n                  :page? true\n                  :interval 1000\n                  :categories [:devtools\n                               :devtools.network\n                               :devtools.timeline]}}}))\n```\n\nUnder the hood, it fills a special `perfLoggingPrefs` dictionary inside the\n`chromeOptions` object.\n\nNow that your browser accumulates these events, you can read them using a\nspecial `dev` namespace.\n\n```clojure\n(go c "http://google.com")\n;; wait until the page gets loaded\n\n;; load the namespace\n(require \'[etaoin.dev :as dev])\n```\n\nLet\'s have a list of ALL the HTTP requests happened during the page was loading.\n\n```clojure\n(def reqs (dev/get-requests c))\n\n;; reqs is a vector of maps\n(count reqs)\n;; 19\n\n;; what were their types?\n(set (map :type reqs))\n;; #{:script :other :document :image :xhr}\n;; we\'ve got Js requests, images, AJAX and other stuff\n```\n\n```clojure\n;; check the last one request, it\'s an image named tia.png\n(-> reqs last clojure.pprint/pprint)\n\n{:state 4,\n :id "1000052292.8",\n :type :image,\n :xhr? false,\n :url "https://www.gstatic.com/inputtools/images/tia.png",\n :with-data? nil,\n :request\n {:method :get,\n  :headers\n  {:Referer "https://www.google.com/",\n   :User-Agent\n   "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36"}},\n :response\n {:status 200,\n  :headers {}, ;; truncated\n  :mime "image/png",\n  :remote-ip "173.194.73.94"},\n :done? true}\n```\n\nSince we\'re mostly interested in AJAX requests, there is a function `get-ajax`\nthat does the same but filters XHR requests:\n\n```clojure\n(-> c dev/get-ajax last clojure.pprint/pprint)\n\n{:state 4,\n :id "1000051989.41",\n :type :xhr,\n :xhr? true,\n :url\n "https://www.google.com/complete/search?q=clojure%20spec&cp=12&client=psy-ab&xssi=t&gs_ri=gws-wiz&hl=ru&authuser=0&psi=4iUbXdapJsbmrgTVt7H4BA.1562060259137&ei=4iUbXdapJsbmrgTVt7H4BA",\n :with-data? nil,\n :request\n {:method :get,\n  :headers\n  {:Referer "https://www.google.com/",\n   :User-Agent\n   "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36"}},\n :response\n {:status 200,\n  :headers {}, ;; truncated\n  :mime "application/json",\n  :remote-ip "74.125.131.99"},\n :done? true}\n```\n\nA typical pattern of `get-ajax` usage is the following. You\'d like to check if a\ncertain request has been fired to the server. So you press a button, wait for a\nwhile and then read the requests made by your browser.\n\nHaving a list of requests, you search for the one you need (e.g. by its URL) and\nthen check its state. The `:state` field\'s got the same semantics like the\n`XMLHttpRequest.readyState` has. It\'s an integer from 1 to 4 with the same\nbehavior.\n\nTo check if a request has been finished, done or failed, use these predicates:\n\n```clojure\n(def req (last reqs))\n\n(dev/request-done? req)\n;; true\n\n(dev/request-failed? req)\n;; false\n\n(dev/request-success? req)\n;; true\n```\n\nNote that `request-done?` doesn\'t mean the request has succeeded. It only means\nits pipeline has reached a final step.\n\n**Warning:** when you read dev logs, you consume them from an internal buffer\nwhich gets flushed. The second call to `get-requests` or `get-ajax` will return\nan empty list.\n\nPerhaps you want to collect these logs by your own. A function\n`dev/get-performance-logs` return a list of logs so you accumulate them in an\natom or whatever:\n\n```clojure\n(def logs (atom []))\n\n;; repeat that form from time to time\n(do (swap! logs concat (dev/get-performance-logs c))\n    true)\n\n(count @logs)\n;; 76\n```\n\nThere are `logs->requests` and `logs->ajax` functions that convert logs into\nrequests. Unlike `get-requests` and `get-ajax`, they are pure functions and won\'t\nflush anything.\n\n```clojure\n(dev/logs->requests @logs)\n```\n\nWhen working with logs and requests, pay attention it their count and size. The\nmaps have got plenty of keys and the amount of items in collections might be\nhuge. Printing a whole bunch of events might freeze your editor. Consider using\n`clojure.pprint/pprint` function as it relies on max level and length limits.\n\n## Postmortem: auto-save artifacts in case of exception\n\nSometimes, it might be difficult to discover what went wrong during the last UI\ntests session. A special macro `with-postmortem` saves some useful data on disk\nbefore the exception was triggered. Those data are a screenshot, HTML code and\nJS console logs. Note: not all browsers support getting JS logs.\n\nExample:\n\n```clojure\n(def driver (chrome))\n(with-postmortem driver {:dir "/Users/ivan/artifacts"}\n  (click driver :non-existing-element))\n```\n\nAn exception will rise, but in `/Users/ivan/artifacts` there will be three files\nnamed by a template `<browser>-<host>-<port>-<datetime>.<ext>`:\n\n- `firefox-127.0.0.1-4444-2017-03-26-02-45-07.png`: an actual screenshot of the\n  browser\'s page;\n- `firefox-127.0.0.1-4444-2017-03-26-02-45-07.html`: the current browser\'s HTML\n  content;\n- `firefox-127.0.0.1-4444-2017-03-26-02-45-07.json`: a JSON file with console\n  logs; those are a vector of objects.\n\nThe handler takes a map of options with the following keys. All of them might be\nabsent.\n\n```clojure\n{;; default directory where to store artifacts; pwd is used when not passed\n :dir "/home/ivan/UI-tests"\n\n ;; a directory where to store screenshots; :dir is used when not passed\n :dir-img "/home/ivan/UI-tests/screenshots"\n\n ;; the same but for HTML sources\n :dir-src "/home/ivan/UI-tests/HTML"\n\n ;; the same but for console logs\n :dir-log "/home/ivan/UI-tests/console"\n\n ;; a string template to format a date; See SimpleDateFormat Java class\n :date-format "yyyy-MM-dd-HH-mm-ss"}\n```\n\n## Reading browser\'s logs\n\nFunction `(get-logs driver)` returns the browser\'s logs as a vector of\nmaps. Each map has the following structure:\n\n```clojure\n{:level :warning,\n :message "1,2,3,4  anonymous (:1)",\n :timestamp 1511449388366,\n :source nil,\n :datetime #inst "2017-11-23T15:03:08.366-00:00"}\n```\n\nCurrently, logs are available in Chrome and Phantom.js only. Please note, the\nmessage text and the source type highly depend on the browser. Chrome wipes the\nlogs once they have been read. Phantom.js keeps them but only until you change\nthe page.\n\n## Additional parameters\n\nWhen running a driver instance, a map of additional parameters might be passed\nto tweak the browser\'s behaviour:\n\n```clojure\n(def driver (chrome {:path "/path/to/driver/binary"}))\n```\n\nBelow, here is a map of parameters the library support. All of them might be\nskipped or have nil values. Some of them, if not passed, are taken from the\n`defaults` map.\n\n```clojure\n{;; Host and port for webdriver\'s process. Both are taken from defaults\n ;; when are not passed. If you pass a port that has been already taken,\n ;; the library will try to take a random one instead.\n :host "127.0.0.1"\n :port 9999\n\n ;; Path to webdriver\'s binary file. Taken from defaults when not passed.\n :path-driver "/Users/ivan/Downloads/geckodriver"\n\n ;; Path to the driver\'s binary file. When not passed, the driver discovers it\n ;; by its own.\n :path-browser "/Users/ivan/Downloads/firefox/firefox"\n\n ;; Extra command line arguments sent to the browser\'s process. See your browser\'s\n ;; supported flags.\n :args ["--incognito" "--app" "http://example.com"]\n\n ;; Extra command line arguments sent to the webdriver\'s process.\n :args-driver ["-b" "/path/to/firefox/binary"]\n\n ;; Sets browser\'s minimal logging level. Only messages with level above\n ;; that one will be collected. Useful for fetching Javascript logs. Possible\n ;; values are: nil (aliases :off, :none), :debug, :info, :warn (alias :warning),\n ;; :err (aliases :error, :severe, :crit, :critical), :all. When not passed,\n ;; :all is set.\n :log-level :err ;; to show only errors but not debug\n\n ;; Path to a custorm browser profile. See the section below.\n :profile "/Users/ivan/Library/Application Support/Firefox/Profiles/iy4iitbg.Test"\n\n ;; Env variables sent to the driver\'s process. Not processed yet.\n :env {:MOZ_CRASHREPORTER_URL "http://test.com"}\n\n ;; Initial window size.\n :size [1024 680]\n\n ;; Default URL to open. Works only in FF for now.\n :url "http://example.com"\n\n ;; Where to download files.\n :download-dir "/Users/ivan/Desktop"\n\n ;; Driver-specific options. Make sure you have read the docs before setting them.\n :capabilities {:chromeOptions {:args ["--headless"]}}}\n```\n\n## Eager page load\n\nWhen you navigate to a certain page, the driver waits until the whole page has\nbeen completely loaded. What\'s fine in most of the cases yet doesn\'t reflect the\nway human beings interact with the Internet.\n\nChange this default behavior with the `:load-strategy` option. There are three\npossible values for that: `:none`, `:eager` and `:normal` which is the default\nwhen not passed.\n\nWhen you pass `:none`, the driver responds immediately so you are welcome to\nexecute next instructions. For example:\n\n```clojure\n(def c (chrome))\n(go c "http://some.slow.site.com")\n;; you\'ll hang on this line until the page loads\n(do-something)\n```\n\nNow when passing the load strategy option:\n\n```clojure\n(def c (chrome {:load-strategy :none}))\n(go c "http://some.slow.site.com")\n;; no pause, acts immediately\n(do-something)\n```\n\nFor the `:eager` option, it works only with Firefox at the moment of adding the\nfeature to the library.\n\n\n## Keyboard chords\n\nThere is an option to input a series of keys simultaneously. That is useful to\nimitate holding a system key like Control, Shift or whatever when typing.\n\nThe namespace `etaoin.keys` carries a bunch of key constants as well as a set of\nfunctions related to input.\n\n```clojure\n(require \'[etaoin.keys :as keys])\n```\n\nA quick example of entering ordinary characters holding Shift:\n\n```clojure\n(def c (chrome))\n(go c "http://google.com")\n\n(fill-active c (keys/with-shift "caps is great"))\n```\n\nThe main input gets populated with "CAPS IS GREAT". Now you\'d like to delete the\nlast word. In Chrome, this is done by pressing backspace holding Alt. Let\'s do\nthat:\n\n```clojure\n(fill-active c (keys/with-alt keys/backspace))\n```\n\nNow you\'ve got only "CAPS IS " in the input.\n\nConsider a more complex example which repeats real users\' behaviour. You\'d like\nto delete everything from the input. First, you move the caret at the very\nbeginning. Then move it to the end holding shift so everything gets\nselected. Finally, you press delete to clear the selected text.\n\nThe combo is:\n\n```clojure\n(fill-active c keys/home (keys/with-shift keys/end) keys/delete)\n```\n\nThere are also `with-ctrl` and `with-command` functions that act the same.\n\nPay attention, these functions do not apply to the global browser\'s\nshortcuts. For example, neither "Command + R" nor "Command + T" reload the page\nor open a new tab.\n\nAll the `keys/with-*` functions are just wrappers upon the `keys/chord` function\nthat might be used for complex cases.\n\n\n## File download directory\n\nTo specify your own directory where to download files, pass `:download-dir`\nparameter into an option map when running a driver:\n\n```clojure\n(def driver (chrome {:download-dir "/Users/ivan/Desktop"}))\n```\n\nNow, once you click on a link, a file should be put into that folder. Currently,\nonly Chrome and Firefox are supported.\n\nFirefox requires to specify MIME-types of those files that should be downloaded\nwithout showing a system dialog. By default, when the `:download-dir` parameter\nis passed, the library adds the most common MIME-types: archives, media files,\noffice documents, etc. If you need to add your own one, override that preference\nmanually:\n\n```clojure\n(def driver (firefox {:download-dir "/Users/ivan/Desktop"\n                      :prefs {:browser.helperApps.neverAsk.saveToDisk\n                              "some-mime/type-1;other-mime/type-2"}}))\n```\n\nTo check whether a file was downloaded during UI tests, see the testing section\nbelow.\n\n## Setting browser profile\n\nWhen running Chrome or Firefox, you may specify a special profile made for test\npurposes. A profile is a folder that keeps browser settings, history, bookmarks\nand other user-specific data.\n\nImagine you\'d like to run your integration tests against a user that turned off\nJavascript execution or image rendering. To prepare a special profile for that\ntask would be a good choice.\n\n### Create and find a profile in Chrome\n\n1. In the right top corner of the main window, click on a user button.\n2. In the dropdown, select "Manage People".\n3. Click "Add person", submit a name and press "Save".\n4. The new browser window should appear. Now, setup the new profile as you want.\n5. Open `chrome://version/` page. Copy the file path that is beneath the\n   `Profile Path` caption.\n\n### Create and find a profile in Firefox\n\n[ff-profile]:https://support.mozilla.org/en-US/kb/profile-manager-create-and-remove-firefox-profiles\n\n1. Run Firefox with `-P`, `-p` or `-ProfileManager` key as the [official\n   page][ff-profile] describes.\n2. Create a new profile and run the browser.\n3. Setup the profile as you need.\n4. Open `about:support` page. Near the `Profile Folder` caption, press the `Show\n   in Finder` button. A new folder window should appear. Copy its path from\n   there.\n\n### Running a driver with a profile\n\nOnce you\'ve got a profile path, launch a driver with a special `:profile` key as\nfollows:\n\n```clojure\n;; Chrome\n(def chrome-profile\n  "/Users/ivan/Library/Application Support/Google/Chrome/Profile 2/Default")\n\n(def chrm (chrome {:profile chrome-profile}))\n\n;; Firefox\n(def ff-profile\n  "/Users/ivan/Library/Application Support/Firefox/Profiles/iy4iitbg.Test")\n\n(def ff (firefox {:profile ff-profile}))\n```\n\n## Scrolling\n\nThe library ships a set of functions to scroll the page.\n\nThe most important one, `scroll-query` jumps the the first element found with\nthe query term:\n\n```clojure\n(def driver (chrome))\n\n;; the form button placed somewhere below\n(scroll-query driver :button-submit)\n\n;; the main article\n(scroll-query driver {:tag :h1})\n```\n\nTo jump to the absolute position, just use `scroll` as follows:\n\n```clojure\n(scroll driver 100 600)\n\n;; or pass a map with x and y keys\n(scroll driver {:x 100 :y 600})\n```\n\nTo scroll relatively, use `scroll-by` with offset values:\n\n```clojure\n;; keeps the same horizontal position, goes up for 100 pixels\n(scroll-by driver 0 -100) ;; map parameter is also supported\n```\n\nThere are two shortcuts to jump top or bottom of the page:\n\n```clojure\n(scroll-bottom driver) ;; you\'ll see the footer...\n(scroll-top driver)    ;; ...and the header again\n```\n\nThe following functions scroll the page in all directions:\n\n```clojure\n(scroll-down driver 200)  ;; scrolls down by 200 pixels\n(scroll-down driver)      ;; scrolls down by the default (100) number of pixels\n\n(scroll-up driver 200)    ;; the same, but scrolls up...\n(scroll-up driver)\n\n(scroll-left driver 200)  ;; ...left\n(scroll-left driver)\n\n(scroll-right driver 200) ;; ... and right\n(scroll-right driver)\n```\n\nOne note, in all cases the scroll actions are served with Javascript. Ensure\nyour browser has it enabled.\n\n## Working with frames and iframes\n\nWhile working with the page, you cannot interact with those items that are put\ninto a frame or an iframe. The functions below switch the current context on\nspecific frame:\n\n```clojure\n(switch-frame driver :frameId) ;; now you are inside an iframe with id="frameId"\n(click driver :someButton)     ;; click on a button inside that iframe\n(switch-frame-top driver)      ;; switches on the top of the page again\n```\n\nFrames could be nested one into another. The functions take that into\naccount. Say you have an HTML layout like this:\n\n```html\n<iframe src="...">\n  <iframe src="...">\n    <button id="the-goal">\n  </frame>\n</frame>\n```\n\nSo you can reach the button with the following code:\n\n```clojure\n(switch-frame-first driver)  ;; switches to the first top-level iframe\n(switch-frame-first driver)  ;; the same for an iframe inside the previous one\n(click driver :the-goal)\n(switch-frame-parent driver) ;; you are in the first iframe now\n(switch-frame-parent driver) ;; you are at the top\n```\n\nTo reduce number of code lines, there is a special `with-frame` macro. It\ntemporary switches frames while executing the body returning its last expression\nand switching to the previous frame afterwards.\n\n```clojure\n(with-frame driver {:id :first-frame}\n  (with-frame driver {:id :nested-frame}\n    (click driver {:id :nested-button})\n    42))\n```\n\nThe code above returns `42` staying at the same frame that has been before\nbefore evaluating the macros.\n\n## Executing Javascript\n\nTo evaluate a Javascript code in a browser, run:\n\n```clojure\n(js-execute driver "alert(1)")\n```\n\nYou may pass any additional parameters into the call and cath them inside a\nscript with the `arguments` array-like object:\n\n```clojure\n(js-execute driver "alert(arguments[2].foo)" 1 false {:foo "hello!"})\n```\n\nAs the result, `hello!` string will appear inside the dialog.\n\nTo return any data into Clojure, just add `return` into your script:\n\n```clojure\n(js-execute driver "return {foo: arguments[2].foo, bar: [1, 2, 3]}"\n                   1 false {:foo "hello!"})\n;; {:bar [1 2 3], :foo "hello!"}\n```\n\n### Asynchronous scripts\n\nIf your script performs AJAX requests or operates on `setTimeout` or any other\nasync stuff, you cannot just `return` the result. Instead, a special callback\nshould be called against the data you\'d like to achieve. The webdriver passes\nthis callback as the last argument for your script and might be reached with the\n`arguments` array-like object.\n\nExample:\n\n```clojure\n(js-async\n  driver\n  "var args = arguments; // preserve the global args\n  var callback = args[args.length-1];\n  setTimeout(function() {\n    callback(args[0].foo.bar.baz);\n  },\n  1000);"\n  {:foo {:bar {:baz 42}}})\n```\n\nreturns `42` to the Clojure code.\n\nTo evaluate an asynchronous script, you need either to setup a special timeout\nfor that:\n\n```clojure\n(set-script-timeout driver 5) ;; in seconds\n```\n\nor wrap the code into a macros that does it temporary:\n\n```clojure\n(with-script-timeout driver 30\n  (js-async driver "some long script"))\n```\n\n## Wait functions\n\nThe main difference between a program and a human being is that the first one\noperates very fast. It means so fast, that sometimes a browser cannot render new\nHTML in time. So after each action you\'d better to put `wait-<something>`\nfunction that just polls a browser until the predicate evaluates into true. Or\njust `(wait <seconds>)` if you don\'t care about optimization.\n\nThe `with-wait` macro might be helpful when you need to prepend each action with\n`(wait n)`. For example, the following form\n\n```clojure\n(with-chrome {} driver\n  (with-wait 3\n    (go driver "http://site.com")\n    (click driver {:id "search_button"})))\n```\n\nturns into something like this:\n\n```clojure\n(with-chrome {} driver\n  (wait 3)\n  (go driver "http://site.com")\n  (wait 3)\n  (click driver {:id "search_button"}))\n```\n\nand thus returns the result of the last form of the original body.\n\nThere is another macro `(doto-wait n driver & body)` that acts like the standard\n`doto` but prepend each form with `(wait n)`. For example:\n\n```clojure\n(with-chrome {} driver\n  (doto-wait 1 driver\n    (go "http://site.com")\n    (click :this-link)\n    (click :that-button)\n    ...etc))\n```\n\nThe final form would be something like this:\n\n```clojure\n(with-chrome {} driver\n  (doto driver\n    (wait 1)\n    (go "http://site.com")\n    (wait 1)\n    (click :this-link)\n    (wait 1)\n    (click :that-button)\n    ...etc))\n```\n\n## Writing Integration Tests For Your Application\n\n### Basic fixture\n\nTo make your test not depend on each other, you need to wrap them into a fixture\nthat will create a new instance of a driver and shut it down properly at the end\nif each test.\n\nGood solution might be to have a global variable (unbound by default) that will\npoint to the target driver during the tests.\n\n```clojure\n(ns project.test.integration\n  "A module for integration tests"\n  (:require [clojure.test :refer :all]\n            [etaoin.api :refer :all]))\n\n(def ^:dynamic\n  "Current driver"\n  *driver*)\n\n(defn fixture-driver\n  "Executes a test running a driver. Bounds a driver\n   with the global *driver* variable."\n  [f]\n  (with-chrome {} driver\n    (binding [*driver* driver]\n      (f))))\n\n(use-fixtures\n  :each ;; start and stop driver for each test\n  fixture-driver)\n\n;; now declare your tests\n\n(deftest ^:integration\n  test-some-case\n  (doto *driver*\n    (go url-project)\n    (click :some-button)\n    (refresh)\n    ...\n    ))\n```\n\n### Multi-Driver Fixtures\n\nIn the example above, we examined a case when you run tests against a single\ntype of driver. However, you may want to test your site on multiple drivers,\nsay, Chrome and Firefox. In that case, your fixture may become a bit more\ncomplex:\n\n```clojure\n\n(def driver-type [:firefox :chrome])\n\n(defn fixture-drivers [f]\n  (doseq [type driver-types]\n    (with-driver type {} driver\n      (binding [*driver* driver]\n        (testing (format "Testing in %s browser" (name type))\n          (f))))))\n```\n\nNow, each test will be run twice in both Firefox and Chrome browsers. Please\nnote the test call is prepended with `testing` macro that puts driver name into\nthe report. Once you\'ve got an error, you\'ll easy find what driver failed the\ntests exactly.\n\n### Postmortem Handler To Collect Artifacts\n\nTo save some artifacts in case of exception, wrap the body of your test into\n`with-postmortem` handler as follows:\n\n```clojure\n(deftest test-user-login\n  (with-postmortem *driver* {:dir "/path/to/folder"}\n    (doto *driver*\n      (go "http://127.0.0.1:8080")\n      (click-visible :login)\n      ;; any other actions...\n      )))\n```\n\nNow that, if any exception occurs in that test, artifacts will be saved.\n\nTo not copy and paste the options map, declare it on the top of the module. If\nyou use Circle CI, it would be great to save the data into a special artifacts\ndirectory that might be downloaded as a zip file once the build has been\nfinished:\n\n```clojure\n(def pm-dir\n  (or (System/getenv "CIRCLE_ARTIFACTS") ;; you are on CI\n      "/some/local/path"))               ;; local machine\n\n(def pm-opt\n  {:dir pm-dir})\n```\n\nNow pass that map everywhere into PM handler:\n\n```clojure\n  ;; test declaration\n  (with-postmortem *driver* pm-opt\n    ;; test body goes here\n    )\n```\n\nOnce an error occurs, you will find a PNG image that represents your browser\npage at the moment of exception and HTML dump.\n\n### Running Tests By Tag\n\nSince UI tests may take lots of time to pass, it\'s definitely a good practice to\npass both server and UI tests independently from each other.\n\nFirst, add `^:integration` tag to all the tests that are run inder the browser\nlike follows:\n\n```clojure\n(deftest ^:integration\n  test-password-reset-pipeline\n  (doto *driver*\n    (go url-password-reset)\n    (click :reset-btn)\n    ...\n```\n\nThen, open your `project.clj` file and add test selectors:\n\n```clojure\n:test-selectors {:default (complement :integration)\n                 :integration :integration}\n```\n\nNow, once you launch `lein test` you will run all the tests except browser\nones. To run integration tests, launch `lein test :integration`.\n\nThe main difference between a program and a human is that the first one\noperates very fast. It means so fast, that sometimes a browser cannot render new\nHTML in time. So after each action you need to put `wait-<something>` function\nthat just polls a browser checking for a predicate. O just `(wait <seconds>)` if\nyou don\'t care about optimization.\n\n### Check whether a file has been downloaded\n\nSometimes, a file starts to download automatically once you clicked on a link or\njust visited some page. In tests, you need to ensure a file really has been\ndownloaded successfully. A common scenario would be:\n\n- provide a custom empty download folder when running a browser (see above).\n- Click on a link or perform any action needed to start file downloading.\n- Wait for some time; for small files, 5-10 seconds would be enough.\n- Using files API, scan that directory and try to find a new file. Check if it\n  matches a proper extension, name, creation date, etc.\n\nExample:\n\n```clojure\n;; Local helper that checks whether it is really an Excel file.\n(defn xlsx? [file]\n  (-> file\n      .getAbsolutePath\n      (str/ends-with? ".xlsx")))\n\n;; Top-level declarations\n(def DL-DIR "/Users/ivan/Desktop")\n(def driver (chrome {:download-dir DL-DIR}))\n\n;; Later, in tests...\n(click-visible driver :download-that-application)\n(wait driver 7) ;; wait for a file has been downloaded\n\n;; Now, scan the directory and try to find a file:\n(let [files (file-seq (io/file DL-DIR))\n      found (some xlsx? files)]\n  (is found (format "No *.xlsx file found in %s directory." DL-DIR)))\n```\n\n## Installing Drivers\n\n[url-webdriver]: https://www.w3.org/TR/webdriver/\n[url-tests]: https://github.com/igrishaev/etaoin/blob/master/test/etaoin/api_test.clj\n[url-chromedriver]: https://sites.google.com/a/chromium.org/chromedriver/\n[url-chromedriver-dl]: https://sites.google.com/a/chromium.org/chromedriver/downloads\n[url-geckodriver-dl]: https://github.com/mozilla/geckodriver/releases\n[url-phantom-dl]: http://phantomjs.org/download.html\n[url-webkit]: https://webkit.org/blog/6900/webdriver-support-in-safari-10/\n\nThis page provides instructions on how to install drivers you need to automate\nyour browser.\n\nInstall Chrome and Firefox browsers downloading them from the official\nsites. There won\'t be a problem on all the platforms.\n\nInstall specific drivers you need:\n\n- Google [Chrome driver][url-chromedriver]:\n\n  - `brew cask install chromedriver` for Mac users\n  - or download compiled binaries from the [official site][url-chromedriver-dl].\n  - ensure you have at least `2.28` version installed. `2.27` and below has a\n    bug related to maximizing a window (see [[Troubleshooting]]).\n\n- Geckodriver, a driver for Firefox:\n\n  - `brew install geckodriver` for Mac users\n  - or download it from the official [Mozilla site][url-geckodriver-dl].\n\n- Phantom.js browser:\n\n  - `brew install phantomjs` For Mac users\n  - or download it from the [official site][url-phantom-dl].\n\n- Safari Driver (for Mac only):\n\n  - update your Mac OS to El Captain using App Store;\n  - set up Safari options as the [Webkit page][url-webkit] says (scroll down to\n    "Running the Example in Safari" section).\n\nNow, check your installation launching any of these commands. For each command,\nan endless process with a local HTTP server should start.\n\n```bash\nchromedriver\ngeckodriver\nphantomjs --wd\nsafaridriver -p 0\n```\n\nYou may run tests for this library launching:\n\n```bash\nlein test\n```\n\nYou\'ll see browser windows open and close in series. The tests use a local HTML\nfile with a special layout to validate the most of the cases.\n\nThis page holds common troubles you might face during webdriver automation.\n\n## Troubleshooting\n\n### Calling maximize function throws an error\n\nExample:\n\n```clojure\netaoin.api> (def driver (chrome))\n#\'etaoin.api/driver\netaoin.api> (maximize driver)\nExceptionInfo throw+: {:response {\n:sessionId "2672b934de785aabb730fd19330cf40c",\n:status 13,\n:value {:message "unknown error: cannot get automation extension\\nfrom unknown error: page could not be found: chrome-extension://aapnijgdinlhnhlmodcfapnahmbfebeb/_generated_background_page.html\\n\n(Session info: chrome=57.0.2987.133)\\n  (Driver info: chromedriver=2.27.440174\n(e97a722caafc2d3a8b807ee115bfb307f7d2cfd9),platform=Mac OS X 10.11.6 x86_64)"}},\n...\n```\n\n**Solution:** just update your `chromedriver` to the last version. Tested with\n2.29, works fine. People say it woks as well since 2.28.\n\nRemember, `brew` package manager has the outdated version 2.27. You will\nprobably have to download binaries from the [official site][chromedriver-dl].\n\nSee the [related issue][maximize-issue] in Selenium project.\n\n[maximize-issue]:https://github.com/SeleniumHQ/selenium/issues/3508\n[chromedriver-dl]:https://sites.google.com/a/chromium.org/chromedriver/downloads\n\n### Querying wrong elements with XPath expressions\n\nWhen passing a vector-like query, say `[{:tag :p} "//*[text()=\'foo\')]]"}]` be\ncareful with hand-written XPath expressions. In vector, every its expression\nsearches from the previous one in a loop. There is a hidden mistake here:\nwithout a leading dot, the `"//..."` clause means to find an element from the\nroot of the whole page. With a dot, it means to find from the current node,\nwhich is one from the previous query, and so forth.\n\nThat\'s why, it\'s easy to select something completely different that what you\nwould like. A proper expression would be: `[{:tag :p} ".//*[text()=\'foo\')]]"}]`.\n\n### Clicking On Non-Visible Element\n\nExample:\n\n```clojure\netaoin.api> (click driver :some-id)\nExceptionInfo throw+: {:response {\n:sessionId "d112ce8ddb49accdae78a769d5809eae",\n:status 11,\n:value {:message "element not visible\\n  (Session info: chrome=57.0.2987.133)\\n\n(Driver info: chromedriver=2.29.461585\n(0be2cd95f834e9ee7c46bcc7cf405b483f5ae83b),platform=Mac OS X 10.11.6 x86_64)"}},\n...\n```\n\n**Solution:** you are trying to click an element that is not visible or its\ndimentions are as little as it\'s impossible for a human to click on it. You\nshould pass another selector.\n\n### Unpredictable errors in Chrome when window is not active\n\n**Problem:** when you focus on other window, webdriver session that is run under\nGoogle Chrome fails.\n\n**Solution:** Google Chrome may suspend a tab when it has been inactive for some\ntime. When the page is suspended, no operation could be done on it. No clicks,\nJs execution, etc. So try to keep Chrome window active during test session.\n\n## Contributors\n\n- [Ivan Grishaev](https://github.com/igrishaev)\n- [Adam Frey](https://github.com/AdamFrey)\n- [JW Koelewijn](https://github.com/jwkoelewijn)\n- [Miloslav Nenad\xc3\xa1l](https://github.com/nenadalm)\n- [Aleh Atsman](https://github.com/atsman)\n- [Marco Molteni](https://github.com/marco-m)\n- [Maxim Stasenkov](https://github.com/nebesnytihohod)\n\nThe project is open for your improvements and ideas. If any of unit tests fall\non your machine please submit an issue giving your OS version, browser and\nconsole output.\n\n## Other materials\n\n[ui-test]:http://grishaev.me/en/ui-test\n[stream]:https://www.youtube.com/watch?v=cLL_5rETLWY\n\n- [Thoughts on UI tests][ui-test]. My blog-post about some pitfalls that might\n  occur when testing UI.\n- [Live-coding session][stream] where I work on some of the Etaoin issues.\n\n## License\n\nCopyright \xc2\xa9 2017 Ivan Grishaev.\n\nDistributed under the Eclipse Public License either version 1.0 or (at your\noption) any later version.\n'