b'# bouncer [![Build Status](https://travis-ci.org/leonardoborges/bouncer.svg?branch=master)](https://travis-ci.org/leonardoborges/bouncer) <a href=\'https://ko-fi.com/H2H8OH34\' target=\'_blank\'><img height=\'36\' style=\'border:0px;height:36px;\' src=\'https://az743702.vo.msecnd.net/cdn/kofi2.png?v=0\' border=\'0\' alt=\'Buy Me a Coffee at ko-fi.com\' /></a>\n\nA validation DSL for Clojure & Clojurescript applications\n\n## Table of Contents\n\n* [Annotated Source](http://leonardoborges.github.com/bouncer/)\n* [Motivation](#motivation)\n* [Setup](#setup)\n* [Usage](#usage)\n    * [Basic validations](#basic-validations)\n    * [Validating nested maps](#validating-nested-maps)\n    * [Multiple validation errors](#multiple-validation-errors)\n    * [Validating collections](#validating-collections)\n    * [Validation threading](#validation-threading)\n    * [Pre-conditions](#pre-conditions)\n* [Validator sets](#validator-sets)\n* [Customization support](#customization-support)\n    * [Custom validators using arbitrary functions](#custom-validations-using-arbitrary-functions)\n    * [Writing validators](#writing-validators)\n        * [Validators and arbitrary number of arguments](#validators-and-arbitrary-number-of-arguments)\n\t* [Internationalization and customised error messages] (#internationalization-and-customised-error-messages)\n* [Built-in validators](#built-in-validations)\n* [Contributing](#contributing)\n* [TODO](#todo)\n* [CHANGELOG](https://github.com/leonardoborges/bouncer/blob/master/CHANGELOG.md)\n* [CONTRIBUTORS](https://github.com/leonardoborges/bouncer/graphs/contributors)\n* [License](#license)\n\n## Motivation\n\nCheck [this blog post](http://www.leonardoborges.com/writings/2013/01/04/bouncer-validation-lib-for-clojure/) where I explain in detail the motivation behind this library\n\n## Setup\n\nStable release:\n\n[![Clojars Project](http://clojars.org/bouncer/latest-version.svg)](http://clojars.org/bouncer)\n\nDevelopment release:\n\n```clojure\n[bouncer "1.0.1"]\n```\n\nCheck out the [CHANGELOG](https://github.com/leonardoborges/bouncer/blob/master/CHANGELOG.md) to see what\'s new.\n\n\nThen, require the library:\n\n```clojure\n(ns some.ns\n  (:require [bouncer.core :as b]\n            [bouncer.validators :as v]))\n```\n\n*bouncer* provides two main validation functions, `validate` and `valid?`\n\n`valid?` is a convenience function built on top of `validate`:\n\n```clojure\n(b/valid? {:name nil}\n    :name v/required)\n\n;; false\n```\n\n`validate` takes a map and one or more validation forms and returns a vector.\n\nThe first element in this vector contains a map of the error messages, whereas the second element contains the original map, augmented with the error messages.\n\nLet\'s look at a few examples:\n\n## Usage\n\n### Basic validations\n\nBelow is an example where we\'re validating that a given map has a value for both the keys `:name` and `:age`.\n\n\n```clojure\n(def person {:name "Leo"})\n\n(b/validate person\n    :name v/required\n    :age  v/required)\n\n;; [{:age ("age must be present")}\n;;  {:name "Leo", :bouncer.core/errors {:age ("age must be present")}}]\n```\n\nAs you can see, since age is missing, it\'s listed in the errors map with the appropriate error messages.\n\nError messages can be customized by providing a `:message` option - e.g: in case you need them internationalized:\n\n```clojure\n(b/validate person\n    :age [[v/required :message "Idade \xc3\xa9 um atributo obrigat\xc3\xb3rio"]])\n\n;; [{:age ("Idade \xc3\xa9 um atributo obrigat\xc3\xb3rio")}\n;;  {:name "Leo", :bouncer.core/errors {:age ("Idade \xc3\xa9 um atributo obrigat\xc3\xb3rio")}}]\n```\n\nNote the double vector:\n\n- the inner one wraps a single validation where the first element is the validating function and the rest are options for that validation.\n- the outer vector simply denotes a list of validations to be applied\n\nBelow is an example of date-time validation. A [clj-time formatter](https://github.com/clj-time/clj-time#clj-timeformat)\nmay optionally be supplied.\n\n```clojure\n(ns some.ns\n  (:require [bouncer.core :as b]\n            [bouncer.validators :as v]\n            [clj-time.format :as f])) ;; cljs-time for clojurescript users\n\n(def person {:name "Jeb" :last-login "2014-10-21 18:00:00"})\n\n(b/validate person\n    :name v/required\n    :last-login v/datetime (:mysql f/formatters))\n\n;; [nil {:name "Jeb" :last-login "2014-10-21 18:00:00"}]\n```\n\n### Validating nested maps\n\nNested maps can easily be validated as well, using the built-in validators:\n\n```clojure\n(def person-1\n    {:address\n        {:street nil\n         :country "Brazil"\n         :postcode "invalid"\n         :phone "foobar"}})\n\n(b/validate person-1\n    [:address :street]   v/required\n    [:address :postcode] v/number\n    [:address :phone]    [[v/matches #"^\\d+$"]])\n\n\n;;[{:address\n;;              {:phone ("phone must match the given regex pattern"),\n;;               :postcode ("postcode must be a number"),\n;;               :street ("street must be present")}}\n;;   {:bouncer.core/errors {:address {\n;;                          :phone ("phone must match the given regex pattern"),\n;;                          :postcode ("postcode must be a number"),\n;;                          :street ("street must be present")}},\n;;                          :address {:country "Brazil", :postcode "invalid", :street nil,\n;;                          :phone "foobar"}}]\n```\n\nIn the example above, the vector of keys is assumed to be the path in an associative structure.\n\n### Multiple validation errors\n\n`bouncer` features a short circuit mechanism for multiple validations within a single field.\n\nFor instance, say you\'re validating a map representing a person and you expect the key `:age` to be `required`, a `number` and also be `positive`:\n\n\n```clojure\n(b/validate {:age nil}\n    :age [v/required v/number v/positive])\n\n;; [{:age ("age must be present")} {:bouncer.core/errors {:age ("age must be present")}, :age nil}]\n```\n\nAs you can see, only the `required` validator was executed. That\'s what I meant by the short circuit mechanism. As soon as a validation fails, it exits and returns that error, skipping further validators.\n\nHowever, note this is true within a single map entry. Multiple map entries will have all its messages returned as expected:\n\n```clojure\n(b/validate person-1\n    [:address :street] v/required\n    [:address :postcode] [v/number v/positive])\n\n;; [{:address {:postcode ("postcode must be a number"), :street ("street must be present")}} {:bouncer.core/errors {:address {:postcode ("postcode must be a number"), :street ("street must be present")}}, :address {:country "Brazil", :postcode "invalid", :street nil, :phone "foobar"}}]\n```\n\nAlso note that if we need multiple validations against any keyword or path, we need only provide them inside a vector, like `[v/number v/positive]` above.\n\n### Validating collections\n\nSometimes it\'s useful to perform simple, ad-hoc checks in collections contained within a map. For that purpose, *bouncer* provides `every`.\n\nIts usage is similar to the validators seen so far. This time however, the value in the given key/path must be a collection (vector, list etc...)\n\nLet\'s see it in action:\n\n```clojure\n(def person-with-pets {:name "Leo"\n                       :pets [{:name nil}\n                              {:name "Gandalf"}]})\n\n(b/validate person-with-pets\n          :pets [[v/every #(not (nil? (:name %)))]])\n\n;;[{:pets ("All items in pets must satisfy the predicate")}\n;; {:name "Leo", :pets [{:name nil} {:name "Gandalf"}],\n;; :bouncer.core/errors {:pets ("All items in pets must satisfy the predicate")}}]\n```\n\nAll we need to do is provide a predicate function to `every`. It will be invoked for every item in the collection, making sure they all pass.\n\n### Validation threading\n\nNote that if a map is threaded through multiple validators, bouncer will leave it\'s errors map untouched and simply add new validation errors to it:\n\n```clojure\n(-> {:age "NaN"}\n    (b/validate :name v/required)\n    second\n    (b/validate :age v/number)\n    second\n    ::b/errors)\n\n;; {:age ("age must be a number"), :name ("name must be present")}\n```\n\n### Pre-conditions\n\nValidators can take a pre-condition option `:pre` that causes it to be executed only if the given pre-condition - a truthy function - is met.\n\nConsider the following:\n\n```clojure\n(b/valid? {:a -1 :b "X"}\n           :b [[v/member #{"Y" "Z"} :pre (comp pos? :a)]])\n\n;; true\n```\n\nAs you can see the value of `b` is clearly not in the set `#{"Y" "Z"}`, however the whole validation passes because the `v/member` check states is should only be run if `:a` is positive.\n\nLet\'s now make it fail:\n\n```clojure\n(b/valid? {:a 1 :b "X"}\n           :b [[v/member #{"Y" "Z"} :pre (comp pos? :a)]])\n\n;; false\n```\n\n## Validator sets\n\nIf you find yourself repeating a set of validators over and over, chances are you will want to group and compose them somehow. Validator sets are simply plain Clojure maps:\n\n\n```clojure\n\n;; first we define the set of validators we want to use\n(def address-validations\n  {:postcode [v/required v/number]\n   :street    v/required\n   :country   v/required})\n\n;;just something to validate\n(def person {:address {\n                :postcode ""\n                :country "Brazil"}})\n\n;;now we compose the validators\n(b/validate person\n            :name    v/required\n            :address address-validations)\n\n;;[{:address\n;;    {:postcode ("postcode must be a number" "postcode must be present"),\n;;     :street ("street must be present")},\n;;     :name ("name must be present")}\n;;\n;; {:bouncer.core/errors {:address {:postcode ("postcode must be a number" "postcode must be present"),\n;;  :street ("street must be present")}, :name ("name must be present")},\n;;  :address {:country "Brazil", :postcode ""}}]\n```\n\nYou can also compose validator sets together and use them as top level validations:\n\n\n```clojure\n(def address-validator\n  {:postcode v/required})\n\n(def person-validator\n  {:name v/required\n   :age [v/required v/number]\n   :address address-validator})\n\n(b/validate {}\n\t\t\tperson-validator)\n\n;;[{:address {:postcode ("postcode must be present")}, :age ("age must be present"), :name ("name must be present")} {:bouncer.core/errors {:address {:postcode ("postcode must be present")}, :age ("age must be present"), :name ("name must be present")}}]\n```\n\n## Customization Support\n\n### Custom validations using plain functions\n\nUsing your own functions as validators is simple:\n\n```clojure\n(defn young? [age]\n    (< age 25))\n\n(b/validate {:age 29}\n            :age [[young? :message "Too old!"]])\n\n;; [{:age ("Too old!")}\n;;  {:bouncer.core/errors {:age ("Too old!")}, :age 29}]\n```\n\n### Writing validators\n\nAs shown above, validators as just functions. The downside is that by using a function bouncer will default to a validation message that might not make sense in a given scenario:\n\n```clojure\n(b/validate {:age 29}\n               :age young?)\n\n;; [{:age ("Custom validation failed for age")}\n;; {:bouncer.core/errors {:age ("Custom validation failed for age")}, :age 29}]\n```\n\nYou could of course use the message keyword as in previous examples but if you reuse the validation in several places, you\'d need a lot of copying and pasting.\n\nAnother way - and the preferred one - to provide custom validations is to use the macro `defvalidator` in the `bouncer.validators` namespace.\n\nThe advantage of this approach is that it attaches the needed metadata for bouncer to know which message to use.\n\nAs an example, here\'s a simplified version of the `bouncer.validators/number` validator:\n\n```clojure\n(use \'[bouncer.validators :only [defvalidator]])\n\n(defvalidator my-number-validator\n  {:default-message-format "%s must be a number"}\n  [maybe-a-number]\n  (number? maybe-a-number))\n```\n\n`defvalidator` takes your validator name, an optional map of options and the body of your predicate function.\n\nOptions is a map of key/value pairs where:\n\n- `:default-message-format` - to be used when clients of this validator don\'t provide one\n- `:optional` - a boolean indicating if this validator should only trigger for keys that have a value different than `nil`. Defaults to true.\n\nThat\'s all syntactic sugar for:\n\n```clojure\n(def my-number-validator\n  (with-meta (fn my-number-validator\n               ([maybe-a-number]\n                  (number? maybe-a-number)))\n    {:default-message-format "%s must be a number", :optional false}))\n```\n\nUsing it is then straightforward:\n\n```clojure\n(b/validate {:postcode "NaN"}\n          :postcode my-number-validator)\n\n\n;; [{:postcode ("postcode must be a number")}\n;;  {:bouncer.core/errors {:postcode ("postcode must be a number")}, :postcode "NaN"}]\n```\n\nAs you\'d expect, the message can be customized as well:\n\n```clojure\n(b/validate {:postcode "NaN"}\n          :postcode [[my-number-validator :message "must be a number"]])\n```\n\n### Validators and arbitrary number of arguments\n\nYour validators aren\'t limited to a single argument though.\n\nSince *v0.2.2*, `defvalidator` takes an arbitrary number of arguments. The only thing you need to be aware of is that the value being validated will **always** be the first argument you list - this applies if you\'re using plain functions too. Let\'s see an example with the `member` validator:\n\n```clojure\n(defvalidator member\n  [value coll]\n  (some #{value} coll))\n```\n\nYup, it\'s that *simple*. Let\'s use it:\n\n```clojure\n(def kid {:age 10})\n\n(b/validate kid\n            :age [[member (range 5)]])\n```\n\nIn the example above, the validator will be called with `10` - that\'s the value the key `:age` holds - and `(0 1 2 3 4)` - which is the result of `(range 5)` and will be fed as the second argument to the validator.\n\n### Internationalization and customised error messages\n\nIn some cases the default behaviour might not be enough.\n\nPerhaps you\'d like to customise your error messages with the value that has been provided.\n\nOr maybe you need access to the options that were given to a specific validator.\n\nAnd what if you need to know which validator generated a specific error message?\n\nSince *0.3.1-beta1*, this is possible. `validate` takes as an optional first argument a function - called a *message-fn* - that is applied to a map containing validation metadata that allows you to customise error messages in any way you like - or even return other data structures instead.\n\nThis map has the following keys:\n\n- :path - where in the map has the error ocurred?\n- :value - what was the value at the time of the validation?\n- :args - which arguments - if any - were passed to the validator?\n- :metadata - what is the metadata associated with this validation?\n- :message - what - if any - is the message passed to this validator instance?\n\nLet\'s see how this works in practice. For the first example, we\'ll simply use `identity` as our *message-fn*:\n\n```clojure\n(def person {:name "Leo" :age "NaN"})\n\n(b/validate identity\n            person\n            :name v/required\n            :age  v/number)\n```\n\nAs you can see we simply supply `identity` as the first argument. This is what gets returned:\n\n```clojure\n[{:age\n  ({:path [:age],\n    :value "NaN",\n    :args nil,\n    :metadata\n    {:optional true,\n     :default-message-format "%s must be a number",\n     :validator :bouncer.validators/number},\n    :message nil})}\n {:age "NaN",\n  :name "Leo",\n  :bouncer.core/errors\n  {:age\n   ({:path [:age],\n     :value "NaN",\n     :args nil,\n     :metadata\n     {:optional true,\n      :default-message-format "%s must be a number",\n      :validator :bouncer.validators/number},\n     :message nil})}}]\n```\n\nContrast this with what the function would have returned by default:\n\n```clojure\n[{:age ("age must be a number")}\n {:age "NaN",\n  :name "Leo",\n  :bouncer.core/errors {:age ("age must be a number")}}]\n```\n\nThis opens a number of possibilities around customising errors messages. Let\'s create a simple *message-fn* to illustrate:\n\n```clojure\n(defn custom-message-fn [{:keys [path value metadata]}]\n  (format "\'%s\' in field %s should be a %s" value path (:validator metadata)))\n\n(b/validate custom-message-fn\n            person\n            :name v/required\n            :age  v/number)\n```\n\nThis time we get a much more informative message:\n\n```clojure\n[{:age ("\'NaN\' in field [:age] should be a :bouncer.validators/number")}\n {:age "NaN",\n  :name "Leo",\n  :bouncer.core/errors\n  {:age\n   ("NaN in field [:age] should be a :bouncer.validators/number")}}]\n```\n\nHats off to [@dm3](https://github.com/dm3) for this pull request.\n\n\n## Built-in validations\n\nI didn\'t spend a whole lot of time on *bouncer* so it only ships with the validations I\'ve needed myself. At the moment they live in the validators namespace:\n\n- `bouncer.validators/required`\n\n- `bouncer.validators/number`\n\n- `bouncer.validators/integer`\n\n- `bouncer.validators/string`\n\n- `bouncer.validators/boolean`\n\n- `bouncer.validators/email`\n\n- `bouncer.validators/positive`\n\n- `bouncer.validators/in-range`\n\n- `bouncer.validators/member`\n\n- `bouncer.validators/max-count`\n\n- `bouncer.validators/min-count`\n\n- `bouncer.validators/matches` (for matching regular expressions)\n\n- `bouncer.validators/every` (for ad-hoc validation of collections. All items must match the provided predicate)\n\n- `bouncer.validators/datetime` (uses [clj-time formatters](https://github.com/clj-time/clj-time#clj-timeformat))\n\n## Contributing\n\nPull requests of bug fixes and new validators are most welcome.\n\nNote that if you wish your validator to be merged and considered *built-in* you must implement it using the macro `defvalidator` shown above.\n\nFeedback to both this library and this guide is welcome.\n\n### Running the tests\n\nBouncer is assumed to work with Clojure 1.4 and up, as well as ClojureScript.\n\nThere is a leiningen alias that makes it easy to run the tests against multiple Clojure versions:\n\n```bash\n\xce\xbb lein all-tests\n```\n\nIt\'ll run all tests against Clojure 1.4, 1.5 and 1.6, as well as Clojurescript - make sure all tests pass before submitting a pull request.\n\n## TODO\n\n- Add more validators (help is appreciated here)\n- Docs are getting a bit messy. Fix that.\n\n## License\n\nCopyright \xc2\xa9 2012-2019 [Leonardo Borges](http://www.leonardoborges.com)\n\nDistributed under the [MIT License](http://opensource.org/licenses/MIT).\n'