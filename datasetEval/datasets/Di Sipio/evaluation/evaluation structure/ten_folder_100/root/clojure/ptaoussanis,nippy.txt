b'<a href="https://www.taoensso.com" title="More stuff by @ptaoussanis at www.taoensso.com">\n<img src="https://www.taoensso.com/taoensso-open-source.png" alt="Taoensso open-source" width="400"/></a>\n\n**[CHANGELOG]** | [API] | current [Break Version]:\n\n```clojure\n[com.taoensso/nippy "2.14.0"]     ; Stable\n[com.taoensso/nippy "2.15.0-RC1"] ; Dev, see CHANGELOG for details\n```\n\n> Please consider helping to [support my continued open-source Clojure/Script work]? \n> \n> Even small contributions can add up + make a big difference to help sustain my time writing, maintaining, and supporting Nippy and other Clojure/Script libraries. **Thank you!**\n>\n> \\- Peter Taoussanis\n\n# Nippy\n\n## The fastest serialization library for Clojure\n\nClojure\'s [rich data types] are *awesome*. And its [reader] allows you to take your data just about anywhere. But the reader can be painfully slow when you\'ve got a lot of data to crunch (like when you\'re serializing to a database).\n\nNippy is an attempt to provide a reliable, high-performance **drop-in alternative to the reader**. Used by the [Carmine Redis client], the [Faraday DynamoDB client], [PigPen], [Onyx] and others.\n\n## Features\n * Small, uncomplicated **all-Clojure** library\n * **Terrific performance** (the fastest for Clojure that I\'m aware of)\n * Comprehesive **support for all standard data types**\n * **Easily extendable to custom data types** (v2.1+)\n * Java\'s **Serializable** fallback when available (v2.5+)\n * **Reader-fallback** for all other types (including Clojure 1.4+ tagged literals)\n * **Full test coverage** for every supported type\n * Fully pluggable **compression**, including built-in high-performance [LZ4] compressor\n * Fully pluggable **encryption**, including built-in high-strength AES128 enabled with a single `:password [:salted "my-password"]` option (v2+)\n * Utils for **easy integration into 3rd-party tools/libraries** (v2+)\n\n## Getting started\n\nAdd the necessary dependency to your project:\n\n```clojure\n[com.taoensso/nippy "2.14.0"]\n```\n\nAnd setup your namespace imports:\n\n```clojure\n(ns my-ns (:require [taoensso.nippy :as nippy]))\n```\n\n### De/serializing\n\nAs an example of what it can do, let\'s take a look at Nippy\'s own reference stress data:\n\n```clojure\nnippy/stress-data\n=>\n{:bytes     (byte-array [(byte 1) (byte 2) (byte 3)])\n :nil       nil\n :true      true\n :false     false\n :char      \\\xe0\xb2\xac\n :str-short "\xe0\xb2\xac\xe0\xb2\xbe \xe0\xb2\x87\xe0\xb2\xb2\xe0\xb3\x8d\xe0\xb2\xb2\xe0\xb2\xbf \xe0\xb2\xb8\xe0\xb2\x82\xe0\xb2\xad\xe0\xb2\xb5\xe0\xb2\xbf\xe0\xb2\xb8"\n :str-long  (apply str (range 1000))\n :kw        :keyword\n :kw-ns     ::keyword\n :sym       \'foo\n :sym-ns    \'foo/bar\n :regex     #"^(https?:)?//(www\\?|\\?)?"\n\n :queue        (-> (PersistentQueue/EMPTY) (conj :a :b :c :d :e :f :g))\n :queue-empty  (PersistentQueue/EMPTY)\n :queue-empty  (enc/queue)\n :sorted-set   (sorted-set 1 2 3 4 5)\n :sorted-map   (sorted-map :b 2 :a 1 :d 4 :c 3)\n\n :list         (list 1 2 3 4 5 (list 6 7 8 (list 9 10)))\n :list-quoted  \'(1 2 3 4 5 (6 7 8 (9 10)))\n :list-empty   (list)\n :vector       [1 2 3 4 5 [6 7 8 [9 10]]]\n :vector-empty []\n :map          {:a 1 :b 2 :c 3 :d {:e 4 :f {:g 5 :h 6 :i 7}}}\n :map-empty    {}\n :set          #{1 2 3 4 5 #{6 7 8 #{9 10}}}\n :set-empty    #{}\n :meta         (with-meta {:a :A} {:metakey :metaval})\n :nested       [#{{1 [:a :b] 2 [:c :d] 3 [:e :f]} [] #{:a :b}}\n                #{{1 [:a :b] 2 [:c :d] 3 [:e :f]} [] #{:a :b}}\n                [1 [1 2 [1 2 3 [1 2 3 4 [1 2 3 4 5]]]]]]\n\n :lazy-seq       (repeatedly 1000 rand)\n :lazy-seq-empty (map identity \'())\n\n :byte         (byte 16)\n :short        (short 42)\n :integer      (int 3)\n :long         (long 3)\n :bigint       (bigint 31415926535897932384626433832795)\n\n :float        (float 3.14)\n :double       (double 3.14)\n :bigdec       (bigdec 3.1415926535897932384626433832795)\n\n :ratio        22/7\n :uuid         (java.util.UUID/randomUUID)\n :date         (java.util.Date.)\n\n :stress-record (StressRecord. "data")\n\n ;; Serializable\n :throwable    (Throwable. "Yolo")\n :exception    (try (/ 1 0) (catch Exception e e))\n :ex-info      (ex-info "ExInfo" {:data "data"})}\n```\n\nSerialize it:\n\n```clojure\n(def frozen-stress-data (nippy/freeze nippy/stress-data))\n=> #<byte[] [B@3253bcf3>\n```\n\nDeserialize it:\n\n```clojure\n(nippy/thaw frozen-stress-data)\n=> {:bytes        (byte-array [(byte 1) (byte 2) (byte 3)])\n    :nil          nil\n    :boolean      true\n    <...> }\n```\n\nCouldn\'t be simpler!\n\nSee also the lower-level `freeze-to-out!` and `thaw-from-in!` fns for operating on `DataOutput` and `DataInput` types directly. \n\n### Encryption (v2+)\n\nNippy also gives you **dead simple data encryption**. Add a single option to your usual freeze/thaw calls like so:\n\n```clojure\n(nippy/freeze nippy/stress-data {:password [:salted "my-password"]}) ; Encrypt\n(nippy/thaw   <encrypted-data>  {:password [:salted "my-password"]}) ; Decrypt\n```\n\nThere\'s two default forms of encryption on offer: `:salted` and `:cached`. Each of these makes carefully-chosen trade-offs and is suited to one of two common use cases. See the `aes128-encryptor` [API] docs for a detailed explanation of why/when you\'d want one or the other.\n\n### Custom types (v2.1+)\n\n```clojure\n(defrecord MyType [data])\n\n(nippy/extend-freeze MyType :my-type/foo ; A unique (namespaced) type identifier\n  [x data-output]\n  (.writeUTF data-output (:data x)))\n\n(nippy/extend-thaw :my-type/foo ; Same type id\n  [data-input]\n  (MyType. (.readUTF data-input)))\n\n(nippy/thaw (nippy/freeze (MyType. "Joe"))) => #taoensso.nippy.MyType{:data "Joe"}\n```\n\n## Performance\n\nNippy is currently the **fastest serialization library for Clojure** that I\'m aware of, and offers roundtrip times between **~10x and ~15x** faster than Clojure\'s `tools.reader.edn`, with a **~40% smaller output size**.\n\n![benchmarks-png]\n\n[Detailed benchmark info] is available on Google Docs.\n\n## Contacting me / contributions\n\nPlease use the project\'s [GitHub issues page] for all questions, ideas, etc. **Pull requests welcome**. See the project\'s [GitHub contributors page] for a list of contributors.\n\nOtherwise, you can reach me at [Taoensso.com]. Happy hacking!\n\n\\- [Peter Taoussanis]\n\n## License\n\nDistributed under the [EPL v1.0] \\(same as Clojure).  \nCopyright &copy; 2012-2016 [Peter Taoussanis].\n\n<!--- Standard links -->\n[Taoensso.com]: https://www.taoensso.com\n[Peter Taoussanis]: https://www.taoensso.com\n[@ptaoussanis]: https://www.taoensso.com\n[More by @ptaoussanis]: https://www.taoensso.com\n[Break Version]: https://github.com/ptaoussanis/encore/blob/master/BREAK-VERSIONING.md\n[support my continued open-source Clojure/Script work]: http://taoensso.com/clojure/backers\n\n<!--- Standard links (repo specific) -->\n[CHANGELOG]: https://github.com/ptaoussanis/nippy/releases\n[API]: http://ptaoussanis.github.io/nippy/\n[GitHub issues page]: https://github.com/ptaoussanis/nippy/issues\n[GitHub contributors page]: https://github.com/ptaoussanis/nippy/graphs/contributors\n[EPL v1.0]: https://raw.githubusercontent.com/ptaoussanis/nippy/master/LICENSE\n[Hero]: https://raw.githubusercontent.com/ptaoussanis/nippy/master/hero.png "Title"\n\n<!--- Unique links -->\n[rich data types]: http://clojure.org/reference/datatypes\n[reader]: http://clojure.org/reference/reader\n[Carmine Redis client]: https://github.com/ptaoussanis/carmine\n[Faraday DynamoDB client]: https://github.com/ptaoussanis/faraday\n[PigPen]: https://github.com/Netflix/PigPen\n[Onyx]: https://github.com/onyx-platform/onyx\n[LZ4]: https://code.google.com/p/lz4/\n[benchmarks-png]: https://github.com/ptaoussanis/nippy/raw/master/benchmarks.png\n[Detailed benchmark info]: https://docs.google.com/spreadsheet/ccc?key=0AuSXb68FH4uhdE5kTTlocGZKSXppWG9sRzA5Y2pMVkE\n'