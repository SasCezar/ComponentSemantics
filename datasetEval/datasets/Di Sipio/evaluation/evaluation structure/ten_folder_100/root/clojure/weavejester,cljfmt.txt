b'# cljfmt\n\n[![Build Status](https://travis-ci.org/weavejester/cljfmt.svg?branch=master)](https://travis-ci.org/weavejester/cljfmt)\n\ncljfmt is a tool for formatting Clojure code [idiomatically][].\n\nIt can turn something like this:\n\n```clojure\n( let [x 3\n    y 4]\n  (+ (* x x\n  )(* y y)\n  ))\n```\n\nInto nicely formatted Clojure code like this:\n\n```clojure\n(let [x 3\n      y 4]\n  (+ (* x x) (* y y)))\n```\n\nHowever, it is not the goal of cljfmt to provide a canonical format.\n\n[idiomatically]: https://github.com/bbatsov/clojure-style-guide\n\n## Installation\n\nThe easiest way to get started with cljfmt is to add the lein-cljfmt\nplugin to your [Leiningen][] project map:\n\n```clojure\n:plugins [[lein-cljfmt "0.6.6"]]\n```\n\ncljfmt has tested on Leiningen 2.5, but may not work on older\nversions, particularly versions prior to Leiningen 2.4.\n\n[leiningen]: https://github.com/technomancy/leiningen\n\n## Usage\n\nTo check the formatting of your source files, use:\n\n    lein cljfmt check\n\nIf the formatting of any source file is incorrect, a diff will be\nsupplied showing the problem, and what cljfmt thinks it should be.\n\nIf you want to check only a specific file, or several specific files,\nyou can do that, too:\n\n    lein cljfmt check src/foo/core.clj\n\nOnce you\'ve identified formatting issues, you can choose to ignore\nthem, fix them manually, or let cljfmt fix them with:\n\n    lein cljfmt fix\n\nAs with the `check` task, you can choose to fix a specific file:\n\n    lein cljfmt fix src/foo/core.clj\n\n## Editor Support\n\n* [vim-cljfmt](https://github.com/venantius/vim-cljfmt)\n* [CIDER 0.9+](https://github.com/clojure-emacs/cider)\n* [Calva](https://github.com/BetterThanTomorrow/calva) (VS Code)\n* [clojureVSCode](https://github.com/avli/clojureVSCode) (VS Code)\n\n## Configuration\n\nYou can configure lein-cljfmt by adding a `:cljfmt` map to your\nproject:\n\n```clojure\n:cljfmt {}\n```\n\ncljfmt has several different formatting rules, and these can be\nselectively enabled or disabled:\n\n* `:indentation?` -\n  true if cljfmt should correct the indentation of your code.\n  Defaults to true.\n\n* `:remove-surrounding-whitespace?` -\n  true if cljfmt should remove whitespace surrounding inner\n  forms. This will convert `(  foo  )` to `(foo)`.\n  Defaults to true.\n\n* `:remove-trailing-whitespace?` -\n  true if cljfmt should remove trailing whitespace in lines. This will\n  convert `(foo)   \\n` to `(foo)\\n`. Defaults to true.\n\n* `:insert-missing-whitespace?` -\n  true if cljfmt should insert whitespace missing from between\n  elements. This will convert `(foo(bar))` to `(foo (bar))`.\n  Defaults to true.\n\n* `:remove-consecutive-blank-lines?` -\n  true if cljfmt should collapse consecutive blank lines. This will\n  convert `(foo)\\n\\n\\n(bar)` to `(foo)\\n\\n(bar)`. Defaults to true.\n\n\nYou can also configure the behavior of cljfmt:\n\n* `:paths` - determines which directories to include in the\n  scan. Arguments to `lein check` take precedence. If neither `:paths`\n  nor command line arguments are given, cljfmt uses the lein project\'s\n  `:source-paths` and `:test-paths`.\n\n* `:file-pattern` -\n  determines which files to scan, `#\xe2\x80\x9d\\.clj[csx]?$\xe2\x80\x9d` by default.\n\n* `:indents` -\n  a map of var symbols to indentation rules, i.e. `{symbol [& rules]}`.\n  See the next section for a detailed explanation.\n\n  Unqualified symbols in the indents map will apply to any symbol with a\n  matching "name" - so `foo` would apply to both `org.me/foo` and\n  `com.them/foo`. If you want finer-grained control, you can use a fully\n  qualified symbol in the indents map to configure indentation that\n  applies only to `org.me/foo`:\n\n  ```clojure\n  :cljfmt {:indents {org.me/foo [[:inner 0]]}}\n  ```\n\n  Configured this way, `org.me/foo` will indent differently from\n  `com.them/foo`.\n\n  Note that `cljfmt` currently doesn\'t resolve symbols brought into a\n  namespace using `:refer` or `:use` - they can only be controlled by an\n  unqualified indent rule.\n\n  As with Leiningen profiles, you can add metadata hints. If you want to\n  override all existing indents, instead of just supplying new indents\n  that are merged with the defaults, you can use the `:replace` hint:\n\n  ```clojure\n  :cljfmt {:indents ^:replace {#".*" [[:inner 0]]}}\n  ```\n\n* `:alias-map` -\n  a map of namespace alias strings to fully qualified namespace\n  names. This option is unnecessary in almost all cases, because\n  `cljfmt` can compute the alias map from an `ns`\n  declaration.\n\n  However, it can\'t do that when used as a CLJS library,\n  or when indenting something with no `ns` declaration like an EDN\n  file. Even in those situations, you only need this option when using\n  indentation rules that rely on the fully qualified symbol name.\n\n  If you definitely need to configure this, it should look like this:\n\n  ```clojure\n  :cljfmt {:indents {org.me/foo [[:inner 0]]}\n           :alias-map {"me" "org.me"}}\n  ```\n\n\n### Indentation rules\n\nThere are two types of indentation rule, `:inner` and `:block`.\n\n#### Inner rules\n\nAn `:inner` rule will apply a constant indentation to all elements at\na fixed depth. So an indent rule:\n\n```clojure\n{foo [[:inner 0]]}\n```\n\nWill indent all elements inside a `foo` form by two spaces:\n\n```clojure\n(foo bar\n  baz\n  bang)\n  ```\n\nWhile an indent rule like:\n\n```clojure\n{foo [[:inner 1]]}\n```\n\nWill indent all subforms one level in:\n\n```clojure\n(foo bar\n baz\n (bang\n   quz\n   qoz))\n```\n\nSometimes it\'s useful to limit indentation to one argument of the\nsurrounding form. For example, `letfn` uses inner indentation only in\nits binding vector:\n\n```clojure\n(letfn [(double [x]\n          (* x 2))]   ;; special indentation here\n  (let [y (double 2)\n        z (double 3)]\n    (println y\n             z)))     ;; but not here\n```\n\nTo achieve this, an additional index argument may be used:\n\n```clojure\n{letfn [[:inner 2 0]]}\n```\n\nThis will limit the inner indent to depth 2 in argument 0.\n\n#### Block rules\n\nA `:block` rule is a little smarter. This will act like an inner\nindent only if there\'s a line break before a certain number of\narguments, otherwise it acts like a normal list form.\n\nFor example, an indent rule:\n\n```clojure\n{foo [[:block 0]]}\n```\n\nIndents like this, if there are more than 0 arguments on the same line\nas the symbol:\n\n```clojure\n(foo bar\n     baz\n     bang)\n```\n\nBut indents at a constant two spaces otherwise:\n\n```clojure\n(foo\n  bar\n  baz\n  bang)\n```\n\n## License\n\nCopyright \xc2\xa9 2019 James Reeves\n\nDistributed under the Eclipse Public License either version 1.0 or (at\nyour option) any later version.\n'