b'<a href="https://www.taoensso.com" title="More stuff by @ptaoussanis at www.taoensso.com">\n<img src="https://www.taoensso.com/taoensso-open-source.png" alt="Taoensso open-source" width="400"/></a>\n\n**[CHANGELOG]** | [API] | current [Break Version]:\n\n```clojure\n[com.taoensso/tufte "2.1.0"] ; Stable, see CHANGELOG for details\n```\n\n> Please consider helping to [support my continued open-source Clojure/Script work]? \n> \n> Even small contributions can add up + make a big difference to help sustain my time writing, maintaining, and supporting Tufte and other Clojure/Script libraries. **Thank you!**\n>\n> \\- Peter Taoussanis\n\n# Tufte\n\n### Simple profiling and performance monitoring for Clojure/Script\n\n![Hero]\n\n> Charles Joseph Minard\'s _Carte Figurative_, one of [Edward Tufte][]\'s favourite examples of good data visualization.\n\n## 10-second example\n\n```clojure\n(require \'[taoensso.tufte :as tufte :refer (defnp p profiled profile)])\n\n;; We\'ll request to send `profile` stats to `println`:\n(tufte/add-basic-println-handler! {})\n\n;;; Let\'s define a couple dummy fns to simulate doing some expensive work\n(defn get-x [] (Thread/sleep 500)             "x val")\n(defn get-y [] (Thread/sleep (rand-int 1000)) "y val")\n\n;; How do these fns perform? Let\'s check:\n\n(profile ; Profile any `p` forms called during body execution\n  {} ; Profiling options; we\'ll use the defaults for now\n  (dotimes [_ 5]\n    (p :get-x (get-x))\n    (p :get-y (get-y))))\n\n;; The following will be printed to *out*:\n;;\n;;       pId  nCalls       Min     50% \xe2\x89\xa4     90% \xe2\x89\xa4     95% \xe2\x89\xa4     99% \xe2\x89\xa4       Max      Mean  MAD  Clock Total\n;;\n;;    :get-y       5   94.01ms  500.99ms  910.14ms  910.14ms  910.14ms  910.14ms  580.49ms \xc2\xb145%  2.90s   53%\n;;    :get-x       5  503.05ms  504.68ms  504.86ms  504.86ms  504.86ms  504.86ms  504.37ms  \xc2\xb10%  2.52s   46%\n;;\n;; Accounted                                                                                     5.42s  100%\n;;     Clock                                                                                     5.43s  100%\n```\n\n## Features\n\n * Small, **fast**, cross-platform Clojure/Script codebase\n * **Tiny**, flexible API: `p`, `profiled`, `profile`\n * Great **compile-time elision** and **runtime filtering** support\n * Arbitrary Clojure/Script **form-level** profiling\n * Full support for **thread-local** and **multi-threaded** profiling\n * **Stats are just Clojure maps**: aggregate, **analyse**, log, serialize to db, ...\n * Ideal for **ongoing application performance monitoring** in staging, production, etc. ([example](https://github.com/ptaoussanis/tufte/tree/master/examples/clj)).\n\n## Quickstart\n\nAdd the necessary dependency to your project:\n\n```clojure\n[com.taoensso/tufte "2.1.0"]\n```\n\nAnd setup your namespace imports:\n\n```clojure\n(ns my-clj-ns ; Clojure namespace\n  (:require [taoensso.tufte :as tufte :refer (defnp p profiled profile)]))\n\n(ns my-cljs-ns ; ClojureScript namespace\n  (:require [taoensso.tufte :as tufte :refer-macros (defnp p profiled profile)]))\n```\n\n### Step 1: identify forms you\'d like to [sometimes] profile\n\nJust wrap them with `p` and give them an id (namespaced keyword):\n\n```clojure\n(defn get-customer-info []\n  (let [raw-customer-map (p ::get-raw-customer (fetch-from-db))]\n    (p ::enrich-raw-customer\n      (do-some-work raw-customer-map))))\n```\n\nTufte will record the execution times of these `p` forms whenever profiling is active. \n\n**NB**: whether or not profiling is active, a `p` form **always returns its normal body result**.\n\n> This last point is important: you never need to worry about Tufte messing with your return values.\n\n### Step 2: activate profiling of `p` forms\n\nActivate profiling with `profiled` or `profile`:\n\nAPI        | Return value                | Effect                                      |\n---------- | --------------------------- | ------------------------------------------- |\n`profiled` | `[<body-result> <?pstats>]` | None                                        |\n`profile`  | `<body-result>`             | Sends `<?pstats>` to registered handlers[1] |\n\n**[1]** Register handlers using `(tufte/add-handler! <handler-id> <ns-pattern> <handler-fn>)`\n\n> Handler ideas: save to a db, log, `put!` to a `core.async` channel, filter, aggregate, use for a realtime analytics dashboard, examine for outliers or unexpected behaviour, feed into your other performance/analytics systems, ...\n\n * Use `profiled` to handle pstats yourself **directly at the callsite**.\n * Use `profile` to queue pstats for handling **later/elsewhere**.\n\nBetween the two, you have great flexibility for a wide range of use cases in production and during development/debugging.\n\n## Conditional profiling\n\nTufte offers extensive facilities to control if and when profiling happens.\n\nBoth **compile-time elision** and **runtime filtering** are supported.\n\n### Method 1/3: profiling levels\n\nEvery `p`, `profiled`, and `profile` form can take an optional **profiling level** \xe2\x88\x88 `#{0 1 2 3 4 5}`.\n\nThis level must be >= `tufte/*min-level*` for profiling to occur.\n\nFor example:\n\n```clojure\n(profiled {:level 3} ...) ; Only activates profiling when (>= 3 *min-level*)\n```\n\nMin level    | Set with                                       |\n------------ | ---------------------------------------------- |\nRuntime      | `tufte/set-min-level!`, `tufte/with-min-level` |\nCompile-time | `TUFTE_MIN_LEVEL` environment variable         |\n\n> Note that runtime filtering stacks with any compile-time elision\n\n### Method 2/3: namespace filtering\n\nLikewise- `p`, `profiled`, and `profile` forms can be elided or filtered by the namespace in which they occur.\n\nNamespace filter | Set with                                         |\n---------------- | ------------------------------------------------ |\nRuntime          | `tufte/set-ns-pattern!`, `tufte-with-ns-pattern` |\nCompile-time     | `TUFTE_NS_PATTERN` environment variable          |\n\n> Note that runtime filtering stacks with any compile-time elision\n\nSome example namespace patterns:\n\n```clojure\n"foo.bar.baz"\n"foo.bar.*"\n#{"foo.bar.*" "some.lib.*"}\n{:whitelist #{"foo.bar.*"} :blacklist #{"noisy.lib.*"}}\n```\n\n### Method 3/3: arbitrary runtime conditions\n\nFinally, `profiled` and `profile` both support an optional arbitrary test expression:\n\n```clojure\n(profiled {:when my-cond?} ...) ; Only activates profiling when `my-cond?` is truthy\n```\n\nThis can be used for a wide range of sophisticated behaviour including smart, **application-aware rate limiting**.\n\nAs one simpler example, we can get **sampled profiling** like this:\n\n```clojure\n(profiled {:when (tufte/chance 0.5)} ...) ; Only activates profiling with 50% probability\n```\n\n## Format pstats options\n\n`tufte/format-pstats` takes an optional map as a second parameter to control formatting:\n\n```clojure\n{;; Vector of ordered columns to include in output (all columns by default):\n :columns [:n-calls :min :p50 :p90 :p95 :p99 :max :mean :mad :clock :total]\n\n ;; Function called on each form id (pid), allowing format customization:\n :format-id-fn #_str (tufte/format-id-abbr) ; For abbreviated ids, see docstring for details\n\n ;; Allows for custom sorting of results:\n :sort-fn (fn [m] (get m :sum))}\n```\n\nIf you\'re using `tufte/add-basic-println-handler!`, you can control formatting\nthrough the `:format-pstats-opts` option:\n\n```clojure\n(tufte/add-basic-println-handler!\n  {:format-pstats-opts {:columns [:n-calls :p50 :mean :clock :total]\n                        :format-id-fn name}})\n\n(defnp get-x [] (Thread/sleep 500)             "x val")\n(defnp get-y [] (Thread/sleep (rand-int 1000)) "y val")\n\n(profile\n  {}\n  (dotimes [_ 5]\n    (get-x)\n    (get-y)))\n\n; How does this output look?\n\n;; pId            nCalls      50% \xe2\x89\xa4       Mean      Clock  Total\n;;\n;; defn_get-y          5   572.09ms   567.82ms     2.84s     53%\n;; defn_get-x          5   500.08ms   500.13ms     2.50s     47%\n;;\n;; Accounted                                       5.34s    100%\n;; Clock                                           5.34s    100%\n```\n\n## Example: monitoring Clojure application performance\n\nPlease see the `add-accumulating-handler!` docstring for an example of one common/convenient way to do this.\n\nThere\'s also an [example project](https://github.com/ptaoussanis/tufte/tree/master/examples/clj).\n\n## FAQ\n\n### How to use this for ongoing application performance monitoring?\n\nThe `pstats` objects generated from Tufte\'s `profiled` or `profile` calls are **~losslessly mergeable**.\n\nThis gives you a lot of flexibility re: integrating Tufte as an **ongoing performance monitoring tool**.\n\nAs one example, suppose you have an HTTP application that you\'d like to monitor+optimize for response times:\n\n- Wrap each endpoint with a sampling call to `profile`. (E.g. with a Ring middleware).\n- Your `profile` handler can accumulate (merge) pstats into a buffer.\n- Every n minutes, drain the buffer and log endpoint performance to a db.\n- Trigger alarms if any performance info (e.g. 95th percentile response times) are out of spec. The accumulated pstats info will also be helpful in quickly diagnosing a cause.\n\n### How\'s the performance in production?\n\nTufte\'s designed specifically to support ongoing use in production, and is **highly optimized**: its overhead is on the order of a couple nanoseconds per wrapping.\n\nIf something\'s remotely worth profiling, Tufte\'s overhead should be completely insignificant.\n\nAlso, keep in mind that Tufte\'s **conditional profiling** gives you complete control over if and when you do pay (however little) for profiling.\n\n### Why not just use [YourKit], [JProfiler], or [VisualVM]?\n\nThe traditional recommendation for Clojure profiling has usually been to use a standard JVM profiling tool like one of the above.\n\nAnd they can certainly do the job, but they also tend to be a little hairy: requiring special effort to use, and often producing gobs of information that can be difficult or time-consuming to meaningfully interpret.\n\nIn contrast, Tufte offers some interesting benefits:\n\n * A **cross-platform API** that works seamlessly between your server (Clj) and client (Cljs) applications\n * Arbitrary **application-aware, form-level** profiling; measure [just] what you care about at the application level\n * Simple **thread-local or multi-threaded semantics**\n * During dev/debug: check performance **right from within your REPL**\n * During production: **ongoing, application-aware** conditional profiling, logging, and analysis (stats are just **Clojure maps**)\n\nNote that JVM profiling tools can still be very handy. Tufte doesn\'t offer memory profiling for example, and it\'s not well suited to forensic or very low-level profiling.\n\nIf you want to know `clojure.lang.Numbers$LongOps.lt(Number, Number)` or memory stats, you\'ll want a JVM tool. If you want to know `my-fn` stats, or you want ongoing stats in production - Tufte could be a good fit.\n\n### How does Tufte compare to the profiling in [@ptaoussanis/Timbre]?\n\nActually, I developed Tufte one weekend while refactoring Timbre\'s profiling. It\'s basically a refinement of the ideas from there.\n\nDecided that I could make some worthwhile improvements with some breaking API changes and a new set of dedicated docs. Tufte\'s implementation is cross-platform, considerably faster, and its API more flexible.\n\nWith the release of Tufte, I\'ll be **deprecating Timbre\'s profiling features**.\n\nNote that Tufte\'s a feature **superset** of Timbre\'s profiling, so porting should be straightforward:\n\nAPI        | Timbre              | Tufte                              |\n---------- | ------------------- | ---------------------------------- |\n`p`        | `[id & body]`       | `[id & body]`, `[opts & body]`     |\n`profile`  | `[level id & body]` | `[opts & body]`                    |\n`profiled` | `[level id & body]` | `[opts & body]`                    |\n`profile`  | Output -> log       | Output -> arbitrary handler-fn [1] |\n\n**[1]** See `tufte.timbre/add-timbre-logging-handler!` for directing Tufte\'s `profile` output to Timbre.\n\n### How does Tufte compare to [@hugoduncan/Criterium]?\n\nBasically, they serve different use cases: **benchmarking** for Criterium, and **profiling** for Tufte.\n\nBenchmarking measures performance from the outside. Profiling measures performance from the inside (using some kind of instrumentation).\n\nEssentially: benchmarking is about measuring how long something takes, while profiling is about measuring how long something takes, **and understanding why**.\n\nBoth can be used for performance measurement + comparison, and both can be used for performance optimization. The main tradeoff is: profiling generally provides deeper information at the cost of increased setup effort (instrumentation).\n\n| Library   | Measures                 | Use for                       | During    | Emphasis           |\n| --------- | ------------------------ | ----------------------------- | --------- | ------------------ |\n| Criterium | 1 Clojure form           | Benchmarking                  | Dev       | Accuracy           |\n| Tufte     | >=1 Clojure/Script forms | Profiling, basic benchmarking | Dev, prod | Flexibility, speed |\n\nSo Criterium produces very accurate stats for a _single_ Clojure expression while Tufte produces _combined stats_ for an _arbitrary_ number of Clojure/Script expressions, possibly over time.\n\nFor example:\n\n * Use **Criterium** for a one-off measurement or comparison of the performance of two libraries.\n * Use **Tufte** to measure or monitor the performance of various parts of your system and how they relate.\n\n### What\'s the difference between thread-local and dynamic (multi-threaded) profiling?\n\nIf you don\'t already know the difference, you probably want **thread-local profiling** (the default). It\'s faster and conceptually simpler: it literally just profiles what happens sequentially on the current thread.\n\nWork being done concurrently in futures and agents will be ignored.\n\nIn contrast, **dynamic profiling** works across thread boundaries using Clojure\'s standard `^:dynamic` binding conveyance as in:\n\n```clojure\n(def ^:dynamic *my-dynamic-var* nil)\n(binding [*my-dynamic-var* "foobar!"] ; This val will be available across Clojure threads\n  (future (println [:thread1 *my-dynamic-var*]))\n  (future (println [:thread2 *my-dynamic-var*]))\n  (println [:thread3 *my-dynamic-var*])\n  (Thread/sleep 100))\n  \n;; %> "foobar!", "foobar!", "foobar!"\n```\n\n### How do I get dynamic (multi-threaded) profiling?\n\n`profiled` and `profile` have a `:dynamic?` option:\n\n```clojure\n(profiled {:dynamic? true} ...) ; Activates dynamic (multi-threaded) profiling\n```\n\nThis works through Clojure\'s standard `^:dynamic` binding conveyance.\n\nIf you really want to get fancy, you can also do _manual_ multi-threaded profiling using `tufte/stats-accumulator`.\n\n### What\'s the difference between Clock Time and Accounted Time?\n\n> This question refers to the values reported by the `format-pstats` util\n\n**Clock time** is just the total real-world time that elapsed between the start and end of a `profiled` or `profile` call. This is the amount of time that you\'d have seen pass on a stopwatch in your hand.\n\n**Accounted time** is the total execution time tracked by all `p` forms during the same period. It can be:\n\nOutcome                    | Meaning                                                 |\n-------------------------- | ------------------------------------------------------- |\n`(< accounted clock-time)` | Some work was done that wasn\'t tracked by any `p` forms |\n`(> accounted clock-time)` | Nested `p` forms, and/or multi-threaded profiling[1]    |\n\n**[1]** For example: if you\'re doing concurrent work on 6 threads, then you can do 6ms of work for each 1ms of clock time.\n\n### What if I want to time something across a promise / async handler / etc.?\n\nA low-level util (`capture-time!`) is provided for this and similar use cases. See its docstring for more info.\n\n## Contacting me / contributions\n\nPlease use the project\'s [GitHub issues page] for all questions, ideas, etc. **Pull requests welcome**. See the project\'s [GitHub contributors page] for a list of contributors.\n\nOtherwise, you can reach me at [Taoensso.com]. Happy hacking!\n\n\\- [Peter Taoussanis]\n\n## License\n\nDistributed under the [EPL v1.0] \\(same as Clojure).  \nCopyright &copy; 2016 [Peter Taoussanis].\n\n<!--- Standard links -->\n[Taoensso.com]: https://www.taoensso.com\n[Peter Taoussanis]: https://www.taoensso.com\n[@ptaoussanis]: https://www.taoensso.com\n[More by @ptaoussanis]: https://www.taoensso.com\n[Break Version]: https://github.com/ptaoussanis/encore/blob/master/BREAK-VERSIONING.md\n[support my continued open-source Clojure/Script work]: http://taoensso.com/clojure/backers\n\n<!--- Standard links (repo specific) -->\n[CHANGELOG]: https://github.com/ptaoussanis/tufte/releases\n[API]: http://ptaoussanis.github.io/tufte/\n[GitHub issues page]: https://github.com/ptaoussanis/tufte/issues\n[GitHub contributors page]: https://github.com/ptaoussanis/tufte/graphs/contributors\n[EPL v1.0]: https://raw.githubusercontent.com/ptaoussanis/tufte/master/LICENSE\n[Hero]: https://raw.githubusercontent.com/ptaoussanis/tufte/master/hero.png "Title"\n\n<!--- Unique links -->\n[Edward Tufte]: https://en.wikipedia.org/wiki/Edward_Tufte\n[YourKit]: https://www.yourkit.com/\n[JProfiler]: http://www.ej-technologies.com/products/jprofiler/overview.html\n[VisualVM]: http://docs.oracle.com/javase/6/docs/technotes/guides/visualvm/index.html\n[@ptaoussanis/Timbre]: https://github.com/ptaoussanis/timbre\n[@hugoduncan/Criterium]: https://github.com/hugoduncan/criterium\n'