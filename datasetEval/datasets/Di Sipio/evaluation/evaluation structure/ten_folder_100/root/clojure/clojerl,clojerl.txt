b'# clojerl\n\n[![Travis](https://travis-ci.org/clojerl/clojerl.svg?branch=master)](https://travis-ci.org/clojerl/clojerl)\n[![Hex.pm](https://img.shields.io/hexpm/v/clojerl.svg)](https://hex.pm/packages/clojerl)\n\nClojure implemented on the Erlang VM.\n\n## Building\n\nBuilding `clojerl` requires *Erlang/OTP 18+* and [*rebar3*][rebar3].\n\n    git clone https://github.com/clojerl/clojerl\n    cd clojerl\n    make\n\nOn Windows:\n\n    git clone https://github.com/clojerl/clojerl\n    cd clojerl\n    rebar3 compile\n\n## Getting Started\n\n### Documentation and Resources\n\nThere is more information regarding Clojerl in [clojerl.org][clojerl], like\nwhat [features][features] does it include and\n[how it differs from Clojure][diff-with-clojure].\n\n### Online REPL\n\nTo try it out and get a sense of what you can do, you can visit\n[Try Clojerl][try-clojerl].\n\n### Local REPL\n\nRunning `make repl` (on Windows `bin/clje.bat`) will start the REPL\nand show its prompt:\n\n    Clojure 0.0.0-974.592ad8a\n    clje.user=>\n\nFrom the REPL it\'s possible to start evaluating Clojure expressions:\n\n    clje.user=> (map inc (range 10))\n    (1 2 3 4 5 6 7 8 9 10)\n    clje.user=> (doc map)\n    -------------------------\n    clojure.core/map\n    ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])\n      Returns a lazy sequence consisting of the result of applying f to\n      the set of first items of each coll, followed by applying f to the\n      set of second items in each coll, until any one of the colls is\n      exhausted.  Any remaining items in other colls are ignored. Function\n      f should accept number-of-colls arguments. Returns a transducer when\n      no collection is provided.\n    nil\n    clje.user=> (doc inc)\n    -------------------------\n    clojure.core/inc\n    ([x])\n      Returns a number one greater than num.\n    nil\n    clje.user=>\n\n### Code Examples\n\nThere are some very basic examples in the [scripts/examples][examples]\ndirectory. These are meant to be references on how special forms in\nClojure on the BEAM are used and how they sometimes differ from Clojure\nJVM.\n\n### Web Application Example\n\nFor a very basic example of a web project please check the\n[example-web-app][example-web-app] repository.\n\n### Building Your Own App\n\nThe build tool for Clojerl is the [`rebar3_clojerl`][rebar3_clojerl]\nplugin. [`rebar3`][rebar3] is the official build tool in the Erlang\ncommunity.\n\nThe plugin provides helpful commands to:\n\n- Build a basic directory scaffolding for a new project\n- Compile\n- Run tests\n- Start a REPL\n\nFor more information on how to use this plugin please check the\ndocumentation in [`rebar3_clojerl`][rebar3_clojerl].\n\n## Rationale\n\nErlang is a great language for building safe, reliable and scalable\nsystems. It provides immutable, persistent data structures\nout of the box and its concurrency semantics are unequalled by any\nother language.\n\nClojure is a Lisp and as such comes with all the goodies Lisps\nprovide. Apart from these Clojure also introduces powerful\nabstractions such as protocols, multimethods and seqs, to name a few.\n\nClojure was built to simplify the development of concurrent programs\nand some of its concurrency abstractions could be adapted to Erlang.\nIt is fair to say that combining the power of the Erlang VM with the\nexpressiveness of Clojure could provide an interesting, useful result\nto make the lives of many programmers simpler and make the world a\nhappier place.\n\n## Goals\n\n- Interoperability as smooth as possible, just like Clojure proper and\n  ClojureScript do.\n- Provide most Clojure abstractions.\n- Provide all Erlang abstractions and toolset.\n- Include a default OTP library in Clojerl.\n\n### Personal Goal\n\nLearn more about Erlang (and its VM), Clojure and language\nimplementation.\n\nThis project is an experiment that I hope others will find useful.\nRegardless of whether it becomes a fully functional implementation of\nClojure or not, I will have learned a lot along the way.\n\n## QAs\n\n### What is Clojerl?\n\nClojerl is an experimental implementation of Clojure on the Erlang VM.\nIts goal is to leverage the features and abstractions of Clojure that\nwe love (macros, collections, seq, protocols, multimethods, metadata,\netc.), with the robustness the Erlang VM provides for building\n(distributed) systems.\n\n### Have you heard about LFE and Joxa?\n\nYes. LFE and Joxa were each created with very specific and different\ngoals in mind. LFE was born to provide a LISP syntax for Erlang. Joxa\nwas mainly created as a platform for creating DSLs that could take\nadvantage of the Erlang VM. Its syntax was inspired by Clojure but the\ncreators weren\'t interested in implementing all of Clojure\'s features.\n\n### Aren\'t the language constructs for concurrency very different between Clojure and Erlang?\n\nYes, they are. On one hand Clojure provides tools to handle mutable\nstate in a sane way, while making a clear distinction between identity\nand state through reference types. On the other, concurrency in the\nErlang VM is implemented through processes and message passing. The\nidea in Clojerl is to encourage the Erlang/OTP concurrency model, but\nsupport as many Clojure constructs as possible and as far as they make\nsense in the Erlang VM.\n\n### But... but... Rich Hickey lists [here](https://clojure.org/about/state#actors) some of the reasons why he chose not to use the actor model in Clojure.\n\nThat is not a question, but I see what you mean :). The points he\nmakes are of course very good. For example, when no state is shared\nbetween processes there is some communication overhead, but this\nisolation is also an advantage under a lot of circumstances. He also\nmentions\n[here](https://groups.google.com/forum/#!msg/clojure/Kisk_-9dFjE/_2WxSxyd1SoJ) that\nbuilding for the distributed case (a.k.a processes and message\npassing) is more complex and not always necessary, so he decided to\noptimise for the non-distributed case and add distribution to the\nparts of the system that need it. Rich Hickey calls Erlang "quite\nimpressive", so my interpretation of these writings is that they are\nmore about exposing the rationale behind the decisions and the\ntrade-offs he made when designing Clojure (on the JVM), than about\ndisregarding the actor model.\n\n### Will Clojerl support every single Clojure feature?\n\nNo. Some of Clojure\'s features are implemented by relying on the\nunderlying mutability of the JVM and its object system. The Erlang VM\nprovides very few mutability constructs and no support for defining\nnew types. This makes it very hard or nearly impossible to port some\nfeatures into Clojerl\'s implementation.\n\n### Can I reuse existing Clojure(Script) libraries?\n\nYes, but they will need to be ported, just like for ClojureScript. In\nfact, most of Clojure\'s core namespaces were ported from the original\n.clj files in the Clojure JVM repository.\n\n## Discussion\n\nYou can find me on [twitter](https://twitter.com/jfacorro) or lurking\non [Clojure](https://groups.google.com/forum/?hl=en#!forum/clojure)\'s\nand\n[Erlang](https://groups.google.com/forum/?hl=en#!forum/erlang-programming)\'s\nmailing lists.\n\nAny feedback, comment and/or suggestion is welcome!\n\n[rebar3]: https://github.com/erlang/rebar3\n[try-clojerl]: http://try.clojerl.online/\n[examples]: scripts/examples\n[example-web-app]: https://github.com/clojerl/example-web-app/\n[rebar3_clojerl]:https://github.com/clojerl/rebar3_clojerl\n[diffs-with-clojure]: https://clojerl.github.io/differences-with-clojure/\n[clojerl]: http://clojerl.org/\n[features]: http://clojerl.org/available-features\n[diff-with-clojure]: http://clojerl.org/differences-with-clojure\n'