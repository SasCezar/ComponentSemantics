b'<a href="https://www.taoensso.com" title="More stuff by @ptaoussanis at www.taoensso.com">\n<img src="https://www.taoensso.com/taoensso-open-source.png" alt="Taoensso open-source" width="400"/></a>\n\n\n**[CHANGELOG]** | [API] | current [Break Version]:\n\n```clojure\n[com.taoensso/timbre "4.10.0"] ; Please check CHANGELOG for details\n```\n\n> Please consider helping to [support my continued open-source Clojure/Script work]? \n> \n> Even small contributions can add up + make a big difference to help sustain my time writing, maintaining, and supporting Timbre and other Clojure/Script libraries. **Thank you!**\n>\n> \\- Peter Taoussanis\n\n# Timbre\n\n## A pure Clojure/Script logging library\n\nJava logging is a Kafkaesque mess of complexity that buys you _nothing_. It can be comically hard to get even the simplest logging working, and it just gets worse at scale.\n\nTimbre offers an **all Clojure/Script** alternative that\'s fast, deeply flexible, easy to configure, and that **works out the box**.  No XML.\n\nSupports optional interop with [tools.logging](https://github.com/ptaoussanis/timbre/blob/master/src/taoensso/timbre/tools/logging.clj) and [log4j/logback/slf4j](https://github.com/fzakaria/slf4j-timbre).\n\nHappy hacking!\n\n## Features\n * Full **Clojure** + **ClojureScript** support (v4+).\n * No XML or properties files. **A single, simple config map**, and you\'re set.\n * Simple, flexible **fn appender model** with **middleware**.\n * **Great performance** at any scale.\n * Filter logging by levels, **namespace whitelist/blacklist patterns**, and more.\n * **Zero overhead** with **complete Clj+Cljs elision** for compile-time level/ns filters.\n * Useful built-in appenders for **out-the-box** Clj+Cljs logging.\n * Powerful, easy-to-configure **rate limits** and **async logging**.\n * [Logs as Clojure values][] (v3+).\n * Small, simple, cross-platform codebase.\n\n## 3rd-party tools, appenders, etc.\n\nLink                     | Description\n------------------------ | -----------------------------------------------------\n[@fzakaria/slf4j-timbre] | Route log4j/logback/sfl4j log output to Timbre\n[@palletops/log-config]  | Library to help manage Timbre logging config\nYour link here?          | **PR\'s welcome!**\n\n## Getting started\n\nAdd the necessary dependency to your project:\n\n```clojure\n[com.taoensso/timbre "4.10.0"]\n```\n\nAnd setup your namespace imports:\n\n```clojure\n(ns my-clj-ns ; Clojure namespace\n  (:require\n    [taoensso.timbre :as timbre\n      :refer [log  trace  debug  info  warn  error  fatal  report\n              logf tracef debugf infof warnf errorf fatalf reportf\n              spy get-env]]))\n\n(ns my-cljs-ns ; ; ClojureScript namespace\n  (:require\n    [taoensso.timbre :as timbre\n      :refer-macros [log  trace  debug  info  warn  error  fatal  report\n                     logf tracef debugf infof warnf errorf fatalf reportf\n                     spy get-env]]))\n```\n\n> You can also call `(timbre/refer-timbre)` to configure Clj ns referrals **automatically**.\n\n### Logging\n\nBy default, Timbre gives you basic `println` and `js/console` (v4+) output at a `:debug` log level:\n\n```clojure\n(info "This will print") => nil\n%> 15-Jun-13 19:18:33 localhost INFO [my-app.core] - This will print\n\n(spy :info (* 5 4 3 2 1)) => 120\n%> 15-Jun-13 19:19:13 localhost INFO [my-app.core] - (* 5 4 3 2 1) => 120\n\n(defn my-mult [x y] (info "Lexical env:" (get-env)) (* x y)) => #\'my-mult\n(my-mult 4 7) => 28\n%> 15-Jun-13 19:21:53 localhost INFO [my-app.core] - Lexical env: {x 4, y 7}\n\n(trace "This won\'t print due to insufficient log level") => nil\n```\n\nFirst-argument exceptions generate a nicely cleaned-up stack trace using [io.aviso.exception][] (Clj only):\n\n```clojure\n(info (Exception. "Oh noes") "arg1" "arg2")\n%> 15-Jun-13 19:22:55 localhost INFO [my-app.core] - arg1 arg2\njava.lang.Exception: Oh noes\n<Stacktrace>\n```\n\nOther utils include: `log-errors`, `log-and-rethrow-errors`, `logged-future`, and `handle-uncaught-jvm-exceptions!` (please see the [API] for details).\n\n#### Disabling stacktrace colors\n\nANSI colors are enabled by default for stacktraces. To turn these off (e.g. for log files or emails), you can add the following entry to your top-level config **or** individual appender map/s:\n\n```clojure\n:output-fn (partial timbre/default-output-fn {:stacktrace-fonts {}})\n```\n\nAnd/or you can set the `TIMBRE_DEFAULT_STACKTRACE_FONTS` environment variable (supports edn).\n\n### Data flow\n\nTimbre\'s inherently a very simple design, no magic. It\'s just Clojure data and functions:\n\n 1. Unfiltered logging calls generate a **data map**: `{:level _ :?ns-str _ ...}`\n 2. The resulting data map passes through any **middleware fns**, `(fn [data]) -> ?data`\n 3. The resulting data map is sent to all **appender fns**, `(fn [data]) -> ?effects`\n\n### Configuration\n\nThis is the biggest win over Java logging IMO. \n\n**All** of Timbre\'s behaviour is controlled through a single, simple Clojure map.\n\n> See `timbre/example-config` for Timbre\'s default config map\n\n```clojure\n(def example-config\n  "An example Timbre v4 config map.\n\n  APPENDERS\n    An appender is a map with keys:\n      :min-level       ; Level keyword, or nil (=> no minimum level)\n      :enabled?        ;\n      :async?          ; Dispatch using agent? Useful for slow appenders (clj only)\n      :rate-limit      ; [[ncalls-limit window-ms] <...>], or nil\n      :output-fn       ; Optional override for inherited (fn [data]) -> string\n      :timestamp-opts  ; Optional override for inherited {:pattern _ :locale _ :timezone _} (clj only)\n      :ns-whitelist    ; Optional, stacks with active config\'s whitelist\n      :ns-blacklist    ; Optional, stacks with active config\'s blacklist\n      :fn              ; (fn [data]) -> side effects, with keys described below\n\n    An appender\'s fn takes a single data map with keys:\n      :config          ; Entire config map (this map, etc.)\n      :appender-id     ; Id of appender currently dispatching\n      :appender        ; Entire map of appender currently dispatching\n      :instant         ; Platform date (java.util.Date or js/Date)\n      :level           ; Keyword\n      :error-level?    ; Is level e/o #{:error :fatal}?\n      :?ns-str         ; String,  or nil\n      :?file           ; String,  or nil\n      :?line           ; Integer, or nil ; Waiting on CLJ-865\n      :?err            ; First-arg platform error, or nil\n      :vargs           ; Vector of raw args\n      :output_         ; Forceable - final formatted output string created\n                       ; by calling (output-fn <this-data-map>)\n      :msg_            ; Forceable - args as a string\n      :timestamp_      ; Forceable - string (clj only)\n      :hostname_       ; Forceable - string (clj only)\n      :output-fn       ; (fn [data]) -> formatted output string\n                       ; (see `default-output-fn` for details)\n      :context         ; *context* value at log time (see `with-context`)\n\n      **NB** - any keys not specifically documented here should be\n      considered private / subject to change without notice.\n\n  MIDDLEWARE\n    Middleware are simple (fn [data]) -> ?data fns (applied left->right) that\n    transform the data map dispatched to appender fns. If any middleware\n    returns nil, NO dispatch will occur (i.e. the event will be filtered).\n\n  The `example-config` source code contains further settings and details.\n  See also `set-config!`, `merge-config!`, `set-level!`."\n\n  {:level :debug  ; e/o #{:trace :debug :info :warn :error :fatal :report}\n\n   ;; Control log filtering by namespaces/patterns. Useful for turning off\n   ;; logging in noisy libraries, etc.:\n   :ns-whitelist  [] #_["my-app.foo-ns"]\n   :ns-blacklist  [] #_["taoensso.*"]\n\n   :middleware [] ; (fns [data]) -> ?data, applied left->right\n\n   ;; Clj only:\n   :timestamp-opts default-timestamp-opts ; {:pattern _ :locale _ :timezone _}\n\n   :output-fn default-output-fn ; (fn [data]) -> string\n\n   :appenders\n   {;; The standard println appender:\n    ;; :println (println-appender {:stream :auto})\n\n    :an-example-custom-println-appender\n    ;; Inline appender definition (just a map):\n    {:enabled?   true\n     :async?     false\n     :min-level  nil\n     :rate-limit [[1 250] [10 5000]] ; 1/250ms, 10/5s\n     :output-fn  :inherit\n     :fn ; Appender\'s (fn [data]) -> side effects\n     (fn [data]\n       (let [{:keys [output_]} data\n             formatted-output-str (force output_)]\n         (println formatted-output-str)))}}})\n```\n\nA few things to note:\n\n * Appenders are _trivial_ to write & configure - **they\'re just fns**. It\'s Timbre\'s job to dispatch useful args to appenders when appropriate, it\'s their job to do something interesting with them.\n * Being \'just fns\', appenders have basically limitless potential: write to your database, send a message over the network, check some other state (e.g. environment config) before making a choice, etc.\n\n#### Log levels and ns filters\n\nThe **log level** may be set:\n\n * At compile-time: (`TIMBRE_LEVEL` environment variable).\n * Statically using: `timbre/set-level!`/`timbre/merge-level!`.\n * Dynamically using: `timbre/with-level`.\n\nThe **ns filters** may be set:\n\n * At compile-time: (`TIMBRE_NS_WHITELIST`, `TIMBRE_NS_BLACKLIST` env vars).\n * Statically using: `timbre/set-config!`/`timbre/merge-config!`.\n * Dynamically using: `timbre/with-config`.\n\nThere are also variants of the core logging macros that take an **explicit config arg**:\n\n```clojure\n(timbre/log*  <config-map> <level> <& args>) ; or\n(timbre/logf* <config-map> <level> <& args>)\n```\n\nLogging calls excluded by a compile-time option (e.g. during Cljs compilation) will be **entirely elided from your codebase**, e.g.:\n\n```bash\n#!/bin/bash\n\n# edn values welcome:\nexport TIMBRE_LEVEL=\':warn\'               # Elide all lower logging calls\nexport TIMBRE_NS_WHITELIST=\'["my-app.*"]\' # Elide all other ns logging calls\nexport TIMBRE_NS_BLACKLIST=\'["my-app.foo" "my-app.bar.*"]\'\n\nlein cljsbuild once # Compile js with appropriate logging calls excluded\nlein uberjar        # Compile jar \'\'\n```\n\n### Built-in appenders\n\n#### Basic file appender\n\n```clojure\n;; (:require [taoensso.timbre.appenders.core :as appenders]) ; Add to ns\n\n(timbre/merge-config!\n  {:appenders {:spit (appenders/spit-appender {:fname "/path/my-file.log"})}})\n\n;; (timbre/merge-config! {:appenders {:spit {:enabled? false}}} ; To disable\n;; (timbre/merge-config! {:appenders {:spit nil}}               ; To remove entirely\n```\n\n#### Redis ([Carmine]) appender (v3+)\n\n```clojure\n;; [com.taoensso/carmine <latest-version>] ; Add to project.clj deps\n;; (:require [taoensso.timbre.appenders (carmine :as car-appender)]) ; Add to ns\n\n(timbre/merge-config! {:appenders {:carmine (car-appender/carmine-appender)}})\n```\n\nThis gives us a high-performance Redis appender:\n\n * **All raw logging args are preserved** in serialized form (even errors).\n * Configurable number of entries to keep per log level.\n * Only the most recent instance of each **unique entry** is kept.\n * Resulting **log is just a Clojure value**: a vector of log entries (maps).\n\nClojure has a rich selection of built-in and 3rd party tools for querying values like this.\n\nSee also `car-appender/query-entries`.\n\n#### Email ([Postal]) appender\n\n```clojure\n;; [com.draines/postal <latest-version>] ; Add to project.clj deps\n;; (:require [taoensso.timbre.appenders (postal :as postal-appender)]) ; Add to ns\n\n(timbre/merge-config!\n  {:appenders\n   {:postal\n    (postal-appender/postal-appender\n      ^{:host "mail.isp.net" :user "jsmith" :pass "sekrat!!1"}\n      {:from "me@draines.com" :to "foo@example.com"})}})\n```\n\n#### Other included appenders\n\nA number of 3rd-party appenders are included out-the-box [here](https://github.com/ptaoussanis/timbre/tree/master/src/taoensso/timbre/appenders/3rd_party). **Please see the relevant docstring for details**. Thanks goes to the respective authors! \n\nJust give me a shout if you\'ve got an appender you\'d like to have added.\n\n## Profiling\n\nAs of v4.6.0, Timbre\'s profiling features have been enhanced and exported to a dedicated profiling library called [Tufte].\n\nTimbre\'s old profiling features **will be kept for backwards compatibility** throughout v4.x, but future development will be focused exclusively on Tufte.\n\nTufte has out-the-box support for integration with Timbre, and [migration](https://github.com/ptaoussanis/tufte#how-does-tufte-compare-to-the-profiling-in-timbre) is usually simple.\n\nSorry for the inconvenience!\n\n## This project supports the ![ClojureWerkz-logo] goals\n\n[ClojureWerkz] is a growing collection of open-source, **batteries-included Clojure libraries** that emphasise modern targets, great documentation, and thorough testing.\n\n## Contacting me / contributions\n\nPlease use the project\'s [GitHub issues page] for all questions, ideas, etc. **Pull requests welcome**. See the project\'s [GitHub contributors page] for a list of contributors.\n\nOtherwise, you can reach me at [Taoensso.com]. Happy hacking!\n\n\\- [Peter Taoussanis]\n\n## License\n\nDistributed under the [EPL v1.0] \\(same as Clojure).  \nCopyright &copy; 2015-2016 [Peter Taoussanis].\n\n<!--- Standard links -->\n[Taoensso.com]: https://www.taoensso.com\n[Peter Taoussanis]: https://www.taoensso.com\n[@ptaoussanis]: https://www.taoensso.com\n[More by @ptaoussanis]: https://www.taoensso.com\n[Break Version]: https://github.com/ptaoussanis/encore/blob/master/BREAK-VERSIONING.md\n[support my continued open-source Clojure/Script work]: http://taoensso.com/clojure/backers\n\n<!--- Standard links (repo specific) -->\n[CHANGELOG]: https://github.com/ptaoussanis/timbre/releases\n[API]: http://ptaoussanis.github.io/timbre/\n[GitHub issues page]: https://github.com/ptaoussanis/timbre/issues\n[GitHub contributors page]: https://github.com/ptaoussanis/timbre/graphs/contributors\n[EPL v1.0]: https://raw.githubusercontent.com/ptaoussanis/timbre/master/LICENSE\n[Hero]: https://raw.githubusercontent.com/ptaoussanis/timbre/master/hero.png "Title"\n\n<!--- Unique links -->\n[logging profiler]: #profiling\n[Logs as Clojure values]: #redis-carmine-appender-v3\n[@palletops/log-config]: https://github.com/palletops/log-config\n[@fzakaria/slf4j-timbre]: https://github.com/fzakaria/slf4j-timbre\n[io.aviso.exception]: https://github.com/AvisoNovate/pretty\n[Carmine]: https://github.com/ptaoussanis/carmine\n[Tufte]: https://github.com/ptaoussanis/tufte\n[Postal]: https://github.com/drewr/postal\n[ClojureWerkz-logo]: https://raw.github.com/clojurewerkz/clojurewerkz.org/master/assets/images/logos/clojurewerkz_long_h_50.png\n[ClojureWerkz]: http://clojurewerkz.org/\n'