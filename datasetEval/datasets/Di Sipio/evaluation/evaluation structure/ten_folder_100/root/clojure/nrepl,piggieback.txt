b'[![CircleCI](https://circleci.com/gh/nrepl/piggieback/tree/master.svg?style=svg)](https://circleci.com/gh/nrepl/piggieback/tree/master)\n[![codecov](https://codecov.io/gh/nrepl/piggieback/branch/master/graph/badge.svg)](https://codecov.io/gh/nrepl/piggieback)\n[![Clojars Project](https://img.shields.io/clojars/v/cider/piggieback.svg)](https://clojars.org/cider/piggieback)\n\n# Piggieback\n\n[nREPL](http://github.com/nrepl/nrepl) middleware that enables the\nuse of a ClojureScript REPL on top of an nREPL session.\n\n## Why?\n\nTwo reasons:\n\n* The default ClojureScript REPL (as described in the\n["quick start"](https://clojurescript.org/guides/quick-start)\ntutorial) assumes that it is running in a teletype environment. This works fine\nwith nREPL tools in that environment (e.g. `lein repl` in `Terminal.app` or\n`gnome-terminal`, etc), but isn\'t suitable for development environments that\nhave richer interaction models (including editors like vim ([vim-fireplace][]) and Emacs\n([CIDER][]), and IDEs like Intellij ([Cursive][]) and Eclipse ([Counterclockwise][CCW])).\n\n* Most of the more advanced tool support for Clojure and ClojureScript (code\n  completion, introspection and inspector utilities, refactoring tools, etc) is\n  packaged and delivered as nREPL extensions (e.g. [cider-nrepl][] and [refactor-nrepl][]).\n\nPiggieback provides an alternative ClojureScript REPL entry point\n(`cider.piggieback/cljs-repl`) that changes an nREPL session into a\nClojureScript REPL for `eval` and `load-file` operations, while accepting all\nthe same options as `cljs.repl/repl`. When the ClojureScript REPL is terminated\n(by sending `:cljs/quit` for evaluation), the nREPL session is restored to it\noriginal state.\n\n## Installation\n\nPiggieback is compatible with Clojure 1.8.0+, and _requires_ ClojureScript\n`1.9` or later and nREPL `0.4.0` or later.\n\n**Note** Piggieback 0.3.7 is the first version compatible with nREPL 0.4+. You need\nPiggieback 0.4+ for nREPL 0.6+.\n\n### Leiningen\n\nThese instructions are for Leiningen. Translating them for use in Boot should be\nstraightforward.\n\nModify your `project.clj` to include the following `:dependencies` and\n`:repl-options`:\n\n```clojure\n:profiles {:dev {:dependencies [[cider/piggieback "0.4.2"]]\n                 :repl-options {:nrepl-middleware [cider.piggieback/wrap-cljs-repl]}}}\n```\n\nThe `:repl-options` bit causes `lein repl` to automagically mix the Piggieback\nnREPL middleware into its default stack.\n\n_If you\'re using Leiningen directly, or as the basis for the REPLs in your local\ndevelopment environment (e.g. CIDER, fireplace, counterclockwise, etc), you\'re\ndone._ [Skip to starting a ClojureScript REPL](#usage).\n\n### Boot\n\nContributions welcome!\n\n### Clojure CLI (aka `tools.deps`)\n\n**The instructions below require nREPL 0.4.4 or newer**\n\nAdd this alias to `~/.clojure/deps.edn`:\n\n``` clojure\n{\n;; ...\n:aliases {:nrepl\n          {:extra-deps\n            {nrepl/nrepl {:mvn/version "0.6.0"}\n             cider/piggieback {:mvn/version "0.4.2"}}}}\n}\n```\n\nThen you can simply run a ClojureScript capable nREPL like this:\n\n``` shell\nclj -R:nrepl -m nrepl.cmdline --middleware "[cider.piggieback/wrap-cljs-repl]"\n```\n\nAfterwards simply connect to the running server with your favourite\nnREPL client (e.g. CIDER).\n\n### Embedded\n\nIf you\'re not starting nREPL through a build tool (e.g. maybe you\'re starting up\nan nREPL server from within an application), you can achieve the same thing by\nspecifying that the `wrap-cljs-repl` middleware be mixed into nREPL\'s default\nhandler:\n\n```clojure\n(require \'[nrepl.server :as server]\n         \'[cider.piggieback :as pback])\n\n(server/start-server\n  :handler (server/default-handler #\'pback/wrap-cljs-repl)\n  ; ...additional `start-server` options as desired\n  )\n```\n\nAlternatively, you can add `wrap-cljs-repl` to your application\'s hand-tweaked\nnREPL handler.  Keep two things in mind when doing so:\n\n* Piggieback needs to be "above" nREPL\'s\n  `nrepl.middleware.interruptible-eval/interruptible-eval`; it\n  doesn\'t use `interruptible-eval`\'s evaluation machinery, but it does reuse its\n  execution queue and thus inherits its interrupt capability.\n* Piggieback depends upon persistent REPL sessions, like those provided by\n  `nrepl.middleware.session/session`.)\n\n\n## Usage\n\n```\n$ lein repl\n....\nuser=> (require \'cljs.repl.nashorn)\nnil\nuser=> (cider.piggieback/cljs-repl (cljs.repl.nashorn/repl-env))\nTo quit, type: :cljs/quit\nnil\ncljs.user=> (defn <3 [a b] (str a " <3 " b "!"))\n#<\nfunction cljs$user$_LT_3(a, b) {\n    return [cljs.core.str(a), cljs.core.str(" <3 "), cljs.core.str(b), cljs.core.str("!")].join("");\n}\n>\ncljs.user=> (<3 "nREPL" "ClojureScript")\n"nREPL <3 ClojureScript!"\n```\n\nSee how the REPL prompt changed after invoking\n`cider.piggieback/cljs-repl`? After that point, all expressions sent to the\nREPL are evaluated within the ClojureScript environment.\n`cider.piggieback/cljs-repl`\'s passes along all of its options to\n`cljs.repl/repl`, so all of the tutorials and documentation related to it hold.\n\n*Important Notes*\n\n1. When using Piggieback to enable a browser REPL: the ClojureScript compiler\n   defaults to putting compilation output in `out`, which is probably not where\n   your ring app is serving resources from (`resources`,\n   `target/classes/public`, etc). Either configure your ring app to serve\n   resources from `out`, or pass a `cljs-repl` `:output-dir` option so that a\n   reasonable correspondence is established.\n2. The `load-file` nREPL operation will only load the state of files from disk.\n   This is in contrast to "regular" Clojure nREPL operation, where the current\n   state of a file\'s buffer is loaded without regard to its saved state on disk.\n\nOf course, you can concurrently take advantage of all of nREPL\'s other\nfacilities, including connecting to the same nREPL server with other clients (so\nas to easily modify Clojure and ClojureScript code via the same JVM), and\ninterrupting hung ClojureScript invocations:\n\n```clojure\ncljs.user=> (iterate inc 0)\n^C\ncljs.user=> "Error evaluating:" (iterate inc 0) :as "cljs.core.iterate.call(null,cljs.core.inc,0);\\n"\njava.lang.ThreadDeath\n        java.lang.Thread.stop(Thread.java:776)\n\t\t....\ncljs.user=> (<3 "nREPL still" "ClojureScript")\n"nREPL still <3 ClojureScript!"\n```\n\n(The ugly `ThreadDeath` exception will be eliminated eventually.)\n\nPiggieback works well with all known ClojureScript REPL environments, including\nNashorn, Node, and browser REPLs.\n\n*Support for Rhino was dropped in version 0.3. All users of Rhino are\nadvised to switch to using Nashorn instead.*\n\n## Acknowledgements\n\n[Nelson Morris](http://twitter.com/xeqixeqi) was instrumental in the initial\ndevelopment of piggieback.\n\n## Need Help?\n\nSend a message to the\n[clojure-tools](http://groups.google.com/group/clojure-tools) mailing list, or\nping `@bhauman` or `@bbatsov` on the Clojurians Slack or Twitter if you\nhave questions or would like to contribute patches.\n\n## License\n\nCopyright \xc2\xa9 2012-2019 Chas Emerick, Bruce Hauman, Bozhidar Batsov and other contributors.\n\nDistributed under the Eclipse Public License, the same as Clojure.\n\n[vim-fireplace]: https://github.com/tpope/vim-fireplace\n[Cursive]: https://cursive-ide.com/\n[CIDER]: https://github.com/clojure-emacs/CIDER\n[cider-nrepl]: https://github.com/clojure-emacs/cider-nrepl\n[refactor-nrepl]: https://github.com/clojure-emacs/refactor-nrepl\n[CCW]: https://github.com/ccw-ide/ccw\n'