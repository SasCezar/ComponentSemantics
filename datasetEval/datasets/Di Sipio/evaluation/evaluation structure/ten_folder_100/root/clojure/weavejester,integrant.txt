b'# Integrant\n\n[![Build Status](https://travis-ci.org/weavejester/integrant.svg?branch=master)](https://travis-ci.org/weavejester/integrant)\n\n> integrant /\xcb\x88\xc9\xaant\xc9\xaa\xc9\xa1r(\xc9\x99)nt/\n>\n> (of parts) making up or contributing to a whole; constituent.\n\nIntegrant is a Clojure (and ClojureScript) micro-framework for\nbuilding applications with data-driven architecture. It can be thought\nof as an alternative to [Component][] or [Mount][], and was inspired\nby [Arachne][] and through work on [Duct][].\n\n[component]: https://github.com/stuartsierra/component\n[mount]: https://github.com/tolitius/mount\n[arachne]: http://arachne-framework.org/\n[duct]: https://github.com/duct-framework/duct\n\n## Rationale\n\nIntegrant was built as a reaction to fix some perceived weaknesses\nwith Component.\n\nIn Component, systems are created programmatically. Constructor\nfunctions are used to build records, which are then assembled into\nsystems.\n\nIn Integrant, systems are created from a configuration data structure,\ntypically loaded from an [edn][] resource. The architecture of the\napplication is defined through data, rather than code.\n\nIn Component, only records or maps may have dependencies. Anything\nelse you might want to have dependencies, like a function, needs to be\nwrapped in a record.\n\nIn Integrant, anything can be dependent on anything else. The\ndependencies are resolved from the configuration before it\'s\ninitialized into a system.\n\n[edn]: https://github.com/edn-format/edn\n\n## Installation\n\nTo use the latest release, add the following to your project\n`:dependencies`:\n\n    [integrant "0.7.0"]\n\n## Presentations\n\n* [Enter Integrant](https://skillsmatter.com/skillscasts/9820-enter-integrant)\n\n## Usage\n\n### Configurations\n\nIntegrant starts with a configuration map. Each top-level key in the\nmap represents a configuration that can be "initialized" into a\nconcrete implementation. Configurations can reference other keys via\nthe `ref` (or `refset`) function.\n\nFor example:\n\n```clojure\n(require \'[integrant.core :as ig])\n\n(def config\n  {:adapter/jetty {:port 8080, :handler (ig/ref :handler/greet)}\n   :handler/greet {:name "Alice"}})\n```\n\nAlternatively, you can specify your configuration as pure edn:\n\n```edn\n{:adapter/jetty {:port 8080, :handler #ig/ref :handler/greet}\n :handler/greet {:name "Alice"}}\n```\n\nAnd load it with Integrant\'s version of `read-string`:\n\n```clojure\n(def config\n  (ig/read-string (slurp "config.edn")))\n```\n\n### Initializing and halting\n\nOnce you have a configuration, Integrant needs to be told how to\nimplement it. The `init-key` multimethod takes two arguments, a key\nand its corresponding value, and tells Integrant how to initialize it:\n\n```clojure\n(require \'[ring.adapter.jetty :as jetty]\n         \'[ring.util.response :as resp])\n\n(defmethod ig/init-key :adapter/jetty [_ {:keys [handler] :as opts}]\n  (jetty/run-jetty handler (-> opts (dissoc :handler) (assoc :join? false))))\n\n(defmethod ig/init-key :handler/greet [_ {:keys [name]}]\n  (fn [_] (resp/response (str "Hello " name))))\n```\n\nKeys are initialized recursively, with the values in the map being\nreplaced by the return value from `init-key`.\n\nIn the configuration we defined before, `:handler/greet` will be\ninitialized first, and it\'s value replaced with a handler function.\nWhen `:adapter/jetty` references `:handler/greet`, it will receive the\ninitialized handler function, rather than the raw configuration.\n\nThe `halt-key!` multimethod tells Integrant how to stop and clean up\nafter a key. Like `init-key`, it takes two arguments, a key and its\ncorresponding initialized value.\n\n```clojure\n(defmethod ig/halt-key! :adapter/jetty [_ server]\n  (.stop server))\n```\n\nNote that we don\'t need to define a `halt-key!` for `:handler/greet`.\n\nOnce the multimethods have been defined, we can use the `init` and\n`halt!` functions to handle entire configurations. The `init` function\nwill start keys in dependency order, and resolve references as it\ngoes:\n\n```clojure\n(def system\n  (ig/init config))\n```\n\nWhen a system needs to be shut down, `halt!` is used:\n\n```clojure\n(ig/halt! system)\n```\n\nLike Component, `halt!` shuts down the system in reverse dependency\norder. Unlike Component, `halt!` is entirely side-effectful. The\nreturn value should be ignored, and the system structure discarded.\n\nIt\'s also important that `halt-key!` is **idempotent**. We should be\nable to run it multiple times on the same key without issue.\n\nIntegrant marks functions that are entirely side-effectful with an\nending `!`. You should ignore the return value of any function ending\nin a `!`.\n\nBoth `init` and `halt!` can take a second argument of a collection of\nkeys. If this is supplied, the functions will only initiate or halt\nthe supplied keys (and any referenced keys). For example:\n\n```clojure\n(def system\n  (ig/init config [:adapter/jetty]))\n```\n\n### Suspending and resuming\n\nDuring development, we often want to rebuild a system, but not to\nclose open connections or terminate running threads. For this purpose\nIntegrant has the `suspend!` and `resume` functions.\n\nThe `suspend!` function acts like `halt!`:\n\n```clojure\n(ig/suspend! system)\n```\n\nBy default this functions the same as `halt!`, but we can customize\nthe behavior with the `suspend-key!` multimethod to keep open\nconnections and resources that `halt-key!` would close.\n\nLike `halt-key!`, `suspend-key!` should be both side-effectful and\nidempotent.\n\nThe `resume` function acts like `init`, but takes an additional\nargument specifying a suspended system:\n\n```clojure\n(def new-system\n  (ig/resume config system))\n```\n\nBy default the system argument is ignored and `resume` functions the\nsame as `init`, but as with `suspend!` we can customize the behavior\nwith the `resume-key` multimethod. If we implement this method, we can\nreuse open resources from the suspended system.\n\nTo illustrate this, let\'s reimplement the Jetty adapter with the\ncapability to suspend and resume:\n\n```clojure\n(defmethod ig/init-key :adapter/jetty [_ opts]\n  (let [handler (atom (delay (:handler opts)))\n        options (-> opts (dissoc :handler) (assoc :join? false))]\n    {:handler handler\n     :server  (jetty/run-jetty (fn [req] (@@handler req)) options)}))\n\n(defmethod ig/halt-key! :adapter/jetty [_ {:keys [server]}]\n  (.stop server))\n\n(defmethod ig/suspend-key! :adapter/jetty [_ {:keys [handler]}]\n  (reset! handler (promise)))\n\n(defmethod ig/resume-key :adapter/jetty [key opts old-opts old-impl]\n  (if (= (dissoc opts :handler) (dissoc old-opts :handler))\n    (do (deliver @(:handler old-impl) (:handler opts))\n        old-impl)\n    (do (ig/halt-key! key old-impl)\n        (ig/init-key key opts))))\n```\n\nThis example may require some explanation. Instead of passing the\nhandler directly to the web server, we put it in an `atom`, so that we\ncan change the handler without restarting the server.\n\nWe further encase the handler in a `delay`. This allows us to replace\nit with a `promise` when we suspend the server. Because a promise will\nblock until a value is delivered, once suspended the server will\naccept requests but wait around until its resumed.\n\nOnce we decide to resume the server, we first check to see if the\noptions have changed. If they have, we don\'t take any chances; better\nto halt and re-init from scratch. If the server options haven\'t\nchanged, then deliver the new handler to the promise which unblocks\nthe server.\n\nNote that we only need to go to this additional effort if retaining\nopen resources is useful during development, otherwise we can rely on\nthe default `init` and `halt!` behavior. In production, it\'s always\nbetter to terminate and restart.\n\nLike `init` and `halt!`, `resume` and `suspend!` can be supplied with\na collection of keys to narrow down the parts of the configuration\nthat are suspended or resumed.\n\n### Prepping\n\nSometimes keys require some preparation. Perhaps you have a\nparticularly complex set of default values, or perhaps you want to add\nin default references to other keys. In these cases, the `prep-key`\nmethod can help.\n\n```clojure\n(defmethod ig/prep-key :adapter/jetty [_ config]\n  (merge {:port 8080} config))\n```\n\nThe `prep-key` method will change the value of a key *before* the\nconfiguration is initialized. In the previous example, the `:port`\nwould default to `8080` if not set.\n\nAll keys in a configuration can be prepped using the `prep` function\nbefore the `init` function:\n\n```clojure\n(-> config ig/prep ig/init)\n```\n\nIf `prep-key` is not defined, it defaults to the identity\nfunction. Prepping keys is particularly useful when adding default\nreferences to derived keywords.\n\n### Derived keywords\n\nKeywords have an inherited hierarchy. Integrant takes advantage of\nthis by allowing keywords to refer to their descendents. For example:\n\n```clojure\n(derive :adapter/jetty :adapter/ring)\n```\n\nThis sets up a hierarchical relationship, where the specific\n`:adapter/jetty` keyword is derived from the more generic\n`:adapter/ring`.\n\nWe can now use `:adapter/ring` in place of `:adapter/jetty`:\n\n```clojure\n(ig/init config [:adapter/ring])\n```\n\nWe can also use it as a reference, but only if the reference is\nunambiguous, and only refers to one key in the configuration.\n\n### Composite keys\n\nSometimes it\'s useful to have two keys of the same type in your\nconfiguration. For example, you may want to run two Ring adapters on\ndifferent ports.\n\nOne way would be to create two new keywords, derived from a common\nparent:\n\n```clojure\n(derive :example/web-1 :adapter/jetty)\n(derive :example/web-2 :adapter/jetty)\n```\n\nYou could then write a configuration like:\n\n```edn\n{:example/web-1 {:port 8080, :handler #ig/ref :handler/greet}\n :example/web-2 {:port 8081, :handler #ig/ref :handler/greet}\n :handler/greet {:name "Alice"}}\n```\n\nHowever, you could also make use of composite keys. If your\nconfiguration contains a key that is a vector of keywords, Integrant\ntreats it as being derived from all the keywords inside it.\n\nSo your could also write:\n\n```edn\n{[:adapter/jetty :example/web-1] {:port 8080, :handler #ig/ref :handler/greet}\n [:adapter/jetty :example/web-2] {:port 8081, :handler #ig/ref :handler/greet}\n :handler/greet {:name "Alice"}}\n```\n\nThis syntax sugar allows you to avoid adding extra `derive`\ninstructions to your source code.\n\n### Composite references\n\nComposite references complement composite keys. A normal reference\nmatches any key derived from the value of the reference. A composite\nreference matches any key derived from every value in a vector.\n\nFor example:\n\n```edn\n{[:group/a :adapter/jetty] {:port 8080, :handler #ig/ref [:group/a :handler/greet]}\n [:group/a :handler/greet] {:name "Alice"}\n [:group/b :adapter/jetty] {:port 8081, :handler #ig/ref [:group/b :handler/greet]}\n [:group/b :handler/greet] {:name "Bob"}}\n```\n\nOne use of composite references is to provide a way of grouping keys\nin a configuration.\n\n### Refs vs refsets\n\nAn Integrant ref is used to reference another key in the\nconfiguration. The ref will be replaced with the initialized value of\nthe key. The ref does not need to refer to an exact key - the parent of\na derived key may be specified, so long as the ref is unambiguous.\n\nFor example suppose we have a configuration:\n\n```edn\n{:handler/greet    {:name #ig/ref :const/name}\n :const.name/alice {:name "Alice"}\n :const.name/bob   {:name "Bob"}}\n```\n\nAnd some definitions:\n\n```clojure\n(defmethod ig/init-key :const/name [_ {:keys [name]}]\n  name)\n\n(derive :const.name/alice :const/name)\n(derive :const.name/bob   :const/name)\n```\n\nIn this case `#ig/ref :const/name` is ambiguous - it could refer to\neither `:const.name/alice` or `:const.name/bob`. To fix this we could\nmake the reference more specific:\n\n```edn\n{:handler/greet    {:name #ig/ref :const.name/alice}\n :const.name/alice {:name "Alice"}\n :const.name/bob   {:name "Bob"}}\n```\n\nBut suppose we want to greet not just one person, but several. In this\ncase we can use a refset:\n\n```edn\n{:handler/greet-all {:names #ig/refset :const/name}\n :const.name/alice  {:name "Alice"}\n :const.name/bob    {:name "Bob"}}\n```\n\nWhen initialized, a refset will produce a set of all matching\nvalues.\n\n```clojure\n(defmethod ig/init-key :handler/greet-all [_ {:keys [names]}]\n  (fn [_] (resp/response (str "Hello " (clojure.string/join ", " names))))\n```\n\n### Specs\n\nIt would be incorrect to write specs directly against the keys used by\nIntegrant, as the same key will used in the configuration, during\ninitiation, and in the resulting system. All will likely have\ndifferent values.\n\nTo resolve this, Integrant has an `pre-init-spec` multimethod that can \nbe extended to provide Integrant with a spec to test the value after\nthe references are resolved, but before they are initiated. The\nresulting spec is checked directly before `init-key`, and an exception\nis raised if it fails.\n\nHere\'s how our two example keys would be specced out:\n\n```clojure\n(require \'[clojure.spec.alpha :as s])\n\n(s/def ::port pos-int?)\n(s/def ::handler fn?)\n\n(defmethod ig/pre-init-spec :adapter/jetty [_]\n  (s/keys :req-un [::port ::handler]))\n  \n(s/def ::name string?)\n\n(defmethod ig/pre-init-spec :handler/greet [_]\n  (s/keys :req-un [::name]))\n```\n\nIf we try to `init` an invalid configuration:\n\n```clojure\n(ig/init {:adapter/jetty {:port 3000} :handler/greet {:name "foo"}})\n```\n\nThen an `ExceptionInfo` is thrown explaining the error:\n\n```\nExceptionInfo Spec failed on key :adapter/jetty when building system\nval: {:port 3000} fails predicate: (contains? % :handler)\n```\n\n### Loading namespaces\n\nIt can be hard to remember to load all the namespaces that contain the\nrelevant multimethods. If you name your keys carefully, Integrant can\nhelp via the `load-namespaces` function.\n\nIf a key has a namespace, `load-namespaces` will attempt to load\nit. It will also try concatenating the name of the key onto the end of\nits namespace, and loading that as well.\n\nFor example:\n\n```clojure\n(load-namespaces {:foo.component/bar {:message "hello"}})\n```\n\nThis will attempt to load the namespace `foo.component` and also\n`foo.component.bar`. A list of all successfully loaded namespaces will\nbe returned from the function. Missing namespaces are ignored.\n\n## Reloaded workflow\n\nSee [Integrant-REPL](https://github.com/weavejester/integrant-repl) to \nuse Integrant systems at the REPL, in line with Stuart Sierra\'s [reloaded \nworkflow](http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded).\n\n## Further Documentation\n\n* [API docs](https://weavejester.github.io/integrant/integrant.core.html)\n\n## License\n\nCopyright \xc2\xa9 2018 James Reeves\n\nReleased under the MIT license.\n'