b'# Expound\n\n[![Clojars Project](https://img.shields.io/clojars/v/expound.svg)](https://clojars.org/expound)\n[![cljdoc badge](https://cljdoc.org/badge/expound/expound)](https://cljdoc.org/d/expound/expound/CURRENT)\n[![CircleCI](https://circleci.com/gh/bhb/expound.svg?style=shield)](https://circleci.com/gh/bhb/expound)\n\nExpound formats `clojure.spec` error messages in a way that is optimized for humans to read.\n\nFor example, Expound will replace a Spec error message like:\n\n```\nval: {} fails spec: :example/place predicate: (contains? % :city)\nval: {} fails spec: :example/place predicate: (contains? % :state)\n:clojure.spec.alpha/spec  :example/place\n:clojure.spec.alpha/value  {}\n```\n\nwith\n\n```\n-- Spec failed --------------------\n\n  {}\n\nshould contain keys: :city, :state\n\n| key    | spec    |\n|========+=========|\n| :city  | string? |\n|--------+---------|\n| :state | string? |\n```\n\nExpound is in alpha while `clojure.spec` is in alpha.\n\n**Expound is supported by [Clojurists Together](https://www.clojuriststogether.org/). If you find this project useful, please consider making a monthly donation to Clojurists Together (or ask your employer to do so).**\n\n## Installation\n\n**If you are using recent versions of ClojureScript, please check the [compatibility guide](doc/compatibility.md)**\n\n### Leiningen/Boot\n\n`[expound "0.8.0"]`\n\n#### deps.edn\n\n`expound {:mvn/version "0.8.0"}`\n\n### Lumo\n\n`npm install @bbrinck/expound`\n\n## Usage\n\n[API docs](https://cljdoc.xyz/d/expound/expound/CURRENT)\n\n```\n> brew install clojure\n> clj -Sdeps \'{:deps {friendly {:git/url "https://gist.github.com/bhb/2686b023d074ac052dbc21f12f324f18" :sha "bb5806bd655d743f3b48b36ce83c0085a8d7c54a"}}}\' -m friendly\nuser=> (require \'[expound.alpha :as expound])\nnil\nuser=> (expound/expound string? 1)\nnil\n-- Spec failed --------------------\n\n  1\n\nshould satisfy\n\n  string?\n\n-------------------------\nDetected 1 error\nuser=>\n```\n\n### `expound`\n\nReplace calls to `clojure.spec.alpha/explain` with `expound.alpha/expound` and to `clojure.spec.alpha/explain-str` with `expound.alpha/expound-str`.\n\n```clojure\n(require \'[clojure.spec.alpha :as s])\n;; for clojurescript:\n;; (require \'[cljs.spec.alpha :as s])\n(require \'[expound.alpha :as expound])\n\n(s/def :example.place/city string?)\n(s/def :example.place/state string?)\n(s/def :example/place (s/keys :req-un [:example.place/city :example.place/state]))\n(expound/expound :example/place {:city "Denver", :state :CO} {:print-specs? false})\n;; -- Spec failed --------------------\n\n;;   {:city ..., :state :CO}\n;;                      ^^^\n\n;; should satisfy\n\n;;   string?\n\n;; -------------------------\n;; Detected 1 error\n```\n\n### `*explain-out*`\n\nTo use other Spec functions, set `clojure.spec.alpha/*explain-out*` (or `cljs.spec.alpha/*explain-out*` for ClojureScript) to `expound/printer`.\n\n```clojure\n(require \'[clojure.spec.alpha :as s])\n;; for clojurescript:\n;; (require \'[cljs.spec.alpha :as s])\n(require \'[expound.alpha :as expound])\n\n(s/def :example.place/city string?)\n(s/def :example.place/state string?)\n\n;;  Use `assert`\n(s/check-asserts true) ; enable asserts\n\n;; Set var in the scope of \'binding\'\n(binding [s/*explain-out* expound/printer]\n  (s/assert :example.place/city 1))\n\n(set! s/*explain-out* expound/printer)\n;; (or alter-var-root - see doc/faq.md)\n(s/assert :example.place/city 1)\n\n;; Use `instrument`\n(require \'[clojure.spec.test.alpha :as st])\n\n(s/fdef pr-loc :args (s/cat :city :example.place/city\n                            :state :example.place/state))\n(defn pr-loc [city state]\n  (str city ", " state))\n\n(st/instrument `pr-loc)\n(pr-loc "denver" :CO)\n\n;; You can use `explain` without converting to expound\n(s/explain :example.place/city 123)\n```\n\nDue to the way that macros are expanded in ClojureScript, you\'ll need to configure Expound in *Clojure* to use Expound during macro-expansion. This does not apply to self-hosted ClojureScript. Note the `-e` arg when starting ClojureScript:\n\n`clj -Srepro -Sdeps \'{:deps {expound {:mvn/version "0.8.0"} org.clojure/test.check {:mvn/version "0.9.0"} org.clojure/clojurescript {:mvn/version "1.10.520"}}}\' -e "(require \'[expound.alpha :as expound]) (set! clojure.spec.alpha/*explain-out* expound.alpha/printer)" -m cljs.main -re node`\n\n### Printing results for `check`\n\nRe-binding `s/*explain-out*` has no effect on the results of `cljs.spec.test.alpha/summarize-results`, but Expound provides the function `expound/explain-results` to print the results from `clojure.spec.test.alpha/check`.\n\n```clojure\n(require \'[expound.alpha :as expound]\n         \'[clojure.spec.test.alpha :as st]\n         \'[clojure.spec.alpha :as s]\n         \'[clojure.test.check])\n\n(s/fdef ranged-rand\n  :args (s/and (s/cat :start int? :end int?)\n               #(< (:start %) (:end %)))\n  :ret int?\n  :fn (s/and #(>= (:ret %) (-> % :args :start))\n             #(< (:ret %) (-> % :args :end))))\n(defn ranged-rand\n  "Returns random int in range start <= rand < end"\n  [start end]\n  (+ start (long (rand (- start end)))))\n\n(set! s/*explain-out* expound/printer)\n;; (or alter-var-root - see doc/faq.md)\n(expound/explain-results (st/check `ranged-rand))\n;;== Checked user/ranged-rand =================\n;;\n;;-- Function spec failed -----------\n;;\n;;  (user/ranged-rand -3 0)\n;;\n;;failed spec. Function arguments and return value\n;;\n;;  {:args {:start -3, :end 0}, :ret -5}\n;;\n;;should satisfy\n;;\n;;  (fn\n;;   [%]\n;;   (>= (:ret %) (-> % :args :start)))\n```\n\n### Error messages for predicates\n\n#### Adding error messages\n\nIf a value fails to satisfy a predicate, Expound will print the name of the function (or `<anonymous function>` if the function has no name). To improve the error message, you can use `expound.alpha/defmsg` to add a human-readable error message to the spec.\n\n```clojure\n(s/def :ex/name string?)\n(expound/defmsg :ex/name "should be a string")\n(expound/expound :ex/name :bob)\n;; -- Spec failed --------------------\n;;\n;; :bob\n;;\n;; should be a string\n```\n\n#### Built-in predicates with error messages\n\nExpound provides a default set of type-like predicates with error messages. For example:\n\n```clojure\n(expound/expound :expound.specs/pos-int -1)\n;; -- Spec failed --------------------\n;;\n;; -1\n;;\n;; should be a positive integer\n```\n\nYou can see the full list of available specs with `expound.specs/public-specs`.\n\n### Printer options\n\n`expound` and `expound-str` can be configured with options:\n\n```\n(expound/expound :example/place {:city "Denver", :state :CO} {:print-specs? false :theme :figwheel-theme})\n```\n\nor, to configure the global printer:\n\n```clojure\n(set! s/*explain-out* (expound/custom-printer {:show-valid-values? true :print-specs? false :theme :figwheel-theme}))\n;; (or alter-var-root - see doc/faq.md)\n```\n\n| name | spec |  default | description |\n|------|------|----------|-------------|\n| `:show-valid-values?` | `boolean?` | `false` | If `false`, replaces valid values with `...` (example below) |\n| `:value-str-fn` | `ifn?` | provided function | Function to print bad values (example below) |\n| `:print-specs?` | `boolean?` | `true` | If true, display "Relevant specs" section. Otherwise, omit that section. |\n| `:theme` | `#{:figwheel-theme :none}` | `:none` | Enables color theme. |\n\n\n#### `:show-valid-values?`\n\nBy default, `printer` will omit valid values and replace them with `...`\n\n```clojure\n(set! s/*explain-out* expound/printer)\n;; (or alter-var-root - see doc/faq.md)\n(s/explain :example/place {:city "Denver" :state :CO :country "USA"})\n\n;; -- Spec failed --------------------\n;;\n;;   {:city ..., :state :CO, :country ...}\n;;                      ^^^\n;;\n;; should satisfy\n;;\n;;   string?\n```\n\nYou can configure Expound to show valid values:\n\n```clojure\n(set! s/*explain-out* (expound/custom-printer {:show-valid-values? true}))\n;; (or alter-var-root - see doc/faq.md)\n(s/explain :example/place {:city "Denver" :state :CO :country "USA"})\n\n;; -- Spec failed --------------------\n;;\n;; {:city "Denver", :state :CO, :country "USA"}\n;;                         ^^^\n;;\n;; should satisfy\n;;\n;;   string?\n```\n\n##### `:value-str-fn`\n\nYou can provide your own function to display the invalid value.\n\n```clojure\n;; Your implementation should meet the following spec:\n(s/fdef my-value-str\n        :args (s/cat\n               :spec-name (s/nilable #{:args :fn :ret})\n               :form any?\n               :path :expound/path\n               :value any?)\n        :ret string?)\n(defn my-value-str [_spec-name form path value]\n  (str "In context: " (pr-str form) "\\n"\n       "Invalid value: " (pr-str value)))\n\n(set! s/*explain-out* (expound/custom-printer {:value-str-fn my-value-str}))\n;; (or alter-var-root - see doc/faq.md)\n(s/explain :example/place {:city "Denver" :state :CO :country "USA"})\n\n;; -- Spec failed --------------------\n;;\n;;   In context: {:city "Denver", :state :CO, :country "USA"}\n;;   Invalid value: :CO\n;;\n;; should satisfy\n;;\n;;   string?\n```\n\n### Manual clojure.test/report override\n\nClojure test allows you to declare a custom multi-method for its `clojure.test/report` function. This is particularly useful in ClojureScript, where a test runner can take care of the boilerplate code:\n\n```clojure\n(ns pkg.test-runner\n  (:require [cljs.spec.alpha :as s]\n            [cljs.test :as test :refer-macros [run-tests]]\n            [expound.alpha :as expound]\n            ;; require your namespaces here\n            [pkg.namespace-test]))\n\n(enable-console-print!)\n\n(set! s/*explain-out* expound/printer)\n;; (or alter-var-root - see doc/faq.md)\n\n;; We try to preserve the clojure.test output format\n(defmethod test/report [:cljs.test/default :error] [m]\n  (test/inc-report-counter! :error)\n  (println "\\nERROR in" (test/testing-vars-str m))\n  (when (seq (:testing-contexts (test/get-current-env)))\n    (println (test/testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (let [actual (:actual m)\n        ex-data (ex-data actual)]\n    (if (:cljs.spec.alpha/failure ex-data)\n      (do (println "expected:" (pr-str (:expected m)))\n          (print "  actual:\\n")\n          (print (.-message actual)))\n      (test/print-comparison m))))\n\n;; run tests, (stest/instrument) either here or in the individual test files.\n(run-tests \'pkg.namespace-test)\n```\n\n### Using Expound as printer for Orchestra\n\nUse [Orchestra](https://github.com/jeaye/orchestra) with Expound to get human-optimized error messages when checking your `:ret` and `:fn` specs.\n\n```clojure\n(require \'[orchestra.spec.test :as st])\n\n(s/fdef location\n        :args (s/cat :city :example.place/city\n                     :state :example.place/state)\n        :ret string?)\n(defn location [city state]\n  ;; incorrect implementation\n  nil)\n\n(st/instrument)\n(set! s/*explain-out* expound/printer)\n;; (or alter-var-root - see doc/faq.md)\n(location "Seattle" "WA")\n\n;;ExceptionInfo Call to #\'user/location did not conform to spec:\n;; form-init3240528896421126128.clj:1\n;;\n;; -- Spec failed --------------------\n;;\n;; Return value\n;;\n;; nil\n;;\n;; should satisfy\n;;\n;; string?\n;;\n;; -------------------------\n;; Detected 1 error\n```\n## Conformers\n\nExpound will not give helpful errors (and in some cases, will throw an exception) if you use conformers to transform values. Although using conformers in this way is fairly common, my understanding is that this is not an [intended use case](https://dev.clojure.org/jira/browse/CLJ-2116).\n\nIf you want to use Expound with conformers, you\'ll need to write a custom printer. See "Printer options" above.\n\n## Related work\n\n- [Inspectable](https://github.com/jpmonettas/inspectable) - Tools to explore specs and spec failures at the REPL\n- [Pretty-Spec](https://github.com/jpmonettas/pretty-spec) - Pretty printer for specs\n- [Phrase](https://github.com/alexanderkiel/phrase) - Use specs to create error messages for users\n- [Pinpointer](https://github.com/athos/Pinpointer) - spec error reporter based on a precise error analysis\n\n## Prior Art\n\n* Error messages in [Elm](http://elm-lang.org/), in particular the [error messages catalog](https://github.com/elm-lang/error-message-catalog)\n* Error messages in [Figwheel](https://github.com/bhauman/lein-figwheel), in particular the config error messages generated from [strictly-specking](https://github.com/bhauman/strictly-specking)\n* [Clojure Error Message Catalog](https://github.com/yogthos/clojure-error-message-catalog)\n* [The Usability of beginner-oriented Clojure error messages](http://wiki.science.ru.nl/tfpie/images/6/6e/TFPIE16-slides-emachkasova.pdf)\n* ["Illuminated Macros" - Chris Houser / Jonathan Claggett](https://www.youtube.com/watch?v=o75g9ZRoLaw)\n* [seqex](https://github.com/jclaggett/seqex)\n* ["Improving Clojure\'s Error Messages with Grammars" - Colin Fleming](https://www.youtube.com/watch?v=kt4haSH2xcs)\n\n## Contributing\n\nPull requests are welcome, although please open an issue first to discuss the proposed change. I also answer questions on the #expound channel on [clojurians Slack](http://clojurians.net/).\n\nIf you are working on the code, please read the [Development Guide](doc/development.md)\n\n## License\n\nCopyright \xc2\xa9 2017-2019 Ben Brinckerhoff\n\nDistributed under the Eclipse Public License version 1.0, just like Clojure.\n'