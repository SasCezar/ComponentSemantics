b'Selmer\n======\n\n[![Continuous Integration status](https://secure.travis-ci.org/yogthos/Selmer.png)](http://travis-ci.org/yogthos/Selmer)\nA fast, [Django](https://docs.djangoproject.com/en/dev/ref/templates/builtins/) inspired template system for Clojure.\n\n## Installation\n\n#### Leiningen\n\n[![Clojars Project](http://clojars.org/selmer/latest-version.svg)](http://clojars.org/selmer)\n\n## Marginalia documentation\n\n[Marginalia documentation](https://rawgithub.com/yogthos/Selmer/master/docs/uberdoc.html)\n\n## Usage\n\n### [Jump to Filters](#filters)\n\n#### Built-in Filters\n\n[abbreviate](#abbreviate)\n[add](#add)\n[addslashes](#addslashes)\n[block.super](#blocksuper)\n[capitalize](#capitalize)\n[center](#center)\n[count](#count)\n[count-is](#count-is)\n[currency-format](#currency-format)\n[date](#date)\n[default](#default)\n[default-if-empty](#default-if-empty)\n[double-format](#double-format)\n[email](#email)\n[empty?](#empty)\n[not-empty](#not-empty)\n[first](#first)\n[take](#take)\n[drop](#drop)\n[drop-last](#drop-last)\n[get-digit](#get-digit)\n[hash](#hash)\n[join](#join)\n[json](#json)\n[last](#last)\n[length](#length)\n[length-is](#length-is)\n[linebreaks](#linebreaks)\n[linebreaks-br](#linebreaks-br)\n[linenumbers](#linenumbers)\n[lower](#lower)\n[name](#name)\n[phone](#phone)\n[pluralize](#pluralize)\n[rand-nth](#rand-nth)\n[remove](#remove)\n[remove-tags](#remove-tags)\n[safe](#safe)\n[sort](#sort)\n[sort-by](#sort-by)\n[sort-by-reversed](#sort-by-reversed)\n[sort-reversed](#sort-reversed)\n[subs](#subs)\n[sum](#sum)\n[str](#str)\n[title](#title)\n[upper](#upper)\n[urlescape](#urlescape)\n[multiply](#multiply)\n[divide](#divide)\n[round](#round)\n[between?](#between)\n[replace](#replace)\n\n### [Jump to Tags](#tags)\n\n#### Built-in Tags\n\n[block](#block)\n[comment](#comment)\n[cycle](#cycle)\n[debug](#debug)\n[if](#if)\n[ifequal](#ifequal)\n[ifunequal](#ifunequal)\n[include](#include)\n[extends](#extends)\n[firstof](#firstof)\n[for](#for)\n[now](#now)\n[safe](#safe-tag)\n[script](#script)\n[style](#style)\n[verbatim](#verbatim)\n[with](#with)\n\n### [Jump to Template Inheritance](#template-inheritance)\n\n\n### Templates\n\nSelmer templates consist of plain text that contains embedded expression and filter tags. While Selmer\nis primarily meant for HTML generation, it can be used for templating any text.\n\nSelmer compiles the template files and replaces any tags with the corresponding functions for handling\ndynamic content. The compiled template can then be rendered given a context map.\n\nFor example, if we wanted to render a string containing a name variable we could write the following:\n\n```clojure\n(use \'selmer.parser)\n\n(render "Hello {{name}}!" {:name "Yogthos"})\n=>"Hello Yogthos!"\n```\n\nTo render a file we can call `render-file` instead:\n\n```clojure\n(use \'selmer.parser)\n\n(render-file "home.html" {:name "Yogthos"})\n```\n\nTo list the declared variables in the template:\n\n```clojure\n(known-variables "{{name}}")\n=>#{:name}\n```\n\n#### \\*\\*Important\\*\\*\n\nWhen rendering files Selmer will cache the compiled template. A recompile will be triggered if the last\nmodified timestamp of the file changes. Note that changes in files referenced by the template **will not**\ntrigger a recompile. This means that if your template extends or includes other templates you must touch\nthe file that\'s being rendered for changes to take effect.\n\nAlternatively you can turn caching on and off using `(selmer.parser/cache-on!)` and\n `(selmer.parser/cache-off!)` respectively.\n\n### Resource Path\n\nBy default the templates are located relative to the `ClassLoader` URL. If you\'d like to set a custom location for the\ntemplates, you can use `selmer.parser/set-resource-path!` to do that:\n\n```clojure\n(selmer.parser/set-resource-path! "/var/html/templates/")\n```\n\nIt\'s also possible to set the root template path in a location relative to the resource path of the application:\n\n```clojure\n(set-resource-path! (clojure.java.io/resource "META-INF/foo/templates"))\n```\n\nThis allows the templates to be refrerenced using `include` and `extends` tags without having to specify the full path.\n\nTo reset the resource path back to the default simply pass it a `nil`:\n\n```clojure\n(selmer.parser/set-resource-path! nil)\n```\n\nThe application will then look for templates at this location. This can be useful if you\'re deploying the application\nas a jar and would like to be able to modify the HTML without having to redeploy it.\n\nBy default, Selmer uses `{%` and `%}` to indicate the start and the end of an expression, while using `{{` and `}}` for for variables.\nThis might conflict with clientside frameworks such as AngularJS. In this case you can specify custom tags by passing\na map containing any of the following keys to the parser:\n\n```clojure\n:tag-open\n:tag-close\n:filter-open\n:filter-close\n:tag-second\n```\n\n```clojure\n(render "[% for ele in foo %]{{[{ele}]}}[%endfor%]"\n                 {:foo [1 2 3]}\n                 {:tag-open \\[\n                  :tag-close \\]})\n=>"{{1}}{{2}}{{3}}"\n```\n\nNote that if you\'re using namespaces keys, such as `:foo.bar/baz`, then you will need to escape the `.` as follows:\n\n```clojure\n(parser/render "{{foo..bar/baz}}" {:foo.bar/baz "hello"})\n```\n\n## Error Handling\n\nSelmer will attempt to validate your templates by default, if you wish to disable validation for any reason it can be done by\ncalling `(selmer.validator/validate-off!)`.\n\nWhenever an error is detected by the validator an instance of `clojure.lang.ExceptionInfo` will be thrown.\nThe exception will contain the following keys:\n\n* `:type` - `:selmer-validation-error`\n* `:error` - the error message\n* `:error-template` - the error page template\n* `:template` - template file that contains the error\n* `:validation-errors` - a vector of validation errors\n\nEach error in the `:validation-errors` vector is a map containing the details specific to the error:\n\n* `:line` - the line on which the error occurred\n* `:tag` - the tag that contains the error\n\nThe template under the `:error-template` key can be used to render a friendly error page.\nSelmer provides a middleware wrapper for this purpose:\n\n```clojure\n(ns myapp.handler\n  (:require [selmer.middleware :refer [wrap-error-page]]\n            [environ.core :refer [env]]))\n\n...\n\n#(if (env :dev) (wrap-error-page %) %)\n```\n\nThe middleware will render a page like the one below whenever any parsing errors are encountered.\n\n![](https://raw.github.com/yogthos/Selmer/master/error_page.png)\n\n## Variables and Tags\n\nVariables are used to inject dynamic content into the text of the template. The values for the variables\nare looked up in the context map as can be seen in the example above. When a value is missing then an\nempty string is rendered in its place.\n\nBy default variables are defined using the double curly braces: `{{myvar}}`.\n\nA variables can also be nested data structures, eg:\n\n`(render "{{person.name}}" {:person {:name "John Doe"}})`\n\n`(render "{{foo.bar.0.baz}}" {:foo {:bar [{:baz "hi"}]}})`\n\nIt works with string keys too. For optimal performance, prefer maps with keyword keys. Occasional\nstring keys are ok, but heavily nested context maps with all string key lookups are slower to render.\n\n`(render "{{foo.bar.baz}}" {:foo {:bar {"baz" "hi"}}})`\n\nTags are used to add various functionality to the template such as looping and conditions.\nFor example, if we wanted to create a list from a collection of items we could use the `for` tag\nas follows:\n\n```xml\n<ul>\n{% for item in items %}\n    <li>{{item}}</li>\n{% endfor %}\n</ul>\n```\n\n## Filters\n\nIn many cases you may wish to postprocess the value of a variable. For example, you might want to convert\nit to upper case, pluralize it, or parse it as a date. This can be done by specifying a filter following the\nname of the variable. The filters are separated using the `|` character.\n\nFor example, if we wanted to convert the variable to upper case we could write `{{user-name|upper}}`. When\nrendered with `{:user-name "Yogthos"}` it would produce `YOGTHOS` as its output.\n\nSome filters can take parameters. `{{domain|hash:"md5"}}` rendered with `{:domain "example.org"}` would produce\n`1bdf72e04d6b50c82a48c7e4dd38cc69`. If a parameter begins with `@` it will be looked up in the context map and,\nif found, will be replaced with its value before\nbeing passed to the filter function. For example, `@foo.bar` will treated as `(get-in context-map [:foo :bar] "@foo.bar")`.\n\nFinally, you can easily register custom filters in addition to those already provided. A filter is simply a function\nthat accepts a value and returns its replacement:\n\n```clojure\n(use \'selmer.filters)\n\n(add-filter! :embiginate clojure.string/upper-case)\n(render "{{shout|embiginate}}" {:shout "hello"})\n=>"HELLO"\n\n(add-filter! :empty? empty?)\n(render "{{files|empty?}}" {:files []})\n=>"true"\n```\n\nby default the content of the filter will be escaped, if you\'d like to make a safe filter then wrap it\'s body\nin a vector with a `:safe` keyword:\n\n```clojure\n(add-filter! :foo  (fn [x] [:safe (.toUpperCase x)]))\n\n(render "{{x|foo}}" {:x "<div>I\'m safe</div>"})\n=>"<DIV>I\'M SAFE</DIV>"\n```\n\nIt is possible to disable escaping (if, for example, your target format is not HTML/XML) using the `selmer.util/without-escaping` macro:\n\n```clojure\n(require \'[selmer.util :refer [without-escaping]])\n\n(without-escaping\n  (render "{{x}}" {:x "I <3 NY"}))\n=>"I <3 NY"\n```\n\nAlternatively, you can turn off escaping permanently in all threads with the `selmer.util/turn-off-escaping!` function.\n\n\n### Built-in Filters\n\n#### abbreviate\n\nAbbreviate the input string to given width if it exceeds a maxium\nwidth. If only a maximum width is given, abbreviated and maximum width\nare the same. The first parameter is the maximum width, the optional\nsecond parameter the abbreviated width.\n\n`(render "{{f|abbreviate:19}}" {:f "an abbreviate example text"}) => "an abbreviate ex..."`\n\n`(render "{{f|abbreviate:19:12}}" {:f "an abbreviate example text"}) => "an abbrev..."`\n\n`(render "{{f|abbreviate:26:12}}" {:f "an abbreviate example text"}) => "an abbreviate example text"`\n\nThe last example shows: if the string fits in the maximum width the\nfull string is used even if the abbreviated form would be shorter.\n\nBy default `...` is used as replacement for the abbreviated part of\nthe string. You can easily change that with the `abbr-ellipsis` filter:\n\n`(render "{{f|abbr-ellipsis:\\"\xe2\x80\xa6 etc. pp.\\"|abbreviate:19}}" {:f "an abbreviate example text"}) => "an abbrev\xe2\x80\xa6 etc. pp."`\n\n`(render "{{f|abbr-ellipsis:\\"\\"|abbreviate:19}}" {:f "an abbreviate example text"}) => "an abbreviate examp"`\n\nNote that the ellipsis can\'t be longer than the abbreviated width.\n\nWith the `abbr-left`, `abbr-right` and `abbr-middle` filters you can\nalso control in which position the abbreviation happens. Filter\n`abbr-right` is provided for completeness, even though it\'s the\ndefault.\n\n`(render "{{f|abbr-left|abbreviate:19:12}}" {:f "an abbreviate example text"}) => "...mple text"`\n\n`(render "{{f|abbr-middle|abbreviate:19}}" {:f "an abbreviate example text"}) => "an abbre...ple text"`\n\nYou also can combine the position and ellipsis filter:\n\n`(render "{{f|abbr-ellipsis:\\" <-- snip --> \\"|abbr-middle|abbreviate:19}}" {:f "an abbreviate example text"}) => "an &lt;-- snip --&gt; ext"`\n\nPlease note that the `abbr-left`, `abbr-right`, `abbr-middle` and\n`abbr-ellipsis` filters can only be used just before an `abbreviate`\nfilter!\n\n#### add\nCan add Integers and Doubles. If one of the parameters cannot be casted into one of the two, all parameters will be concatenated to a String.\n\n`(render "{{add_me|add:2:3:4}}" {:add_me 2})` => `11`\n\n`(render "{{h|add:e:l:l:o}}" {:h "h"})` => `"hello"`\n\n#### addslashes\nNota bene, the slashes aren\'t actually in the input string, but they *are* going to be in the input. Just trying to write valid Clojure code.\n\n`(render "{{name|addslashes}}" {:name "\\"Russian tea is best tea\\""})` => `"\\"Russian tea is best tea\\""`\n\n#### block.super\n\nCan be used inside a block to insert the content from the parent block in its place\n\n`{% block foo %} {{block.super}} some content{% endblock %}`\n\n\n#### capitalize\n`(render "{{name|capitalize}}" {:name "russian tea is best tea"})` => `"Russian tea is best tea"`\n\n#### center\n`(render "{{name|center:20}}" {:name "yogthos"})` => `"      yogthos     "`\n\n#### count\n`(render "{{name|count}}" {:name "Yogthos"})` => `"7"`\n\n`(render "{{items|count}}" {:items [1 2 3 4]})` => `"4"`\n\n#### count-is\n`(render "{{x|count-is:3}}" {:x [1 2 3]})` => `"true"`\n`(render "{{x|count-is:0}}" {})` => `"true"`\n\n#### currency-format\n`"{{amount|currency-format}}" {:amount 123})` => `"$123.00"`\n\nUses `java.text.NumberFormat/getCurrencyInstance` for formatting the currency value.\nThe formatter defaults to the default locale for this instance of the Java Virtual Machine.\n\nAn ISO 639 2-letter language code can be added as a locale.\n\n`"{{amount|currency-format:de}}" {:amount 123})` => `"\xe2\x82\xac 123,00"`\n\nAdditionally, the locale can be followed by the country code.\n\n`"{{amount|currency-format:de:DE}}" {:amount 123})` => `"\xe2\x82\xac 123,00"`\n\n#### date\nFormat a date. Supports a number of predefined formats, whose output may differ according to the current locale and / or JVM version. Valid formats are: `shortDate`, `shortTime`, `shortDateTime`, `mediumDate`, `mediumTime`, `mediumDateTime`, `longDate`, `longTime`, `longDateTime`, `fullDate`, `fullTime`, and `fullDateTime`.\n\n`(render "{{d|date:shortDate}}" {:d (java.util.Date.)})` => `"8/3/13"`\n\n`(render "{{d|date:shortDate}}" {:d nil})` => `""`\n\nTo more precisely control the output format, pass a format string:\n\n`(render "{{d|date:\\"yyyy-MM-dd\\"}}" {:d (java.util.Date.)})` => `"2013-08-03"`\n\nAn ISO 639 2-letter language code can be added to force a particular locale:\n\n`(render "{{now|date:\\"MMMM\\":fr}}" {:now (java.util.Date.)})` => `"mars"`\n\nTo conveniently render the current date, see the [now](#now) tag.\n\n#### default\n`(render "{{name|default:"I <3 ponies"}}" {:name "yogthos"})` => `"yogthos"`\n`(render "{{name|default:"I <3 ponies"}}" {:name nil})` => `"I <3 ponies"`\n`(render "{{name|default:"I <3 ponies"}}" {:name []})` => `"[]"`\n\n`(render "{{name|default:"I <3 ponies"}}" {})` => `"I <3 ponies"`\n\n#### default-if-empty\n`(render "{{name|default-if-empty:"I <3 ponies"}}" {:name "yogthos"})` => `"yogthos"`\n`(render "{{name|default-if-empty:"I <3 ponies"}}" {:name nil})` => `"I <3 ponies"`\n`(render "{{name|default-if-empty:"I <3 ponies"}}" {:name []})` => `"I <3 ponies"`\n`(render "{{name|default-if-empty:"I <3 ponies"}}" {})` => `"I <3 ponies"`\n\n#### double-format\n`(render "{{tis-a-number|double-format:2}}" {:tis-a-number 10.00001})` => `10.00`\n`(render "{{tis-a-number|double-format}}" {:tis-a-number 10.00001})` => `10.0`\n\n#### email\nRenders an email address as a selectable link.\n\n`(render "{{address|email}}" {:address "mickey@disney.com"})` => `<a href="mickey@disney.com">mickey@disney.com</a>`\n\nNota bene, the email filter takes an optional `validate?` argument. If it is present and equal to `false`, the email filter will process any argument as above:\n\n`(render "{{address|email:false}}" {:address "this.is.not.an.email.address"})` => `<a href="this.is.not.an.email.address">this.is.not.an.email.address</a>`\n\nHowever, if it is not present or is present but not equal to `false`, an obviously invalid email address will cause an exception to be thrown. Validation is done by a simple regular expression; it will not catch all invalid email addresses.\n\n#### empty?\n`(render "{% if xs|empty? %}foo{% endif %}" {:xs []})` => `"foo"`\n\n#### not-empty\n`(render "{% if xs|not-empty %}foo{% endif %}" {:xs [1 2]})` => `"foo"`\n\n#### first\n`(render "{{seq-of-some-sort|first}}" {:seq-of-some-sort [:dog :cat :bird :bird :bird :is :the :word]})` => `:dog`\n\n#### take\n`(render "{{seq-of-some-sort|take:3}}" {:seq-of-some-sort [:dog :cat :bird :bird :bird :is :the :word]})` => `[:dog :cat :bird]`\n\n#### drop\n`(render "{{seq-of-some-sort|drop:4}}" {:seq-of-some-sort [:dog :cat :bird :bird :bird :is :the :word]})` => `[:bird :is :the :word]`\n\n`(render "{{seq-of-some-sort|drop:4}}" {:seq-of-some-sort [:dog :cat :bird :bird :bird :is :the :word]})` => `[:bird :is :the :word]`\n\n`(render "{{seq-of-some-sort|drop:4|join:\\" \\"}}" {:seq-of-some-sort ["dog" "cat" "bird" "bird" "bird" "is" "the" "word"]})` => `bird is the word`\n\n#### drop-last\nSimilar to drop:\n\n`(render "{{seq-of-some-sort|drop-last:4}}" {:seq-of-some-sort [:dog :cat :bird :bird :bird :is :the :word]})` =\\> `[:dog :cat :bird :bird]`\n\n\n#### get-digit\n`(render "{{tis-a-number|get-digit:1}}" {:tis-a-number 12.34567})` => `7`\n\n#### hash\navailable hashes: `md5`, `sha`, `sha256`, `sha384`, `sha512`\n\n`(render "{{domain|hash:\\"md5\\"}}" {:domain "example.org"})` => `"1bdf72e04d6b50c82a48c7e4dd38cc69"`\n\n\n#### join\n`(render "{{sequence|join}}" {:sequence [1 2 3 4]})` => `"1234"`\n`(render "{{sequence|join:\\", \\"}}" {:sequence [1 2 3 4]})` => `"1, 2, 3, 4"`\n\n#### json\nby default content will be escaped\n\n`(render "{{data|json}}" {:data [1 2 {:foo 27 :dan "awesome"}]})` => `"[1,2,{&quot;foo&quot;:27,&quot;dan&quot;:&quot;awesome&quot;}]"`\n\nif you wish to render it unescaped use the `safe` filter:\n\n`(render "{{f|json|safe}}" {:f {:foo 27 :dan "awesome"}})`\n\n\n#### last\n`(render "{{sequence|last}}" {:sequence 12.34567})` => `7`\n`(render "{{sequence|last}}" {:sequence [1 2 3 4]})` => `4`\n\n#### length\n`(render "{{sequence|length}}" {:sequence [1 2 3 4]})` => `4`\n\n#### length-is\n`(render "{{sequence|length-is:4}}" {:sequence [1 2 3 4]})` => `true`\n\n#### linebreaks\nSingle newlines become `<br />`, double newlines mean new paragraph. Content will\nbe escaped by default.\n\n`(render "{{foo|linebreaks|safe}}" {:foo "\\nbar\\nbaz"})` => `"<p><br />bar<br />baz</p>"`\n\n#### linebreaks-br\nlike `linebreaks` but doesn\'t insert `<p>` tags.\n`(render "{{foo|linebreaks-br|safe}}" {:foo "\\nbar\\nbaz"})` => `"<br />bar<br />baz"`\n\n#### linenumbers\nDisplays text with line numbers.\n`(render "{{foo|linenumbers}}" {:foo "foo\\n\\bar\\nbaz"})` => `"1. foo\\n2. bar\\n3. baz"`\n\n#### lower\n`(render "{{foo|lower}}" {:foo "FOOBaR"})` => `"foobar"`\n\n#### name\n`(render "{{foo|name}}" {:foo :foobar})` => `"foobar"`\n\n#### number-format\n`(render "{{amount|number-format:%.3f}}" {:amount 123.04455})` => `"123.045"`\n\nAn ISO 639 2-letter language code can be added as a locale.\n\n`(render "{{amount|number-format:%.3f:de}}" {:amount 123.04455})` => `"123,045"`\n\n#### phone\nRenders a phone number as a selectable link, for use with telephony systems (including mobile phones).\n\n`(render "{{number|phone}}" {:number "01234 567890"})` => `"<a href=\'tel:01234-567890\'>01234 567890</a>"`\n\nThe `phone` filter takes two optional positional arguments:\n\n* `national-prefix` The [ITU-T E.123](https://en.wikipedia.org/wiki/E.123) [international subscriber dialing prefix](https://en.wikipedia.org/wiki/List_of_country_calling_codes) to prepend in place of a leading zero. Default is do not prepend.\n* `validate?` if present and equal to "false", do not throw exception if number appears invalid. Default behaviour is do throw an exception.\n\nBoth arguments are optional, but because they are positional the `national-prefix` must come before `validate?` when\nboth arguments are supplied.\n\nThus:\n\n`(render "{{number|phone:44:true}}" {:number "01234 567890"})` => `"<a href=\'tel:+44-1234-567890\'>01234 567890</a>"`\n\nValidation is done by a simple regular expression; it will not catch all invalid phone numbers.\n\n#### pluralize\nReturns the correct (English) pluralization based on the variable. This works with many words, but certainly not all (eg. foot/feet, mouse/mice, etc.)\n\n`(render "{{items|count}} item{{items|pluralize}}" {:items []})` => `"0 items"`\n\n`(render "{{items|count}} item{{items|pluralize}}" {:items [1]})` => `"1 item"`\n\n`(render "{{items|count}} item{{items|pluralize}}" {:items [1 2]})` => `"2 items"`\n\n`(render "{{fruit|count}} tomato{{fruit|pluralize:\\"es\\"}}" {:fruit []})` => `"0 tomatoes"`\n\n`(render "{{people|count}} lad{{people|pluralize:\\"y\\":\\"ies\\"}}" {:people [1]})` => `"1 lady"`\n\n`(render "{{people|count}} lad{{people|pluralize:\\"y\\":\\"ies\\"}}" {:people [1 2]})` => `"2 ladies"`\n\n`(render "{{people}} lad{{people|pluralize:\\"y\\":\\"ies\\"}}" {:people 2})` => `"2 ladies"`\n\n#### rand-nth\nreturns rand-nths value from a collection:\n`(render "{{foo|rand-nth}}" {:foo [1 2 3]})` => `"2"`\n\n#### remove\nremoves specified characters from the string:\n`(render "{{foo|remove:\\"aeiou\\"}}" {:foo "abcdefghijklmnop"})` => `"bcdfghjklmnp"`\n#### remove-tags\nRemoves the specified HTML tags from the string:\n`(render "{{ value|remove-tags:b:span }}" {:value "<b><span>foobar</span></b>"})` => `"foobar"`\n\n#### safe\nBy default Selmer will HTML escape all variables, The `safe` filter exempts the variable from being html-escaped:\n\n`(render "{{data}}" {:data "<foo>"})` => `"&lt;foo&gt;"`\n\n`(render "{{data|safe}}" {:data "<foo>"})` => `"<foo>"`\n\n#### sort\n`(render "{{ value|sort }}" {:value [1 4 2 3 5]})` => `"(1 2 3 4 5)"`\n\n#### sort-by\n`(render "{{ value|sort-by:name }}" {:value [{:name "John"} {:name "Jane"}]})` => `"({:name &quot;Jane&quot;} {:name &quot;John&quot;})"`\n\n#### sort-reversed\nsame as sort, but in reverse order\n\n#### sort-by-reversed\nsame as sort-by, but in reverse order\n\n#### str\nLike the clojure function `str`. So you can do crazy stuff like:\n`(render "{{people|length-is:2|last|str|join:\\"-\\"}} lad{{people|pluralize:\\"y\\":\\"ies\\"}}" {:people [1 2]})` => `"t-r-u-e ladies"`\nWithout raising an exception.\n\n#### subs\nLike the clojure function `subs`.\n `(render "{{s|subs:0:3:\\" ..."}}", {:s "Foo bar baz"})` => `"Foo ..."`\n\n#### title\nCapitalize the words of a string\n`(render "{{s|title}}" {:s "my fancy title"})` => `"My Fancy Title"`\n\n#### upper\n`(render "{{shout|upper}}" {:shout "hello"})` => `"HELLO"`\n\n#### urlescape\n`(render "{{data|urlescape}}" {:data "clojure url"})` => `"clojure+url"`\n\n#### round\n\nReturns the closest integer to the argument, with ties rounding up.\n\n`(render "{{foo|round}}" {:foo 3.33333})` =\\> `"3"`\n\n#### multiply\n\nMultiplies the value with the given number. Throws error if one of the both\nvalues are neither Long nor Double.\n\n`(render "{{foo|multiply:2}}" {:foo 3.3})` =\\> `"6.6"`\n\n#### divide\n\nMultiplies the value with the given number. Throws error if one of the both\nvalues are neither Long nor Double.\n\n`(render "{{foo|divide:2}}" {:foo 6})` =\\> `"3"`\n\n#### replace\n\nReplaces all occurrences of the first string with the second string. \n\n`(render "{{foo|replace:foo:bar}}" {:foo "foo test foo ..."})` =\\> `"bar test\nbar ..."`\n\n#### between?\n\n`(render "{{foo|between?:2:4}}" {:foo 3})` =\\> `"true"`\n\n\n## Tags\n\nSelmer supports two types of tags. The tags can be inline, which means that they consist of a single\ntag statement such as `include` or `extends`, or contain a body and intermediate tags,\nsuch as `if`, `else`, `endif`.\n\nFor example if we wanted to iterate over a collection of items, we could write the following:\n\n```clojure\n(render\n  "{% for user in users %}{{user.name}}{% endfor %}"\n  {:users [{:name "John"} {:name "Jane"}]})\n=>"JohnJane"\n```\n\nIt\'s also possible to define custom tags using the `add-tag!` macro:\n\n```clojure\n(use \'selmer.parser)\n\n(add-tag! :foo\n  (fn [args context-map]\n    (str "foo " (first args))))\n\n(render "{% foo quux %} {% foo baz %}" {})\n=>"foo quux foo baz"\n```\nit\'s also possible to add block tags. When adding a block tag, the handler\nfunction should accept the tag arguments, the context map, and the content.\nThe content will be keyed on the opening tag name as can be seen below:\n\n```clojure\n(add-tag! :uppercase\n          (fn [args context-map content]\n            (.toUpperCase (get-in content [:uppercase :content])))\n          :enduppercase)\n\n(render "{% uppercase %}foo {{bar}} baz{% enduppercase %}" {:bar "injected"})\n=>"FOO INJECTED BAZ"\n```\n### Built-in Tags\n\n#### include\n\nreplaces itself with the contents of the referenced template\n\n`{% include "path/to/comments.html" %}`\n\noptionally, you can supply default arguments any tags matching these will have the `default` filter applied using the value supplied:\n\n`{% include "templates/inheritance/child.html" with name="Jane Doe" greeting="Hello!" %}`\n\n#### block\n\nAllows specifying a block of content that can be overwritten using the template inheritance discussed below.\n\n`{% block foo %}This text can be overridden later{% endblock %}`\n\n#### cycle\n\nWill cycle through the supplied values.\n\n```\n(render "{% for i in items %}<li class={% cycle \\"blue\\" \\"white\\" %}>{{i}}</li>{% endfor %}"\n        {:items (range 5)})\n```\n=>\n```\n"<li class=\\"blue\\">0</li><li class=\\"white\\">1</li><li class=\\"blue\\">2</li><li class=\\"white\\">3</li><li class=\\"blue\\">4</li>"\n```\n\n#### debug\n\nPretty prints the context map passed to the template using [json-html](https://github.com/yogthos/json-html).\n\n ```\n (render "{% debug %}" {:foo :bar})\n ```\n =>\n ```\n <div class="jh-root">\n  <table class="jh-type-object">\n   <tbody><tr><th class="jh-key jh-object-key"><span class="jh-type-string">:foo</span></th>\n     <td class="jh-value jh-object-value"><span class="jh-type-string">:bar</span></td></tr>\n   </tbody>\n  </table>\n </div>\n ```\n\n#### extends\n\nThis tag is used to reference a parent template. The blocks in parents are recursively overridden by\nthe blocks from child templates.\n\n* Note: child templates can **only** contain blocks. Any tags or text outside the blocks will be\nignored!\n\nFor example, say we have a base template called `base.html` and a child template `child.html`:\n\n```xml\n<html>\n\t<body>\n\t\t{% block foo %}This text can be overridden later{% endblock %}\n\t</body>\n</html>\n```\n\n```xml\n{% extends "base.html" %}\n{% block foo %}<p>This text will override the text in the parent</p>{% endblock %}\n```\n\n#### if\n\nIt\'s an `if` -- only render the body if the conditional is true.\n\n`{% if condition %}yes!{% endif %}`\n\n`{% if not condition %}yes!{% endif %}`\n\n`{% if condition %}yes!{% else %}no!{% endif %}`\n\nit\'s possible to use `any` and `all` operators to check multiple values:\n\n`(render "{% if any foo bar baz %}hello{% endif %}" {:bar "foo"})`\n\n`(render "{% if not any foo bar baz %}hello{% endif %}" {})`\n\n`(render "{% if all foo bar %}hello{% endif %}" {:foo "foo" :bar "bar"})`\n\nnumeric comparisons are also supported using the `=`, `<`, `>`, `<=` and `>=` operators\n\n`(render "{% if 5 >= x %}yes!{% endif %}" {:x 3})`\n\n`(render "{% if x <= y %}yes!{% endif %}" {:x 3 :y 5})`\n\n`(render "{% if x = 5.0 %}yes!{% else %}no!{% endif %}" {:x 5})`\n\n`(render "{% if x > 5 %}yes!{% else %}no!{% endif %}" {:x 6})`\n\n`(render "{% if vals|length <= 3 %}yes!{% else %}no!{% endif %}" {:vals (range 3)})`\n\n\nfilters work for the conditions:\n\n```clojure\n(add-filter! :empty? empty?)\n(render "{% if files|empty? %}no files{% else %}files{% endif %}"\n  {:files []})\n```\n\n#### ifequal\nOnly render the body if the two args are equal (according to clojure.core/=).\n\n`{% ifequal foo bar %}yes!{% endifequal %}`\n\n`{% ifequal foo bar %}yes!{% else %}no!{% endifequal %}`\n\n`{% ifequal foo "this also works" %}yes!{% endifequal %}`\n\n#### ifunequal\nOnly render the body if the two args are unequal (according to clojure.core/=).\n\n`{% ifunequal foo bar %}yes!{% endifunequal %}`\n\n**for/endfor** *block*\n\n#### for\nRender the body one time for each element in the list. Each render will introduce the following variables into the context:\n\n* `forloop.first`\n* `forloop.last`\n* `forloop.counter`\n* `forloop.counter0`\n* `forloop.revcounter`\n* `forloop.revcounter0`\n* `forloop.length`\n\n`{% for x in some-list %}element: {{x}} first? {{forloop.first}} last? {{forloop.last}}{% endfor %}`\n\nyou can iterate over nested data structures, eg:\n\n`{% for item in items %} <tr><td>{{item.name}}</td><td>{{item.age}}</td></tr> {% endfor %}`\n\narray elements can be destructured in for loops:\n\n`(render "{% for x,y in items %}{{x}},{{y}}{% endfor %}" {:items [["a" "b"] ["c" "d"]]})` => `"a,bc,d"`\n\nyou can also specify the default content if there are no items using the `{% empty %}` tag:\n\n`(render "{% for i in foo %} {{i}} {% empty %}no elements{% endfor %}" {})` => `"no elements"`\n\nfilters can be used inside the for loop:\n\n`(render "{% for x in foo.bar|sort %}{{x}}{% endfor %}" {:foo {:bar [1 4 3 5]}})` => `"1345"`\n\n\n#### sum\nSums multiple variables together\n`(render "{% sum foo bar baz %}" {:foo 3 :bar 2 :baz 1})` => `"6"`\n\n#### now\nrenders current time\n\n`(render (str "{% now \\"dd MM yyyy\\" %}") {})` => `"\\"01 08 2013\\""`\n\n#### comment\nignores any content inside the block\n\n`(render "foo bar {% comment %} baz test {{x}} {% endcomment %} blah" {})` => `"foo bar  blah"`\n\nA short form is also available:\n\n`(render "foo bar {# baz test {{x}} #} blah" {})` => `"foo bar  blah"`\n\n#### firstof\nrenders the first occurance of supplied keys that doesn\'t resolve to false:\n\n`(render "{% firstof var1 var2 var3 %}" {:var2 "x" :var3 "not me"})` => `"x"`\n\n<h4>\n<a name="user-content-safe-tag" class="anchor" href="#safe-tag" aria-hidden="true"><span class="octicon octicon-link"></span></a>safe</h4>\n\nsafe tag will prevent escaping of any content inside it:\n\n`(render "{% safe %}{{foo|upper}}{% endsafe %}" {:foo "<foo>"})` => `<FOO>`\n\nNote, the escaping of variables can also be controlled through the dynamic binding of `selmer.util/*escape-variables`.\n\n#### script\n\nThe script tag will generate an HTML script tag and prepend the value of the `selmer/context` key\nto the URI. When `selmer/context` key is not present then the original URI is set.\n\n`(render "{% script \\"/js/site.js\\" %}" {:selmer/context "/myapp"})` =>\n```\n"<script src=\\"/myapp/js/site.js\\" type=\\"text/javascript\\"></script>"\n```\n\nSince 1.11.1 URI can be a name of context parameter with optional filters.\n\n`(render "{% script path %}" {:selmer/context "/myapp" :path "/js/site.js"})` =>\n```\n"<script src=\\"/myapp/js/site.js\\" type=\\"text/javascript\\"></script>"\n```\n\n`(render "{% script path|upper %}" {:selmer/context "/myapp" :path "/js/site.js"})` =>\n```\n"<script src=\\"/myapp/JS/SITE.JS\\" type=\\"text/javascript\\"></script>"\n```\n#### style\n\nThe style tag will generate an HTML style tag and prepend the value of the `selmer/context` key\nto the URI. When `selmer/context` key is not present then the original URI is set.\n\n`(render "{% style \\"/css/screen.css\\" %}" {:selmer/context "/myapp"})` =>\n```\n"<link href=\\"/myapp/css/screen.css\\" rel=\\"stylesheet\\" type=\\"text/css\\" />"\n```\n\nSince 1.11.1 URI can be a name of context parameter with optional filters.\n\n`(render "{% style path %}" {:selmer/context "/myapp" :path "/css/screen.css"})` =>\n```\n"<link href=\\"/myapp/css/screen.css\\" rel=\\"stylesheet\\" type=\\"text/css\\" />"\n```\n\n`(render "{% style path|upper %}" {:selmer/context "/myapp" :path "/css/screen.css"})` =>\n```\n"<link href=\\"/myapp/CSS/SCREEN.CSS\\" rel=\\"stylesheet\\" type=\\"text/css\\" />"\n```\n#### verbatim\nprevents any tags inside from being parsed:\n\n`(render "{% verbatim %}{{if dying}}Still alive.{{/if}}{% endverbatim %}" {})` => `"{{if dying}}Still alive.{{/if}}"`\n\n#### with\ninjects the specified keys into the context map:\n\n`(render "{% with total=business.employees|count %}{{ total }}{% endwith %}" {:business {:employees (range 5)}})` => `"5 employees"`\n\n## Template Inheritance\n\n### Extending Templates\n\nTemplates can inherit from other templates using the `extends` tag. When extending a template, any blocks in the parent\nwill be overwritten by blocks from the child with the same name. For example if we had the following scenario:\n\n`base.html`\n\n```xml\n<html>\n<body>\n{% block header %}\n{% endblock %}\n\n{% block content %}\n{% endblock %}\n\n{% block footer %}\n{% endblock %}\n</body>\n</html>\n```\n\n`child-a.html`\n\n```xml\n{% extends "base.html" %}\n{% block header %}\n<h1>child-a header</h1>\n{% endblock %}\n\n{% block footer %}\n<p>footer</p>\n{% endblock %}\n```\n\n`child-b.html`\n\n```xml\n{% extends "child-a.html" %}\n{% block header %}\n<h1>child-b header</h1>\n{% endblock %}\n\n{% block content %}\nSome content\n{% endblock %}\n```\n\nIf we called `(render-file "child-b.html" {})` then the compiled template would look as follows:\n\n```xml\n<html>\n<body>\n{% block header %}\n<h1>child-b header</h1>\n{% endblock %}\n{% block content %}\nSome content\n{% endblock %}\n\n{% block footer %}\n<p>footer</p>\n{% endblock %}\n</body>\n</html>\n```\n\nIt\'s also possible to include content from the parent block using the `{{block.super}}` hint. If we change `child-b.html`\nto look as follows:\n\n```xml\n{% extends "child-a.html" %}\n{% block header %}\n{{block.super}}\n<h1>child-b header</h1>\n{% endblock %}\n\n{% block content %}\nSome content\n{% endblock %}\n```\n\nThen we\'d have the following output:\n\n```xml\n<html>\n<body>\n{% block header %}\n\n<h1>child-a header</h1>\n\n<h1>child-b header</h1>\n{% endblock %}\n{% block content %}\nSome content\n{% endblock %}\n\n{% block footer %}\n<p>footer</p>\n{% endblock %}\n</body>\n</html>\n```\n\n### Including Templates\n\nTemplates can also `include` other templates. In this case the contents of the child are simply spliced in place\nof the tag:\n\n`base.html`\n\n```xml\n<html>\n{% include "content.html" %}\n</html>\n```\n\n`content.html`\n\n```xml\n<body>content</body>\n```\n\nresults in:\n\n```xml\n<html>\n<body>content</body>\n</html>\n```\n\nIt\'s also possible to specify default values for the included templates using\n`with`:\n\n`base.html`\n\n```xml\n<html>\n{% include "content.html" with content="some content" %}\n</html>\n```\n\n`content.html`\n\n```xml\n<body>{{content}}</body>\n```\n\nresults in:\n\n```xml\n<html>\n<body>{{content|default:"some content"}}</body>\n</html>\n```\n\nYou may also specify more than one value:\n\n`base.html`\n\n```xml\n<html>\n{% include "content.html" with content="some content" url="/path/to/page" %}\n</html>\n```\n\n\n## Missing values\n\nMissing values are by default rendered as an empty string:\n\n```clojure\n(render "{{missing}}" {})\n=> ""\n```\nThe same goes for for loops:\n```clojure\n(parser/render "{% for e in items %}{% endfor %}" {})\n=> ""\n```\n\nIt is possible to overwrite this behavior to output a different value when encountering a mising value. This is done by calling `selmer.util/set-missing-value-formatter!` to provide a function that produces the desired output.\n\n`set-missing-value-formatter!` takes a function of two arguments, a map of info about the tag and the context map, which is called on a missing value. The function should return the value to be output in place of an empty string (which is the default from \'default-missing-value-formatter\').\n\n\n```clojure\n(defn missing-value-fn [tag context-map]\n  (str "<Missing value: " (or (:tag-value tag) (:tag-name tag)) ">"))\n\n(selmer.util/set-missing-value-formatter! missing-value-fn)\n\n(selmer.parser/render "{{not-here}}" {})\n=> "<Missing value: not-here>"\n```\n\nor you can throw an exception:\n\n```clojure\n(defn missing-value-fn [tag context-map]\n  (throw (Exception. "Nope")))\n\n(selmer.util/set-missing-value-formatter! missing-value-fn)\n\n(selmer.parser/render "{{not-here}}" {}) => Exception: Nope\n```\n\nWhen you set a custom missing value handler, by default filters are bypassed for missing values:\n\n```clojure\n(defn missing-value-fn [tag context-map]\n  (str "<Missing value: " (or (:tag-value tag) (:tag-name tag)) ">"))\n\n(selmer.util/set-missing-value-formatter! missing-value-fn)\n\n(selmer.parser/render "{{not-here|count}}" {})\n=> "<Missing value: not-here>"\n```\n\nbut this can be overwritten so filters are evaluated for missing values:\n\n```clojure\n(defn missing-value-fn [tag context-map]\n  (str "<Missing value: " (or (:tag-value tag) (:tag-name tag)) ">"))\n\n(selmer.util/set-missing-value-formatter! missing-value-fn :filter-missing-values true)\n\n(selmer.parser/render "{{not-here|count}}" {})\n=> "0"\n```\n\nAlthough for most use cases, this will not make sense.\n\n## Internationalization\n\nWhile there is no built in support for internationalization, it can be added via a custom tag.\nThe following example uses the [tongue](https://github.com/tonsky/tongue) library to implement\nthe `i18n` tag:\n\n```clojure\n(require \'[tongue.core :as tongue]\n         \'[selmer.parser :as parser])\n\n(def translate\n  ;; [locale key & args] => string\n  (tongue/build-translate\n    {:en {:animals\n          {:dog "dog"\n           :cat "cat"}}\n     :fr {:animals\n          {:dog "chien"\n           :cat "chat"}}}))\n\n(parser/add-tag! :i18n\n  (fn [[k] context]\n    (->> k (keyword) (translate (or (:i18n/locale context) :en)))))\n\n(parser/render "{% i18n animals/dog %}" {})\n;=> "dog"\n(parser/render "{% i18n animals/dog %}" {:i18n/locale :fr})\n;=> "chien"\n```\n\n[**Back To Top \xe2\x87\xa7**](#selmer)\n\n## License\n\nCopyright \xc2\xa9 2015 Dmitri Sotnikov\n\nDistributed under the Eclipse Public License, the same as Clojure.\n'