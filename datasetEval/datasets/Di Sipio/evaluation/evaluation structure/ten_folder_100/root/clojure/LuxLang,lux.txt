b'## What is Lux?\n\nLux is a new programming language in the making.\n\nIt\'s meant to be a functional, statically-typed Lisp that will run on several platforms, such as the Java Virtual Machine and JavaScript interpreters.\n\n### What\'s the current version?\n\n0.5.0\n\n### How far ahead is the project?\n\nLux is in the **beta** stage.\n\nThe JVM compiler is pretty stable and the standard library has grown to a respectable size.\n\nAlso, new experimental support for Android has been added.\n\n### How can I use it?\n\nYou should use the Leiningen plugin for Lux to compile your programs and manage your dependencies.\n\nYou can find it here: https://github.com/LuxLang/lux/tree/master/lux-lein\n\nAfter compiling your program, this will generate a directory named "target" and put all the .class files there.\n\nThen, you can run the program like this:\n\n\tjava -jar target/jvm/program.jar\n\n### Sample\n\nTo take a look at sample Lux projects, check these repositories:\n\n* https://github.com/LuxLang/tutorial1\n* https://github.com/LuxLang/lux/tree/master/luxdoc\n\nThe `luxdoc` program was actually used to generate the documentation for the standard library (located here: https://luxlang.github.io/lux/)\n\n### What\'s the license?\n\n[Custom License](license.txt)\n\nRead carefully before using this project, as the license disallows commercial use, and has other conditions which may be undesirable for some.\n\n## What\'s interesting about the language?\n\n### Inspirations\n\nThe language is mostly inspired by the following 3 languages:\n\n* Haskell (functional programming)\n* Clojure (syntax, overall look & feel)\n* ML (module system)\n\nThe compiler is even implemented in Clojure.\n\n### Types\n\nThey are implemented as plain-old data-structures whose expressions get eval\'ed by the compiler and integrated into the type-checker.\n\nThat means it\'s actually possible to generate types via functions and macros.\n\n### Module system\n\nThe module system is heavily inspired by ML, and both signatures and structures are supported.\n\nThe main difference between Lux and ML is that ML separates signatures and structures from the rest of the language, whereas Lux implements them on top of the base language.\n\nHow?\n\nBy implementing signatures as record-types and structures as actual records.\n\n##### But, why not just use type-classes?\n\nHaskell\'s type-class system forces the user to only specify 1 instance for any given type-class and its argument.\n\nIf there are more than 1 possible valid instances (as is the case for Monoid of Int), you have to resort to _newtype hacks_ to be able to provide alternative implementations.\n\nBy using a system like ML\'s, that problem is averted.\n\nAdditionally, by hosting the module system on top of records, which are regular values, you get the further benefit that structures can be parameterized at run-time just like any other value.\n\nYou can also write functions that take and return structures (as _functors_ do in ML), and you can generate structures on the fly.\n\n> Also, Lux now offers a mechanism for easy polymorphism, just like Haskell\'s type-classes, but built upon it\'s module system, thanks to the `lux/type/auto` module and its `:::` macro.\n\n> You can learn more about that by reading the book and the documentation.\n\n### Functional programming\n\nWhile the means to do Java-interop are provided, Lux is commited to functional programming.\n\nFunctions are curried and partial application is as simple as just applying a function to less arguments than it needs (as in Haskell).\n\ne.g.\n\n\t(map (i.+ 1) (list 1 2 3 4 5))\n\n### Macros\n\nUnlike in most other lisps, Lux macros are monadic.\n\nThe **(Lux a)** type is the one responsible for the magic by threading **Compiler** instances through macros.\n\nYou can use **macro:** to define these monadic macros.\n\nAlternatively, you can use the **syntax:** macro, which also offers monadic parsing of Code tokens for convenience.\n\n### Custom pattern-matching\n\n##### Wait... wut?\n\nCustom pattern-matching basically means that you can use macros to provide custom syntax and features on top of the pattern-matching macro `case`.\n\nFor instance, the **list** and **list&** macros are used to build lists.\nBut you can also use them to destructure lists inside pattern-matching:\n\n\t(case (: (List Int) (list 1 2 3))\n\t  (#Cons x (#Cons y (#Cons z #Nil)))\n\t  (#Some ($_ i.* x y z))\n\n\t  _\n\t  #None)\n\n\t(case (: (List Int) (list 1 2 3))\n\t  (^ (list x y z))\n\t  (#Some ($_ i.* x y z))\n\n\t  _\n\t  #None)\n\nThere is also the special **^or** macro, which introduces *or patterns*:\n\n\t(type: Weekday\n\t  #Monday\n\t  #Tuesday\n\t  #Wednesday\n\t  #Thursday\n\t  #Friday\n\t  #Saturday\n\t  #Sunday))\n\n\t(def: (weekend? day)\n\t  (-> Weekday Bool)\n\t  (case day\n\t    (^or #Saturday #Sunday)\n\t    true\n\n\t    _\n\t    false))\n\n> Please note: ^ and ^or are just macros like any other and anyone can implement them.\n\n### Is there a community for this?\n\nCome join the forum at: http://luxlang.freeforums.net/\n\nIf you want to communicate with me directly, just email me at luxlisp@gmail.com\n\n### How can I edit Lux code?\n\nCheck out the Emacs plugin for it: https://github.com/LuxLang/lux/tree/master/lux-mode\n\n### Where do I learn Lux?\n\nThe main resource is the book: https://www.gitbook.com/book/luxlang/the-lux-programming-language/details\n\nIt will always be up-to-date with the latest stable version of the language.\n\nAlso, you can check out the documentation for the currently available modules: https://luxlang.github.io/lux/\n\n### How can I contribute?\n\nFor starters, you can check out the Trello board for Lux development: https://trello.com/b/VRQhvXjs/lux-jvm-compiler\n\nI\'ll be putting there tasks that people can contribute to; both in the compiler and outside (like plugins for editors).\n\nWriting libraries in Lux will also help a lot in making this a more practical language for day to day use.\n\n##### Copyright (c) 2014-2018 Eduardo Julian. All rights reserved.\n'