b'# rebel-readline\n\n[![Clojars Project](https://img.shields.io/clojars/v/com.bhauman/rebel-readline.svg)](https://clojars.org)\n[![Clojars Project](https://img.shields.io/clojars/v/com.bhauman/rebel-readline-cljs.svg)](https://clojars.org/com.bhauman/rebel-readline-cljs)\n\nA terminal readline library for Clojure Dialects\n\n[![asciicast](https://asciinema.org/a/160597.png)](https://asciinema.org/a/160597)\n\n## Why create a terminal readline library?\n\nhttps://github.com/bhauman/rebel-readline/blob/master/rebel-readline/doc/intro.md\n\n## Important note!!!\n\nThe line reader will attempt to manipulate the terminal that initiates\nthe JVM process. For this reason it is important to start your JVM in\na terminal.\n\nThat means you should launch your Java process using the\n\n * the java command\n * the Clojure `clojure` tool (without readline support)\n * lein trampoline\n * boot - would need to run in boot\'s worker pod\n\nLaunching the terminal readline process from another Java process will not work.\n\nIt\'s best to not launch this readline behind other readline tools like `rlwrap`.\n\n## Quick try\n\n#### Clojure tools\n\nIf you want to try this really quickly\n[install the Clojure CLI tools](https://clojure.org/guides/getting_started)\nand then invoke this:\n\n```shell\nclojure -Sdeps "{:deps {com.bhauman/rebel-readline {:mvn/version \\"0.1.4\\"}}}" -m rebel-readline.main\n```\n\nThat should start a Clojure REPL that takes its input from the Rebel readline editor.\n\nNote that I am using the `clojure` command and not the `clj` command\nbecause the latter wraps the process with another readline program (rlwrap).\n\nAlternatively you can specify an alias in your `$HOME/.clojure/deps.edn`\n\n```clojure\n{\n ...\n :aliases {:rebel {:extra-deps {com.bhauman/rebel-readline {:mvn/version "0.1.4"}}\n                   :main-opts  ["-m" "rebel-readline.main"]}}\n}\n```\n\nAnd then run with a simpler:\n\n```shell\n$ clojure -A:rebel\n```\n\n#### Leiningen\n\nAdd `[com.bhauman/rebel-readline "0.1.4"]` to the dependencies in your\n`project.clj` then start a REPL like this:\n\n```shell\nlein trampoline run -m rebel-readline.main\n```\n\nAlternatively, you can add rebel-readline globally to `$HOME/.lein/profiles.clj`\n\n```clojure\n{\n ...\n :user {:dependencies [[com.bhauman/rebel-readline "0.1.4"]]}\n}\n```\n\nThen you can call\n\n```shell\nlein trampoline run -m rebel-readline.main\n```\n\nTo make this less verbose you can use an alias in your `project.clj`:\n\n```clojure\n{\n ...\n :aliases {"rebl" ["trampoline" "run" "-m" "rebel-readline.main"]}\n}\n```\n\nAlternatively, you can do this globally in `$HOME/.lein/profiles.clj`:\n\n```clojure\n{\n ...\n :user {:aliases {"rebl" ["trampoline" "run" "-m" "rebel-readline.main"]}}\n}\n```\n\nNow you can start a rebel-readline REPL with `lein rebl`.\n\n#### Boot\n\n```\nboot -d com.bhauman/rebel-readline call -f rebel-readline.main/-main\n```\n\n#### Clone repo\n\nClone this repo and then from the `rebel-readline` sub-directory\ntyping `lein trampoline run -m rebel-readline.main` will get you into\na Clojure REPL with the readline editor working.\n\nNote that `lein run -m rebel-readline.main` will not work! See above.\n\n## How do I default to vi bindings?\n\nIn `~/.clojure/rebel_readline.edn` put\n\n```\n{:key-map :viins}\n```\n\n## Config\n\nIn `~/.clojure/rebel_readline.edn` you can provide a map with the\nfollowing options:\n\n```\n:key-map         - either :viins or :emacs. Defaults to :emacs\n\n:color-theme     - either :light-screen-theme or :dark-screen-theme\n\n:highlight       - boolean, whether to syntax highlight or not. Defaults to true\n\n:completion      - boolean, whether to complete on tab. Defaults to true\n\n:eldoc           - boolean, whether to display function docs as you type.\n                   Defaults to true\n\n:indent          - boolean, whether to auto indent code on newline. Defaults to true\n\n:redirect-output - boolean, rebinds root *out* during read to protect linereader\n                   Defaults to true\n                   \n:key-bindings    - map of key-bindings that get applied after all other key \n                   bindings have been applied\n```\n\n#### Key binding config\n\nYou can configure key bindings in the config file, but your milage may vary.\n\nExample:\n\n```\n{ \n...\n:key-bindings { :emacs [["^D" :clojure-doc-at-point]] \n                :viins [["^J" :clojure-force-accept-line]] }\n}\n```\n\nSerialized keybindings are tricky and the keybinding strings are translated with\n`org.jline.keymap.KeyMap/translate` which is a bit peculiar in how it translates things.\n\nIf you want literal characters you can use a list of chars or ints i.e\n`(\\\\ \\d)` instead of the serialized key names. So you can use `(4 4)` inplace of `"^D^D"`.\n\nThe best way to look up the available widget names is to use the `:repl/key-bindings`\ncommand at the REPL prompt.\n\nNote: I have found that JLine handles control characters and\nalphanumeric characters quite well but if you want to bind special\ncharacters you shouldn\'t be surprised if it doesn\'t work.\n\n## Quick Lay of the land\n\nYou should look at `rebel-readline.clojure.main` and `rebel-readline.core`\nto give you top level usage information.\n\nThe core of the functionality is in\n`rebel-readline.clojure.line-reader` everything else is just support.\n\n## Quick Usage\n\nThese are some quick examples demonstrating how to use the rebel-readline\nAPI.\n\nThe main way to utilize this readline editor is to replace the\n`clojure.main/repl-read` behavior in `clojure.main/repl`.\n\nThe advantage of doing this is that it won\'t interfere with the input\nstream if you are working on something that needs to read from\n`*in*`. This is because the line-reader will only be engaged when the\nREPL loop is reading.\n\nExample:\n\n```clojure\n(rebel-readline.core/with-line-reader\n  (rebel-readline.clojure.line-reader/create\n    (rebel-readline.clojure.service.local/create))\n  (clojure.main/repl\n     :prompt (fn []) ;; prompt is handled by line-reader\n     :read (rebel-readline.clojure.main/create-repl-read)))\n```\n\nAnother option is to just wrap a call you your REPL with\n`rebel-readline.core/with-readline-in` this will bind `*in*` to an\ninput-stream that is supplied by the line reader.\n\n```clojure\n(rebel-readline.core/with-readline-in\n  (rebel-readline.clojure.line-reader/create\n    (rebel-readline.clojure.service.local/create))\n  (clojure.main/repl :prompt (fn[])))\n```\n\nOr with a fallback:\n\n```clojure\n(try\n  (rebel-readline.core/with-readline-in\n    (rebel-readline.clojure.line-reader/create\n      (rebel-readline.clojure.service.local/create))\n    (clojure.main/repl :prompt (fn[])))\n  (catch clojure.lang.ExceptionInfo e\n    (if (-> e ex-data :type (= :rebel-readline.jline-api/bad-terminal))\n      (do (println (.getMessage e))\n        (clojure.main/repl))\n      (throw e))))\n```\n\n## Services\n\nThe line reader provides features like completion, documentation,\nsource, apropos, eval and more. The line reader needs a Service to\nprovide this functionality.\n\nWhen you create a `rebel-readline.clojure.line-reader`\nyou need to supply this service.\n\nThe more common service is the\n`rebel-readline.services.clojure.local` which uses the\nlocal clojure process to provide this functionality and its a good\nexample of how a service works.\n\nhttps://github.com/bhauman/rebel-readline/blob/master/rebel-readline/src/rebel_readline/clojure/service/local.clj\n\nIn general, it\'s much better if the service is querying the Clojure process\nwhere the eventual REPL eval takes place.\n\nHowever, the service doesn\'t necessarily have to query the same\nenvironment that the REPL is using for evaluation. All the editing\nfunctionality that rebel readline provides works without an\nenvironment to query. And the apropos, doc and completion functionality is\nstill sensible when you provide those abilities from the local clojure process.\n\nThis could be helpful when you have a Clojurey REPL process and you\ndon\'t have a Service for it. In this case you can just use a\n`clojure.service.local` or a `clojure.service.simple` service. If you\ndo this you can expect less than optimal results but multi-line\nediting, syntax highlighting, auto indenting will all work just fine.\n\n## Key-bindings\n\n**Bindings of interest**\n\n* Ctrl-C => aborts editing the current line\n* Ctrl-D at the start of a line => sends an end of stream message\n  which in most cases should quit the REPL\n\n* TAB => word completion or code indent if the cursor is in the whitespace at the\n  start of a line\n* Ctrl-X_Ctrl-D => Show documentation for word at point\n* Ctrl-X_Ctrl-S => Show source for word at point\n* Ctrl-X_Ctrl-A => Show apropos for word at point\n* Ctrl-X_Ctrl-E => Inline eval for SEXP before the point\n\nYou can examine the key-bindings with the `:repl/key-bindings` command.\n\n## Commands\n\nThere is a command system. If the line starts with a "repl" namespaced\nkeyword then the line-reader will attempt to interpret it as a command.\n\nType `:repl/help` or `:repl` TAB to see a list of available commands.\n\nYou can add new commands by adding methods to the\n`rebel-readline.commands/command` multimethod. You can add\ndocumentation for the command by adding a method to the\n`rebel-readline.commands/command-doc` multimethod.\n\n## CLJS\n\nSee https://github.com/bhauman/rebel-readline/tree/master/rebel-readline-cljs\n\n## nREPL, SocketREPL, pREPL?\n\nServices have not been written for these REPLs yet!!\n\nBut you can use the `rebel-readline.clojure.service.simple` service in the meantime.\n\n## Contributing\n\nPlease contribute!\n\nI\'m trying to mark issues with `help wanted` for issues that I feel\nare good opportunities for folks to help out. If you want to work on\none of these please mention it in the issue.\n\nIf you do contribute:\n\n* if the change isn\'t small please file an issue before a PR.\n* please put all PR changes into one commit\n* make small grokable changes. Large changes are more likely to be\n  ignored and or used as a starting issue for exploration.\n* break larger solutions down into a logical series of small PRs\n* mention it at the start, if you are filing a PR that is more of an\n  exploration of an idea\n\nI\'m going to be more open to repairing current behavior than I will be\nto increasing the scope of rebel-readline.\n\nI will have a preference for creating hooks so that additional functionality\ncan be layered on with libraries.\n\nIf you are wanting to contribute but don\'t know what to work on reach\nout to me on the clojurians slack channel.\n\n## License\n\nCopyright \xc2\xa9 2018 Bruce Hauman\n\nDistributed under the Eclipse Public License either version 1.0 or (at\nyour option) any later version.\n'