b'# defun\n\nA macro to define clojure functions with pattern matching just as erlang or elixir. It supports both clojure and clojurescript.\n\n## News\n\n* **Since 0.3.0-RC1, `defun` namespace is renamed to `defun.core` .**\n\n## Usage\n\nDependency in leiningen:\n\n``` clj\n    [defun "0.3.1"]\n```\n\n### Basic usage\n\nRequire `defun.core` in clojure:\n\n```clj\n(require \'[defun.core :refer [defun]])\n```\n\nOr `refer-macros` in clojurescript:\n\n```cljs\n(ns cljs-test\n  (:require  [defun.core :refer-macros [defun]])\n(enable-console-print!)\n```\n\n**Since 0.3.0-RC, `defun` namespace is renamed to `defun.core` .**\n\nTry to define function just like `defn`:\n\n``` clj\n(defun hello\n   "hello world"\n   [name] (str "hello," name))\n(hello "defun")\n;; "hello,defun"\n```\n\nSupports variadic arguments, doc, metadata etc. as `defun` too. No supprises?\n\nThe fun thing is coming, let\'s say hi to people:\n\n``` clj\n(defun say-hi\n  ([:dennis] "Hi,good morning, dennis.")\n  ([:catty] "Hi, catty, what time is it?")\n  ([:green] "Hi,green, what a good day!")\n  ([other] (str "Say hi to " other)))\n```\n\nThen calling `say-hi` with different names:\n\n``` clj\n(say-hi :dennis)\n;;  "Hi,good morning, dennis."\n(say-hi :catty)\n;;  "Hi, catty, what time is it?"\n(say-hi :green)\n;;  "Hi,green, what a good day!"\n(say-hi "someone")\n;;  "Say hi to someone"\n```\n\nWe define functions just like Erlang\'s function with parameters pattern match (thanks to [core.match](https://github.com/clojure/core.match)), we don\'t need `if,cond,case` any more, that\'s cool!\n\n### Recursion\n\nLet\'s move on, what about define a recursive function? That\'s easy too:\n\n``` clj\n(defun count-down\n  ([0] (println "Reach zero!"))\n  ([n] (println n)\n     (recur (dec n))))\n```\n\nInvoke it:\n\n``` clj\n(count-down 5)\n;;5\n;;4\n;;3\n;;2\n;;1\n;;Reach zero!\nnil\n```\n\nAn accumulator from zero to number `n`:\n\n``` clj\n    (defun accum\n      ([0 ret] ret)\n      ([n ret] (recur (dec n) (+ n ret)))\n      ([n] (recur n 0)))\n\n\t (accum 100)\n\t ;;5050\n```\n\nA fibonacci function:\n\n``` clj\n(defun fib\n    ([0] 0)\n    ([1] 1)\n    ([n] (+ (fib (- n 1)) (fib (- n 2)))))\n```\n\nOutput:\n\n``` clj\n(fib 10)\n;; 55\n```\n\nOf course it\'s not tail recursive, but it\'s really cool, isn\'t it?\n\n### Guards\n\nAdded a guard function to parameters:\n\n``` clj\n(defun funny\n  ([(N :guard #(= 42 %))] true)\n  ([_] false))\n\n(funny 42)\n;;  true\n(funny 43)\n;; false\n```\n\nAnother function to detect if longitude and latitude values are both valid:\n\n``` clj\n(defun valid-geopoint?\n    ([(_ :guard #(and (> % -180) (< % 180)))\n      (_ :guard #(and (> % -90) (< % 90)))] true)\n    ([_ _] false))\n\n(valid-geopoint? 30 30)\n;; true\n(valid-geopoint? -181 30)\n;; false\n```\n\n### Private defun\n\nOf course, you can use `defun-` to define a function that is private just as `defn-`\n\n### More Patterns\n\nIn fact ,the above `say-hi` function will be expanded to be:\n\n``` clj\n(defn\n say-hi\n {:arglists \'([& args])}\n [& args#]\n (clojure.core.match/match\n  [(vec args#)]\n  [[:dennis]]\n  (do "Hi,good morning, dennis.")\n  [[:catty]]\n  (do "Hi, catty, what time is it?")\n  [[:green]]\n  (do "Hi,green, what a good day!")\n  [[other]]\n  (do (str "Say hi to " other))))\n```\n\nThe argument vector is in fact a pattern in core.match, so we can use all patterns that supported by [core.match](https://github.com/clojure/core.match/wiki/Basic-usage).\n\nFor example, matching literals\n\n``` clj\n(defun test1\n    ([true false] 1)\n    ([true true] 2)\n    ([false true] 3)\n    ([false false] 4))\n\n(test1 true true)\n;; 2\n(test1 false false)\n;; 4\n```\n\nMatching sequence:\n\n``` clj\n(defun test2\n    ([([1] :seq)] :a0)\n    ([([1 2] :seq)] :a1)\n    ([([1 2 nil nil nil] :seq)] :a2))\n\n(test2 [1 2 nil nil nil])\n;; a2\n```\n\nMatching vector:\n\n``` clj\n(defun test3\n    ([[_ _ 2]] :a0)\n    ([[1 1 3]] :a1)\n    ([[1 2 3]] :a2))\n\n(test3 [1 2 3])\n;; :a2\n```\n\nRest Pattern, Map Pattern, Or Pattern etc.\n\nI don\'t want to copy the [core.match\'s wiki](https://github.com/clojure/core.match/wiki/Basic-usage),please visit it by yourself.\n\n### fun and letfun\n\nSince 0.2.0, there are two new macros: `fun` and `letfun`, just like `clojure.core/fn` and `clojure.core/letfn`\n\n``` clojure\n((fun\n    ([[_ _ 2]] :a0)\n    ([[1 1 3]] :a1)\n    ([[1 2 3]] :a2))\n  [1 2 3])\n;; :a2\n\n(letfun [(test3 ([[_ _ 2]] :a0)\n                    ([[1 1 3]] :a1)\n                    ([[1 2 3]] :a2))]\n  (test3 [1 2 3]))\n;; :a2\n```\n\n\n\n## Criterium benchmarking\n\nUses the above function `accum` compared with a normal clojure function:\n\n``` clj\n(require \'[criterium.core :refer [bench]])\n\n(defn accum-defn\n    ([n] (accum-defn 0 n))\n    ([ret n] (if (= n 0) ret (recur (+ n ret) (dec n)))))\n\n(defun accum-defun\n  ([0 ret] ret)\n  ([n ret] (recur (dec n) (+ n ret)))\n  ([n] (recur n 0)))\n\n(bench (accum-defn 10000))\n;;Evaluation count : 106740 in 60 samples of 1779 calls.\n;;             Execution time mean : 578.777537 \xc2\xb5s\n;;    Execution time std-deviation : 23.354350 \xc2\xb5s\n;;   Execution time lower quantile : 552.627735 \xc2\xb5s ( 2.5%)\n;;   Execution time upper quantile : 637.001868 \xc2\xb5s (97.5%)\n;;                   Overhead used : 17.111650 ns\n\n(bench (accum-defun 10000))\n;;Evaluation count : 54660 in 60 samples of 911 calls.\n;;             Execution time mean : 1.115643 ms\n;;    Execution time std-deviation : 32.916487 \xc2\xb5s\n;;   Execution time lower quantile : 1.078117 ms ( 2.5%)\n;;   Execution time upper quantile : 1.180711 ms (97.5%)\n;;                   Overhead used : 17.111650 ns\n```\n\naccum-defn is faster than accum-defun. Pattern matching does have a tradeoff.\n\n## Contributors\n\nThanks .\n\n- [kgann](https://github.com/kgann)\n- [danielcompton](https://github.com/danielcompton)\n- [Sander Dijkhuis](https://github.com/sander)\n\n## License\n\nCopyright \xc2\xa9 2014 [Dennis Zhuang](mailto:killme2008@gmail.com)\n\nDistributed under the Eclipse Public License either version 1.0 or (at\n\nyour option) any later version.\n'