b'<a href="https://www.taoensso.com" title="More stuff by @ptaoussanis at www.taoensso.com">\n<img src="https://www.taoensso.com/taoensso-open-source.png" alt="Taoensso open-source" width="400"/></a>\n\n**[CHANGELOG]** | [API] | current [Break Version]:\n\n```clojure\n[com.taoensso/carmine "2.19.1"]       ; Stable\n[com.taoensso/carmine "2.20.0-beta2"] ; See CHANGELOG for details\n```\n\n> Please consider helping to [support my continued open-source Clojure/Script work]? \n> \n> Even small contributions can add up + make a big difference to help sustain my time writing, maintaining, and supporting Carmine and other Clojure/Script libraries. **Thank you!**\n>\n> \\- Peter Taoussanis\n\n# Carmine\n\n### A Clojure Redis client & message queue\n\n[Redis] is _awesome_ and it\'s getting [more awesome](http://www.redis.io/commands/eval) [every day](http://redis.io/topics/cluster-spec). It deserves a great Clojure client.\n\n## Features\n * Small, simple **all-Clojure** library\n * **Fully documented**, API with full support for the latest Redis versions\n * **Great performance**\n * Industrial strength **connection pooling**\n * Composable, **first-class command functions**\n * Flexible, high-performance **binary-safe serialization** using [Nippy]\n * Full support for **Lua scripting**, **Pub/Sub**, etc.\n * Full support for custom **reply parsing**\n * **Command helpers** (`atomic`, `lua`, `sort*`, etc.)\n * **Ring session-store**\n * Simple, high-performance **message queue** (v2+, Redis 2.6+)\n * Simple, high-performance **distributed lock** (v2+, Redis 2.6+)\n * Pluggable **compression** and **encryption** support (v2+)\n * Includes _Tundra_, an API for **replicating data to an additional datastore** (v2+, Redis 2.6+)\n\n## 3rd-party tools, etc.\n\nLink                     | Description\n------------------------ | -----------------------------------------------------\n[@lantiga/redlock-clj]   | Distributed locks for uncoordinated Redis clusters\n[@danielsz/system]       | PubSub component for system\nYour link here?          | **PR\'s welcome!**\n\n## Getting started\n\nAdd the necessary dependency to your project:\n\n```clojure\n[com.taoensso/carmine "2.19.1"]\n```\n\nAnd setup your namespace imports:\n\n```clojure\n(ns my-app\n  (:require [taoensso.carmine :as car :refer (wcar)]))\n```\n\n### Connections\n\nYou\'ll usually want to define a single connection pool, and one connection spec for each of your Redis servers.\n\n```clojure\n(def server1-conn {:pool {<opts>} :spec {<opts>}}) ; See `wcar` docstring for opts\n(defmacro wcar* [& body] `(car/wcar server1-conn ~@body))\n```\n\nA simple example spec with default pool and one server using redistogo.com would be:\n\n```clojure\n(def server1-conn {:pool {} :spec {:uri "redis://redistogo:pass@panga.redistogo.com:9475/"}})\n```\n\n### Basic commands\n\nExecuting commands is easy:\n\n```clojure\n(wcar* (car/ping)) ; => "PONG" (1 command -> 1 reply)\n\n(wcar*\n  (car/ping)\n  (car/set "foo" "bar")\n  (car/get "foo")) ; => ["PONG" "OK" "bar"] (3 commands -> 3 replies)\n```\n\nNote that executing multiple Redis commands in a single `wcar` request uses efficient Redis [pipelining] under the hood, and returns a pipeline reply (vector) for easy destructuring, etc.\n\nIf the number of commands you\'ll be calling might vary, it\'s possible to request that Carmine _always_ return a destructurable pipeline-style reply:\n\n```clojure\n(wcar* :as-pipeline (car/ping)) ; => ["PONG"] ; Note the pipeline-style reply\n```\n\nIf the server responds with an error, an exception is thrown:\n\n```clojure\n(wcar* (car/spop "foo"))\n=> Exception ERR Operation against a key holding the wrong kind of value\n```\n\nBut what if we\'re pipelining?\n\n```clojure\n(wcar* (car/set  "foo" "bar")\n       (car/spop "foo")\n       (car/get  "foo"))\n=> ["OK" #<Exception ERR Operation against ...> "bar"]\n```\n\n### Serialization\n\nThe only value type known to Redis internally is the [byte string]. But Carmine uses [Nippy] under the hood and understands all of Clojure\'s [rich datatypes], letting you use them with Redis painlessly:\n\n```clojure\n(wcar* (car/set "clj-key" {:bigint (bigint 31415926535897932384626433832795)\n                           :vec    (vec (range 5))\n                           :set    #{true false :a :b :c :d}\n                           :bytes  (byte-array 5)\n                           ;; ...\n                           })\n       (car/get "clj-key"))\n=> ["OK" {:bigint 31415926535897932384626433832795N\n          :vec    [0 1 2 3 4]\n          :set    #{true false :a :c :b :d}\n          :bytes  #<byte [] [B@4d66ea88>}]\n```\n\nTypes are handled as follows:\n\nClojure type             | Redis type\n------------------------ | --------------------------\nStrings                  | Redis strings\nKeywords                 | Redis strings (v2+)\nSimple numbers           | Redis strings\nEverything else          | Auto de/serialized with [Nippy]\n\nYou can force automatic de/serialization for an argument of any type by wrapping it with `car/serialize`.\n\n### Documentation and command coverage\n\nLike [labs-redis-clojure], Carmine uses the [official Redis command reference] to generate its own command API. Which means that not only is Carmine\'s command coverage *always complete*, but it\'s also **fully documented**:\n\n```clojure\n(use \'clojure.repl)\n(doc car/sort)\n=> "SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]\n\nSort the elements in a list, set or sorted set.\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is currently O(N) as there is a copy step that will be avoided in next releases."\n```\n\n### Lua\n\nRedis 2.6 introduced a remarkably powerful feature: server-side Lua scripting! As an example, let\'s write our own version of the `set` command:\n\n```clojure\n(defn my-set\n  [key value]\n  (car/lua "return redis.call(\'set\', _:my-key, \'lua \'.. _:my-val)"\n                  {:my-key key}   ; Named key variables and their values\n                  {:my-val value} ; Named non-key variables and their values\n                  ))\n\n(wcar* (my-set "foo" "bar")\n       (car/get "foo"))\n=> ["OK" "lua bar"]\n```\n\nScript primitives are also provided: `eval`, `eval-sha`, `eval*`, `eval-sha*`. See the [Lua scripting docs] for more info.\n\n### Helpers\n\nThe `lua` command above is a good example of a Carmine *helper*.\n\nCarmine will never surprise you by interfering with the standard Redis command API. But there are times when it might want to offer you a helping hand (if you want it). Compare:\n\n```clojure\n(wcar* (car/zunionstore "dest-key" 3 "zset1" "zset2" "zset3" "WEIGHTS" 2 3 5))\n(wcar* (car/zunionstore* "dest-key" ["zset1" "zset2" "zset3"] "WEIGHTS" 2 3 5))\n```\n\nBoth of these calls are equivalent but the latter counted the keys for us. `zunionstore*` is another helper: a slightly more convenient version of a standard command, suffixed with a `*` to indicate that it\'s non-standard.\n\nHelpers currently include: `atomic`, `eval*`, `evalsha*`, `info*`, `lua`, `sort*`, `zinterstore*`, and `zunionstore*`. See their docstrings for more info.\n\n### Commands are (just) functions\n\nIn Carmine, Redis commands are *real functions*. Which means you can *use* them like real functions:\n\n```clojure\n(wcar* (doall (repeatedly 5 car/ping)))\n=> ["PONG" "PONG" "PONG" "PONG" "PONG"]\n\n(let [first-names ["Salvatore"  "Rich"]\n      surnames    ["Sanfilippo" "Hickey"]]\n  (wcar* (mapv #(car/set %1 %2) first-names surnames)\n         (mapv car/get first-names)))\n=> ["OK" "OK" "Sanfilippo" "Hickey"]\n\n(wcar* (mapv #(car/set (str "key-" %) (rand-int 10)) (range 3))\n       (mapv #(car/get (str "key-" %)) (range 3)))\n=> ["OK" "OK" "OK" "OK" "0" "6" "6" "2"]\n```\n\nAnd since real functions can compose, so can Carmine\'s. By nesting `wcar` calls, you can fully control how composition and pipelining interact:\n\n```clojure\n(let [hash-key "awesome-people"]\n  (wcar* (car/hmset hash-key "Rich" "Hickey" "Salvatore" "Sanfilippo")\n         (mapv (partial car/hget hash-key)\n               ;; Execute with own connection & pipeline then return result\n               ;; for composition:\n               (wcar* (car/hkeys hash-key)))))\n=> ["OK" "Sanfilippo" "Hickey"]\n```\n\n### Listeners & Pub/Sub\n\nCarmine has a flexible **Listener** API to support persistent-connection features like [monitoring] and Redis\'s fantastic [Publish/Subscribe] facility:\n\n```clojure\n(def listener\n  (car/with-new-pubsub-listener (:spec server1-conn)\n    {"foobar" (fn f1 [msg] (println "Channel match: " msg))\n     "foo*"   (fn f2 [msg] (println "Pattern match: " msg))}\n   (car/subscribe  "foobar" "foobaz")\n   (car/psubscribe "foo*")))\n```\n\nNote the map of message handlers. `f1` will trigger when a message is published to channel `foobar`. `f2` will trigger when a message is published to `foobar`, `foobaz`, `foo Abraham Lincoln`, etc.\n\nPublish messages:\n\n```clojure\n(wcar* (car/publish "foobar" "Hello to foobar!"))\n```\n\nWhich will trigger:\n\n```clojure\n(f1 \'("message" "foobar" "Hello to foobar!"))\n;; AND ALSO\n(f2 \'("pmessage" "foo*" "foobar" "Hello to foobar!"))\n```\n\nYou can adjust subscriptions and/or handlers:\n\n```clojure\n(with-open-listener listener\n  (car/unsubscribe) ; Unsubscribe from every channel (leave patterns alone)\n  (car/psubscribe "an-extra-channel"))\n\n(swap! (:state listener) assoc "*extra*" (fn [x] (println "EXTRA: " x)))\n```\n\n**Remember to close the listener** when you\'re done with it:\n\n```clojure\n(car/close-listener listener)\n```\n\nNote that subscriptions are *connection-local*: you can have three different listeners each listening for different messages, using different handlers. This is great stuff.\n\n### Reply parsing\n\nWant a little more control over how server replies are parsed? You have all the control you need:\n\n```clojure\n(wcar* (car/ping)\n       (car/with-parser clojure.string/lower-case (car/ping) (car/ping))\n       (car/ping))\n=> ["PONG" "pong" "pong" "PONG"]\n```\n\n### Binary data\n\nCarmine\'s serializer has no problem handling arbitrary byte[] data. But the serializer involves overhead that may not always be desireable. So for maximum flexibility Carmine gives you automatic, *zero-overhead* read and write facilities for raw binary data:\n\n```clojure\n(wcar* (car/set "bin-key" (byte-array 50))\n       (car/get "bin-key"))\n=> ["OK" #<byte[] [B@7c3ab3b4>]\n```\n\n### Message queue\n\nRedis makes a great [message queue server]:\n\n```clojure\n(:require [taoensso.carmine.message-queue :as car-mq]) ; Add to `ns` macro\n\n(def my-worker\n  (car-mq/worker {:pool {<opts>} :spec {<opts>}} "my-queue"\n   {:handler (fn [{:keys [message attempt]}]\n               (println "Received" message)\n               {:status :success})}))\n\n(wcar* (car-mq/enqueue "my-queue" "my message!"))\n%> Received my message!\n\n(car-mq/stop my-worker)\n```\n\nGuarantees:\n * Messages are persistent (durable) as per Redis config\n * Each message will be handled once and only once\n * Handling is fault-tolerant: a message cannot be lost due to handler crash\n * Message de-duplication can be requested on an ad hoc (per message) basis. In these cases, the same message cannot ever be entered into the queue more than once simultaneously or within a (per message) specifiable post-handling backoff period.\n\nSee the relevant [API] docs for details.\n\n### Distributed locks\n\n```clojure\n(:require [taoensso.carmine.locks :as locks]) ; Add to `ns` macro\n\n(locks/with-lock\n  {:pool {<opts>} :spec {<opts>}} ; Connection details\n  "my-lock" ; Lock name/identifier\n  1000 ; Time to hold lock\n  500  ; Time to wait (block) for lock acquisition\n  (println "This was printed under lock!"))\n```\n\nAgain: simple, distributed, fault-tolerant, and _fast_.\n\nSee the relevant [API] docs for details.\n\n## Tundra (beta)\n\nRedis is a beautifully designed datastore that makes some explicit engineering tradeoffs. Probably the most important: your data _must_ fit in memory. Tundra helps relax this limitation: only your **hot** data need fit in memory. How does it work?\n\n 1. Use Tundra\'s `dirty` command **any time you modify/create evictable keys**\n 2. Use `worker` to create a threaded worker that\'ll **automatically replicate dirty keys to your secondary datastore**\n 3. When a dirty key hasn\'t been used in a specified TTL, it will be **automatically evicted from Redis** (eviction is optional if you just want to use Tundra as a backup/just-in-case mechanism)\n 4. Use `ensure-ks` **any time you want to use evictable keys** - this\'ll extend their TTL or fetch them from your datastore as necessary\n\nThat\'s it: two Redis commands, and a worker! Tundra uses Redis\' own dump/restore mechanism for replication, and Carmine\'s own message queue to coordinate the replication worker.\n\nTundra can be _very_ easily extended to **any K/V-capable datastore**. Implementations are provided out-the-box for: **Disk**, **Amazon S3** and **DynamoDB**.\n\n```clojure\n(:require [taoensso.carmine.tundra :as tundra :refer (ensure-ks dirty)]\n          [taoensso.carmine.tundra.s3]) ; Add to ns\n\n(def my-tundra-store\n  (tundra/tundra-store\n    ;; A datastore that implements the necessary (easily-extendable) protocol:\n    (taoensso.carmine.tundra.s3/s3-datastore {:access-key "" :secret-key ""}\n      "my-bucket/my-folder")))\n\n;; Now we have access to the Tundra API:\n(comment\n (worker    my-tundra-store {} {}) ; Create a replication worker\n (dirty     my-tundra-store "foo:bar1" "foo:bar2" ...) ; Queue for replication\n (ensure-ks my-tundra-store "foo:bar1" "foo:bar2" ...) ; Fetch from replica when necessary\n)\n```\n\nNote that this API makes it convenient to use several different datastores simultaneously (perhaps for different purposes with different latency requirements).\n\nSee the relevant [API] docs for details.\n\n## Performance\n\nRedis is probably most famous for being [fast]. Carmine hold up its end and usu. performs w/in ~10% of the official C `redis-benchmark` utility despite offering features like command composition, reply parsing, etc.\n\n## Thanks to Navicat\n\n![Navicat-logo](https://github.com/ptaoussanis/carmine/blob/master/navicat-logo.png)\n\nCarmine\'s SQL-interop features (forthcoming) were developed with the help of [Navicat], kindly sponsored by PremiumSoft CyberTech Ltd.\n\n## Thanks to YourKit\n\nCarmine was developed with the help of the [YourKit Java Profiler](http://www.yourkit.com/java/profiler/index.jsp). YourKit, LLC kindly supports open source projects by offering an open source license.\n\n## This project supports the ![ClojureWerkz-logo] goals\n\n * [ClojureWerkz] is a growing collection of open-source, **batteries-included Clojure libraries** that emphasise modern targets, great documentation, and thorough testing.\n\n## Contacting me / contributions\n\nPlease use the project\'s [GitHub issues page] for all questions, ideas, etc. **Pull requests welcome**. See the project\'s [GitHub contributors page] for a list of contributors.\n\nOtherwise, you can reach me at [Taoensso.com]. Happy hacking!\n\n\\- [Peter Taoussanis]\n\n## License\n\nDistributed under the [EPL v1.0] \\(same as Clojure).  \nCopyright &copy; 2012-2016 [Peter Taoussanis].\n\n<!--- Standard links -->\n[Taoensso.com]: https://www.taoensso.com\n[Peter Taoussanis]: https://www.taoensso.com\n[@ptaoussanis]: https://www.taoensso.com\n[More by @ptaoussanis]: https://www.taoensso.com\n[Break Version]: https://github.com/ptaoussanis/encore/blob/master/BREAK-VERSIONING.md\n[support my continued open-source Clojure/Script work]: http://taoensso.com/clojure/backers\n\n<!--- Standard links (repo specific) -->\n[CHANGELOG]: https://github.com/ptaoussanis/carmine/releases\n[API]: http://ptaoussanis.github.io/carmine/\n[GitHub issues page]: https://github.com/ptaoussanis/carmine/issues\n[GitHub contributors page]: https://github.com/ptaoussanis/carmine/graphs/contributors\n[EPL v1.0]: https://raw.githubusercontent.com/ptaoussanis/carmine/master/LICENSE\n[Hero]: https://raw.githubusercontent.com/ptaoussanis/carmine/master/hero.png "Title"\n\n<!--- Unique links -->\n[Redis]: http://www.redis.io/\n[Nippy]: https://github.com/ptaoussanis/nippy\n[@lantiga/redlock-clj]: https://github.com/lantiga/redlock-clj\n[@danielsz/system]: https://github.com/danielsz/system\n[pipelining]: http://redis.io/topics/pipelining\n[byte string]: http://redis.io/topics/data-types\n[rich datatypes]: http://clojure.org/datatypes\n[labs-redis-clojure]: https://github.com/wallrat/labs-redis-clojure\n[official Redis command reference]: https://github.com/antirez/redis-doc/blob/master/commands.json\n[Lua scripting docs]: http://redis.io/commands/eval\n[monitoring]: http://redis.io/commands/monitor\n[Publish/Subscribe]: http://redis.io/topics/pubsub\n[message queue server]: http://antirez.com/post/250\n[fast]: http://redis.io/topics/benchmarks\n[Detailed benchmark info]: https://docs.google.com/spreadsheet/ccc?key=0AuSXb68FH4uhdE5kTTlocGZKSXppWG9sRzA5Y2pMVkE\n[YourKit Java Profiler]: http://www.yourkit.com/java/profiler/index.jsp\n\n[ClojureWerkz-logo]: https://raw.github.com/clojurewerkz/clojurewerkz.org/master/assets/images/logos/clojurewerkz_long_h_50.png\n[ClojureWerkz]: http://clojurewerkz.org/\n[Navicat]: http://www.navicat.com/\n'