b"# [Learning to Learn](https://arxiv.org/abs/1606.04474) in TensorFlow\n\n\n## Dependencies\n\n* [TensorFlow >=1.0](https://www.tensorflow.org/)\n* [Sonnet >=1.0](https://github.com/deepmind/sonnet)\n\n\n## Training\n\n```\npython train.py --problem=mnist --save_path=./mnist\n```\n\nCommand-line flags:\n\n* `save_path`: If present, the optimizer will be saved to the specified path\n    every time the evaluation performance is improved.\n* `num_epochs`: Number of training epochs.\n* `log_period`: Epochs before mean performance and time is reported.\n* `evaluation_period`: Epochs before the optimizer is evaluated.\n* `evaluation_epochs`: Number of evaluation epochs.\n* `problem`: Problem to train on. See [Problems](#problems) section below.\n* `num_steps`: Number of optimization steps.\n* `unroll_length`: Number of unroll steps for the optimizer.\n* `learning_rate`: Learning rate.\n* `second_derivatives`: If `true`, the optimizer will try to compute second\n    derivatives through the loss function specified by the problem.\n\n\n## Evaluation\n\n```\npython evaluate.py --problem=mnist --optimizer=L2L --path=./mnist\n```\n\nCommand-line flags:\n\n* `optimizer`: `Adam` or `L2L`.\n* `path`: Path to saved optimizer, only relevant if using the `L2L` optimizer.\n* `learning_rate`: Learning rate, only relevant if using `Adam` optimizer.\n* `num_epochs`: Number of evaluation epochs.\n* `seed`: Seed for random number generation.\n* `problem`: Problem to evaluate on. See [Problems](#problems) section below.\n* `num_steps`: Number of optimization steps.\n\n\n## Problems\n\nThe training and evaluation scripts support the following problems (see\n`util.py` for more details):\n\n* `simple`: One-variable quadratic function.\n* `simple-multi`: Two-variable quadratic function, where one of the variables\n    is optimized using a learned optimizer and the other one using Adam.\n* `quadratic`: Batched ten-variable quadratic function.\n* `mnist`: Mnist classification using a two-layer fully connected network.\n* `cifar`: Cifar10 classification using a convolutional neural network.\n* `cifar-multi`: Cifar10 classification using a convolutional neural network,\n    where two independent learned optimizers are used. One to optimize\n    parameters from convolutional layers and the other one for parameters from\n    fully connected layers.\n\n\nNew problems can be implemented very easily. You can see in `train.py` that\nthe `meta_minimize` method from the `MetaOptimizer` class is given a function\nthat returns the TensorFlow operation that generates the loss function we want\nto minimize (see `problems.py` for an example).\n\nIt's important that all operations with Python side effects (e.g. queue\ncreation) must be done outside of the function passed to `meta_minimize`. The\n`cifar10` function in `problems.py` is a good example of a loss function that\nuses TensorFlow queues.\n\n\nDisclaimer: This is not an official Google product.\n"