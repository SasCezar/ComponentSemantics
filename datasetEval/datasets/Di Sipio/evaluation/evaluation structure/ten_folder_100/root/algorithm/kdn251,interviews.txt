b'# Interviews\n> Your personal guide to Software Engineering technical interviews. Video\n> solutions to the following interview problems with detailed explanations can be found [here](https://www.youtube.com/channel/UCKvwPt6BifPP54yzH99ff1g).\n<a href="https://www.youtube.com/channel/UCKvwPt6BifPP54yzH99ff1g" style="display:block;"><img src="/images/youtube.jpg?raw=true"></a>\n>\n> Maintainer - [Kevin Naughton Jr.](https://github.com/kdn251)\n\n## Translations\n\n- [\xe7\xae\x80\xe4\xbd\x93\xe4\xb8\xad\xe6\x96\x87](./README-zh-cn.md)\n\n## Table of Contents\n- [YouTube](#youtube)\n- [Instagram](#instagram)\n- [Articles](#articles)\n- [Online Judges](#online-judges)\n- [Live Coding Practice](#live-coding-practice)\n- [Data Structures](#data-structures)\n- [Algorithms](#algorithms)\n- [Greedy Algorithms](#greedy-algorithms)\n- [Bitmasks](#bitmasks)\n- [Runtime Analysis](#runtime-analysis)\n- [Video Lectures](#video-lectures)\n- [Interview Books](#interview-books)\n- [Computer Science News](#computer-science-news)\n- [Directory Tree](#directory-tree)\n\n## YouTube\n* [Kevin Naughton Jr.](https://www.youtube.com/channel/UCKvwPt6BifPP54yzH99ff1g)\n\n## Instagram \n* [Programeme](https://www.instagram.com/programeme/)\n\n## Articles\n* [Starting Work](https://medium.com/@Naughton/starting-work-b06e10f6007e)\n\n## Online Judges\n* [LeetCode](https://leetcode.com/)\n* [Virtual Judge](https://vjudge.net/)\n* [CareerCup](https://www.careercup.com/)\n* [HackerRank](https://www.hackerrank.com/)\n* [CodeFights](https://codefights.com/)\n* [Kattis](https://open.kattis.com/)\n* [HackerEarth](https://www.hackerearth.com)\n* [Codility](https://codility.com/programmers/lessons/1-iterations/)\n* [Code Forces](http://codeforces.com/)\n* [Code Chef](https://www.codechef.com/)\n* [Sphere Online Judge - SPOJ](http://www.spoj.com/)\n* [InterviewBit](https://www.interviewbit.com/)\n\n## Live Coding Practice\n* [Pramp](https://www.pramp.com/ref/gt4)\n* [Gainlo](http://www.gainlo.co/#!/)\n* [Refdash](https://refdash.com/)\n* [Interviewing.io](https://www.interviewing.io/)\n\n## Data Structures\n### Linked List\n * A *Linked List* is a linear collection of data elements, called nodes, each\n   pointing to the next node by means of a pointer. It is a data structure\n   consisting of a group of nodes which together represent a sequence.\n * **Singly-linked list**: linked list in which each node points to the next node and the last node points to null\n * **Doubly-linked list**: linked list in which each node has two pointers, p and n, such that p points to the previous node and n points to the next node; the last node\'s n pointer points to null\n * **Circular-linked list**: linked list in which each node points to the next node and the last node points back to the first node\n * Time Complexity:\n   * Access: `O(n)`\n   * Search: `O(n)`\n   * Insert: `O(1)`\n   * Remove: `O(1)`\n\n### Stack\n * A *Stack* is a collection of elements, with two principle operations: *push*, which adds to the collection, and\n   *pop*, which removes the most recently added element\n * **Last in, first out data structure (LIFO)**: the most recently added object is the first to be removed\n * Time Complexity:\n   * Access: `O(n)`\n   * Search: `O(n)`\n   * Insert: `O(1)`\n   * Remove: `O(1)`\n\n### Queue\n * A *Queue* is a collection of elements, supporting two principle operations: *enqueue*, which inserts an element\n   into the queue, and *dequeue*, which removes an element from the queue\n * **First in, first out data structure (FIFO)**: the oldest added object is the first to be removed\n * Time Complexity:\n   * Access: `O(n)`\n   * Search: `O(n)`\n   * Insert: `O(1)`\n   * Remove: `O(1)`\n\n### Tree\n * A *Tree* is an undirected, connected, acyclic graph\n\n### Binary Tree\n * A *Binary Tree* is a tree data structure in which each node has at most two children, which are referred to as\n   the *left child* and *right child*\n * **Full Tree**: a tree in which every node has either 0 or 2 children\n * **Perfect Binary Tree**: a binary tree in which all interior nodes have two children and all leave have the same depth\n * **Complete Tree**: a binary tree in which every level *except possibly the last* is full and all nodes in the last\n   level are as far left as possible\n\n### Binary Search Tree\n * A binary search tree, sometimes called BST, is a type of binary tree which maintains the property that the value in each\n   node must be greater than or equal to any value stored in the left sub-tree, and less than or equal to any value stored\n   in the right sub-tree\n * Time Complexity:\n   * Access: `O(log(n))`\n   * Search: `O(log(n))`\n   * Insert: `O(log(n))`\n   * Remove: `O(log(n))`\n\n<img src="/images/BST.png?raw=true" alt="Binary Search Tree" width="400" height="500">\n\n### Trie\n* A trie, sometimes called a radix or prefix tree, is a kind of search tree that is used to store a dynamic set or associative\n  array where the keys are usually Strings. No node in the tree stores the key associated with that node; instead, its position \n  in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the String associated \n  with that node, and the root is associated with the empty String.\n\n![Alt text](/images/trie.png?raw=true "Trie")\n\n### Fenwick Tree\n* A Fenwick tree, sometimes called a binary indexed tree, is a tree in concept, but in practice is implemented as an implicit data\n  structure using an array. Given an index in the array representing a vertex, the index of a vertex\'s parent or child is calculated\n  through bitwise operations on the binary representation of its index. Each element of the array contains the pre-calculated sum of\n  a range of values, and by combining that sum with additional ranges encountered during an upward traversal to the root, the prefix\n  sum is calculated\n* Time Complexity:\n  * Range Sum: `O(log(n))`\n  * Update: `O(log(n))`\n\n![Alt text](/images/fenwickTree.png?raw=true "Fenwick Tree")\n\n### Segment Tree\n* A Segment tree, is a tree data structure for storing intervals, or segments. It allows querying which of the stored segments contain\n  a given point\n* Time Complexity:\n  * Range Query: `O(log(n))`\n  * Update: `O(log(n))`\n\n![Alt text](/images/segmentTree.png?raw=true "Segment Tree")\n\n### Heap\n* A *Heap* is a specialized tree based structure data structure that satisfies the *heap* property: if A is a parent node of\nB, then the key (the value) of node A is ordered with respect to the key of node B with the same ordering applying across the entire heap.\nA heap can be classified further as either a "max heap" or a "min heap". In a max heap, the keys of parent nodes are always greater\nthan or equal to those of the children and the highest key is in the root node. In a min heap, the keys of parent nodes are less than\nor equal to those of the children and the lowest key is in the root node\n* Time Complexity:\n  * Access Max / Min: `O(1)`\n  * Insert: `O(log(n))`\n  * Remove Max / Min: `O(log(n))`\n\n<img src="/images/heap.png?raw=true" alt="Max Heap" width="400" height="500">\n\n\n### Hashing\n* *Hashing* is used to map data of an arbitrary size to data of a fixed size. The values returned by a hash\n  function are called hash values, hash codes, or simply hashes. If two keys map to the same value, a collision occurs\n* **Hash Map**: a *hash map* is a structure that can map keys to values. A hash map uses a hash function to compute\n  an index into an array of buckets or slots, from which the desired value can be found.\n* Collision Resolution\n * **Separate Chaining**: in *separate chaining*, each bucket is independent, and contains a list of entries for each index. The\n time for hash map operations is the time to find the bucket (constant time), plus the time to iterate through the list\n * **Open Addressing**: in *open addressing*, when a new entry is inserted, the buckets are examined, starting with the\n hashed-to-slot and proceeding in some sequence, until an unoccupied slot is found. The name open addressing refers to\n the fact that the location of an item is not always determined by its hash value\n\n\n![Alt text](/images/hash.png?raw=true "Hashing")\n\n### Graph\n* A *Graph* is an ordered pair of G = (V, E) comprising a set V of vertices or nodes together with a set E of edges or arcs,\n  which are 2-element subsets of V (i.e. an edge is associated with two vertices, and that association takes the form of the\n  unordered pair comprising those two vertices)\n * **Undirected Graph**: a graph in which the adjacency relation is symmetric. So if there exists an edge from node u to node\n v (u -> v), then it is also the case that there exists an edge from node v to node u (v -> u)\n * **Directed Graph**: a graph in which the adjacency relation is not symmetric. So if there exists an edge from node u to node v\n (u -> v), this does *not* imply that there exists an edge from node v to node u (v -> u)\n\n\n<img src="/images/graph.png?raw=true" alt="Graph" width="400" height="500">\n\n## Algorithms\n\n### Sorting\n\n#### Quicksort\n* Stable: `No`\n* Time Complexity:\n  * Best Case: `O(nlog(n))`\n  * Worst Case: `O(n^2)`\n  * Average Case: `O(nlog(n))`\n\n![Alt text](/images/quicksort.gif?raw=true "Quicksort")\n\n#### Mergesort\n* *Mergesort* is also a divide and conquer algorithm. It continuously divides an array into two halves, recurses on both the\n  left subarray and right subarray and then merges the two sorted halves\n* Stable: `Yes`\n* Time Complexity:\n  * Best Case: `O(nlog(n))`\n  * Worst Case: `O(nlog(n))`\n  * Average Case: `O(nlog(n))`\n\n![Alt text](/images/mergesort.gif?raw=true "Mergesort")\n\n#### Bucket Sort\n* *Bucket Sort* is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket\n  is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm\n* Time Complexity:\n  * Best Case: `\xce\xa9(n + k)`\n  * Worst Case: `O(n^2)`\n  * Average Case:`\xce\x98(n + k)`\n\n![Alt text](/images/bucketsort.png?raw=true "Bucket Sort")\n\n#### Radix Sort\n* *Radix Sort* is a sorting algorithm that like bucket sort, distributes elements of an array into a number of buckets. However, radix\n  sort differs from bucket sort by \'re-bucketing\' the array after the initial pass as opposed to sorting each bucket and merging\n* Time Complexity:\n  * Best Case: `\xce\xa9(nk)`\n  * Worst Case: `O(nk)`\n  * Average Case: `\xce\x98(nk)`\n\n### Graph Algorithms\n\n#### Depth First Search\n* *Depth First Search* is a graph traversal algorithm which explores as far as possible along each branch before backtracking\n* Time Complexity: `O(|V| + |E|)`\n\n![Alt text](/images/dfsbfs.gif?raw=true "DFS / BFS Traversal")\n\n#### Breadth First Search\n* *Breadth First Search* is a graph traversal algorithm which explores the neighbor nodes first, before moving to the next\n  level neighbors\n* Time Complexity: `O(|V| + |E|)`\n\n![Alt text](/images/dfsbfs.gif?raw=true "DFS / BFS Traversal")\n\n#### Topological Sort\n* *Topological Sort* is the linear ordering of a directed graph\'s nodes such that for every edge from node u to node v, u\n  comes before v in the ordering\n* Time Complexity: `O(|V| + |E|)`\n\n#### Dijkstra\'s Algorithm\n* *Dijkstra\'s Algorithm* is an algorithm for finding the shortest path between nodes in a graph\n* Time Complexity: `O(|V|^2)`\n\n![Alt text](/images/dijkstra.gif?raw=true "Dijkstra\'s")\n\n#### Bellman-Ford Algorithm\n* *Bellman-Ford Algorithm* is an algorithm that computes the shortest paths from a single source node to all other nodes in a weighted graph\n* Although it is slower than Dijkstra\'s, it is more versatile, as it is capable of handling graphs in which some of the edge weights are\n  negative numbers\n* Time Complexity:\n  * Best Case: `O(|E|)`\n  * Worst Case: `O(|V||E|)`\n\n![Alt text](/images/bellman-ford.gif?raw=true "Bellman-Ford")\n\n#### Floyd-Warshall Algorithm\n* *Floyd-Warshall Algorithm* is an algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights, but\n  no negative cycles\n* A single execution of the algorithm will find the lengths (summed weights) of the shortest paths between *all* pairs of nodes\n* Time Complexity:\n  * Best Case: `O(|V|^3)`\n  * Worst Case: `O(|V|^3)`\n  * Average Case: `O(|V|^3)`\n\n#### Prim\'s Algorithm\n* *Prim\'s Algorithm* is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. In other words, Prim\'s find a\n  subset of edges that forms a tree that includes every node in the graph\n* Time Complexity: `O(|V|^2)`\n\n![Alt text](/images/prim.gif?raw=true "Prim\'s Algorithm")\n\n#### Kruskal\'s Algorithm\n* *Kruskal\'s Algorithm* is also a greedy algorithm that finds a minimum spanning tree in a graph. However, in Kruskal\'s, the graph does not\n  have to be connected\n* Time Complexity: `O(|E|log|V|)`\n\n![Alt text](/images/kruskal.gif?raw=true "Kruskal\'s Algorithm")\n\n## Greedy Algorithms\n* *Greedy Algorithms* are algorithms that make locally optimal choices at each step in the hope of eventually reaching the globally optimal solution\n* Problems must exhibit two properties in order to implement a Greedy solution:\n * Optimal Substructure\n    * An optimal solution to the problem contains optimal solutions to the given problem\'s subproblems\n * The Greedy Property\n    * An optimal solution is reached by "greedily" choosing the locally optimal choice without ever reconsidering previous choices\n* Example - Coin Change\n    * Given a target amount V cents and a list of denominations of n coins, i.e. we have coinValue[i] (in cents) for coin types i from [0...n - 1],\n      what is the minimum number of coins that we must use to represent amount V? Assume that we have an unlimited supply of coins of any type\n    * Coins - Penny (1 cent), Nickel (5 cents), Dime (10 cents), Quarter (25 cents)\n    * Assume V = 41. We can use the Greedy algorithm of continuously selecting the largest coin denomination less than or equal to V, subtract that\n      coin\'s value from V, and repeat.\n    * V = 41 | 0 coins used\n    * V = 16 | 1 coin used (41 - 25 = 16)\n    * V = 6  | 2 coins used (16 - 10 = 6)\n    * V = 1  | 3 coins used (6 - 5 = 1)\n    * V = 0  | 4 coins used (1 - 1 = 0)\n    * Using this algorithm, we arrive at a total of 4 coins which is optimal\n\n## Bitmasks\n* Bitmasking is a technique used to perform operations at the bit level. Leveraging bitmasks often leads to faster runtime complexity and\n  helps limit memory usage\n* Test kth bit: `s & (1 << k);`\n* Set kth bit: `s |= (1 << k);`\n* Turn off kth bit: `s &= ~(1 << k);`\n* Toggle kth bit: `s ^= (1 << k);`\n* Multiple by 2<sup>n</sup>: `s << n;`\n* Divide by 2<sup>n</sup>: `s >> n;`\n* Intersection: `s & t;`\n* Union: `s | t;`\n* Set Subtraction: `s & ~t;`\n* Extract lowest set bit: `s & (-s);`\n* Extract lowest unset bit: `~s & (s + 1);`\n* Swap Values:\n             ```\n                x ^= y;\n                y ^= x;\n                x ^= y;\n             ```\n\n## Runtime Analysis\n\n#### Big O Notation\n* *Big O Notation* is used to describe the upper bound of a particular algorithm. Big O is used to describe worst case scenarios\n\n![Alt text](/images/bigO.png?raw=true "Theta Notation")\n\n#### Little O Notation\n* *Little O Notation* is also used to describe an upper bound of a particular algorithm; however, Little O provides a bound\n  that is not asymptotically tight\n\n#### Big \xce\xa9 Omega Notation\n* *Big Omega Notation* is used to provide an asymptotic lower bound on a particular algorithm\n\n![Alt text](/images/bigOmega.png?raw=true "Theta Notation")\n\n#### Little \xcf\x89 Omega Notation\n* *Little Omega Notation* is used to provide a lower bound on a particular algorithm that is not asymptotically tight\n\n#### Theta \xce\x98 Notation\n* *Theta Notation* is used to provide a bound on a particular algorithm such that it can be "sandwiched" between\n  two constants (one for an upper limit and one for a lower limit) for sufficiently large values\n\n![Alt text](/images/theta.png?raw=true "Theta Notation")\n\n## Video Lectures\n* Data Structures\n    * [UC Berkeley Data Structures](https://archive.org/details/ucberkeley-webcast?&and[]=subject%3A%22Computer%20Science%22&and[]=subject%3A%22CS%22)\n    * [MIT Advanced Data Structures](https://www.youtube.com/watch?v=T0yzrZL1py0&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&index=1)\n* Algorithms\n    * [MIT Introduction to Algorithms](https://www.youtube.com/watch?v=HtSuA80QTyo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=1)\n    * [MIT Advanced Algorithms](https://www.youtube.com/playlist?list=PL6ogFv-ieghdoGKGg2Bik3Gl1glBTEu8c)\n    * [UC Berkeley Algorithms](https://archive.org/details/ucberkeley-webcast?&and[]=subject%3A%22Computer%20Science%22&and[]=subject%3A%22CS%22)\n\n## Interview Books\n* [Competitive Programming 3 - Steven Halim & Felix Halim](https://www.amazon.com/Competitive-Programming-3rd-Steven-Halim/dp/B00FG8MNN8) \n* [Cracking The Coding Interview - Gayle Laakmann McDowell](https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850/ref=sr_1_1?s=books&ie=UTF8)\n* [Cracking The PM Interview - Gayle Laakmann McDowell & Jackie Bavaro](https://www.amazon.com/Cracking-PM-Interview-Product-Technology-ebook/dp/B00ISYMUR6/ref=sr_1_1?s=books&ie=UTF8)\n* [Introduction to Algorithms -  Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest & Clifford Stein](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=sr_1_1?ie=UTF8&qid=1490295989&sr=8-1&keywords=Introduction+to+Algorithms)\n\n## Computer Science News\n* [Hacker News](https://news.ycombinator.com/)\n* [Lobsters](https://lobste.rs/)\n\n## Directory Tree\n\n```\n.\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 Array\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 bestTimeToBuyAndSellStock.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 findTheCelebrity.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 gameOfLife.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 increasingTripletSubsequence.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 insertInterval.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 longestConsecutiveSequence.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 maximumProductSubarray.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 maximumSubarray.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mergeIntervals.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 missingRanges.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 productOfArrayExceptSelf.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 rotateImage.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 searchInRotatedSortedArray.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 spiralMatrixII.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 subsetsII.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 subsets.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 summaryRanges.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 wiggleSort.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 wordSearch.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 Backtracking\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 androidUnlockPatterns.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 generalizedAbbreviation.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 letterCombinationsOfAPhoneNumber.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 BinarySearch\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 closestBinarySearchTreeValue.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 firstBadVersion.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 guessNumberHigherOrLower.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 pow(x,n).java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 sqrt(x).java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 BitManipulation\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 binaryWatch.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 countingBits.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 hammingDistance.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 maximumProductOfWordLengths.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 numberOf1Bits.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 sumOfTwoIntegers.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 utf-8Validation.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 BreadthFirstSearch\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 binaryTreeLevelOrderTraversal.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 cloneGraph.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 pacificAtlanticWaterFlow.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 removeInvalidParentheses.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 shortestDistanceFromAllBuildings.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 symmetricTree.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 wallsAndGates.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 DepthFirstSearch\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 balancedBinaryTree.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 battleshipsInABoard.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 convertSortedArrayToBinarySearchTree.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 maximumDepthOfABinaryTree.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 numberOfIslands.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 populatingNextRightPointersInEachNode.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 sameTree.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 Design\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 zigzagIterator.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 DivideAndConquer\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 expressionAddOperators.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 kthLargestElementInAnArray.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 DynamicProgramming\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 bombEnemy.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 climbingStairs.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 combinationSumIV.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 countingBits.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 editDistance.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 houseRobber.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 paintFence.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 paintHouseII.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 regularExpressionMatching.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 sentenceScreenFitting.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 uniqueBinarySearchTrees.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 wordBreak.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 HashTable\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 binaryTreeVerticalOrderTraversal.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 findTheDifference.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 groupAnagrams.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 groupShiftedStrings.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 islandPerimeter.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 loggerRateLimiter.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 maximumSizeSubarraySumEqualsK.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 minimumWindowSubstring.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 sparseMatrixMultiplication.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 strobogrammaticNumber.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 twoSum.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 uniqueWordAbbreviation.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 LinkedList\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 addTwoNumbers.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 deleteNodeInALinkedList.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mergeKSortedLists.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 palindromeLinkedList.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 plusOneLinkedList.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 README.md\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 reverseLinkedList.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 Queue\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 movingAverageFromDataStream.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 README.md\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 Sort\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 meetingRoomsII.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 meetingRooms.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 Stack\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 binarySearchTreeIterator.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 decodeString.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 flattenNestedListIterator.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 trappingRainWater.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 String\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 addBinary.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 countAndSay.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 decodeWays.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 editDistance.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 integerToEnglishWords.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 longestPalindrome.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 longestSubstringWithAtMostKDistinctCharacters.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 minimumWindowSubstring.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 multiplyString.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 oneEditDistance.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 palindromePermutation.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 README.md\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 reverseVowelsOfAString.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 romanToInteger.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 validPalindrome.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 validParentheses.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 Tree\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 binaryTreeMaximumPathSum.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 binaryTreePaths.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 inorderSuccessorInBST.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 invertBinaryTree.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 lowestCommonAncestorOfABinaryTree.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 sumOfLeftLeaves.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 validateBinarySearchTree.java\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 Trie\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 addAndSearchWordDataStructureDesign.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 implementTrie.java\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 wordSquares.java\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 TwoPointers\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 3Sum.java\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 3SumSmaller.java\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mergeSortedArray.java\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 minimumSizeSubarraySum.java\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 moveZeros.java\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 removeDuplicatesFromSortedArray.java\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 reverseString.java\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 sortColors.java\n\n18 directories, 124 files\n```\n'