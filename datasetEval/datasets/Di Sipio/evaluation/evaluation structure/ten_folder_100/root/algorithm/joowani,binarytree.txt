b"Binarytree: Python Library for Studying Binary Trees\n----------------------------------------------------\n\n.. image:: https://travis-ci.org/joowani/binarytree.svg?branch=master\n    :target: https://travis-ci.org/joowani/binarytree\n    :alt: Build Status\n\n.. image:: https://badge.fury.io/py/binarytree.svg\n    :target: https://badge.fury.io/py/binarytree\n    :alt: Package Version\n\n.. image:: https://img.shields.io/badge/python-2.7%2C%203.4%2C%203.5%2C%203.6%2C%203.7-blue.svg\n    :target: https://github.com/joowani/binarytree\n    :alt: Python Versions\n\n.. image:: https://coveralls.io/repos/github/joowani/binarytree/badge.svg?branch=master\n    :target: https://coveralls.io/github/joowani/binarytree?branch=master\n    :alt: Test Coverage\n\n.. image:: https://img.shields.io/github/issues/joowani/binarytree.svg\n    :target: https://github.com/joowani/binarytree/issues\n    :alt: Issues Open\n\n.. image:: https://img.shields.io/badge/license-MIT-blue.svg\n    :target: https://raw.githubusercontent.com/joowani/binarytree/master/LICENSE\n    :alt: MIT License\n\n|\n\n.. image:: https://user-images.githubusercontent.com/2701938/34109703-4a8810aa-e3b9-11e7-8138-68eec47cfddb.gif\n    :alt: Demo GIF\n\nIntroduction\n============\n\nAre you studying binary trees for your next exam, assignment or technical interview?\n\n**Binarytree** is a Python library which provides a simple API to generate,\nvisualize, inspect and manipulate binary trees. It allows you to skip the\ntedious work of setting up test data, and dive straight into practising your\nalgorithms. Heaps and BSTs (binary search trees) are also supported.\n\nAnnouncements\n=============\n\n* Please see the releases_ page for details on the latest updates.\n\n.. _releases: https://github.com/joowani/binarytree/releases\n\nRequirements\n============\n\n- Python 2.7, 3.4, 3.5, 3.6 or 3.7.\n\nInstallation\n============\n\nTo install a stable version from PyPi_:\n\n.. code-block:: bash\n\n    ~$ pip install binarytree\n\nTo install the latest version directly from GitHub_:\n\n.. code-block:: bash\n\n    ~$ pip install -e git+git@github.com:joowani/binarytree.git@master#egg=binarytree\n\nYou may need to use ``sudo`` depending on your environment.\n\n.. _PyPi: https://pypi.python.org/pypi/binarytree\n.. _GitHub: https://github.com/joowani/binarytree\n\nGetting Started\n===============\n\nBy default, **binarytree** uses the following class to represent a node:\n\n.. code-block:: python\n\n    class Node(object):\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value  # The node value\n            self.left = left    # Left child\n            self.right = right  # Right child\n\nGenerate and pretty-print various types of binary trees:\n\n.. code-block:: python\n\n    >>> from binarytree import tree, bst, heap\n    >>>\n    >>> # Generate a random binary tree and return its root node\n    >>> my_tree = tree(height=3, is_perfect=False)\n    >>>\n    >>> # Generate a random BST and return its root node\n    >>> my_bst = bst(height=3, is_perfect=True)\n    >>>\n    >>> # Generate a random max heap and return its root node\n    >>> my_heap = heap(height=3, is_max=True, is_perfect=False)\n    >>>\n    >>> # Pretty-print the trees in stdout\n    >>> print(my_tree)\n    #\n    #        _______1_____\n    #       /             \\\n    #      4__          ___3\n    #     /   \\        /    \\\n    #    0     9      13     14\n    #         / \\       \\\n    #        7   10      2\n    #\n    >>> print(my_bst)\n    #\n    #            ______7_______\n    #           /              \\\n    #        __3__           ___11___\n    #       /     \\         /        \\\n    #      1       5       9         _13\n    #     / \\     / \\     / \\       /   \\\n    #    0   2   4   6   8   10    12    14\n    #\n    >>> print(my_heap)\n    #\n    #              _____14__\n    #             /         \\\n    #        ____13__        9\n    #       /        \\      / \\\n    #      12         7    3   8\n    #     /  \\       /\n    #    0    10    6\n    #\n\nUse the `binarytree.Node`_ class to build your own trees:\n\n.. _binarytree.Node:\n    http://binarytree.readthedocs.io/en/latest/specs.html#class-binarytree-node\n\n.. code-block:: python\n\n    >>> from binarytree import Node\n    >>>\n    >>> root = Node(1)\n    >>> root.left = Node(2)\n    >>> root.right = Node(3)\n    >>> root.left.right = Node(4)\n    >>>\n    >>> print(root)\n    #\n    #      __1\n    #     /   \\\n    #    2     3\n    #     \\\n    #      4\n    #\n\nInspect tree properties:\n\n.. code-block:: python\n\n    >>> from binarytree import Node\n    >>>\n    >>> root = Node(1)\n    >>> root.left = Node(2)\n    >>> root.right = Node(3)\n    >>> root.left.left = Node(4)\n    >>> root.left.right = Node(5)\n    >>>\n    >>> print(root)\n    #\n    #        __1\n    #       /   \\\n    #      2     3\n    #     / \\\n    #    4   5\n    #\n    >>> root.height\n    2\n    >>> root.is_balanced\n    True\n    >>> root.is_bst\n    False\n    >>> root.is_complete\n    True\n    >>> root.is_max_heap\n    False\n    >>> root.is_min_heap\n    True\n    >>> root.is_perfect\n    False\n    >>> root.is_strict\n    True\n    >>> root.leaf_count\n    3\n    >>> root.max_leaf_depth\n    2\n    >>> root.max_node_value\n    5\n    >>> root.min_leaf_depth\n    1\n    >>> root.min_node_value\n    1\n    >>> root.size\n    5\n\n    >>> root.properties  # To see all at once:\n    {'height': 2,\n     'is_balanced': True,\n     'is_bst': False,\n     'is_complete': True,\n     'is_max_heap': False,\n     'is_min_heap': True,\n     'is_perfect': False,\n     'is_strict': True,\n     'leaf_count': 3,\n     'max_leaf_depth': 2,\n     'max_node_value': 5,\n     'min_leaf_depth': 1,\n     'min_node_value': 1,\n     'size': 5}\n\n    >>> root.leaves\n    [Node(3), Node(4), Node(5)]\n\n    >>> root.levels\n    [[Node(1)], [Node(2), Node(3)], [Node(4), Node(5)]]\n\nUse `level-order (breadth-first)`_ indexes to manipulate nodes:\n\n.. _level-order (breadth-first):\n    https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search\n\n.. code-block:: python\n\n    >>> from binarytree import Node\n    >>>\n    >>> root = Node(1)                  # index: 0, value: 1\n    >>> root.left = Node(2)             # index: 1, value: 2\n    >>> root.right = Node(3)            # index: 2, value: 3\n    >>> root.left.right = Node(4)       # index: 4, value: 4\n    >>> root.left.right.left = Node(5)  # index: 9, value: 5\n    >>>\n    >>> print(root)\n    #\n    #      ____1\n    #     /     \\\n    #    2__     3\n    #       \\\n    #        4\n    #       /\n    #      5\n    #\n    >>> # Use binarytree.Node.pprint instead of print to display indexes\n    >>> root.pprint(index=True)\n    #\n    #       _________0-1_\n    #      /             \\\n    #    1-2_____        2-3\n    #            \\\n    #           _4-4\n    #          /\n    #        9-5\n    #\n    >>> # Return the node/subtree at index 9\n    >>> root[9]\n    Node(5)\n\n    >>> # Replace the node/subtree at index 4\n    >>> root[4] = Node(6, left=Node(7), right=Node(8))\n    >>> root.pprint(index=True)\n    #\n    #       ______________0-1_\n    #      /                  \\\n    #    1-2_____             2-3\n    #            \\\n    #           _4-6_\n    #          /     \\\n    #        9-7     10-8\n    #\n    >>> # Delete the node/subtree at index 1\n    >>> del root[1]\n    >>> root.pprint(index=True)\n    #\n    #    0-1_\n    #        \\\n    #        2-3\n\nTraverse the trees using different algorithms:\n\n.. code-block:: python\n\n    >>> from binarytree import Node\n    >>>\n    >>> root = Node(1)\n    >>> root.left = Node(2)\n    >>> root.right = Node(3)\n    >>> root.left.left = Node(4)\n    >>> root.left.right = Node(5)\n    >>>\n    >>> print(root)\n    #\n    #        __1\n    #       /   \\\n    #      2     3\n    #     / \\\n    #    4   5\n    #\n    >>> root.inorder\n    [Node(4), Node(2), Node(5), Node(1), Node(3)]\n\n    >>> root.preorder\n    [Node(1), Node(2), Node(4), Node(5), Node(3)]\n\n    >>> root.postorder\n    [Node(4), Node(5), Node(2), Node(3), Node(1)]\n\n    >>> root.levelorder\n    [Node(1), Node(2), Node(3), Node(4), Node(5)]\n\n    >>> list(root)  # Equivalent to root.levelorder\n    [Node(1), Node(2), Node(3), Node(4), Node(5)]\n\n`List representations`_ are also supported:\n\n.. _List representations: https://en.wikipedia.org/wiki/Binary_tree#Arrays\n\n.. code-block:: python\n\n    >>> from binarytree import build\n    >>>\n    >>> # Build a tree from list representation\n    >>> values = [7, 3, 2, 6, 9, None, 1, 5, 8]\n    >>> root = build(values)\n    >>> print(root)\n    #\n    #            __7\n    #           /   \\\n    #        __3     2\n    #       /   \\     \\\n    #      6     9     1\n    #     / \\\n    #    5   8\n    #\n    >>> # Convert the tree back to list representation\n    >>> root.values\n    [7, 3, 2, 6, 9, None, 1, 5, 8]\n\nCheck out the documentation_ for more details!\n\n.. _documentation: http://binarytree.readthedocs.io/en/latest/index.html\n\nContributing\n============\n\nPlease have a look at this page_ before submitting a pull request. Thanks!\n\n.. _page: http://binarytree.readthedocs.io/en/latest/contributing.html\n"