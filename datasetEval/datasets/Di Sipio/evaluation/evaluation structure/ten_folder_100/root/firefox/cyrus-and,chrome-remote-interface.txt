b'# chrome-remote-interface [![Build Status][]][travis]\n\n[Build Status]: https://travis-ci.org/cyrus-and/chrome-remote-interface.svg?branch=master\n[travis]: https://travis-ci.org/cyrus-and/chrome-remote-interface\n\n[Chrome Debugging Protocol] interface that helps to instrument Chrome (or any\nother suitable [implementation](#implementations)) by providing a simple\nabstraction of commands and notifications using a straightforward JavaScript\nAPI.\n\nThis module is one of the many [third-party protocol clients][3rd-party].\n\n[3rd-party]: https://developer.chrome.com/devtools/docs/debugging-clients#chrome-remote-interface\n\n## Sample API usage\n\nThe following snippet loads `https://github.com` and dumps every request made:\n\n```js\nconst CDP = require(\'chrome-remote-interface\');\n\nasync function example() {\n    let client;\n    try {\n        // connect to endpoint\n        client = await CDP();\n        // extract domains\n        const {Network, Page} = client;\n        // setup handlers\n        Network.requestWillBeSent((params) => {\n            console.log(params.request.url);\n        });\n        // enable events then start!\n        await Network.enable();\n        await Page.enable();\n        await Page.navigate({url: \'https://github.com\'});\n        await Page.loadEventFired();\n    } catch (err) {\n        console.error(err);\n    } finally {\n        if (client) {\n            await client.close();\n        }\n    }\n}\n\nexample();\n```\n\nFind more examples in the [wiki]. You may also want to take a look at the [FAQ].\n\n[wiki]: https://github.com/cyrus-and/chrome-remote-interface/wiki\n[async-await-example]: https://github.com/cyrus-and/chrome-remote-interface/wiki/Async-await-example\n[FAQ]: https://github.com/cyrus-and/chrome-remote-interface#faq\n\n## Installation\n\n    npm install chrome-remote-interface\n\nInstall globally (`-g`) to just use the [bundled client](#bundled-client).\n\n## Implementations\n\nThis module should work with every application implementing the\n[Chrome Debugging Protocol]. In particular, it has been tested against the\nfollowing implementations:\n\nImplementation             | Protocol version   | [Protocol] | [List] | [New] | [Activate] | [Close] | [Version]\n---------------------------|--------------------|------------|--------|-------|------------|---------|-----------\n[Google Chrome][1.1]       | [tip-of-tree][1.2] | yes\xc2\xb9       | yes    | yes   | yes        | yes     | yes\n[Opera][2.1]               | [tip-of-tree][2.2] | yes        | yes    | yes   | yes        | yes     | yes\n[Node.js][3.1] ([v6.3.0]+) | [node][3.2]        | yes        | no     | no    | no         | no      | yes\n[Safari (iOS)][4.1]        | [*partial*][4.2]   | no         | yes    | no    | no         | no      | no\n[Microsoft Edge][5.1]      | [*partial*][5.2]   | yes        | yes    | no    | no         | no      | yes\n[Mozilla Firefox][6.1]     | [*partial*][6.2]   | yes        | yes    | no    | yes        | yes     | yes\n\n\xc2\xb9 Not available on [Chrome for Android][chrome-mobile-protocol].\n\n[chrome-mobile-protocol]: https://bugs.chromium.org/p/chromium/issues/detail?id=824626#c4\n\n[1.1]: #chromechromium\n[1.2]: https://chromedevtools.github.io/devtools-protocol/tot/\n\n[2.1]: #opera\n[2.2]: https://chromedevtools.github.io/devtools-protocol/tot/\n\n[3.1]: #nodejs\n[3.2]: https://chromedevtools.github.io/devtools-protocol/v8/\n\n[4.1]: #safari-ios\n[4.2]: http://trac.webkit.org/browser/trunk/Source/JavaScriptCore/inspector/protocol\n\n[5.1]: #edge\n[5.2]: https://docs.microsoft.com/en-us/microsoft-edge/devtools-protocol/0.1/domains/\n\n[6.1]: #firefox\n[6.2]: https://firefox-source-docs.mozilla.org/remote/index.html\n\n[v6.3.0]: https://nodejs.org/en/blog/release/v6.3.0/\n\n[Protocol]: #cdpprotocoloptions-callback\n[List]: #cdplistoptions-callback\n[New]: #cdpnewoptions-callback\n[Activate]: #cdpactivateoptions-callback\n[Close]: #cdpcloseoptions-callback\n[Version]: #cdpversionoptions-callback\n\nThe meaning of *target* varies according to the implementation, for example,\neach Chrome tab represents a target whereas for Node.js a target is the\ncurrently inspected script.\n\n## Setup\n\nAn instance of either Chrome itself or another implementation needs to be\nrunning on a known port in order to use this module (defaults to\n`localhost:9222`).\n\n### Chrome/Chromium\n\n#### Desktop\n\nStart Chrome with the `--remote-debugging-port` option, for example:\n\n    google-chrome --remote-debugging-port=9222\n\n##### Headless\n\nSince version 59, additionally use the `--headless` option, for example:\n\n    google-chrome --headless --remote-debugging-port=9222\n\n#### Android\n\nPlug the device and enable the [port forwarding][adb], for example:\n\n    adb forward tcp:9222 localabstract:chrome_devtools_remote\n\n[adb]: https://developer.chrome.com/devtools/docs/remote-debugging-legacy\n\n##### WebView\n\nIn order to be inspectable, a WebView must\nbe [configured for debugging][webview] and the corresponding process ID must be\nknown. There are several ways to obtain it, for example:\n\n    adb shell grep -a webview_devtools_remote /proc/net/unix\n\nFinally, port forwarding can be enabled as follows:\n\n    adb forward tcp:9222 localabstract:webview_devtools_remote_<pid>\n\n[webview]: https://developers.google.com/web/tools/chrome-devtools/remote-debugging/webviews#configure_webviews_for_debugging\n\n### Opera\n\nStart Opera with the `--remote-debugging-port` option, for example:\n\n    opera --remote-debugging-port=9222\n\n### Node.js\n\nStart Node.js with the `--inspect` option, for example:\n\n    node --inspect=9222 script.js\n\n### Safari (iOS)\n\nInstall and run the [iOS WebKit Debug Proxy][iwdp]. Then use it with the `local`\noption set to `true` to use the local version of the protocol or pass a custom\ndescriptor upon connection (`protocol` option).\n\n[iwdp]: https://github.com/google/ios-webkit-debug-proxy\n\n### Edge\n\nStart Edge with the `--devtools-server-port` option, for example:\n\n    MicrosoftEdge.exe --devtools-server-port 9222 about:blank\n\nPlease find more information [here][edge-devtools].\n\n[edge-devtools]: https://docs.microsoft.com/en-us/microsoft-edge/devtools-protocol/\n\n### Firefox\n\nStart Firefox with the `--remote-debugger` option, for example:\n\n    firefox --remote-debugger\n\nJust make sure to set the `remote.enabled` preference to `true`.\n\n## Bundled client\n\nThis module comes with a bundled client application that can be used to\ninteractively control a remote instance.\n\n### Target management\n\nThe bundled client exposes subcommands to interact with the HTTP frontend\n(e.g., [List](#cdplistoptions-callback), [New](#cdpnewoptions-callback), etc.),\nrun with `--help` to display the list of available options.\n\nHere are some examples:\n\n```js\n$ chrome-remote-interface new \'http://example.com\'\n{\n    "description": "",\n    "devtoolsFrontendUrl": "/devtools/inspector.html?ws=localhost:9222/devtools/page/b049bb56-de7d-424c-a331-6ae44cf7ae01",\n    "id": "b049bb56-de7d-424c-a331-6ae44cf7ae01",\n    "thumbnailUrl": "/thumb/b049bb56-de7d-424c-a331-6ae44cf7ae01",\n    "title": "",\n    "type": "page",\n    "url": "http://example.com/",\n    "webSocketDebuggerUrl": "ws://localhost:9222/devtools/page/b049bb56-de7d-424c-a331-6ae44cf7ae01"\n}\n$ chrome-remote-interface close \'b049bb56-de7d-424c-a331-6ae44cf7ae01\'\n```\n\n### Inspection\n\nUsing the `inspect` subcommand it is possible to\nperform [command execution](#clientdomainmethodparams-callback)\nand [event binding](#clientdomaineventcallback) in a REPL fashion. But unlike\nthe regular API, events never return a promise, if the callback is omitted a\ndefault implementation is provided which allows to toggle the handler.\n\nRemember that the REPL interface provides completion.\n\nHere is a sample session:\n\n```js\n$ chrome-remote-interface inspect\n>>> Runtime.evaluate({expression: \'window.location.toString()\'})\n...\n{ result: { type: \'string\', value: \'about:blank\' } }\n>>> Page.enable()\n...\n{}\n>>> Page.loadEventFired() // registered\n{ \'Page.loadEventFired\': true }\n>>> Page.loadEventFired() // unregistered\n{ \'Page.loadEventFired\': false }\n>>> Page.loadEventFired() // registered\n{ \'Page.loadEventFired\': true }\n>>> Page.navigate({url: \'https://github.com\'})\n...\n{ frameId: \'15174.1\' }\n{ \'Page.loadEventFired\': { timestamp: 46427.780513 } }\n>>> Runtime.evaluate({expression: \'window.location.toString()\'})\n...\n{ result: { type: \'string\', value: \'https://github.com/\' } }\n```\n\n## Embedded documentation\n\nIn both the REPL and the regular API every object of the protocol is *decorated*\nwith the meta information found within the descriptor. In addition The\n`category` field is added, which determines if the member is a `command`, an\n`event` or a `type`.\n\nFor example to learn how to call `Page.navigate`:\n\n```js\n>>> Page.navigate\n{ [Function]\n  category: \'command\',\n  parameters: { url: { type: \'string\', description: \'URL to navigate the page to.\' } },\n  returns:\n   [ { name: \'frameId\',\n       \'$ref\': \'FrameId\',\n       hidden: true,\n       description: \'Frame id that will be navigated.\' } ],\n  description: \'Navigates current page to the given URL.\',\n  handlers: [ \'browser\', \'renderer\' ] }\n```\n\nTo learn about the parameters returned by the `Network.requestWillBeSent` event:\n\n```js\n>>> Network.requestWillBeSent\n{ [Function]\n  category: \'event\',\n  description: \'Fired when page is about to send HTTP request.\',\n  parameters:\n   { requestId: { \'$ref\': \'RequestId\', description: \'Request identifier.\' },\n     frameId:\n      { \'$ref\': \'Page.FrameId\',\n        description: \'Frame identifier.\',\n        hidden: true },\n     loaderId: { \'$ref\': \'LoaderId\', description: \'Loader identifier.\' },\n     documentURL:\n      { type: \'string\',\n        description: \'URL of the document this request is loaded for.\' },\n     request: { \'$ref\': \'Request\', description: \'Request data.\' },\n     timestamp: { \'$ref\': \'Timestamp\', description: \'Timestamp.\' },\n     wallTime:\n      { \'$ref\': \'Timestamp\',\n        hidden: true,\n        description: \'UTC Timestamp.\' },\n     initiator: { \'$ref\': \'Initiator\', description: \'Request initiator.\' },\n     redirectResponse:\n      { optional: true,\n        \'$ref\': \'Response\',\n        description: \'Redirect response data.\' },\n     type:\n      { \'$ref\': \'Page.ResourceType\',\n        optional: true,\n        hidden: true,\n        description: \'Type of this resource.\' } } }\n```\n\nTo inspect the `Network.Request` (note that unlike commands and events, types\nare named in upper camel case) type:\n\n```js\n>>> Network.Request\n{ category: \'type\',\n  id: \'Request\',\n  type: \'object\',\n  description: \'HTTP request data.\',\n  properties:\n   { url: { type: \'string\', description: \'Request URL.\' },\n     method: { type: \'string\', description: \'HTTP request method.\' },\n     headers: { \'$ref\': \'Headers\', description: \'HTTP request headers.\' },\n     postData:\n      { type: \'string\',\n        optional: true,\n        description: \'HTTP POST request data.\' },\n     mixedContentType:\n      { optional: true,\n        type: \'string\',\n        enum: [Object],\n        description: \'The mixed content status of the request, as defined in http://www.w3.org/TR/mixed-content/\' },\n     initialPriority:\n      { \'$ref\': \'ResourcePriority\',\n        description: \'Priority of the resource request at the time request is sent.\' } } }\n```\n\n## Chrome Debugging Protocol versions\n\nBy default `chrome-remote-interface` *asks* the remote instance to provide its\nown protocol.\n\nThis behavior can be changed by setting the `local` option to `true`\nupon [connection](#cdpoptions-callback), in which case the [local version] of\nthe protocol descriptor is used. This file is manually updated from time to time\nusing `scripts/update-protocol.sh` and pushed to this repository.\n\nTo further override the above behavior there are basically two options:\n\n- pass a custom protocol descriptor upon [connection](#cdpoptions-callback)\n  (`protocol` option);\n\n- use the *raw* version of the [commands](#clientsendmethod-params-callback)\n  and [events](#event-domainmethod) interface to use bleeding-edge features that\n  do not appear in the [local version] of the protocol descriptor;\n\n[local version]: lib/protocol.json\n\n## Browser usage\n\nThis module is able to run within a web context, with obvious limitations\nthough, namely external HTTP requests\n([List](#cdplistoptions-callback), [New](#cdpnewoptions-callback), etc.) cannot\nbe performed directly, for this reason the user must provide a global\n`criRequest` in order to use them:\n\n```js\nfunction criRequest(options, callback) {}\n```\n\n`options` is the same object used by the Node.js `http` module and `callback` is\na function taking two arguments: `err` (JavaScript `Error` object or `null`) and\n`data` (string result).\n\n### Using [webpack](https://webpack.github.io/)\n\nIt just works, simply require this module:\n\n```js\nconst CDP = require(\'chrome-remote-interface\');\n```\n\n### Using *vanilla* JavaScript\n\nTo generate a JavaScript file that can be used with a `<script>` element:\n\n1. run `npm install` from the root directory;\n\n2. manually run webpack with:\n\n        TARGET=var npm run webpack\n\n3. use as:\n\n    ```html\n    <script>\n      function criRequest(options, callback) { /*...*/ }\n    </script>\n    <script src="chrome-remote-interface.js"></script>\n    ```\n\n## API\n\nThe API consists of three parts:\n\n- *DevTools* methods (for those [implementations](#implementations) that support\n  them, e.g., [List](#cdplistoptions-callback), [New](#cdpnewoptions-callback),\n  etc.);\n\n- [connection](#cdpoptions-callback) establishment;\n\n- the actual [protocol interaction](#class-cdp).\n\n### CDP([options], [callback])\n\nConnects to a remote instance using the [Chrome Debugging Protocol].\n\n`options` is an object with the following optional properties:\n\n- `host`: HTTP frontend host. Defaults to `localhost`;\n- `port`: HTTP frontend port. Defaults to `9222`;\n- `secure`: HTTPS/WSS frontend. Defaults to `false`;\n- `useHostName`: do not perform a DNS lookup of the host. Defaults to `false`;\n- `alterPath`: a `function` taking and returning the path fragment of a URL\n  before that a request happens. Defaults to the identity function;\n- `target`: determines which target this client should attach to. The behavior\n  changes according to the type:\n\n  - a `function` that takes the array returned by the `List` method and returns\n    a target or its numeric index relative to the array;\n  - a target `object` like those returned by the `New` and `List` methods;\n  - a `string` representing the raw WebSocket URL, in this case `host` and\n    `port` are not used to fetch the target list, yet they are used to complete\n    the URL if relative;\n  - a `string` representing the target id.\n\n  Defaults to a function which returns the first available target according to\n  the implementation (note that at most one connection can be established to the\n  same target);\n- `protocol`: [Chrome Debugging Protocol] descriptor object. Defaults to use the\n  protocol chosen according to the `local` option;\n- `local`: a boolean indicating whether the protocol must be fetched *remotely*\n  or if the local version must be used. It has no effect if the `protocol`\n  option is set. Defaults to `false`.\n\nThese options are also valid properties of all the instances of the `CDP`\nclass. In addition to that, the `webSocketUrl` field contains the currently used\nWebSocket URL.\n\n`callback` is a listener automatically added to the `connect` event of the\nreturned `EventEmitter`. When `callback` is omitted a `Promise` object is\nreturned which becomes fulfilled if the `connect` event is triggered and\nrejected if the `error` event is triggered.\n\nThe `EventEmitter` supports the following events:\n\n#### Event: \'connect\'\n\n```js\nfunction (client) {}\n```\n\nEmitted when the connection to the WebSocket is established.\n\n`client` is an instance of the `CDP` class.\n\n#### Event: \'error\'\n\n```js\nfunction (err) {}\n```\n\nEmitted when `http://host:port/json` cannot be reached or if it is not possible\nto connect to the WebSocket.\n\n`err` is an instance of `Error`.\n\n### CDP.Protocol([options], [callback])\n\nFetch the [Chrome Debugging Protocol] descriptor.\n\n`options` is an object with the following optional properties:\n\n- `host`: HTTP frontend host. Defaults to `localhost`;\n- `port`: HTTP frontend port. Defaults to `9222`;\n- `secure`: HTTPS/WSS frontend. Defaults to `false`;\n- `useHostName`: do not perform a DNS lookup of the host. Defaults to `false`;\n- `alterPath`: a `function` taking and returning the path fragment of a URL\n  before that a request happens. Defaults to the identity function;\n- `local`: a boolean indicating whether the protocol must be fetched *remotely*\n  or if the local version must be returned. Defaults to `false`.\n\n`callback` is executed when the protocol is fetched, it gets the following\narguments:\n\n- `err`: a `Error` object indicating the success status;\n- `protocol`: the [Chrome Debugging Protocol] descriptor.\n\nWhen `callback` is omitted a `Promise` object is returned.\n\nFor example:\n\n```js\nconst CDP = require(\'chrome-remote-interface\');\nCDP.Protocol((err, protocol) => {\n    if (!err) {\n        console.log(JSON.stringify(protocol, null, 4));\n    }\n});\n```\n\n### CDP.List([options], [callback])\n\nRequest the list of the available open targets/tabs of the remote instance.\n\n`options` is an object with the following optional properties:\n\n- `host`: HTTP frontend host. Defaults to `localhost`;\n- `port`: HTTP frontend port. Defaults to `9222`;\n- `secure`: HTTPS/WSS frontend. Defaults to `false`;\n- `useHostName`: do not perform a DNS lookup of the host. Defaults to `false`;\n- `alterPath`: a `function` taking and returning the path fragment of a URL\n  before that a request happens. Defaults to the identity function.\n\n`callback` is executed when the list is correctly received, it gets the\nfollowing arguments:\n\n- `err`: a `Error` object indicating the success status;\n- `targets`: the array returned by `http://host:port/json/list` containing the\n  target list.\n\nWhen `callback` is omitted a `Promise` object is returned.\n\nFor example:\n\n```js\nconst CDP = require(\'chrome-remote-interface\');\nCDP.List((err, targets) => {\n    if (!err) {\n        console.log(targets);\n    }\n});\n```\n\n### CDP.New([options], [callback])\n\nCreate a new target/tab in the remote instance.\n\n`options` is an object with the following optional properties:\n\n- `host`: HTTP frontend host. Defaults to `localhost`;\n- `port`: HTTP frontend port. Defaults to `9222`;\n- `secure`: HTTPS/WSS frontend. Defaults to `false`;\n- `useHostName`: do not perform a DNS lookup of the host. Defaults to `false`;\n- `alterPath`: a `function` taking and returning the path fragment of a URL\n  before that a request happens. Defaults to the identity function;\n- `url`: URL to load in the new target/tab. Defaults to `about:blank`.\n\n`callback` is executed when the target is created, it gets the following\narguments:\n\n- `err`: a `Error` object indicating the success status;\n- `target`: the object returned by `http://host:port/json/new` containing the\n  target.\n\nWhen `callback` is omitted a `Promise` object is returned.\n\nFor example:\n\n```js\nconst CDP = require(\'chrome-remote-interface\');\nCDP.New((err, target) => {\n    if (!err) {\n        console.log(target);\n    }\n});\n```\n\n### CDP.Activate([options], [callback])\n\nActivate an open target/tab of the remote instance.\n\n`options` is an object with the following properties:\n\n- `host`: HTTP frontend host. Defaults to `localhost`;\n- `port`: HTTP frontend port. Defaults to `9222`;\n- `secure`: HTTPS/WSS frontend. Defaults to `false`;\n- `useHostName`: do not perform a DNS lookup of the host. Defaults to `false`;\n- `alterPath`: a `function` taking and returning the path fragment of a URL\n  before that a request happens. Defaults to the identity function;\n- `id`: Target id. Required, no default.\n\n`callback` is executed when the response to the activation request is\nreceived. It gets the following arguments:\n\n- `err`: a `Error` object indicating the success status;\n\nWhen `callback` is omitted a `Promise` object is returned.\n\nFor example:\n\n```js\nconst CDP = require(\'chrome-remote-interface\');\nCDP.Activate({id: \'CC46FBFA-3BDA-493B-B2E4-2BE6EB0D97EC\'}, (err) => {\n    if (!err) {\n        console.log(\'target is activated\');\n    }\n});\n```\n\n### CDP.Close([options], [callback])\n\nClose an open target/tab of the remote instance.\n\n`options` is an object with the following properties:\n\n- `host`: HTTP frontend host. Defaults to `localhost`;\n- `port`: HTTP frontend port. Defaults to `9222`;\n- `secure`: HTTPS/WSS frontend. Defaults to `false`;\n- `useHostName`: do not perform a DNS lookup of the host. Defaults to `false`;\n- `alterPath`: a `function` taking and returning the path fragment of a URL\n  before that a request happens. Defaults to the identity function;\n- `id`: Target id. Required, no default.\n\n`callback` is executed when the response to the close request is received. It\ngets the following arguments:\n\n- `err`: a `Error` object indicating the success status;\n\nWhen `callback` is omitted a `Promise` object is returned.\n\nFor example:\n\n```js\nconst CDP = require(\'chrome-remote-interface\');\nCDP.Close({id: \'CC46FBFA-3BDA-493B-B2E4-2BE6EB0D97EC\'}, (err) => {\n    if (!err) {\n        console.log(\'target is closing\');\n    }\n});\n```\n\nNote that the callback is fired when the target is *queued* for removal, but the\nactual removal will occur asynchronously.\n\n### CDP.Version([options], [callback])\n\nRequest version information from the remote instance.\n\n`options` is an object with the following optional properties:\n\n- `host`: HTTP frontend host. Defaults to `localhost`;\n- `port`: HTTP frontend port. Defaults to `9222`;\n- `secure`: HTTPS/WSS frontend. Defaults to `false`;\n- `useHostName`: do not perform a DNS lookup of the host. Defaults to `false`;\n- `alterPath`: a `function` taking and returning the path fragment of a URL\n  before that a request happens. Defaults to the identity function.\n\n`callback` is executed when the version information is correctly received, it\ngets the following arguments:\n\n- `err`: a `Error` object indicating the success status;\n- `info`: a JSON object returned by `http://host:port/json/version` containing\n  the version information.\n\nWhen `callback` is omitted a `Promise` object is returned.\n\nFor example:\n\n```js\nconst CDP = require(\'chrome-remote-interface\');\nCDP.Version((err, info) => {\n    if (!err) {\n        console.log(info);\n    }\n});\n```\n\n### Class: CDP\n\n#### Event: \'event\'\n\n```js\nfunction (message) {}\n```\n\nEmitted when the remote instance sends any notification through the WebSocket.\n\n`message` is the object received, it has the following properties:\n\n- `method`: a string describing the notification (e.g.,\n  `\'Network.requestWillBeSent\'`);\n- `params`: an object containing the payload.\n\nRefer to the [Chrome Debugging Protocol] specification for more information.\n\nFor example:\n\n```js\nclient.on(\'event\', (message) => {\n    if (message.method === \'Network.requestWillBeSent\') {\n        console.log(message.params);\n    }\n});\n```\n\n#### Event: \'`<domain>`.`<method>`\'\n\n```js\nfunction (params) {}\n```\n\nEmitted when the remote instance sends a notification for `<domain>.<method>`\nthrough the WebSocket.\n\n`params` is an object containing the payload.\n\nThis is just a utility event which allows to easily listen for specific\nnotifications (see [`\'event\'`](#event-event)), for example:\n\n```js\nclient.on(\'Network.requestWillBeSent\', console.log);\n```\n\n#### Event: \'ready\'\n\n```js\nfunction () {}\n```\n\nEmitted every time that there are no more pending commands waiting for a\nresponse from the remote instance. The interaction is asynchronous so the only\nway to serialize a sequence of commands is to use the callback provided by\nthe [`send`](#clientsendmethod-params-callback) method. This event acts as a\nbarrier and it is useful to avoid the *callback hell* in certain simple\nsituations.\n\nUsers are encouraged to extensively check the response of each method and should\nprefer the promises API when dealing with complex asynchronous program flows.\n\nFor example to load a URL only after having enabled the notifications of both\n`Network` and `Page` domains:\n\n```js\nclient.Network.enable();\nclient.Page.enable();\nclient.once(\'ready\', () => {\n    client.Page.navigate({url: \'https://github.com\'});\n});\n```\n\nIn this particular case, not enforcing this kind of serialization may cause that\nthe remote instance does not properly deliver the desired notifications the\nclient.\n\n\n#### Event: \'disconnect\'\n\n```js\nfunction () {}\n```\n\nEmitted when the instance closes the WebSocket connection.\n\nThis may happen for example when the user opens DevTools or when the tab is\nclosed.\n\n#### client.send(method, [params], [callback])\n\nIssue a command to the remote instance.\n\n`method` is a string describing the command.\n\n`params` is an object containing the payload.\n\n`callback` is executed when the remote instance sends a response to this\ncommand, it gets the following arguments:\n\n- `error`: a boolean value indicating the success status, as reported by the\n  remote instance;\n- `response`: an object containing either the response (`result` field, if\n  `error === false`) or the indication of the error (`error` field, if `error\n  === true`).\n\nWhen `callback` is omitted a `Promise` object is returned instead, with the\nfulfilled/rejected states implemented according to the `error` parameter. The\n`Error` object returned contains two additional parameters: `request` and\n`response` which contain the raw massages, useful for debugging purposes. In\ncase of low-level WebSocket errors, the `error` parameter contains the\noriginating `Error` object and no `response` is returned.\n\nNote that the field `id` mentioned in the [Chrome Debugging Protocol]\nspecification is managed internally and it is not exposed to the user.\n\nFor example:\n\n```js\nclient.send(\'Page.navigate\', {url: \'https://github.com\'}, console.log);\n```\n\n#### client.`<domain>`.`<method>`([params], [callback])\n\nJust a shorthand for:\n\n```js\nclient.send(\'<domain>.<method>\', params, callback);\n```\n\nFor example:\n\n```js\nclient.Page.navigate({url: \'https://github.com\'}, console.log);\n```\n\n#### client.`<domain>`.`<event>`([callback])\n\nJust a shorthand for:\n\n```js\nclient.on(\'<domain>.<event>\', callback);\n```\n\nWhen `callback` is omitted the event is registered only once and a `Promise`\nobject is returned.\n\nWhen `callback` is provided, it returns a function that can be used to\nunsubscribe `callback` from the event, it can be useful when anonymous functions\nare used as callbacks.\n\nFor example:\n\n```js\nconst unsubscribe = client.Network.requestWillBeSent((params) => {\n    console.log(params.request.url);\n});\nunsubscribe();\n```\n\n#### client.close([callback])\n\nClose the connection to the remote instance.\n\n`callback` is executed when the WebSocket is successfully closed.\n\nWhen `callback` is omitted a `Promise` object is returned.\n\n## FAQ\n\n### Invoking `Domain.method` I obtain `Domain.method is not a function`\n\nThis means that the Chrome version that you are using does not support\n`Domain.method`. The solution is to update to a newer version.\n\nSee [here](#chrome-debugging-protocol-versions) for more information.\n\n### Invoking `Domain.method` I obtain `Domain.method wasn\'t found`\n\nThis means that you are providing a custom protocol descriptor\n(`CDP({protocol: customProtocol})`) which declares `Domain.method` while the\nChrome version that you are using does not support it.\n\nTo inspect the currently available protocol descriptor use:\n\n```\n$ chrome-remote-interface inspect\n```\n\nSee [here](#chrome-debugging-protocol-versions) for more information.\n\n### Headless Chrome problems?\n\nBear in mind that `--headless` Chrome is relatively new and there are kinks (in\nChrome) that are being worked out. If you believe you have encountered a bug,\ntake a look at the open issues, especially [external issues].\n\n[external issues]: https://github.com/cyrus-and/chrome-remote-interface/issues?q=label%3A%22external+issue%22\n\n### Why my program stalls or behave unexpectedly if I run Chrome in a Docker container?\n\nThis happens because the size of `/dev/shm` is set to 64MB by default in Docker\nand may not be enough for Chrome to navigate certain web pages.\n\nYou can change this value by running your container with, say,\n`--shm-size=256m`.\n\n### Using `Runtime.evaluate` with `awaitPromise: true` I sometimes obtain `Error: Promise was collected`\n\nThis is thrown by `Runtime.evaluate` when the browser-side promise gets\n*collected* by the Chrome\'s garbage collector, this happens when the whole\nJavaScript execution environment is invalidated, e.g., a when page is navigated\nor reloaded while a promise is still waiting to be resolved.\n\nHere is an example:\n\n```\n$ chrome-remote-interface inspect\n>>> Runtime.evaluate({expression: `new Promise(() => {})`, awaitPromise: true})\n>>> Page.reload() // then wait several seconds\n{ result: {} }\n{ error: { code: -32000, message: \'Promise was collected\' } }\n```\n\nTo fix this, just make sure there are no pending promises before closing,\nreloading, etc. a page.\n\n### How does this compare to Puppeteer?\n\n[Puppeteer] is an additional high-level API built upon the [Chrome Debugging\nProtocol] which, among the other things, may start and use a bundled version of\nChromium instead of the one installed on your system. Use it if its API meets\nyour needs as it would probably be easier to work with.\n\nchrome-remote-interface instead is just a general purpose 1:1 Node.js binding\nfor the [Chrome Debugging Protocol]. Use it if you need all the power of the raw\nprotocol, e.g., to implement your own high-level API.\n\nSee [#240] for a more thorough discussion.\n\n[Puppeteer]: https://github.com/GoogleChrome/puppeteer\n[#240]: https://github.com/cyrus-and/chrome-remote-interface/issues/240\n\n## Contributors\n\n- [Andrey Sidorov](https://github.com/sidorares)\n- [Greg Cochard](https://github.com/gcochard)\n\n## Resources\n\n- [Chrome Debugging Protocol]\n- [Chrome Debugging Protocol Google group](https://groups.google.com/forum/#!forum/chrome-debugging-protocol)\n- [devtools-protocol official repo](https://github.com/ChromeDevTools/devtools-protocol)\n- [Showcase Chrome Debugging Protocol Clients](https://developer.chrome.com/devtools/docs/debugging-clients)\n- [Awesome chrome-devtools](https://github.com/ChromeDevTools/awesome-chrome-devtools)\n\n[Chrome Debugging Protocol]: https://chromedevtools.github.io/devtools-protocol/\n'