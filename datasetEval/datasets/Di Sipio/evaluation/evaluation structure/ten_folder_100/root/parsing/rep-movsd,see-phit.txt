b'# see-phit\n\nSee-phit is a compile time HTML templating library written in modern C++. \n\nYou write plain HTML as C++ string literals and it is parsed at compile time into a DOM like data structure.\n\nIt makes your "stringly typed" HTML text into an actual strongly typed DSL. \n\nC++14 is required to compile - it implements a fairly complete HTML parser as constexpr functions.\nBefore constexpr, the way to make C++ DSLs was by (ab)using operator overloading in ingenious ways, but now we can actually have a DSL as a user literal string and let the compiler compile your DSL into C++\n \n\nExample:\n``` cpp\n#include <iostream>\n#include "seephit.h"\nusing namespace std;\n\n\n\nint main()\n{\n  constexpr auto parser =\n    R"*(\n    <span >\n    <p  color="red" height=\'10\' >{{name}} is a {{profession}} in {{city}}</p  >\n    </span>\n    )*"_html;\n    \n  spt::tree spt_tree(parser);\n  \n  spt::template_dict dct;\n  dct["name"] = "Mary";\n  dct["profession"] = "doctor";\n  dct["city"] = "London";\n  \n  spt_tree.root.render(cerr, dct);\n  cerr << endl;\n  \n  dct["city"] = "New York";\n  dct["name"] = "John";\n  dct["profession"] = "janitor";\n\n  spt_tree.root.render(cerr, dct);\n  cerr << endl;\n}\n```\n\nproduces the following output\n``` html\n<HTML>\n  <span>\n    <p COLOR=\'red\' HEIGHT=\'10\'>\n    Mary is a doctor in London\n    </p>\n  </span>\n</HTML>\n\n<HTML>\n  <span>\n    <p COLOR=\'red\' HEIGHT=\'10\'>\n    John is a janitor in New York\n    </p>\n  </span>\n</HTML>\n```\nThe program will fail to compile if the HTML is malformed - We attempt to make the compiler generate the most sensible error message: \n\nFor example, the following fragment:\n    \n``` html\n<DIV>\nThis is a bad closing tag\n</DIVV>\n```\n\nGenerates the following compile errors in gcc:\n\n```\n$ g++ --std=c++14  -Wall main.cpp\nIn file included from seephit.h:21:0,\n                 from main.cpp:3:\nparse_error.h: In instantiation of \'constexpr spt::Error<ROW, COL, WHAT>::Error() [with int ROW = 4; int COL = 3; WHAT = spt::Mismatched_Close_Tag]\':\nmain.cpp:13:3:   required from here\nparse_error.h:40:15: error: incompatible types in assignment of \'const int\' to \'char [0]\'\n     SPTParser = fatal;\n     ~~~~~~~~~~^~~~~~~\n```\n    \nAnd the following in clang:\n\n```\n$ clang++ --std=c++14 -Wall main.cpp\nIn file included from main.cpp:3:\nIn file included from ./seephit.h:21:\n./parse_error.h:40:15: error: array type \'char [0]\' is not assignable\n    SPTParser = fatal;\n    ~~~~~~~~~ ^\nmain.cpp:13:3: note: in instantiation of member function \'spt::Error<4, 3, spt::Mismatched_Close_Tag>::Error\' requested here\n  REPORT_ERRORS(parser);\n  ^\n./parse_error_generated.h:100:94: note: expanded from macro \'REPORT_ERRORS\'\nspt::IF<hasErr, spt::Error<parser.errRow, parser.errCol, spt::MsgToType<parser.err>::type>> {};\n                                                                                             ^\n1 error generated.\n```\n\nSome complicated template magic has been implemented to show the ROW and COLUMN in the text where the error occured.\ngcc actually prints ROW = xxx and COL = xxx, which is great!\nIf your IDE does background parsing, it will indicate that your HTML template is malformed as you type it.\n\n### Limitations\nThe number of maximum nodes and attributes per parse is hardcoded to 1024.\n\n### Future plans\nAdd more complicated templating functionality with loops, conditionals and perhaps lambdas, and also allow this to be used on the frontend JS with emscripten.\n\nOptimize the hell out of the templating engine\n\n \n'