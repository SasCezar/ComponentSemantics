b'cpp-peglib\n==========\n\n[![Build Status](https://travis-ci.org/yhirose/cpp-peglib.svg?branch=master)](https://travis-ci.org/yhirose/cpp-peglib)\n[![Bulid Status](https://ci.appveyor.com/api/projects/status/github/yhirose/cpp-peglib?branch=master&svg=true)](https://ci.appveyor.com/project/yhirose/cpp-peglib)\n\nC++11 header-only [PEG](http://en.wikipedia.org/wiki/Parsing_expression_grammar) (Parsing Expression Grammars) library. You can start using it right away just by including `peglib.h` in your project.\n\nYou can also try the online version, PEG Playground at https://yhirose.github.io/cpp-peglib.\n\nThe PEG syntax is well described on page 2 in the [document](http://www.brynosaurus.com/pub/lang/peg.pdf). *cpp-peglib* also supports the following additional syntax for now:\n\n  * `\'...\'i` (Case-insensitive literal operator)\n  * `<` ... `>` (Token boundary operator)\n  * `~` (Ignore operator)\n  * `\\x20` (Hex number char)\n  * `%whitespace` (Automatic whitespace skipping)\n  * `%word` (Word expression)\n  * `$name(` ... `)` (Capture scope operator)\n  * `$name<` ... `>` (Named capture operator)\n  * `$name` (Backreference operator)\n  * `MACRO_NAME(` ... `)` (Parameterized rule or Macro)\n\nThis library also supports the linear-time parsing known as the [*Packrat*](http://pdos.csail.mit.edu/~baford/packrat/thesis/thesis.pdf) parsing.\n\n  IMPORTANT NOTE for some Linux distributions such as Ubuntu and CentOS: Need `-pthread` option when linking. See [#23](https://github.com/yhirose/cpp-peglib/issues/23#issuecomment-261126127), [#46](https://github.com/yhirose/cpp-peglib/issues/46#issuecomment-417870473) and [#62](https://github.com/yhirose/cpp-peglib/issues/62#issuecomment-492032680).\n\nHow to use\n----------\n\nThis is a simple calculator sample. It shows how to define grammar, associate samantic actions to the grammar, and handle semantic values.\n\n```cpp\n// (1) Include the header file\n#include <peglib.h>\n#include <assert.h>\n#include <iostream>\n\nusing namespace peg;\nusing namespace std;\n\nint main(void) {\n    // (2) Make a parser\n    auto grammar = R"(\n        # Grammar for Calculator...\n        Additive    <- Multitive \'+\' Additive / Multitive\n        Multitive   <- Primary \'*\' Multitive / Primary\n        Primary     <- \'(\' Additive \')\' / Number\n        Number      <- < [0-9]+ >\n        %whitespace <- [ \\t]*\n    )";\n\n    parser parser;\n\n    parser.log = [](size_t line, size_t col, const string& msg) {\n        cerr << line << ":" << col << ": " << msg << "\\n";\n    };\n\n    auto ok = parser.load_grammar(grammar);\n    assert(ok);\n\n    // (3) Setup actions\n    parser["Additive"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:  // "Multitive \'+\' Additive"\n            return any_cast<int>(sv[0]) + any_cast<int>(sv[1]);\n        default: // "Multitive"\n            return any_cast<int>(sv[0]);\n        }\n    };\n\n    parser["Multitive"] = [](const SemanticValues& sv) {\n        switch (sv.choice()) {\n        case 0:  // "Primary \'*\' Multitive"\n            return any_cast<int>(sv[0]) + any_cast<int>(sv[1]);\n        default: // "Primary"\n            return any_cast<int>(sv[0]);\n        }\n    };\n\n    parser["Number"] = [](const SemanticValues& sv) {\n        return stoi(sv.token(), nullptr, 10);\n    };\n\n    // (4) Parse\n    parser.enable_packrat_parsing(); // Enable packrat parsing.\n\n    int val;\n    parser.parse(" (1 + 2) * 3 ", val);\n\n    assert(val == 9);\n}\n```\n\nThere are four semantic actions available:\n\n```cpp\n[](const SemanticValues& sv, any& dt)\n[](const SemanticValues& sv)\n[](SemanticValues& sv, any& dt)\n[](SemanticValues& sv)\n```\n\n`SemanticValues` value contains the following information:\n\n - Semantic values\n - Matched string information\n - Token information if the rule is literal or uses a token boundary operator\n - Choice number when the rule is \'prioritized choise\'\n\n`any& dt` is a \'read-write\' context data which can be used for whatever purposes. The initial context data is set in `peg::parser::parse` method.\n\n`peg::any` is a simpler implementatin of std::any. If the compiler in use supports C++17, by default `peg::any` is defined as an alias to `std::any`.\n\nTo force using the simpler `any` implementation that comes with `cpp-peglib`, define `PEGLIB_USE_STD_ANY` as 0 before including `peglib.h`:\n```cpp\n#define PEGLIB_USE_STD_ANY 0\n#include <peglib.h>\n[...]\n```\n\nA semantic action can return a value of arbitrary data type, which will be wrapped by `peg::any`. If a user returns nothing in a semantic action, the first semantic value in the `const SemanticValues& sv` argument will be returned. (Yacc parser has the same behavior.)\n\nHere shows the `SemanticValues` structure:\n\n```cpp\nstruct SemanticValues : protected std::vector<any>\n{\n    // Input text\n    const char* path;\n    const char* ss;\n\n    // Matched string\n    std::string str() const;    // Matched string\n    const char* c_str() const;  // Matched string start\n    size_t      length() const; // Matched string length\n\n    // Line number and column at which the matched string is\n    std::pair<size_t, size_t> line_info() const;\n\n    // Tokens\n    std::vector<\n        std::pair<\n            const char*, // Token start\n            size_t>>     // Token length\n        tokens;\n\n    std::string token(size_t id = 0) const;\n\n    // Choice number (0 based index)\n    size_t      choice() const;\n\n    // Transform the semantic value vector to another vector\n    template <typename T> vector<T> transform(size_t beg = 0, size_t end = -1) const;\n}\n```\n\nThe following example uses `<` ... ` >` operator, which is *token boundary* operator.\n\n```cpp\nauto syntax = R"(\n    ROOT  <- _ TOKEN (\',\' _ TOKEN)*\n    TOKEN <- < [a-z0-9]+ > _\n    _     <- [ \\t\\r\\n]*\n)";\n\npeg pg(syntax);\n\npg["TOKEN"] = [](const SemanticValues& sv) {\n    // \'token\' doesn\'t include trailing whitespaces\n    auto token = sv.token();\n};\n\nauto ret = pg.parse(" token1, token2 ");\n```\n\nWe can ignore unnecessary semantic values from the list by using `~` operator.\n\n```cpp\npeg::parser parser(R"(\n    ROOT  <-  _ ITEM (\',\' _ ITEM _)*\n    ITEM  <-  ([a-z])+\n    ~_    <-  [ \\t]*\n)");\n\nparser["ROOT"] = [&](const SemanticValues& sv) {\n    assert(sv.size() == 2); // should be 2 instead of 5.\n};\n\nauto ret = parser.parse(" item1, item2 ");\n```\n\nThe following grammar is same as the above.\n\n```cpp\npeg::parser parser(R"(\n    ROOT  <-  ~_ ITEM (\',\' ~_ ITEM ~_)*\n    ITEM  <-  ([a-z])+\n    _     <-  [ \\t]*\n)");\n```\n\n*Semantic predicate* support is available. We can do it by throwing a `peg::parse_error` exception in a semantic action.\n\n```cpp\npeg::parser parser("NUMBER  <-  [0-9]+");\n\nparser["NUMBER"] = [](const SemanticValues& sv) {\n    auto val = stol(sv.str(), nullptr, 10);\n    if (val != 100) {\n        throw peg::parse_error("value error!!");\n    }\n    return val;\n};\n\nlong val;\nauto ret = parser.parse("100", val);\nassert(ret == true);\nassert(val == 100);\n\nret = parser.parse("200", val);\nassert(ret == false);\n```\n\n*enter* and *leave* actions are also avalable.\n\n```cpp\nparser["RULE"].enter = [](const char* s, size_t n, any& dt) {\n    std::cout << "enter" << std::endl;\n};\n\nparser["RULE"] = [](const SemanticValues& sv, any& dt) {\n    std::cout << "action!" << std::endl;\n};\n\nparser["RULE"].leave = [](const char* s, size_t n, size_t matchlen, any& value, any& dt) {\n    std::cout << "leave" << std::endl;\n};\n```\n\nIgnoring Whitespaces\n--------------------\n\nAs you can see in the first example, we can ignore whitespaces between tokens automatically with `%whitespace` rule.\n\n`%whitespace` rule can be applied to the following three conditions:\n\n  * trailing spaces on tokens\n  * leading spaces on text\n  * trailing spaces on literal strings in rules\n\nThese are valid tokens:\n\n```\nKEYWORD   <- \'keyword\'\nKEYWORDI  <- \'case_insensitive_keyword\'\nWORD      <-  < [a-zA-Z0-9] [a-zA-Z0-9-_]* >    # token boundary operator is used.\nIDNET     <-  < IDENT_START_CHAR IDENT_CHAR* >  # token boundary operator is used.\n```\n\nThe following grammar accepts ` one, "two three", four `.\n\n```\nROOT         <- ITEM (\',\' ITEM)*\nITEM         <- WORD / PHRASE\nWORD         <- < [a-z]+ >\nPHRASE       <- < \'"\' (!\'"\' .)* \'"\' >\n\n%whitespace  <-  [ \\t\\r\\n]*\n```\n\nWord expression\n---------------\n\n```cpp\npeg::parser parser(R"(\n    ROOT         <-  \'hello\' \'world\'\n    %whitespace  <-  [ \\t\\r\\n]*\n    %word        <-  [a-z]+\n)");\n\nparser.parse("hello world"); // OK\nparser.parse("helloworld");  // NG\n```\n\nCapture/Backreference\n---------------------\n\n```cpp\npeg::parser parser(R"(\n    ROOT      <- CONTENT\n    CONTENT   <- (ELEMENT / TEXT)*\n    ELEMENT   <- $(STAG CONTENT ETAG)\n    STAG      <- \'<\' $tag< TAG_NAME > \'>\'\n    ETAG      <- \'</\' $tag \'>\'\n    TAG_NAME  <- \'b\' / \'u\'\n    TEXT      <- TEXT_DATA\n    TEXT_DATA <- ![<] .\n)");\n\nparser.parse("This is <b>a <u>test</u> text</b>."); // OK\nparser.parse("This is <b>a <u>test</b> text</u>."); // NG\nparser.parse("This is <b>a <u>test text</b>.");     // NG\n```\n\nParameterized Rule or Macro\n---------------------------\n\n```peg\n# Syntax\nStart      \xe2\x86\x90 _ Expr\nExpr       \xe2\x86\x90 Sum\nSum        \xe2\x86\x90 List(Product, SumOpe)\nProduct    \xe2\x86\x90 List(Value, ProOpe)\nValue      \xe2\x86\x90 Number / T(\'(\') Expr T(\')\')\n\n# Token\nSumOpe     \xe2\x86\x90 T(\'+\' / \'-\')\nProOpe     \xe2\x86\x90 T(\'*\' / \'/\')\nNumber     \xe2\x86\x90 T([0-9]+)\n~_         \xe2\x86\x90 [ \\t\\r\\n]*\n\n# Macro\nList(I, D) \xe2\x86\x90 I (D I)*\nT(x)       \xe2\x86\x90 < x > _\n```\n\nAST generation\n--------------\n\n*cpp-peglib* is able to generate an AST (Abstract Syntax Tree) when parsing. `enable_ast` method on `peg::parser` class enables the feature.\n\n```\npeg::parser parser("...");\n\nparser.enable_ast();\n\nshared_ptr<peg::Ast> ast;\nif (parser.parse("...", ast)) {\n    cout << peg::ast_to_s(ast);\n\n    ast = peg::AstOptimizer(true).optimize(ast);\n    cout << peg::ast_to_s(ast);\n}\n```\n\n`peg::AstOptimizer` removes redundant nodes to make a AST simpler. You can make your own AST optimizers to fit your needs.\n\nSee actual usages in the [AST calculator example](https://github.com/yhirose/cpp-peglib/blob/master/example/calc3.cc) and [PL/0 language example](https://github.com/yhirose/cpp-peglib/blob/master/pl0/pl0.cc).\n\nMake a parser with parser combinators\n-------------------------------------\n\nInstead of makeing a parser by parsing PEG syntax text, we can also construct a parser by hand with *parser combinatorss*. Here is an example:\n\n```cpp\nusing namespace peg;\nusing namespace std;\n\nvector<string> tags;\n\nDefinition ROOT, TAG_NAME, _;\nROOT     <= seq(_, zom(seq(chr(\'[\'), TAG_NAME, chr(\']\'), _)));\nTAG_NAME <= oom(seq(npd(chr(\']\')), dot())), [&](const SemanticValues& sv) {\n                tags.push_back(sv.str());\n            };\n_        <= zom(cls(" \\t"));\n\nauto ret = ROOT.parse(" [tag1] [tag:2] [tag-3] ");\n```\n\nThe following are available operators:\n\n| Operator |     Description       |\n| :------- | :-------------------- |\n| seq      | Sequence              |\n| cho      | Prioritized Choice    |\n| zom      | Zero or More          |\n| oom      | One or More           |\n| opt      | Optional              |\n| apd      | And predicate         |\n| npd      | Not predicate         |\n| lit      | Literal string        |\n| liti     | Case-insensitive Literal string |\n| cls      | Character class       |\n| chr      | Character             |\n| dot      | Any character         |\n| tok      | Token boundary        |\n| ign      | Ignore semantic value |\n| csc      | Capture scope         |\n| cap      | Capture               |\n| bkr      | Back reference        |\n| usr      | User defined parser   |\n\nAdjust definitions\n------------------\n\nIt\'s possible to add/override definitions.\n\n```cpp\nauto syntax = R"(\n    ROOT <- _ \'Hello\' _ NAME \'!\' _\n)";\n\nRules additional_rules = {\n    {\n        "NAME", usr([](const char* s, size_t n, SemanticValues& sv, any& dt) -> size_t {\n            static vector<string> names = { "PEG", "BNF" };\n            for (const auto& name: names) {\n                if (name.size() <= n && !name.compare(0, name.size(), s, name.size())) {\n                    return name.size(); // processed length\n                }\n            }\n            return -1; // parse error\n        })\n    },\n    {\n        "~_", zom(cls(" \\t\\r\\n"))\n    }\n};\n\nauto g = parser(syntax, additional_rules);\n\nassert(g.parse(" Hello BNF! "));\n```\n\nUnicode support\n---------------\n\ncpp-peglib accepts UTF8 text. `.` matches a Unicode codepoint. Also, it supports `\\u????`.\n\npeglint - PEG syntax lint utility\n---------------------------------\n\n### Build peglint\n\n```\n> cd lint\n> mkdir build\n> cd build\n> cmake ..\n> make\n> ./peglint\nusage: peglint [--ast] [--optimize_ast_nodes|--opt] [--source text] [--trace] [grammar file path] [source file path]\n```\n\n### Lint grammar\n\n```\n> cat a.peg\nA <- \'hello\' ^ \'world\'\n\n> peglint a.peg\na.peg:1:14: syntax error\n```\n\n```\n> cat a.peg\nA <- B\n\n> peglint a.peg\na.peg:1:6: \'B\' is not defined.\n```\n\n```\n> cat a.peg\nA <- B / C\nB <- \'b\'\nC <- A\n\n> peglint a.peg\na.peg:1:10: \'C\' is left recursive.\na.peg:3:6: \'A\' is left recursive.\n```\n\n### Lint source text\n\n```\n> cat a.peg\nAdditive    <- Multitive \'+\' Additive / Multitive\nMultitive   <- Primary \'*\' Multitive / Primary\nPrimary     <- \'(\' Additive \')\' / Number\nNumber      <- < [0-9]+ >\n%whitespace <- [ \\t\\r\\n]*\n\n> peglint --source "1 + a * 3" a.peg\n[commendline]:1:3: syntax error\n```\n\n```\n> cat a.txt\n1 + 2 * 3\n\n> peglint --ast a.peg a.txt\n+ Additive\n  + Multitive\n    + Primary\n      - Number (1)\n  + Additive\n    + Multitive\n      + Primary\n        - Number (2)\n      + Multitive\n        + Primary\n          - Number (3)\n```\n\n```\n> peglint --ast --opt --source "1 + 2 * 3" a.peg\n+ Additive\n  - Multitive[Number] (1)\n  + Additive[Multitive]\n    - Primary[Number] (2)\n    - Multitive[Number] (3)\n```\n\nSample codes\n------------\n\n  * [Calculator](https://github.com/yhirose/cpp-peglib/blob/master/example/calc.cc)\n  * [Calculator (with parser operators)](https://github.com/yhirose/cpp-peglib/blob/master/example/calc2.cc)\n  * [Calculator (AST version)](https://github.com/yhirose/cpp-peglib/blob/master/example/calc3.cc)\n  * [PL/0 language example](https://github.com/yhirose/cpp-peglib/blob/master/pl0/pl0.cc)\n  * [A tiny PL/0 JIT compiler in less than 700 LOC with LLVM and PEG parser](https://github.com/yhirose/pl0-jit-compiler)\n\nPEG debug\n---------\n\nA debug viewer for Parsing Expression Grammars using cpp-peglib by [mqnc](https://github.com/mqnc). Please see [his gihub project page](https://github.com/mqnc/pegdebug) for the detail. You can see a parse result of PL/0 code [here](https://mqnc.github.io/pegdebug/example/output.html).\n\nTested compilers\n----------------\n\n  * Visual Studio 2017\n  * Visual Studio 2015\n  * Visual Studio 2013 with update 5\n  * Clang++ 5.0.1\n  * Clang++ 5.0\n  * Clang++ 4.0\n  * Clang++ 3.5\n  * G++ 5.4 on Ubuntu 16.04\n\nTODO\n----\n\n  * Advanced Unicode support ([Unicode regular expressoin](http://www.unicode.org/reports/tr18/))\n\nLicense\n-------\n\nMIT license (\xc2\xa9 2018 Yuji Hirose)\n'