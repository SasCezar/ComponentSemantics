b'# dissect.cstruct\nStructure parsing in Python made easy. With cstruct, you can write C-like structures and use them to parse binary data, either as file-like objects or bytestrings.\n\nParsing binary data with cstruct feels familiar and easy. No need to learn a new syntax or the quirks of a new parsing library before you can start parsing data. The syntax isn\'t strict C but it\'s compatible with most common structure definitions. You can often use structure definitions from open-source C projects and use them out of the box with little to no changes. Need to parse an EXT4 super block? Just copy the structure definition from the Linux kernel source code. Need to parse some custom file format? Write up a simple structure and immediately start parsing data, tweaking the structure as you go.\n\nBy design cstruct is incredibly simple. No complex syntax, filters, pre- or postprocessing steps. Just structure parsing.\n\n## Installation\n```\npip install dissect.cstruct\n```\n\n## Usage\nAll you need to do is instantiate a new cstruct instance and load some structure definitions in there. After that you can start using them from your Python code.\n\n```python\nfrom dissect import cstruct\n\n# Default endianness is LE, but can be configured using a kwarg or setting the \'endian\' attribute\n# e.g. cstruct.cstruct(endian=\'>\') or cparser.endian = \'>\'\ncparser = cstruct.cstruct()\ncparser.load("""\n#define SOME_CONSTANT   5\n\nenum Example : uint16 {\n    A, B = 0x5, C\n};\n\nstruct some_struct {\n    uint8   field_1;\n    char    field_2[SOME_CONSTANT];\n    char    field_3[field_1 & 1 * 5];  // Some random expression to calculate array length\n    Example field_4[2];\n};\n""")\n\ndata = b\'\\x01helloworld\\x00\\x00\\x06\\x00\'\nresult = cparser.some_struct(data)  # Also accepts file-like objects\nassert result.field_1 == 0x01\nassert result.field_2 == b\'hello\'\nassert result.field_3 == b\'world\'\nassert result.field_4 == [cparser.Example.A, cparser.Example.C]\n\nassert cparser.Example.A == 0\nassert cparser.Example.C == 6\nassert cparser.Example(5) == cparser.Example.B\n\nassert result.dumps() == data\n\n# You can also instantiate structures from Python by using kwargs\n# Note that array sizes are not enforced\ninstance = cparser.some_struct(field_1=5, field_2=\'lorem\', field_3=\'ipsum\', field_4=[cparser.Example.B, cparser.Example.A])\nassert instance.dumps() == b\'\\x05loremipsum\\x05\\x00\\x00\\x00\'\n```\n\nBy default, all structures are compiled into classes that provide optimised performance. You can disable this by passing a `compiled=False` keyword argument to the `.load()` call. You can also inspect the resulting source code by accessing the source attribute of the structure: `print(cparser.some_struct.source)`.\n\nMore examples can be found in the `examples` directory.\n\n## Features\n### Structure parsing\nWrite simple C-like structures and use them to parse binary data, as can be seen in the examples.\n\n### Type parsing\nAside from loading structure definitions, any of the supported types can be used individually for parsing data. For example, the following is all supported:\n\n```python\nfrom dissect import cstruct\ncs = cstruct.cstruct()\n# Default endianness is LE, but can be configured using a kwarg or setting the attribute\n# e.g. cstruct.cstruct(endian=\'>\') or cs.endian = \'>\'\nassert cs.uint32(b\'\\x05\\x00\\x00\\x00\') == 5\nassert cs.uint24[2](b\'\\x01\\x00\\x00\\x02\\x00\\x00\') == [1, 2]  # You can also parse arrays using list indexing\nassert cs.char[None](b\'hello world!\\x00\') == b\'hello world!\'  # A list index of None means null terminated\n```\n\n### Parse bit fields\nBit fields are supported as part of structures. They are properly aligned to their boundaries.\n\n```python\nbitdef = """\nstruct test {\n    uint16  a:1;\n    uint16  b:1;  # Read 2 bits from an uint16\n    uint32  c;    # The next field is properly aligned\n    uint16  d:2;\n    uint16  e:3;\n};\n"""\nbitfields = cstruct.cstruct()\nbitfields.load(bitdef)\n\nd = b\'\\x03\\x00\\xff\\x00\\x00\\x00\\x1f\\x00\'\na = bitfields.test(d)\n\nassert a.a == 0b1\nassert a.b == 0b1\nassert a.c == 0xff\nassert a.d == 0b11\nassert a.e == 0b111\nassert a.dumps() == d\n```\n\n### Enums\nThe API to access enum members and their values is similar to that of the native Enum type in Python 3. Functionally, it\'s best comparable to the IntEnum type.\n\n### Custom types\nYou can implement your own types by subclassing `BaseType` or `RawType`, and adding them to your cstruct instance with `addtype(name, type)`\n\n### Custom definition parsers\nDon\'t like the C-like definition syntax? Write your own syntax parser!\n\n## Todo\n- Nested structure definitions\n- Unions\n'