b'<p align="center"><img src="./Serpent_icon.png?raw=true" alt="Serpent"/></p>\n\n[![CircleCI](https://circleci.com/gh/nodes-ios/Serpent.svg?style=shield)](https://circleci.com/gh/nodes-ios/Serpent)\n[![Codecov](https://img.shields.io/codecov/c/github/nodes-ios/Serpent.svg)](https://codecov.io/github/nodes-ios/Serpent)\n[![codebeat badge](https://codebeat.co/badges/bf41edec-511c-405d-9036-a7253492c118)](https://codebeat.co/projects/github-com-nodes-ios-serpent)\n[![Carthage Compatible](https://img.shields.io/badge/carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)\n[![CocoaPods](https://img.shields.io/cocoapods/v/Serpent.svg)](https://cocoapods.org/pods/Serpent)    \n![Plaforms](https://img.shields.io/badge/platforms-iOS%20|%20macOS%20|%20tvOS%20|%20watchOS%20-lightgrey.svg)\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/nodes-ios/Serpent/blob/master/LICENSE)\n\n**Serpent** *(previously known as Serializable)* is a framework made for creating model objects or structs that can be easily serialized and deserialized from/to JSON. It\'s easily expandable and handles all common data types used when consuming a REST API, as well as recursive parsing of custom objects. Designed for use with Alamofire.\n\nIt\'s designed to be used together with our helper app, the [![ModelBoiler](http://i.imgur.com/V5UzMVk.png)](https://github.com/nodes-ios/ModelBoiler) [Model Boiler](https://github.com/nodes-ios/ModelBoiler), making model creation a breeze.\n\nSerpent is implemented using protocol extensions and static typing.\n\n## \xf0\x9f\x93\x91 Table of Contents\n\n- [\xf0\x9f\x90\x8d Why Serpent?](#-why-serpent)\n- [\xf0\x9f\x93\x9d Requirements](#-requirements)\n- [\xf0\x9f\x93\xa6 Installation](#-installation)\n\t- [Carthage](#carthage)\n\t- [CocoaPods](#cocoapods)\n\t- [Swift Package Manager](#swift-package-manager)\n- [\xf0\x9f\x94\xa7 Setup](#-setup)\n- [\xf0\x9f\x92\xbb Usage](#-usage)\n\t- [Getting started](#getting-started)\n\t- [Using Serpent models](#using-serpent-models)\n\t- [More complex examples](#more-complex-examples)\n\t- [Using with Alamofire](#using-with-alamofire)\n\t- [Date parsing](#date-parsing)\n- [\xf0\x9f\x91\xa5 Credits](#-credits)\n- [\xf0\x9f\x93\x84 License](#-license)\n\n## \xf0\x9f\x90\x8d Why Serpent?\nThere are plenty of other Encoding and Decoding frameworks available. Why should you use Serpent?\n\n* [Performance](https://github.com/nodes-ios/SerpentPerformanceComparison). Serpent is fast, up to 4x faster than similar frameworks.\n* [Features](https://github.com/nodes-ios/SerpentPerformanceComparison#-feature-comparison). Serpent can parse anything you throw at it. Nested objects, Enums, URLs, UIColor, you name it!\n* [![ModelBoiler](http://i.imgur.com/V5UzMVk.png)](https://github.com/nodes-ios/ModelBoiler) [Model Boiler](https://github.com/nodes-ios/ModelBoiler). Every framework of this kind requires tedious boilerplate code that takes forever to write.  [![ModelBoiler](http://i.imgur.com/V5UzMVk.png)](https://github.com/nodes-ios/ModelBoiler) [Model Boiler](https://github.com/nodes-ios/ModelBoiler) generates it for you instantly.\n* [Alamofire Integration](). Using the included Alamofire extensions makes implementing an API call returning parsed model data as simple as doing a one-liner!\n* [Expandability](). Parsing into other datatypes can easily be added.\n* [Persisting](). Combined with our caching framework [Cashier](https://github.com/nodes-ios/Cashier), Serpent objects can be very easily persisted to disk.\n* <a href = "https://github.com/nodes-ios/SerpentXcodeFileTemplate"><img src = "https://raw.githubusercontent.com/nodes-ios/SerpentXcodeFileTemplate/master/Serpent/Serpent%20Model.xctemplate/TemplateIcon.png" height = 25> Serpent Xcode File Template </a> makes it easier to create the model files in Xcode.\n\n## \xf0\x9f\x93\x9d Requirements\n\n* iOS 8.0+ / macOS 10.10+ / tvOS 9.0+ / watchOS 2.0+\n* Swift 3.0+  \n*(Swift 2.2 & Swift 2.3 supported in older versions)*\n\n## \xf0\x9f\x93\xa6 Installation\n\n### Carthage\n~~~bash\ngithub "nodes-ios/Serpent" ~> 1.0\n~~~\n\n> Last versions compatible with lower Swift versions:  \n>\n> **Swift 2.3**  \n> `github "nodes-ios/Serpent" == 0.13.2`\n>\n> **Swift 2.2**  \n> `github "nodes-ios/Serpent" == 0.11.2`\n>\n> **NOTE:** Serpent was previously known as **Serializable**.\n\n### CocoaPods\n\nChoose one of the following, add it to your `Podfile` and run `pod install`:\n\n~~~ruby\npod \'Serpent\', \'~> 1.0\' # Just core\npod \'Serpent/Extensions\', \'~> 1.0\' # Includes core and all extensions\npod \'Serpent/AlamofireExtension\', \'~> 1.0\' # Includes core and Alamofire extension\npod \'Serpent/CashierExtension\', \'~> 1.0\' # Includes core and Cashier extension\n~~~\n\n> **NOTE:** CocoaPods only supports Serpent using Swift version 3.0 and higher.\n\n### Swift Package Manager\n\nTo use Serpent as a [Swift Package Manager](https://swift.org/package-manager/) package just add the following to your `Package.swift` file.  \n\n~~~swift\nimport PackageDescription\n\nlet package = Package(\n    name: "YourPackage",\n    dependencies: [\n        .Package(url: "https://github.com/nodes-ios/Serpent.git", majorVersion: 1)\n    ]\n)\n~~~\n\n\n## \xf0\x9f\x94\xa7 Setup\n\nWe **highly** recommend you use our [![ModelBoiler](http://i.imgur.com/V5UzMVk.png)](https://github.com/nodes-ios/ModelBoiler) [Model Boiler](https://github.com/nodes-ios/ModelBoiler) to assist with generating the code needed to conform to Serpent. Instructions for installation and usage can be found at the [Model Boiler GitHub repository](https://github.com/nodes-ios/ModelBoiler).\n\n## \xf0\x9f\x92\xbb Usage\n\n### Getting started\n\nSerpent supports all primitive types, `enum`, `URL`, `Date`, `UIColor`, other `Serpent` model, and `Array` of all of the aforementioned types. Your variable declarations can have a default value or be optional.\n\nPrimitive types do not need to have an explicit type, if Swift is able to infer it normally. `var name: String = ""` works just as well as `var name = ""`. Optionals will of course need an explicit type.\n\n> **NOTE:** Enums you create must conform to `RawRepresentable`, meaning they must have an explicit type. Otherwise, the parser won\'t know what to do with the incoming data it receives.\n\n\n#### Create your model struct or class:\n\n~~~swift\nstruct Foo {\n\tvar id = 0\n\tvar name = ""\n\tvar address: String?\n}\n~~~\n\n> **NOTE:** Classes must be marked `final`.\n\n#### Add the required methods for `Encodable` and `Decodable`:\n\n~~~swift\nextension Foo: Serializable {\n    init(dictionary: NSDictionary?) {\n        id      <== (self, dictionary, "id")\n        name    <== (self, dictionary, "name")\n        address <== (self, dictionary, "address")\n    }\n\n    func encodableRepresentation() -> NSCoding {\n        let dict = NSMutableDictionary()\n        (dict, "id")      <== id\n        (dict, "name")    <== name\n        (dict, "address") <== address\n        return dict\n    }\n}\n~~~\n\n> **NOTE:** You can add conformance to `Serializable` which is a type alias for both `Encodable` and `Decodable`.\n\nAnd thats it! If you\'re using the [![ModelBoiler](http://i.imgur.com/V5UzMVk.png)](https://github.com/nodes-ios/ModelBoiler) [Model Boiler](https://github.com/nodes-ios/ModelBoiler), this extension will be generated for you, so that you don\'t need to type it all out for every model you have.\n\n### Using Serpent models\n\nNew instances of your model can be created with a dictionary, e.g. from parsed JSON.\n\n~~~swift\nlet dictionary = try JSONSerialization.jsonObject(with: someData, options: .allowFragments) as? NSDictionary\nlet newModel = Foo(dictionary: dictionary)\n~~~\n\nYou can generate a dictionary version of your model by calling `encodableRepresentation()`:\n\n~~~swift\nlet encodedDictionary = newModel.encodableRepresentation()\n~~~\n\n### More complex examples\n\nIn this example, we have two models, Student and School.\n\n~~~swift\nstruct Student {\n\tenum Gender: String {\n\t\tcase male = "male"\n\t\tcase female = "female"\n\t\tcase unspecified = "unspecified"\n\t}\n\n\tvar name = ""\n\tvar age: Int = 0\n\tvar gender: Gender?\n}\n\nstruct School {\n\tenum Sport: Int {\n\t\tcase football\n\t\tcase basketball\n\t\tcase tennis\n\t\tcase swimming\n\t}\n\n\tvar name = ""\n\tvar location = ""\n\tvar website: URL?\n\tvar students: [Student] = []\n\tvar sports: [Sport]?\n}\n~~~\n\n\nYou can get as complicated as you like, and the syntax will always remain the same. The extensions will be:\n\n~~~swift\nextension Student: Serializable {\n\tinit(dictionary: NSDictionary?) {\n\t\tname   <== (self, dictionary, "name")\n\t\tage    <== (self, dictionary, "age")\n\t\tgender <== (self, dictionary, "gender")\n\t}\n\n\tfunc encodableRepresentation() -> NSCoding {\n\t\tlet dict = NSMutableDictionary()\n\t\t(dict, "name")   <== name\n\t\t(dict, "age")    <== age\n\t\t(dict, "gender") <== gender\n\t\treturn dict\n\t}\n}\n\nextension School: Serializable {\n\tinit(dictionary: NSDictionary?) {\n\t\tname     <== (self, dictionary, "name")\n\t\tlocation <== (self, dictionary, "location")\n\t\twebsite  <== (self, dictionary, "website")\n\t\tstudents <== (self, dictionary, "students")\n\t\tsports   <== (self, dictionary, "sports")\n\t}\n\n\tfunc encodableRepresentation() -> NSCoding {\n\t\tlet dict = NSMutableDictionary()\n\t\t(dict, "name")     <== name\n\t\t(dict, "location") <== location\n\t\t(dict, "website")  <== website\n\t\t(dict, "students") <== students\n\t\t(dict, "sports")   <== sports\n\t\treturn dict\n\t}\n}\n~~~\nAgain, the [![ModelBoiler](http://i.imgur.com/V5UzMVk.png)](https://github.com/nodes-ios/ModelBoiler) [Model Boiler](https://github.com/nodes-ios/ModelBoiler) generates all of this code for you in less than a second!\n\n### Using with Alamofire\n\nSerpent comes integrated with Alamofire out of the box, through an extension on Alamofire\'s `Request` construct, that adds the function `responseSerializable(completion:unwrapper)`\n\nThe extension uses Alamofire\'s familiar `Response` type to hold the returned data, and uses its generic associated type to automatically parse the data.\n\nConsider an endpoint returning a single `school` structure matching the struct from the example above. To implement the call, simply add a function to your shared connection manager or where ever you like to put it:\n\n~~~swift\nfunc requestSchool(completion: @escaping (DataResponse<School>) -> Void) {\n\trequest("http://somewhere.com/school/1", method: .get).responseSerializable(completion)\n}\n~~~\n\nIn the consuming method you use it like this:\n\n~~~swift\nrequestSchool() { (response) in\n\tswitch response.result {\n\t\tcase .success(let school):\n\t\t\t//Use your new school object!\n\n\t\tcase .failure(let error):\n\t\t\t//Handle the error object, or check your Response for more detail\n\t}\n}\n~~~\n\nFor an array of objects, use the same technique:\n\n~~~swift\nstatic func requestStudents(completion: @escaping (DataResponse<[Student]>) -> Void) {\n\trequest("http://somewhere.com/school/1/students", method: .get).responseSerializable(completion)\n}\n~~~\n\nSome APIs wrap their data in containers. Use the `unwrapper` closure for that. Let\'s say your `/students` endpoint returns the data wrapped in a `students` object:\n\n~~~json\n{\n\t"students" : [\n\t\t{\n\t\t    "..." : "..."\n\t\t},\n\t\t{\n\t\t    "..." : "..."\n\t\t}\n\t]\n}\n~~~\n\nThe `unwrapper` closure has 2 input arguments: The `sourceDictionary` (the JSON Response Dictionary) and the `expectedType` (the *type* of the target Serpent). Return the object that will serve as the input for the Serializable initializer.\n\n~~~swift\nstatic func requestStudents(completion: (DataResponse<[Student]>) -> Void) {\n\trequest("http://somewhere.com/school/1/students", method: .get).responseSerializable(completion, unwrapper: { $0.0["students"] })\n}\n~~~\n\nIf you need to unwrap the response data in every call, you can install a default unwrapper using\n\n~~~swift\nParser.defaultWrapper = { sourceDictionary, expectedType in \n\t// You custom unwrapper here... \n\treturn sourceDictionary\n}\n~~~\n\nThe `expectedType` can be used to dynamically determine the key based on the type name using reflection. This is especially useful when handling paginated data.\n\nSee [here](https://github.com/nodes-ios/Nodes) for an example on how we use this in our projects at Nodes.\n\n***NOTE:*** `responseSerializable` Internally calls `validate().responseJSON()` on the request, so you don\'t have to do that.\n\n### Date parsing\nSerpent can create `Date` objects from the date strings in the JSON. By default, Serpent can parse the date strings from the following formats: `yyyy-MM-dd\'T\'HH:mm:ssZZZZZ`, `yyyy-MM-dd\'T\'HH:mm:ss`, `yyyy-MM-dd`. If you need to parse other date formats, you can do it by adding this line to your code (for example, in `AppDelegate`\'s `didFinishLaunchingWithOptions:`:\n\n~~~swift\nDate.customDateFormats = ["yyyyMMddHHmm", "yyyyMMdd"]    // add the custom date formats you need here\n~~~\n\nThe custom date formats won\'t replace the default ones, they will be still supported. \n\n## \xf0\x9f\x91\xa5 Credits\nMade with \xe2\x9d\xa4\xef\xb8\x8f at [Nodes](http://nodesagency.com).\n\n## \xf0\x9f\x93\x84 License\n**Serpent** is available under the MIT license. See the [LICENSE](https://github.com/nodes-ios/Serpent/blob/master/LICENSE) file for more info.\n'