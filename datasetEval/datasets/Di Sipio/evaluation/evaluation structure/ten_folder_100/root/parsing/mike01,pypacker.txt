b'# <span style="color:red">Please note: This respository has become staled due to relocation to GitLab. Visit https://gitlab.com/mike01/pypacker for up-to-date versions.</span>\n\n\n<p align="center">\n\t<img src="./pypacker_logo_large.png">\n</p>\n\n[![Build Status](https://travis-ci.org/mike01/pypacker.svg?branch=master)](https://travis-ci.org/mike01/pypacker)\n[![Code Health](https://landscape.io/github/mike01/pypacker/master/landscape.svg?style=flat)](https://landscape.io/github/mike01/pypacker/master)\n[![version](http://img.shields.io/pypi/v/pypacker.svg)](https://pypi.python.org/pypi/pypacker)\n[![supported-versions](https://img.shields.io/pypi/pyversions/pypacker.svg)](https://pypi.python.org/pypi/pypacker)\n[![supported-implementations](https://img.shields.io/pypi/implementation/pypacker.svg)](https://pypi.python.org/pypi/pypacker)\n[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-blue.svg)](LICENSE)\n\n# General information\nThis is Pypacker: The fastest and simplest packet manipulation lib for Python.\nIt lets you create packets manually by defining every aspect of all header data,\ndissect packets by parsing raw packet bytes, sending/receiving packets on different layers and intercepting packets.\n\n## What you can do with Pypacker\nCreate Packets giving specific values or take the defaults:\n\n```python\nfrom pypacker.layer3.ip import IP\nfrom pypacker.layer3.icmp import ICMP\n\nip = IP(src_s="127.0.0.1", dst_s="192.168.0.1", p=1) +\\\n\tICMP(type=8) +\\\n\tICMP.Echo(id=123, seq=1, body_bytes=b"foobar")\n\n# output packet\nprint("%s" % ip)\nIP(v_hl=45, tos=0, len=2A, id=0, off=0, ttl=40, p=1, sum=3B29, src=b\'\\x7f\\x00\\x00\\x01\', dst=b\'\\xc0\\xa8\\x00\\x01\', opts=[], handler=icmp)\nICMP(type=8, code=0, sum=C03F, handler=echo)\nEcho(id=7B, seq=1, ts=0, bytes=b\'foobar\')\n```\n\nRead packets from file (pcap/tcpdump format), analyze it and write them back:\n\n```python\nfrom pypacker import ppcap\nfrom pypacker.layer12 import ethernet\nfrom pypacker.layer3 import ip\nfrom pypacker.layer4 import tcp\n\npreader = ppcap.Reader(filename="packets_ether.pcap")\npwriter = ppcap.Writer(filename="packets_ether_new.pcap", linktype=ppcap.DLT_EN10MB)\n\nfor ts, buf in preader:\n\teth = ethernet.Ethernet(buf)\n\n\tif eth[ethernet.Ethernet, ip.IP, tcp.TCP] is not None:\n\t\tprint("%d: %s:%s -> %s:%s" % (ts, eth[ip.IP].src_s, eth[tcp.TCP].sport,\n\t\t\teth[ip.IP].dst_s, eth[tcp.TCP].dport))\n\t\tpwriter.write(eth.bin())\n\npwriter.close()\n```\n\nIntercept (and modificate) Packets eg for MITM:\n\n```python\n# Add iptables rule:\n# iptables -I INPUT 1 -p icmp -j NFQUEUE --queue-balance 0:2\nimport time\n\nfrom pypacker import interceptor\nfrom pypacker.layer3 import ip, icmp\n\n# ICMP Echo request intercepting\ndef verdict_cb(ll_data, ll_proto_id, data, ctx):\n\tip1 = ip.IP(data)\n\ticmp1 = ip1[icmp.ICMP]\n\n\tif icmp1 is None or icmp1.type != icmp.ICMP_TYPE_ECHO_REQ:\n\t\treturn data, interceptor.NF_ACCEPT\n\n\techo1 = icmp1[icmp.ICMP.Echo]\n\n\tif echo1 is None:\n\t\treturn data, interceptor.NF_ACCEPT\n\n\tpp_bts = b"PYPACKER"\n\tprint("changing ICMP echo request packet")\n\techo1.body_bytes = echo1.body_bytes[:-len(pp_bts)] + pp_bts\n\treturn ip1.bin(), interceptor.NF_ACCEPT\n\nictor = interceptor.Interceptor()\nictor.start(verdict_cb, queue_ids=[0, 1, 2])\nprint("now sind a ICMP echo request to localhost: ping 127.0.0.1")\ntime.sleep(999)\nictor.stop()\n```\n\nSend and receive packets:\n\n```python\n# send/receive raw bytes\nfrom pypacker import psocket\nfrom pypacker.layer12 import ethernet\nfrom pypacker.layer3 import ip\n\npsock = psocket.SocketHndl(mode=psocket.SocketHndl.MODE_LAYER_2, timeout=10)\n\nfor raw_bytes in psock:\n\teth = ethernet.Ethernet(raw_bytes)\n\tprint("Got packet: %r" % eth)\n\teth.reverse_address()\n\teth.ip.reverse_address()\n\tpsock.send(eth.bin())\n\t# stop on first packet\n\tbreak\n\npsock.close()\n```\n\n```python\n# send/receive using filter\nfrom pypacker import psocket\nfrom pypacker.layer3 import ip\nfrom pypacker.layer4 import tcp\n\npacket_ip = ip.IP(src_s="127.0.0.1", dst_s="127.0.0.1") + tcp.TCP(dport=80)\npsock = psocket.SocketHndl(mode=psocket.SocketHndl.MODE_LAYER_3, timeout=10)\n\ndef filter_pkt(pkt):\n\treturn pkt.ip.tcp.sport == 80\n\npsock.send(packet_ip.bin(), dst=packet_ip.dst_s)\npkts = psock.recvp(filter_match_recv=filter_pkt)\n\nfor pkt in pkts:\n\tprint("got answer: %r" % pkt)\n\npsock.close()\n\n```\n\n```python\n# Send/receive based on source/destination data\nfrom pypacker import psocket\nfrom pypacker.layer3 import ip\nfrom pypacker.layer4 import tcp\n\npacket_ip = ip.IP(src_s="127.0.0.1", dst_s="127.0.0.1") + tcp.TCP(dport=80)\npsock = psocket.SocketHndl(mode=psocket.SocketHndl.MODE_LAYER_3, timeout=10)\npackets = psock.sr(packet_ip, max_packets_recv=1)\n\nfor p in packets:\n    print("got layer 3 packet: %s" % p)\npsock.close()\n```\n\n## Key features\n\n- Create network packets on different OSI layers using keywords like MyPacket(value=123) or raw bytes MyPacket(b"value")\n- Concatination of layers via "+" like packet = layer1 + layer2\n- Fast access to layers via packet[tcp.TCP] or packet.sublayerXYZ.tcp notation\n- Readable packet structure using print(packet) or similar statements\n- Read/store packets via Pcap/tcpdump file reader/writer\n- Live packet reading/writing using a wrapped socket API\n- Auto Checksum calculation capabilities\n- Intercept Packets using NFQUEUE targets\n- Easily create new protocols (see FAQ below)\n\n\n## Prerequisites\n- Python 3.x (CPython, Pypy, Jython or whatever Interpreter)\n- Optional (for interceptor):\n  - CPython\n  - Linux based system\n  - iptables\n  - NFQUEUE target support in kernel for packet intercepting\n  - libnetfilter_queue library (see http://www.netfilter.org/projects/libnetfilter_queue)\n\n## Installation\nSome examples:\n- Download/clone pypacker -> python setup.py install (newest version)\n- pip install pypacker (synched to master on major version changes)\n\n## Usage examples\nSee examples/ and tests/test_pypacker.py.\n\n## Testing\nTests are executed as follows:\n\n1) Add Pypacker directory to the PYTHONPATH.\n\n- cd pypacker\n- export PYTHONPATH=$PYTHONPATH:$(pwd)\n\n2) execute tests\n\n- python tests/test_pypacker.py\n\n**Performance test results: pypacker**\n```\norC = Intel Core2 Duo CPU @ 1,866 GHz, 2GB RAM, CPython v3.6\norP = Intel Core2 Duo CPU @ 1,866 GHz, 2GB RAM, Pypy 5.10.1\nrounds per test: 10000\n=====================================\n>>> parsing (IP + ICMP)\norC = 86064 p/s\norP = 208346 p/s\n>>> creating/direct assigning (IP only header)\norC = 41623 p/s\norP = 59370 p/s\n>>> bin() without change (IP)\norC = 170356 p/s\norP = 292133 p/s\n>>> output with change/checksum recalculation (IP)\norC = 10104 p/s\norP = 23851 p/s\n>>> basic/first layer parsing (Ethernet + IP + TCP + HTTP)\norC = 62748 p/s\norP = 241047 p/s\n>>> changing Triggerlist element value (Ethernet + IP + TCP + HTTP)\norC = 101552 p/s\norP = 201994 p/s\n>>> changing Triggerlist/text based proto (Ethernet + IP + TCP + HTTP)\norC = 37249 p/s\norP = 272972 p/s\n>>> direct assigning and concatination (Ethernet + IP + TCP + HTTP)\norC = 7428 p/s\norP = 14315 p/s\n>>> full packet parsing (Ethernet + IP + TCP + HTTP)\norC = 6886 p/s\norP = 17040 p/s\n```\n\n**Performance test results: pypacker vs. dpkt vs. scapy**\n```\nComparing pypacker, dpkt and scapy performance (parsing Ethernet + IP + TCP + HTTP)\norC = Intel Core2 Duo CPU @ 1,866 GHz, 2GB RAM, CPython v3.6\norC2 = Intel Core2 Duo CPU @ 1,866 GHz, 2GB RAM, CPython v2.7\nrounds per test: 10000\n=====================================\n>>> testing pypacker parsing speed\norC = 17938 p/s\n>>> testing dpkt parsing speed\norC = 12431 p/s\n>>> testing scapy parsing speed\norC2 = 726 p/s\n```\n\n# FAQ\n\n**Q**:\tWhere should I start learn to use Pypacker?\n\n**A**:\tIf you allready know Scapy starting by reading the examples should be OK. Otherwise there\n\tis a general introduction to pypacker included at the doc\'s which shows the usage and concepts\n\tof pypacker.\n\n**Q**:\tHow fast is pypacker?\n\n**A**:\tSee results above. For detailed results on your machine execute tests.\n\n**Q**:\tIs there any documentation?\n\n**A**:\tPypacker is based on code of dpkt, which in turn didn\'t have any official and very little\n\tinternal code documentation. This made understanding of the internal behaviour tricky.\n\tAfter all the code documentation was pretty much extended for Pypacker. Documentation can\n\tbe found in these directories and files:\n- examples/ (many examples showing the usage of Pypacker)\n- wiki (general intro into pypacker)\n- pypacker.py (general Packet structure)\n\nProtocols itself (see layerXYZ) generally don\'t have much documentation because those are documented\nby their respective RFCs/official standards.\n\n**Q**:\tWhich protocols are supported?\n\n**A**:\tCurrently minimum supported protocols are:\n\tEthernet, Radiotap, IEEE80211, ARP, DNS, STP, PPP, OSPF, VRRP, DTP, IP, ICMP, PIM, IGMP, IPX,\n\tTCP, UDP, SCTP, HTTP, NTP, RTP, DHCP, RIP, SIP, Telnet, HSRP, Diameter, SSL, TPKT, Pmap, Radius, BGP\n\n**Q**:\tHow are protocols added?\n\n**A**:  Short answer: Extend Packet class and add the class variable `__hdr__` to define header fields.\n        Long answer: See examples/examples_new_protocol.py for a very complete example.\n\n**Q**: How can I contribute to this project?\n\n**A**: Please use the Github bug-tracker for bugs/feature request. Please read the bugtracker for\n     already known bugs before filing a new one. Patches can be send via pull request.\n\n**Q**:\tUnder which license Pypacker is issued?\n\n**A**:\tIt\'s the GPLv2 License (see LICENSE file for more information).\n\n**Q**:\tAre there any plans to support [protocol xyz]?\n\n**A**:\tSupport for particular protocols is added to Pypacker as a result of people contributing\n\tthat support - no formal plans for adding support for particular protocols in particular\n\tfuture releases exist. \n\n**Q**:\tThere is problem xyz with Pypacker using Windows 3.11/XP/7/8/mobile etc. Can you fix that?\n\n**A**:\tThe basic features should work with any OS. Optional ones may make trouble (eg interceptor)\n        and there will be no support for that. Why? Because quality matters and I won\'t give support for\n\tinferior systems. Think twice before chosing an operating system and deal with the consequences;\n\tdon\'t blame others for your decision. Alternatively: give me monetary compensation and I\'ll see\n\twhat I can do (;\n\n\n# Usage hints\n## Performance related\n- For maxmimum performance start accessing attributes at lowest level e.g. for filtering:\n```\n# This will lazy parse only needed layers behind the scenes\nif ether.src == "...":\n    ...\nelif ip.src == "...":\n    ...\nelif tcp.sport == "...":\n    ...\n```\n\n- Avoid to convert packets using the "%s" or "%r" format as it triggers parsing behind the scene:\n```\npkt = Ethernet() + IP() + TCP()\n# This parses ALL layers\npacket_print = "%s" % pkt\n```\n\n- Avoid searching for a layer using single-value index-notation via pkt[L] as it parses all layers until L is found or highest layer is reached:\n```\npacket_found = pkt[Telnet]\n# Alternative: Use multi-value index-notation. This will stop parsing at any non-matching layer:\npacket_found = pkt[Ethernet,IP,TCP,Telnet]\n```\n\n- For even more performance disable auto fields (affects calling bin(...)):\n```\npkt = ip.IP(src_s="1.2.3.4", dst_s="1.2.3.5") + tcp.TCP()\n# Disable checksum calculation (and any other update) for IP and TCP (only THIS packet instance)\npkt.sum_au_active = False\npkt.tcp.sum_au_active = False\nbts = pkt.bin(update_auto_fields=False)\n```\n\n- Enlarge receive/send buffers to get max performance. This can be done using the following commands\n\t(taken from: http://www.cyberciti.biz/faq/linux-tcp-tuning/):\n```\nsysctl -w net.core.rmem_max=12582912\nsysctl -w net.core.rmem_default=12582912\nsysctl -w net.core.wmem_max=12582912\nsysctl -w net.core.wmem_default=12582912\nsysctl -w net.core.optmem_max=2048000\nsysctl -w net.core.netdev_max_backlog=5000\nsysctl -w net.unix.max_dgram_qlen=1000\nsysctl -w net.ipv4.tcp_rmem="10240 87380 12582912"\nsysctl -w net.ipv4.tcp_wmem="10240 87380 12582912"\nsysctl -w net.ipv4.tcp_mem="21228 87380 12582912"\nsysctl -w net.ipv4.udp_mem="21228 87380 12582912"\nsysctl -w net.ipv4.tcp_window_scaling=1\nsysctl -w net.ipv4.tcp_timestamps=1\nsysctl -w net.ipv4.tcp_sack=1\n```\n\n## Misc related\n- Assemblation of TCP/UDP streams can be done by tshark using pipes\n\twith "-i -" and "-z follow,prot,mode,filter[,range]"\n'