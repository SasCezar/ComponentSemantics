b'# Wrangling Untrusted File Formats Safely\n\n([Formerly known as\nPuffs](https://groups.google.com/d/topic/puffslang/ZX-ymyf8xh0/discussion):\nParsing Untrusted File Formats Safely).\n\nWuffs is a domain-specific language and library for wrangling untrusted file\nformats safely. Wrangling includes parsing, decoding and encoding. Examples of\nsuch file formats include images, audio, video, fonts and compressed archives.\n\nUnlike the C programming language, Wuffs is safe with respect to buffer\noverflows, integer arithmetic overflows and null pointer dereferences. The key\ndifference between Wuffs and other memory-safe languages is that all such\nchecks are done at compile time, not at run time. *If it compiles, it is safe*,\nwith respect to those three bug classes.\n\nThe aim is to produce software libraries that are as safe as Go or Rust,\nroughly speaking, but as fast as C, and that can be used anywhere C libraries\nare used. This includes very large C/C++ products, such as popular web browsers\nand operating systems (using that term to include desktop and mobile user\ninterfaces, not just the kernel).\n\nThe trade-off in aiming for both safety and speed is that Wuffs programs take\nlonger for a programmer to write, as they have to explicitly annotate their\nprograms with proofs of safety. A statement like `x += 1` unsurprisingly means\nto increment the variable `x` by `1`. However, in Wuffs, such a statement is a\ncompile time error unless the compiler can also prove that `x` is not the\nmaximal value of `x`\'s type (e.g. `x` is not `255` if `x` is a `u8`), as the\nincrement would otherwise overflow. Similarly, an integer arithmetic expression\nlike `x / y` is a compile time error unless the compiler can also prove that\n`y` is not zero.\n\nWuffs is not a general purpose programming language. While technically\npossible, it is unlikely that a Wuffs compiler would be worth writing in Wuffs.\n\n\n## What Does Wuffs Code Look Like?\n\nThe [`std/lzw/decode_lzw.wuffs`](./std/lzw/decode_lzw.wuffs) file is a good\nexample. See the "Poking Around" section below for more guidance.\n\n\n## What Does Compile Time Checking Look Like?\n\nFor example, making this one-line edit to the GIF codec leads to a compile time\nerror. `wuffs gen` fails to generate the C code, i.e. fails to compile\n(transpile) the Wuffs code to C code:\n\n```diff\ndiff --git a/std/lzw/decode_lzw.wuffs b/std/lzw/decode_lzw.wuffs\nindex f878c5e..f10dcee 100644\n--- a/std/lzw/decode_lzw.wuffs\n+++ b/std/lzw/decode_lzw.wuffs\n@@ -98,7 +98,7 @@ pub func lzw_decoder.decode?(dst ptr buf1, src ptr buf1, src_final bool)() {\n                        in.dst.write?(x:s)\n\n                        if use_save_code {\n-                               this.suffixes[save_code] = c as u8\n+                               this.suffixes[save_code] = (c + 1) as u8\n                                this.prefixes[save_code] = prev_code as u16\n                        }\n```\n\n```\n$ wuffs gen std/gif\ncheck: expression "(c + 1) as u8" bounds [1 ..= 256] is not within bounds [0 ..= 255] at\n/home/n/go/src/github.com/google/wuffs/std/lzw/decode_lzw.wuffs:101. Facts:\n    n_bits < 8\n    c < 256\n    this.stack[s] == (c as u8)\n    use_save_code\n```\n\nIn comparison, this two-line edit will compile (but the "does it decode GIF\ncorrectly" tests then fail):\n\n```diff\ndiff --git a/std/lzw/decode_lzw.wuffs b/std/lzw/decode_lzw.wuffs\nindex f878c5e..b43443d 100644\n--- a/std/lzw/decode_lzw.wuffs\n+++ b/std/lzw/decode_lzw.wuffs\n@@ -97,8 +97,8 @@ pub func lzw_decoder.decode?(dst ptr buf1, src ptr buf1, src_final bool)() {\n                        // type checking, bounds checking and code generation for it).\n                        in.dst.write?(x:s)\n\n-                       if use_save_code {\n-                               this.suffixes[save_code] = c as u8\n+                       if use_save_code and (c < 200) {\n+                               this.suffixes[save_code] = (c + 1) as u8\n                                this.prefixes[save_code] = prev_code as u16\n                        }\n```\n\n```\n$ wuffs gen std/gif\ngen wrote:      /home/n/go/src/github.com/google/wuffs/gen/c/gif.c\ngen unchanged:  /home/n/go/src/github.com/google/wuffs/gen/h/gif.h\n$ wuffs test std/gif\ngen unchanged:  /home/n/go/src/github.com/google/wuffs/gen/c/gif.c\ngen unchanged:  /home/n/go/src/github.com/google/wuffs/gen/h/gif.h\ntest:           /home/n/go/src/github.com/google/wuffs/test/c/gif\ngif/basic.c     clang   PASS (8 tests run)\ngif/basic.c     gcc     PASS (8 tests run)\ngif/gif.c       clang   FAIL test_lzw_decode: bufs1_equal: wi: got 19311, want 19200.\ncontents differ at byte 3 (in hex: 0x000003):\n  000000: dcdc dc00 00d9 f5f9 f6df dc5f 393a 3a3a  ..........._9:::\n  000010: 3a3b 618e c8e4 e4e4 e5e4 e600 00e4 bbbb  :;a.............\n  000020: eded 8f91 9191 9090 9090 9190 9192 9192  ................\n  000030: 9191 9292 9191 9293 93f0 f0f0 f1f1 f2f2  ................\nexcerpts of got (above) versus want (below):\n  000000: dcdc dcdc dcd9 f5f9 f6df dc5f 393a 3a3a  ..........._9:::\n  000010: 3a3a 618e c8e4 e4e4 e5e4 e6e4 e4e4 bbbb  ::a.............\n  000020: eded 8f91 9191 9090 9090 9090 9191 9191  ................\n  000030: 9191 9191 9191 9193 93f0 f0f0 f1f1 f2f2  ................\n\ngif/gif.c       gcc     FAIL test_lzw_decode: bufs1_equal: wi: got 19311, want 19200.\ncontents differ at byte 3 (in hex: 0x000003):\n  000000: dcdc dc00 00d9 f5f9 f6df dc5f 393a 3a3a  ..........._9:::\n  000010: 3a3b 618e c8e4 e4e4 e5e4 e600 00e4 bbbb  :;a.............\n  000020: eded 8f91 9191 9090 9090 9190 9192 9192  ................\n  000030: 9191 9292 9191 9293 93f0 f0f0 f1f1 f2f2  ................\nexcerpts of got (above) versus want (below):\n  000000: dcdc dcdc dcd9 f5f9 f6df dc5f 393a 3a3a  ..........._9:::\n  000010: 3a3a 618e c8e4 e4e4 e5e4 e6e4 e4e4 bbbb  ::a.............\n  000020: eded 8f91 9191 9090 9090 9090 9191 9191  ................\n  000030: 9191 9191 9191 9193 93f0 f0f0 f1f1 f2f2  ................\n\nwuffs-test-c: some tests failed\nwuffs test: some tests failed\n```\n\n# Background\n\nDecoding untrusted data, such as images downloaded from across the web, have a\nlong history of security vulnerabilities. As of 2017, libpng is over 18 years\nold, and the [PNG specification is dated 2003](https://www.w3.org/TR/PNG/), but\nthat well examined C library is still getting [CVE\'s published in\n2017](https://www.cvedetails.com/vulnerability-list/vendor_id-7294/year-2017/Libpng.html).\n\nSandboxing and fuzzing can mitigate the danger, but they are reactions to C\'s\nfundamental unsafety. Newer programming languages remove entire classes of\npotential security bugs. Buffer overflows and null pointer dereferences are\namongst the most well known.\n\nLess well known are integer overflow bugs. Offset-length pairs, defining a\nsub-section of a file, are seen in many file formats, such as OpenType fonts\nand PDF documents. A conscientious C programmer might think to check that a\nsection of a file or a buffer is within bounds by writing `if (offset + length\n< end)` before processing that section, but that addition can silently\noverflow, and a maliciously crafted file might bypass the check.\n\nA variation on this theme is where `offset` is a pointer, exemplified by\n[capnproto\'s\nCVE-2017-7892](https://github.com/sandstorm-io/capnproto/blob/master/security-advisories/2017-04-17-0-apple-clang-elides-bounds-check.md)\nand [another\nexample](https://www.blackhat.com/docs/us-14/materials/us-14-Rosenberg-Reflections-on-Trusting-TrustZone.pdf).\nFor a pointer-typed offset, witnessing such a vulnerability can depend on both\nthe malicious input itself and the addresses of the memory the software used to\nprocess that input. Those addresses can vary from run to run and from system to\nsystem, e.g. 32-bit versus 64-bit systems and whether dynamically allocated\nmemory can have sufficiently high address values, and that variability makes it\nharder to reproduce and to catch such subtle bugs from fuzzing.\n\nIn C, some integer overflow is *undefined behavior*, as per [the C99 spec\nsection 3.4.3](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf). In\nGo, integer overflow is [silently\nignored](https://golang.org/ref/spec#Integer_overflow). In Rust, integer\noverflow is [checked at run time in debug mode and silently ignored in release\nmode](http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/)\nby default, as the run time performance penalty was deemed too great. In Swift,\nit\'s a [run time\nerror](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID37).\nIn D, it\'s [configurable](http://dconf.org/2017/talks/alexandrescu.pdf). Other\nlanguages like Python and Haskell can automatically spill into \'big integers\'\nlarger than 64 bits, but this can have a performance impact when such integers\nare used in inner loops.\n\nEven if overflow is checked, it is usually checked at run time. Similarly,\nmodern languages do their bounds checking at run time. An expression like\n`a[i]` is really `if ((0 <= i) && (i < a.length)) { use a[i] } else { throw }`,\nin mangled pseudo-code. Compilers for these languages can often eliminate many\nof these bounds checks, e.g. if `i` is an iterator index, but not always all of\nthem.\n\nThe run time cost is small, measured in nanoseconds. But if an image decoding\nlibrary has to eat this cost per pixel, and you have a megapixel image, then\nnanoseconds become milliseconds, and milliseconds can matter.\n\nIn comparison, in Wuffs, all bounds checks and arithmetic overflow checks\nhappen at compile time, with zero run time overhead.\n\n\n# Getting Started\n\nWuffs code (that is proved safe via explicit assertions) is compiled to C code\n(with those assertions removed) - it is transpiled. If you are a C/C++\nprogrammer and just want to *use* the C edition of the Wuffs standard library,\nthen clone the repository and look at the files in the `gen/c` and `gen/h`\ndirectories. No other software tools are required and there are no library\ndependencies, other than C standard library concepts like `<stdint.h>`\'s\n`uint32_t` type and `<string.h>`\'s `memset` function.\n\nIf your C/C++ project is large, you might want both the .c files (adding each\nto your build system) and the .h files. If your C/C++ project is small, you\nmight only need the .c files, not the .h files, as the .c files are designed to\nbe a [drop-in library](http://gpfault.net/posts/drop-in-libraries.txt.html).\nFor example, if you want a GIF decoder, you only need `gif.c`. See TODO for an\nexample. More complicated decoders might require multiple .c files - multiple\nmodules. For example, the PNG codec (TODO) requires the deflate codec, but they\nare separate files, since HTTP can use also deflate compression (also known as\ngzip or zlib, roughly speaking) without necessarily processing PNG images.\n\n\n## Getting Deeper\n\nIf you want to modify the Wuffs standard library, or compile your own Wuffs\ncode, you will need to do a little more work, and will have to install at least\nthe Go toolchain in order to build the Wuffs tools. To run the test suite, you\nmight also have to install C compilers like clang and gcc, as well as C\nlibraries (and their .h files) like libjpeg and libpng, as some tests compare\nthat Wuffs produces exactly the same output as these other libraries.\n\nRunning `go get -v github.com/google/wuffs/cmd/...` will download and install\nthe Wuffs tools. Change `get` to `install` to re-install those programs without\ndownloading, e.g. after you\'ve modified their source code, or after a manually\nissued `git pull`. The Wuffs tools that you\'ll most often use are `wuffsfmt`\n(analogous to `clang-format`, `gofmt` or `rustfmt`) and `wuffs` (roughly\nanalogous to `make`, `go` or `cargo`).\n\nYou should now be able to run `wuffs test`. If all goes well, you should see\nsome output containing the word "PASS" multiple times.\n\n\n## Poking Around\n\nFeel free to edit the `std/lzw/decode_lzw.wuffs` file, which implements the GIF\nLZW decoder. After editing, run `wuffs gen std/gif` or `wuffs test std/gif` to\nre-generate the C edition of the Wuffs standard library\'s GIF codec, and\noptionally run its tests.\n\nTry deleting an assert statement and re-running `wuffs gen`. The result should\nbe syntactically valid, but a compile error, as some bounds checks can no\nlonger be proven.\n\nFind the line `var bits u32`, which declares the bits variable and initializes\nit to zero. Try adding `bits -= 1` on a new line of code after it. Again,\n`wuffs gen` should fail, as the computation can underflow.\n\nSimilarly, replacing the line `var n_bits u32` with `var n_bits u32 = 10`\nshould fail, as an `n_bits < 8` assertion, a pre-condition, a few lines further\ndown again cannot be proven.\n\nSimilarly, changing the `4095` in `var prev_code u32[..= 4095]` either higher\nor lower should fail.\n\nTry adding `assert false` at various places, which should obviously fail, but\nshould also cause `wuffs gen` to print what facts the compiler can prove at\nthat point. This can be useful when debugging why Wuffs can\'t prove something\nyou think it should be able to.\n\n\n## Running the Tests\n\nIf you\'ve changed any of the tools (i.e. changed any `.go` code), re-run `go\ninstall -v github.com/google/wuffs/cmd/...` and `go test\ngithub.com/google/wuffs/lang/...`.\n\nIf you\'ve changed any of the libraries (i.e. changed any `.wuffs` code), run\n`wuffs test` or, ideally, `wuffs test -mimic` to also check that Wuffs\' output\nmimics (i.e. exactly matches) other libraries\' output, such as giflib for GIF,\nlibpng for PNG, etc.\n\nIf your library change is an optimization, run `wuffs bench` or `wuffs bench\n-mimic` both before and after your change to quantify the improvement. The\nmimic benchmark numbers should\'t change if you\'re only changing `.wuffs` code,\nbut seeing zero change in those numbers is a sanity check on any unrelated\nsystem variance, such as software updates or virus checkers running in the\nbackground.\n\n\n## Directory Layout\n\n- `lang` holds the Go libraries that implement the Wuffs language: tokenizer,\n  AST, parser, renderer, etc. The Wuffs tools are written in Go, but as\n  mentioned above, Wuffs transpiles to C code, and Go is not necessarily\n  involved if all you want is to use the C edition of Wuffs.\n- `lib` holds other Go libraries, not specific to the Wuffs language per se.\n- `internal` holds internal implementation details, as per Go\'s [internal\n  packages](https://golang.org/s/go14internal) convention.\n- `cmd` holds Wuffs\' command line tools, also written in Go.\n- `std` holds the Wuffs standard library\'s code. The initial focus is on\n  popular image codecs: BMP, GIF, JPEG, PNG, TIFF and WEBP.\n- `gen` holds the transpiled editions of that standard library. The initial\n  focus is generating C code. Later on, the repository might include generated\n  Go and Rust code.\n- `release` holds the releases of the Wuffs standard library.\n- `test` holds the regular tests for the Wuffs standard library.\n- `fuzz` holds the fuzz tests for the Wuffs standard library.\n- `script` holds miscellaneous utility programs.\n- `doc` holds documentation.\n- `example` holds example programs.\n\nFor a guide on how various things work together, the "99ff8e2 Let fields have\ndefault values" commit is an example of adding new Wuffs syntax and threading\nthat all the way through to C code generation and testing.\n\n\n# Documentation\n\n- [Changelog](./doc/changelog.md)\n- [Related Work](./doc/related-work.md)\n- [Roadmap](./doc/roadmap.md)\n- [Wuffs the Language](./doc/wuffs-the-language.md)\n- Wuffs the Library (TODO)\n\nMeasurements:\n\n- [Benchmarks](./doc/benchmarks.md)\n- [Binary Size](./doc/binary-size.md)\n- [Compatibility](./doc/compatibility.md)\n\n\n# Status\n\nProof of concept. Version 0.1 at best. API and ABI aren\'t stabilized yet. There\nare plenty of tests to create, docs to write and TODOs to do. The compiler\nundoubtedly has bugs. Assertion checking needs more rigor, especially around\nside effects and aliasing, and being sufficiently well specified to allow\nalternative implementations. Lots of detail needs work, but the broad\nbrushstrokes are there.\n\n\n# Discussion\n\nThe mailing list is at\n[https://groups.google.com/forum/#!forum/wuffs](https://groups.google.com/forum/#!forum/wuffs).\n\n\n# Contributing\n\nThe [CONTRIBUTING.md](./CONTRIBUTING.md) file contains instructions on how to\nfile the Contributor License Agreement before sending any pull requests (PRs).\nOf course, if you\'re new to the project, it\'s usually best to discuss any\nproposals and reach consensus before sending your first PR.\n\n\n# License\n\nApache 2. See the LICENSE file for details.\n\n\n# Disclaimer\n\nThis is not an official Google product, it is just code that happens to be\nowned by Google.\n\n\n---\n\nUpdated on October 2019.\n'