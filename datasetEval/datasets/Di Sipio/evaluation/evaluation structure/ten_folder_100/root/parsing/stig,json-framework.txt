b'SBJson 5\n========\n\nJSON (JavaScript Object Notation) is a light-weight data interchange format\nthat\'s easy to read and write for humans and computers alike. This library\nimplements stream/chunk-based JSON parsing and generation in Objective-C.\n\n[![CircleCI](https://circleci.com/gh/stig/json-framework.svg?style=svg)](https://circleci.com/gh/stig/json-framework)\n[![codecov.io](http://codecov.io/github/stig/json-framework/coverage.svg?branch=master)](http://codecov.io/github/stig/json-framework?branch=master)\n[![Project Status: Inactive - The project has reached a stable, usable state but is no longer being actively developed; support/maintenance will be provided as time allows.](http://www.repostatus.org/badges/0.1.0/inactive.svg)](http://www.repostatus.org/#inactive)\n[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)\n\nOverview\n========\n\nSBJson\'s number one feature is stream/chunk-based operation. Feed the parser one or\nmore chunks of UTF8-encoded data and it will call a block you provide with each\nroot-level document or array. Or, optionally, for each top-level entry in each\nroot-level array.\n\nWith this you can reduce the apparent latency for each\ndownload/parse cycle of documents over a slow connection. You can start\nparsing *and return chunks of the parsed document* before the full document\nhas downloaded. You can also parse massive documents bit by bit so you\ndon\'t have to keep them all in memory.\n\nSBJson maps JSON types to Objective-C types in the following way:\n\n| JSON Type | Objective-C Type                |\n|-----------|---------------------------------|\n| null      | NSNull                          |\n| string    | NSString                        |\n| array     | NSMutableArray                  |\n| object    | NSMutableDictionary             |\n| true      | -[NSNumber numberWithBool: YES] |\n| false     | -[NSNumber numberWithBool: NO]  |\n| number    | NSNumber                        |\n\n- Booleans roundtrip properly even though Objective-C doesn\'t have a\n  dedicated class for boolean values.\n- Integers use either `long long` or `unsigned long long` if they fit,\n  to avoid rounding errors.  For all other numbers we use the `double`\n  type, with all the potential rounding errors that entails.\n\n"Plain" Chunk Based Parsing\n---------------------------\n\nFirst define a simple block & an error handler. (These are just minimal\nexamples. You should strive to do something better that makes sense in your\napplication!)\n\n```objc\nSBJson5ValueBlock block = ^(id v, BOOL *stop) {\n    BOOL isArray = [v isKindOfClass:[NSArray class]];\n    NSLog(@"Found: %@", isArray ? @"Array" : @"Object");\n};\n\nSBJson5ErrorBlock eh = ^(NSError* err) {\n    NSLog(@"OOPS: %@", err);\n    exit(1);\n};\n```\n\nThen create a parser and add data to it:\n\n```objc\nid parser = [SBJson5Parser parserWithBlock:block\n                              errorHandler:eh];\n\nid data = [@"[true," dataWithEncoding:NSUTF8StringEncoding];\n[parser parse:data]; // returns SBJson5ParserWaitingForData\n\n// block is not called yet...\n\n// ok, now we add another value and close the array\n\ndata = [@"false]" dataWithEncoding:NSUTF8StringEncoding];\n[parser parse:data]; // returns SBJson5ParserComplete\n\n// the above -parse: method calls your block before returning.\n```\n\nAlright! Now let\'s look at something slightly more interesting.\n\nHandling multiple documents\n---------------------------\n\nThis is useful for something like Twitter\'s feed, which gives you one JSON\ndocument per line. Here is an example of parsing many consequtive JSON\ndocuments, where your block will be called once for each document:\n\n```objc\nid parser = [SBJson5Parser multiRootParserWithBlock:block\n                                       errorHandler:eh];\n\n// Note that this input contains multiple top-level JSON documents\nid data = [@"[]{}" dataWithEncoding:NSUTF8StringEncoding];\n[parser parse:data];\n[parser parse:data];\n```\n\nThe above example will print:\n\n```\nFound: Array\nFound: Object\nFound: Array\nFound: Object\n```\n\nUnwrapping a gigantic top-level array\n-------------------------------------\n\nOften you won\'t have control over the input you\'re parsing, so can\'t use a\nmultiRootParser. But, all is not lost: if you are parsing a long array you can\nget the same effect by using an unwrapRootArrayParser:\n\n```objc\nid parser = [SBJson5Parser unwrapRootArrayParserWithBlock:block\n                                             errorHandler:eh];\n\n// Note that this input contains A SINGLE top-level document\nid data = [@"[[],{},[],{}]" dataWithEncoding:NSUTF8StringEncoding];\n[parser parse:data];\n```\n\nOther features\n--------------\n\n* For safety there is a max nesting level for all input. This defaults to 32,\n  but is configurable.\n* The writer can sort dictionary keys so output is consistent across writes.\n* The writer can create human-readable output, with newlines and indents.\n* You can install SBJson v3, v4 and v5 side-by-side in the same application.\n  (This is possible because all classes & public symbols contains the major\n  version number.)\n\nA word of warning\n-----------------\n\nStream based parsing does mean that you lose some of the correctness\nverification you would have with a parser that considered the entire input\nbefore returning an answer. It is technically possible to have some parts of a\ndocument returned *as if they were correct* but then encounter an error in a\nlater part of the document. You should keep this in mind when considering\nwhether it would suit your application.\n\nAmerican Fuzzy Lop\n==================\n\nI\'ve run [AFL][] on the sbjson binary for over 24 hours, with no crashes\nfound. (I cannot reproduce the hangs reported when attempting to parse them\nmanually.)\n\n[AFL]: http://lcamtuf.coredump.cx/afl/\n\n```\n                       american fuzzy lop 2.35b (sbjson)\n\n\xe2\x94\x8c\xe2\x94\x80 process timing \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80 overall results \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x90\n\xe2\x94\x82        run time : 1 days, 0 hrs, 45 min, 26 sec      \xe2\x94\x82  cycles done : 2      \xe2\x94\x82\n\xe2\x94\x82   last new path : 0 days, 0 hrs, 5 min, 24 sec       \xe2\x94\x82  total paths : 555    \xe2\x94\x82\n\xe2\x94\x82 last uniq crash : none seen yet                      \xe2\x94\x82 uniq crashes : 0      \xe2\x94\x82\n\xe2\x94\x82  last uniq hang : 0 days, 2 hrs, 11 min, 43 sec      \xe2\x94\x82   uniq hangs : 19     \xe2\x94\x82\n\xe2\x94\x9c\xe2\x94\x80 cycle progress \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80 map coverage \xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n\xe2\x94\x82  now processing : 250* (45.05%)     \xe2\x94\x82    map density : 0.70% / 1.77%         \xe2\x94\x82\n\xe2\x94\x82 paths timed out : 0 (0.00%)         \xe2\x94\x82 count coverage : 3.40 bits/tuple       \xe2\x94\x82\n\xe2\x94\x9c\xe2\x94\x80 stage progress \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80 findings in depth \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n\xe2\x94\x82  now trying : auto extras (over)    \xe2\x94\x82 favored paths : 99 (17.84%)            \xe2\x94\x82\n\xe2\x94\x82 stage execs : 603/35.6k (1.70%)     \xe2\x94\x82  new edges on : 116 (20.90%)           \xe2\x94\x82\n\xe2\x94\x82 total execs : 20.4M                 \xe2\x94\x82 total crashes : 0 (0 unique)           \xe2\x94\x82\n\xe2\x94\x82  exec speed : 481.9/sec             \xe2\x94\x82   total hangs : 44 (19 unique)         \xe2\x94\x82\n\xe2\x94\x9c\xe2\x94\x80 fuzzing strategy yields \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80 path geometry \xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n\xe2\x94\x82   bit flips : 320/900k, 58/900k, 5/899k             \xe2\x94\x82    levels : 8          \xe2\x94\x82\n\xe2\x94\x82  byte flips : 0/112k, 4/112k, 3/112k                \xe2\x94\x82   pending : 385        \xe2\x94\x82\n\xe2\x94\x82 arithmetics : 66/6.24M, 0/412k, 0/35                \xe2\x94\x82  pend fav : 1          \xe2\x94\x82\n\xe2\x94\x82  known ints : 5/544k, 0/3.08M, 0/4.93M              \xe2\x94\x82 own finds : 554        \xe2\x94\x82\n\xe2\x94\x82  dictionary : 0/0, 0/0, 29/1.83M                    \xe2\x94\x82  imported : n/a        \xe2\x94\x82\n\xe2\x94\x82       havoc : 64/300k, 0/0                          \xe2\x94\x82 stability : 100.00%    \xe2\x94\x82\n\xe2\x94\x82        trim : 45.19%/56.5k, 0.00%                   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x98\n^C\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x98             [cpu: 74%]\n\n+++ Testing aborted by user +++\n[+] We\'re done here. Have a nice day!\n```\n\nAPI Documentation\n=================\n\nPlease see the [API Documentation](http://cocoadocs.org/docsets/SBJson) for\nmore details.\n\n\nInstallation\n============\n\nCocoaPods\n---------\n\nThe preferred way to use SBJson is by using\n[CocoaPods](http://cocoapods.org/?q=sbjson). In your Podfile use:\n\n    pod \'SBJson5\', \'~> 5.0.0\'\n\nCarthage\n--------\n\nSBJson is compatible with _Carthage_. Follow the [Getting Started Guide for iOS](https://github.com/Carthage/Carthage#if-youre-building-for-ios-tvos-or-watchos).\n\n\tgithub "stig/json-framework" == 5.0.0\n\nBundle the source files\n-----------------------\n\nAn alternative that I no longer recommend is to copy all the source files (the\ncontents of the `Classes` folder) into your own Xcode project.\n\nExamples\n========\n\n* https://github.com/stig/ChunkedDelivery - a toy example showing how one can\n  use `NSURLSessionDataDelegate` to do chunked delivery.\n* https://github.com/stig/DisplayPretty - a very brief example using SBJson 4\n  to reflow JSON on OS X.\n\nSupport\n=======\n\n* Check StackOverflow questions\n  [tagged with SBJson](http://stackoverflow.com/questions/tagged/sbjson) if\n  you have questions about how to use the library. I try to read all questions\n  with this tag.\n* Use the [issue tracker](http://github.com/stig/json-framework/issues) if you\n  have found a bug.\n\nLicense\n=======\n\nBSD. See [LICENSE](LICENSE) for details.\n'