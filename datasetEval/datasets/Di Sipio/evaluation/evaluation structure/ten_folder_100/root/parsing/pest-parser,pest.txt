b'<p align="center">\n  <img src="https://raw.github.com/pest-parser/pest/master/pest-logo.svg?sanitize=true" width="80%"/>\n</p>\n\n# pest. The Elegant Parser\n\n[![Join the chat at https://gitter.im/dragostis/pest](https://badges.gitter.im/dragostis/pest.svg)](https://gitter.im/dragostis/pest?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Book](https://img.shields.io/badge/book-WIP-4d76ae.svg)](https://pest-parser.github.io/book)\n[![Docs](https://docs.rs/pest/badge.svg)](https://docs.rs/pest)\n\n[![Build Status](https://travis-ci.org/pest-parser/pest.svg?branch=master)](https://travis-ci.org/pest-parser/pest)\n[![codecov](https://codecov.io/gh/pest-parser/pest/branch/master/graph/badge.svg)](https://codecov.io/gh/pest-parser/pest)\n[![Fuzzit Status](https://app.fuzzit.dev/badge?org_id=pest-parser)](https://app.fuzzit.dev/orgs/pest-parser/dashboard)\n[![Crates.io](https://img.shields.io/crates/d/pest.svg)](https://crates.io/crates/pest)\n[![Crates.io](https://img.shields.io/crates/v/pest.svg)](https://crates.io/crates/pest)\n\npest is a general purpose parser written in Rust with a focus on accessibility,\ncorrectness, and performance. It uses parsing expression grammars\n(or [PEG]) as input, which are similar in spirit to regular expressions, but\nwhich offer the enhanced expressivity needed to parse complex languages.\n\n[PEG]: https://en.wikipedia.org/wiki/Parsing_expression_grammar\n\n## Getting started\n\nThe recommended way to start parsing with pest is to read the official [book].\n\nOther helpful resources:\n\n* API reference on [docs.rs]\n* play with grammars and share them on our [fiddle]\n* leave feedback, ask questions, or greet us on [Gitter]\n\n[book]: https://pest-parser.github.io/book\n[docs.rs]: https://docs.rs/pest\n[fiddle]: https://pest-parser.github.io/#editor\n[Gitter]: https://gitter.im/dragostis/pest\n\n## Example\n\nThe following is an example of a grammar for a list of alpha-numeric identifiers\nwhere the first identifier does not start with a digit:\n\n```rust\nalpha = { \'a\'..\'z\' | \'A\'..\'Z\' }\ndigit = { \'0\'..\'9\' }\n\nident = { (alpha | digit)+ }\n\nident_list = _{ !digit ~ ident ~ (" " ~ ident)+ }\n          // ^\n          // ident_list rule is silent which means it produces no tokens\n```\n\nGrammars are saved in separate .pest files which are never mixed with procedural\ncode. This results in an always up-to-date formalization of a language that is\neasy to read and maintain.\n\n## Meaningful error reporting\n\nBased on the grammar definition, the parser also includes automatic error\nreporting. For the example above, the input `"123"` will result in:\n\n```\nthread \'main\' panicked at \' --> 1:1\n  |\n1 | 123\n  | ^---\n  |\n  = unexpected digit\', src/main.rs:12\n```\nwhile `"ab *"` will result in:\n```\nthread \'main\' panicked at \' --> 1:1\n  |\n1 | ab *\n  |    ^---\n  |\n  = expected ident\', src/main.rs:12\n```\n\n## Pairs API\n\nThe grammar can be used to derive a `Parser` implementation automatically.\nParsing returns an iterator of nested token pairs:\n\n```rust\nextern crate pest;\n#[macro_use]\nextern crate pest_derive;\n\nuse pest::Parser;\n\n#[derive(Parser)]\n#[grammar = "ident.pest"]\nstruct IdentParser;\n\nfn main() {\n \xc2\xa0 \xc2\xa0let pairs = IdentParser::parse(Rule::ident_list, "a1 b2").unwrap_or_else(|e| panic!("{}", e));\n\n    // Because ident_list is silent, the iterator will contain idents\n    for pair in pairs {\n        // A pair is a combination of the rule which matched and a span of input\n        println!("Rule:    {:?}", pair.as_rule());\n        println!("Span:    {:?}", pair.as_span());\n        println!("Text:    {}", pair.as_str());\n\n        // A pair can be converted to an iterator of the tokens which make it up:\n        for inner_pair in pair.into_inner() {\n            match inner_pair.as_rule() {\n                Rule::alpha => println!("Letter:  {}", inner_pair.as_str()),\n                Rule::digit => println!("Digit:   {}", inner_pair.as_str()),\n                _ => unreachable!()\n            };\n        }\n    }\n}\n```\n\nThis produces the following output:\n```\nRule:    ident\nSpan:    Span { start: 0, end: 2 }\nText:    a1\nLetter:  a\nDigit:   1\nRule:    ident\nSpan:    Span { start: 3, end: 5 }\nText:    b2\nLetter:  b\nDigit:   2\n```\n\n## Other features\n\n* Precedence climbing\n* Input handling\n* Custom errors\n* Runs on stable Rust\n\n## Projects using pest\n\n* [pest_meta](https://github.com/pest-parser/pest/blob/master/meta/src/grammar.pest) (bootstrapped)\n* [AshPaper](https://github.com/shnewto/ashpaper)\n* [brain](https://github.com/brain-lang/brain)\n* [Chelone](https://github.com/Aaronepower/chelone)\n* [comrak](https://github.com/kivikakk/comrak)\n* [elastic-rs](https://github.com/cch123/elastic-rs)\n* [graphql-parser](https://github.com/Keats/graphql-parser)\n* [handlebars-rust](https://github.com/sunng87/handlebars-rust)\n* [hexdino](https://github.com/Luz/hexdino)\n* [Huia](https://gitlab.com/jimsy/huia/)\n* [jql](https://github.com/yamafaktory/jql)\n* [json5-rs](https://github.com/callum-oakley/json5-rs)\n* [mt940](https://github.com/svenstaro/mt940-rs)\n* [py_literal](https://github.com/jturner314/py_literal)\n* [rouler](https://github.com/jarcane/rouler)\n* [RuSh](https://github.com/lwandrebeck/RuSh)\n* [rs_pbrt](https://github.com/wahn/rs_pbrt)\n* [stache](https://github.com/dgraham/stache)\n* [tera](https://github.com/Keats/tera)\n* [ui_gen](https://github.com/emoon/ui_gen)\n* [ukhasnet-parser](https://github.com/adamgreig/ukhasnet-parser)\n* [ZoKrates](https://github.com/ZoKrates/ZoKrates)\n\n## Special thanks\n\nA special round of applause goes to prof. Marius Minea for his guidance and all\npest contributors, some of which being none other than my friends.\n'