b'# ldetool means line data extraction tool\n[![Build Status](https://travis-ci.org/sirkon/ldetool.svg?branch=master)](https://travis-ci.org/sirkon/ldetool)\n\n`ldetool` is a command line utility to generate Go code for fast log files parsing.\n\n```bash\ngo get -u github.com/sirkon/ldetool\n```\n\n1. [Contributors](CONTRIBUTORS.md)\n1. [Rationale](RATIONALE.md)\n2. [Typical operations and formal set of rules](TOOL_RULES.md)\n3. [Performance comparison against regexp and Ragel](PERFORMANCE.md)\n5. [Usage examples](EXAMPLES.md)\n\n\n### How it works.\n1. First write extraction script, we usually name it `<something>.lde`\n2. Generate go code with `ldetool <something.lde> --package main`. Of course\n   you can use your own package name, not only `main`\n3. Use it via the generated extraction method `Parse(line []byte)`.\n\n> It turned out we like using it even for non-performant tasks, where we are dealing with strings, not slices of bytes \n> and it would be handy to use it for strings as well without manual type casting. There\'s an option to generate code\n> that use string, just put an option `--go-string`\n\n##### CLI utility options\n1. `--go-string` generates code that uses `string` everywhere instead of `[]byte`. You better not to use it for log processing as it may lead to excessive memory allocations.\n2. `--yaml-dict` or `--json-dict` sets translation rules for names. For instance, if we have YAML file with\n    ```yaml\n    http: HTTP\n    ```\n    and feed this file to the `ldetool` then every name (of field or rule itself) like `GetHttpHandle` or `get_http_hanlde` will be traslated into `GetHTTPHandle`\n3. `--package <pkg name>` name of the package to use in generated code. If a directory of `*.lde` file has other Go files package name will automatically setup with these files\' package name.\n4. `--big-endian` or `--little-endian` sets the target architecture to be either big or little endian. This\n    enables prefix check optimization \n\n#### Example\n\nTake a look at these two lines\n\n```\n[2017-09-02T22:48:13] FETCH first[1] format[JSON] hidden[0] userAgent[Android App v1.0] rnd[21341975] country[MA]\n[2017-09-02T22:48:14] FETCH first[0] format[JSON] userAgent[Android App v1.0] rnd[10000000] country[LC]\n```\n\nWe likely need a time, value of parameter `first`, `format`, `hidden`, `userAgent` and `country`. We obviously don\'t need `rnd`\n\n##### Extraction script syntax\nSee [more details](https://github.com/sirkon/ldetool/blob/master/TOOL_RULES.md) on extraction rules\n\n```perl\n# filename: line.lde\nLine =                                   # Name of the extraction object\' type\n  ^\'[\' Time(string) \']\'                  # The line must start with [, then take everything as a struct field Time string right to \']\' character\n  ^" FETCH "                             # Current rest must starts with " FETCH " string\n  ^"first[" First(uint8) \']\'[1]          # The rest must starts with "first[" characters, then take the rest until \']\' as uint8. It is\n                                         # known First is the single character, thus the [1] index.\n                                         # under the name of First\n  ^" format[" Format(string) ~\']\'        # Take format id. Format is a short word: XML, JSON, BIN. ~ before lookup oobject suggests\n                                         # generator to use for loop scan rather than IndexByte, which is although fast\n                                         # has call overhead as it cannot be inlined by Go compiler.\n  ?Hidden (^" hidden[" Value(uint8) \']\') # Optionally look for " hidden[\\d+]"\n  ^" user_agent[" UserAgent(string) \']\'  # User agent data\n  _ "country[" Country(string)  \']\'      # Look for the piece starting with country[\n;\n```\n\n##### Code generation\nThe recommended way is to put something like `//go:generate ldetool generate --package main Line.lde` in `generate.go` of a package and then generate a code with\n```bash\ngo generate <project path>\n```\nIt will be written into `line_lde.go` file in the same directory. It will look like [this](SAMPLE.md)\n\nNow, we have\n1. Data extractor type\n    ```go\n    // Line autogenerated parser\n    type Line struct {\n        Rest   []byte\n        Time   []byte\n        First  uint8\n        Format []byte\n        Hidden struct {\n            Valid bool\n            Value uint8\n        }\n        UserAgent []byte\n        Country   []byte\n    }\n    ```\n2. Parse method\n    ```go\n    // Extract autogenerated method of Line\n    func (p *Line) Extract(line []byte) (bool, error) {\n       \xe2\x80\xa6\n    }\n    ```\n    Take a look at return data. First bool signals if the data was successfully matched and error that is not nil signals if there were\n    any error. String to numeric failures are always treated as errors, you can put `!` into extraction script and all\n    mismatches after the sign will be treated as errors\n3. Helper to access optional `Hidden` area returning default Go value if the the area was not matched\n    ```go\n    // GetHiddenValue retrieves optional value for HiddenValue.Name\n    func (p *Line) GetHiddenValue() (res uint8) {\n        if !p.Hidden.Valid {\n            return\n        }\n        return p.Hidden.Value\n    }\n    ```\n\n##### Generated code usage\nIt is easy: put\n```go\nl := &Line{}\n```\nbefore and then feed `Extract` method with lines:\n```go\nscanner := bufio.NewScanner(reader)\nfor scanner.Scan() {\n    ok, err := l.Extract(scanner.Bytes())\n    if !ok {\n        if err != nil {\n            return err\n        }\n        continue\n    }\n    \xe2\x80\xa6\n    l.Format\n    l.Time\n    l.GetHiddenValue()\n    \xe2\x80\xa6\n}\n```\n\n#### custom types\n\n> Special thanks to Matt Hook (github.com/hookenz) who proposed this feature\n\nIt is possible to use custom types in generated structure. You should declare them first via\n\n```perl\ntype pkg.Type from "pkgpath";\n```\n\nfor external types and \n\n```perl\ntype typeName;\n```\n\nfor local types before all rules definitions and you can use them as field types. The parsing to be done via\n\n```go\np.unmarshal<FieldName>([]byte) (Type, error)\n``` \n\nfunction.\n\nExample:\n\n```perl\ntype time.Time from "time";\ntype net.IP from "net";\n\nCustom = Time(time.Time) \' \' ?Addr(^"addr: " IP(ip.IP) \' \');\n```\n\nNow, two parsing functions will be needed to parse this:\n\n```go\nfunc (p *Custom) unmarshalTime(s string) (time.Time, error) { \xe2\x80\xa6 }\n\nfunc (p *Custom) unmarshalAddrIP(s string) (net.IP, error) { \xe2\x80\xa6 }\n```\n'