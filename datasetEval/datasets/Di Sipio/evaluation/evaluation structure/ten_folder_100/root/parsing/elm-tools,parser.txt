b'# Parser + Nice Error Messages\n\nGoals:\n\n  - Make writing parsers as simple and fun as possible.\n  - Produce excellent error messages.\n  - Go pretty fast.\n\nThis is achieved with a couple concepts that I have not seen in any other parser libraries: [parser pipelines](#parser-pipelines), [tracking context](#tracking-context), and [delayed commits](#delayed-commits).\n\n\n## Parser Pipelines\n\nTo parse a 2D point like `( 3, 4 )`, you might create a `point` parser like this:\n\n```elm\nimport Parser exposing (Parser, (|.), (|=), succeed, symbol, float, ignore, zeroOrMore)\n\n\ntype alias Point =\n  { x : Float\n  , y : Float\n  }\n\n\npoint : Parser Point\npoint =\n  succeed Point\n    |. symbol "("\n    |. spaces\n    |= float\n    |. spaces\n    |. symbol ","\n    |. spaces\n    |= float\n    |. spaces\n    |. symbol ")"\n\n\nspaces : Parser ()\nspaces =\n  ignore zeroOrMore (\\c -> c == \' \')\n```\n\nAll the interesting stuff is happening in `point`. It uses two operators:\n\n  - [`(|.)`][ignore] means \xe2\x80\x9cparse this, but **ignore** the result\xe2\x80\x9d\n  - [`(|=)`][keep] means \xe2\x80\x9cparse this, and **keep** the result\xe2\x80\x9d\n\nSo the `Point` function only gets the result of the two `float` parsers.\n\n[ignore]: http://package.elm-lang.org/packages/elm-tools/parser/latest/Parser#|.\n[keep]: http://package.elm-lang.org/packages/elm-tools/parser/latest/Parser#|=\n\nThe theory is that `|=` introduces more \xe2\x80\x9cvisual noise\xe2\x80\x9d than `|.`, making it pretty easy to pick out which lines in the pipeline are important.\n\nI recommend having one line per operator in your parser pipeline. If you need multiple lines for some reason, use a `let` or make a helper function.\n\n\n## Tracking Context\n\nMost parsers tell you the row and column of the problem:\n\n    Something went wrong at (4:17)\n\nThat may be true, but it is not how humans think. It is how text editors think! It would be better to say:\n\n    I found a problem with this list:\n\n        [ 1, 23zm5, 3 ]\n             ^\n    I wanted an integer, like 6 or 90219.\n\nNotice that the error messages says `this list`. That is context! That is the language my brain speaks, not rows and columns.\n\nThis parser package lets you annotate context with the [`inContext`][inContext] function. You can let the parser know \xe2\x80\x9cI am trying to parse a `"list"` right now\xe2\x80\x9d so if an error happens anywhere in that context, you get the hand annotation!\n\n[inContext]: http://package.elm-lang.org/packages/elm-tools/parser/latest/Parser#inContext\n\n> **Note:** This technique is used by the parser in the Elm compiler to give more helpful error messages.\n\n\n## Delayed Commits\n\nTo make fast parsers with precise error messages, this package lets you control when a parser **commits** to a certain path.\n\nFor example, you are trying to parse the following list:\n\n```elm\n[ 1, 23zm5, 3 ]\n```\n\nIdeally, you want the error at the `z`, but the libraries I have seen make this difficult to achieve efficiently. You often end up with an error at `[` because \xe2\x80\x9csomething went wrong\xe2\x80\x9d.\n\n**This package introduces [`delayedCommit`][delayedCommit] to resolve this.**\n\nSay we want to create `intList`, a parser for comma separated lists of integers like `[1, 2, 3]`. We would say something like this:\n\n[delayedCommit]: http://package.elm-lang.org/packages/elm-tools/parser/latest/Parser#delayedCommit\n\n```elm\nimport Parser exposing (..)\n\n\n{-| We start by ignoring the opening square brace and some spaces.\nWe only really care about the numbers, so we parse an `int` and\nthen use `intListHelp` to start chomping other list entries.\n-}\nintList : Parser (List Int)\nintList =\n  succeed identity\n    |. symbol "["\n    |. spaces\n    |= andThen (\\n -> intListHelp [n]) int\n    |. spaces\n    |. symbol "]"\n\n\n{-| `intListHelp` checks if there is a `nextInt`. If so, it\ncontinues trying to find more list items. If not, it gives\nback the list of integers we have accumulated so far.\n-}\nintListHelp : List Int -> Parser (List Int)\nintListHelp revInts =\n  oneOf\n    [ nextInt\n        |> andThen (\\n -> intListHelp (n :: revInts))\n    , succeed (List.reverse revInts)\n    ]\n```\n\nNow we get to the tricky part! How do we define `nextInt`? Here are two approaches, but only the second one actually works!\n\n\n```elm\n-- BAD\nbadNextInt : Parser Int\nbadNextInt =\n  succeed identity\n    |. spaces\n    |. symbol ","\n    |. spaces\n    |= int\n\n-- GOOD\nnextInt : Parser Int\nnextInt =\n  delayedCommit spaces <|\n    succeed identity\n      |. symbol ","\n      |. spaces\n      |= int\n```\n\nThe `badNextInt` looks pretty normal, but it will not work. It commits as soon as the first `spaces` parser succeeds. It fails in the following situation:\n\n```elm\n[ 1, 2, 3 ]\n          ^\n```\n\nWhen we get to the closing `]` we have already successfully parsed some spaces. That means we are commited to `badNextInt` and need a comma. That fails, so the whole parse fails!\n\nWith `nextInt`, the [`delayedCommit`][delayedCommit] function is saying to parse `spaces` but only commit if progress is made *after* that. So we are only commited to this parser if we see a comma.\n\n<br>\n\n<br>\n\n## [Comparison with Prior Work](https://github.com/elm-tools/parser/blob/master/comparison.md)\n'