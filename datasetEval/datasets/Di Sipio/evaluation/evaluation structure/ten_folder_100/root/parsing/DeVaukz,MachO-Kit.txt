b'<p align="center">\n    <img width="850" height="200" src="https://raw.githubusercontent.com/DeVaukz/MachO-Kit/master/.github/banner.png">\n</p>\n\n## What is Mach-O Kit?\n\nMach-O Kit is an Objective-C framework for parsing Mach-O binaries used by Darwin platforms (macOS, iOS, tvOS, and watchOS).  The project also includes a lightweight C library - libMachO - for parsing Mach-O images loaded in the current process.\n\nMach-O Kit is designed to be easy to use while still exposing all the details of the parsed Mach-O file (if you need them).  It can serve as the foundation for anything that needs to read Mach-O files - from a one-off command line tool up to a fully featured interactive disassembler.  Most importantly, Mach-O Kit is designed to be safe.  Every read operation and its returned data is extensively error checked so that parsing a malformed Mach-O file (even a malicious one) does not crash your program.\n\n## Projects Using Mach-O Kit\n\n* [Mach-O Explorer](https://github.com/DeVaukz/MachO-Explorer) - A graphical Mach-O viewer for macOS.\n\n## Getting Started\n\nMach-O Kit supports 32/64 bit OS X 10.10+, iOS 8.0+, and tvOS 9.0+.\n\n*NOTE*: Mach-O Kit can build with older versions of Xcode.  However, the unit tests require the latest Xcode or command line tools to pass.\n\n### Obtaining Mach-O Kit\n\n***Use a recursive git clone***.\n\n```\ngit clone --recursive https://github.com/DeVaukz/MachO-Kit\n```\n\n### Installation\n\n1. Clone the Mach-O repository into your application\'s repository.\n```\ncd MyGreatApp;\ngit clone --recursive https://github.com/DeVaukz/MachO-Kit\n```\n2. Drag and drop MachOKit.xcodeproj into your application\xe2\x80\x99s Xcode project or workspace.\n3. On the \xe2\x80\x9cGeneral\xe2\x80\x9d tab of your application target\xe2\x80\x99s settings, add MachOKit.framework to the \xe2\x80\x9cEmbedded Binaries\xe2\x80\x9d section.\n\n### Using Mach-O Kit\n\nBefore Mach-O Kit can begin parsing a file, you must first create an `MKMemoryMap` for the file.  The memory map is used by the rest of Mach-O Kit to safely read the file\'s contents.  An `MKMemoryMap` can instead be instantiated with a task port for parsing a Mach-O image loaded in a process that you posses the task port for.\n\n```\nlet memoryMap = try! MKMemoryMap(contentsOfFile: URL(fileURLWithPath: "/System/Library/Frameworks/Foundation.framework/Foundation"))\n```\n\nIf the file is a FAT binary, Mach-O Kit provides the `MKFatBinary` class for parsing the FAT header.\n\n```\nlet fatBinary = try! MKFatBinary(memoryMap: memoryMap)\n\n# Retrieve the x86_64 slice\nlet slice64 = fatBinary.architectures.first { $0.cputype == CPU_TYPE_X86_64 }\n\n# Retrieve the offset of the x86_64 slice within the file\nlet slice64FileOffset = slice64!.offset\n```\n\nYou can now instantiate an instance of `MKMachOImage`.  This class is the top-level parser for a Mach-O binary.  `MKMachOImage` requires a memory map and an offset in the provided memory map to begin parsing.  For a FAT binary, this is the file offset of the slice you want to parse.  For in-process parsing, this is the load address of the Mach-O image which you can retrieve using the `dyld_*` APIs.\n\n```\nlet macho = try! MKMachOImage(name: "Foundation", flags: .init(rawValue: 0), atAddress: mk_vm_address_t(slice64FileOffset), inMapping: memoryMap)\n```\n\n#### Retrieving Load Commands\n\nLoad commands can be retrieved from the `loadCommands` property of `MKMachOImage`.  Each load command is represented by a instance of an `MKLoadCommand` subclass.\n\n```\nlet loadCommands = macho.loadCommands\n\nprint(loadCommands)\n``` \n\nMost classes in Mach-O Kit print verbose debug descriptions.  `MKLoadCommand` is no exception.\n\n```\n# The above code outputs:\n[\n   ...\n<MKLCLoadDylib 0x7fa647b36a30; contextAddress = 0x1f38; size = 104> {\n\tname.offset = 24\n\ttimestamp = 1970-01-01 00:00:02 +0000\n\tcurrent version = 1.0.0\n\tcompatibility version = 1.0.0\n\tname = <MKLoadCommandString 0x7fa647b49080; contextAddress = 0x1f50; size = 80> {\n\t\toffset = 24\n\t\tstring = /System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration\n\t}\n},\n   ...\n]\n```\n\n#### Dependent Libraries\n\nIf you just want to inspect the libraries that a Mach-O binary links against, `MKLoadCommand` includes a `dependentLibraries` property that returns an array of `MKDependentLibrary` instances.  `MKDependentLibrary` provides a slightly higher level interface than inspecting the load commands directly.\n\n```\n# Prints the names of all the libraries that Foundation links against\nfor library in macho.dependentLibraries {\n\tprint(library.value!.name)\n}\n```\n\n#### Objective-C Metadata\n\nMach-O Kit has complete support for parsing Objective-C metadata.  Here is how to print the names of all Objective-C classes in a Mach-O binary:\n\n```\nfor (_, section) in macho.sections {\n\t// Mach-O Kit instantiates specialized subclass of MKSection when it encounters a section containing Objective-C class list metadata\n\tguard let section = section as? MKObjCClassListSection else { continue }\n\t\n\tfor clsPointer in section.elements {\n\t\t// The __objc_(n)classlist sections are just a list of pointers to class structures in the data section\n\t\tguard let cls = clsPointer.pointee.value else { continue}\n\t\t// The pointer to the class name is stored in the class data structure\n\t\tguard let clsData = cls.classData.pointee.value else { continue }\n\t\t// Finally, the name is a pointer to a string in the strings section\n\t\tguard let clsName = clsData.name.pointee.value else { continue }\n\t\t\n\t\tprint(clsName)\n\t}\n}\n```\n\n\n## Status\n\nMach-O Kit currently supports executables, dynamic shared libraries (dylibs and frameworks), and bundles.  Parsing for the following are fully implemented or partially implemented:\n\n* Containers\n    * FAT Binary \xe2\x9c\x94\n    * DYLD Shared Cache (*needs further testing*)\n* Mach-O\n    * Header \xe2\x9c\x94\n    * Load Commands \xe2\x9c\x94 *except*\n        * LC_SYMSEG\n        * LC_THREAD\n        * LC_UNIXTHREAD\n        * LC_LOADFVMLIB\n        * LC_IDFVMLIB\n        * LC_IDENT\n        * LC_FVMFILE\n        * LC_PREPAGE\n        * LC_PREBOUND_DYLIB\n        * LC_SUB_UMBRELLA\n        * LC_LINKER_OPTION\n        * LC_LINKER_OPTIMIZATION_HINT\n    * Segments and Sections \xe2\x9c\x94\n        * Strings Section \xe2\x9c\x94\n        * Pointer List Section \xe2\x9c\x94\n        * Data Section \xe2\x9c\x94\n        * Stubs Section \xe2\x9c\x94\n        * Indirect Pointers Section \xe2\x9c\x94\n    * Rebase Information \xe2\x9c\x94\n        * Commands \xe2\x9c\x94\n        * Fixups \xe2\x9c\x94\n    * Bindings \xe2\x9c\x94\n        * Standard \xe2\x9c\x94\n        * Weak \xe2\x9c\x94\n        * Lazy \xe2\x9c\x94\n        * Threaded \xe2\x9c\x94 (*needs further testing*)\n    * Exports Information \xe2\x9c\x94\n    * Function Starts \xe2\x9c\x94\n    * Segment Split Info\n        * V1 \xe2\x9c\x94\n    * Data in Code Entries \xe2\x9c\x94\n    * Symbols \xe2\x9c\x94\n        * STABS: *All stabs can be parsed by Mach-O Kit (because all stabs are symbols).  Specialized subclasses with refined API are only provided for the subset of stab types that are emitted by Apple\'s modern development tools.*\n        * Undefined Symbols \xe2\x9c\x94\n        * Common Symbols \xe2\x9c\x94\n        * Absolute Symbols \xe2\x9c\x94\n        * Section Symbols \xe2\x9c\x94\n        * Alias Symbols \xe2\x9c\x94\n    * Indirect Symbols \xe2\x9c\x94\n* ObjC Metadata\n    * Image Info \xe2\x9c\x94\n    * Classes \xe2\x9c\x94\n    * Protocols \xe2\x9c\x94\n    * Methods \xe2\x9c\x94\n    * Properties \xe2\x9c\x94\n    * Instance Variables \xe2\x9c\x94\n    * Categories \xe2\x9c\x94\n    * ObjC-Specific Sections\n        * `__objc_imageinfo` \xe2\x9c\x94\n        * `__objc_selrefs` \xe2\x9c\x94\n        * `__objc_superrefs` \xe2\x9c\x94\n        * `__objc_protorefs` \xe2\x9c\x94\n        * `__objc_classrefs` \xe2\x9c\x94\n        * `__objc_classlist / __objc_nlclslist` \xe2\x9c\x94\n        * `__objc_catlist / __objc_nlcatlist` \xe2\x9c\x94\n        * `__objc_protolist` \xe2\x9c\x94\n        * `__objc_ivar` \xe2\x9c\x94\n        * `__objc_const` \xe2\x9c\x94\n        * `__objc_data` \xe2\x9c\x94\n* CF Data\n\t* CFString \xe2\x9c\x94\n\t* CF-Specific Sections\n\t\t* `__cfstring` \xe2\x9c\x94\n\n\n## libMachO\n\nlibMachO is a lightweight, C library for safely parsing Mach-O images loaded into a process.  You can use libMachO to parse Mach-O images in your own process or any process that your process posses the task port for.  \n\nAs with Mach-O Kit, access to memory by libMachO is mediated by a memory map.  All memory access is checked to prevent parsing a malformed Mach-O image from crashing the parser.  Included are memory maps for reading from the current process or from a task port.  Any differences between the target architecture of the Mach-O image and the process hosting libMachO are handled transparently.\n\nTo keep the library lightweight libMachO overlays itself atop the Mach-O image and provides a set of APIs for reading the underlying Mach-O data structures.  libMachO does not build up its own independent representation of the Mach-O image, opting to continuously walk the Mach-O structures to access requested data.  A consequence of this design is that libMachO generally expects well-formed Mach-O images.\n\nlibMachO does not perform any dynamic memory allocation.  Clients are responsible for allocating buffers which are then initialized by the functions called in libMachO.  Consequently, the lifetimes of these buffers must be managed by clients.\n\n## License\n\nMach-O Kit is released under the MIT license. See\n[LICENSE.md](https://github.com/DeVaukz/MachO-Kit/blob/master/LICENSE).\n'