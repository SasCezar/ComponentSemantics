b'# pom\n\n[![Crates.io](https://img.shields.io/crates/v/pom.svg)](https://crates.io/crates/pom)\n[![Build Status](https://travis-ci.org/J-F-Liu/pom.png)](https://travis-ci.org/J-F-Liu/pom)\n[![Docs](https://docs.rs/pom/badge.svg)](https://docs.rs/pom)\n[![Discord](https://img.shields.io/badge/discord-pom-red.svg)](https://discord.gg/CVy85pg)\n\nPEG parser combinators created using operator overloading without macros.\n\n## Document\n\n- [Tutorial](https://github.com/J-F-Liu/pom/blob/master/doc/article.md)\n- [API Reference](https://docs.rs/crate/pom/)\n- [Learning Parser Combinators With Rust](https://bodil.lol/parser-combinators/) - By Bodil Stokke\n\n## What is PEG?\n\nPEG stands for parsing expression grammar, is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language.\nUnlike CFGs, PEGs cannot be ambiguous; if a string parses, it has exactly one valid parse tree.\nEach parsing function conceptually takes an input string as its argument, and yields one of the following results:\n- success, in which the function may optionally move forward or consume one or more characters of the input string supplied to it, or\n- failure, in which case no input is consumed.\n\nRead more on [Wikipedia](https://en.wikipedia.org/wiki/Parsing_expression_grammar).\n\n## What is parser combinator?\n\nA parser combinator is a higher-order function that accepts several parsers as input and returns a new parser as its output.\nParser combinators enable a recursive descent parsing strategy that facilitates modular piecewise construction and testing.\n\nParsers built using combinators are straightforward to construct, readable, modular, well-structured and easily maintainable.\nWith operator overloading, a parser combinator can take the form of an infix operator, used to glue different parsers to form a complete rule.\nParser combinators thereby enable parsers to be defined in an embedded style, in code which is similar in structure to the rules of the formal grammar.\nAnd the code is easier to debug than macros.\n\nThe main advantage is that you don\'t need to go through any kind of code generation step, you\'re always using the vanilla language underneath.\nAside from build issues (and the usual issues around error messages and debuggability, which in fairness are about as bad with macros as with code generation), it\'s usually easier to freely intermix grammar expressions and plain code.\n\n## List of predefined parsers and combinators\n\n|Basic Parsers|Description|\n| --- | --- |\n|empty()|Always succeeds, consume no input.|\n|end()  |Match end of input.|\n|sym(t)|Match a single terminal symbol *t*.|\n|seq(s) |Match sequence of symbols.|\n|list(p,s) |Match list of *p*, separated by *s*.|\n|one_of(set) |Success when current input symbol is one of the set.|\n|none_of(set)|Success when current input symbol is none of the set.|\n|is_a(predicate) |Success when predicate return true on current input symbol.|\n|not_a(predicate)|Success when predicate return false on current input symbol.|\n|take(n)|Read *n* symbols.|\n|skip(n)|Skip *n* symbols.|\n|call(pf)|Call a parser factory, can be used to create recursive parsers.|\n\n|Parser Combinators|Description|\n| --- | --- |\n| p &#124; q | Match p or q, return result of the first success. |\n| p + q | Match p and q, if both succeed return a pair of results. |\n| p - q | Match p and q, if both succeed return result of p. |\n| p * q | Match p and q, if both succeed return result of q. |\n| p >> q | Parse p and get result P, then parse q and return result of q(P). |\n| -p | Success when p succeeds, doesn\'t consume input. |\n| !p | Success when p fails, doesn\'t consume input. |\n|p.opt()|Make parser optional. Returns an `Option`.|\n|p.repeat(m..n)| `p.repeat(0..)` repeat p zero or more times<br>`p.repeat(1..)` repeat p one or more times<br>`p.repeat(1..4)` match p at least 1 and at most 3 times<br>`p.repeat(5)` repeat p exactly 5 times|\n|p.map(f)|Convert parser result to desired value.|\n|p.convert(f)|Convert parser result to desired value, fails in case of conversion error.|\n|p.pos() |Get input position after matching p.|\n|p.collect()|Collect all matched input symbols.|\n|p.discard()|Discard parser output.|\n|p.name(_)|Give parser a name to identify parsing errors.|\n|p.expect(_)|Mark parser as expected, abort early when failed in ordered choice.|\n\nThe choice of operators is established by their operator precedence, arity and "meaning".\nUse `*` to ignore the result of first operand on the start of an expression, `+` and `-` can fulfill the need on the rest of the expression.\n\nFor example, `A * B * C - D + E - F` will return the results of C and E as a pair.\n\n## Example code\n```rust\nextern crate pom;\nuse pom::parser::*;\n\nlet input = b"abcde";\nlet parser = sym(b\'a\') * none_of(b"AB") - sym(b\'c\') + seq(b"de");\nlet output = parser.parse(input);\nassert_eq!(output, Ok( (b\'b\', vec![b\'d\', b\'e\']) ) );\n```\n\n### Example JSON parser\n```rust\nextern crate pom;\nuse pom::parser::*;\nuse pom::Parser;\n\nuse std::collections::HashMap;\nuse std::str::{self, FromStr};\n\n#[derive(Debug, PartialEq)]\npub enum JsonValue {\n\tNull,\n\tBool(bool),\n\tStr(String),\n\tNum(f64),\n\tArray(Vec<JsonValue>),\n\tObject(HashMap<String,JsonValue>)\n}\n\nfn space() -> Parser<u8, ()> {\n\tone_of(b" \\t\\r\\n").repeat(0..).discard()\n}\n\nfn number() -> Parser<u8, f64> {\n\tlet integer = one_of(b"123456789") - one_of(b"0123456789").repeat(0..) | sym(b\'0\');\n\tlet frac = sym(b\'.\') + one_of(b"0123456789").repeat(1..);\n\tlet exp = one_of(b"eE") + one_of(b"+-").opt() + one_of(b"0123456789").repeat(1..);\n\tlet number = sym(b\'-\').opt() + integer + frac.opt() + exp.opt();\n\tnumber.collect().convert(str::from_utf8).convert(|s|f64::from_str(&s))\n}\n\nfn string() -> Parser<u8, String> {\n\tlet special_char = sym(b\'\\\\\') | sym(b\'/\') | sym(b\'"\')\n\t\t| sym(b\'b\').map(|_|b\'\\x08\') | sym(b\'f\').map(|_|b\'\\x0C\')\n\t\t| sym(b\'n\').map(|_|b\'\\n\') | sym(b\'r\').map(|_|b\'\\r\') | sym(b\'t\').map(|_|b\'\\t\');\n\tlet escape_sequence = sym(b\'\\\\\') * special_char;\n\tlet string = sym(b\'"\') * (none_of(b"\\\\\\"") | escape_sequence).repeat(0..) - sym(b\'"\');\n\tstring.convert(String::from_utf8)\n}\n\nfn array() -> Parser<u8, Vec<JsonValue>> {\n\tlet elems = list(call(value), sym(b\',\') * space());\n\tsym(b\'[\') * space() * elems - sym(b\']\')\n}\n\nfn object() -> Parser<u8, HashMap<String, JsonValue>> {\n\tlet member = string() - space() - sym(b\':\') - space() + call(value);\n\tlet members = list(member, sym(b\',\') * space());\n\tlet obj = sym(b\'{\') * space() * members - sym(b\'}\');\n\tobj.map(|members|members.into_iter().collect::<HashMap<_,_>>())\n}\n\nfn value() -> Parser<u8, JsonValue> {\n\t( seq(b"null").map(|_|JsonValue::Null)\n\t| seq(b"true").map(|_|JsonValue::Bool(true))\n\t| seq(b"false").map(|_|JsonValue::Bool(false))\n\t| number().map(|num|JsonValue::Num(num))\n\t| string().map(|text|JsonValue::Str(text))\n\t| array().map(|arr|JsonValue::Array(arr))\n\t| object().map(|obj|JsonValue::Object(obj))\n\t) - space()\n}\n\npub fn json() -> Parser<u8, JsonValue> {\n\tspace() * value() - end()\n}\n\nfn main() {\n\tlet input = br#"\n\t{\n        "Image": {\n            "Width":  800,\n            "Height": 600,\n            "Title":  "View from 15th Floor",\n            "Thumbnail": {\n                "Url":    "http://www.example.com/image/481989943",\n                "Height": 125,\n                "Width":  100\n            },\n            "Animated" : false,\n            "IDs": [116, 943, 234, 38793]\n        }\n    }"#;\n\n\tprintln!("{:?}", json().parse(input));\n}\n```\nYou can run this example with the following command:\n```\ncargo run --example json\n```\n\n## Benchmark\n\n| Parser           | Time to parse the same JSON file |\n|------------------|----------------------------------|\n| pom: json_byte   | 621,319 ns/iter (+/- 20,318)     |\n| pom: json_char   | 627,110 ns/iter (+/- 11,463)     |\n| [pest](https://github.com/dragostis/pest): json_char  | 13,359 ns/iter (+/- 811)|\n'