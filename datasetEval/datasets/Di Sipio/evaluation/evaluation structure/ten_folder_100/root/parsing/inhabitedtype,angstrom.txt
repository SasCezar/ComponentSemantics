b"# Angstrom\n\nAngstrom is a parser-combinator library that makes it easy to write efficient,\nexpressive, and reusable parsers suitable for high-performance applications. It\nexposes monadic and applicative interfaces for composition, and supports\nincremental input through buffered and unbuffered interfaces. Both interfaces\ngive the user total control over the blocking behavior of their application,\nwith the unbuffered interface enabling zero-copy IO. Parsers are backtracking\nby default and support unbounded lookahead.\n\n[![Build Status](https://travis-ci.org/inhabitedtype/angstrom.svg?branch=master)](https://travis-ci.org/inhabitedtype/angstrom)\n\n\n## Installation\n\nInstall the library and its dependencies via [OPAM][opam]:\n\n[opam]: http://opam.ocaml.org/\n\n```bash\nopam install angstrom\n```\n\n## Usage\n\nAngstrom is written with network protocols and serialization formats in mind.\nAs such, its source distribution includes implementations of various RFCs that\nare illustrative of real-world applications of the library. These include an\n[HTTP parser][http] and a [JSON parser][json].\n\n[http]: https://github.com/inhabitedtype/angstrom/blob/master/examples/rFC2616.ml\n[json]: https://github.com/inhabitedtype/angstrom/blob/master/examples/rFC7159.ml\n\nIn addition, it is an informal tradition for OCaml parser-combinator libraries\nto include in their READMEs a parser for a simple arithmetic expression\nlanguage. The code below implements a parser for such a language and computes\nthe numerical result of the expression as it is being parsed. Because Angstrom\nis written with network protocols and serialization libraries in mind, it does\nnot include combinators for creating infix expression parsers. Such\ncombinators, e.g., `chainl1`, are nevertheless simple to define.\n\n```ocaml\nopen Angstrom\n\nlet parens p = char '(' *> p <* char ')'\nlet add = char '+' *> return (+)\nlet sub = char '-' *> return (-)\nlet mul = char '*' *> return ( * )\nlet div = char '/' *> return (/)\nlet integer =\n  take_while1 (function '0' .. '9' -> true | _ -> false) >>| int_of_string\n\nlet chainl1 e op =\n  let rec go acc =\n    (lift2 (fun f x -> f acc x) op e >>= go) <|> return acc in\n  e >>= fun init -> go init\n\nlet expr : int t =\n  fix (fun expr ->\n    let factor = parens expr <|> integer in\n    let term   = chainl1 factor (mul <|> div) in\n    chainl1 term (add <|> sub))\n\nlet eval (str:string) : int =\n  match parse_string expr str with\n  | Ok v      -> v\n  | Error msg -> failwith msg\n```\n\nFor an explanation of the infix operators and other combinators used in the\nimplementation of this example, see the documentation in the [`mli`][mli].\n\n[mli]: https://github.com/inhabitedtype/angstrom/blob/master/lib/angstrom.mli\n\n\n## Comparison to Other Libraries\n\nThere are several other parser-combinator libraries available for OCaml that\nmay suit your needs, and are worth considering. Most of them are derivatives of\nor inspired by [Parsec][]. As such, they require the use of a `try` combinator\nto achieve backtracking, rather than providing it by default. They also all use\nsomething akin to a lazy character stream as the underlying input abstraction.\nWhile this suits Haskell quite nicely, it requires blocking read calls when the\nentire input is not immediately available&mdash;an approach that is inherently\nincompatible with monadic concurrency libraries such as [Async] and [Lwt], and\nwriting high-performance, concurrent applications in general. Another\nconsequence of this approach to modeling and retrieving input is that the\nparsers cannot iterate over sections of input in a tight loop, which adversely\naffects performance.\n\nBelow is a table that compares the features of Angstrom against the those of\nother parser-combinator libraries.\n\n[parsec]: https://hackage.haskell.org/package/parsec\n[async]: https://github.com/janestreet/async\n[lwt]: https://ocsigen.org/lwt/\n\n\nFeature \\ Library                   | Angstrom | [mparser] | [planck] | [opal] |\n------------------------------------|:--------:|:---------:|:--------:|:------:|\nMonadic interface                   | \xe2\x9c\x85        | \xe2\x9c\x85         | \xe2\x9c\x85        | \xe2\x9c\x85      |\nBacktracking by default             | \xe2\x9c\x85        | \xe2\x9d\x8c         | \xe2\x9d\x8c        | \xe2\x9d\x8c      |\nUnbounded lookahead                 | \xe2\x9c\x85        | \xe2\x9c\x85         | \xe2\x9c\x85        | \xe2\x9d\x8c      |\nReports line numbers in errors      | \xe2\x9d\x8c        | \xe2\x9c\x85         | \xe2\x9d\x8c        | \xe2\x9d\x8c      |\nEfficient `take_while`/`skip_while` | \xe2\x9c\x85        | \xe2\x9d\x8c         | \xe2\x9d\x8c        | \xe2\x9d\x8c      |\nUnbuffered (zero-copy) interface    | \xe2\x9c\x85        | \xe2\x9d\x8c         | \xe2\x9d\x8c        | \xe2\x9d\x8c      |\nNon-blocking incremental interface  | \xe2\x9c\x85        | \xe2\x9d\x8c         | \xe2\x9d\x8c        | \xe2\x9d\x8c      |\nAsync Support                       | \xe2\x9c\x85        | \xe2\x9d\x8c         | \xe2\x9d\x8c        | \xe2\x9d\x8c      |\nLwt Support                         | \xe2\x9c\x85        | \xe2\x9d\x8c         | \xe2\x9d\x8c        | \xe2\x9d\x8c      |\n\n[mparser]: https://github.com/cakeplus/mparser\n[opal]: https://github.com/pyrocat101/opal\n[planck]: https://bitbucket.org/camlspotter/planck\n\n\n## Development\n\nTo install development dependencies, pin the package from the root of the\nrepository:\n\n```bash\nopam pin add -n angstrom .\nopam install --deps-only angstrom\n```\n\nAfter this, you may install a development version of the library using the\ninstall command as usual.\n\nFor building and running the tests during development, you will need to install\nthe `alcotest` package:\n\n```bash\nopam install alcotest\nmake test\n```\n\n## Acknowledgements\n\nThis library started off as a direct port of the inimitable [attoparsec][]\nlibrary. While the original approach of continuation-passing still survives in\nthe source code, several modifications have been made in order to adapt the\nideas to OCaml, and in the process allow for more efficient memory usage and\nintegration with monadic concurrency libraries. This library will undoubtedly\ndiverge further as time goes on, but its name will stand as an homage to its\norigin.\n\n[attoparsec]: https://github.com/bos/attoparsec\n\n\n## License\n\nBSD3, see LICENSE file for its text.\n"