b'<p align="center">\n  <img src="https://raw.githubusercontent.com/remoteinterview/zero/master/docs/images/logo.png" width="50">\n  <h1 align="center">Zero Server</h1>\n  <p align="center">Zero configuration web framework.</p>\n</p>\n\n<p align="center">\n  <a href="#features">Features</a> |\n  <a href="#installation">Installation</a> |\n  <a href="#getting-started">Getting Started</a> |\n  <a href="examples/">Examples</a> |\n  <a href="#running-on-cloud">Running on Cloud</a> |\n  <a href="docs/">Docs</a>\n</p>\n\n<p align="center">\n  <a href="https://discord.gg/n7y5nRs">\n    <img alt="Join the community on Discord" width="120" src="https://raw.githubusercontent.com/remoteinterview/zero/master/docs/images/discord.png" />\n  </a>\n</p>\n\n---\n\n**Zero** is a web framework to simplify modern web development. It allows you to build your application without worrying about package management or routing. It\'s as simple as writing your code in a mix of [Node.js](docs/nodejs/README.md), [React](docs/react/README.md), [HTML](docs/html/README.md), [MDX](docs/mdx/README.md), [Vue](docs/vue/README.md), [Svelte](docs/svelte/README.md), [Python](docs/python/README.md), and [static files](docs/static/README.md) and putting them all in a folder. Zero will serve them all. Zero abstracts the usual project configuration for routing, bundling, and transpiling to make it easier to get started.\n\n_An example project with different types of pages, all in one folder:_\n\n![A basic mono-repo](https://raw.githubusercontent.com/remoteinterview/zero/master/docs/images/header.gif "A basic mono-repo")\n\n## Features\n\n**Auto Configuration**: Your project folder doesn\'t require config files. You just place your code and it\'s automatically compiled, bundled and served.\n\n**File-system Based Routing**: If your code resides in `./api/login.js` it\'s exposed at `http://<SERVER>/api/login`. Inspired by good ol\' PHP days.\n\n**Auto Dependency Resolution**: If a file does `require(\'underscore\')`, it is automatically installed and resolved. You can always create your own `package.json` file to install a specific version of a package.\n\n**Multiple Languages**: Zero is designed to support code written in many languages all under a single project. Imagine this:\n\n1. Exposing your Tensorflow model as a python API.\n2. Using React pages to consume it.\n3. Writing the user login code in Node.js.\n4. Your landing pages in a mix of HTML or Markdown/MDX.\n\nAll under a single project folder as a single web application.\n\n## Play on Glitch\n\nYou can play with Zero without installing it locally. Click the button below:\n\n<!-- Remix Button -->\n<a href="https://glitch.com/edit/#!/remix/zero-starter">\n  <img src="https://cdn.glitch.com/2bdfb3f8-05ef-4035-a06e-2043962a3a13%2Fremix%402x.png?1513093958726" alt="remix this" height="30">\n</a>\n\n## Installation\n\nYou can install `zero` globally by:\n\n```sh\nnpm install -g zero\n```\n\n## Getting Started\n\nLet\'s start by making a website that tells us server time.\n\nFirst we need to create an API endpoint in Node.js to tell us time in JSON.\n\nCreate a new folder and add a new file `time.js` in that folder. In this file, export a function that accepts `Request` and `Response` objects ([like Express](https://expressjs.com/en/4x/api.html#res)):\n\n```js\n// time.js\nconst moment = require("moment");\n\nmodule.exports = (req, res) => {\n  var time = moment().format("LT"); // 11:51 AM\n  res.send({ time: time });\n};\n```\n\nOnce saved, you can `cd` into that folder and start the server like this:\n\n```sh\nzero\n```\n\nRunning this command will automatically install any dependencies (like _momentjs_ here) and start the web server.\n\nOpen this URL in the browser: [`http://localhost:3000/time`](http://localhost:3000/time)\n\nYou just created an API endpoint \xf0\x9f\x8e\x89:\n\n![Time API](docs/images/timeapi.png?raw=true "Time API")\n\nKeep the server running. Now let\'s consume our API from a React page, create a new file `index.jsx` and add the following code:\n\n```jsx\n// index.jsx\nimport React from "react";\n\nexport default class extends React.Component {\n  static async getInitialProps() {\n    var json = await fetch("/time").then(resp => resp.json());\n    return { time: json.time };\n  }\n\n  render() {\n    return <p>Current time is: {this.props.time}</p>;\n  }\n}\n```\n\nThis is a standard React component. With one additional hook for initial data population:\n\n`getInitialProps` is an `async` static method which is called by `zero` when the page loads. This method can return a plain object which populates `props`.\n\nNow go to this URL: `http://localhost:3000/` and you should see the current server time rendered by React while `fetch`-ing an API endpoint you created earlier:\n\n![Time In React](docs/images/timejsx.png?raw=true "Time In React")\n\n`zero` automatically bundles your code and supports server-side rendering. You don\'t need to fiddle with webpack anymore.\n\nThat\'s it! You just created a web application.\n\n## Routing\n\n### File-system Based Routing\n\nZero serves routes based on file structure. If you write a function that resides in `./api/login.js` it\'s exposed at `http://<SERVER>/api/login`. Similarly if you put a React page under `./about.jsx` it will be served at `http://<SERVER>/about`\n\n### 404 Page\n\nCreate a `./404.js` file (or a `.jsx`, `.vue`, .`py`, etc) to catch all requests to pages that don\'t exist.\n\n### Dynamic Routes (Pretty URL Slugs)\n\nZero decides routes based on file structure. Most projects also require dynamic routes like `/user/luke` and `/user/anakin`. Where `luke` and `anakin` are parameters. Zero natively supports this type of routes: any file or folder that **starts with \\$** is considered a dynamic route.\n\nSo if you create `./user/$username.js` and then from browser visit `/user/luke`, Zero will send that request to `$username.js` file and set `req.params` to `{username: \'luke\'}`. Code for this:\n\n```js\n/*\nproject/\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 user/\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 $username.js <- this file\n*/\nmodule.exports = function(req, res) {\n  console.log(req.params); // = {username: \'luke\'} when user visits /user/luke\n  res.send({ params: req.params });\n};\n```\n\nParameters apply to folder-names too. Another example: if you want to cater `/user/luke/messages` route, you can handle this with following directory structure:\n\n```\nproject/\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 user/\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 $username/\n        \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 index.js\n        \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 messages.js\n```\n\n- `index.js` handles `/user/:username` routes.\n- `messages.js` handles `/user/:username/messages` routes.\n\n**Tip:** `$` is used by Bash for variables. So it might be confusing when you do `cd $username` or `mkdir $username` and nothing happens. The right way to do this is escaping the `$` ie. `cd \\$username` or `mkdir \\$username`.\n\n## Supported Languages\n\n- [Node.js](docs/nodejs/README.md) _(JavaScript & TypeScript)_\n- [React](docs/react/README.md) _(JavaScript & TypeScript)_\n- [HTML](docs/html/README.md)\n- [Markdown / MDX](docs/mdx/README.md)\n- [Vue](docs/vue/README.md)\n- [Svelte](docs/svelte/README.md)\n- [Python](docs/python/README.md)\n\n## Auto Dependency Resolution\n\nIf a file does `require(\'underscore\')`, the latest version of that package is automatically installed from NPM and resolved.\n\nBut sometimes you want to use a specific version or a dependency from a private repository. You can do that by creating a `package.json` in your project folder and adding dependencies to it. Zero will install those versions instead.\n\nExample (package.json):\n\n```json\n{\n  "name": "myapp",\n  "dependencies": {\n    "underscore": "^1.4.0",\n    "private_ui_pkg": "git+https://github.com/user/repo.git"\n  }\n}\n```\n\n## .zeroignore file\n\nBy default, Zero compiles and serves all files in your project. But most of the time, you don\'t want to expose a certain file or folder. You can add `.zeroignore` file to prevent Zero from serving that file as a valid route.\n\n### Example\n\nIn a project with following structure:\n\n```\n- project/\n-- components/\n-- api/\n-- index.jsx\n```\n\nYou probably don\'t want to expose `components` directory. To do this, you can create `.zeroignore` file with the following text:\n\n```\ncomponents\n```\n\nThis will prevent your users from accessing `/components` path directly.\n\n## Running on Cloud\n\nA Zero app is a regular Node.js server. But zero doesn\'t create `package.json` in your project folder. For most clouds (Heroku, EC2, etc) you probably need `package.json`. You can create one similar to this:\n\n```json\n{\n  "name": "my-zero-app",\n  "scripts": {\n    "dev": "zero",\n    "build": "zero build",\n    "start": "NODE_ENV=production zero"\n  },\n  "dependencies": {\n    "zero": "latest"\n  }\n}\n```\n\n- We add dependency `zero`, so the cloud builder can install `zero` on your server.\n- Add a `"start"` command and also set `NODE_ENV` to `production` so zero generates minified builds and disabled HMR etc.\n- Add a `"build"` command to pre-build all files to speed up cold boots. Don\'t forget to run `npm run build` in your build step (in your Dockerfile, `heroku-postbuild`, etc)\n- If your cloud has an option to set environment variables / config variables (to store secrets, API keys, etc), these variables are automatically passed to your code and can be accessed as you normally would. In node, using `process.env.MY_SECRET`. You should never commit your local `.env` file to your code.\n\nAfter this, you can follow the instructions from your cloud provider for deploying a Node.js app.\n\n### Heroku Buildpack\n\nWe provide an official [Buildpack for Heroku](https://github.com/remoteinterview/zero-heroku-buildpack). If you are deploying on Heroku, this is the easiest way.\n\n### Changing Server\'s Port\n\nBy default zero runs on port `3000`. You can change this by setting the `PORT` environment variable, like this: `PORT=8080 zero`\n\n### Running with Docker\n\nHere is a basic `Dockerfile` you can add to your zero application to Docker-ize it:\n\n```dockerfile\nFROM node:alpine\n\n\n# Install dependencies via apk\nRUN apk update && apk upgrade \\\n    && apk add --no-cache python python3 g++ make \\\n    && rm -rf /var/cache/apk/*\n\n# Install zero globally\nRUN npm install --quiet --no-progress --unsafe-perm -g zero\n\n# Add current folder to /app\nADD . /app\n\n# Run zero in production mode\nENV NODE_ENV production\n\n# Generate bundles\nRUN zero build\n\n# Expose port\nENV PORT 80\nEXPOSE 80\n\nWORKDIR /app\n\nCMD ["zero"]\n```\n\n## Contributing\n\nPlease see our [CONTRIBUTING.md](CONTRIBUTING.md)\n\n## License\n\nZero is [Apache-2.0 licensed](LICENSE.md).\n'