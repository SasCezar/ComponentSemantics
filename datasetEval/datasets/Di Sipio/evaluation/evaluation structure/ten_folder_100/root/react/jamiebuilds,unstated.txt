b'<div align="center">\n  <br><br><br><br><br>\n  <img src="https://raw.githubusercontent.com/thejameskyle/unstated/master/logo.png" alt="Unstated Logo" width="400">\n  <br><br><br><br><br><br><br><br>\n</div>\n\n# Unstated\n\n> State so simple, it goes without saying\n\n### :wave: [Check out the *-next version of Unstated with an all new React Hooks API &rarr;](https://github.com/jamiebuilds/unstated-next)\n\n## Installation\n\n```sh\nyarn add unstated\n```\n\n## Example\n\n```jsx\n// @flow\nimport React from \'react\';\nimport { render } from \'react-dom\';\nimport { Provider, Subscribe, Container } from \'unstated\';\n\ntype CounterState = {\n  count: number\n};\n\nclass CounterContainer extends Container<CounterState> {\n  state = {\n    count: 0\n  };\n\n  increment() {\n    this.setState({ count: this.state.count + 1 });\n  }\n\n  decrement() {\n    this.setState({ count: this.state.count - 1 });\n  }\n}\n\nfunction Counter() {\n  return (\n    <Subscribe to={[CounterContainer]}>\n      {counter => (\n        <div>\n          <button onClick={() => counter.decrement()}>-</button>\n          <span>{counter.state.count}</span>\n          <button onClick={() => counter.increment()}>+</button>\n        </div>\n      )}\n    </Subscribe>\n  );\n}\n\nrender(\n  <Provider>\n    <Counter />\n  </Provider>,\n  document.getElementById(\'root\')\n);\n```\n\nFor more examples, see the `example/` directory.\n\n## Happy Customers\n\n<h4 align="center">\n  "Unstated is a breath of fresh air for state management. I rewrote my whole app to use it yesterday."\n  <br><br>\n  <a href="https://twitter.com/sindresorhus">Sindre Sorhus</a>\n</h4>\n\n<h4 align="center">\n  "When people say you don\'t need Redux most of the time, they actually mean you do need Unstated.<br>It\'s like setState on fucking horse steroids"\n  <br><br>\n  <a href="https://twitter.com/ken_wheeler">Ken Wheeler</a> (obviously)\n</h4>\n\n## Guide\n\nIf you\'re like me, you\'re sick of all the ceremony around state management in\nReact, you want something that fits in well with the React way of thinking,\nbut doesn\'t command some crazy architecture and methodology.\n\nSo first off: Component state is nice! It makes sense and people can pick it\nup quickly:\n\n```jsx\nclass Counter extends React.Component {\n  state = { count: 0 };\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n  decrement = () => {\n    this.setState({ count: this.state.count - 1 });\n  };\n  render() {\n    return (\n      <div>\n        <span>{this.state.count}</span>\n        <button onClick={this.decrement}>-</button>\n        <button onClick={this.increment}>+</button>\n      </div>\n    );\n  }\n}\n```\n\nAs a new React developer you might not know exactly how everything works, but\nyou can get a general sense pretty quickly.\n\nThe only problem here is that we can\'t easily share this state with other\ncomponents in our tree. Which is intentional! React components are designed to\nbe very self-contained.\n\nWhat would be great is if we could replicate the nice parts of React\'s\ncomponent state API while sharing it across multiple components.\n\nBut how do we share values between components in React? Through "context".\n\n> **Note:** The following is part of the new `React.createContext` API\n> [described in this RFC](https://github.com/reactjs/rfcs/blob/master/text/0002-new-version-of-context.md).\n\n```jsx\nconst Amount = React.createContext(1);\n\nclass Counter extends React.Component {\n  state = { count: 0 };\n  increment = amount => { this.setState({ count: this.state.count + amount }); };\n  decrement = amount => { this.setState({ count: this.state.count - amount }); };\n  render() {\n    return (\n      <Amount.Consumer>\n        {amount => (\n          <div>\n            <span>{this.state.count}</span>\n            <button onClick={() => this.decrement(amount)}>-</button>\n            <button onClick={() => this.increment(amount)}>+</button>\n          </div>\n        )}\n      </Amount.Consumer>\n    );\n  }\n}\n\nclass AmountAdjuster extends React.Component {\n  state = { amount: 0 };\n  handleChange = event => {\n    this.setState({\n      amount: parseInt(event.currentTarget.value, 10)\n    });\n  };\n  render() {\n    return (\n      <Amount.Provider value={this.state.amount}>\n        <div>\n          {this.props.children}\n          <input type="number" value={this.state.amount} onChange={this.handleChange}/>\n        </div>\n      </Amount.Provider>\n    );\n  }\n}\n\nrender(\n  <AmountAdjuster>\n    <Counter/>\n  </AmountAdjuster>\n);\n```\n\nThis is already pretty great. Once you get a little bit used to React\'s way of\nthinking, it makes total sense and it\'s very predictable.\n\nBut can we build on this pattern to make something even nicer?\n\n### Introducing Unstated\n\nWell this is where Unstated comes in.\n\nUnstated is designed to build on top of the patterns already set out by React\ncomponents and context.\n\nIt has three pieces:\n\n##### `Container`\n\nWe\'re going to want another place to store our state and some of the logic for\nupdating it.\n\n`Container` is a very simple class which is meant to look just like\n`React.Component` but with only the state-related bits: `this.state` and\n`this.setState`.\n\n```js\nclass CounterContainer extends Container {\n  state = { count: 0 };\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n  decrement = () => {\n    this.setState({ count: this.state.count - 1 });\n  };\n}\n```\n\nBehind the scenes our `Container`s are also event emitters that our app can\nsubscribe to for updates. When you call `setState` it triggers components to\nre-render, be careful not to mutate `this.state` directly or your components\nwon\'t re-render.\n\n###### `setState()`\n\n`setState()` in `Container` mimics React\'s `setState()` method as closely as\npossible.\n\n```js\nclass CounterContainer extends Container {\n  state = { count: 0 };\n  increment = () => {\n    this.setState(\n      state => {\n        return { count: state.count + 1 };\n      },\n      () => {\n        console.log(\'Updated!\');\n      }\n    );\n  };\n}\n```\n\nIt\'s also run asynchronously, so you need to follow the same rules as React.\n\n**Don\'t read state immediately after setting it**\n\n```js\nclass CounterContainer extends Container {\n  state = { count: 0 };\n  increment = () => {\n    this.setState({ count: 1 });\n    console.log(this.state.count); // 0\n  };\n}\n```\n\n**If you are using previous state to calculate the next state, use the function form**\n\n```js\nclass CounterContainer extends Container {\n  state = { count: 0 };\n  increment = () => {\n    this.setState(state => {\n      return { count: state.count + 1 };\n    });\n  };\n}\n```\n\nHowever, unlike React\'s `setState()` Unstated\'s `setState()` returns a promise,\nso you can `await` it like this:\n\n```js\nclass CounterContainer extends Container {\n  state = { count: 0 };\n  increment = async () => {\n    await this.setState({ count: 1 });\n    console.log(this.state.count); // 1\n  };\n}\n```\n\nAsync functions are now available in [all the major browsers](https://caniuse.com/#feat=async-functions),\nbut you can also use [Babel](http://babeljs.io) to compile them down to\nsomething that works in every browser.\n\n##### `<Subscribe>`\n\nNext we\'ll need a piece to introduce our state back into the tree so that:\n\n* When state changes, our components re-render.\n* We can depend on our container\'s state.\n* We can call methods on our container.\n\nFor this we have the `<Subscribe>` component which allows us to pass our\ncontainer classes/instances and receive instances of them in the tree.\n\n```jsx\nfunction Counter() {\n  return (\n    <Subscribe to={[CounterContainer]}>\n      {counter => (\n        <div>\n          <span>{counter.state.count}</span>\n          <button onClick={counter.decrement}>-</button>\n          <button onClick={counter.increment}>+</button>\n        </div>\n      )}\n    </Subscribe>\n  );\n}\n```\n\n`<Subscribe>` will automatically construct our container and listen for changes.\n\n##### `<Provider>`\n\nThe final piece that we\'ll need is something to store all of our instances\ninternally. For this we have `<Provider>`.\n\n```jsx\nrender(\n  <Provider>\n    <Counter />\n  </Provider>\n);\n```\n\nWe can do some interesting things with `<Provider>` as well like dependency\ninjection:\n\n```jsx\nlet counter = new CounterContainer();\n\nrender(\n  <Provider inject={[counter]}>\n    <Counter />\n  </Provider>\n);\n```\n\n### Testing\n\nWhenever we consider the way that we write the state in our apps we should be\nthinking about testing.\n\nWe want to make sure that our state containers have a clean way\n\nWell because our containers are very simple classes, we can construct them in\ntests and assert different things about them very easily.\n\n```js\ntest(\'counter\', async () => {\n  let counter = new CounterContainer();\n  assert(counter.state.count === 0);\n\n  await counter.increment();\n  assert(counter.state.count === 1);\n\n  await counter.decrement();\n  assert(counter.state.count === 0);\n});\n```\n\nIf we want to test the relationship between our container and the component\nwe can again construct our own instance and inject it into the tree.\n\n```js\ntest(\'counter\', async () => {\n  let counter = new CounterContainer();\n  let tree = render(\n    <Provider inject={[counter]}>\n      <Counter />\n    </Provider>\n  );\n\n  await click(tree, \'#increment\');\n  assert(counter.state.count === 1);\n\n  await click(tree, \'#decrement\');\n  assert(counter.state.count === 0);\n});\n```\n\nDependency injection is useful in many ways. Like if we wanted to stub out a\nmethod in our state container we can do that painlessly.\n\n```js\ntest(\'counter\', async () => {\n  let counter = new CounterContainer();\n  let inc = stub(counter, \'increment\');\n  let dec = stub(counter, \'decrement\');\n\n  let tree = render(\n    <Provider inject={[counter]}>\n      <Counter />\n    </Provider>\n  );\n\n  await click(tree, \'#increment\');\n  assert(inc.calls.length === 1);\n  assert(dec.calls.length === 0);\n});\n```\n\nWe don\'t even have to do anything to clean up after ourselves because we just\nthrow everything out afterwards.\n\n## FAQ\n\n#### What state should I put into Unstated?\n\nThe React community has focused a lot on trying to put all their state in one\nplace. You could keep doing that with Unstated, but I wouldn\'t recommend it.\n\nI would recommend a multi-part solution.\n\nFirst, use local component state as much as you possibly can. That counter\nexample from above never should have been refactored away from component\nstate, it was fine before Unstated.\n\nSecond, use libraries to abstract away the bits of state that you\'ll repeat\nover and over.\n\nLike if form state has you down, you might want to use a library like\n[Final Form](https://github.com/final-form/react-final-form).\n\nIf fetching data is getting to be too much, maybe try out [Apollo](https://www.apollographql.com).\nOr even something uncool but familiar and reliable like [Backbone models and collections](http://backbonejs.org).\nWhat? Are you too cool to use an old framework?\n\nThird, a lot of shared state between components is localized to a few\ncomponents in the tree.\n\n```jsx\n<Tabs>\n  <Tab>One</Tab>\n  <Tab>Two</Tab>\n  <Tab>Three</Tab>\n</Tabs>\n```\n\nFor this, I recommend using React\'s built-in `React.createContext()` API\nand being careful in designing the API for the base components you create.\n\n> **Note:** If you\'re on an old version of React and want to use the new\n> context API, [I\'ve got you](https://github.com/thejameskyle/create-react-context/)\n\nFinally, (and only after other things are exhausted), if you really need\nsome global state to be shared throughout your app, you can use Unstated.\n\nI know all of this might sound somehow more complicated, but it\'s a\nmatter of using the right tool for the job and not forcing a single\nparadigm on the entire universe.\n\nUnstated isn\'t ambitious, use it as you need it, it\'s nice and small for\nthat reason. Don\'t think of it as a "Redux killer". Don\'t go trying to\nbuild complex tools on top of it. Don\'t reinvent the wheel. Just try it\nout and see how you like it.\n\n#### Passing your own instances directly to `<Subscribe to>`\n\nIf you want to use your own instance of a container directly to `<Subscribe>`\nand you don\'t care about dependency injection, you can do so:\n\n<!-- prettier-ignore -->\n```jsx\nlet counter = new CounterContainer();\n\nfunction Counter() {\n  return (\n    <Subscribe to={[counter]}>\n      {counter => <div>...</div>}\n    </Subscribe>\n  );\n}\n```\n\nYou just need to keep a couple things in mind:\n\n1. You are opting out of dependency injection, you won\'t be able to\n   `<Provider inject>` another instance in your tests.\n2. Your instance will be local to whatever `<Subscribe>`\'s you pass it to, you\n   will end up with multiple instances of your container if you don\'t pass the\n   same reference in everywhere.\n\nAlso remember that it is _okay_ to use `<Provider inject>` in your application\ncode, you can pass your instance in there. It\'s probably better to do that in\nmost scenarios anyways (cause then you get dependency injection and all that\ngood stuff).\n\n#### How can I pass in options to my container?\n\nA good pattern for doing this might be to add a constructor to your container\nwhich accepts `props` sorta like React components. Then create your own\ninstance of your container and pass it into `<Provider inject>`.\n\n```jsx\nclass CounterContainer extends Container {\n  constructor(props = {}) {\n    super();\n    this.state = {\n      amount: props.initialAmount || 1,\n      count: 0\n    };\n  }\n\n  increment = () => {\n    this.setState({ count: this.state.count + this.state.amount });\n  };\n}\n\nlet counter = new CounterContainer({\n  initialAmount: 5\n});\n\nrender(\n  <Provider inject={[counter]}>\n    <Counter />\n  </Provider>\n);\n```\n\n## Related\n\n- [unstated-debug](https://github.com/sindresorhus/unstated-debug) - Debug your Unstated containers with ease\n \n'