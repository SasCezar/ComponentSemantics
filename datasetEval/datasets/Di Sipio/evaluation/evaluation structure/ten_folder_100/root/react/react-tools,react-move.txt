b'<div style="text-align:center;">\n  <a href="https://github.com/react-tools/react-move" target="\\_parent"><img src="https://github.com/react-tools/media/raw/master/logo-react-move.png" alt="React Table Logo" style="width:450px;"/></a>\n</div>\n\n# React-Move\n\nBeautiful, data-driven animations for React. Just 3.5kb (gzipped)!\n### [Documentation and Examples](https://react-move.js.org)\n\n[![Build Status](https://travis-ci.org/react-tools/react-move.svg?branch=master)](https://travis-ci.org/react-tools/react-move)\n[![npm version](https://img.shields.io/npm/v/react-move.svg)](https://www.npmjs.com/package/react-move)\n[![npm downloads](https://img.shields.io/npm/dm/react-move.svg)](https://www.npmjs.com/package/react-move)\n[![license](https://img.shields.io/github/license/mashape/apistatus.svg?maxAge=2592000)](https://github.com/react-tools/react-move/blob/master/LICENSE)\n\n## Features\n\n* Animate HTML, SVG & React-Native\n* Fine-grained control of delay, duration and easing\n* Animation lifecycle events: start, interrupt, end\n* Custom tweening functions\n* Awesome documentation and lots of examples\n* Supports TypeScript\n\n## Installation\n\n```bash\n// React ^16.3.0\nnpm install react-move\n\n// React ^0.14.9 || ^15.3.0 || ^16.0.0\nnpm install react-move@^5.0.0\n```\n\n**Note:** The API for React Move 5.x and 6.x is exactly the same.  The 5.x version just includes [react-lifecycles-compat](https://www.npmjs.com/package/react-lifecycles-compat) to make the library work with earlier versions of React.  This adds a little to the bundle so use 6.x if you\'re using React 16.3+.\n\n### Upgrading from React Move 2.x and 3.x  \n\nThe API for React Move has been essentially stable since the 2.0 version.  The 4.0 version of React Move introduced a change that broke the hard dependency on d3-interpolate and introduced the `interpolation` prop. The current version of React Move will by default only do numeric interpolation and apply easing functions.  **If you only need to do numeric interpolation you don\'t need to do anything. Just upgrade and done.**\n\nTo get the same interpolation found in React Move 2.x and 3.x which includes support for colors, paths and SVG transforms do this:\n\nInstall d3-interpolate:\n```\nnpm install d3-interpolate\n```\n\nThen in your app:\n```js\nimport { NodeGroup } from \'react-move\'\nimport { interpolate, interpolateTransformSvg } from \'d3-interpolate\'\n\n...\n<NodeGroup\n  data={this.state.data}\n  keyAccessor={(d) => d.name}\n\n  start={(data, index) => ({\n    ...\n  })}\n\n  enter={(data, index) => ([ // An array\n    ...\n  ])}\n\n  update={(data) => ({\n    ...\n  })}\n\n  leave={() => ({\n    ...\n  })}\n  \n  interpolation ={(begValue, endValue, attr) => { // pass as prop\n    if (attr === \'transform\') {\n      return interpolateTransformSvg(begValue, endValue)\n    }\n\n    return interpolate(begValue, endValue)\n  }}\n>\n  ...children\n</NodeGroup>\n```\n\n## Demos\n\n* [CodeSandbox - Animated Bars](https://codesandbox.io/s/w0ol90x9z5) ([@animateddata](https://github.com/animateddata))\n* [Blog Post by Peter Cook](https://frontendcharts.com/react-move-barchart/) \n* [CodeSandbox - Collapsible Tree](https://codesandbox.io/s/ww0xkyqonk) ([@techniq](https://github.com/techniq))\n* [CodeSandbox - Draggable List](https://codesandbox.io/s/j2povnz8ly)\n* [CodeSandbox - Circle Inferno](https://codesandbox.io/s/n033m6nw00)\n* [CodeSandbox - Animated Mount/Unmount](https://codesandbox.io/s/9z04rpypny)\n* [Examples](https://react-move.js.org)\n\n# Documentation\n\nThe docs below are for version **6.x.x** of React-Move.\n\nOlder versions:\n\n* [Version 1.x.x](https://github.com/react-tools/react-move/tree/v1.6.1)\n\nThe API for `NodeGroup` and `Animate` have not changed except for the `interpolation`xw prop, but if you want to refer back:\n* [Version 2.x.x](https://github.com/react-tools/react-move/tree/v2.9.1)\n* [Version 3.x.x](https://github.com/react-tools/react-move/tree/v3.1.0)\n* [Version 4.x.x](https://github.com/react-tools/react-move/tree/v4.0.0)\n* [Version 5.x.x](https://github.com/react-tools/react-move/tree/v5.0.0)\n\n# Getting Started\n\nReact Move exports just two components:\n- NodeGroup - If you have an **array of items** that enter, update and leave\n- Animate - If you have a **singe item** that enters, updates and leaves\n\n## < NodeGroup />\n\n### Component Props\n\n| Name | Type | Default | Description |\n|:-----|:-----|:-----|:-----|\n| <span style="color: #31a148">data *</span> | array |  |  An array. The data prop is treated as immutable so the nodes will only update if prev.data !== next.data. |\n| <span style="color: #31a148">keyAccessor *</span> | function |  |  Function that returns a string key given the data and its index. Used to track which nodes are entering, updating and leaving. |\n| interpolation | function | numeric |  A function that returns an interpolator given the begin value, end value, attr and namespace. Defaults to numeric interpolation. See docs for more. |\n| <span style="color: #31a148">start *</span> | function |  |  A function that returns the starting state. The function is passed the data and index and must return an object. |\n| enter | function | () => {} |  A function that **returns an object or array of objects** describing how the state should transform on enter.  The function is passed the data and index. |\n| update | function | () => {} |  A function that **returns an object or array of objects** describing how the state should transform on update.  The function is passed the data and index. |\n| leave | function | () => {} |  A function that **returns an object or array of objects** describing how the state should transform on leave.  The function is passed the data and index. |\n| <span style="color: #31a148">children *</span> | function |  |  A function that receives an array of nodes. |\n\n## < Animate />\n\n### Component Props\n\n| Name | Type | Default | Description |\n|:-----|:-----|:-----|:-----|\n| show | bool | true |  Boolean value that determines if the child should be rendered or not. |\n| interpolation | function | numeric |  A function that returns an interpolator given the begin value, end value, atrr and namespace. See docs for more. |\n| start | union:<br>&nbsp;func<br>&nbsp;object<br> |  |  An object or function that returns an obejct to be used as the starting state. |\n| enter | union:<br>&nbsp;func<br>&nbsp;array<br>&nbsp;object<br> |  |  An object, array of objects, or function that returns an object or array of objects describing how the state should transform on enter. |\n| update | union:<br>&nbsp;func<br>&nbsp;array<br>&nbsp;object<br> |  |  An object, array of objects, or function that returns an object or array of objects describing how the state should transform on update. ***Note:*** although not required, in most cases it make sense to specify an update prop to handle interrupted enter and leave transitions. |\n| leave | union:<br>&nbsp;func<br>&nbsp;array<br>&nbsp;object<br> |  |  An object, array of objects, or function that returns an object or array of objects describing how the state should transform on leave. |\n| <span style="color: #31a148">children *</span> | function |  |  A function that receives the state. |\n\n## Starting state\n\nBefore looking at the components it might be good to look at starting state.  You are going to be asked to define starting states for each item in your `NodeGroup` and `Animate` components. This is a key concept and probably the most error prone for developers working with React Move.  The starting state for each item is always **an object with string or number leaves**.  The leaf keys are referred to as "attrs" as in "attribute."  There are also "namespaces" which are a purely organizational concept.\n\nTwo rules to live by for starting states:\n- Don\'t use the strings "timing" or "events" as an attr or namespace.\n- There should never be an array anywhere in your object.\n\nExample starting state:\n```js\n// GOOD\n{\n  attr1: 100,\n  attr2: 200,\n  attr3: \'#dadada\'\n}\n\n// BAD\n{\n  attr1: [100], // NO ARRAYS\n  attr2: 200,\n  attr3: \'#dadada\'\n}\n```\n\nA more concrete example might be:\n```js\n{\n  opacity: 0.1,\n  x: 200,\n  y: 100,\n  color: \'#dadada\'\n}\n```\n\nYou can add "namespaces" to help organize your state:\n```js\n{\n  attr1: 100,\n  attr2: 200,\n  attr3: \'#ddaabb\',\n  namespace1: {\n    attr1: 100,\n    attr2: 200\n  }\n}\n```\nOr something like:\n```js\n{\n  namespace1: {\n    attr1: 100,\n    attr2: 200\n  },\n  namespace2: {\n    attr1: 100,\n    attr2: 200\n  }\n}\n```\nYou might use namespaces like so:\n```js\n{\n  inner: {\n    x: 100,\n    y: 150,\n    color: \'#545454\'\n  },\n  outer: {\n    x: 300,\n    y: 350,\n    color: \'#3e3e3e\'\n  }\n}\n```\n\n#### Starting state in NodeGroup\n\nIn `NodeGroup` you are working with an array of items and you pass a start prop (a function) that receives the data item and its index.  The start prop will be called when that data item (identified by its key) enters.  Note it could leave and come back and that prop will be called again.  Immediately after the starting state is set your enter transition (optional) is called allowing you to transform that state.\n\n```js\n<NodeGroup\n  data={data} // an array (required)\n  keyAccessor={item => item.name} // function to get the key of each object (required)\n  start={(item, index) => ({ // returns the starting state of node (required)\n    ...\n  })}\n>\n  {(nodes) => (\n    ...\n      {nodes.map(({ key, data, state }) => {\n        ...\n      })}\n    ...\n  )}\n</NodeGroup>\n```\n\n#### Starting state in Animate\n\nIn `Animate` you are animating a single item and pass a start prop that is an object or a function.  The start prop will be called when that the item enters.  Note it could leave and come back by toggling the show prop.  Immediately after the starting state is set your enter transition (optional) is called allowing you to transform that state.\n\n```js\n<Animate\n  start={{ // object or function\n    ...\n  }}\n>\n  {state => (\n    ...\n  )}\n</Animate>\n```\n\n## Transitioning state\n\nYou return a config object or an array of config objects in your **enter**, **update** and **leave** props functions for both `NodeGroup` and `Animate`. Instead of simply returning the next state these objects describe how to transform the state. Each config object can specify its own duration, delay, easing and events independently.\n\nThere are two special keys you can use: **timing** and **events**. Both are optional.\nTiming and events are covered in more detail below.\n\nIf you aren\'t transitioning anything then it wouldn\'t make sense to be using NodeGroup.\nThat said, it\'s convenient to be able to set a key to value when a node enters, updates or leaves without transitioning.\nTo support this you can return four different types of values to specify how you want to transform the state.\n\n* `string or number`: Set the key to the value immediately with no transition.  Ignores all timing values.\n\n* `array [value]`: Transition from the key\'s current value to the specified value. Value is a string or number.\n\n* `array [value, value]`: Transition from the first value to the second value. Each value is a string or number.\n\n* `function`: Function will be used as a custom tween function.\n\n\nExample config object:\n```js\n{\n  attr1: [200],\n  attr2: 300,\n  attr3: [\'#dadada\']\n  timing: { duration: 300, delay: 100 }\n}\n```\n\nUsing namespaces:\n```js\n{\n  attr1: [100],\n  attr3: \'#ddaabb\',\n  namespace1: {\n    attr1: [300],\n    attr2: 200\n  },\n  timing: { duration: 300, delay: 100 }\n}\n```\n\nTo have different timing for some keys use an array of config objects:\n```js\n[\n  {\n    attr1: [200, 500],\n    timing: { duration: 300, delay: 100 }\n  },\n  {\n    attr2: 300, // this item, not wrapped in an array, will be set immediately, so which object it\'s in doesn\'t matter\n    attr3: [\'#dadada\']\n    timing: { duration: 600 }\n  },\n]\n```\n\n### Example Transitions in NodeGroup\n\n```js\n<NodeGroup\n  data={this.state.data}\n  keyAccessor={(d) => d.name}\n\n  start={(data, index) => ({\n    opacity: 1e-6,\n    x: 1e-6,\n    fill: \'green\',\n    width: scale.bandwidth(),\n  })}\n\n  enter={(data, index) => ({\n    opacity: [0.5], // transition opacity on enter\n    x: [scale(data.name)], // transition x on on enter\n    timing: { duration: 1500 }, // timing for transitions\n  })}\n\n  update={(data) => ({\n    ...\n  })}\n\n  leave={() => ({\n    ...\n  })}\n>\n  {(nodes) => (\n    ...\n  )}\n</NodeGroup>\n```\n\nUsing an array of config objects:\n```js\nimport { easeQuadInOut } from \'d3-ease\';\n\n...\n\n<NodeGroup\n  data={this.state.data}\n  keyAccessor={(d) => d.name}\n\n  start={(data, index) => ({\n    opacity: 1e-6,\n    x: 1e-6,\n    fill: \'green\',\n    width: scale.bandwidth(),\n  })}\n\n  enter={(data, index) => ([ // An array\n    {\n      opacity: [0.5], // transition opacity on enter\n      timing: { duration: 1000 }, // timing for transition\n    },\n    {\n      x: [scale(data.name)], // transition x on on enter\n      timing: { delay: 750, duration: 1500, ease: easeQuadInOut }, // timing for transition\n    },\n  ])}\n\n  update={(data) => ({\n    ...\n  })}\n\n  leave={() => ({\n    ...\n  })}\n>\n  {(nodes) => (\n    ...\n  )}\n</NodeGroup>\n```\n\n## Timing\n\nIf there\'s no timing key in your object you\'ll get the timing defaults.\nYou can specify just the things you want to override on your timing key.\n\nHere\'s the timing defaults...\n\n```js\nconst defaultTiming = {\n  delay: 0,\n  duration: 250,\n  ease: easeLinear\n};\n```\n\nFor the ease key, just provide the function. You can use any easing function, like those from d3-ease...\n\n[List of ease functions exported from d3-ease](https://github.com/d3/d3-ease/blob/master/src/index.js)\n\n## Events\n\nYou can add events on your config objects.  You can pass a function that will run when the transition starts, is interrupted (an update to the data occurs) or ends.\n\nUsing Events:\n```js\n{\n  attr1: [100],\n  attr3: \'#ddaabb\',\n  namespace1: {\n    attr1: [300],\n    attr2: 200\n  },\n  timing: { duration: 300, delay: 100 },\n  events: {\n    start: () => {\n      ..do stuff - use an arrow function to keep the context of the outer component\n    },\n    interrupt: () => {\n      ..do stuff - use an arrow function to keep the context of the outer component\n    },\n    end: () => {\n      ..do stuff - use an arrow function to keep the context of the outer component\n    },\n  }\n}\n```\n\n### Interpolation\n\nYou can wire your components in `react-move` to handle different types of interpolation using the `interpolation` prop in both `NodeGroup` and `Animate`.  The code for interpolating strings or SVG paths can be bulky and, in many cases, it\'s not needed so by default components only handle numeric interpolation. \n\nYour `interpolation` prop is a function that should avoid a lot of logic and computation.  It will get called at high frequency when transitions fire in your components.  You get the begin and end values and what the attribute name (string) is.  You will also get the namespace string (less common) if you are using them in your state.  **See the sections on starting states and transitions for more on attrs and namespaces.**\n\n#### Cadillac Interpolation  - Depends on d3-interpolate\n\nTo wire up a full service interpolation that will interpolate colors, paths, numbers and SVG transforms you can use a setup like this:\n\n```\nnpm install react-move d3-interpolate\n```\n\nThen in your app:\n```js\nimport { NodeGroup, Animate } from \'react-move\'\nimport { interpolate, interpolateTransformSvg } from \'d3-interpolate\'\n\n...\n<NodeGroup\n  data={this.state.data}\n  keyAccessor={(d) => d.name}\n\n  start={(data, index) => ({\n    ...\n  })}\n\n  enter={(data, index) => ([ // An array\n    ...\n  ])}\n\n  update={(data) => ({\n    ...\n  })}\n\n  leave={() => ({\n    ...\n  })}\n  \n  interpolation ={(begValue, endValue, attr, namespace) => { // pass as prop\n    if (attr === \'transform\') {\n      return interpolateTransformSvg(begValue, endValue)\n    }\n\n    return interpolate(begValue, endValue)\n  }}\n>\n  ...children\n</NodeGroup>\n```\n\nThis setup mimics how `d3.js` works for selecting interpolators and will not force you to think too much about the values your are using.  For example, if you use colors (in any format) they will be recognized and interpolated correctly. The `interpolate` function exported from d3-interpolate does a great job of guessing what you\'re trying to do and handles it for you but it also includes a lot of code (e.g. d3-color) that may not be needed for your project.\n\n#### Numeric Interpolation Only - Default - No dependencies\n \nTo do numeric interpolation you don\'t need to do anything in your components.  The default numeric interpolator looks like this:\n\n```js\n// The default interpolator used in NodeGroup and Animate\n\nconst numeric = (beg, end) => {\n  const a = +beg\n  const b = +end - a\n  \n  return function(t) {\n    return a + b * t\n  } \n}\n\n```\n\n## React-Move vs React-Motion\n\n* React-move allows you to define your animations using durations, delays and ease functions.\n  In react-motion you use spring configurations to define your animations.\n\n* React-move is designed to easily plugin interpolation for strings, numbers, colors, SVG paths and SVG transforms.\n  With react-motion you can only interpolate numbers so you have to do a bit more work use colors, paths, etc.\n\n* In react-move you can define different animations for entering, updating and leaving with the ability to specify delay, duration and ease on each individual key.\n  React-motion allows you to define a spring configuration for each key in the "style" object.\n\n* React-move has lifecycle events on its transitions.\n  You can pass a function to be called on transition start, interrupt or end.\n  React-motion has an "onRest" prop that fires a callback when the animation stops (just the `Motion` component not `TransitionMotion` or `StaggeredMotion`).\n\n* React-move also allows you to pass your own custom tween functions. It\'s all springs in react-motion.\n\n## Contributing\n\nWe love contributions from the community! Read the [contributing info here](https://github.com/react-tools/react-move/blob/master/CONTRIBUTING.md).\n\n#### Run the repo locally\n\n* Fork this repo\n* `npm install`\n* `cd docs`\n* `npm install`\n* `npm start`\n\n#### Scripts\n\nRun these from the root of the repo\n\n* `npm run lint` Lints all files in src and docs\n* `npm run test` Runs the test suite locally\n* `npm run test:coverage` Get a coverage report in the console\n* `npm run test:coverage:html` Get an HTML coverage report in coverage folder\n\nGo to [live examples, code and docs](https://react-move.js.org)!\n'