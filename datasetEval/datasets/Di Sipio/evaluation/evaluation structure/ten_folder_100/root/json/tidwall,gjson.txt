b'<p align="center">\n<img \n    src="logo.png" \n    width="240" height="78" border="0" alt="GJSON">\n<br>\n<a href="https://travis-ci.org/tidwall/gjson"><img src="https://img.shields.io/travis/tidwall/gjson.svg?style=flat-square" alt="Build Status"></a>\n<a href="https://godoc.org/github.com/tidwall/gjson"><img src="https://img.shields.io/badge/api-reference-blue.svg?style=flat-square" alt="GoDoc"></a>\n<a href="http://tidwall.com/gjson-play"><img src="https://img.shields.io/badge/%F0%9F%8F%90-playground-9900cc.svg?style=flat-square" alt="GJSON Playground"></a>\n</p>\n\n\n\n<p align="center">get json values quickly</a></p>\n\nGJSON is a Go package that provides a [fast](#performance) and [simple](#get-a-value) way to get values from a json document.\nIt has features such as [one line retrieval](#get-a-value), [dot notation paths](#path-syntax), [iteration](#iterate-through-an-object-or-array), and [parsing json lines](#json-lines).\n\nAlso check out [SJSON](https://github.com/tidwall/sjson) for modifying json, and the [JJ](https://github.com/tidwall/jj) command line tool.\n\nGetting Started\n===============\n\n## Installing\n\nTo start using GJSON, install Go and run `go get`:\n\n```sh\n$ go get -u github.com/tidwall/gjson\n```\n\nThis will retrieve the library.\n\n## Get a value\nGet searches json for the specified path. A path is in dot syntax, such as "name.last" or "age". When the value is found it\'s returned immediately. \n\n```go\npackage main\n\nimport "github.com/tidwall/gjson"\n\nconst json = `{"name":{"first":"Janet","last":"Prichard"},"age":47}`\n\nfunc main() {\n\tvalue := gjson.Get(json, "name.last")\n\tprintln(value.String())\n}\n```\n\nThis will print:\n\n```\nPrichard\n```\n*There\'s also the [GetMany](#get-multiple-values-at-once) function to get multiple values at once, and [GetBytes](#working-with-bytes) for working with JSON byte slices.*\n\n## Path Syntax\n\nBelow is a quick overview of the path syntax, for more complete information please\ncheck out [GJSON Syntax](SYNTAX.md).\n\nA path is a series of keys separated by a dot.\nA key may contain special wildcard characters \'\\*\' and \'?\'.\nTo access an array value use the index as the key.\nTo get the number of elements in an array or to access a child path, use the \'#\' character.\nThe dot and wildcard characters can be escaped with \'\\\\\'.\n\n```json\n{\n  "name": {"first": "Tom", "last": "Anderson"},\n  "age":37,\n  "children": ["Sara","Alex","Jack"],\n  "fav.movie": "Deer Hunter",\n  "friends": [\n    {"first": "Dale", "last": "Murphy", "age": 44, "nets": ["ig", "fb", "tw"]},\n    {"first": "Roger", "last": "Craig", "age": 68, "nets": ["fb", "tw"]},\n    {"first": "Jane", "last": "Murphy", "age": 47, "nets": ["ig", "tw"]}\n  ]\n}\n```\n```\n"name.last"          >> "Anderson"\n"age"                >> 37\n"children"           >> ["Sara","Alex","Jack"]\n"children.#"         >> 3\n"children.1"         >> "Alex"\n"child*.2"           >> "Jack"\n"c?ildren.0"         >> "Sara"\n"fav\\.movie"         >> "Deer Hunter"\n"friends.#.first"    >> ["Dale","Roger","Jane"]\n"friends.1.last"     >> "Craig"\n```\n\nYou can also query an array for the first match by using `#(...)`, or find all \nmatches with `#(...)#`. Queries support the `==`, `!=`, `<`, `<=`, `>`, `>=` \ncomparison operators and the simple pattern matching `%` (like) and `!%` \n(not like) operators.\n\n```\nfriends.#(last=="Murphy").first    >> "Dale"\nfriends.#(last=="Murphy")#.first   >> ["Dale","Jane"]\nfriends.#(age>45)#.last            >> ["Craig","Murphy"]\nfriends.#(first%"D*").last         >> "Murphy"\nfriends.#(first!%"D*").last        >> "Craig"\nfriends.#(nets.#(=="fb"))#.first   >> ["Dale","Roger"]\n```\n\n*Please note that prior to v1.3.0, queries used the `#[...]` brackets. This was\nchanged in v1.3.0 as to avoid confusion with the new\n[multipath](SYNTAX.md#multipaths) syntax. For backwards compatibility, \n`#[...]` will continue to work until the next major release.*\n\n## Result Type\n\nGJSON supports the json types `string`, `number`, `bool`, and `null`. \nArrays and Objects are returned as their raw json types. \n\nThe `Result` type holds one of these:\n\n```\nbool, for JSON booleans\nfloat64, for JSON numbers\nstring, for JSON string literals\nnil, for JSON null\n```\n\nTo directly access the value:\n\n```go\nresult.Type    // can be String, Number, True, False, Null, or JSON\nresult.Str     // holds the string\nresult.Num     // holds the float64 number\nresult.Raw     // holds the raw json\nresult.Index   // index of raw value in original json, zero means index unknown\n```\n\nThere are a variety of handy functions that work on a result:\n\n```go\nresult.Exists() bool\nresult.Value() interface{}\nresult.Int() int64\nresult.Uint() uint64\nresult.Float() float64\nresult.String() string\nresult.Bool() bool\nresult.Time() time.Time\nresult.Array() []gjson.Result\nresult.Map() map[string]gjson.Result\nresult.Get(path string) Result\nresult.ForEach(iterator func(key, value Result) bool)\nresult.Less(token Result, caseSensitive bool) bool\n```\n\nThe `result.Value()` function returns an `interface{}` which requires type assertion and is one of the following Go types:\n\nThe `result.Array()` function returns back an array of values.\nIf the result represents a non-existent value, then an empty array will be returned.\nIf the result is not a JSON array, the return value will be an array containing one result.\n\n```go\nboolean >> bool\nnumber  >> float64\nstring  >> string\nnull    >> nil\narray   >> []interface{}\nobject  >> map[string]interface{}\n```\n\n### 64-bit integers\n\nThe `result.Int()` and `result.Uint()` calls are capable of reading all 64 bits, allowing for large JSON integers.\n\n```go\nresult.Int() int64    // -9223372036854775808 to 9223372036854775807\nresult.Uint() int64   // 0 to 18446744073709551615\n```\n\n## Modifiers and path chaining \n\nNew in version 1.2 is support for modifier functions and path chaining.\n\nA modifier is a path component that performs custom processing on the \njson.\n\nMultiple paths can be "chained" together using the pipe character. \nThis is useful for getting results from a modified query.\n\nFor example, using the built-in `@reverse` modifier on the above json document,\nwe\'ll get `children` array and reverse the order:\n\n```\n"children|@reverse"           >> ["Jack","Alex","Sara"]\n"children|@reverse|0"         >> "Jack"\n```\n\nThere are currently three built-in modifiers:\n\n- `@reverse`: Reverse an array or the members of an object.\n- `@ugly`: Remove all whitespace from a json document.\n- `@pretty`: Make the json document more human readable.\n\n### Modifier arguments\n\nA modifier may accept an optional argument. The argument can be a valid JSON \ndocument or just characters.\n\nFor example, the `@pretty` modifier takes a json object as its argument. \n\n```\n@pretty:{"sortKeys":true} \n```\n\nWhich makes the json pretty and orders all of its keys.\n\n```json\n{\n  "age":37,\n  "children": ["Sara","Alex","Jack"],\n  "fav.movie": "Deer Hunter",\n  "friends": [\n    {"age": 44, "first": "Dale", "last": "Murphy"},\n    {"age": 68, "first": "Roger", "last": "Craig"},\n    {"age": 47, "first": "Jane", "last": "Murphy"}\n  ],\n  "name": {"first": "Tom", "last": "Anderson"}\n}\n```\n\n*The full list of `@pretty` options are `sortKeys`, `indent`, `prefix`, and `width`. \nPlease see [Pretty Options](https://github.com/tidwall/pretty#customized-output) for more information.*\n\n### Custom modifiers\n\nYou can also add custom modifiers.\n\nFor example, here we create a modifier that makes the entire json document upper\nor lower case.\n\n```go\ngjson.AddModifier("case", func(json, arg string) string {\n  if arg == "upper" {\n    return strings.ToUpper(json)\n  }\n  if arg == "lower" {\n    return strings.ToLower(json)\n  }\n  return json\n})\n```\n\n```\n"children|@case:upper"           >> ["SARA","ALEX","JACK"]\n"children|@case:lower|@reverse"  >> ["jack","alex","sara"]\n```\n\n## JSON Lines\n\nThere\'s support for [JSON Lines](http://jsonlines.org/) using the `..` prefix, which treats a multilined document as an array. \n\nFor example:\n\n```\n{"name": "Gilbert", "age": 61}\n{"name": "Alexa", "age": 34}\n{"name": "May", "age": 57}\n{"name": "Deloise", "age": 44}\n```\n\n```\n..#                   >> 4\n..1                   >> {"name": "Alexa", "age": 34}\n..3                   >> {"name": "Deloise", "age": 44}\n..#.name              >> ["Gilbert","Alexa","May","Deloise"]\n..#(name="May").age   >> 57\n```\n\nThe `ForEachLines` function will iterate through JSON lines.\n\n```go\ngjson.ForEachLine(json, func(line gjson.Result) bool{\n    println(line.String())\n    return true\n})\n```\n\n## Get nested array values\n\nSuppose you want all the last names from the following json:\n\n```json\n{\n  "programmers": [\n    {\n      "firstName": "Janet", \n      "lastName": "McLaughlin", \n    }, {\n      "firstName": "Elliotte", \n      "lastName": "Hunter", \n    }, {\n      "firstName": "Jason", \n      "lastName": "Harold", \n    }\n  ]\n}\n```\n\nYou would use the path "programmers.#.lastName" like such:\n\n```go\nresult := gjson.Get(json, "programmers.#.lastName")\nfor _, name := range result.Array() {\n\tprintln(name.String())\n}\n```\n\nYou can also query an object inside an array:\n\n```go\nname := gjson.Get(json, `programmers.#(lastName="Hunter").firstName`)\nprintln(name.String())  // prints "Elliotte"\n```\n\n## Iterate through an object or array\n\nThe `ForEach` function allows for quickly iterating through an object or array. \nThe key and value are passed to the iterator function for objects.\nOnly the value is passed for arrays.\nReturning `false` from an iterator will stop iteration.\n\n```go\nresult := gjson.Get(json, "programmers")\nresult.ForEach(func(key, value gjson.Result) bool {\n\tprintln(value.String()) \n\treturn true // keep iterating\n})\n```\n\n## Simple Parse and Get\n\nThere\'s a `Parse(json)` function that will do a simple parse, and `result.Get(path)` that will search a result.\n\nFor example, all of these will return the same result:\n\n```go\ngjson.Parse(json).Get("name").Get("last")\ngjson.Get(json, "name").Get("last")\ngjson.Get(json, "name.last")\n```\n\n## Check for the existence of a value\n\nSometimes you just want to know if a value exists. \n\n```go\nvalue := gjson.Get(json, "name.last")\nif !value.Exists() {\n\tprintln("no last name")\n} else {\n\tprintln(value.String())\n}\n\n// Or as one step\nif gjson.Get(json, "name.last").Exists() {\n\tprintln("has a last name")\n}\n```\n\n## Validate JSON\n\nThe `Get*` and `Parse*` functions expects that the json is well-formed. Bad json will not panic, but it may return back unexpected results.\n\nIf you are consuming JSON from an unpredictable source then you may want to validate prior to using GJSON.\n\n```go\nif !gjson.Valid(json) {\n\treturn errors.New("invalid json")\n}\nvalue := gjson.Get(json, "name.last")\n```\n\n## Unmarshal to a map\n\nTo unmarshal to a `map[string]interface{}`:\n\n```go\nm, ok := gjson.Parse(json).Value().(map[string]interface{})\nif !ok {\n\t// not a map\n}\n```\n\n## Working with Bytes\n\nIf your JSON is contained in a `[]byte` slice, there\'s the [GetBytes](https://godoc.org/github.com/tidwall/gjson#GetBytes) function. This is preferred over `Get(string(data), path)`.\n\n```go\nvar json []byte = ...\nresult := gjson.GetBytes(json, path)\n```\n\nIf you are using the `gjson.GetBytes(json, path)` function and you want to avoid converting `result.Raw` to a `[]byte`, then you can use this pattern:\n\n```go\nvar json []byte = ...\nresult := gjson.GetBytes(json, path)\nvar raw []byte\nif result.Index > 0 {\n    raw = json[result.Index:result.Index+len(result.Raw)]\n} else {\n    raw = []byte(result.Raw)\n}\n```\n\nThis is a best-effort no allocation sub slice of the original json. This method utilizes the `result.Index` field, which is the position of the raw data in the original json. It\'s possible that the value of `result.Index` equals zero, in which case the `result.Raw` is converted to a `[]byte`.\n\n## Get multiple values at once\n\nThe `GetMany` function can be used to get multiple values at the same time.\n\n```go\nresults := gjson.GetMany(json, "name.first", "name.last", "age")\n```\n\nThe return value is a `[]Result`, which will always contain exactly the same number of items as the input paths.\n\n## Performance\n\nBenchmarks of GJSON alongside [encoding/json](https://golang.org/pkg/encoding/json/), \n[ffjson](https://github.com/pquerna/ffjson), \n[EasyJSON](https://github.com/mailru/easyjson),\n[jsonparser](https://github.com/buger/jsonparser),\nand [json-iterator](https://github.com/json-iterator/go)\n\n```\nBenchmarkGJSONGet-8                  3000000        372 ns/op          0 B/op         0 allocs/op\nBenchmarkGJSONUnmarshalMap-8          900000       4154 ns/op       1920 B/op        26 allocs/op\nBenchmarkJSONUnmarshalMap-8           600000       9019 ns/op       3048 B/op        69 allocs/op\nBenchmarkJSONDecoder-8                300000      14120 ns/op       4224 B/op       184 allocs/op\nBenchmarkFFJSONLexer-8               1500000       3111 ns/op        896 B/op         8 allocs/op\nBenchmarkEasyJSONLexer-8             3000000        887 ns/op        613 B/op         6 allocs/op\nBenchmarkJSONParserGet-8             3000000        499 ns/op         21 B/op         0 allocs/op\nBenchmarkJSONIterator-8              3000000        812 ns/op        544 B/op         9 allocs/op\n```\n\nJSON document used:\n\n```json\n{\n  "widget": {\n    "debug": "on",\n    "window": {\n      "title": "Sample Konfabulator Widget",\n      "name": "main_window",\n      "width": 500,\n      "height": 500\n    },\n    "image": { \n      "src": "Images/Sun.png",\n      "hOffset": 250,\n      "vOffset": 250,\n      "alignment": "center"\n    },\n    "text": {\n      "data": "Click Here",\n      "size": 36,\n      "style": "bold",\n      "vOffset": 100,\n      "alignment": "center",\n      "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;"\n    }\n  }\n}    \n```\n\nEach operation was rotated though one of the following search paths:\n\n```\nwidget.window.name\nwidget.image.hOffset\nwidget.text.onMouseUp\n```\n\n*These benchmarks were run on a MacBook Pro 15" 2.8 GHz Intel Core i7 using Go 1.8 and can be be found [here](https://github.com/tidwall/gjson-benchmarks).*\n\n\n## Contact\nJosh Baker [@tidwall](http://twitter.com/tidwall)\n\n## License\n\nGJSON source code is available under the MIT [License](/LICENSE).\n'