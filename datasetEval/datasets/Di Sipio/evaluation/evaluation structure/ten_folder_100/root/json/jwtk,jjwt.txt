b'[![Build Status](https://travis-ci.org/jwtk/jjwt.svg?branch=master)](https://travis-ci.org/jwtk/jjwt)\n[![Coverage Status](https://coveralls.io/repos/github/jwtk/jjwt/badge.svg?branch=master)](https://coveralls.io/github/jwtk/jjwt?branch=master)\n[![Gitter](https://badges.gitter.im/jwtk/jjwt.svg)](https://gitter.im/jwtk/jjwt?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\n\n## Java JWT: JSON Web Token for Java and Android\n\nJJWT aims to be the easiest to use and understand library for creating and verifying JSON Web Tokens (JWTs) on the JVM\nand Android.\n\nJJWT is a pure Java implementation based \nexclusively on the [JWT](https://tools.ietf.org/html/rfc7519), \n[JWS](https://tools.ietf.org/html/rfc7515), [JWE](https://tools.ietf.org/html/rfc7516), \n[JWK](https://tools.ietf.org/html/rfc7517) and [JWA](https://tools.ietf.org/html/rfc7518) RFC specifications and \nopen source under the terms of the [Apache 2.0 License](http://www.apache.org/licenses/LICENSE-2.0).\n\nThe library was created by [Okta\'s](http://www.okta.com) Senior Architect, [Les Hazlewood](https://github.com/lhazlewood)\nand is supported and maintained by a [community](https://github.com/jwtk/jjwt/graphs/contributors) of contributors.\n\n[Okta](https://developer.okta.com/) is a complete authentication and user management API for developers.\n\nWe\'ve also added some convenience extensions that are not part of the specification, such as JWS compression and claim \nenforcement.\n\n## Table of Contents\n\n* [Features](#features)\n  * [Currently Unsupported Features](#features-unsupported)\n* [Community](#community)\n  * [Getting Help](#help)\n    * [Questions](#help-questions)\n    * [Bugs and Feature Requests](#help-issues)\n  * [Contributing](#contributing)\n    * [Pull Requests](#contributing-pull-requests)\n    * [Help Wanted](#contributing-help-wanted)\n* [What is a JSON Web Token?](#overview)\n* [Installation](#install)\n  * [JDK Projects](#install-jdk)\n    * [Maven](#install-jdk-maven)\n    * [Gradle](#install-jdk-gradle)\n  * [Android Projects](#install-android)\n    * [Dependencies](#install-android-dependencies)\n    * [Proguard Exclusions](#install-android-proguard)\n  * [Understanding JJWT Dependencies](#install-understandingdependencies)\n* [Quickstart](#quickstart)\n* [Signed JWTs](#jws)\n  * [Signature Algorithm Keys](#jws-key)\n    * [HMAC-SHA](#jws-key-hmacsha)\n    * [RSA](#jws-key-rsa)\n    * [Elliptic Curve](#jws-key-ecdsa)\n    * [Creating Safe Keys](#jws-key-create)\n      * [Secret Keys](#jws-key-create-secret)\n      * [Asymetric Keys](#jws-key-create-asym)\n  * [Create a JWS](#jws-create)\n    * [Header](#jws-create-header)\n      * [Instance](#jws-create-header-instance)\n      * [Map](#jws-create-header-map)\n    * [Claims](#jws-create-claims)\n      * [Standard Claims](#jws-create-claims-standard)\n      * [Custom Claims](#jws-create-claims-custom)\n      * [Claims Instance](#jws-create-claims-instance)\n      * [Claims Map](#jws-create-claims-map)\n    * [Signing Key](#jws-create-key)\n      * [Signature Algorithm Override](#jws-create-key-algoverride)\n    * [Compression](#jws-create-compression)\n  * [Read a JWS](#jws-read)\n    * [Verification Key](#jws-read-key)\n      * [Find the Verification Key at Runtime](#jws-read-key-resolver)\n    * [Claims Assertions](#jws-read-claims)\n    * [Accounting for Clock Skew](#jws-read-clock)\n      * [Custom Clock](#jws-read-clock-custom)\n    * [Decompression](#jws-read-decompression)\n    <!-- * [Error Handling](#jws-read-errors) -->\n* [Compression](#compression)\n  * [Custom Compression Codec](#compression-custom)\n* [JSON Processor](#json)\n  * [Custom JSON Processor](#json-custom)\n  * [Jackson ObjectMapper](#json-jackson)\n* [Base64 Codec](#base64)\n  * [Custom Base64 Codec](#base64-custom)\n\n<a name="features"></a>\n## Features\n\n * Fully functional on all JDKs and Android\n * Automatic security best practices and assertions\n * Easy to learn and read API\n * Convenient and readable [fluent](http://en.wikipedia.org/wiki/Fluent_interface) interfaces, great for IDE auto-completion to write code quickly\n * Fully RFC specification compliant on all implemented functionality, tested against RFC-specified test vectors\n * Stable implementation with enforced 100% test code coverage.  Literally every single method, statement and \n   conditional branch variant in the entire codebase is tested and required to pass on every build.\n * Creating, parsing and verifying digitally signed compact JWTs (aka JWSs) with all standard JWS algorithms:\n    * HS256: HMAC using SHA-256\n    * HS384: HMAC using SHA-384\n    * HS512: HMAC using SHA-512\n    * ES256: ECDSA using P-256 and SHA-256\n    * ES384: ECDSA using P-384 and SHA-384\n    * ES512: ECDSA using P-521 and SHA-512\n    * RS256: RSASSA-PKCS-v1_5 using SHA-256\n    * RS384: RSASSA-PKCS-v1_5 using SHA-384\n    * RS512: RSASSA-PKCS-v1_5 using SHA-512\n    * PS256: RSASSA-PSS using SHA-256 and MGF1 with SHA-256<sup>1</sup>\n    * PS384: RSASSA-PSS using SHA-384 and MGF1 with SHA-384<sup>1</sup>\n    * PS512: RSASSA-PSS using SHA-512 and MGF1 with SHA-512<sup>1</sup>\n    \n     <sup>1. Requires JDK 11 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.</sup>\n * Convenience enhancements beyond the specification such as\n    * Body compression for any large JWT, not just JWEs\n    * Claims assertions (requiring specific values)\n    * Claim POJO marshaling and unmarshaling when using a compatible JSON parser (e.g. Jackson) \n    * Secure Key generation based on desired JWA algorithms\n    * and more...\n    \n<a name="features-unsupported"></a>\n### Currently Unsupported Features\n\n* [Non-compact](https://tools.ietf.org/html/rfc7515#section-7.2) serialization and parsing.\n* JWE (Encryption for JWT)\n\nThese features will be implemented in a future release.  Community contributions are welcome!\n\n<a name="community"></a>\n## Community\n\n<a name="help"></a>\n### Getting Help\n\nIf you have trouble using JJWT, please first read the documentation on this page before asking questions.  We try \nvery hard to ensure JJWT\'s documentation is robust, categorized with a table of contents, and up to date for each release.\n\n<a name="help-questions"></a>\n#### Questions\n\nIf the documentation or the API JavaDoc isn\'t sufficient, and you either have usability questions or are confused\nabout something, please [ask your question here](https://stackoverflow.com/questions/ask?tags=jjwt&guided=false).\n\nAfter asking your question, you may wish to join our [Slack](https://jwtk.slack.com/messages/CBNACTN3A) or\n[Gittr](https://gitter.im/jwtk/jjwt) chat rooms, but note that they may not always be attended. You will usually\nhave a better chance of having your question answered by \n[asking your question here](https://stackoverflow.com/questions/ask?tags=jjwt&guided=false).\n   \nIf you believe you have found a bug or would like to suggest a feature enhancement, please create a new GitHub issue, \nhowever:\n\n**Please do not create a GitHub issue to ask a question.**  \n\nWe use GitHub Issues to track actionable work that requires changes to JJWT\'s design and/or codebase.  If you have a \nusability question, instead please \n[ask your question here](https://stackoverflow.com/questions/ask?tags=jjwt&guided=false), or try Slack or Gittr as \ndescribed above.\n\n**If a GitHub Issue is created that does not represent actionable work for JJWT\'s codebase, it will be promptly closed.**\n\n<a name="help-issues"></a>\n#### Bugs and Feature Requests\n\nIf you do not have a usability question and believe you have a legitimate bug or feature request, \nplease do [create a new JJWT issue](https://github.com/jwtk/jjwt/issues/new).\n\nIf you feel like you\'d like to help fix a bug or implement the new feature yourself, please read the Contributing \nsection next before starting any work.\n\n<a name="contributing"></a>\n### Contributing\n\n<a name="contributing-pull-requests"></a>\n#### Pull Requests\n\nSimple Pull Requests that fix anything other than JJWT core code (documentation, JavaDoc, typos, test cases, etc) are \nalways appreciated and have a high likelihood of being merged quickly. Please send them!\n\nHowever, if you want or feel the need to change JJWT\'s functionality or core code, please do not issue a pull request \nwithout [creating a new JJWT issue](https://github.com/jwtk/jjwt/issues/new) and discussing your desired \nchanges **first**, _before you start working on it_.\n\nIt would be a shame to reject your earnest and genuinely appreciated pull request if it might not not align with the \nproject\'s goals, design expectations or planned functionality.  We\'ve sadly had to reject large PRs in the past because\nthey were out of sync with project or design expectations - all because the PR author didn\'t first check in with \nthe team first before working on a solution.\n\nSo, please [create a new JJWT issue](https://github.com/jwtk/jjwt/issues/new) first to discuss, and then we can see if\n(or how) a PR is warranted.  Thank you!\n\n<a name="contributing-help-wanted"></a>\n#### Help Wanted\n\nIf you would like to help, but don\'t know where to start, please visit the \n[Help Wanted Issues](https://github.com/jwtk/jjwt/labels/help%20wanted) page and pick any of the \nones there, and we\'ll be happy to discuss and answer questions in the issue comments.\n\nIf any of those don\'t appeal to you, no worries! Any help you would like to offer would be \nappreciated based on the above caveats concerning [contributing pull reqeuests](#contributing-pull-requests). Feel free\nto discuss or ask questions first if you\'re not sure. :)\n\n<a name="overview"></a>\n## What is a JSON Web Token?\n\nDon\'t know what a JSON Web Token is? Read on. Otherwise, jump on down to the [Installation](#Installation) section.\n\nJWT is a means of transmitting information between two parties in a compact, verifiable form.\n\nThe bits of information encoded in the body of a JWT are called `claims`. The expanded form of the JWT is in a JSON format, so each `claim` is a key in the JSON object.\n \nJWTs can be cryptographically signed (making it a [JWS](https://tools.ietf.org/html/rfc7515)) or encrypted (making it a [JWE](https://tools.ietf.org/html/rfc7516)).\n\nThis adds a powerful layer of verifiability to the user of JWTs. The receiver has a high degree of confidence that the JWT has not been tampered with by verifying the signature, for instance.\n\nThe compact representation of a signed JWT is a string that has three parts, each separated by a `.`:\n\n```\neyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJKb2UifQ.ipevRNuRP6HflG8cFKnmUPtypruRC4fb1DWtoLL62SY\n```\n\nEach part is [Base64URL](https://en.wikipedia.org/wiki/Base64)-encoded. The first part is the header, which at a \nminimum needs to specify the algorithm used to sign the JWT. The second part is the body. This part has all \nthe claims of this JWT encoded in it. The final part is the signature. It\'s computed by passing a combination of \nthe header and body through the algorithm specified in the header.\n \nIf you pass the first two parts through a base 64 url decoder, you\'ll get the following (formatting added for \nclarity):\n\n`header`\n```\n{\n  "alg": "HS256"\n}\n```\n\n`body`\n```\n{\n  "sub": "Joe"\n}\n```\n\nIn this case, the information we have is that the HMAC using SHA-256 algorithm was used to sign the JWT. And, the \nbody has a single claim, `sub` with value `Joe`.\n\nThere are a number of standard claims, called [Registered Claims](https://tools.ietf.org/html/rfc7519#section-4.1), \nin the specification and `sub` (for subject) is one of them.\n\nTo compute the signature, you need a secret key to sign it. We\'ll cover keys and algorithms later.\n\n<a name="install"></a>\n## Installation\n\nUse your favorite Maven-compatible build tool to pull the dependencies from Maven Central.\n\nThe dependencies could differ slightly if you are working with a [JDK project](#install-jdk) or an \n[Android project](#install-android).\n\n<a name="install-jdk"></a>\n### JDK Projects\n\nIf you\'re building a (non-Android) JDK project, you will want to define the following dependencies:\n\n<a name="install-jdk-maven"></a>\n#### Maven\n\n```xml\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-api</artifactId>\n    <version>0.10.7</version>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-impl</artifactId>\n    <version>0.10.7</version>\n    <scope>runtime</scope>\n</dependency>\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-jackson</artifactId>\n    <version>0.10.7</version>\n    <scope>runtime</scope>\n</dependency>\n<!-- Uncomment this next dependency if you want to use RSASSA-PSS (PS256, PS384, PS512) algorithms:\n<dependency>\n    <groupId>org.bouncycastle</groupId>\n    <artifactId>bcprov-jdk15on</artifactId>\n    <version>1.60</version>\n    <scope>runtime</scope>\n</dependency>\n-->\n\n```\n\n<a name="install-jdk-gradle"></a>\n#### Gradle\n\n```groovy\ndependencies {\n    compile \'io.jsonwebtoken:jjwt-api:0.10.7\'\n    runtime \'io.jsonwebtoken:jjwt-impl:0.10.7\',\n            // Uncomment the next line if you want to use RSASSA-PSS (PS256, PS384, PS512) algorithms:\n            //\'org.bouncycastle:bcprov-jdk15on:1.60\',\n            \'io.jsonwebtoken:jjwt-jackson:0.10.7\'\n}\n```\n\n<a name="install-android"></a>\n### Android Projects\n\nAndroid projects will want to define the following dependencies and Proguard exclusions:\n\n<a name="install-android-dependencies"></a>\n#### Dependencies\n\nAdd the dependencies to your project:\n\n```groovy\ndependencies {\n    api \'io.jsonwebtoken:jjwt-api:0.10.7\'\n    runtimeOnly \'io.jsonwebtoken:jjwt-impl:0.10.7\' \n    runtimeOnly(\'io.jsonwebtoken:jjwt-orgjson:0.10.7\') {\n        exclude group: \'org.json\', module: \'json\' //provided by Android natively\n    }\n    // Uncomment the next line if you want to use RSASSA-PSS (PS256, PS384, PS512) algorithms:\n    //runtimeOnly \'org.bouncycastle:bcprov-jdk15on:1.60\'\n}\n```\n\n<a name="install-android-proguard"></a>\n#### Proguard\n\nYou can use the following [Android Proguard](https://developer.android.com/studio/build/shrink-code) exclusion rules: \n\n```\n-keepattributes InnerClasses\n\n-keep class io.jsonwebtoken.** { *; }\n-keepnames class io.jsonwebtoken.* { *; }\n-keepnames interface io.jsonwebtoken.* { *; }\n\n-keep class org.bouncycastle.** { *; }\n-keepnames class org.bouncycastle.** { *; }\n-dontwarn org.bouncycastle.**\n```\n\n<a name="install-understandingdependencies"></a>\n### Understanding JJWT Dependencies\n\nNotice the above dependency declarations all have only one compile-time dependency and the rest are declared as \n_runtime_ dependencies.\n\nThis is because JJWT is designed so you only depend on the APIs that are explicitly designed for you to use in\nyour applications and all other internal implementation details - that can change without warning - are relegated to\nruntime-only dependencies.  This is an extremely important point if you want to ensure stable JJWT usage and\nupgrades over time:\n\n**JJWT guarantees semantic versioning compatibility for all of its artifacts _except_ the `jjwt-impl` .jar.  No such \nguarantee is made for the `jjwt-impl` .jar and internal changes in that .jar can happen at any time.  Never add the \n`jjwt-impl` .jar to your project with `compile` scope - always declare it with `runtime` scope.**\n\nThis is done to benefit you: great care goes into curating the `jjwt-api` .jar and ensuring it contains what you need\nand remains backwards compatible as much as is possible so you can depend on that safely with compile scope.  The \nruntime `jjwt-impl` .jar strategy affords the JJWT developers the flexibility to change the internal packages and \nimplementations whenever and however necessary.  This helps us implement features, fix bugs, and ship new releases to \nyou more quickly and efficiently.\n\n<a name="quickstart"></a>\n## Quickstart\n\nMost complexity is hidden behind a convenient and readable builder-based [fluent interface](http://en.wikipedia.org/wiki/Fluent_interface), great for relying on IDE auto-completion to write code quickly.  Here\'s an example:\n\n```java\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport io.jsonwebtoken.security.Keys;\nimport java.security.Key;\n\n// We need a signing key, so we\'ll create one just for this example. Usually\n// the key would be read from your application configuration instead.\nKey key = Keys.secretKeyFor(SignatureAlgorithm.HS256);\n\nString jws = Jwts.builder().setSubject("Joe").signWith(key).compact();\n```\n\nHow easy was that!?\n\nIn this case, we are:\n \n 1. *building* a JWT that will have the \n[registered claim](https://tools.ietf.org/html/rfc7519#section-4.1) `sub` (subject) set to `Joe`. We are then\n 2. *signing* the JWT using a key suitable for the HMAC-SHA-256 algorithm.  Finally, we are\n 3. *compacting* it into its final `String` form.  A signed JWT is called a \'JWS\'.\n\nThe resultant `jws` String looks like this:\n\n```\neyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJKb2UifQ.1KP0SsvENi7Uz1oQc07aXTL7kpQG5jBNIybqr60AlD4\n```\n\nNow let\'s verify the JWT (you should always discard JWTs that don\'t match an expected signature):\n\n```java\nassert Jwts.parser().setSigningKey(key).parseClaimsJws(jws).getBody().getSubject().equals("Joe");\n```\n\n**NOTE: Ensure you call the `parseClaimsJws` method** (since there are many similar methods available). You will get an `UnsupportedJwtException` if you parse your JWT with wrong method.\n\nThere are two things going on here. The `key` from before is being used to validate the signature of the JWT. If it \nfails to verify the JWT, a `SignatureException` (which extends from `JwtException`) is thrown. Assuming the JWT is \nvalidated, we parse out the claims and assert that that subject is set to `Joe`.\n\nYou have to love code one-liners that pack a punch!\n\nBut what if parsing or signature validation failed?  You can catch `JwtException` and react accordingly:\n\n```java\ntry {\n\n    Jwts.parser().setSigningKey(key).parseClaimsJws(compactJws);\n\n    //OK, we can trust this JWT\n\n} catch (JwtException e) {\n\n    //don\'t trust the JWT!\n}\n```\n\n<a name="jws"></a>\n## Signed JWTs\n\nThe JWT specification provides for the ability to \n[cryptographically _sign_](https://en.wikipedia.org/wiki/Digital_signature) a JWT.  Signing a JWT:\n \n1. guarantees the JWT was created by someone we know (it is authentic) as well as\n2. guarantees that no-one has manipulated or changed the JWT after it was created (its integrity is maintained).\n\nThese two properties - authenticity and integrity - assure us that a JWT contains information we can trust.  If a \nJWT fails authenticity or integrity checks, we should always reject that JWT because we can\'t trust it.\n\nSo how is a JWT signed?  Let\'s walk through it with some easy-to-read pseudocode:\n\n1. Assume we have a JWT with a JSON header and body (aka \'Claims\') as follows:\n  \n   **header**\n   ```\n   {\n     "alg": "HS256"\n   }\n   ```\n   \n   **body**\n   ```\n   {\n     "sub": "Joe"\n   }\n   ```\n   \n2. Remove all unnecessary whitespace in the JSON:\n   \n   ```groovy\n   String header = \'{"alg":"HS256"}\'\n   String claims = \'{"sub":"Joe"}\'\n   ```\n   \n3. Get the UTF-8 bytes and Base64URL-encode each:\n   \n   ```groovy\n   String encodedHeader = base64URLEncode( header.getBytes("UTF-8") )\n   String encodedClaims = base64URLEncode( claims.getBytes("UTF-8") )\n   ```\n   \n4. Concatenate the encoded header and claims with a period character between them:\n\n   ```groovy\n   String concatenated = encodedHeader + \'.\' + encodedClaims\n   ```\n   \n5.  Use a sufficiently-strong cryptographic secret or private key, along with a signing algorithm of your choice\n    (we\'ll use HMAC-SHA-256 here), and sign the concatenated string:\n    \n    ```groovy\n    Key key = getMySecretKey()\n    byte[] signature = hmacSha256( concatenated, key )\n    ```\n    \n6. Because signatures are always byte arrays, Base64URL-encode the signature and append a period character \'.\' and it \n   to the concatenated string:\n   \n   ```groovy\n   String jws = concatenated + \'.\' + base64URLEncode( signature )\n   ```\n \n \nAnd there you have it, the final `jws` String looks like this:\n \n```\neyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJKb2UifQ.1KP0SsvENi7Uz1oQc07aXTL7kpQG5jBNIybqr60AlD4\n```\n\nThis is called a \'JWS\' - short for _signed_ JWT.\n\nOf course, no one would want to do this manually in code, and worse, if you get anything wrong, you could cause \nsecurity problems or weaknesses.  As a result, JJWT was created to handle all of this for you: JJWT completely \nautomates both the creation of JWSs as well as the parsing and verification of JWSs for you.\n\nBut before we dig in to showing you how to create a JWS using JJWT, let\'s briefly discuss Signature Algorithms and \nKeys, specifically as they relate to the JWT specifications.  Understanding them is critical to being able to create a \nJWS properly.\n\n<a name="jws-key"></a>\n### Signature Algorithms Keys\n\nThe JWT specification identifies 12 standard signature algorithms - 3 secret key algorithms and 9 asymmetric \nkey algorithms - identified by the following names:\n\n* `HS256`: HMAC using SHA-256\n* `HS384`: HMAC using SHA-384\n* `HS512`: HMAC using SHA-512\n* `ES256`: ECDSA using P-256 and SHA-256\n* `ES384`: ECDSA using P-384 and SHA-384\n* `ES512`: ECDSA using P-521 and SHA-512\n* `RS256`: RSASSA-PKCS-v1_5 using SHA-256\n* `RS384`: RSASSA-PKCS-v1_5 using SHA-384\n* `RS512`: RSASSA-PKCS-v1_5 using SHA-512\n* `PS256`: RSASSA-PSS using SHA-256 and MGF1 with SHA-256\n* `PS384`: RSASSA-PSS using SHA-384 and MGF1 with SHA-384\n* `PS512`: RSASSA-PSS using SHA-512 and MGF1 with SHA-512\n\nThese are all represented in the `io.jsonwebtoken.SignatureAlgorithm` enum.\n\nWhat\'s really important about these algorithms - other than their security properties - is that the JWT specification\n[RFC 7518, Sections 3.2 through 3.5](https://tools.ietf.org/html/rfc7518#section-3)\n_requires_ (mandates) that you MUST use keys that are sufficiently strong for a chosen algorithm.\n\nThis means that JJWT - a specification-compliant library - will also enforce that you use sufficiently strong keys\nfor the algorithms you choose.  If you provide a weak key for a given algorithm, JJWT will reject it and throw an\nexception.\n\nThis is not because we want to make your life difficult, we promise! The reason why the JWT specification, and \nconsequently JJWT, mandates key lengths is that the security model of a particular algorithm can completely break \ndown if you don\'t adhere to the mandatory key properties of the algorithm, effectively having no security at all.  No \none wants completely insecure JWTs, right?  Neither would we.\n\nSo what are the requirements?\n\n<a name="jws-key-hmacsha"></a>\n#### HMAC-SHA\n\nJWT HMAC-SHA signature algorithms `HS256`, `HS384`, and `HS512` require a secret key that is _at least_ as many bits as\nthe algorithm\'s signature (digest) length per [RFC 7512 Section 3.2](https://tools.ietf.org/html/rfc7518#section-3.2). \nThis means:\n\n* `HS256` is HMAC-SHA-256, and that produces digests that are 256 bits (32 bytes) long, so `HS256` _requires_ that you\n  use a secret key that is at least 32 bytes long.\n  \n* `HS384` is HMAC-SHA-384, and that produces digests that are 384 bits (48 bytes) long, so `HS384` _requires_ that you\n  use a secret key that is at least 48 bytes long. \n\n* `HS512` is HMAC-SHA-512, and that produces digests that are 512 bits (64 bytes) long, so `HS512` _requires_ that you\n  use a secret key that is at least 64 bytes long. \n  \n<a name="jws-key-rsa"></a>\n#### RSA\n\nJWT RSA signature algorithms `RS256`, `RS384`, `RS512`, `PS256`, `PS384` and `PS512` all require a minimum key length\n(aka an RSA modulus bit length) of `2048` bits per RFC 7512 Sections \n[3.3](https://tools.ietf.org/html/rfc7518#section-3.3) and [3.5](https://tools.ietf.org/html/rfc7518#section-3.5). \nAnything smaller than this (such as 1024 bits) will be rejected with an `InvalidKeyException`.\n\nThat said, in keeping with best practices and increasing key lengths for security longevity, JJWT \nrecoommends that you use:\n\n* at least 2048 bit keys with `RS256` and `PS256`\n* at least 3072 bit keys with `RS384` and `PS384`\n* at least 4096 bit keys with `RS512` and `PS512`\n\nThese are only JJWT suggestions and not requirements. JJWT only enforces JWT specification requirements and\nfor any RSA key, the requirement is the RSA key (modulus) length in bits MUST be >= 2048 bits.\n\n<a name="jws-key-ecdsa"></a>\n#### Elliptic Curve\n\nJWT Elliptic Curve signature algorithms `ES256`, `ES384`, and `ES512` all require a minimum key length\n(aka an Elliptic Curve order bit length) that is _at least_ as many bits as the algorithm signature\'s individual \n`R` and `S` components per [RFC 7512 Section 3.4](https://tools.ietf.org/html/rfc7518#section-3.4).  This means:\n\n* `ES256` requires that you use a private key that is at least 256 bits (32 bytes) long.\n  \n* `ES384` requires that you use a private key that is at least 384 bits (48 bytes) long.\n\n* `ES512` requires that you use a private key that is at least 512 bits (64 bytes) long.\n\n<a name="jws-key-create"></a>\n#### Creating Safe Keys\n\nIf you don\'t want to think about bit length requirements or just want to make your life easier, JJWT has\nprovided the `io.jsonwebtoken.security.Keys` utility class that can generate sufficiently secure keys for any given\nJWT signature algorithm you might want to use.\n\n<a name="jws-key-create-secret"></a>\n##### Secret Keys\n\nIf you want to generate a sufficiently strong `SecretKey` for use with the JWT HMAC-SHA algorithms, use the \n`Keys.secretKeyFor(SignatureAlgorithm)` helper method:\n\n```java\nSecretKey key = Keys.secretKeyFor(SignatureAlgorithm.HS256); //or HS384 or HS512\n```\n\nUnder the hood, JJWT uses the JCA provider\'s `KeyGenerator` to create a secure-random key with the correct minimum\nlength for the given algorithm.\n\nIf you have an existing HMAC SHA `SecretKey`\'s \n[encoded byte array](https://docs.oracle.com/javase/8/docs/api/java/security/Key.html#getEncoded--), you can use \nthe `Keys.hmacShaKeyFor` helper method.  For example:\n\n```java\nbyte[] keyBytes = getSigningKeyFromApplicationConfiguration();\nSecretKey key = Keys.hmacShaKeyFor(keyBytes);\n```\n\n<a name="jws-key-create-asym"></a>\n##### Asymmetric Keys\n\nIf you want to generate sufficiently strong Elliptic Curve or RSA asymmetric key pairs for use with JWT ECDSA or RSA\nalgorithms, use the `Keys.keyPairFor(SignatureAlgorithm)` helper method:\n\n```java\nKeyPair keyPair = Keys.keyPairFor(SignatureAlgorithm.RS256); //or RS384, RS512, PS256, PS384, PS512, ES256, ES384, ES512\n```\n\nYou use the private key (`keyPair.getPrivate()`) to create a JWS and the public key (`keyPair.getPublic()`) to \nparse/verify a JWS.\n\n**NOTE: The `PS256`, `PS384`, and `PS512` algorithms require JDK 11 or a compatible JCA Provider \n(like BouncyCastle) in the runtime classpath.**  If you are using JDK 10 or earlier and you want to use them, see \nthe [Installation](#Installation) section to see how to enable BouncyCastle.  All other algorithms are natively \nsupported by the JDK.\n\n<a name="jws-create"></a>\n### Creating a JWS\n\nYou create a JWS as follows:\n\n1. Use the `Jwts.builder()` method to create a `JwtBuilder` instance.  \n2. Call `JwtBuilder` methods to add header parameters and claims as desired.\n3. Specify the `SecretKey` or asymmetric `PrivateKey` you want to use to sign the JWT.\n4. Finally, call the `compact()` method to compact and sign, producing the final jws.\n\nFor example:\n\n```java\nString jws = Jwts.builder() // (1)\n\n    .setSubject("Bob")      // (2) \n\n    .signWith(key)          // (3)\n     \n    .compact();             // (4)\n```\n\n<a name="jws-create-header"></a>\n#### Header Parameters\n\nA JWT Header provides metadata about the contents, format and cryptographic operations relevant to the JWT\'s Claims.\n\nIf you need to set one or more JWT header parameters, such as the `kid` \n[(Key ID) header parameter](https://tools.ietf.org/html/rfc7515#section-4.1.4), you can simply call\n`JwtBuilder` `setHeaderParam` one or more times as needed:\n\n```java\nString jws = Jwts.builder()\n\n    .setHeaderParam("kid", "myKeyId")\n    \n    // ... etc ...\n\n```\n\nEach time `setHeaderParam` is called, it simply appends the key-value pair to an internal `Header` instance, \npotentially overwriting any existing identically-named key/value pair.\n\n**NOTE**: You do not need to set the `alg` or `zip` header parameters as JJWT will set them automatically\ndepending on the signature algorithm or compression algorithm used.\n\n<a name="jws-create-header-instance"></a>\n##### Header Instance\n\nIf you want to specify the entire header at once, you can use the `Jwts.header()` method and build up the header\nparamters with it:\n\n```java\n\nHeader header = Jwts.header();\n\npopulate(header); //implement me\n\nString jws = Jwts.builder()\n\n    .setHeader(header)\n    \n    // ... etc ...\n\n```\n\n**NOTE**: Calling `setHeader` will overwrite any existing header name/value pairs with the same names that might have \nalready been set. In all cases however, JJWT will still set (and overwrite) any `alg` and `zip` headers regardless \nif those are in the specified `header` object or not.\n\n<a name="jws-create-header-map"></a>\n##### Header Map\n\nIf you want to specify the entire header at once and you don\'t want to use `Jwts.header()`, you can use `JwtBuilder` \n`setHeader(Map)` method instead:\n\n```java\n\nMap<String,Object> header = getMyHeaderMap(); //implement me\n\nString jws = Jwts.builder()\n\n    .setHeader(header)\n    \n    // ... etc ...\n\n```\n\n\n**NOTE**: Calling `setHeader` will overwrite any existing header name/value pairs with the same names that might have \nalready been set. In all cases however, JJWT will still set (and overwrite) any `alg` and `zip` headers regardless \nif those are in the specified `header` object or not.\n\n<a name="jws-create-claims"></a>\n#### Claims\n\nClaims are a JWT\'s \'body\' and contain the information that the JWT creator wishes to present to the JWT recipient(s).\n\n<a name="jws-create-claims-standard"></a>\n##### Standard Claims\n\nThe `JwtBuilder` provides convenient setter methods for standard registered Claim names defined in the JWT \nspecification.  They are:\n\n* `setIssuer`: sets the [`iss` (Issuer) Claim](https://tools.ietf.org/html/rfc7519#section-4.1.1)\n* `setSubject`: sets the [`sub` (Subject) Claim](https://tools.ietf.org/html/rfc7519#section-4.1.2)\n* `setAudience`: sets the [`aud` (Audience) Claim](https://tools.ietf.org/html/rfc7519#section-4.1.3)\n* `setExpiration`: sets the [`exp` (Expiration Time) Claim](https://tools.ietf.org/html/rfc7519#section-4.1.4)\n* `setNotBefore`: sets the [`nbf` (Not Before) Claim](https://tools.ietf.org/html/rfc7519#section-4.1.5)\n* `setIssuedAt`: sets the [`iat` (Issued At) Claim](https://tools.ietf.org/html/rfc7519#section-4.1.6)\n* `setId`: sets the [`jti` (JWT ID) Claim](https://tools.ietf.org/html/rfc7519#section-4.1.7)\n\nFor example:\n\n```java\n\nString jws = Jwts.builder()\n\n    .setIssuer("me")\n    .setSubject("Bob")\n    .setAudience("you")\n    .setExpiration(expiration) //a java.util.Date\n    .setNotBefore(notBefore) //a java.util.Date \n    .setIssuedAt(new Date()) // for example, now\n    .setId(UUID.randomUUID()) //just an example id\n    \n    /// ... etc ...\n```\n\n<a name="jws-create-claims-custom"></a>\n##### Custom Claims\n\nIf you need to set one or more custom claims that don\'t match the standard setter method claims shown above, you\ncan simply call `JwtBuilder` `claim` one or more times as needed:\n\n```java\nString jws = Jwts.builder()\n\n    .claim("hello", "world")\n    \n    // ... etc ...\n\n```\n\nEach time `claim` is called, it simply appends the key-value pair to an internal `Claims` instance, potentially \noverwriting any existing identically-named key/value pair.\n\nObviously, you do not need to call `claim` for any [standard claim name](#jws-create-claims-standard) and it is \nrecommended instead to call the standard respective setter method as this enhances readability.\n\n<a name="jws-create-claims-instance"></a>\n###### Claims Instance\n\nIf you want to specify all claims at once, you can use the `Jwts.claims()` method and build up the claims\nwith it:\n\n```java\n\nClaims claims = Jwts.claims();\n\npopulate(claims); //implement me\n\nString jws = Jwts.builder()\n\n    .setClaims(claims)\n    \n    // ... etc ...\n\n```\n\n**NOTE**: Calling `setClaims` will overwrite any existing claim name/value pairs with the same names that might have \nalready been set.\n\n<a name="jws-create-claims-map"></a>\n###### Claims Map\n\nIf you want to specify all claims at once and you don\'t want to use `Jwts.claims()`, you can use `JwtBuilder` \n`setClaims(Map)` method instead:\n\n```java\n\nMap<String,Object> claims = getMyClaimsMap(); //implement me\n\nString jws = Jwts.builder()\n\n    .setClaims(claims)\n    \n    // ... etc ...\n\n```\n\n**NOTE**: Calling `setClaims` will overwrite any existing claim name/value pairs with the same names that might have \nalready been set.\n\n<a name="jws-create-key"></a>\n#### Signing Key\n\nIt is recommended that you specify the signing key by calling call the `JwtBuilder`\'s `signWith` method and let JJWT\ndetermine the most secure algorithm allowed for the specified key.:\n\n```java\nString jws = Jwts.builder()\n\n   // ... etc ...\n   \n   .signWith(key) // <---\n   \n   .compact();\n```\n\nFor example, if you call `signWith` with a `SecretKey` that is 256 bits (32 bytes) long, it is not strong enough for\n`HS384` or `HS512`, so JJWT will automatically sign the JWT using `HS256`.\n\nWhen using `signWith` JJWT will also automatically set the required `alg` header with the associated algorithm \nidentifier.\n\nSimilarly, if you called `signWith` with an RSA `PrivateKey` that was 4096 bits long, JJWT will use the `RS512`\nalgorithm and automatically set the `alg` header to `RS512`.\n\nThe same selection logic applies for Elliptic Curve `PrivateKey`s.\n\n**NOTE: You cannot sign JWTs with `PublicKey`s as this is always insecure.** JJWT will reject any specified\n`PublicKey` for signing with an `InvalidKeyException`. \n\n<a name="jws-create-key-algoverride"></a>\n##### SignatureAlgorithm Override\n\nIn some specific cases, you might want to override JJWT\'s default selected algorithm for a given key.\n\nFor example, if you have an RSA `PrivateKey` that is 2048 bits, JJWT would automatically choose the `RS256` algorithm.\nIf you wanted to use `RS384` or `RS512` instead, you could manually specify it with the overloaded `signWith` method\nthat accepts the `SignatureAlgorithm` as an additional parameter:\n\n```java\n\n   .signWith(privateKey, SignatureAlgorithm.RS512) // <---\n   \n   .compact();\n\n```\n\nThis is allowed because the JWT specification allows any RSA algorithm strength for any RSA key >= 2048 bits.  JJWT just\nprefers `RS512` for keys >= 4096 bits, followed by `RS384` for keys >= 3072 bits and finally `RS256` for keys >= 2048\nbits.\n\n**In all cases however, regardless of your chosen algorithms, JJWT will assert that the specified key is allowed to be \nused for that algorithm according to the JWT specification requirements.**\n\n<a name="jws-create-compression"></a>\n#### JWS Compression\n\nIf your JWT claims set is large (contains a lot of data), and you are certain that JJWT will also be the same library \nthat reads/parses your JWS, you might want to compress the JWS to reduce its size.  Note that this is\n*not* a standard feature for JWS and is not likely to be supported by other JWT libraries.\n\nPlease see the main [Compression](#compression) section to see how to compress and decompress JWTs.\n\n<a name="jws-read"></a>\n### Reading a JWS\n\nYou read (parse) a JWS as follows:\n\n1. Use the `Jwts.parser()` method to create a `JwtParser` instance.  \n2. Specify the `SecretKey` or asymmetric `PublicKey` you want to use to verify the JWS signature.<sup>1</sup>\n3. Finally, call the `parseClaimsJws(String)` method with your jws `String`, producing the original JWS.\n4. The entire call is wrapped in a try/catch block in case parsing or signature validation fails.  We\'ll cover\n   exceptions and causes for failure later.\n\n<sup>1. If you don\'t know which key to use at the time of parsing, you can look up the key using a `SigningKeyResolver` \nwhich [we\'ll cover later](#jws-read-key-resolver).</sup>\n\nFor example:\n\n```java\nJws<Claims> jws;\n\ntry {\n    jws = Jwts.parser()         // (1)\n    .setSigningKey(key)         // (2)\n    .parseClaimsJws(jwsString); // (3)\n    \n    // we can safely trust the JWT\n     \n} catch (JwtException ex) {     // (4)\n    \n    // we *cannot* use the JWT as intended by its creator\n}\n```\n\n**NOTE: If you expecting a JWS, always call `JwtParser`\'s `parseClaimsJws` method** (and not one of the other similar methods \navailable) as this guarantees the correct security model for parsing signed JWTs.\n\n<a name="jws-read-key"></a>\n#### Verification Key\n\nThe most important thing to do when reading a JWS is to specify the key to use to verify the JWS\'s\ncryptographic signature.  If signature verification fails, the JWT cannot be safely trusted and should be \ndiscarded.\n\nSo which key do we use for verification?\n\n* If the jws was signed with a `SecretKey`, the same `SecretKey` should be specified on the `JwtParser`.  For example:\n\n  ```java\n  Jwts.parser()\n      \n    .setSigningKey(secretKey) // <----\n    \n    .parseClaimsJws(jwsString);\n  ```\n* If the jws was signed with a `PrivateKey`, that key\'s corresponding `PublicKey` (not the `PrivateKey`) should be \n  specified on the `JwtParser`.  For example:\n\n  ```java\n  Jwts.parser()\n      \n    .setSigningKey(publicKey) // <---- publicKey, not privateKey\n    \n    .parseClaimsJws(jwsString);\n  ```\n  \nBut you might have noticed something - what if your application doesn\'t use just a single SecretKey or KeyPair? What\nif JWSs can be created with different `SecretKey`s or public/private keys, or a combination of both?  How do you\nknow which key to specify if you can\'t inspect the JWT first?\n\nIn these cases, you can\'t call the `JwtParser`\'s `setSigningKey` method with a single key - instead, you\'ll need\nto use a `SigningKeyResolver`, covered next.\n\n<a name="jws-read-key-resolver"></a>\n##### Signing Key Resolver\n\nIf your application expects JWSs that can be signed with different keys, you won\'t call the `setSigningKey` method.\nInstead, you\'ll need to implement the \n`SigningKeyResolver` interface and specify an instance on the `JwtParser` via the `setSigningKeyResolver` method.  \nFor example:\n\n```java\nSigningKeyResolver signingKeyResolver = getMySigningKeyResolver();\n\nJwts.parser()\n\n    .setSigningKeyResolver(signingKeyResolver) // <----\n    \n    .parseClaimsJws(jwsString);\n```\n\nYou can simplify things a little by extending from the `SigningKeyResolverAdapter` and implementing the \n`resolveSigningKey(JwsHeader, Claims)` method.  For example:\n\n```java\npublic class MySigningKeyResolver extends SigningKeyResolverAdapter {\n    \n    @Override\n    public Key resolveSigningKey(JwsHeader jwsHeader, Claims claims) {\n        // implement me\n    }\n}\n```\n\nThe `JwtParser` will invoke the `resolveSigningKey` method after parsing the JWS JSON, but _before verifying the\njws signature_.  This allows you to inspect the `JwsHeader` and `Claims` arguments for any information that can\nhelp you look up the `Key` to use for verifying _that specific jws_.  This is very powerful for applications\nwith more complex security models that might use different keys at different times or for different users or customers.\n\nWhich data might you inspect?\n\nThe JWT specification\'s supported way to do this is to set a `kid` (Key ID) field in the JWS header when the JWS is \nbeing created, for example:\n\n```java\n\nKey signingKey = getSigningKey();\n\nString keyId = getKeyId(signingKey); //any mechanism you have to associate a key with an ID is fine\n\nString jws = Jwts.builder()\n    \n    .setHeaderParam(JwsHeader.KEY_ID, keyId) // 1\n    \n    .signWith(signingKey)                    // 2\n    \n    .compact();\n```\n\nThen during parsing, your `SigningKeyResolver` can inspect the `JwsHeader` to get the `kid` and then use that value\nto look up the key from somewhere, like a database.  For example:\n\n```java\npublic class MySigningKeyResolver extends SigningKeyResolverAdapter {\n    \n    @Override\n    public Key resolveSigningKey(JwsHeader jwsHeader, Claims claims) {\n        \n        //inspect the header or claims, lookup and return the signing key\n        \n        String keyId = jwsHeader.getKeyId(); //or any other field that you need to inspect\n        \n        Key key = lookupVerificationKey(keyId); //implement me\n        \n        return key;\n    }\n}\n```\n\nNote that inspecting the `jwsHeader.getKeyId()` is just the most common approach to look up a key - you could \ninspect any number of header fields or claims to determine how to lookup the verification key.  It is all based on \nhow the JWS was created.\n\nFinally remember that for HMAC algorithms, the returned verification key should be a `SecretKey`, and for asymmetric \nalgorithms, the key returned should be a `PublicKey` (not a `PrivateKey`).\n\n<a name="jws-read-claims"></a>\n#### Claim Assertions\n\nYou can enforce that the JWS you are parsing conforms to expectations that you require and are important for your \napplication.\n\nFor example, let\'s say that you require that the JWS you are parsing has a specific `sub` (subject) value,\notherwise you may not trust the token.  You can do that by using one of the various `require`* methods on the \n`JwtParser`:\n\n```java\ntry {\n    Jwts.parser().requireSubject("jsmith").setSigningKey(key).parseClaimsJws(s);\n} catch(InvalidClaimException ice) {\n    // the sub field was missing or did not have a \'jsmith\' value\n}\n```\n\nIf it is important to react to a missing vs an incorrect value, instead of catching `InvalidClaimException`, \nyou can catch either `MissingClaimException` or `IncorrectClaimException`:\n\n```java\ntry {\n    Jwts.parser().requireSubject("jsmith").setSigningKey(key).parseClaimsJws(s);\n} catch(MissingClaimException mce) {\n    // the parsed JWT did not have the sub field\n} catch(IncorrectClaimException ice) {\n    // the parsed JWT had a sub field, but its value was not equal to \'jsmith\'\n}\n```\n\nYou can also require custom fields by using the `require(fieldName, requiredFieldValue)` method - for example:\n\n```java\ntry {\n    Jwts.parser().require("myfield", "myRequiredValue").setSigningKey(key).parseClaimsJws(s);\n} catch(InvalidClaimException ice) {\n    // the \'myfield\' field was missing or did not have a \'myRequiredValue\' value\n}\n```\n(or, again, you could catch either `MissingClaimException` or `IncorrectClaimException` instead).\n\nPlease see the `JwtParser` class and/or JavaDoc for a full list of the various `require`* methods you may use for claims\nassertions.\n\n<a name="jws-read-clock"></a>\n#### Accounting for Clock Skew\n\nWhen parsing a JWT, you might find that `exp` or `nbf` claim assertions fail (throw exceptions) because the clock on \nthe parsing machine is not perfectly in sync with the clock on the machine that created the JWT.  This can cause \nobvious problems since `exp` and `nbf` are time-based assertions, and clock times need to be reliably in sync for shared\nassertions.\n\nYou can account for these differences (usually no more than a few minutes) when parsing using the `JwtParser`\'s\n `setAllowedClockSkewSeconds`. For example:\n\n```java\nlong seconds = 3 * 60; //3 minutes\n\nJwts.parser()\n    \n    .setAllowedClockSkewSeconds(seconds) // <----\n    \n    // ... etc ...\n    .parseClaimsJws(jwt);\n```\nThis ensures that clock differences between the machines can be ignored. Two or three minutes should be more than \nenough; it would be fairly strange if a production machine\'s clock was more than 5 minutes difference from most \natomic clocks around the world.\n\n<a name="jws-read-clock-custom"></a>\n##### Custom Clock Support\n\nIf the above `setAllowedClockSkewSeconds` isn\'t sufficient for your needs, the timestamps created\nduring parsing for timestamp comparisons can be obtained via a custom time source.  Call the `JwtParser`\'s `setClock`\n method with an implementation of the `io.jsonwebtoken.Clock` interface.  For example:\n \n ```java\nClock clock = new MyClock();\n\nJwts.parser().setClock(myClock) //... etc ...\n``` \n\nThe `JwtParser`\'s default `Clock` implementation simply returns `new Date()` to reflect the time when parsing occurs, \nas most would expect.  However, supplying your own clock could be useful, especially when writing test cases to \nguarantee deterministic behavior.\n\n<a name="jws-read-decompression"></a>\n#### JWS Decompression\n\nIf you used JJWT to compress a JWS and you used a custom compression algorithm, you will need to tell the `JwtParser`\nhow to resolve your `CompressionCodec` to decompress the JWT.\n\nPlease see the [Compression](#compression) section below to see how to decompress JWTs during parsing.\n\n<!-- TODO: ## Encrypted JWTs -->\n\n<a name="compression"></a>\n## Compression\n\n**The JWT specification only standardizes this feature for JWEs (Encrypted JWTs) and not JWSs (Signed JWTs), however\nJJWT supports both**.  If you are positive that a JWS you create with JJWT will _also_ be parsed with JJWT, you \ncan use this feature with JWSs, otherwise it is best to only use it for JWEs.  \n\nIf a JWT\'s Claims set is sufficiently large - that is, it contains a lot of name/value pairs, or individual values are \nvery large or verbose - you can reduce the size of the created JWS by compressing the claims body.\n\nThis might be important to you if the resulting JWS is used in a URL for example, since URLs are best kept under \n4096 characters due to browser, user mail agent, or HTTP gateway compatibility issues.  Smaller JWTs also help reduce \nbandwidth utilization, which may or may not be important depending on your application\'s volume or needs.\n\nIf you want to compress your JWT, you can use the `JwtBuilder`\'s  `compressWith(CompressionAlgorithm)` method.  For \nexample:\n\n```java\n   Jwts.builder()\n   \n   .compressWith(CompressionCodecs.DEFLATE) // or CompressionCodecs.GZIP\n   \n   // .. etc ...\n```\n\nIf you use the `DEFLATE` or `GZIP` Compression Codecs - that\'s it, you\'re done.  You don\'t have to do anything during \nparsing or configure the `JwtParser` for compression - JJWT will automatically decompress the body as expected.\n\n<a name="compression-custom"></a>\n### Custom Compression Codec\n\nIf however, you used your own custom compression codec when creating the JWT (via `JwtBuilder` `compressWith`), then\nyou need to supply the codec to the `JwtParser` using the `setCompressionCodecResolver` method.  For example:\n\n```java\nCompressionCodecResolver ccr = new MyCompressionCodecResolver();\n\nJwts.parser()\n\n    .setCompressionCodecResolver(ccr) // <----\n    \n    // .. etc ...\n```\n\nTypically a `CompressionCodecResolver` implementation will inspect the `zip` header to find out what algorithm was\nused and then return a codec instance that supports that algorithm.  For example:\n\n```java\npublic class MyCompressionCodecResolver implements CompressionCodecResolver {\n        \n    @Override\n    public CompressionCodec resolveCompressionCodec(Header header) throws CompressionException {\n        \n        String alg = header.getCompressionAlgorithm();\n            \n        CompressionCodec codec = getCompressionCodec(alg); //implement me\n            \n        return codec;\n    }\n}\n```\n\n<a name="json"></a>\n## JSON Support\n\nA `JwtBuilder` will serialize the `Header` and `Claims` maps (and potentially any Java objects they \ncontain) to JSON with a `Serializer<Map<String, ?>>` instance.  Similarly, a `JwtParser` will \ndeserialize JSON into the `Header` and `Claims` using a `Deserializer<Map<String, ?>>` instance.\n\nIf you don\'t explicitly configure a `JwtBuilder`\'s `Serializer` or a `JwtParser`\'s `Deserializer`, JJWT will \nautomatically attempt to discover and use the following JSON implementations if found in the runtime classpath.  \nThey are checked in order, and the first one found is used:\n\n1. Jackson: This will automatically be used if you specify `io.jsonwebtoken:jjwt-jackson` as a project runtime \n   dependency.  Jackson supports POJOs as claims with full marshaling/unmarshaling as necessary.\n   \n2. JSON-Java (`org.json`): This will be used automatically if you specify `io.jsonwebtoken:jjwt-orgjson` as a \n   project runtime dependency.\n   \n   **NOTE:** `org.json` APIs are natively enabled in Android environments so this is the recommended JSON processor for \n   Android applications _unless_ you want to use POJOs as claims.  The `org.json` library supports simple \n   Object-to-JSON marshaling, but it *does not* support JSON-to-Object unmarshalling.\n\n**If you want to use POJOs as claim values, use the `io.jsonwebtoken:jjwt-jackson` dependency** (or implement your own\nSerializer and Deserializer if desired).  **But beware**, Jackson will force a sizable (> 1 MB) dependency to an \nAndroid application thus increasing the app download size for mobile users.\n\n<a name="json-custom"></a>\n### Custom JSON Processor\n\nIf you don\'t want to use JJWT\'s runtime dependency approach, or just want to customize how JSON serialization and \ndeserialization works, you can implement the `Serializer` and `Deserializer` interfaces and specify instances of\nthem on the `JwtBuilder` and `JwtParser` respectively.  For example:\n\nWhen creating a JWT:\n\n```java\nSerializer<Map<String,?>> serializer = getMySerializer(); //implement me\n\nJwts.builder()\n\n    .serializeToJsonWith(serializer)\n    \n    // ... etc ...\n```\n\nWhen reading a JWT:\n\n```java\nDeserializer<Map<String,?>> deserializer = getMyDeserializer(); //implement me\n\nJwts.parser()\n\n    .deserializeJsonWith(deserializer)\n    \n    // ... etc ...\n```\n\n<a name="json-jackson"></a>\n### Jackson JSON Processor\n\nIf you have an application-wide Jackson `ObjectMapper` (as is typically recommended for most applications), you can \neliminate the overhead of JJWT constructing its own `ObjectMapper` by using yours instead.\n\nYou do this by declaring the `io.jsonwebtoken:jjwt-jackson` dependency with **compile** scope (not runtime \nscope which is the typical JJWT default).  That is:\n\n**Maven**\n\n```xml\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt-jackson</artifactId>\n    <version>0.10.7</version>\n    <scope>compile</scope> <!-- Not runtime -->\n</dependency>\n```\n\n**Gradle or Android**\n\n```groovy\ndependencies {\n    compile \'io.jsonwebtoken:jjwt-jackson:0.10.7\'\n}\n```\n\nAnd then you can specify the `JacksonSerializer` using your own `ObjectMapper` on the `JwtBuilder`:\n\n```java\nObjectMapper objectMapper = getMyObjectMapper(); //implement me\n\nString jws = Jwts.builder()\n\n    .serializeToJsonWith(new JacksonSerializer(objectMapper))\n    \n    // ... etc ...\n```\n\nand the `JacksonDeserializer` using your `ObjectMapper` on the `JwtParser`:\n\n```java\nObjectMapper objectMapper = getMyObjectMapper(); //implement me\n\nJwts.parser()\n\n    .deserializeJsonWith(new JacksonDeserializer(objectMapper))\n    \n    // ... etc ...\n```\n\n<a name="base64"></a>\n## Base64 Support\n\nJJWT uses a very fast pure-Java [Base64](https://tools.ietf.org/html/rfc4648) codec for Base64 and \nBase64Url encoding and decoding that is guaranteed to work deterministically in all JDK and Android environments.\n\nYou can access JJWT\'s encoders and decoders using the `io.jsonwebtoken.io.Encoders` and `io.jsonwebtoken.io.Decoders` \nutility classes.\n\n`io.jsonwebtoken.io.Encoders`:\n\n* `BASE64` is an RFC 4648 [Base64](https://tools.ietf.org/html/rfc4648#section-4) encoder\n* `BASE64URL` is an RFC 4648 [Base64URL](https://tools.ietf.org/html/rfc4648#section-5) encoder\n\n`io.jsonwebtoken.io.Decoders`:\n\n* `BASE64` is an RFC 4648 [Base64](https://tools.ietf.org/html/rfc4648#section-4) decoder\n* `BASE64URL` is an RFC 4648 [Base64URL](https://tools.ietf.org/html/rfc4648#section-5) decoder  \n\n<a name="base64-custom"></a>\n### Custom Base64\n\nIf for some reason you want to specify your own Base64Url encoder and decoder, you can use the `JwtBuilder`\n`base64UrlEncodeWith` method to set the encoder:\n\n```java\nEncoder<byte[], String> base64UrlEncoder = getMyBase64UrlEncoder(); //implement me\n\nString jws = Jwts.builder()\n\n    .base64UrlEncodeWith(base64UrlEncoder)\n    \n    // ... etc ...\n```\n\nand the `JwtParser`\'s `base64UrlDecodeWith` method to set the decoder:\n\n```java\nDecoder<String, byte[]> base64UrlDecoder = getMyBase64UrlDecoder(); //implement me\n\nJwts.parser()\n\n    .base64UrlDecodeWith(base64UrlEncoder)\n    \n    // ... etc ...\n```\n\n## Learn More\n\n- [JSON Web Token for Java and Android](https://stormpath.com/blog/jjwt-how-it-works-why/)\n- [How to Create and Verify JWTs in Java](https://stormpath.com/blog/jwt-java-create-verify/)\n- [Where to Store Your JWTs - Cookies vs HTML5 Web Storage](https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage/)\n- [Use JWT the Right Way!](https://stormpath.com/blog/jwt-the-right-way/)\n- [Token Authentication for Java Applications](https://stormpath.com/blog/token-auth-for-java/)\n- [JJWT Changelog](CHANGELOG.md)\n\n## Author\n\nMaintained by Les Hazlewood &amp; [Okta](https://okta.com/)\n\n<a name="license"></a>\n## License\n\nThis project is open-source via the [Apache 2.0 License](http://www.apache.org/licenses/LICENSE-2.0).\n'