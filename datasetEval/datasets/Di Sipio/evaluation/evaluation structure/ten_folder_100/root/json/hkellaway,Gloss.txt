b'![Gloss](http://hkellaway.github.io/Gloss/images/gloss_logo_tagline.png)\n\n## Features :sparkles:  \n[![CocoaPods](https://img.shields.io/cocoapods/v/Gloss.svg)](http://cocoapods.org/pods/Gloss) \n[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg)](https://github.com/Carthage/Carthage) \n[![SPM](https://img.shields.io/badge/SPM-compatible-brightgreen.svg)](https://github.com/apple/swift-package-manager)\n[![License](https://img.shields.io/cocoapods/l/Gloss.svg)](https://raw.githubusercontent.com/hkellaway/Gloss/master/LICENSE) \n[![CocoaPods](https://img.shields.io/cocoapods/p/Gloss.svg)](http://cocoapods.org/pods/Gloss)\n[![Build Status](https://travis-ci.org/hkellaway/Gloss.svg?branch=develop)](https://travis-ci.org/hkellaway/Gloss)\n\n* Mapping JSON to objects\n* Mapping objects to JSON\n* Nested objects\n* Custom transformations\n\n## Getting Started\n\nThe Gloss source currently available via CocoaPods, Carthage and Swift Package Manager. Example projects are included in this repository of integration (via CocoaPods and SPM) and sample implementation.\n\n### Swift Version\n\nGloss is compatible with Swift 5.0.\n\nTo use a version compatible with Swift 4.2, use version 2.1.x.\n\n### Installation with CocoaPods\n\n```ruby\npod \'Gloss\', \'~> 3.1\'\n```\n\n### Installation with Carthage\n\n```\ngithub "hkellaway/Gloss"\n```\n\n### Installation with Swift Package Manager\n\nSee [Adding Package Dependencies to Your App](https://developer.apple.com/documentation/xcode/adding_package_dependencies_to_your_app). Search for `Gloss` with *Owner* `hkellaway`. Point to the desired version or the `master` branch.\n\n## Usage\n\n### Deserialization\n\n#### A Simple Model\n\nLet\'s imagine we have a simple model represented by the following JSON:\n\n``` JSON\n{\n  "id" : 5456481,\n  "login" : "hkellaway"\n}\n```\n\nOur Gloss model would look as such:\n\n``` swift\nimport Gloss\n\nstruct RepoOwner: JSONDecodable {\n\n    let ownerId: Int?\n    let username: String?\n\n    // MARK: - Deserialization\n\n    init?(json: JSON) {\n        self.ownerId = "id" <~~ json\n        self.username = "login" <~~ json\n    }\n\n}\n```\n\nThis model:\n\n* Imports `Gloss`\n* Adopts the `JSONDecodable` protocol\n* Implements the `init?(json:)` initializer\n\n(Note: If using custom operators like `<~~` is not desired, see [On Not Using Gloss Operators](#on-not-using-gloss-operators).)\n\n#### A Simple Model with Non-Optional Properties\n\nThe prior example depicted the model with only Optional properties - i.e. all properties end with a `?`. If you are certain that the JSON being used to create your models will always have the values for your properties, you can represent those properties as non-Optional.\n\nNon-Optional properties require additional use of the `guard` statement within `init?(json:)` to make sure the values are available at runtime. If values are unavailable, `nil` should be returned.\n\nLet\'s imagine we know that the value for our `RepoOwner` property `ownerId` will always be available:\n\n``` swift\nimport Gloss\n\nstruct RepoOwner: JSONDecodable {\n\n    let ownerId: Int\n    let username: String?\n\n    // MARK: - Deserialization\n\n    init?(json: JSON) {\n        guard let ownerId: Int = "id" <~~ json else { \n            return nil \n        }\n\n        self.ownerId = ownerId\n        self.username = "login" <~~ json\n    }\n}\n\n```\n\nThis model has changed in two ways:\n\n* The `ownerId` property is no longer an Optional\n* The `init?(json:)` initializer now has a `guard` statement checking only non-Optional property(s)\n\n#### A More Complex Model\n\nLet\'s imagine we had a more complex model represented by the following JSON:\n\n``` JSON\n{\n\t"id" : 40102424,\n\t"name": "Gloss",\n\t"description" : "A shiny JSON parsing library in Swift",\n\t"html_url" : "https://github.com/hkellaway/Gloss",\n\t"owner" : {\n\t\t"id" : 5456481,\n\t\t"login" : "hkellaway"\n\t},\n\t"language" : "Swift"\n}\n```\n\nThis model is more complex for a couple reasons:\n\n* Its properties are not just simple types\n* It has a nested model, `owner`\n\nOur Gloss model would look as such:\n\n``` swift\nimport Gloss\n\nstruct Repo: JSONDecodable {\n\n    let repoId: Int?\n    let name: String?\n    let desc: String?\n    let url: NSURL?\n    let owner: RepoOwner?\n    let primaryLanguage: Language?\n\n    enum Language: String {\n        case Swift = "Swift"\n        case ObjectiveC = "Objective-C"\n    }\n\n    // MARK: - Deserialization\n\n    init?(json: JSON) {\n        self.repoId = "id" <~~ json\n        self.name = "name" <~~ json\n        self.desc = "description" <~~ json\n        self.url = "html_url" <~~ json\n        self.owner = "owner" <~~ json\n        self.primaryLanguage = "language" <~~ json\n    }\n\n}\n```\n\nDespite being more complex, this model is just as simple to compose - common types such as an `NSURL`, an `enum` value, and another Gloss model, `RepoOwner`, are handled without extra overhead! :tada:\n\n-(Note: If nested models are present in JSON but not desired in your Gloss models, see [Retrieving Nested Model Values without Creating Extra Models](#retrieving-nested-model-values-without-creating-extra-models).)\n\n### Serialization\n\nNext, how would we allow models to be translated _to_ JSON? Let\'s take a look again at the `RepoOwner` model:\n\n``` swift\nimport Gloss\n\nstruct RepoOwner: Glossy {\n\n    let ownerId: Int?\n    let username: String?\n\n    // MARK: - Deserialization\n    // ...\n\n    // MARK: - Serialization\n\n    func toJSON() -> JSON? {\n        return jsonify([\n            "id" ~~> self.ownerId,\n            "login" ~~> self.username\n        ])\n    }\n\n}\n```\n\nThis model now:\n\n* Adopts the `Glossy` protocol\n* Implements `toJSON()` which calls the `jsonify(_:)` function\n\n(Note: If using custom operators like `~~>` is not desired, see [On Not Using Gloss Operators](#on-not-using-gloss-operators).)\n\n\n### Initializing Model Objects and Arrays\n\nInstances of `JSONDecodable` Gloss models are made by calling `init?(json:)`.\n\nFor example, we can create a `RepoOwner` as follows:\n\n``` swift\nlet repoOwnerJSON = [\n        "id" : 5456481,\n        "name": "hkellaway"\n]\n\nguard let repoOwner = RepoOwner(json: repoOwnerJSON) else { \n    // handle decoding failure here\n}\n\nprint(repoOwner.repoId)\nprint(repoOwner.name)\n```\n\nOr, using `if let` syntax: \n\n``` swift\nif let repoOwner = RepoOwner(json: repoOwnerJSON) {\n    print(repoOwner.repoId)\n    print(repoOwner.name)\n}\n\n```\n\n#### Model Objects from JSON Arrays\n\nGloss also supports creating models from JSON arrays. The `from(jsonArray:)` function can be called on a Gloss model array type to produce an array of objects of that type from a JSON array passed in.\n\nFor example, let\'s consider the following array of JSON representing repo owners:\n\n``` swift\nlet repoOwnersJSON = [\n    [\n        "id" : 5456481,\n        "name": "hkellaway"\n    ],\n    [\n        "id" : 1234567,\n        "name": "user2"\n    ]\n]\n```\nAn array of `RepoOwner` objects could be obtained via the following:\n\n``` swift\nguard let repoOwners = [RepoOwner].from(jsonArray: repoOwnersJSON) else {\n    // handle decoding failure here\n}\n\nprint(repoOwners)\n```\n\n#### Model Objects from Data\n\nModel objects can also be initialized directly from `Data` for convenience:\n\n``` swift\nlet repoOwner: RepoOwner? = RepoOwner(data: repoOwnerData)\n```\n\n``` swift\nlet repoOwners: [RepoOwner]? = [RepoOwner].from(data: repoOwnerDAta)\n```\n\n### Translating Model Objects to JSON\n\nThe JSON representation of an `JSONEncodable` Gloss model is retrieved via `toJSON()`:\n\n``` swift\nrepoOwner.toJSON()\n\n```\n#### JSON Arrays from Model Objects\n\nAn array of JSON from an array of `JSONEncodable` models is retrieved via `toJSONArray()`:\n\n``` swift\nguard let jsonArray = repoOwners.toJSONArray() else {\n    // handle encoding failure here\n}\n\nprint(jsonArray)\n```\n\n### Retrieving Nested Model Values without Creating Extra Models\n\nWe saw in earlier examples that `Repo` has a nested model `RepoOwner` - and that nested Gloss models are handled automatically. But what if the nested models represented in our JSON really don\'t need to be their own models? \n\nGloss provides a way to indicate nested model values with simple `.` syntax - let\'s revisit the `owner` values for `Repo` and see what changes:\n\n``` swift\nimport Gloss\n\nstruct Repo: Glossy {\n\n    let ownerId: Int?\n    let ownerUsername: String?\n\n    // MARK: - Deserialization\n\n    init?(json: JSON) {\n        self.ownerId = "owner.id" <~~ json\n        self.ownerUsername = "owner.login" <~~ json\n    }\n\n    // MARK: - Serialization\n\n        func toJSON() -> JSON? {\n        return jsonify([\n            "owner.id" ~~> self.ownerId,\n            "owner.login" ~~> self.ownerUsername\n            ])\n\n}\n\n```\n\nNow, instead of declaring a nested model `owner` of type `RepoOwner` with its own `id` and `username` properties, the desired values from `owner` are retrieved by specifying the key names in a string delimited by periods (i.e. `owner.id` and `owner.login`).\n\n## Additonal Topics\n\n### Gloss Transformations\n\nGloss comes with a number of transformations built in for convenience (See: [Gloss Operators](#gloss-operators)).\n\n#### Date Transformations\n\n`NSDate`s require an additional `dateFormatter` parameter, and thus cannot be retrieved via binary operators (`<~~` and `~~>`).\n\nTranslating from and to JSON is handled via:\n\n`Decoder.decode(dateForKey:, dateFormatter:)` and `Decode.decode(dateArrayFromKey:, dateFormatter:)` where `key` is the JSON key and `dateFormatter` is the `DateFormatter` used to translate the date(s). e.g. `self.date = Decoder.decode(dateForKey: "dateKey", dateFormatter: myDateFormatter)(json)`\n\n`Encoder.encode(dateForKey:, dateFormatter:)` and `Encode.encode(dateForKey:, dateFormatter:)` where `key` is the JSON key and `dateFormatter` is the `DateFormatter` used to translate the date(s). e.g. `Encoder.encode(dateForKey: "dateKey", dateFormatter: myDateFormatter)(self.date)`\n\n#### Custom Transformations\n\n##### From JSON\n\nYou can write your own functions to enact custom transformations during model creation.\n\nLet\'s imagine the `username` property on our `RepoOwner` model was to be an uppercase string. We could update as follows:\n\n``` swift\nimport Gloss\n\nstruct RepoOwner: JSONDecodable {\n\n    let ownerId: Int?\n    let username: String?\n\n    // MARK: - Deserialization\n\n    init?(json: JSON) {\n        self.ownerId = "id" <~~ json\n        self.username = Decoder.decodeStringUppercase(key: "login", json: json)\n    }\n\n}\n\nextension Decoder {\n\n    static func decodeStringUppercase(key: String, json: JSON) -> String? {\n            \n        if let string = json.valueForKeypath(key) as? String {\n            return string.uppercaseString\n        }\n\n        return nil\n    }\n\n}\n```\n\nWe\'ve created an extension on `Decoder` and written our own decode function, `decodeStringUppercase`.\n\nWhat\'s important to note is that the return type for `decodeStringUppercase` is the desired type -- in this case, `String?`. The value you\'re working with will be accessible via `json.valueForKeypath(_:)` and will need to be cast to the desired type using `as?`. Then, manipulation can be done - for example, uppercasing. The transformed value should be returned; in the case that the cast failed, `nil` should be returned.\n\nThough depicted here as being in the same file,  the `Decoder` extension is not required to be. Additionally, representing the custom decoding function as a member of `Decoder` is not required, but simply stays true to the semantics of Gloss.\n\n##### To JSON\n\nYou can also write your own functions to enact custom transformations during JSON translation.\n\nLet\'s imagine the `username` property on our `RepoOwner` model was to be a lowercase string. We could update as follows:\n\n``` swift\nimport Gloss\n\nstruct RepoOwner: Glossy {\n\n    let ownerId: Int?\n    let username: String?\n\n    // MARK: - Deserialization\n    // ...\n\n   // MARK: - Serialization\n\n    func toJSON() -> JSON? {\n        return jsonify([\n            "id" ~~> self.ownerId,\n            Encoder.encodeStringLowercase(key: "login", value: self.username)\n        ])\n    }\n\n\n}\n\nextension Encoder {\n\n    static func encodeStringLowercase(key: String, value: String?) -> JSON? {\n            \n        if let value = value {\n            return [key : value.lowercaseString]\n        }\n\n        return nil\n    }\n\n}\n```\n\nWe\'ve created an extension on `Encoder` and written our own encode function, `encodeStringLowercase`.\n\nWhat\'s important to note is that `encodeStringLowercase` takes in a `value` whose type is what it\'s translating from (`String?`) and returns `JSON?`. The value you\'re working with will be accessible via the `if let` statement. Then, manipulation can be done - for example, lowercasing. What should be returned is a dictionary with `key` as the key and the manipulated value as its value. In the case that the `if let` failed, `nil` should be returned.\n\nThough depicted here as being in the same file, the `Encoder` extension is not required to be. Additionally, representing the custom encoding function as a member of `Encoder` is not required, but simply stays true to the semantics of Gloss.\n\n### Gloss Operators\n\n#### On Not Using Gloss Operators\n\nGloss offers custom operators as a way to make your models less visually cluttered. However, some choose not to use custom operators for good reason - custom operators do not always clearly communicate what they are doing (See [this discussion](http://programmers.stackexchange.com/questions/180948/why-arent-user-defined-operators-more-common)).\n\nIf you wish to not use the `<~~` or `~~>` operators, their `Decoder.decode` and `Encoder.encode` complements can be used instead.\n\nFor example,\n\n`self.url = "html_url" <~~ json` would become `self.url = Decoder.decodeURL("html_url")(json)`\n\nand\n\n`"html_url" ~~> self.url` would become `Encoder.encodeURL("html_url")(self.url)`\n\n#### On Using Gloss Operators\n\n##### The Decode Operator: `<~~`\n\nThe `<~~` operator is simply syntactic sugar for a set of `Decoder.decode` functions:\n\n* Simple types (`Decoder.decode(key:)`)\n* `JSONDecodable` models (`Decoder.decode(decodableForKey:)`)\n* Simple arrays (`Decoder.decode(key:)`)\n* Arrays of `JSONDecodable` models (`Decoder.decode(decodableArrayForKey:)`)\n* Dictionaries of `JSONDecodable` models (`Decoder.decode(decodableDictionaryForKey:)`)\n* Enum types (`Decoder.decode(enumForKey:)`)\n* Enum arrays (`Decoder.decode(enumArrayForKey:)`)\n* Int32 types (`Decoder.decode(int32ForKey:)`)\n* Int32 arrays (`Decoder.decode(int32ArrayForKey:)`)\n* UInt32 types (`Decoder.decode(uint32ForKey:)`)\n* UInt32 arrays (`Decoder.decode(uint32ArrayForKey:)`)\n* Int64 types (`Decoder.decode(int64ForKey:)`)\n* Int64 array (`Decoder.decode(int64ArrayForKey:)`)\n* UInt64 types (`Decoder.decode(uint64ForKey:)`)\n* UInt64 array (`Decoder.decode(uint64ArrayForKey:)`)\n* Double types (`Decoder.decode(doubleForKey:)`)\n* Double array (`Decoder.decode(doubleArrayForKey:)`)\n* NSURL types (`Decoder.decode(urlForKey:)`)\n* NSURL arrays (`Decode.decode(urlArrayForKey:)`)\n* UUID types (`Decoder.decode(uuidForKey:)`)\n* UUID arrays (`Decoder.decode(uuidArrayForKey:)`)\n* Decimal types `(Decoder.decode(dedimalForKey:)`)\n* Decimal arrays (`Decoder.decode(decimalArrayForKey:)`)\n\n##### The Encode Operator: `~~>`\n\nThe `~~>` operator is simply syntactic sugar for a set of `Encoder.encode` functions:\n\n* Simple types (`Encoder.encode(key:)`)\n* `JSONEncodable` models (`Encoder.encode(encodableForKey:)`)\n* Simple arrays (`Encoder.encode(arrayForKey:)`)\n* Arrays of `JSONEncodable` models (`Encoder.encode(encodableArrayForKey:)`)\n* Dictionaries of `JSONEncodable` models (`Encoder.encode(encodableDictionaryForKey:)`)\n* Enum types (`Encoder.encode(enumForKey:)`)\n* Enum arrays (`Encoder.encode(enumArrayForKey:)`)\n* Int32 types (`Encoder.encode(int32ForKey:)`)\n* Int32 arrays (`Encoder.encode(int32ArrayForKey:)`)\n* UInt32 types (`Encoder.encode(uint32ForKey:)`)\n* UInt32 arrays (`Encoder.encode(uint32ArrayForKey:)`)\n* Int64 types (`Encoder.encode(int64ForKey:)`)\n* Int64 arrays (`Encoder.encode(int64ArrayForKey:)`)\n* UInt64 types (`Encoder.encode(uint64ForKey:)`)\n* UInt64 arrays (`Encoder.encode(uint64ArrayForKey:)`)\n* Double types (`Encoder.encode(doubleForKey:)`)\n* Double arrays (`Encoder.encode(doubleArrayForKey:)`)\n* NSURL types (`Encoder.encode(urlForKey:)`)\n* UUID types (`Encoder.encode(uuidForKey:)`)\n* Decimal types (`Encoder.encode(decimalForKey:)`)\n* Decimal array (`Encoder.encode(decimalArrayForKey:)`)\n\n### Gloss Protocols\n\nModels that are to be created from JSON _must_ adopt the `JSONDecodable` protocol.\n\nModels that are to be transformed to JSON _must_ adopt the `JSONEncodable` protocol.\n\nThe `Glossy` protocol depicted in the examples is simply a convenience for defining models that can translated to _and_ from JSON. `Glossy` can be replaced by `JSONDecodable, JSONEncodable` for more preciseness, if desired.\n\n## Why "Gloss"?\n\nThe name for Gloss was inspired by the name for a popular Objective-C library, [Mantle](https://github.com/Mantle/Mantle) - both names are a play on the word "layer", in reference to their role in supporting the model layer of the application.\n\nThe particular word "gloss" was chosen as it evokes both being lightweight and adding beauty.\n\n## Credits\n\nGloss was created by [Harlan Kellaway](http://harlankellaway.com).\n\nInspiration was gathered from other great JSON parsing libraries like [Argo](https://github.com/thoughtbot/Argo). Read more about why Gloss was made [here](http://harlankellaway.com/blog/2015/08/16/introducing-gloss-json-parsing-swift).\n\nSpecial thanks to all [contributors](https://github.com/hkellaway/Gloss/contributors)! :sparkling_heart:\n\n### Featured\n\nCheck out Gloss in these cool places!\n\n#### Posts\n\n* [Ray Wenderlich | Swift Tutorial: Working with JSON](http://www.raywenderlich.com/120442/swift-json-tutorial)\n\n#### Libraries\n\n* [Alamofire-Gloss](https://github.com/spxrogers/Alamofire-Gloss)\n* [Moya-Gloss](https://github.com/spxrogers/Moya-Gloss)\n* [Restofire-Gloss](https://github.com/Restofire/Restofire-Gloss)\n\n#### Newsletters\n\n* [The iOS Times](http://theiostimes.com/year-01-issue-12.html)\n* [Swift Sandbox](http://swiftsandbox.io/issues/3#b1RJwo2)\n* [iOS Goodies](http://ios-goodies.com/post/127166753231/week-93)\n\n## License\n\nGloss is available under the MIT license. See the [LICENSE](https://raw.githubusercontent.com/hkellaway/Gloss/master/LICENSE) file for more info.\n'