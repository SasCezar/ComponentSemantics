b'# MoreLINQ\n\nLINQ to Objects is missing a few desirable features.\n\nThis project enhances LINQ to Objects with extra methods, in a manner which\nkeeps to the spirit of LINQ.\n\nMoreLINQ is available for download and installation as\n[NuGet packages](https://www.nuget.org/packages/morelinq/).\n\nDocumentation for the stable and beta releases can be found at\n[morelinq.github.io](http://morelinq.github.io/).\n\n\n## Usage\n\nMoreLINQ can be used in one of two ways. The simplest is to just import the\n`MoreLinq` namespace and all extension methods become instantly available for\nyou to use on the types they extend (typically some instantiation of\n`IEnumerable<T>`). In some very rare instances, however, doing so can cause\nconflicts with other libraries you may be using that incidentally also extend\nthe same type with an identically named method and signature. This happened\nwith MoreLINQ, for example, when Microsoft .NET Framework 4.0 introduced\n[`Zip`][netzip] and [MoreLINQ already had one][zip]. Starting with version 3.0\nof MoreLINQ, you can reduce the potential for present (or even future)\nconflicts by individually importing just the extension methods you need using\nthe [static imports feature introduced in C# 6][using-static]:\n\n```c#\nusing static MoreLinq.Extensions.LagExtension;\nusing static MoreLinq.Extensions.LeadExtension;\n```\n\nIn the example above, only the [`Lag`][lag] and [`Lead`][lead] extension\nmethods will be available in scope.\n\nApart from extension methods, MoreLINQ also offers regular static method\nthat *generate* (instead of operating on) sequences, like `Unfold`,\n`Random`, `Sequence` and others. If you want to use these while statically\nimporting other individual extension methods, you can do so via aliasing:\n\n```c#\nusing static MoreLinq.Extensions.LagExtension;\nusing static MoreLinq.Extensions.LeadExtension;\nusing MoreEnumerable = MoreLinq.MoreEnumerable;\n```\n\nIn the example above, [`Lag`][lag] and [`Lead`][lead] will be available as\nextension methods as well as all the regular static methods on\n`MoreEnumerable` but _without_ any of the extension methods offered by\n`MoreEnumerable`.\n\n\n[lag]: https://morelinq.github.io/2.0/ref/api/html/Overload_MoreLinq_MoreEnumerable_Lag.htm\n[lead]: https://morelinq.github.io/2.0/ref/api/html/Overload_MoreLinq_MoreEnumerable_Lead.htm\n[using-static]: https://docs.microsoft.com/en-us/dotnet/articles/csharp/whats-new/csharp-6#using-static\n[netzip]: https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.zip--3\n[zip]: https://morelinq.github.io/1.x/ref/api/html/M_MoreLinq_MoreEnumerable_Zip__3.htm\n[unfold]: https://morelinq.github.io/2.3/ref/api/html/M_MoreLinq_MoreEnumerable_Unfold__3.htm\n[random]: https://morelinq.github.io/2.0/ref/api/html/Overload_MoreLinq_MoreEnumerable_Random.htm\n[sequence]: https://morelinq.github.io/2.2/ref/api/html/Overload_MoreLinq_MoreEnumerable_Sequence.htm\n\n\n## Building\n\nTo build MoreLINQ from sources, you will need:\n\n- [.NET Core 2.0 with SDK 2.1][dotnet-2.0-sdk-2.1]\n- [Mono][mono] 5.0 if building on other platforms than Windows\n\nThen run either `build.cmd` if building on Windows or `build.sh` if\nbuilding on macOS or a Linux distribution supported by .NET Core.\n\nSome code in the project is generated using [T4][t4] templates. To regenerate\nthe code from modified templates, run `MoreLinq\\tt.cmd` (Windows) or\n`MoreLinq/tt.sh` depending on your platform.\n\nBuilding the documentation is supported on Windows only and requires\n[Sandcastle Help File Builder (SHFB)][shfb]. Executing `builddocs.cmd`\ngenerates the documentation in the `docs/api` directory. It can be browsed\nlocally using any HTTP server of static files, like\n[http-server][http-server].\n\n\n[mono]: https://www.mono-project.com/\n[dotnet-2.0-sdk-2.1]: https://github.com/dotnet/core/blob/master/release-notes/download-archives/2.1.2-sdk-download.md\n[shfb]: https://github.com/EWSoftware/SHFB/releases/tag/v2017.12.30.2\n[http-server]: https://www.npmjs.com/package/http-server\n[t4]: https://docs.microsoft.com/en-us/visualstudio/modeling/code-generation-and-t4-text-templates\n\n\n## Operators\n\n### Acquire\n\nEnsures that a source sequence of disposable objects are all acquired\nsuccessfully. If the acquisition of any one fails then those successfully\nacquired till that point are disposed.\n\n### Aggregate\n\nApplies multiple accumulators sequentially in a single pass over a sequence.\n\nThis method has 7 overloads.\n\n### AggregateRight\n\nApplies a right-associative accumulator function over a sequence.\nThis operator is the right-associative version of the Aggregate LINQ operator.\n\nThis method has 3 overloads.\n\n### Append\n\nReturns a sequence consisting of the head element and the given tail elements.\n\n### Assert\n\nAsserts that all elements of a sequence meet a given condition otherwise\nthrows an exception.\n\nThis method has 2 overloads.\n\n### AssertCount\n\nAsserts that a source sequence contains a given count of elements.\n\nThis method has 2 overloads.\n\n### AtLeast\n\nDetermines whether or not the number of elements in the sequence is greater\nthan or equal to the given integer.\n\n### AtMost\n\nDetermines whether or not the number of elements in the sequence is lesser\nthan or equal to the given integer.\n\n### Backsert\n\nInserts the elements of a sequence into another sequence at a\nspecified index from the tail of the sequence, where zero always represents\nthe last position, one represents the second-last element, two represents\nthe third-last element and so on.\n\n### Batch\n\nBatches the source sequence into sized buckets.\n\nThis method has 2 overloads.\n\n### Cartesian\n\nReturns the Cartesian product of two or more sequences by combining each\nelement from the sequences and applying a user-defined projection to the\nset.\n\nThis method has 7 overloads.\n\n### Choose\n\nApplies a function to each element of the source sequence and returns a new\nsequence of result elements for source elements where the function returns a\ncouple (2-tuple) having a `true` as its first element and result as the\nsecond.\n\n### CompareCount\n\nCompares two sequences and returns an integer that indicates whether the\nfirst sequence has fewer, the same or more elements than the second sequence.\n\n### ~~Concat~~\n\nReturns a sequence consisting of the head element and the given tail elements.\n\nThis method is obsolete and will be removed in a future version. Use `Append`\ninstead.\n\n### Consume\n\nCompletely consumes the given sequence. This method uses immediate execution,\nand doesn\'t store any data during execution\n\n### CountBetween\n\nDetermines whether or not the number of elements in the sequence is between an\ninclusive range of minimum and maximum integers.\n\n### CountBy\n\nApplies a key-generating function to each element of a sequence and returns a\nsequence of unique keys and their number of occurrences in the original\nsequence.\n\nThis method has 2 overloads.\n\n### CountDown\n\nProvides a countdown counter for a given count of elements at the tail of the\nsequence where zero always represents the last element, one represents the\nsecond-last element, two represents the third-last element and so on.\n\n### DistinctBy\n\nReturns all distinct elements of the given source, where "distinctness" is\ndetermined via a projection and the default equality comparer for the\nprojected type.\n\nThis method has 2 overloads.\n\n### EndsWith\n\nDetermines whether the end of the first sequence is equivalent to the second\nsequence.\n\nThis method has 2 overloads.\n\n### EquiZip\n\nReturns a projection of tuples, where each tuple contains the N-th\nelement from each of the argument sequences. An exception is thrown\nif the input sequences are of different lengths.\n\nThis method has 3 overloads.\n\n### Exactly\n\nDetermines whether or not the number of elements in the sequence is equals\nto the given integer.\n\n### ExceptBy\n\nReturns the set of elements in the first sequence which aren\'t in the second\nsequence, according to a given key selector.\n\nThis method has 2 overloads.\n\n### Exclude\n\nExcludes elements from a sequence starting at a given index\n\n### FallbackIfEmpty\n\nReturns the elements of a sequence and falls back to another if the original\nsequence is empty.\n\nThis method has 6 overloads.\n\n### FillBackward\n\nReturns a sequence with each null reference or value in the source replaced\nwith the following non-null reference or value in that sequence.\n\nThis method has 3 overloads.\n\n### FillForward\n\nReturns a sequence with each null reference or value in the source replaced\nwith the previous non-null reference or value seen in that sequence.\n\nThis method has 3 overloads.\n\n### Flatten\n\nFlattens a sequence containing arbitrarily-nested sequences.\n\nThis method has 3 overloads.\n\n### Fold\n\nReturns the result of applying a function to a sequence with 1 to 16 elements.\n\nThis method has 16 overloads.\n\n### ForEach\n\nImmediately executes the given action on each element in the source sequence.\n\nThis method has 2 overloads.\n\n### From\n\nReturns a sequence containing the values resulting from invoking (in order)\neach function in the source sequence of functions.\n\nThis method has 4 overloads.\n\n### FullGroupJoin\n\nPerforms a Full Group Join between the and sequences.\n\nThis method has 4 overloads.\n\n### FullJoin\n\nPerforms a full outer join between two sequences.\n\nThis method has 4 overloads.\n\n### Generate\n\nReturns a sequence of values consecutively generated by a generator function\n\n### GenerateByIndex\n\nReturns a sequence of values based on indexes\n\n### GroupAdjacent\n\nGroups the adjacent elements of a sequence according to a specified key\nselector function.\n\nThis method has 6 overloads.\n\n### ~~Incremental~~\n\n`Incremental` was redundant with `Pairwise` and so deprecated since version\n[2.1][v2.1]. It was eventually removed in version [3.0][v3.0].\n\n### Index\n\nReturns a sequence of where the key is the zero-based index of the value in\nthe source sequence.\n\nThis method has 2 overloads.\n\n### IndexBy\n\n\nApplies a key-generating function to each element of a sequence and returns\na sequence that contains the elements of the original sequence as well its\nkey and index inside the group of its key. An additional argument specifies\na comparer to use for testing equivalence of keys.\n\nThis method has 2 overloads.\n\n### Insert\n\nInserts the elements of a sequence into another sequence at a specified index.\n\n### Interleave\n\nInterleaves the elements of two or more sequences into a single sequence,\nskipping sequences as they are consumed.\n\n### Lag\n\nProduces a projection of a sequence by evaluating pairs of elements separated\nby a negative offset.\n\nThis method has 2 overloads.\n\n### Lead\n\nProduces a projection of a sequence by evaluating pairs of elements separated\nby a positive offset.\n\nThis method has 2 overloads.\n\n### LeftJoin\n\nPerforms a left outer join between two sequences.\n\nThis method has 4 overloads.\n\n### MaxBy\n\nReturns the maxima (maximal elements) of the given sequence, based on the\ngiven projection.\n\nThis method has 2 overloads.\n\n### MinBy\n\nReturns the minima (minimal elements) of the given sequence, based on the\ngiven projection.\n\nThis method has 2 overloads.\n\n### Move\n\nReturns a sequence with a range of elements in the source sequence\nmoved to a new offset.\n\n### OrderBy\n\nSorts the elements of a sequence in a particular direction (ascending,\ndescending) according to a key.\n\nThis method has 2 overloads.\n\n### OrderedMerge\n\nMerges two ordered sequences into one. Where the elements equal in both\nsequences, the element from the first sequence is returned in the resulting\nsequence.\n\nThis method has 7 overloads.\n\n### Pad\n\nPads a sequence with default values if it is narrower (shorter in length) than\na given width.\n\nThis method has 3 overloads.\n\n### PadStart\n\nPads a sequence with default values in the beginning if it is narrower\n(shorter in length) than a given width.\n\nThis method has 3 overloads.\n\n### Pairwise\n\nReturns a sequence resulting from applying a function to each element in the\nsource sequence and its predecessor, with the exception of the first element\nwhich is only returned as the predecessor of the second element\n\n### PartialSort\n\nCombines `OrderBy` (where element is key) and `Take` in a single operation.\n\nThis method has 4 overloads.\n\n### PartialSortBy\n\nCombines `OrderBy` and `Take` in a single operation.\n\nThis method has 4 overloads.\n\n### Partition\n\nPartitions a sequence by a predicate, or a grouping by Boolean keys or up to 3\nsets of keys.\n\nThis method has 10 overloads.\n\n### Permutations\n\nGenerates a sequence of lists that represent the permutations of the original\nsequence\n\n### Pipe\n\nExecutes the given action on each element in the source sequence and yields it\n\n### Prepend\n\nPrepends a single value to a sequence\n\n### PreScan\n\nPerforms a pre-scan (exclusive prefix sum) on a sequence of elements\n\n### Random\n\nReturns an infinite sequence of random integers using the standard .NET random\nnumber generator.\n\nThis method has 6 overloads.\n\n### RandomDouble\n\nReturns an infinite sequence of random double values between 0.0 and 1.0.\n\nThis method has 2 overloads.\n\n### RandomSubset\n\nReturns a sequence of a specified size of random elements from the original\nsequence.\n\nThis method has 2 overloads.\n\n### Rank\n\nRanks each item in the sequence in descending ordering using a default\ncomparer.\n\nThis method has 2 overloads.\n\n### RankBy\n\nRanks each item in the sequence in descending ordering by a specified key\nusing a default comparer.\n\nThis method has 2 overloads.\n\n### Repeat\n\nRepeats the sequence indefinitely or a specific number of times.\n\nThis method has 2 overloads.\n\n### Return\n\nReturns a single-element sequence containing the item provided.\n\n### RightJoin\n\nPerforms a right outer join between two sequences.\n\nThis method has 4 overloads.\n\n### RunLengthEncode\n\nRun-length encodes a sequence by converting consecutive instances of the same\nelement into a `KeyValuePair<T, int>` representing the item and its occurrence\ncount.\n\nThis method has 2 overloads.\n\n### Scan\n\nPeforms a scan (inclusive prefix sum) on a sequence of elements.\n\nThis method has 2 overloads.\n\n### ScanBy\n\nApplies an accumulator function over sequence element keys, returning the keys\nalong with intermediate accumulator states.\n\nThis method has 2 overloads.\n\n### ScanRight\n\nPeforms a right-associative scan (inclusive prefix) on a sequence of elements.\nThis operator is the right-associative version of the Scan operator.\n\nThis method has 2 overloads.\n\n### Segment\n\nDivides a sequence into multiple sequences by using a segment detector based\non the original sequence.\n\nThis method has 3 overloads.\n\n### Sequence\n\nGenerates a sequence of integral numbers within the (inclusive) specified range.\n\nThis method has 2 overloads.\n\n### Shuffle\n\nReturns a sequence of elements in random order from the original sequence.\n\nThis method has 2 overloads.\n\n### SkipLast\n\nBypasses a specified number of elements at the end of the sequence.\n\n### SkipUntil\n\nSkips items from the input sequence until the given predicate returns true\nwhen applied to the current source item; that item will be the last skipped\n\n### Slice\n\nExtracts elements from a sequence at a particular zero-based starting index\n\n### SortedMerge\n\nMerges two or more sequences that are in a common order (either ascending or\ndescending) into a single sequence that preserves that order.\n\nThis method has 2 overloads.\n\n### Split\n\nSplits the source sequence by a separator.\n\nThis method has 12 overloads.\n\n### StartsWith\n\nDetermines whether the beginning of the first sequence is equivalent to the\nsecond sequence.\n\nThis method has 2 overloads.\n\n### Subsets\n\nReturns a sequence of representing all of the subsets of any size that are\npart of the original sequence.\n\nThis method has 2 overloads.\n\n### TagFirstLast\n\nReturns a sequence resulting from applying a function to each element in the\nsource sequence with additional parameters indicating whether the element is\nthe first and/or last of the sequence\n\n### TakeEvery\n\nReturns every N-th element of a source sequence\n\n### TakeLast\n\nReturns a specified number of contiguous elements from the end of a sequence\n\n### TakeUntil\n\nReturns items from the input sequence until the given predicate returns true\nwhen applied to the current source item; that item will be the last returned\n\n### ThenBy\n\nPerforms a subsequent ordering of elements in a sequence in a particular\ndirection (ascending, descending) according to a key.\n\nThis method has 2 overloads.\n\n### ToArrayByIndex\n\nCreates an array from an IEnumerable<T> where a function is used to determine\nthe index at which an element will be placed in the array.\n\nThis method has 6 overloads.\n\n### ToDataTable\n\nAppends elements in the sequence as rows of a given object with a set of\nlambda expressions specifying which members (property or field) of each\nelement in the sequence will supply the column values.\n\nThis method has 4 overloads.\n\n### ToDelimitedString\n\nCreates a delimited string from a sequence of values. The delimiter used\ndepends on the current culture of the executing thread.\n\nThis method has 15 overloads.\n\n### ToDictionary\n\nCreates a [dictionary][dict] from a sequence of [key-value pair][kvp] elements\nor tuples of 2.\n\nThis method has 4 overloads.\n\n### ToHashSet\n\nReturns a [hash-set][hashset] of the source items using the default equality\ncomparer for the type.\n\nThis method has 2 overloads.\n\n### ToLookup\n\nCreates a [lookup][lookup] from a sequence of [key-value pair][kvp] elements\nor tuples of 2.\n\nThis method has 4 overloads.\n\n### Transpose\n\nTransposes the rows of a sequence into columns.\n\n### TraverseBreadthFirst\n\nTraverses a tree in a breadth-first fashion, starting at a root node and using\na user-defined function to get the children at each node of the tree.\n\n### TraverseDepthFirst\n\nTraverses a tree in a depth-first fashion, starting at a root node and using a\nuser-defined function to get the children at each node of the tree.\n\n### Trace\n\nTraces the elements of a source sequence for diagnostics.\n\nThis method has 3 overloads.\n\n### TrySingle\n\nReturns the only element of a sequence that has just one element. If the\nsequence has zero or multiple elements, then returns a user-defined value\nthat indicates the cardinality of the result sequence.\n\nThis method has 2 overloads.\n\n### Unfold\n\nReturns a sequence generated by applying a state to the generator function,\nand from its result, determines if the sequence should have a next element and\nits value, and the next state in the recursive call.\n\n### Window\n\nProcesses a sequence into a series of subsequences representing a windowed\nsubset of the original\n\n### ~~Windowed~~\n\nProcesses a sequence into a series of subsequences representing a windowed\nsubset of the original\n\nThis method is obsolete and will be removed in a future version. Use `Window`\ninstead.\n\n### WindowLeft\n\nCreates a left-aligned sliding window over the source sequence of a given size.\n\n### WindowRight\n\nCreates a right-aligned sliding window over the source sequence of a given size.\n\n### ZipLongest\n\nReturns a projection of tuples, where each tuple contains the N-th\nelement from each of the argument sequences. The resulting sequence\nwill always be as long as the longest of input sequences where the\ndefault value of each of the shorter sequence element types is used\nfor padding.\n\nThis method has 3 overloads.\n\n### ZipShortest\n\nReturns a projection of tuples, where each tuple contains the N-th\nelement from each of the argument sequences. The resulting sequence\nis as short as the shortest input sequence.\n\nThis method has 3 overloads.\n\n\n## Experimental Operators\n\nTHESE METHODS ARE EXPERIMENTAL. THEY MAY BE UNSTABLE AND UNTESTED. THEY MAY BE\nREMOVED FROM A FUTURE MAJOR OR MINOR RELEASE AND POSSIBLY WITHOUT NOTICE. USE\nTHEM AT YOUR OWN RISK. THE METHODS ARE PUBLISHED FOR FIELD EXPERIMENTATION TO\nSOLICIT FEEDBACK ON THEIR UTILITY AND DESIGN/IMPLEMENTATION DEFECTS.\n\nUse of experimental methods requires importing the `MoreLinq.Experimental`\nnamespace.\n\n### Aggregate\n\nApplies multiple accumulator queries sequentially in a single pass over a\nsequence.\n\nThis method has 8 overloads.\n\n### Await\n\nCreates a sequence query that streams the result of each task in the source\nsequence as it completes asynchronously.\n\nThis method has 2 overloads.\n\n### AwaitCompletion\n\nAwaits completion of all asynchronous evaluations irrespective of whether they\nsucceed or fail. An additional argument specifies a function that projects the\nfinal result given the source item and completed task.\n\n### Memoize\n\nCreates a sequence that lazily caches the source as it is iterated for the\nfirst time, reusing the cache thereafter for future re-iterations. If the\nsource is already cached or buffered then it is returned verbatim.\n\n\n[#122]: https://github.com/morelinq/MoreLINQ/issues/122\n[dict]: https://docs.microsoft.com/en-us/dotnet/api/System.Collections.Generic.Dictionary-2\n[hashset]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1\n[kvp]: https://docs.microsoft.com/en-us/dotnet/api/System.Collections.Generic.KeyValuePair-2\n[lookup]: https://docs.microsoft.com/en-us/dotnet/api/system.linq.lookup-2\n[v2.1]: https://github.com/morelinq/MoreLINQ/releases/tag/v2.1.0\n[v3.0]: https://github.com/morelinq/MoreLINQ/releases/tag/v3.0.0\n'