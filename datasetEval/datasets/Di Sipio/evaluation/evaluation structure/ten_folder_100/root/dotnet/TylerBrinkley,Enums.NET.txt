b'![GitHub last commit (master)](https://img.shields.io/github/last-commit/TylerBrinkley/Enums.NET/master.svg?logo=github)\n[![NuGet Version](https://img.shields.io/nuget/v/Enums.NET.svg?logo=nuget)](https://www.nuget.org/packages/Enums.NET/)\n[![NuGet Downloads](https://img.shields.io/nuget/dt/Enums.NET.svg?logo=nuget)](https://www.nuget.org/packages/Enums.NET/)\n[![Build status](https://img.shields.io/azure-devops/build/tydude4christ/Public/2.svg?logo=azuredevops)](https://dev.azure.com/tydude4christ/Public/_build?definitionId=2)\n\n## v3.0 Changes\nOne of the major changes for v3.0 is the deprecation of the `NonGenericEnums`, `NonGenericFlagEnums`, `UnsafeEnums`, and `UnsafeFlagEnums` classes whose methods have been added to the `Enums` and `FlagEnums` classes to better match `System.Enum` and provide better discoverability. To help you migrate your code to using the new methods I have created the C# roslyn analyzer [`Enums.NET.Analyzer`](https://www.nuget.org/packages/Enums.NET.Analyzer/) which provides a code fix to migrate your usages of the non-generic and unsafe methods to the new methods.\n\n# Enums.NET\nEnums.NET is a high-performance type-safe .NET enum utility library which provides many operations as convenient extension methods. It is compatible with .NET Framework 4.5+ and .NET Standard 1.0+.\n\nI\'m trying to integrate some of Enums.NET\'s improvements into [corefx](https://github.com/dotnet/corefx) so if interested in its progress please check out the proposal [here](https://github.com/dotnet/corefx/issues/15453).\n\n## What\'s wrong with `System.Enum`\n1. Nearly all of `Enum`\'s static methods are non-generic leading to the following issues.\n   * Requires the enum type to be explicitly specified as an argument and requires invocation using static method syntax such as `Enum.IsDefined(typeof(ConsoleColor), value)` instead of what should be `value.IsDefined()`.\n   * Requires casting/unboxing for methods with an enum return value, eg. `ToObject`, `Parse`, and `GetValues`.\n   * Requires boxing for methods with enum input parameters losing type-safety, eg. `IsDefined` and `GetName`.\n2. Support for flag enums is limited to just the `HasFlag` method which isn\'t type-safe, is inefficient, and is ambiguous as to whether it determines if the value has all or any of the specified flags. It\'s all by the way.\n3. Most of its methods use reflection on each call without any sort of caching causing poor performance.\n4. The pattern to associate extra data with an enum member using `Attribute`s is not supported and instead requires users to manually retrieve the `Attribute`s via reflection. This pattern is commonly used on enum members with the `DescriptionAttribute`, `EnumMemberAttribute`, and `DisplayAttribute`.\n\nEnums.NET solves all of these issues and more.\n\n## Enums.NET Demo\n\n```c#\nusing System;\nusing System.Linq;\nusing EnumsNET;\nusing NUnit.Framework;\nusing DescriptionAttribute = System.ComponentModel.DescriptionAttribute;\n\n[TestFixture]\nclass EnumsNETDemo\n{\n    // Enum definitions at bottom\n\n    [Test]\n    public void Enumerate()\n    {\n        var count = 0;\n        // Retrieves all enum members in increasing value order\n        foreach (var member in Enums.GetMembers<NumericOperator>())\n        {\n            NumericOperator value = member.Value;\n            string name = member.Name;\n            AttributeCollection attributes = member.Attributes;\n            ++count;\n        }\n        Assert.AreEqual(8, count);\n\n        count = 0;\n        // Retrieves distinct values in increasing value order\n        foreach (var value in Enums.GetValues<NumericOperator>(EnumMemberSelection.Distinct))\n        {\n            string name = value.GetName();\n            AttributeCollection attributes = value.GetAttributes();\n            ++count;\n        }\n        Assert.AreEqual(6, count);\n    }\n\n    [Test]\n    public void FlagEnumOperations()\n    {\n        // HasAllFlags\n        Assert.IsTrue((DaysOfWeek.Monday | DaysOfWeek.Wednesday | DaysOfWeek.Friday).HasAllFlags(DaysOfWeek.Monday | DaysOfWeek.Wednesday));\n        Assert.IsFalse(DaysOfWeek.Monday.HasAllFlags(DaysOfWeek.Monday | DaysOfWeek.Wednesday));\n\n        // HasAnyFlags\n        Assert.IsTrue(DaysOfWeek.Monday.HasAnyFlags(DaysOfWeek.Monday | DaysOfWeek.Wednesday));\n        Assert.IsFalse((DaysOfWeek.Monday | DaysOfWeek.Wednesday).HasAnyFlags(DaysOfWeek.Friday));\n\n        // CombineFlags ~ bitwise OR\n        Assert.AreEqual(DaysOfWeek.Monday | DaysOfWeek.Wednesday, DaysOfWeek.Monday.CombineFlags(DaysOfWeek.Wednesday));\n        Assert.AreEqual(DaysOfWeek.Monday | DaysOfWeek.Wednesday | DaysOfWeek.Friday, FlagEnums.CombineFlags(DaysOfWeek.Monday, DaysOfWeek.Wednesday, DaysOfWeek.Friday));\n\n        // CommonFlags ~ bitwise AND\n        Assert.AreEqual(DaysOfWeek.Monday, DaysOfWeek.Monday.CommonFlags(DaysOfWeek.Monday | DaysOfWeek.Wednesday));\n        Assert.AreEqual(DaysOfWeek.None, DaysOfWeek.Monday.CommonFlags(DaysOfWeek.Wednesday));\n\n        // RemoveFlags\n        Assert.AreEqual(DaysOfWeek.Wednesday, (DaysOfWeek.Monday | DaysOfWeek.Wednesday).RemoveFlags(DaysOfWeek.Monday));\n        Assert.AreEqual(DaysOfWeek.None, (DaysOfWeek.Monday | DaysOfWeek.Wednesday).RemoveFlags(DaysOfWeek.Monday | DaysOfWeek.Wednesday));\n\n        // GetFlags, splits out the individual flags in increasing significance bit order\n        var flags = DaysOfWeek.Weekend.GetFlags().ToList();\n        Assert.AreEqual(2, flags.Count);\n        Assert.AreEqual(DaysOfWeek.Sunday, flags[0]);\n        Assert.AreEqual(DaysOfWeek.Saturday, flags[1]);\n    }\n\n    [Test]\n    public new void ToString()\n    {\n        // AsString, equivalent to ToString\n        Assert.AreEqual("Equals", NumericOperator.Equals.AsString());\n        Assert.AreEqual("-1", ((NumericOperator)(-1)).AsString());\n\n        // GetName\n        Assert.AreEqual("Equals", NumericOperator.Equals.GetName());\n        Assert.IsNull(((NumericOperator)(-1)).GetName());\n\n        // Get description\n        Assert.AreEqual("Is", NumericOperator.Equals.AsString(EnumFormat.Description));\n        Assert.IsNull(NumericOperator.LessThan.AsString(EnumFormat.Description));\n\n        // Get description if applied, otherwise the name\n        Assert.AreEqual("LessThan", NumericOperator.LessThan.AsString(EnumFormat.Description, EnumFormat.Name));\n    }\n\n    [Test]\n    public void Validate()\n    {\n        // Standard Enums, checks is defined\n        Assert.IsTrue(NumericOperator.LessThan.IsValid());\n        Assert.IsFalse(((NumericOperator)20).IsValid());\n\n        // Flag Enums, checks is valid flag combination or is defined\n        Assert.IsTrue((DaysOfWeek.Sunday | DaysOfWeek.Wednesday).IsValid());\n        Assert.IsFalse((DaysOfWeek.Sunday | DaysOfWeek.Wednesday | ((DaysOfWeek)(-1))).IsValid());\n\n        // Custom validation through IEnumValidatorAttribute<TEnum>\n        Assert.IsTrue(DayType.Weekday.IsValid());\n        Assert.IsTrue((DayType.Weekday | DayType.Holiday).IsValid());\n        Assert.IsFalse((DayType.Weekday | DayType.Weekend).IsValid());\n    }\n\n    [Test]\n    public void CustomEnumFormat()\n    {\n        EnumFormat symbolFormat = Enums.RegisterCustomEnumFormat(member => member.Attributes.Get<SymbolAttribute>()?.Symbol);\n        Assert.AreEqual(">", NumericOperator.GreaterThan.AsString(symbolFormat));\n        Assert.AreEqual(NumericOperator.LessThan, Enums.Parse<NumericOperator>("<", ignoreCase: false, symbolFormat));\n    }\n\n    [Test]\n    public void Attributes()\n    {\n        Assert.AreEqual("!=", NumericOperator.NotEquals.GetAttributes().Get<SymbolAttribute>().Symbol);\n        Assert.IsTrue(Enums.GetMember<NumericOperator>("GreaterThanOrEquals").Attributes.Has<PrimaryEnumMemberAttribute>());\n        Assert.IsFalse(NumericOperator.LessThan.GetAttributes().Has<DescriptionAttribute>());\n    }\n\n    [Test]\n    public void Parsing()\n    {\n        Assert.AreEqual(NumericOperator.GreaterThan, Enums.Parse<NumericOperator>("GreaterThan"));\n        Assert.AreEqual(NumericOperator.NotEquals, Enums.Parse<NumericOperator>("1"));\n        Assert.AreEqual(NumericOperator.Equals, Enums.Parse<NumericOperator>("Is", ignoreCase: false, EnumFormat.Description));\n\n        Assert.AreEqual(DaysOfWeek.Monday | DaysOfWeek.Wednesday, Enums.Parse<DaysOfWeek>("Monday, Wednesday"));\n        Assert.AreEqual(DaysOfWeek.Tuesday | DaysOfWeek.Thursday, FlagEnums.ParseFlags<DaysOfWeek>("Tuesday | Thursday", ignoreCase: false, delimiter: "|"));\n    }\n\n    enum NumericOperator\n    {\n        [Symbol("="), Description("Is")]\n        Equals,\n        [Symbol("!="), Description("Is not")]\n        NotEquals,\n        [Symbol("<")]\n        LessThan,\n        [Symbol(">="), PrimaryEnumMember] // PrimaryEnumMember indicates enum member as primary duplicate for extension methods\n        GreaterThanOrEquals,\n        NotLessThan = GreaterThanOrEquals,\n        [Symbol(">")]\n        GreaterThan,\n        [Symbol("<="), PrimaryEnumMember]\n        LessThanOrEquals,\n        NotGreaterThan = LessThanOrEquals\n    }\n\n    [AttributeUsage(AttributeTargets.Field)]\n    class SymbolAttribute : Attribute\n    {\n        public string Symbol { get; }\n\n        public SymbolAttribute(string symbol)\n        {\n            Symbol = symbol;\n        }\n    }\n\n    [Flags]\n    enum DaysOfWeek\n    {\n        None = 0,\n        Sunday = 1,\n        Monday = 2,\n        Tuesday = 4,\n        Wednesday = 8,\n        Thursday = 16,\n        Friday = 32,\n        Weekdays = Monday | Tuesday | Wednesday | Thursday | Friday,\n        Saturday = 64,\n        Weekend = Sunday | Saturday,\n        All = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n    }\n\n    [Flags, DayTypeValidator]\n    enum DayType\n    {\n        Weekday = 1,\n        Weekend = 2,\n        Holiday = 4\n    }\n\n    [AttributeUsage(AttributeTargets.Enum)]\n    class DayTypeValidatorAttribute : Attribute, IEnumValidatorAttribute<DayType>\n    {\n        public bool IsValid(DayType value) => value.GetFlagCount(DayType.Weekday | DayType.Weekend) == 1 && FlagEnums.IsValidFlagCombination(value);\n    }\n}\n```\n\n---\n![Performance](performance.png)\n\nResults from running the [PerformanceTestConsole](./Src/Enums.NET.PerfTestConsole/Program.cs) BenchmarkDotNet application.\n\n## Interface\nSee [fuget](https://www.fuget.org/packages/Enums.NET) for exploring the interface.\n\n## Credits\nInspired by Jon Skeet\'s [Unconstrained Melody](https://github.com/jskeet/unconstrained-melody).\n\nUses Simon Cropp\'s [Fody](https://github.com/Fody/Fody) which is built on Jb Evain\'s [Mono.Cecil](https://github.com/jbevain/cecil) for building the assembly.\n'