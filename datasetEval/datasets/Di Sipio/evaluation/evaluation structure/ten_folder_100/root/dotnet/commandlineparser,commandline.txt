b'[![Build status](https://ci.appveyor.com/api/projects/status/p61dj8udxs2aocmo/branch/master?svg=true)](https://ci.appveyor.com/project/commandlineparser/commandline/branch/master)\n[![NuGet](https://img.shields.io/nuget/dt/commandlineparser.svg)](http://nuget.org/packages/commandlineparser)\n[![NuGet](https://img.shields.io/nuget/v/commandlineparser.svg)](http://nuget.org/packages/commandlineparser)\n[![NuGet](https://img.shields.io/nuget/vpre/commandlineparser.svg)](http://nuget.org/packages/commandlineparser)\n[![Join the Gitter chat!](https://badges.gitter.im/gsscoder/commandline.svg)](https://gitter.im/gsscoder/commandline?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n# Command Line Parser Library for CLR and NetStandard\n\n**Note:** the API surface has changed since v1.9.x and earlier. If you are looking for documentation on v1.9.x, please see [stable-1.9.71.2](https://github.com/gsscoder/commandline/tree/stable-1.9.71.2)\n\nThe Command Line Parser Library offers CLR applications a clean and concise API for manipulating command line arguments and related tasks, such as defining switches, options and verb commands. It allows you to display a help screen with a high degree of customization and a simple way to report syntax errors to the end user.\n\n```\nC:\\Project> NuGet Install CommandLineParser\n```\n\n_NOTE: Mentioned F# Support is provided via ```CommandLineParser.FSharp``` package with FSharp dependencies._\n\n__This library provides _hassle free_ command line parsing with a constantly updated API since 2005.__\n\n# At a glance:\n\n- Compatible with __.NET Framework 4.0+__, __Mono 2.1+ Profile__, and __.NET Core__\n- Doesn\'t depend on other packages (No dependencies beyond standard base libraries)\n- One line parsing using default singleton: `CommandLine.Parser.Default.ParseArguments(...)`.\n- Automatic or one line help screen generator: `HelpText.AutoBuild(...)`.\n- Supports `--help`, `--version`, `version` and `help [verb]` by default.\n- Map to sequences (via `IEnumerable<T>` and similar) and scalar types, including Enums and `Nullable<T>`.\n- You can also map to every type with a constructor that accepts a string (like `System.Uri`).\n- Define [verb commands](https://github.com/commandlineparser/commandline/wiki/Verbs) similar to `git commit -a`.\n- Unparsing support: `CommandLine.Parser.Default.FormatCommandLine<T>(T options)`.\n- CommandLineParser.FSharp package is F#-friendly with support for `option<\'a>`, see [demo](https://github.com/commandlineparser/commandline/blob/master/demo/fsharp-demo.fsx).  _NOTE: This is a separate NuGet package._\n- Most of features applies with a [CoC](http://en.wikipedia.org/wiki/Convention_over_configuration) philosophy.\n- C# demo: source [here](https://github.com/commandlineparser/commandline/tree/master/demo/ReadText.Demo).\n\n# Getting Started with the Command Line Parser Library\n\nYou can utilize the parser library in several ways:\n\n- Install via NuGet/Paket: [https://www.nuget.org/packages/CommandLineParser/](https://www.nuget.org/packages/CommandLineParser/)\n- Integrate directly into your project by copying the .cs files into your project.\n- ILMerge during your build process.\n\n## Quick Start Examples\n\n1. Create a class to define valid options, and to receive the parsed options.\n2. Call ParseArguments with the args string array.\n\nC# Quick Start:\n\n```csharp\nusing System;\nusing CommandLine;\n\nnamespace QuickStart\n{\n    class Program\n    {\n        public class Options\n        {\n            [Option(\'v\', "verbose", Required = false, HelpText = "Set output to verbose messages.")]\n            public bool Verbose { get; set; }\n        }\n\n        static void Main(string[] args)\n        {\n            Parser.Default.ParseArguments<Options>(args)\n                   .WithParsed<Options>(o =>\n                   {\n                       if (o.Verbose)\n                       {\n                           Console.WriteLine($"Verbose output enabled. Current Arguments: -v {o.Verbose}");\n                           Console.WriteLine("Quick Start Example! App is in Verbose mode!");\n                       }\n                       else\n                       {\n                           Console.WriteLine($"Current Arguments: -v {o.Verbose}");\n                           Console.WriteLine("Quick Start Example!");\n                       }\n                   });\n        }\n    }\n}\n```\n\nC# Examples:\n\n```csharp\nclass Options\n{\n  [Option(\'r\', "read", Required = true, HelpText = "Input files to be processed.")]\n  public IEnumerable<string> InputFiles { get; set; }\n\n  // Omitting long name, defaults to name of property, ie "--verbose"\n  [Option(\n\tDefault = false,\n\tHelpText = "Prints all messages to standard output.")]\n  public bool Verbose { get; set; }\n  \n  [Option("stdin",\n\tDefault = false,\n\tHelpText = "Read from stdin")]\n  public bool stdin { get; set; }\n\n  [Value(0, MetaName = "offset", HelpText = "File offset.")]\n  public long? Offset { get; set; }\n}\n\nstatic void Main(string[] args)\n{\n  CommandLine.Parser.Default.ParseArguments<Options>(args)\n    .WithParsed<Options>(opts => RunOptionsAndReturnExitCode(opts))\n    .WithNotParsed<Options>((errs) => HandleParseError(errs));\n}\n```\n\nF# Examples:\n\n```fsharp\ntype options = {\n  [<Option(\'r\', "read", Required = true, HelpText = "Input files.")>] files : seq<string>;\n  [<Option(HelpText = "Prints all messages to standard output.")>] verbose : bool;\n  [<Option(Default = "\xd1\x80\xd1\x83\xd1\x81\xd1\x81\xd0\xba\xd0\xb8\xd0\xb9", HelpText = "Content language.")>] language : string;\n  [<Value(0, MetaName="offset", HelpText = "File offset.")>] offset : int64 option;\n}\n\nlet main argv =\n  let result = CommandLine.Parser.Default.ParseArguments<options>(argv)\n  match result with\n  | :? Parsed<options> as parsed -> run parsed.Value\n  | :? NotParsed<options> as notParsed -> fail notParsed.Errors\n```\n\nVB.NET:\n\n```VB.NET\nClass Options\n\t<CommandLine.Option(\'r\', "read", Required := true,\n\tHelpText:="Input files to be processed.")>\n\tPublic Property InputFiles As IEnumerable(Of String)\n\n\t\' Omitting long name, defaults to name of property, ie "--verbose"\n\t<CommandLine.Option(\n\tHelpText:="Prints all messages to standard output.")>\n\tPublic Property Verbose As Boolean\n\n\t<CommandLine.Option(Default:="\xe4\xb8\xad\xe6\x96\x87",\n\tHelpText:="Content language.")>\n\tPublic Property Language As String\n\n\t<CommandLine.Value(0, MetaName:="offset",\n\tHelpText:="File offset.")>\n\tPublic Property Offset As Long?\nEnd Class\n\nSub Main(ByVal args As String())\n    CommandLine.Parser.Default.ParseArguments(Of Options)(args) _\n        .WithParsed(Function(opts As Options) RunOptionsAndReturnExitCode(opts)) _\n        .WithNotParsed(Function(errs As IEnumerable(Of [Error])) 1)\nEnd Sub\n```\n\n### For verbs:\n\n1. Create separate option classes for each verb.  An options base class is supported.  \n2. Call ParseArguments with all the verb attribute decorated options classes.\n3. Use MapResult to direct program flow to the verb that was parsed.\n\nC# example:\n\n```csharp\n[Verb("add", HelpText = "Add file contents to the index.")]\nclass AddOptions {\n  //normal options here\n}\n[Verb("commit", HelpText = "Record changes to the repository.")]\nclass CommitOptions {\n  //commit options here\n}\n[Verb("clone", HelpText = "Clone a repository into a new directory.")]\nclass CloneOptions {\n  //clone options here\n}\n\nint Main(string[] args) {\n  return CommandLine.Parser.Default.ParseArguments<AddOptions, CommitOptions, CloneOptions>(args)\n\t.MapResult(\n\t  (AddOptions opts) => RunAddAndReturnExitCode(opts),\n\t  (CommitOptions opts) => RunCommitAndReturnExitCode(opts),\n\t  (CloneOptions opts) => RunCloneAndReturnExitCode(opts),\n\t  errs => 1);\n}\n```\n\nVB.NET example:\n\n```VB.NET\n<CommandLine.Verb("add", HelpText:="Add file contents to the index.")>\nPublic Class AddOptions\n    \'Normal options here\nEnd Class\n<CommandLine.Verb("commit", HelpText:="Record changes to the repository.")>\nPublic Class CommitOptions\n    \'Normal options here\nEnd Class\n<CommandLine.Verb("clone", HelpText:="Clone a repository into a new directory.")>\nPublic Class CloneOptions\n    \'Normal options here\nEnd Class\n\nFunction Main(ByVal args As String()) As Integer\n    Return CommandLine.Parser.Default.ParseArguments(Of AddOptions, CommitOptions, CloneOptions)(args) _\n          .MapResult(\n              (Function(opts As AddOptions) RunAddAndReturnExitCode(opts)),\n              (Function(opts As CommitOptions) RunCommitAndReturnExitCode(opts)),\n              (Function(opts As CloneOptions) RunCloneAndReturnExitCode(opts)),\n              (Function(errs As IEnumerable(Of [Error])) 1)\n          )\nEnd Function\n```\n\nF# Example:\n\n```fsharp\nopen CommandLine\n\n[<Verb("add", HelpText = "Add file contents to the index.")>]\ntype AddOptions = {\n  // normal options here\n}\n[<Verb("commit", HelpText = "Record changes to the repository.")>]\ntype CommitOptions = {\n  // normal options here\n}\n[<Verb("clone", HelpText = "Clone a repository into a new directory.")>]\ntype CloneOptions = {\n  // normal options here\n}\n\n[<EntryPoint>]\nlet main args =\n  let result = Parser.Default.ParseArguments<AddOptions, CommitOptions, CloneOptions> args\n  match result with\n  | :? CommandLine.Parsed<obj> as command ->\n\tmatch command.Value with\n\t| :? AddOptions as opts -> RunAddAndReturnExitCode opts\n\t| :? CommitOptions as opts -> RunCommitAndReturnExitCode opts\n\t| :? CloneOptions as opts -> RunCloneAndReturnExitCode opts\n  | :? CommandLine.NotParsed<obj> -> 1\n```\n\n# Contributors\nFirst off, _Thank you!_  All contributions are welcome.  \n\nPlease consider sticking with the GNU getopt standard for command line parsing.  \n\nAdditionally, for easiest diff compares, please follow the project\'s tabs settings.  Utilizing the EditorConfig extension for Visual Studio/your favorite IDE is recommended.\n\n__And most importantly, please target the ```develop``` branch in your pull requests!__\n\n## Main Contributors (alphabetical order):\n- Alexander Fast (@mizipzor)\n- Dan Nemec (@nemec)\n- Eric Newton (@ericnewton76)\n- Kevin Moore (@gimmemoore)\n- Steven Evans\n- Thomas D\xc3\xa9moulins (@Thilas)\n\n## Resources for newcomers:\n\n- [Wiki](https://github.com/commandlineparser/commandline/wiki)\n- [GNU getopt](http://www.gnu.org/software/libc/manual/html_node/Getopt.html)\n\n# Contacts:\n\n- Giacomo Stelluti Scala\n  - gsscoder AT gmail DOT com (_use this for everything that is not available via GitHub features_)\n  - GitHub: [gsscoder](https://github.com/gsscoder)\n  - [Blog](http://gsscoder.blogspot.it)\n  - [Twitter](http://twitter.com/gsscoder)\n- Dan Nemec\n- Eric Newton\n  - ericnewton76+commandlineparser AT gmail DOT com\n  - GitHub: [ericnewton76](https://github.com/ericnewton76)\n  - Blog: \n  - Twitter: [enorl76](http://twitter.com/enorl76)\n'