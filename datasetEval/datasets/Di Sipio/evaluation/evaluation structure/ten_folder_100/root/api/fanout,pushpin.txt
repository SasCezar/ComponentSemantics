b'Pushpin\n=======\n\nWebsite: http://pushpin.org/  \nMailing List: http://lists.fanout.io/mailman/listinfo/fanout-users  \nChat Room: [![Join the chat at https://gitter.im/fanout/pushpin](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/fanout/pushpin?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nPushpin is a reverse proxy server written in C++ that makes it easy to implement WebSocket, HTTP streaming, and HTTP long-polling services. The project is unique among realtime push solutions in that it is designed to address the needs of API creators. Pushpin is transparent to clients and integrates easily into an API stack.\n\nHow it works\n------------\n\nPushpin is placed in the network path between the backend and any clients:\n\n<p align="center">\n  <img src="http://pushpin.org/image/pushpin-abstract.png" alt="pushpin-abstract"/>\n</p>\n\nPushpin communicates with backend web applications using regular, short-lived HTTP requests. This allows backend applications to be written in any language and use any webserver. There are two main integration points:\n\n1. The backend must handle proxied requests. For HTTP, each incoming request is proxied to the backend. For WebSockets, the activity of each connection is translated into a series of HTTP requests<sup>[1](#proxy-modes)</sup> sent to the backend. Pushpin\'s behavior is determined by how the backend responds to these requests.\n2. The backend must tell Pushpin to push data. Regardless of how clients are connected, data may be pushed to them by making an HTTP POST request to Pushpin\'s private control API (`http://localhost:5561/publish/` by default). Pushpin will inject this data into any client connections as necessary.\n\nTo assist with integration, there are [libraries](http://pushpin.org/docs/usage/#libraries) for many backend languages and frameworks. Pushpin has no libraries on the client side because it is transparent to clients.\n\nExample\n-------\n\nTo create an HTTP streaming connection, respond to a proxied request with special headers `Grip-Hold` and `Grip-Channel`<sup>[2](#grip)</sup>:\n\n```http\nHTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: 22\nGrip-Hold: stream\nGrip-Channel: test\n\nwelcome to the stream\n```\n\nWhen Pushpin receives the above response from the backend, it will process it and send an initial response to the client that instead looks like this:\n\n```http\nHTTP/1.1 200 OK\nContent-Type: text/plain\nTransfer-Encoding: chunked\nConnection: Transfer-Encoding\n\nwelcome to the stream\n```\n\nPushpin eats the special headers and switches to chunked encoding (notice there\'s no `Content-Length`). The request between Pushpin and the backend is now complete, but the request between the client and Pushpin remains held open. The request is subscribed to a channel called `test`.\n\nData can then be pushed to the client by publishing data on the `test` channel:\n\n```bash\ncurl -d \'{ "items": [ { "channel": "test", "formats": { "http-stream": \\\n    { "content": "hello there\\n" } } } ] }\' \\\n    http://localhost:5561/publish\n```\n\nThe client would then see the line "hello there" appended to the response stream. Ta-da, transparent realtime push!\n\nFor more details, see the [HTTP streaming](http://pushpin.org/docs/usage/#http-streaming) section of the documentation. Pushpin also supports [HTTP long-polling](http://pushpin.org/docs/usage/#http-long-polling) and [WebSockets](http://pushpin.org/docs/usage/#websockets).\n\nExample using a library\n-----------------------\n\nUsing a library on the backend makes integration is even easier. Here\'s another HTTP streaming example, similar to the one shown above, except using Pushpin\'s [Django library](https://github.com/fanout/django-grip). Please note that Pushpin is not Python/Django-specific and there are backend libraries for [other languages/frameworks, too](http://pushpin.org/docs/usage/#libraries).\n\nThe Django library requires configuration in `settings.py`:\n```python\nMIDDLEWARE_CLASSES = (\n    \'django_grip.GripMiddleware\',\n    ...\n)\n\nGRIP_PROXIES = [{\'control_uri\': \'http://localhost:5561\'}]\n```\n\nHere\'s a simple view:\n```python\nfrom django.http import HttpResponse\nfrom django_grip import set_hold_stream\n\ndef myendpoint(request):\n    if request.method == \'GET\':\n        # subscribe every incoming request to a channel in stream mode\n        set_hold_stream(request, \'test\')\n        return HttpResponse(\'welcome to the stream\\n\', content_type=\'text/plain\')\n    ...\n```\n\nWhat happens here is the `set_hold_stream()` method flags the request as needing to turn into a stream, bound to channel `test`. The middleware will see this and add the necessary `Grip-Hold` and `Grip-Channel` headers to the response.\n\nPublishing data is easy:\n```python\nfrom gripcontrol import HttpStreamFormat\nfrom django_grip import publish\n\npublish(\'test\', HttpStreamFormat(\'hello there\\n\'))\n```\n\nExample using WebSockets\n------------------------\n\nPushpin supports WebSockets by converting connection activity/messages into HTTP requests and sending them to the backend. For this example, we\'ll use Pushpin\'s [Express library](https://github.com/fanout/express-grip). As before, please note that Pushpin is not Node/Express-specific and there are backend libraries for [other languages/frameworks, too](http://pushpin.org/docs/usage/#libraries).\n\nThe Express library requires configuration and setting up middleware handlers before and after any endpoints:\n```javascript\nvar express = require(\'express\');\nvar grip = require(\'grip\');\nvar expressGrip = require(\'express-grip\');\n\nexpressGrip.configure({\n    gripProxies: [{\'control_uri\': \'http://localhost:5561\', \'key\': \'changeme\'}]\n});\n\nvar app = express();\n\n// Add the pre-handler middleware to the front of the stack\napp.use(expressGrip.preHandlerGripMiddleware);\n\n// put your normal endpoint handlers here, for example:\napp.get(\'/hello\', function(req, res, next) {\n    res.send(\'hello world\\n\');\n\n    // next() must be called for the post-handler middleware to execute\n    next();\n});\n\n// Add the post-handler middleware to the back of the stack\napp.use(expressGrip.postHandlerGripMiddleware);\n```\n\nBecause of the post-handler middleware, it\'s important that you call `next()` at the end of your handlers.\n\nWith that structure in place, here\'s an example of a WebSocket endpoint:\n```javascript\napp.post(\'/websocket\', function(req, res, next) {\n    var ws = expressGrip.getWsContext(res);\n\n    // If this is a new connection, accept it and subscribe it to a channel\n    if (ws.isOpening()) {\n        ws.accept();\n        ws.subscribe(\'all\');\n    }\n\n    while (ws.canRecv()) {\n        var message = ws.recv();\n\n        // If return value is null then connection is closed\n        if (message == null) {\n            ws.close();\n            break;\n        }\n\n        // broadcast the message to everyone connected\n        expressGrip.publish(\'all\', new grip.WebSocketMessageFormat(message));\n    }\n\n    // next() must be called for the post-handler middleware to execute\n    next();\n});\n```\n\nThe above code binds all incoming connections to a channel called `all`. Any received messages are published out to all connected clients.\n\nWhat\'s particularly noteworthy is that the above endpoint is stateless. The app doesn\'t keep track of connections, and the handler code only runs whenever messages arrive. Restarting the app won\'t disconnect clients.\n\nThe `while` loop is deceptive. It looks like it\'s looping for the lifetime of the WebSocket connection, but what it\'s really doing is looping through a batch of WebSocket messages that was just received via HTTP. Often this will be one message, and so the loop performs one iteration and then exits. Similarly, the `ws` object only exists for the duration of the handler invocation, rather than for the lifetime of the connection as you might expect. It may look like socket code, but it\'s all an illusion. :tophat:\n\nFor details on the underlying protocol conversion, see the [WebSocket-Over-HTTP Protocol spec](http://pushpin.org/docs/protocols/websocket-over-http/).\n\nExample without a webserver\n---------------------------\n\nPushpin can also connect to backend servers via ZeroMQ instead of HTTP. This may be preferred for writing lower-level services where a real webserver isn\'t needed. The messages exchanged over the ZeroMQ connection contain the same information as HTTP, encoded as TNetStrings.\n\nTo use a ZeroMQ backend, first make sure there\'s an appropriate route in Pushpin\'s `routes` file:\n```\n* zhttpreq/tcp://127.0.0.1:10000\n```\n\nThe above line tells Pushpin to bind a REQ-compatible socket on port 10000 that handlers can connect to.\n\nActivating an HTTP stream is as easy as responding on a REP socket:\n```python\nimport zmq\nimport tnetstring\n\nzmq_context = zmq.Context()\nsock = zmq_context.socket(zmq.REP)\nsock.connect(\'tcp://127.0.0.1:10000\')\n\nwhile True:\n    req = tnetstring.loads(sock.recv()[1:])\n\n    resp = {\n        \'id\': req[\'id\'],\n        \'code\': 200,\n        \'reason\': \'OK\',\n        \'headers\': [\n            [\'Grip-Hold\', \'stream\'],\n            [\'Grip-Channel\', \'test\'],\n            [\'Content-Type\', \'text/plain\']\n        ],\n        \'body\': \'welcome to the stream\\n\'\n    }\n\n    sock.send(\'T\' + tnetstring.dumps(resp))\n```\n\nWhy another realtime solution?\n------------------------------\n\nPushpin is an ambitious project with two primary goals:\n\n* Make realtime API development easier. There are many other solutions out there that are excellent for building realtime apps, but few are useful within the context of *APIs*. For example, you can\'t use Socket.io to build Twitter\'s streaming API. A new kind of project is needed in this case.\n* Make realtime push behavior delegable. The reason there isn\'t a realtime push CDN yet is because the standards and practices necessary for delegating to a third party in a transparent way are not yet established. Pushpin is more than just another realtime push solution; it represents the next logical step in the evolution of realtime web architectures.\n\nTo really understand Pushpin, you need to think of it as more like a gateway than a message queue. Pushpin does not persist data and it is agnostic to your application\'s data model. Your backend provides the mapping to whatever that data model is. Tools like Kafka and RabbitMQ are complementary. Pushpin is also agnostic to your API definition. Clients don\'t necessarily subscribe to "channels" or receive "messages". Clients make HTTP requests or send WebSocket frames, and your backend decides the meaning of those inputs. Pushpin could perhaps be awkwardly described as "a proxy server that enables web services to delegate the handling of realtime push primitives".\n\nOn a practical level, there are many benefits to Pushpin that you don\'t see anywhere else:\n\n* The proxy design allows Pushpin to fit nicely within an API stack. This means it can inherit other facilities from your REST API, such as authentication, logging, throttling, etc. It can be combined with an API management system.\n* As your API scales, a multi-tiered architecture will become inevitable. With Pushpin you can easily do this from the start.\n* It works well with microservices. Each microservice can have its own Pushpin instance. No central bus needed.\n* Hot reload. Restarting the backend doesn\'t disconnect clients.\n* In the case of WebSocket messages being proxied out as HTTP requests, the messages may be handled statelessly by the backend. Messages from a single connection can even be load balanced across a set of backend instances.\n\nInstall\n-------\n\nCheck out the [the Install guide](http://pushpin.org/docs/install/), which covers how to install and run. There are packages available for Debian/Ubuntu and Homebrew (Mac), or you can build from source.\n\nIf you want to build the git version and have the dependencies installed already, then below are brief build instructions:\n\n```\n# pull submodules\ngit submodule init && git submodule update\n\n# build\n./configure --qtselect=5 && make\n\n# copy default config\ncp -r examples/config .\n\n# run!\n./pushpin\n```\n\nBy default, Pushpin listens on port 7999 and requests are handled by its internal test handler. You can confirm the server is working by browsing to `http://localhost:7999/`. Next, you should modify the `routes` config file to route requests to your backend webserver. See [Configuration](http://pushpin.org/docs/configuration/).\n\nScalability\n-----------\n\nPushpin is horizontally scalable. Instances don\xe2\x80\x99t talk to each other, and sticky routing is not needed. Backends must publish data to all instances to ensure clients connected to any instance will receive the data. Most of the backend libraries support configuring more than one Pushpin instance, so that a single publish call will send data to multiple instances at once.\n\nOptionally, ZeroMQ PUB/SUB can be used to send data to Pushpin instead of using HTTP POST. When this method is used, subscription information is forwarded to each publisher, such that data will only be published to instances that have listeners.\n\nAs for vertical scalability, Pushpin has been tested reliably with 10,000 concurrent connections running on a single Amazon EC2 m3.xlarge instance. 20,000 connections and beyond are possible with some latency degradation. We definitely want to increase this number, but the important thing is that Pushpin is horizontally scalable which is effectively limitless.\n\nWhat does the name mean?\n------------------------\n\nPushpin means to "pin" connections open for "pushing".\n\nLicense\n-------\n\nPushpin is offered under the GNU AGPL. See the COPYING file.\n\nFootnotes\n---------\n\n<a name="proxy-modes">1</a>: Pushpin can communicate WebSocket activity to the backend using either HTTP or WebSockets. Conversion to HTTP is generally recommended as it makes the backend easier to reason about.\n\n<a name="grip">2</a>: GRIP (Generic Realtime Intermediary Protocol) is the name of Pushpin\'s backend protocol. More about that [here](http://pushpin.org/docs/protocols/grip/).\n'