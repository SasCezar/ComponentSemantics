b'React Refetch\n=========================\nA simple, declarative, and composable way to fetch data for React components.\n\n![React Refetch Logo](logo.png)\n\n## Installation\n\n[![build status](https://img.shields.io/travis/heroku/react-refetch/master.svg?style=flat-square)](https://travis-ci.org/heroku/react-refetch) [![npm version](https://img.shields.io/npm/v/react-refetch.svg?style=flat-square)](https://www.npmjs.com/package/react-refetch)\n[![npm downloads](https://img.shields.io/npm/dm/react-refetch.svg?style=flat-square)](https://www.npmjs.com/package/react-refetch)\n\nRequires **React 0.14 or later.**\n\n```\nnpm install --save react-refetch\n```\n\nThis assumes that you\xe2\x80\x99re using [npm](http://npmjs.com/) package manager with a module bundler like [Webpack](http://webpack.github.io) or [Browserify](http://browserify.org/) to consume [CommonJS modules](http://webpack.github.io/docs/commonjs.html).\n\nThe following ES6 functions are required:\n\n- [`Object.assign`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n- [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n- [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch)\n- [`Array.prototype.find`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n\nCheck the compatibility tables ([`Object.assign`](https://kangax.github.io/compat-table/es6/#test-Object_static_methods_Object.assign), [`Promise`](https://kangax.github.io/compat-table/es6/#test-Promise), [`fetch`](http://caniuse.com/#feat=fetch), [`Array.prototype.find`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)) to make sure all browsers and platforms you need to support have these, and include polyfills as necessary.\n\n## Introduction\n\nSee [Introducing React Refetch](https://blog.heroku.com/react-refetch) on the [Heroku Engineering Blog](https://blog.heroku.com/engineering) for background and a quick introduction to this project.\n\n## Motivation\n\nThis project was inspired by (and forked from) [React Redux](https://github.com/rackt/react-redux). Redux/Flux is a wonderful library/pattern for applications that need to maintain complicated client-side state; however, if your application is mostly fetching and rendering read-only data from a server, it can over-complicate the architecture to fetch data in actions, reduce it into the store, only to select it back out again. The other approach of fetching data [inside](https://facebook.github.io/react/tips/initial-ajax.html) the component and dumping it in local state is also messy and makes components smarter and more mutable than they need to be. This module allows you to wrap a component in a `connect()` decorator like react-redux, but instead of mapping state to props, this lets you map props to URLs to props. This lets you keep your components completely stateless, describe data sources in a declarative manner, and delegate the complexities of data fetching to this module. Advanced options are also supported to lazy load data, poll for new data, and post data to the server.\n\n## Example\n\nIf you have a component called `Profile` that has a `userId` prop, you can wrap it in `connect()` to map `userId` to one or more requests and assign them to new props called `userFetch` and `likesFetch`:\n\n```jsx\nimport React, { Component } from \'react\'\nimport { connect, PromiseState } from \'react-refetch\'\n\nclass Profile extends Component {\n  render() {\n    // see below\n  }\n}\n\nexport default connect(props => ({\n  userFetch: `/users/${props.userId}`,\n  likesFetch: `/users/${props.userId}/likes`\n}))(Profile)\n```\n\nWhen the component mounts, the requests will be calculated, fetched, and the result will be passed into the component as the props specified. The result is represented as a `PromiseState`, which is a synchronous representation of the fetch [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise). It will either be `pending`, `fulfilled`, or `rejected`. This makes it simple to reason about the fetch state at the point in time the component is rendered:\n\n```jsx\nrender() {\n  const { userFetch, likesFetch } = this.props\n\n  if (userFetch.pending) {\n    return <LoadingAnimation/>\n  } else if (userFetch.rejected) {\n    return <Error error={userFetch.reason}/>\n  } else if (userFetch.fulfilled) {\n    return <User user={userFetch.value}/>\n  }\n\n  // similar for `likesFetch`\n}\n```\n\nSee the [composing responses](#composing-responses) to see how to handle `userFetch` and `likesFetch` together. Although not included in this library because of application-specific defaults, see an example [`PromiseStateContainer`](https://gist.github.com/ryanbrainard/788c12c3811d3da13124#file-promisestatecontainer-jsx) and its example [usage](https://gist.github.com/ryanbrainard/7713b4a6f328ac4b71e2#file-profile-jsx) for a way to abstract and simplify the rendering of `PromiseState`s.\n\n## Refetching\n\nWhen new props are received, the requests are re-calculated, and if they changed, the data is *refetched* and passed into the component as new `PromiseState`s. Using something like [React Router](https://github.com/rackt/react-router) to derive the props from the URL in the browser, the application can control state changes just by changing the URL. When the URL changes, the props change, which recalculates the requests, new data is fetched, and it is reinjected into the components:\n\n![react-refetch-flow](https://heroku-blog-files.s3.amazonaws.com/posts/1488278436-react-refetch-flow.svg)\n\nBy default, the requests are compared using their URL, headers, and body; however, if you want to use a custom value for the comparison, set the `comparison` attribute on the request. This can be helpful when the request should or should not be refetched in response to a prop change that is not in the request itself. A common situation where this occurs is when two different requests should be refetched together even though one of the requests does not actually include the prop. Note, this is using the request object syntax for `userStatsFetch` instead of just a plain URL string. This syntax allows for more advanced options. See the API documentation for details:\n\n```jsx\nconnect(props => ({\n  usersFetch:  `/users?status=${props.status}&page=${props.page}`,\n  userStatsFetch: { url: `/users/stats`, comparison: `${props.status}:${props.page}` }\n}))(UsersList)\n```\n\nIn this example, `usersFetch` is refetched every time `props.status` or `props.page` changes because the URL is changed. However, `userStatsFetch` does not contain these props in its URL, so would not normally be refetched, but because we added `comparison: ${props.status}:${props.page}`, it will be refetched along with `usersFetch`. In general, you should only rely on changes to the requests themselves to control when data is refetched, but this technique can be helpful when finer-grained control is needed.\n\nIf you always want data to be refetched when any new props are received, set the `force: true` option on the request. This will take precedence over any custom `comparison` and the default request comparison. For example:\n\n```jsx\nconnect(props => ({\n  usersFetch: `/users?status=${props.status}&page=${props.page}`,\n  userStatsFetch: { url: `/users/stats`, force: true }\n}))(UsersList)\n```\n\nSetting `force: true` should be avoid if at all possible because it could result in extraneous data fetching and rendering of the component. Try to use the default comparison or custom `comparison` option instead.\n\n## Automatic Refreshing\n\nIf the `refreshInterval` option is provided along with a URL, the data will be refreshed that many milliseconds after the last successful response. If a request was ever rejected, it will not be refreshed or otherwise retried. In this example, `likesFetch` will be refreshed every minute. Note, this is using the request object syntax for `likeFetch` instead of just a plain URL string. This syntax allows for more advanced options. See the [API documentation](https://github.com/heroku/react-refetch/blob/master/docs/api.md) for details.\n\n```jsx\nconnect(props => ({\n  userFetch:`/users/${props.userId}`,\n  likesFetch: { url: `/users/${props.userId}/likes`, refreshInterval: 60000 }\n}))(Profile)\n```\n\nWhen refreshing, the `PromiseState` will be the same as a the previous `fulfilled` state, but with the `refreshing` attribute set. That is, `pending` will remain unset and the existing `value` will be left in tact. When the refresh completes, `refreshing` will be unset and the `value` will be updated with the latest data. If the refresh is rejected, the `PromiseState` will move into a `rejected` and not attempt to refresh again.\n\n## Fetch Functions\n\nInstead of mapping the props directly to a URL string or request object, you can also map the props to a function that returns a URL string or request object. When the component receives props, instead of the data being fetched immediately and injected as a `PromiseState`, the function is bound to the props and injected into the component as functional prop to be called later (usually in response to a user action). This can be used to either lazy load data, post data to the server, or refresh data. These are best shown with examples:\n\n### Lazy Loading\n\nHere is a simple example of lazy loading the `likesFetch` with a function:\n\n```jsx\nconnect(props => ({\n  userFetch: `/users/${props.userId}`,\n  lazyFetchLikes: max => ({\n    likesFetch: `/users/${props.userId}/likes?max=${max}`\n  })\n}))(Profile)\n```\n\nIn this example, `userFetch` is fetched normally when the component receives  props, but `lazyFetchLikes` is a function that returns `likesFetch`, so nothing is fetched immediately. Instead `lazyFetchLikes` is injected into the component as a function to be called later inside the component:\n\n```jsx\nthis.props.lazyFetchLikes(10)\n```\n\nWhen this function is called, the request is calculated using both the bound props and any passed in arguments, and the `likesFetch` result is injected into the component normally as a `PromiseState`.\n\n### Posting Data\n\nFunctions can also be used for post data to the server in response to a user action. For example:\n\n```jsx\nconnect(props => ({\n  postLike: subject => ({\n    postLikeResponse: {\n      url: `/users/${props.userId}/likes`,\n      method: \'POST\',\n      body: JSON.stringify({ subject })\n    }\n  })\n}))(Profile)\n```\n\nThe `postLike` function is injected in as a prop, which can then be tied to a button:\n\n```jsx\n<button onClick={() => this.props.postLike(someSubject)}>Like!</button>\n```\n\nWhen the user clicks the button, `someSubject` is posted to the URL and the response is injected as a new `postLikeResponse` prop as a `PromiseState` to show progress and feedback to the user.\n\n### Manually Refreshing Data\n\nFunctions can also be used to manually refresh data by overwriting an existing `PromiseState`:\n\n```jsx\nconnect(props => {\n const url = `/users/${props.userId}`\n\n return {\n   userFetch: url,\n   refreshUser: () => ({\n     userFetch: {\n       url,\n       force: true,\n       refreshing: true\n     }\n   })\n }\n})(Profile)\n```\n\nThe `userFetch` data is first loaded normally when the component receives props, but the `refreshUser` function is also injected into the component. When `this.props.refreshUser()` is called, the request is calculated, and compared with the existing `userFetch` request. If the request changed (or `force: true`), the data is refetched and the existing `userFetch` `PromiseState` is overwritten.  This should generally only be used for user-invoked refreshes; see above for [automatically refreshing on an interval](#automatic-refreshing).\n\nNote, the example above sets `force: true` and `refreshing: true` on the request returned by the `refreshUser()` function. These attributes are optional, but commonly used with manual refreshes. `force: true` avoids the default request comparison (e.g. `url`, `method`, `headers`, `body`) with the existing `userFetch` request so that every time `this.props.refreshUser()` is called, a fetch is performed. Because the request would not have changed from the last prop change in the example above, `force: true` is required in this case for the fetch to occur when `this.props.refreshUser()` is called. `refreshing: true` avoids the existing `PromiseState` from being cleared while fetch is in progress.\n\n### Posting + Refreshing Data\n\nThe two examples above can be combined to post data to the server and refresh an existing `PromiseState`. This is a common pattern when a responding to a user action to update a resource and reflect that update in the component. For example, if `PATCH /users/:user_id` responds with the updated user, it can be used to overwrite the existing `userFetch` when the user updates her name:\n\n```jsx\nconnect(props => ({\n  userFetch: `/users/${props.userId}`,\n  updateUser: (firstName, lastName) => ({\n    userFetch: {\n      url: `/users/${props.userId}`\n      method: \'PATCH\'\n      body: JSON.stringify({ firstName, lastName })\n     }\n   })\n}))(Profile)\n```\n\n## Composing Responses\n\nIf a component needs data from more than one URL, the `PromiseState`s can be combined with [`PromiseState.all()`](https://github.com/heroku/react-refetch/blob/master/docs/api.md#promisestate) to be `pending` until all the `PromiseState`s have been fulfilled. For example:\n\n```jsx\nrender() {\n  const { userFetch, likesFetch } = this.props\n\n  // compose multiple PromiseStates together to wait on them as a whole\n  const allFetches = PromiseState.all([userFetch, likesFetch])\n\n  // render the different promise states\n  if (allFetches.pending) {\n    return <LoadingAnimation/>\n  } else if (allFetches.rejected) {\n    return <Error error={allFetches.reason}/>\n  } else if (allFetches.fulfilled) {\n    // decompose the PromiseState back into individual\n    const [user, likes] = allFetches.value\n    return (\n      <div>\n          <User data={user}/>\n          <Likes data={likes}/>\n      </div>\n    )\n  }\n}\n```\n\nSimilarly, `PromiseState.race()` can be used to return the first settled `PromiseState`. Like their asynchronous [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) counterparts, `PromiseStates` can be chained with `then()` and `catch()`; however, the handlers are run immediately to transform the existing state. This can be helpful to handle errors or transform values as part of a composition. For example, to provide a fallback value to `likesFetch` in the case of failure:\n\n```jsx\nPromiseState.all([userFetch, likesFetch.catch(reason => [])])\n```\n\n## Chaining Requests\n\nInside of `connect()`, requests can be chained using `then()`, `catch()`, `andThen()` and `andCatch()` to trigger additional requests after a previous request is fulfilled. These are not to be confused with the similar sounding functions on `PromiseState`, which are on the response side, are synchronous, and are executed for every change of the `PromiseState`.\n\n`then()` is helpful for cases where multiple requests are required to get the data needed by the component and the subsequent request relies on data from the previous request. For example, if you need to make a request to `/foos/${name}` to look up `foo.id` and then make a second request to `/bar-for-foos-by-id/${foo.id}` and return the whole thing as `barFetch` (the component will not have access to the intermediate `foo`):\n\n```jsx\nconnect(({ name }) => ({\n  barFetch: {\n    url: `/foos/${name}`,\n    then: foo => `/bar-for-foos-by-id/${foo.id}`\n  }\n}))\n```\n\n`andThen()` is similar, but is intended for side effect requests where you still need access to the result of the first request and/or need to fanout to multiple requests:\n\n```jsx\nconnect(({ name }) => ({\n  fooFetch: {\n    url: `/foos/${name}`,\n    andThen: foo => ({\n      barFetch: `/bar-for-foos-by-id/${foo.id}`\n    })\n  }\n}))\n```\n\nThis is also helpful for cases where a fetch function is changing data that is in some other fetch that is a collection. For example, if you have a list of `foo`s and you create a new `foo` and the list needs to be refreshed:\n\n```jsx\n connect(({ name }) => ({\n    foosFetch: \'/foos\',\n    createFoo: name => ({\n      fooCreation: {\n        method: \'POST\',\n        url: \'/foos\',\n        andThen: () => ({\n          foosFetch: {\n            url: \'/foos\',\n            refreshing: true\n          }\n        })\n      }\n    })\n  }))\n```\n\n`catch` and `andCatch` are similar, but for error cases.\n\n## Identity Requests: Static Data & Transforming Responses\n\nTo support static data and response transformations, there is a special kind of request called an "identity request" that has a `value` instead of a `url`. The `value` is passed through directly to the `PromiseState` without actually fetching anything. In its pure form, it looks like this:\n\n```jsx\nconnect(props => ({\n  usersFetch: {\n    value: [\n      {\n        id: 1,\n        name: \'Jane Doe\',\n        verified: true\n      },\n      {\n        id: 2,\n        name: \'John Doe\',\n        verified: false\n      }\n    ]\n  }\n}))(Users)\n```\n\nIn this case, the `usersFetch` `PromiseState` will be set to the provided list of users. The use case for identity requests by themselves is limited to mostly injecting static data during development and testing; however, they can be quite powerful when used with [request chaining](#chaining-requests). For example, it is possible to fetch data from the server, filter it within a `then` function, and return an identity request:\n\n```jsx\nconnect(props => ({\n  usersFetch: {\n    url: `/users`,\n    then: (users) => ({\n      value: users.filter(u => u.verified)\n    })\n  }\n}))(Users)\n```\n\nNote, this form of transformation is similar to what is possible on the `PromiseState` (i.e. `this.props.usersFetch.then(users => users.filter(u => u.verified))`); however, this has the advantage of only being called when `usersFetch` changes and keeps the logic out of the component.\n\n**Identity requests can also be provided a `Promise` (or any "thenable") or a `Function`.**\nIf `value` is a `Promise`, the `PromiseState` will be `pending` until the `Promise` is resolved. This can be helpful for asynchronous, non-fetch operations (e.g. file i/o) that want to use a similar pattern as fetch operations.\nIf `value` is a `Function`, it will be evaluated with no arguments and its return value will be used instead, as in cases described above. The `Function` will be only be called when `comparison` changes. This can be helpful for cases where you want to provide an identify request, but it is expensive to evaluate. By wrapping it in a function, it is only evaluated when something changes.\n\n```jsx\nconnect(props => ({\n  userFetch: {\n    comparison: props.userId,\n    value: () => SomeExternalAPI.getUser(`/users/${props.userId}`)\n  }\n}))(Users)\n```\n\n## Accessing Headers & Metadata\n\nBoth request and response headers and other metadata are accessible. Custom request headers can be set on the request as an object:\n\n```jsx\nconnect(props => ({\n  userFetch: {\n    url: `/users/${props.userId}`,\n    headers: {\n      FOO: \'foo\',\n      BAR: \'bar\'\n    }\n  }\n}))(Profile)\n```\n\nThe raw [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) and [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) can be accessed via the `meta` attribute on the `PromiseState`. For example, to access the a response header:\n\n```jsx\nuserFetch.meta.response.headers.get(\'FOO\')\n```\n\nDo not attempt to read bodies directly from `meta.request` or `meta.response`. They are provided for metadata purposes only.\n\n## Setting defaults and hooking into internal processing\n\nIt is possible to modify the various defaults used by React Refetch, as well as substitute in custom implementations of internal functions. A simple use case would be to avoid repeating the same option for every fetch block:\n\n```jsx\nimport { connect } from \'react-refetch\'\nconst refetch = connect.defaults({\n  credentials: \'include\'\n})\n\nrefetch(props => ({\n  userFetch: `/users/${props.userId}`\n}))(Profile)\n```\n\nA more advanced use case would be to replace the `buildRequest` internal function to, for example, modify headers on the fly based on the URL of the request, or using advanced [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request) options:\n\n```jsx\n// api-connector.js\nimport { connect } from \'react-refetch\'\nimport urlJoin from \'url-join\'\nimport { getPrivateToken } from \'./api-tokens\'\n\nconst baseUrl = \'https://api.example.com/\'\n\nexport default connect.defaults({\n  buildRequest: function (mapping) {\n    const options = {\n      method: mapping.method,\n      cache: \'force-cache\',\n      referrer: \'https://example.com\',\n      headers: mapping.headers,\n      credentials: mapping.credentials,\n      redirect: mapping.redirect,\n      mode: mapping.mode,\n      body: mapping.body\n    }\n\n    if (mapping.url.match(/private/)) {\n      options.headers[\'X-Api-Token\'] = getPrivateToken()\n    }\n\n    if (mapping.url.match(/listOfServers.json$/)) {\n      options.integrity = \'sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=\'\n    }\n\n    return new Request(urlJoin(baseUrl, mapping.url), options)\n  }\n})\n\n// ProfileComponent.js\nimport connect from \'./api-connector\'\nconnect(props => ({\n  userFetch: `/users/${props.userId}`,\n  serversFetch: `/listOfServers.json`\n}))(Profile)\n```\n\nYou can also replace the `handleResponse` function, which takes a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response), and should return a Promise that resolves to the value of the response, or rejects based on the body, headers, status code, etc. You can use it, for example, to parse CSV instead of JSON:\n\n```jsx\n// api-connector.js\nimport { connect } from \'react-refetch\'\nimport { parse } from \'csv\'\n\nconst csvConnector = connect.defaults({\n  handleResponse: function (response) {\n    if (response.headers.get(\'content-length\') === \'0\' || response.status === 204) {\n      return\n    }\n\n    const csv = response.text()\n\n    if (response.status >= 200 && response.status < 300) {\n      return csv.then(text => new Promise((resolve, reject) => {\n        parse(text, (err, data) => {\n          if (err) { reject(err) }\n          resolve(data)\n        })\n      }))\n    } else {\n      return csv.then(cause => Promise.reject(new Error(cause)))\n    }\n  }\n})\n\ncsvConnector(props => ({\n  userFetch: `/users/${props.userId}.csv`\n}))(Profile)\n```\n\n### On changing the `fetch` and `Request` implementations\n\nThrough this same API it is possible to change the internal `fetch` and `Request` implementations. This could be useful for a number of reasons, such as precise control over requests or customisation that is not possible with either `buildRequest` or `handleResponse`.\n\nFor example, here\'s a simplistic implementation of a "caching fetch," which will cache the result of successful requests for a minute, regardless of headers:\n\n```jsx\nimport { connect } from \'react-refetch\'\n\nconst cache = new Map()\nfunction cachingFetch(input, init) {\n  const req = new Request(input, init)\n  const now = new Date().getTime()\n  const oneMinuteAgo = now - 60000\n  const cached = cache.get(req.url)\n\n  if (cached && cached.time < oneMinuteAgo) {\n    return new Promise(resolve => resolve(cached.response.clone()))\n  }\n\n  return fetch(req).then(response => {\n    cache.set(req.url, {\n      time: now,\n      response: response.clone()\n    })\n\n    return response\n  })\n}\n\nconnect.defaults({ fetch: cachingFetch })(props => ({\n  userFetch: `/users/${props.userId}`\n}))(Profile)\n```\n\nWhen using this feature, make sure to read the [`fetch` API and interface documentation](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) and all related topics. Notably, you need to keep in mind that the `body` of a `Response` can _only be consumed once_, so if you need to read it in your custom `fetch`, you also need to recreate a brand new `Response` (or a `.clone()` of the original one if you\'re not modifying the body) so React Refetch can work properly.\n\nThis is an _advanced feature_. Use existing declarative functionality wherever possible. Customise `buildRequest` or `handleResponse` if these can work instead. Please be aware that changing the `fetch` (or `Request`) implementation could conflict with built-in current or future functionality.\n\n## Unit Testing Connected Components\n\nFor unit testing components connected, a non-default export of the unconnected component can be exposed to allow unit tests to inject their own `PromiseState`(s) as props. This allows for unit tests to test both success and error scenarios without having to deal with mocking HTTP, timing of responses, or other details about how the `PromiseState`(s) is fulfilled -- instead, they can just focus on asserting that the component itself renders the `PromiseState`(s) correctly in various scenarios.\n\nThe recommended naming convention for the unconnected component is to prepend an underscore to the component name. For example, if there is a component called `Profile`, add a non-default export of `_Profile` before the default export with `connect`:\n\n```jsx\nclass Profile extends React.Component {\n  static propTypes = {\n    userFetch: PropTypes.instanceOf(PromiseState).isRequired,\n  }\n\n  render() {\n    const { userFetch } = this.props\n\n    if (userFetch.pending) {\n      return <LoadingAnimation/>\n    } else if (userFetch.rejected) {\n      return <ErrorBox error={userFetch.reason}/>\n    } else if (userFetch.fulfilled) {\n      return <User user={userFetch.value}/>\n    }\n  }\n}\n\nexport { Profile as _Profile }\n\nexport default connect(props => ({\n  userFetch: `/users/${props.userId}`\n}))(Profile)\n```\n\nNow, unit tests can use the static methods on `PromiseState` to inject their own `PromiseState`(s) as props. For example, here is a unit test using [Enzyme](https://github.com/airbnb/enzyme) to shallow render the unconnected `_Profile` and provides a pending `PromiseState` and asserts that the `LoadingAnimation` is present:\n\n```jsx\nconst c = shallow(\n  <_Profile\n    userFetch={PromiseState.create()}\n  />\n)\n\nexpect(wrapper.find(LoadingAnimation)).to.have.length(1)\n```\n\nSimilarly, the rejected and fulfilled cases can be tested:\n\n```jsx\nconst expectedError = new Error(\'boom\')\n\nconst c = shallow(\n  <_Profile\n    userFetch={PromiseState.reject(expectedError)}\n  />\n)\n\nexpect(c.find(ErrorBox).first().prop().error).toEqual(expectedError)\n```\n\n\n```jsx\nconst user = new User()\n\nconst c = shallow(\n  <_Profile\n    userFetch={PromiseState.resolve(user)}\n  />\n)\n\nexpect(wrapper.find(User)).to.have.length(1)\n```\n\n## Complete Example\n\nThis is a complex example demonstrating various feature at once:\n\n```jsx\nimport React, { Component, PropTypes } from \'react\'\nimport { connect, PromiseState } from \'react-refetch\'\n\nclass Profile extends React.Component {\n  static propTypes = {\n    params: PropTypes.shape({\n      userId: PropTypes.string.isRequired,\n    }).isRequired,\n    userFetch: PropTypes.instanceOf(PromiseState).isRequired\n    likesFetch: PropTypes.instanceOf(PromiseState).isRequired\n    updateStatus: PropTypes.func.isRequired\n    updateStatusResponse: PropTypes.instanceOf(PromiseState) // will not be set until after `updateStatus()` is called\n  }\n\n  render() {\n    const { userFetch, likesFetch } = this.props\n\n    // compose multiple PromiseStates together to wait on them as a whole\n    const allFetches = PromiseState.all([userFetch, likesFetch])\n\n    // render the different promise states\n    if (allFetches.pending) {\n      return <LoadingAnimation/>\n    } else if (allFetches.rejected) {\n      return <Error error={allFetches.reason}/>\n    } else if (allFetches.fulfilled) {\n      // decompose the PromiseState back into individual\n      const [user, likes] = allFetches.value\n      return (\n        <div>\n          <User data={user}/>\n          <Likes data={likes}/>\n        </div>\n      )\n    }\n\n    // call `updateStatus()` on button click\n    <button onClick={() => { this.props.updateStatus("Hello World")} }>Update Status</button>\n\n    if (updateStatusResponse) {\n      // render the different promise states, but will be `null` until `updateStatus()` is called\n    }\n  }\n}\n\n// declare the requests for fetching the data, assign them props, and connect to the component.\nexport default connect(props => {\n  return {\n    // simple GET from a URL injected as `userFetch` prop\n    // if `userId` changes, data will be refetched\n    userFetch: `/users/${props.params.userId}`,\n\n    // similar to `userFetch`, but using object syntax\n    // specifies a refresh interval to poll for new data\n    likesFetch: {\n      url: `/users/${props.userId}/likes`,\n      refreshInterval: 60000\n    },\n\n    // declaring a request as a function\n    // not immediately fetched, but rather bound to the `userId` prop and injected as `updateStatus` prop\n    // when `updateStatus` is called, the `status` is posted and the response is injected as `updateStatusResponse` prop.\n    updateStatus: status => ({\n      updateStatusResponse: {\n        url: `/users/${props.params.userId}/status`,\n        method: \'POST\',\n        body: status\n      }\n    })\n  }\n})(Profile)\n```\n\n## API Documentation\n\n- [`connect([mapPropsToRequestsToProps])`](https://github.com/heroku/react-refetch/blob/master/docs/api.md#connectmappropstorequeststoprops-options)\n- [`connect.defaults([newDefaults])`](https://github.com/heroku/react-refetch/blob/master/docs/api.md#connectdefaultsnewdefaults)\n- [`PromiseState(iterable)`](https://github.com/heroku/react-refetch/blob/master/docs/api.md#promisestate)\n\n## Support\n\nThis software is provided "as is", without warranty or support of any kind, express or implied. See [license](https://github.com/heroku/react-refetch/blob/master/LICENSE.md) for details.\n\n## License\n\n[MIT](https://github.com/heroku/react-refetch/blob/master/LICENSE.md)\n'