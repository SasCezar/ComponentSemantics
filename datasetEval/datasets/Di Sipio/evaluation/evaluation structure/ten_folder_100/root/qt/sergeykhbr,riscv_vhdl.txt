b'System-On-Chip template based on synthesizable processor compliant with the RISC-V architecture.\n=====================\n\nThis repository provides open source System-on-Chip implementation based on\n64-bits CPU "Rocket-chip" distributed under BSD license. SOC source files\neither include general set of peripheries, FPGA CADs projects files, own\nimplementation of the Windows/Linux debugger and several examples that help\nto run your firmware on almost any FPGA boards.\nSatellite Navigation (GPS/GLONASS/Galileo) modules were stubbed in this\nrepository and can be requested separately.\n\n\n## What is Rocket-chip and [RISC-V ISA](http://www.riscv.org)?\n\nRISC-V (pronounced "risk-five") is a new instruction set architecture (ISA)\nthat was originally designed to support computer architecture research and\neducation and is now set become a standard open architecture for industry\nimplementations under the governance of the RISC-V Foundation. RISC-V was\noriginally developed in the Computer Science Division of the EECS Department\nat the University of California, Berkeley.\n\nParameterized generator of the Rocket-chip can be found here:\n[https://github.com/ucb-bar](https://github.com/ucb-bar)\n\n## What is River CPU?\n\nIt\'s my own implementation of RISC-V ISA used in a several projects including\nthe multi-sytem Satellite Navigation receiver. It is great for an \nembedded applications with active usage of 64-bits computations (like DSP).  \n**River CPU** includes the following tools and features:\n\n1. Source code\n    - */debugger/cpu_fnc_plugin*  - Functional RISC-V CPU model.\n    - */debugger/cpu_sysc_plugin* - Precise SystemC RIVER CPU model.\n    - */rtl/riverlib*      -  synthesisable VHDL model of a 64-bit processor compliant with the RISC-V architecture.\n2. Floating Point Unit (FPU)\n3. Dual-Core configuration\n4. Advanced debugging features\n    - Test Access Points (TAPs) via Ethernet, UART and JTAG in one system.\n    - System Bus tracer\n    - Pipeline statistic (CPI, HW stacktrace) in a real-time on HW level.\n    - Plug\'n\'Play information\n5. Integration with GUI from the very beginning.\n\nYou can find several **demonstration videos**\n[here](https://github.com/sergeykhbr/riscv_vhdl/tree/master/debugger) of working with the \nDual-Core SoC on FPGA and with the emulated platforms.\n\nMy goal is to develop open source fault-tolerant processor with the user-friendly\nframework.\n\n## System-on-Chip structure\n\nSoC documentation in [.pdf](docs/riscv_vhdl_trm.pdf) and \n[.html](http://sergeykhbr.github.io/riscv_vhdl/) formats.\n\n![SOC top](docs/doxygen/pics/soc_top_v5.png)\n\n## Performance\n\nPerformance analysis is based on very compact\n[**Dhrystone v2.1. benchmark**](http://fossies.org/linux/privat/old/dhrystone-2.1.tar.gz/)\napplication available as the bare-metal test in *$(TOP)/example/dhrystone21*\nfolder and entirely ported into Zephyr shell (see animated gif below). Benchmark was executed\nwith enabled (-O0) and disabled (-O2) optimization to define HW and GCC-compiler advantages.\nAll sources are available and could be run on the simulator or on the \ndifferent FPGA targets.\n\nTarget             | Git tag | Dhrystone<br> per sec,<br> -O0 | Dhrystone<br> per sec,<br> -O2 | Information.\n-------------------|:-------:|:------------------------------:|:------------------------------:|:------------\nRISC-V simulator   | v6.0    | **65652.0** | **76719.0**   | Ubuntu GNU GCC 6.1.0 toolchain RV64IMA custom build\n"Rocket" CPU       | v6.0    | -           | **23999.0**   | GCC 6.1.0\n"River" CPU        | v6.0    | -           | **35121.0**   | GCC 6.1.0\nRISC-V simulator   | latest  | **76824.0** | **176469.0**  | *GCC 7.1.1* with the compressed instructions set\n"River" CPU        | latest  | **29440.0** | **89420.0**   | *GCC 7.1.1* with the compressed instructions set\nARM simulator      | latest  | **78451.0** | **162600.0**  | *arm-none-eabi-gcc 7.2.0*, ARM ISA only\nCortex-R5 ARM      | No      | **20561.0** | **42401.0**   | *arm-none-eabi-gcc 7.2.0*, custom FPGA system:<br> Single-Core, MPU enabled, **Caches disabled**\nCortex-R5 ARM      | No      | **54052.0** | **132446.0**  | *arm-none-eabi-gcc 7.2.0*, custom FPGA system:<br> Single-Core, MPU enabled, **Caches enabled**\nCortex-M3 Thumb2   | [arm_vhdl](https://github.com/sergeykhbr/arm_vhdl) | soon       | soon          | *arm-none-eabi-gcc 7.2.0*, custom FPGA system\n"LEON3" SPARC V8   | No      | **48229.0** | **119515.0**  | *sparc-elf-gcc 4.4.2*, custom FPGA system\n\nAccess to all memory banks and peripheries for all targets (including ARM and Leon3) is made \nin the same clock domain and always is\none clock (without wait-states). So, this benchmark \nresult (**Dhrystone per seconds**) shows performance of the CPU with integer \ninstructions and degradation of the CPI relative ideal (simulation) case.\n\nCPU         | Clocks-Per-Instruction,<br> CPI | Description.\n------------|:-------:|:------------------------------\nCortext-R5  | 1.22    | This is **dual-issue** processor capable to execute a pair of instructions per<br> one clock. It\'s a very good but quite expensive CPU.\nLEON3       | 1.5     | CPI information from [here](https://www.gaisler.com/index.php/products/simulators/tsim).\nRiver       | 1.9     | Free-to-use and highly customizable CPU. This result achieved with enabled 16 KB I-cache.\nCortex-M3   | soon    | RTL is under development.\n\n   **Since the tag \'v7.0\' RIVER CPU is the main processor in the system and all issues\n     related to Rocket-chip instance will be supported only by request.**\n\n## Repository structure\n\nThis repository consists of three sub-projects each in own subfolder:\n\n- **rtl** is the folder with VHDL/Verilog sources of the SOC\n  including synthesizable processors *"Rocket"* and *"River"* and peripheries. \n  Source code is portable on almost any FPGA is due to the fact that\n  technology dependant modules (like *PLL*, *IO-buffers* \n  etc) instantiated inside of "virtual" components \n  in a similar to Gailser\'s *[GRLIB](www.gailser.com)* way.  \n  Full SOC design without FPU occupies less than 5 % of FPGA resources (Virtex6). \n  *"Rocket-chip"* CPU itself is the modern **64-bits processor \n  with L1-cache, branch-predictor, MMU and virtualization support**.  \n  This sub-project also contains:\n    * *fw_images*: directory with the ROM images in HEX-format.\n    * *prj*: project files for different CADs (Xilinx ISE, ModelSim).\n    * *tb*: VHDL testbech of the full system and utilities.\n    * *bit_files*: Pre-built FPGA images for ML605 and KC705 boards.\n- **examples** folder contains several C-examples that could help start working\n  with the RISC-V system:\n    * *boot* is the code of the Boot Loader. It is also used for the SRAM \n      initialization with the FW image and it allows to run examples on\n      FPGA without using the debugger and external flash memory.\n    * *helloworld* the simplest example with UART output.\n    * *isrdemo* example with 1 second interrupt from timer and debug output.\n    * *zephyr* is ported on RISC-V 64-bits operation system.\n      Information about this Real-Time Operation System for Internet of\n      Things Devices provided by [Zephyr Project](https://www.zephyrproject.org/).\n      Early support for the Zephyr Project includes Intel Corporation,\n      NXP Semiconductors N.V., Synopsys, Inc. and UbiquiOS Technology Limited.\n- **debugger**. The last piece of the ready-to-use open HW/SW system is\n  [Software Debugger (C++)](http://sergeykhbr.github.io/riscv_vhdl/sw_debugger_api_link.html)\n  with the full system simulator available as a plug-in.\n  Debugger interacts with the target (FPGA or Software Simulator) \n  via [Ethernet](http://sergeykhbr.github.io/riscv_vhdl/eth_link.html)\n  using EDCL protocol over UDP. To provide this functionality SOC includes\n  [**10/100 Ethernet MAC with EDCL**](http://sergeykhbr.github.io/riscv_vhdl/eth_link.html)\n  and [**Debug Support Unit (DSU)**](http://sergeykhbr.github.io/riscv_vhdl/periphery_page_1.html)\n  devices on AMBA AXI4 bus.\n\n# Step I: Simple FPGA test.\n\nYou can use the pre-built FPGA image (for Xilinx ML605 or KC705 board) and any serial\nconsole application (*putty*, *screen* or other) to run Dhrystone v2.1 benchmark as \non the animated picture below.\n\n![Zephyr demo](docs/doxygen/pics/zephyr_demo.gif)\n\n1. Unpack and load file image *riscv_soc.bit* from */rtl/bit_files/* into FPGA board.\n2. Connect to serial port. I used standard console utility *screen* on Ubuntu.\n\n        $ sudo apt-get install screen\n        $ sudo screen /dev/ttyUSB0 115200\n\n3. Use button "*Center*" to reset FPGA system and reprint initial messages (or just press Enter):\n\nTo end the session, use *Ctrl-A*, *Shift-K*\n\n# Step II: Build and run Software models with GUI.\n\nAt this step we\'re going to build: functional models of CPU and peripheries,\nprecise SystemC model of \'River\' CPU and RISC-V Debugger with GUI\n(MS Visual Studio project for Windows is also available).  \nThis step **doesn\'t require any Hardware** and the final result will look as on\nthe following animated picture:\n\n![Debugger demo](docs/doxygen/pics/debugger_demo.gif)  \n\nThere\'s dependency of two others open source projects:\n\n* **[Qt-libraries](https://www.qt.io/download/)**\n* **[SystemC library](http://accellera.org/downloads/standards/systemc)**\n\n1. Download and install Qt-package (checked with version 5.7).\n2. Specify environment variable QT_PATH:\n\n        $ export QT_PATH=/home/install_dir/Qt5.7.0/5.7/gcc_64\n\n3. If you would like to run SystemC models download the systemc archive.\n4. Unpack and build sources:\n\n        $ tar -xvzf systemc-2.3.1a.tar.gz\n        $ cd systemc-2.3.1a\n        $ mkdir tmp\n        $ cd tmp\n        $ ./../configure --prefix=/home/user/systemc-2.3.1a/build\n        $ make\n        $ make install\n\n5. Specify environment variable SYSTEMC_PATH:\n\n        $ export SYSTEMC_PATH=/home/user/systemc-2.3.1a/build")\n\n   **Note: System Simulator supports blocking and non-blocking accesses to the simulated\n   devices. You can request additional information of how to connect your\n   SystemC device to this SoC.**  \n\n6. Build project:\n\n        $ cd debugger/makefiles\n        $ make\n\n7. In a case of successful build start desired configuration:\n\n        $ cd ../linuxbuild/bin\n\nStart Configuration        | Description\n---------------------------|-----------------\n$ ./_run_functional_sim.sh | Functional RISC-V Full System Model\n$ ./_run_systemc_sim.sh    | Use SystemC Precise Model of RIVER CPU\n$ ./_run_fpga_gui.sh       | FPGA board. Default port \'COM3\', TAP IP = 192.168.0.51\n\n**Note:** Specify correct serial port in the file *debugger/targets/fpga_gui.json* \n(COM3 -> ttyUSB0) if you run debugger on linux.\n\n**Note:** Instruction of how to connect FPGA board via\nEthernet your can find [here](http://sergeykhbr.github.io/riscv_vhdl/eth_link.html).  \nSimulation and Hardware targets use identical EDCL over UDP interface so that \n[Debugger](http://sergeykhbr.github.io/riscv_vhdl/sw_debugger_api_link.html) can work \nwith any target using the same set of commands.  \n\n**Debugger doesn\'t implement any specific interface for the simulation.\nDebugger uses only architectural access via TAP (EDCL over UDP) for all targets.**\n\n\n# Step III: Build FPGA image\n\nDefault VHDL configuration enables River CPU with full debug support.\n\n![River top](docs/doxygen/pics/river_top.png)\n\nYou can enable usage of "Rocket-chip" CPU instead of "River" disabling the\nconfiguration parameter in */rtl/work/config_common.vhd* \nCFG_COMMON_RIVER_CPU_ENABLE.\n\n1. Open ML605 project file for Xilinx ISE14.7 *prj/ml605/riscv_soc.xise*\n   or KC705 project file for Xilinx Vivado *prj/kc705/riscv_soc.xpr*.\n2. Edit configuration constants in file **work/config_common.vhd** if needed.\n   (Skip this step by default).\n3. Use *rtl/work/tb/riscv_soc_tb.vhd"* testbench file to verify\n   full system including *CPU*, *UART*, *Timers*, *Ethernet*, *GPIO* etc.\n4. Generate bit-file and load it into FPGA.\n\n\n# Step IV: How to build 64-bits Zephyr v1.6.0 for RISC-V or other custom firmware\n\nAs an example we\'re going to build two programs:\n\n* Zephyr OS kernel with ROM-image generation.\n* \'Hello world\' example. Then load it into the target using Debugger\'s command.\n\n## 1. Setup GCC toolchain\n\n  You can find step-by-step instruction of how to build your own\ntoolchain on [riscv.org](http://riscv.org/software-tools/). If you would like\nto use pre-build GCC binary files and libraries you can download it here:\n\n   GCC 7.1 from [SiFive](https://www.sifive.com/products/tools/) for Linux, Windows and macOS  \n   GCC 7.1 from [SysProgs](http://gnutoolchains.com/risc-v/) for Windows\n\nI\'m on transition stage to a new v7.0 release with implemented Compressed\ninstructions set (C-extensions). It will allow to use the latest GCC builds without modifications.\nSome fatal errors can be found during this time, sorry.\n\nPrevious obsolete GCC builds:\n\n* Upto release tag v6.0 was used\n   [Ubuntu GNU GCC 6.1.0 toolchain RV64IMA (204MB)](http://www.gnss-sensor.com/index.php?LinkID=1017)  \n\n* Upto release tag v3.1 was used\n   [Ubuntu GNU GCC 5.1.0 toolchain RV64IMA (256MB)](http://www.gnss-sensor.com/index.php?LinkID=1013)\n\nIf you would like to generate hex-file and use it for ROM initialization you can use\n*\'elf2hex\'* and *\'libfesvr.so\'* library from the GNU toolchain but I suggest to use my version\nof such tool *\'elf2raw64\'*. I\'ve put this binary into pre-built GCC archive \'gnu_toolchain-rv64/bin\'. \nIf *elf2raw64* conflicts with installed LIBC version re-build it from *examples/elf2raw64/makefiles*\ndirectory.\n\n## 2. Patch and build Zephyr OS v1.6.0 binary\n\n    $ mkdir zephyr_160\n    $ cd zephyr_160\n    $ git clone https://github.com/zephyrproject-rtos/zephyr.git\n    $ cd zephyr\n    $ git checkout tags/v1.6.0\n    $ cp ../../riscv_vhdl/zephyr/v1.6.0-riscv64-base.diff .\n    $ cp ../../riscv_vhdl/zephyr/v1.6.0-riscv64-exten.diff .\n    $ git apply v1.6.0-riscv64-base.diff\n    $ git apply v1.6.0-riscv64-exten.diff\n\nThe first patch adds base functionality for RISC-V 64-bits architecture.  \nThe second one extends it by adding Dhrystone 2.1. benchmark and\nMS Visual Studio target and maybe something else.\n\nBuild elf-file:\n\n    $ export ZEPHYR_BASE=/home/zephyr_160/zephyr\n    $ cd zephyr/samples/shell\n    $ make ARCH=riscv64 CROSS_COMPILE=/home/your_path/gnu-toolchain-rv64ima/bin/riscv64-unknown-elf- BOARD=riscv_gnss 2>&1 | tee _err.log\n\nCreate HEX-image for ROM initialization. I use own analog of the *elf2raw*\nutility named as *elf2raw64*. You can find it in GNU tools archive.\n\n    $ elf2raw64 outdir/riscv_gnss/zephyr.elf -h -f 262144 -l 8 -o fwimage.hex\n\nFlags:\n\n    -h        -- specify HEX format of the output file.\n    -f 262144 -- specify total ROM size in bytes.\n    -l 8      -- specify number of bytes in one line (AXI databus width). Default is 16.\n\nCopy *fwimage.hex* to rtl subdirectory\n\n    $ cp fwimage.hex ../../../rtl/fw_images\n\n## 3. Debug Zephyr kernel with debug symbols.\n\nUse the following debugger\'s console commands to load symbols information\nfrom elf-file:\n\n    riscv# loadelf zephyr.elf\n    riscv# loadelf zephyr.elf nocode\n\nThe second command loads debug information without target reprogramming.\n\n## 4. Build and run custom FW like \'Hello World\' example.\n\nBuild example:\n\n    $ cd /your_git_path/examples/helloworld/makefiles\n    $ make\n\nRun Risc-V Debugger application:\n\n    $ ./your_git_path/debugger/linuxbuild/bin/_run_functional_sim.sh\n\nLoad elf-file using debugger\'s console:\n\n    #riscv loadelf bin/helloworld\n\nYou should see something like:\n\n```\n    riscv# loadelf e:/helloworld\n    [loader0]: Loading \'.text\' section\n    [loader0]: Loading \'.eh_frame\' section\n    [loader0]: Loading \'.rodata.str1.8\' section\n    [loader0]: Loading \'.rodata\' section\n    [loader0]: Loading \'.data\' section\n    [loader0]: Loading \'.sdata\' section\n    [loader0]: Loading \'.sbss\' section\n    [loader0]: Loading \'.bss\' section\n    [loader0]: Loaded: 42912 B\n```\n\nJust after image loading has been finished debugger clears reset CPU signal.\nStart the simulation manually (F5) if the processor was in \'halt\' state.  \nThis example prints only once UART message *\'Hello World - 1\'*,\nso if you\'d like to repeat test reload image using **loadelf** command.\n\nNow we can also generate HEX-file for ROM initialization to do that\nsee other example with **bootrom** implementation\n\n    $ cd examples/boot/makefiles\n    $ make\n    $ cd ../linuxbuild/bin\n\nOpened directory contains the following files:\n- _bootimage_       - elf-file (not used by SOC).\n- _bootimage.dump_  - disassembled file for the verification.\n- *_bootimage.hex_* - HEX-file for the Boot ROM intialization.\n\nYou can also check *bootimage.hex* and memory dump for consistence:\n\n    #riscv dump 0 8192 dump.hex hex\n\nI hope your also have run firmware on RISC-V system successfully.\n\nMy usual FPGA setup is ML605 board and debugger that is running on Windows 7\nfrom Visual Studio project, so other target configurations (linux + KC705)\ncould contain errors that are fixing with a small delay. Let me know if see one.\n\n## 5. Example of debug session with RF front-end and GNSS IPs on ML605 board.\n\n![GUI gnss](docs/doxygen/pics/dbg_gnss.png)\n\n\n## Versions History\n\n### Implemented functionality (v6.0)\n\n- GNSS IPs successfully integrated into RISC-V based SoC.\n- Add Test Access (TAP) over Serial port.\n- Add GUI integration with Open Street Maps and position tracking.\n- Add performance analisys tool into GUI.\n\n### Implemented functionality (v5.1)\n\n- "RIVER" critical bugs fixed:Not decoded  SRAI instrucion, missed exception generation.\n- Zephyr v1.6.0 ported with *unikernel* instead of the obsolete *nanokernel*.\n\n### Implemented functionality (v5.0)\n\n- New CPU implemented ("RIVER").\n- "Rocket-chip" CPU updated to date 18 Jan 2017. TileLink interface was totally redesigned.\n- SystemC support was added with the precise CPU model and VCD-stimulus generator.\n- Debugger functionality is now oriented only on RIVER implementation\n  and includes a lot of new features: breakpoints, disassembler,\n  CPI meter and others.\n- AXI bus controller significantly improved\n\n### Implemented functionality (v4.0)\n\n- Support new revision of User-Level ISA Spec. 2.1 and Privileged spec. 1.9.\n- FW will be binary incompatible with the previous Rocket-chip CPU (changed CSR\'s \nindexes, instruction ERET removed, new set of instructions xRET was added etc).\n- GCC versions (5.x) becomes obsolete.\n- FPU enabled by default and pre-built GCC 6.x with --hard-float provided.\n- HostIO bus removed.\n- HW Debug capability significantly affetcted by new DebugUnit, but Simulation\nsignificantly improved.\n- Updated bootloader and FW will become available soon.\n\n### Implemented functionality (v3.1)\n\nTo get branch *v3.1* use the following git command:\n\n    $ git clone -b v3.1 https://github.com/sergeykhbr/riscv_vhdl.git\n\nThis is the last revision of the RISC-V SOC based on ISA version 1.9.\nAll afterwards updates will be **binary incompatible** with this tag.\nTag v3.1 adds:\n\n- New Zephyr Kernel with the shell autocompletion.\n- Significantly updated GUI of the debugger.\n\n**Use tag v3.1 and GCC 5.1.0 instead of latest revision while release v4.0\nwon\'t ready. GCC 6.1.0 and 5.1.0 are binary incompatible either as SoC itself!**\n\n\n### Implemented functionality (v3.0)\n\nTo get branch *v3.0* use the following git command:\n\n    $ git clone -b v3.0 https://github.com/sergeykhbr/riscv_vhdl.git\n\n- Ported open source Real-Time Operation System for Internet of Things\n  Devices provided by [Zephyr Project](https://www.zephyrproject.org/).\n- Benchmark *Dhrystone v2.1* run on FPGA and Simulator with published results.\n- Testmode removed. *\'gnsslib\'* fully disabled.\n- Graphical User Interface (GUI) for the debugger based on QT-libraries\n  with significantly increasing of the debugger functionality.\n\n### Implemented functionality (v2.0)\n\nTo get branch *v2.0* use the following git command:\n\n    $ git clone -b v2.0 https://github.com/sergeykhbr/riscv_vhdl.git\n\nThis release add to following features to *v1.0*:\n\n- *Debug Support Unit* (DSU) for the access to all CPU registers (CSRs).\n- *10/100 Ethernet MAC with EDCL* that allows to debug processor from the\n  reset vector redirecting UDP requests directly on system bus.\n- GNSS engine and RF-mezzanine card support.\n- **Test Mode** (DIP[0]=1) that allows to use SOC with or without\n  *RF-mezzanine card*.\n- Master/Slave AMBA AXI4 interface refactoring.\n- *Debugger Software (C++)* for Windows and Linux with built-in simulator \n  and plugins support.\n- Portable asynchronous FIFO implementation allowing to connect modules to the\n  System BUS from a separate clock domains (ADC clock domain):\n- A lot of system optimizations.\n\n\n### Implemented functionality (v1.0)\n\nThe initial *v1.0* release provides base SOC functionality with minimal\nset of peripheries. To get this version use:\n\n    $ git clone -b v1.0 https://github.com/sergeykhbr/riscv_vhdl.git\n\n- Proof-of-concept VHDL SOC based on Verilog generated core *"Rocket-chip"*.\n- Peripheries with AMBA AXI4 interfaces: GPIO, LEDs, UART, IRQ controller etc.\n- Plug\'n-Play support.\n- Configuration and constraint files for ML605 (Virtex6) and KC705 (Kintex7)\n  FPGA boards.\n- Bit-files for ML605 and KC705 boards.\n- Pre-built ROM images with the BootLoader and FW-image. FW-image is copied\n  into internal SRAM during boot-stage.\n- *"Hello World"* example.\n\n\n## Doxygen project documentation\n\n[http://sergeykhbr.github.io/riscv_vhdl/](http://sergeykhbr.github.io/riscv_vhdl/)\n'