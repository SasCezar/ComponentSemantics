b'picoweb\n=======\n\npicoweb is a "micro" web micro-framework (thus, "pico-framework") for\nradically unbloated web applications using radically unbloated Python\nimplementation, Pycopy, https://github.com/pfalcon/pycopy .\n\nFeatures:\n\n* Asynchronous from the start, using unbloated asyncio-like library\n  for Pycopy (`uasyncio <https://github.com/pfalcon/pycopy-lib/tree/master/uasyncio>`_).\n  This means that ``picoweb`` can process multiple concurrent requests\n  at the same time (using I/O and/or CPU multiplexing).\n* Small memory usage. Initial version required about 64K of heap for\n  a trivial web app, and since then, it was optimized to allow run\n  more or less realistic web app in ~36K of heap. More optimizations\n  on all the levels (Pycopy and up) are planned (but may lead to\n  API changes).\n* Has API affinity with some well-known Python web micro-framework(s),\n  thus it should be an easy start if you have experience with them, and\n  existing applications can be potentially ported, instead of requiring\n  complete rewrite.\n\n\nRequirements and optional modules\n---------------------------------\n\n``picoweb`` depends on ``uasyncio`` for asynchronous networking\n(https://github.com/pfalcon/pycopy-lib/tree/master/uasyncio).\n``uasyncio`` itself requires `Pycopy <https://github.com/pfalcon/pycopy>`,\na minimalist, lightweight, and resource-efficient Python language\nimplementation.\n\nIt is also indended to be used with ``utemplate``\n(https://github.com/pfalcon/utemplate) for templating, but this is\na "soft" dependency - picoweb offers convenience functions to use\n``utemplate`` templates, but if you don\'t use them or will handle\ntemplating in your app (e.g. with a different library), it won\'t be\nimported.\n\nFor database access, there are following options (``picoweb`` does\nnot depend on any of them, up to your application to choose):\n\n* `btree <https://pycopy.readthedocs.io/en/latest/library/btree.html>`_\n  builtin Pycopy module. This is a recommended way to do a database\n  storage for `picoweb`, as it allows portability across all Pycopy\n  targets, starting with very memory- and storage-limited baremetal systems.\n* ``btreedb`` wrapper on top of ``btree`` builtin module. This may add some\n  overhead, but may allow to make an application portable between different\n  database backends (`filedb` and `uorm` below).\n  https://github.com/pfalcon/pycopy-btreedb\n* ``filedb``, for a simple database using files in a filesystem\n  https://github.com/pfalcon/filedb\n* ``uorm``, for Sqlite3 database access (works only with Pycopy\n  Unix port) https://github.com/pfalcon/uorm\n\nLast but not least, ``picoweb`` uses a standard ``logging``-compatible\nlogger for diagnostic output (like a connection opened, errors and debug\ninformation). However this output is optional, and otherwise you can use\na custom logging class instead of the standard ``logging``/``ulogging``\nmodule. Due to this, and to not put additional dependencies burden on\nthe small webapps for small systems, ``logging`` module is not included\nin ``picoweb``\'s installation dependencies. Instead, a particular app\nusing ``picoweb`` should depend on ``pycopy-ulogging`` or\n``pycopy-logging`` package. Note that to disable use of logging,\nan application should start up using ``WebApp.run(debug=-1)``. The\ndefault value for ``debug`` parameter is 0 however, in which case\npicoweb will use ``ulogging`` module (on which your application needs\nto depend, again).\n\n\nDetails\n-------\n\npicoweb API is roughly based on APIs of other well-known Python web\nframeworks. The strongest affinity is Flask, http://flask.pocoo.org, as\narguably the most popular micro-framework. Some features are also based on\nBottle and Django. Note that this does not mean particular "compatibility"\nwith Flask, Bottle, or Django: most existing web frameworks are synchronous\n(and threaded), while picoweb is async framework, so its architecture is\nquite different. However, there is an aim to save porting efforts from\nrepetitive search & replace trials: for example, when methods do similar\nthings, they are likely named the same (but they may take slightly different\nparameters, return different values, and behave slightly differently).\n\nThe biggest difference is async, non-threaded nature of picoweb. That means\nthat the same code may handle multiple requests at the same time, but unlike\nthreaded environment, there\'s no external context (like thread and thread\nlocal storage) to associate with each request. Thus, there\'re no "global"\n(or thread-local "global") request and response objects, like Flask,\nBottle, Django have. Instead, all picoweb functions explicitly pass the\ncurrent request and response objects around.\n\nAlso, picoweb, being unbloated framework, tries to avoid avoidable\nabstractions. For example, HTTP at the lowest level has just read and write\nendpoints of a socket. To dispatch request, picoweb needs to pre-parse\nsome request data from input stream, and it saves that partially (sic!)\nparsed data as a "request" object, and that\'s what passed to application\nhandlers. However, there\'s no unavoidable need to have a "response"\nabstraction - the most efficient/lightweight application may want to\njust write raw HTTP status line, headers, and body to the socket. Thus,\nraw write stream is passed to application handlers as the "response" object.\n(But high-level convenience functions to construct an HTTP response are\nprovided).\n\nLast point is questionable conveniences. For example, both Flask and Bottle\nprovide special objects to handle form/get parameters, with features\nlike "if request variable has only one value, the value is returned directly;\notherwise, list of values is returned".\n\n*<strike>However, Python standard library\nprovides function parse_qs(), which always returns array of values (based\non the fact that any request variable may have more than one value). Given\n2 choices, picoweb follows the interface of the standard library, instead of\nproviding extra wrapper class on top of it.</strike>* - Changed in 1.5: now\nnormal single-valued fields store the value directly, a list is used only\nfor multi-valued fields. (Reasons: convenience, reduced memory usage.)\n\n\nAPI reference\n-------------\n\nThe best API reference currently are examples (see below) and the ``picoweb``\nsource code itself. It\'s under 10K, so enjoy:\nhttps://github.com/pfalcon/picoweb/blob/master/picoweb/__init__.py\n\nNote that API is experimental and may undergo changes.\n\n\nExamples\n--------\n\n* `example_webapp.py <https://github.com/pfalcon/picoweb/blob/master/example_webapp.py>`_ -\n  A simple webapp showing you how to generate a complete HTTP response\n  yourself, use ``picoweb`` convenience functions for HTTP headers generation,\n  and use of templates. Mapping from URLs to webapp view functions ("web\n  routes" or just "routes") is done Django-style, using a centralized route\n  list.\n* `example_webapp2.py <https://github.com/pfalcon/picoweb/blob/master/example_webapp2.py>`_ -\n  Like above, but uses ``app.route()`` decorator for route specification,\n  Flask-style.\n* `examples/ <https://github.com/pfalcon/picoweb/tree/master/examples>`_ -\n  Additional examples for various features of picoweb. See comments in each\n  file for additional info. To run examples in this directory, you normally\n  would need to have picoweb installed (i.e. available in your ``MICROPYPATH``,\n  which defaults to ``~/.micropython/lib/``).\n* `notes-pico <https://github.com/pfalcon/notes-pico>`_ - A more realistic\n  example webapp, ported from the Flask original.\n\n\nRunning under CPython (regressed)\n---------------------------------\n\nInitial versions of picoweb could run under CPython, but later it was\nfurther optimized for Pycopy, and ability to run under CPython\nregressed. It\'s still on TODO to fix it, instructions below tell how\nit used to work.\n\nAt least CPython 3.4.2 is required (for asyncio loop.create_task() support).\nTo run under CPython, uasyncio compatibility module for CPython is required\n(pycopy-cpython-uasyncio). This and other dependencies can be installed\nusing requirements-cpython.txt::\n\n    pip install -r requirements-cpython.txt\n'