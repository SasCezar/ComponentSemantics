b'[![Build Status](https://travis-ci.org/tiangolo/uwsgi-nginx-flask-docker.svg?branch=master)](https://travis-ci.org/tiangolo/uwsgi-nginx-flask-docker)\n\n## Supported tags and respective `Dockerfile` links\n\n* [`python3.7`, `latest` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python3.7/Dockerfile)\n* [`python3.6` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python3.6/Dockerfile)\n* [`python3.6-index` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python3.6-index/Dockerfile)\n* [`python3.6-alpine3.7` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python3.6-alpine3.7/Dockerfile)\n* [`python3.6-alpine3.8` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python3.6-alpine3.8/Dockerfile)\n* [`python3.5` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python3.5/Dockerfile)\n* [`python3.5-index` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python3.5/Dockerfile)\n* [`python2.7` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python2.7/Dockerfile)\n* [`python2.7-index` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python2.7-index/Dockerfile)\n* [`python2.7-alpine3.7` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python2.7-alpine3.7/Dockerfile)\n* [`python2.7-alpine3.8` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python2.7-alpine3.8/Dockerfile)\n\n**Note**: Note: There are [tags for each build date](https://hub.docker.com/r/tiangolo/uwsgi-nginx-flask/tags). If you need to "pin" the Docker image version you use, you can select one of those tags. E.g. `tiangolo/uwsgi-nginx-flask:python3.7-2019-10-14`.\n\n## Temporarily not supported\n\n* [`python3.7-alpine3.7` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python3.7-alpine3.7/Dockerfile) and [`python3.7-alpine3.8` _(Dockerfile)_](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/python3.7-alpine3.8/Dockerfile) Temporarily not supported as uWSGI has not been released with Python 3.7 support for [Alpine 3.7](https://pkgs.alpinelinux.org/package/v3.7/main/x86/uwsgi-python3) nor for [Alpine 3.8](https://pkgs.alpinelinux.org/package/v3.8/main/x86/uwsgi-python3)\n\n# uwsgi-nginx-flask\n\n**Docker** image with **uWSGI** and **Nginx** for **Flask** web applications in **Python 3.7**, **Python 3.6**, **Python 3.5** and **Python 2.7** running in a single container. Optionally using Alpine Linux.\n\n## Description\n\nThis [**Docker**](https://www.docker.com/) image allows you to create [**Flask**](http://flask.pocoo.org/) web applications in [**Python**](https://www.python.org/) that run with [**uWSGI**](https://uwsgi-docs.readthedocs.org/en/latest/) and [**Nginx**](http://nginx.org/en/) in a single container.\n\nThe combination of uWSGI with Nginx is a [common way to deploy Python Flask web applications](http://flask.pocoo.org/docs/1.0/deploying/uwsgi/). It is widely used in the industry and would give you decent performance. (*)\n\nThere is also an Alpine version. If you want it, use one of the Alpine tags from above.\n\n### * Note on performance and features\n\nIf you are starting a new project, you might benefit from a newer and faster framework based on ASGI instead of WSGI (Flask and Django are WSGI-based).\n\nYou could use an ASGI framework like:\n\n* [**FastAPI**](https://github.com/tiangolo/fastapi) (which is based on Starlette) with this Docker image: [**tiangolo/uvicorn-gunicorn-fastapi**](https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker).\n* [**Starlette**](https://github.com/encode/starlette) directly, with this Docker image: [**tiangolo/uvicorn-gunicorn-starlette**](https://github.com/tiangolo/uvicorn-gunicorn-starlette-docker).\n\nFastAPI, or Starlette, would give you about 800% (8x) the performance achievable with Flask using this image (**tiangolo/uwsgi-nginx-flask**). [You can see the third-party benchmarks here](https://www.techempower.com/benchmarks/#section=test&runid=a979de55-980d-4721-a46f-77298b3f3923&hw=ph&test=fortune&l=zijzen-7).\n\nAlso, if you want to use new technologies like WebSockets it would be easier (and *possible*) with a newer framework based on ASGI, like FastAPI or Starlette. As the standard ASGI was designed to be able to handle asynchronous code like the one needed for WebSockets.\n\n#### If you need Flask\n\nIf you need to use Flask (instead of something based on ASGI) and you need to have the best performance possible, you can use the alternative image: [**tiangolo/meinheld-gunicorn-flask**](https://github.com/tiangolo/meinheld-gunicorn-flask-docker).\n\n**tiangolo/meinheld-gunicorn-flask** will give you about 400% (4x) the performance of this image (**tiangolo/uwsgi-nginx-flask**).\n\nIt is very similar to **tiangolo/uwsgi-nginx-flask**, so you can still use many of the ideas described here.\n\n---\n\n**GitHub repo**: [https://github.com/tiangolo/uwsgi-nginx-flask-docker](https://github.com/tiangolo/uwsgi-nginx-flask-docker)\n\n**Docker Hub image**: [https://hub.docker.com/r/tiangolo/uwsgi-nginx-flask/](https://hub.docker.com/r/tiangolo/uwsgi-nginx-flask/)\n\n## Examples (simple project templates)\n\n* **`python3.7`** tag: general Flask web application:\n\n[**example-flask-python3.7.zip**](<https://github.com/tiangolo/uwsgi-nginx-flask-docker/releases/download/v0.3.10/example-flask-python3.7.zip>)\n\n* **`python3.7`** tag: general Flask web application, structured as a package, for bigger Flask projects, with different submodules. Use it only as an example of how to import your modules and how to structure your own project:\n\n[**example-flask-package-python3.7.zip**](<https://github.com/tiangolo/uwsgi-nginx-flask-docker/releases/download/v0.3.10/example-flask-package-python3.7.zip>)\n\n* **`python3.7`** tag: `static/index.html` served directly in `/`, e.g. for [Vue](https://vuejs.org/), [React](https://reactjs.org/), [Angular](https://angular.io/), or any other Single-Page Application that uses a static `index.html`, not modified by Python:\n\n[**example-flask-python3.7-index.zip**](<https://github.com/tiangolo/uwsgi-nginx-flask-docker/releases/download/v0.3.10/example-flask-python3.7-index.zip>)\n\n## General Instructions\n\nYou don\'t have to clone this repo, you should be able to use this image as a base image for your project with something in your `Dockerfile` like:\n\n```Dockerfile\nFROM tiangolo/uwsgi-nginx-flask:python3.7\n\nCOPY ./app /app\n```\n\nThere are several image tags available for Python 3.7, Python 3.6, Python 3.5 and Python 2.7, but for new projects you should use **Python 3.7**.\n\nAs of now, [everyone](https://www.python.org/dev/peps/pep-0373/) [should be](http://flask.pocoo.org/docs/0.12/python3/#python3-support) [using **Python 3**](https://docs.djangoproject.com/en/1.11/faq/install/#what-python-version-should-i-use-with-django).\n\nThere are several template projects that you can download (as a `.zip` file) to bootstrap your project in the section "**Examples (project templates)**" above.\n\nThis Docker image is based on [**tiangolo/uwsgi-nginx**](https://hub.docker.com/r/tiangolo/uwsgi-nginx/). That Docker image has uWSGI and Nginx installed in the same container and was made to be the base of this image.\n\n## Quick Start\n\n**Note**: You can download the **example-flask-python3.7.zip** project example and use it as the template for your project from the section **Examples** above.\n\n---\n\nOr you may follow the instructions to build your project from scratch:\n\n* Go to your project directory\n* Create a `Dockerfile` with:\n\n```Dockerfile\nFROM tiangolo/uwsgi-nginx-flask:python3.7\n\nCOPY ./app /app\n```\n\n* Create an `app` directory and enter in it\n* Create a `main.py` file (it should be named like that and should be in your `app` directory) with:\n\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route("/")\ndef hello():\n    return "Hello World from Flask"\n\nif __name__ == "__main__":\n    # Only for debugging while developing\n    app.run(host=\'0.0.0.0\', debug=True, port=80)\n```\n\nthe main application object should be named `app` (in the code) as in this example.\n\n**Note**: The section with the `main()` function is for debugging purposes. To learn more, read the **Advanced instructions** below.\n\n* You should now have a directory structure like:\n\n```\n.\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.py\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 Dockerfile\n```\n\n* Go to the project directory (in where your `Dockerfile` is, containing your `app` directory)\n* Build your Flask image:\n\n```bash\ndocker build -t myimage .\n```\n\n* Run a container based on your image:\n\n```bash\ndocker run -d --name mycontainer -p 80:80 myimage\n```\n\n...and you have an optimized Flask server in a Docker container.\n\nYou should be able to check it in your Docker container\'s URL, for example: <a href="http://192.168.99.100" target="_blank">http://192.168.99.100</a> or <a href="http://127.0.0.1" target="_blank">http://127.0.0.1</a>\n\n## Project Generators\n\nThere are several project generators that you can use to start your project, with everything already configured.\n\n### Server set up\n\nAll these project generators include automatic and free HTTPS certificates generation provided by:\n\n* [Traefik](https://traefik.io/) and\n* [Let\'s Encrypt](https://letsencrypt.org/)\n\n...using the ideas from [DockerSwarm.rocks](https://dockerswarm.rocks).\n\nIt would take about 20 minutes to read that guide and have a Docker cluster (of one or more servers) up and running ready for your projects.\n\nYou can have several projects in the same cluster, all with automatic HTTPS, even if they have different domains or sub-domains.\n\n### Generate a project\n\nThen you can use one of the following project generators.\n\nIt would take about 5 extra minutes to generate one of these projects.\n\n### Deploy\n\nAnd it would take about 3 more minutes to deploy them in your cluster.\n\n---\n\nIn total, about 28 minutes to start from scratch and get an HTTPS Docker cluster with your full application(s) ready.\n\n---\n\nThese are the project generators:\n\n### flask-frontend-docker\n\nProject link: [https://github.com/tiangolo/flask-frontend-docker](https://github.com/tiangolo/flask-frontend-docker)\n\nMinimal project generator with a Flask backend, a modern frontend (Vue, React or Angular) using Docker multi-stage building and Nginx, a Traefik load balancer with HTTPS, Docker Compose (and Docker Swarm mode) etc.\n\n### full-stack\n\nProject Link: [https://github.com/tiangolo/full-stack](https://github.com/tiangolo/full-stack)\n\nFull stack project generator with Flask backend, PostgreSQL DB, PGAdmin, SQLAlchemy, Alembic migrations, Celery asynchronous jobs, API testing, CI integration, Docker Compose (and Docker Swarm mode), Swagger, automatic HTTPS, Vue.js, etc.\n\n### full-stack-flask-couchbase\n\nProject Link: [https://github.com/tiangolo/full-stack-flask-couchbase](https://github.com/tiangolo/full-stack-flask-couchbase)\n\n\xe2\x9c\xa8 This project generator is the most feature-complete. \xe2\x9c\xa8\n\nFull stack project generator with Flask backend, Couchbase, Couchbase Sync Gateway, Celery asynchronous jobs, API testing, CI integration, Docker Compose (and Docker Swarm mode), Swagger, automatic HTTPS, Vue.js, etc.\n\nSimilar to the one above (`full-stack`), but with Couchbase instead of PostgreSQL, and some more features.\n\n### full-stack-flask-couchdb\n\nProject Link: [https://github.com/tiangolo/full-stack-flask-couchdb](https://github.com/tiangolo/full-stack-flask-couchdb)\n\nFull stack project generator with Flask backend, CouchDB, Celery asynchronous jobs, API testing, CI integration, Docker Compose (and Docker Swarm mode), Swagger, automatic HTTPS, Vue.js, etc.\n\nSimilar to `full-stack-flask-couchbase`, but with CouchDB instead of Couchbase (or PostgreSQL).\n\n## Quick Start for SPAs *\n\n### Modern Single Page Applications\n\nIf you are building modern frontend applications (e.g. [Vue](https://vuejs.org/), [React](https://reactjs.org/), [Angular](https://angular.io/)) you would most probably be compiling a modern version of JavaScript (ES2015, TypeScript, etc) to a less modern, more compatible version.\n\nIf you want to serve your (compiled) frontend code by the same backend (Flask) Docker container, you would have to copy the code to the container after compiling it.\n\nThat means that you would need to have all the frontend tools installed on the building machine (it might be your computer, a remote server, etc).\n\nThat also means that you would have to, somehow, always remember to compile the frontend code right before building the Docker image.\n\nAnd it might also mean that you could then have to add your compiled frontend code to your `git` repository (hopefully you are using Git already, or [learning how to use `git`](https://www.atlassian.com/git)).\n\nAdding your compiled code to Git is a very bad idea for several reasons, some of those are:\n\n* You don\'t have a single, ultimate source of truth (the source code).\n* The compiled code might be stale, even when your source code is new, which might make you spend a lot of time debugging.\n* You might run into a lot of code conflicts when interacting with multiple team members with different Git branches, and spend a lot of time solving irrelevant code conflicts in the compiled code.\n    * This might also ruin automatic branch merging in pull requests from other team members.\n\nFor these reasons, it is not recommended that you serve your frontend code from the same backend (Flask) Docker container.\n\n### Better alternative\n\nThere\'s a much better alternative to serving your frontend code from the same backend (Flask) Docker container.\n\nYou can have another Docker container with all the frontend tools installed (Node.js, etc) that:\n\n* Takes your source frontend code.\n* Compiles it and generates the final "distributable" frontend.\n* Uses Docker "multi-stage builds" to copy that compiled code into a pure Nginx Docker image.\n* The final frontend image only contains the compiled frontend code, directly from the source, but has the small size of an Nginx image, with all the performance from Nginx.\n\nTo learn the specifics of this process for the frontend building in Docker you can read:\n\n* [React in Docker with Nginx, built with multi-stage Docker builds, including testing](https://medium.com/@tiangolo/react-in-docker-with-nginx-built-with-multi-stage-docker-builds-including-testing-8cc49d6ec305)\n* [Angular in Docker with Nginx, supporting configurations / environments, built with multi-stage Docker builds and testing with Chrome Headless](https://medium.com/@tiangolo/angular-in-docker-with-nginx-supporting-environments-built-with-multi-stage-docker-builds-bb9f1724e984)\n\nAfter having one backend (Flask) container and one frontend container, you need to serve both of them.\n\nAnd you might want to serve them under the same domain, under a different path. For example, the backend (Flask) app at the path `/api` and the frontend at the "root" path `/`.\n\nYou can then use [Traefik](https://traefik.io/) to handle that.\n\nAnd it can also automatically generate HTTPS certificates for your application using Let\'s Encrypt. All for free, in a very easy setup.\n\nIf you want to use this alternative, [check the project generators above](#project-generators), they all use this idea.\n\nIn this scenario, you would have 3 Docker containers:\n\n* Backend (Flask)\n* Frontend (Vue.js, Angular, React or any other)\n* Traefik (load balancer, HTTPS)\n\n### Deprecated Single Page Applications guide\n\nIf you want to check the previous (deprecated) documentation on adding a frontend to the same container, you can [read the deprecated guide for single page apps](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/deprecated-single-page-apps-in-same-container.md).\n\n## Quick Start for bigger projects structured as a Python package\n\n**Note**: You can download the **example-flask-package-python3.7.zip** project example and use it as an example or template for your project from the section **Examples** above.\n\n---\n\nYou should be able to follow the same instructions as in the "**QuickStart**" section above, with some minor modifications:\n\n* Instead of putting your code in the `app/` directory, put it in a directory `app/app/`.\n* Add an empty file `__init__.py` inside of that `app/app/` directory.\n* Add a file `uwsgi.ini` inside your `app/` directory (that is copied to `/app/uwsgi.ini` inside the container).\n* In your `uwsgi.ini` file, add:\n\n```ini\n[uwsgi]\nmodule = app.main\ncallable = app\n```\n\nThe explanation of the `uwsgi.ini` is as follows:\n\n* The module in where my Python web app lives is `app.main`. So, in the package `app` (`/app/app`), get the `main` module (`main.py`).\n* The Flask web application is the `app` object (`app = Flask(__name__)`).\n\nYour file structure would look like:\n\n```\n.\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 __init__.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 uwsgi.ini\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 Dockerfile\n```\n\n...instead of:\n\n```\n.\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n\xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.py\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 Dockerfile\n```\n\n...after that, everything should work as expected. All the other instructions would apply normally.\n\n### Working with submodules\n\n* After adding all your modules you could end up with a file structure similar to (taken from the example project):\n\n```\n.\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 api\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 api.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 endpoints\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 __init__.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 user.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 __init__.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 utils.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 core\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app_setup.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 database.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 __init__.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 __init__.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 models\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0     \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 __init__.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 user.py\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 uwsgi.ini\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 Dockerfile\n```\n\n* Make sure you follow [the official docs while importing your modules](https://docs.python.org/3/tutorial/modules.html#intra-package-references):\n\n* For example, if you are in `app/app/main.py` and want to import the module in `app/app/core/app_setup.py` you would write it like:\n\n```python\nfrom .core import app_setup\n```\n\nor\n\n```python\nfrom app.core import app_setup\n```\n\n* And if you are in `app/app/api/endpoints/user.py` and you want to import the `users` object from `app/app/core/database.py` you would write it like:\n\n```python\nfrom ...core.database import users\n```\n\nor\n\n```python\nfrom app.core.database import users\n```\n\n## Advanced instructions\n\nYou can customize several things using environment variables.\n\n### Serve `index.html` directly\n\n**Notice**: this technique is deprecated, as it can create several issues with modern frontend frameworks. For the details and better alternatives, read the section above.\n\nSetting the environment variable `STATIC_INDEX` to be `1` you can configure Nginx to serve the file in the URL `/static/index.html` when requested for `/`.\n\nThat would improve speed as it would not involve uWSGI nor Python. Nginx would serve the file directly. To learn more follow the section above "**QuickStart for SPAs**".\n\nFor example, to enable it, you could add this to your `Dockerfile`:\n\n```Dockerfile\nENV STATIC_INDEX 1\n```\n\n### Custom uWSGI process number\n\nBy default, the image starts with 2 uWSGI processes running. When the server is experiencing a high load, it creates up to 16 uWSGI processes to handle it on demand.\n\nIf you need to configure these numbers you can use environment variables.\n\nThe starting number of uWSGI processes is controlled by the variable `UWSGI_CHEAPER`, by default set to `2`.\n\nThe maximum number of uWSGI processes is controlled by the variable `UWSGI_PROCESSES`, by default set to `16`.\n\nHave in mind that `UWSGI_CHEAPER` must be lower than `UWSGI_PROCESSES`.\n\nSo, if, for example, you need to start with 4 processes and grow to a maximum of 64, your `Dockerfile` could look like:\n\n```Dockerfile\nFROM tiangolo/uwsgi-nginx-flask:python3.7\n\nENV UWSGI_CHEAPER 4\nENV UWSGI_PROCESSES 64\n\nCOPY ./app /app\n```\n\n### Max upload file size\n\nYou can set a custom maximum upload file size using an environment variable `NGINX_MAX_UPLOAD`, by default it has a value of `0`, that allows unlimited upload file sizes. This differs from Nginx\'s default value of 1 MB. It\'s configured this way because that\'s the simplest experience an inexperienced developer in Nginx would expect.\n\nFor example, to have a maximum upload file size of 1 MB (Nginx\'s default) add a line in your `Dockerfile` with:\n\n```Dockerfile\nENV NGINX_MAX_UPLOAD 1m\n```\n\n### Custom listen port\n\nBy default, the container made from this image will listen on port 80.\n\nTo change this behavior, set the `LISTEN_PORT` environment variable. You might also need to create the respective `EXPOSE` Docker instruction.\n\nYou can do that in your `Dockerfile`, it would look something like:\n\n```Dockerfile\nFROM tiangolo/uwsgi-nginx-flask:python3.7\n\nENV LISTEN_PORT 8080\n\nEXPOSE 8080\n\nCOPY ./app /app\n```\n\n### Custom `uwsgi.ini` configurations\n\nThere is a default file in `/app/uwsgi.ini` with app specific configurations (on top of the global `uwsgi` configurations).\n\nIt only contains:\n\n```ini\n[uwsgi]\nmodule = main\ncallable = app\n```\n\n* `module = main` refers to the file `main.py`.\n* `callable = app` refers to the `Flask` "application", in the variable `app`.\n\n---\n\nYou can customize `uwsgi` by replacing that file with your own, including all your configurations.\n\nFor example, to extend the default one above and enable threads, you could have a file:\n\n```ini\n[uwsgi]\nmodule = main\ncallable = app\nenable-threads = true\n```\n\n### Custom `uwsgi.ini` file location\n\nYou can override where the image should look for the app `uwsgi.ini` file using the envirnoment variable `UWSGI_INI`.\n\nWith that you could change the default directory for your app from `/app` to something else, like `/application`.\n\nFor example, to make the image use the file in `/application/uwsgi.ini`, you could add this to your `Dockerfile`:\n\n```Dockerfile\nENV UWSGI_INI /application/uwsgi.ini\n\nCOPY ./application /application\nWORKDIR /application\n```\n\n**Note**: the `WORKDIR` is important, otherwhise uWSGI will try to run the app in `/app`.\n\n**Note**: you would also have to configure the `static` files path, read below.\n\n### Custom `./static/` path\n\nYou can make Nginx use a custom directory path with the files to serve directly (without having uWSGI involved) with the environment variable `STATIC_PATH`.\n\nFor example, to make Nginx serve the static content using the files in `/app/custom_static/` you could add this to your `Dockerfile`:\n\n```Dockerfile\nENV STATIC_PATH /app/custom_static\n```\n\nThen, when the browser asked for a file in, for example, http://example.com/static/index.html, Nginx would answer directly using a file in the path `/app/custom_static/index.html`.\n\n**Note**: you would also have to configure Flask to use that as its `static` directory.\n\n---\n\nAs another example, if you needed to put your application code in a different directory, you could configure Nginx to serve those static files from that different directory.\n\nIf you needed to have your static files in `/application/static/` you could add this to your `Dockerfile`:\n\n```Dockerfile\nENV STATIC_PATH /application/static\n```\n\n### Custom `/static` URL\n\nYou can also make Nginx serve the static files in a different URL, for that, you can use the environment variable `STATIC_URL`.\n\nFor example, if you wanted to change the URL `/static` to `/content` you could add this to your `Dockerfile`:\n\n```Dockerfile\nENV STATIC_URL /content\n```\n\nThen, when the browser asked for a file in, for example, http://example.com/content/index.html, Nginx would answer directly using a file in the path `/app/static/index.html`.\n\n### Custom `/app/prestart.sh`\n\nIf you need to run anything before starting the app, you can add a file `prestart.sh` to the directory `/app`. The image will automatically detect and run it before starting everything.\n\nFor example, if you want to add Alembic SQL migrations (with SQLAlchemy), you could create a `./app/prestart.sh` file in your code directory (that will be copied by your `Dockerfile`) with:\n\n```bash\n#! /usr/bin/env bash\n\n# Let the DB start\nsleep 10;\n# Run migrations\nalembic upgrade head\n```\n\nand it would wait 10 seconds to give the database some time to start and then run that `alembic` command.\n\nIf you need to run a Python script before starting the app, you could make the `/app/prestart.sh` file run your Python script, with something like:\n\n```bash\n#! /usr/bin/env bash\n\n# Run custom Python script before starting\npython /app/my_custom_prestart_script.py\n```\n\n**Note**: The image uses `source` to run the script, so for example, environment variables would persist. If you don\'t understand the previous sentence, you probably don\'t need it.\n\n### Custom Nginx processes number\n\nBy default, Nginx will start one "worker process".\n\nIf you want to set a different number of Nginx worker processes you can use the environment variable `NGINX_WORKER_PROCESSES`.\n\nYou can use a specific single number, e.g.:\n\n```Dockerfile\nENV NGINX_WORKER_PROCESSES 2\n```\n\nor you can set it to the keyword `auto` and it will try to auto-detect the number of CPUs available and use that for the number of workers.\n\nFor example, using `auto`, your Dockerfile could look like:\n\n```Dockerfile\nFROM tiangolo/uwsgi-nginx-flask:python3.7\n\nENV NGINX_WORKER_PROCESSES auto\n\nCOPY ./app /app\n```\n\n### Custom Nginx maximum connections per worker\n\nBy default, Nginx will start with a maximum limit of 1024 connections per worker.\n\nIf you want to set a different number you can use the environment variable `NGINX_WORKER_CONNECTIONS`, e.g:\n\n```Dockerfile\nENV NGINX_WORKER_CONNECTIONS 2048\n```\n\nIt cannot exceed the current limit on the maximum number of open files. See how to configure it in the next section.\n\n### Custom Nginx maximum open files\n\nThe number connections per Nginx worker cannot exceed the limit on the maximum number of open files.\n\nYou can change the limit of open files with the environment variable `NGINX_WORKER_OPEN_FILES`, e.g.:\n\n```Dockerfile\nENV NGINX_WORKER_OPEN_FILES 2048\n```\n\n### Customizing Nginx additional configurations\n\nIf you need to configure Nginx further, you can add `*.conf` files to `/etc/nginx/conf.d/` in your `Dockerfile`.\n\nJust have in mind that the default configurations are created during startup in a file at `/etc/nginx/conf.d/nginx.conf` and `/etc/nginx/conf.d/upload.conf`. So you shouldn\'t overwrite them. You should name your `*.conf` file with something different than `nginx.conf` or `upload.conf`, for example: `custom.conf`.\n\n**Note**: if you are customizing Nginx, maybe copying configurations from a blog or a StackOverflow answer, have in mind that you probably need to use the [configurations specific to uWSGI](http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html), instead of those for other modules, like for example, `ngx_http_fastcgi_module`.\n\n### Overriding Nginx configuration completely\n\nIf you need to configure Nginx even further, completely overriding the defaults, you can add a custom Nginx configuration to `/app/nginx.conf`.\n\nIt will be copied to `/etc/nginx/nginx.conf` and used instead of the generated one.\n\nHave in mind that, in that case, this image won\'t generate any of the Nginx configurations, it will only copy and use your configuration file.\n\nThat means that all the environment variables described above that are specific to Nginx won\'t be used.\n\nIt also means that it won\'t use additional configurations from files in `/etc/nginx/conf.d/*.conf`, unless you explicitly have a section in your custom file `/app/nginx.conf` with:\n\n```conf\ninclude /etc/nginx/conf.d/*.conf;\n```\n\nIf you want to add a custom `/app/nginx.conf` file but don\'t know where to start from, you can use [the `nginx.conf` used for the tests](https://github.com/tiangolo/uwsgi-nginx-flask-docker/blob/master/tests/test_02_app/custom_nginx_app/app/nginx.conf) and customize it or modify it further.\n\n## Technical details\n\nThe combination of uWSGI with Nginx is a [common way to deploy Python Flask web applications](http://flask.pocoo.org/docs/1.0/deploying/uwsgi/).\n\nRoughly:\n\n* **Nginx** is a web server, it takes care of the HTTP connections and also can serve static files directly and more efficiently.\n\n* **uWSGI** is an application server, that\'s what runs your Python code and it talks with Nginx.\n\n* **Your Python code** has the actual **Flask** web application, and is run by uWSGI.\n\nThe image [**tiangolo/uwsgi-nginx**](https://hub.docker.com/r/tiangolo/uwsgi-nginx/) takes advantage of already existing slim and optimized Docker images (based on Debian as [recommended by Docker](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/)) and implements several of Docker\'s best practices.\n\nIt uses the official Python Docker image, installs uWSGI and on top of that (with the least amount of modifications) adds the official Nginx image.\n\nAnd it controls all these processes with Supervisord.\n\nThe image (and tags) created by this repo is based on the image [**tiangolo/uwsgi-nginx**](https://hub.docker.com/r/tiangolo/uwsgi-nginx/). This image adds Flask and sensible defaults on top of it.\n\nIf you follow the instructions and keep the root directory `/app` in your container, with a file named `main.py` and a Flask object named `app` in it, it should "just work".\n\nThere\'s already a `uwsgi.ini` file in the `/app` directory with the uWSGI configurations for it to "just work". And all the other required parameters are in another `uwsgi.ini` file in the image, inside `/etc/uwsgi/`.\n\nIf you need to change the main file name or the main Flask object, you would have to provide your own `uwsgi.ini` file. You may use the one in this repo as a template to start with (and you only would have to change the 2 corresponding lines).\n\nYou can have a `/app/static` directory and those files will be efficiently served by Nginx directly (without going through your Flask code or even uWSGI), it\'s already configured for you. But you can configure it further using environment variables (read above).\n\nSupervisord takes care of running uWSGI with the `uwsgi.ini` file in `/app` file (including also the file in `/etc/uwsgi/uwsgi.ini`) and starting Nginx.\n\n---\n\nThere\'s the rule of thumb that you should have "one process per container".\n\nThat helps, for example, isolating an app and its database in different containers.\n\nBut if you want to have a "micro-services" approach you may want to [have more than one process in one container](https://valdhaus.co/writings/docker-misconceptions/) if they are all related to the same "service", and you may want to include your Flask code, uWSGI and Nginx in the same container (and maybe run another container with your database).\n\nThat\'s the approach taken in this image.\n\n---\n\nThis image (and tags) have some default files, so if you run it by itself (not as the base image of your own project) you will see a default "Hello World" web app.\n\nWhen you build a `Dockerfile` with a `COPY ./app /app` you replace those default files with your app code.\n\nThe main default file is only in `/app/main.py`. And in the case of the tags with `-index`, also in `/app/static/index.html`.\n\nBut those files render a "(default)" text in the served web page, so that you can check if you are seeing the default code or your own code overriding the default.\n\nYour app code should be in the container\'s `/app` directory, it should have a `main.py` file and that `main.py` file should have a Flask object `app`.\n\nIf you follow the instructions above or use one of the downloadable example templates, you should be OK.\n\nThere is also a `/app/uwsgi.ini` file inside the images with the default parameters for uWSGI.\n\nThe downloadable examples include a copy of the same `uwsgi.ini` file for debugging purposes. To learn more, read the "**Advanced development instructions**" below.\n\n## Advanced development instructions\n\nWhile developing, you might want to make your code directory a volume in your Docker container.\n\nWith that you would have your files (temporarily) updated every time you modify them, without needing to build your container again.\n\nTo do this, you can use the command `pwd` (print working directory) inside your `docker run` and the flag `-v` for volumes.\n\nWith that you could map your `./app` directory to your container\'s `/app` directory.\n\nBut first, as you will be completely replacing the directory `/app` in your container (and all of its contents) you will need to have a `uwsgi.ini` file in your `./app` directory with:\n\n```ini\n[uwsgi]\nmodule = main\ncallable = app\n```\n\nand then you can do the Docker volume mapping.\n\n**Note**: A `uwsgi.ini` file is included in the downloadable examples.\n\n* To try it, go to your project directory (the one with your `Dockerfile` and your `./app` directory)\n* Make sure you have a `uwsgi.ini` file in your `./app` directory\n* Build your Docker image:\n\n```bash\ndocker build -t myimage .\n```\n\n* Run a container based on your image, mapping your code directory (`./app`) to your container\'s `/app` directory:\n\n```bash\ndocker run -d --name mycontainer -p 80:80 -v $(pwd)/app:/app myimage\n```\n\nIf you go to your Docker container URL you should see your app, and you should be able to modify files in `./app/static/` and see those changes reflected in your browser just by reloading.\n\n...but, as uWSGI loads your whole Python Flask web application once it starts, you won\'t be able to edit your Python Flask code and see the changes reflected.\n\nTo be able to (temporarily) debug your Python Flask code live, you can run your container overriding the default command (that starts Supervisord which in turn starts uWSGI and Nginx) and run your application directly with `python`, in debug mode, using the `flask` command with its environment variables.\n\nSo, with all the modifications above and making your app run directly with `flask`, the final Docker command would be:\n\n ```bash\ndocker run -d --name mycontainer -p 80:80 -v $(pwd)/app:/app -e FLASK_APP=main.py -e FLASK_DEBUG=1 myimage flask run --host=0.0.0.0 --port=80\n```\n\nOr in the case of a package project, you would set `FLASK_APP=main/main.py`:\n\n```bash\ndocker run -d --name mycontainer -p 80:80 -v $(pwd)/app:/app -e FLASK_APP=main/main.py -e FLASK_DEBUG=1 myimage flask run --host=0.0.0.0 --port=80\n```\n\nNow you can edit your Flask code in your local machine and once you refresh your browser, you will see the changes live.\n\nRemember that you should use this only for debugging and development, for deployment in production you shouldn\'t mount volumes and you should let Supervisord start and let it start uWSGI and Nginx (which is what happens by default).\n\nAn alternative for these last steps to work when you don\'t have a package, but just a flat structure with single files (modules), your Python Flask code could have that section with:\n\n```python\nif __name__ == "__main__":\n   # Only for debugging while developing\n   app.run(host=\'0.0.0.0\', debug=True, port=80)\n```\n\n...and you could run it with `python main.py`. But that will only work when you are not using a package structure and don\'t plan to do it later. In that specific case, if you didn\'t add the code block above, your app would only listen to `localhost` (inside the container), in another port (5000) and not in debug mode.\n\n**Note**: The example project **example-flask-python3.7** includes a `docker-compose.yml` and `docker-compose.override.yml` with all these configurations, if you are using Docker Compose.\n\n---\n\nAlso, if you want to do the same live debugging using the environment variable `STATIC_INDEX=1` (to serve `/app/static/index.html` directly when requested for `/`) your Nginx won\'t serve it directly as it won\'t be running (only your Python Flask app in debug mode will be running).\n\n```python\nfrom flask import Flask, send_file\n```\n\nand\n\n```python\n@app.route(\'/\')\ndef route_root():\n    index_path = os.path.join(app.static_folder, \'index.html\')\n    return send_file(index_path)\n```\n\n...that makes sure your app also serves the `/app/static/index.html` file when requested for `/`. Or if you are using a package structure, the `/app/main/static/index.html` file.\n\nAnd if you are using a SPA framework, to allow it to handle the URLs in the browser, your Python Flask code should have the section with:\n\n```python\n# Everything not declared before (not a Flask route / API endpoint)...\n@app.route(\'/<path:path>\')\ndef route_frontend(path):\n    # ...could be a static file needed by the front end that\n    # doesn\'t use the `static` path (like in `<script src="bundle.js">`)\n    file_path = os.path.join(app.static_folder, path)\n    if os.path.isfile(file_path):\n        return send_file(file_path)\n    # ...or should be handled by the SPA\'s "router" in front end\n    else:\n        index_path = os.path.join(app.static_folder, \'index.html\')\n        return send_file(index_path)\n```\n\n...that makes Flask send all the CSS, JavaScript and image files when requested in the root (`/`) URL but also makes sure that your frontend SPA handles all the other URLs that are not defined in your Flask app.\n\nThat\'s how it is written in the tutorial above and is included in the downloadable examples.\n\n**Note**: The example project **example-flask-python3.7-index** includes a `docker-compose.yml` and `docker-compose.override.yml` with all these configurations, if you are using Docker Compose.\n\n## More advanced development instructions\n\nIf you follow the instructions above, it\'s probable that at some point, you will write code that will break your Flask debugging server and it will crash.\n\nAnd since the only process running was your debugging server, that now is stopped, your container will stop.\n\nThen you will have to start your container again after fixing your code and you won\'t see very easily what is the error that is crashing your server.\n\nSo, while developing, you could do the following (that\'s what I normally do, although I do it with Docker Compose, as in the example projects):\n\n* Make your container run and keep it alive in an infinite loop (without running any server):\n\n```bash\ndocker run -d --name mycontainer -p 80:80 -v $(pwd)/app:/app -e FLASK_APP=main.py -e FLASK_DEBUG=1 myimage bash -c "while true ; do sleep 10 ; done"\n```\n\n* Or, if your project is a package, set `FLASK_APP=main/main.py`:\n\n```bash\ndocker run -d --name mycontainer -p 80:80 -v $(pwd)/app:/app -e FLASK_APP=main/main.py -e FLASK_DEBUG=1 myimage bash -c "while true ; do sleep 10 ; done"\n```\n\n* Connect to your container with a new interactive session:\n\n```bash\ndocker exec -it mycontainer bash\n```\n\nYou will now be inside your container in the `/app` directory.\n\n* Now, from inside the container, run your Flask debugging server:\n\n```bash\nflask run --host=0.0.0.0 --port=80\n```\n\nYou will see your Flask debugging server start, you will see how it sends responses to every request, you will see the errors thrown when you break your code, and how they stop your server, and you will be able to re-start it very fast, by just running the command above again.\n\n## Release Notes\n\n### Latest Changes\n\n### 1.2.0\n\n* Refactor tests to use env vars and add image tags for each build date, like `tiangolo/uwsgi-nginx-flask:python3.7-2019-10-14`. PR [#154](https://github.com/tiangolo/uwsgi-nginx-flask-docker/pull/154).\n* Upgrade Travis. PR [#135](https://github.com/tiangolo/uwsgi-nginx-flask-docker/pull/135).\n\n### 1.1.0\n\n* Move `/start.sh` and `/app/prestart.sh` functionality to parent image. [PR #134](https://github.com/tiangolo/uwsgi-nginx-flask-docker/pull/134).\n\n### 1.0.0\n\n2019-02-02:\n\n* The Nginx configurations are generated dynamically from the entrypoint, instead of modifying pre-existing files. [PR #50 in the parent image `uwsgi-nginx`](https://github.com/tiangolo/uwsgi-nginx-docker/pull/50) and [PR #121](https://github.com/tiangolo/uwsgi-nginx-flask-docker/pull/121).\n* Support for a completely custom `/app/nginx.conf` file that overrides the generated one. [PR #51 in the parent image `uwsgi-nginx`](https://github.com/tiangolo/uwsgi-nginx-docker/pull/51) and [PR #122](https://github.com/tiangolo/uwsgi-nginx-flask-docker/pull/122).\n\n2019-01-01:\n\n* Improved guide for single page applications.\n* Links to project generators.\n\n2018-12-29:\n\n* Travis integration, images built and pushed by Travis.\n* Fixes in parent image for Nginx.\n\n2018-11-23:\n\n* New Alpine 3.8 images for Python 2.7, Python 3.6 and (temporarily disabled) Python 3.7.\n\n2018-09-22:\n\n* New Python 3.7 images, based on standard Debian and Alpine Linux. All the documentation and project templates have been updated to use Python 3.7 by default. Thanks to [desaintmartin](https://github.com/desaintmartin) in [this PR](https://github.com/tiangolo/uwsgi-nginx-flask-docker/pull/82).\n\n2018-06-22:\n\n* You can now use `NGINX_WORKER_CONNECTIONS` to set the maximum number of Nginx worker connections and `NGINX_WORKER_OPEN_FILES` to set the maximum number of open files. Thanks to [ronlut](https://github.com/ronlut) in [this PR](https://github.com/tiangolo/uwsgi-nginx-flask-docker/pull/56).\n\n2018-06-22:\n\nImprovements from parent image:\n\n* Make uWSGI require an app to run, instead of going in "full dynamic mode" while there was an error. Supervisord doesn\'t terminate itself but tries to restart uWSGI and shows the errors. Uses `need-app` as suggested by [luckydonald](https://github.com/luckydonald) in [this comment](https://github.com/tiangolo/uwsgi-nginx-flask-docker/issues/3#issuecomment-321991279).\n\n* Correctly handled graceful shutdown of uWSGI and Nginx. Thanks to [desaintmartin](https://github.com/desaintmartin) in [this PR](https://github.com/tiangolo/uwsgi-nginx-docker/pull/30).\n\n2018-02-04:\n\nIt\'s now possible to set the number of Nginx worker processes with the environment variable `NGINX_WORKER_PROCESSES`. Thanks to [naktinis](https://github.com/naktinis) in [this PR](https://github.com/tiangolo/uwsgi-nginx-docker/pull/22).\n\n2018-01-14:\n\n* There are now two Alpine based versions, `python2.7-alpine3.7` and `python3.6-alpine3.7`.\n\n2017-12-10:\n\n* Added support for `/app/prestart.sh` script to run arbitrary code before starting the app (for example, Alembic - SQLAlchemy migrations). The [documentation for the `/app/prestart.sh` is in the main README](https://github.com/tiangolo/uwsgi-nginx-flask-docker#custom-appprestartsh).\n* `/app` is part of the `PYTHONPATH` environment variable. That allows global imports from several places, easier Alembic integration, etc.\n\n2017-12-08: Now you can configure which port the container should listen on, using the environment variable `LISTEN_PORT` thanks to [tmshn](https://github.com/tmshn) in [this PR](https://github.com/tiangolo/uwsgi-nginx-docker/pull/16).\n\n2017-09-10: Updated examples and sample project to work with SPAs even when structuring the app as a package (with subdirectories).\n\n2017-09-02:\n\n* Example project with a [Python package](https://docs.python.org/3/tutorial/modules.html#packages) structure and a section explaining how to use it and structure a Flask project like that.\n* Also, the examples and documentation now use the [`flask run`](http://flask.pocoo.org/docs/0.12/quickstart/#a-minimal-application) commands, that allows running a package application while developing more easily.\n\n2017-08-10: Many changes:\n\n* New official image tags: `python3.6`, `python3.6-index`, `python.3.5`, `python3.5-index`, `python2.7` and `python2.7-index`. All the other images are deprecated in favor is this ones.\n* Python 3.6 is now the recommended default. Even the example projects for other versions were removed to discourage using older Python versions for new projects.\n* Any of the older images that didn\'t have a Python version will show a deprecation warning and take some time to start. As soon the tag `latest` will point to Python 3.6 and the other tags will be removed.\n* There were several improvements in the base image `tiangolo/uwsgi-nginx` that improved this image too.\n* By default, now there is no limit in the upload file size in Nginx. It can be configured in an environment variable.\n* It\'s now possible to configure several things with environment variables:\n  * Serve `index.html` directly: `STATIC_INDEX`\n  * Set the max upload file size: `NGINX_MAX_UPLOAD`\n  * Set a custom `uwsgi.ini` file (that allows using a custom directory different than `/app`): `UWSGI_INI` (using the ideas by @bercikr in #5 ).\n  * Set a custom `./static/` path: `STATIC_PATH`\n  * Set a custom `/static/` URL: `STATIC_URL`\n* As all this configurations are available as environment variables, the choices are a lot more simple. Actually, any new project would just need to use a `Dockerfile` with:\n\n```Dockerfile\nFROM tiangolo/uwsgi-nginx-flask:python3.6\n\nCOPY ./app /app\n```\n\nand then customize with environment variables.\n\n## Tests\n\nAll the image tags, configurations, environment variables and application options are tested.\n\n## License\n\nThis project is licensed under the terms of the Apache license.\n'