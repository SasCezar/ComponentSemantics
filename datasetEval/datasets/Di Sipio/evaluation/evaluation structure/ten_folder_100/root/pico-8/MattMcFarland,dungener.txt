b'## Dungeon Generation API\nThis is a highly commented, thorough dungeon generation API that uses BSP (Binary Space Partitioning)\n\n## Usage\nTo use, copy and paste all of the contents of [index.lua](./index.lua) into your pico8 file.\n\n## Demo\n\n![demo](./demo.gif)\n\n## API\n\n### `genesis(width,height,max_depth,pathfn,renderfn,min_size) -> rooms, tree`\n\nGenerates a dungeon using the BSP algorith.\nThe width and height are arbitrary units that can be used for pixels, the pico8 map, or something of your own creation.\n\n```lua\nlocal rooms, tree = genesis(\n  map_width,\n  map_height,\n  depth,\n  on_path_render,\n  on_room_render\n)\n```\n\n#### max_depth (int)\n\nHow deep the BSP tree gets. The greater the number, the more and smaller rooms are generated. For large maps, a higher number is useful, smaller maps, a lower number works better. The program will begin to decrease depth automatically if the process is taking too long. (decreases every second)\n\n#### pathfn (function)\n\nit is called with (x0,y0,x1,y1)   where the coordinates make a line from two points, the line is always  vertical, or horizontal. it always goes from center of a container to another center of another container. It is guaranteed to go from left to right, or top to bottom.\n\n```lua\nfunction on_path_render (x0,y0,x1,y1)\n  line(x0,y0,x1,y1,6)\nend\n```\n\n#### renderfn (function)\n\nit is called with (x0,y0,x1,y1) where the coordinates make a rectangle called on your own by iterating over rooms and calling room.render() on each used to render tiles to the map, or to pixels.\n\n```lua\nfunction on_room_render (x0,y0,x1,y1)\n  rectfill(x0,y0,x1,y1,3)\n  rect(x0,y0,x1,y1,6)\nend\n```\n\n#### min_size (int) (default: 8)\n\nminimum room size before the room is not added to the rooms array, default is 8.\nThe program will decrease the minimum size automatically if it is taking too long to process, which is usually only the case when the minimum size is too high.\n\n#### returns\n\nA tuple of rooms and the tree. rooms contains data about each room in the map, and the tree contains traversable tree of containing cells primarily used for calling rendering functions\n\n#### Rendering\n\nAssuming you have created something like the `on_path_render` and `on_room_render` functions above, you then iterate over the rooms and traverse the tree to render the map.  In the demo, we use these functions:\n\n```lua\nfunction render_rooms()\n  foreach(rooms, function(room)\n    room:render()\n  end)\nend\n\nfunction render_paths(node)\n  if (nil == node.lchild or nil == node.rchild) return\n  node.lchild.leaf:render_path(node.rchild.leaf)\n  render_paths(node.lchild)\n  render_paths(node.rchild)\nend\n```\n\nWhich then could be called to render like this\n```lua\ncls()\nrender_paths(tree)\nrender_rooms()\n```\n\n### Full Example\n```lua\nfunction _init()\n  -- since we are rendering to pixels,\n  -- we use the screen resolution\n  local map_width=127\n  local map_height=127\n  -- define how deep our binary trie goes\n  -- the higher, the smaller and more rooms you get\n  -- for smaller maps, you should use a smaller number.\n  local depth=5\n  -- declare how the paths are rendered\n  function on_path_render (x0,y0,x1,y1)\n    line(x0,y0,x1,y1,6)\n  end\n  -- declare how the rooms are rendered\n  function on_room_render (x0,y0,x1,y1)\n    rectfill(x0,y0,x1,y1,3)\n    rect(x0,y0,x1,y1,6)\n  end\n  -- get our room and tree tables from\n  -- the generator\n  local rooms, tree = genesis(\n    map_width,\n    map_height,\n    depth,\n    on_path_render,\n    on_room_render,\n    6\n  )\n  -- now we have our rooms and tree (technically trie)\n  -- but they arent going to render themselves.\n  -- to do this, we need to iterate over the rooms\n  -- and the paths by themselves.\n\n  -- create a function that will render all of the rooms\n  -- by calling the render function on each of the rooms,\n  -- the rooms themselves will then call the on_room_render\n  function render_rooms()\n    foreach(rooms, function(room)\n      room:render()\n    end)\n  end\n  -- create a function that will recursively walk down the tree\n  -- and render paths between each container cell and\n  -- rooms. which creates our hallways. it will end when\n  -- it reaches the "bottom" of the tree, where a node does not\n  -- have children.\n  function render_paths(node)\n    if (nil == node.lchild or nil == node.rchild) return\n    node.lchild.leaf:render_path(node.rchild.leaf)\n    render_paths(node.lchild)\n    render_paths(node.rchild)\n  end\n  -- with our functions defined, we can now render the dungeon.\n  cls()\n  render_paths(tree)\n  render_rooms()\nend\n```\n\n\n## License\nMIT\n'