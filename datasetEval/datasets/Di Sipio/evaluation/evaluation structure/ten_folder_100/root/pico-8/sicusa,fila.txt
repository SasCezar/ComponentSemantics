b'[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-brightgreen.svg)](https://github.com/sicusa/fila/graphs/commit-activity)\n[![License](https://img.shields.io/github/license/mashape/apistatus.svg)](https://en.wikipedia.org/wiki/MIT_License) \n[![Made With PICO-8](https://img.shields.io/badge/Made%20With-PICO--8-ff004d.svg?style=flat&logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAlUlEQVQ4jWP8v5gBFTxOR%2BVXPfuPwp8SxIjCt%2BBG4TIxUBkMfgNZGIyi0IRmoobZxxeo0rcPocp%2FEEEJ08HvZaobyPj%2FjTpqmLAeJM2EtgMo3MHvZeqnw9X%2FXVHSUdhnP5Qw%2Fc%2B7CUVDS%2BsWFH6QpuyIT4cMT8xQBJI%2B1aHwj1%2F3RgnTVJbrKGH29egxFPWD38tUNxAAun4liexlTtMAAAAASUVORK5CYII%3D)](https://www.lexaloffle.com/pico-8.php)\n\n![PICO-Tween](img/logo.png)\n\nFila is a generalized PICO-8 framework derived from ECS paradigm and prototype-oriented programming. It allows developers to model both data and logic in an unprecedented way.\n\n## Demo\n\n``` lua\n-- create a new fila instance\nlocal life = fila()\n\n-- life --> "mortal"\nlife:knot("mortal")\nassert(life:find("mortal"))\n\n-- ===========================\n\n-- create a child instance of\n-- life\nlocal animal = life()\n\nassert(animal:get_parent()\n    == life)\nassert(animal:is(life))\n\n-- * life is mortal (knot)\n--   animal is life (instance)\n--   animal is mortal\n--    (knot inheritance)\nassert(animal:find("mortal"))\n\n-- ===========================\n\nlocal bird = animal()\n\nassert(bird:is(animal))\nassert(bird:is(life))\nassert(bird:find("mortal"))\n\n-- bird -[true]-> "can_fly"\nbird:knot("can_fly", true)\n\nlocal res, param\nres, param = bird:find("can_fly")\nassert(res == true)\nassert(param == true)\nassert(not animal:find("can_fly"))\n\n-- ===========================\n\nlocal penguin = bird()\n\n-- override parent\'s knot\npenguin:knot("can_fly", false)\n\nres, param = penguin:find("can_fly")\nassert(res == true)\nassert(param == false)\n\n-- ===========================\n\n-- more compact way to create\n-- an instance with knots\nlocal ostrich = bird {\n    can_fly = false,\n    "funny", -- no parameter\n}\n\n-- more compact way to get knot\nassert(ostrich:get("can_fly")\n    == false)\nassert(ostrich:get("funny")\n    == nil) -- no parameter\n    \n-- life:get("can_fly")\n-- ! error: knot not found\n\n-- ostrich:unknot("mortal")\n-- ! error: knot not found\n--   * parent\'s knots cannot be\n--     removed from children\n\nostrich:knot("mortal")\nostrich:unknot("mortal")\n-- unknot only removes knots\n-- from the instance itself,\n-- life is still mortal\nassert(ostrich:find("mortal"))\n\n-- ===========================\n\nassert(bird:get_children_count()\n    == 2)\n\nlocal children = {}\nfor child in bird:iter_children() do\n    children[child] = true\nend\n\nassert(children[penguin])\nassert(children[ostrich])\n\n-- ===========================\n\nlocal knots = {}\nfor knot, param in penguin:iter_knots() do\n    knots[knot] = param == nil\n        and "no_param" or param\nend\n\nassert(knots["can_fly"] == false)\n-- iter_knots only provide\n-- knots added specifically\n-- on this instance\nassert(knots["mortal"] == nil)\n\n-- ===========================\n\n-- group containing children\n-- of life that has remaining-\n-- _lifetime less or equal to 0\nlocal dead_grp =\n    life:group(function(f)\n        local res, l =\n            f:find("remaining_lifetime")\n        return res and l <= 0\n    end)\n    \n-- when an life is added to the\n-- group, knot it with "dead"\ndead_grp:on_add(function(g, f)\n    f:knot("dead")\nend)\n\n-- when an life is removed from\n-- the group, unknot "dead"\ndead_grp:on_remove(function(g, f)\n    f:unknot("dead")\nend)\n\n-- * use unlisten_add and\n--   unlisten_remove to remove\n--   callbacks from group\n\nlocal old_penguin = penguin {\n    remaining_lifetime = 1\n}\n\nassert(not dead_grp:has(old_penguin))\nassert(not old_penguin:find("dead"))\n\nold_penguin:knot(\n    "remaining_lifetime", 0)\n\nassert(dead_grp:count() == 1)\nassert(dead_grp:has(old_penguin))\nassert(old_penguin:find("dead"))\n    \nlocal old_ostrich = ostrich {\n    remaining_lifetime = -1\n}\n\nassert(dead_grp:count() == 2)\nassert(dead_grp:has(old_ostrich))\nassert(old_ostrich:find("dead"))\n\n-- don\'t misinterpret * child\n-- instance * as \'child\' in\n-- real world. it\'s more like\n-- * derived concept *.\n-- a child instance of old_-\n-- penguin inherits all the\n-- knots from old_penguin, thus\n-- is also dead (unfortunately)\nlocal old_penguin_2 =\n    old_penguin {\n        other_knot = "other_param"\n    }\nassert(old_penguin_2:find("dead"))\n\nlocal dead = {}\n\nfor i, f in dead_grp:iter() do\n    dead[f] = true\nend\n\nassert(dead[old_penguin])\nassert(dead[old_ostrich])\n\n-- let\'s revive them!\n\nold_penguin:knot(\n    "remaining_lifetime", 41)\nold_ostrich:knot(\n    "remaining_lifetime", 42)\n    \nassert(not old_penguin:find("dead"))\nassert(not old_ostrich:find("dead"))\n\n-- since old_penguin_2 is the\n-- child instance and does not\n-- override its parent\'s\n-- remaining_lifetime knot,\n-- when the parent gets revived\n-- it revives at the same time\nassert(not old_penguin_2:find("dead"))\n\nassert(dead_grp:count() == 0)\nassert(not dead_grp:has(old_penguin))\nassert(not dead_grp:has(old_ostrich))\n\n-- groups do not act on filae\n-- containing them\nlife:knot(\n    "remaining_lifetime", -1)\nassert(not life:find("dead"))\nlife:unknot(\n    "remaining_lifetime")\n    \n-- sadly, old_penguin does not\n-- hold the answer to life,\n-- the universe, and everything\nold_penguin:knot(\n    "remaining_lifetime", 0)\nassert(old_penguin:find("dead"))\nassert(old_penguin_2:find("dead"))\n\n-- groups does not get released\n-- after not referenced any\n-- more, you must destroy them\n-- manually\ndead_grp:destroy()\n\n-- when getting destroyed, all\n-- filae in the group are\n-- removed, triggering on_remove\n-- callbacks\nassert(not old_penguin:find("dead"))\nassert(not old_penguin_2:find("dead"))\n\n-- * groups created by group\n--   method have very poor\n--   performance since the\n--   predicate function has to\n--   be executed each time when\n--   any child of the instance\n--   knots or unknots anything\n\n-- * more performance can be\n--   gained by seperating\n--   groups into different fila\n--   instances that really need\n--   them\n\n-- * for better performance,\n--   use * fast group *\n\n-- ===========================\n\n-- fast groups are literally\n-- faster but limited in their\n-- instance selecting method:\n-- they can only be used to\n-- select instances that have\n-- specific set of knots\n\n-- g contains all the instances\n-- of life which have remainin-\n-- g_lifetime knot (and any\n-- pamameter of it)\nlocal g = life:fast_group(\n    "remaining_lifetime")\n    \n-- note that fast groups are\n-- cached - invoking fast_group\n-- twice with the same knots as\n-- arguments on the same fila\n-- gets the same group\nassert(g == life:fast_group(\n    "remaining_lifetime"))\n    \nassert(g:count() == 3)\nassert(g:has(old_penguin))\nassert(g:has(old_penguin_2))\nassert(g:has(old_ostrich))\n\nlocal dead = {}\n\nfor i, f in g:iter() do\n    dead[f] = true\nend\n\nassert(dead[old_penguin])\nassert(dead[old_penguin_2])\nassert(dead[old_ostrich])\n\n-- on_add_iter listens the add\n-- event just as on_add, while\n-- also invoking the callback\n-- for each fila that has been\n-- added to the group before\ng:on_add_iter(function(g, f)\n    -- filae in the group must\n    -- have remaining_lifetime\n    -- knot\n    local l =\n        f:get("remaining_lifetime")\n    if l <= 0 then\n        f:knot("dead")\n    end\nend)\n\ng:on_remove(function(g, f)\n    f:unknot("dead")\nend)\n\nassert(old_penguin:find("dead"))\nassert(old_penguin_2:find("dead"))\n-- recall that old_ostrich has\n-- remaining lifetime of 42\nassert(not old_ostrich:find("dead"))\n\n-- now let\'s revive old_penguin\n-- (and old_penguin_2)\nold_penguin:knot(\n    "remaining_lifetime", 42)\n\n-- but old penguin is still\n-- dead! this is because on_add\n-- callback only gets invoked\n-- when remaining_lifetime knot\n-- is added to a fila (a knot\n-- event), not when modified\n-- (a reknot event)\nassert(old_penguin:find("dead"))\n\n-- * to achieve the result we\n--   want, i.e. invoking some\n--   callbacks each time when a\n--   fila that has specific set\n--   of knots changes one of\n--   those knots, promote the\n--   existing group to or\n--   create a new * reactive\n--   group *\n\n-- ===========================\n\n-- create a new reactive group\n-- (if a fast group with the\n-- same knot arguments has \n-- already existed, it will be\n-- promoted to reactive group)\nlocal g = life:reactive_group(\n    "remaining_lifetime")\n\n-- on_react callbacks are\n-- invoked each time when a\n-- fila is added to the group\n-- or updates its knots that\n-- are used by this group to\n-- select filae (in this case,\n-- it\'s remaining_lifetime)\n\n-- just like on_add_iter, call-\n-- backs added by on_react will\n-- be invoked firstly for each\n-- existing fila in the group\ng:on_react(function(g, f)\n    local l =\n        f:get("remaining_lifetime")\n    if l <= 0 then\n        f:knot("dead")\n    else\n        -- try_unknot won\'t throw\n        -- an error if the knot does\n        -- not exist\n        f:try_unknot("dead")\n    end\nend)\n\n-- * for removing the callback,\n--   use unlisten_react\n\n-- now, old_penguin and old_pe-\n-- guin_2 are alive!\nassert(not old_penguin:find("dead"))\nassert(not old_penguin_2:find("dead"))\n\nold_ostrich:knot(\n    "remaining_lifetime", 0)\nassert(old_ostrich:find("dead"))\n\n-- * in essence, a group repre-\n--   sents some sort of rule\n--   that must be abided by all\n--   the child instances of the\n--   fila containing the group\n\n-- ===========================\n\n-- as you may have gussed,\n-- fast groups and reactive\n-- groups can have multiple\n-- knot targets as their\n-- arguments to select child\n-- instances (which are\n-- called knottees in fila\n-- paradigm, so knot = knottee\n-- + optional parameter)\n\n-- a dead life will start\n-- decomposing\nlife:fast_group("dead")\n    :on_add(function(g, f)\n        f:knot("decomposing")\n    end)\n\nlocal during_decomposing\nlocal goodbye\n\n-- a decomposing life which\n-- has decomposing time greater\n-- or equal to 1 will be\n-- destroyed (for fila, it\'s\n-- done by reset method) \nlife:reactive_group(\n    "decomposing",\n    "decomposing_time")\n    :on_react(function(g, f)\n        if f:get("decomposing_time")\n            >= 1 then\n            f:reset()\n        end\n    end)\n    -- on_* methods returns the\n    -- group itself, so you can\n    -- chain them together\n    :on_add(function(g, f)\n        during_decomposing = true\n    end)\n    :on_remove(function(g, f)\n        goodbye = true\n    end)\n\nold_penguin:knot(\n    "remaining_lifetime", 0)\n    \nassert(old_penguin:find(\n    "dead"))\nassert(old_penguin:find(\n    "decomposing"))\n\nassert(not during_decomposing)\n\nold_penguin:knot(\n    "decomposing_time", 0)\n    \nassert(during_decomposing)\n\nold_penguin:knot(\n    "decomposing_time", 1)\n    \nassert(goodbye)\n\n-- once a fila is reset it will\n-- be detached from its parent,\n-- and all the knots and groups\n-- will be removed, as if you \n-- reassign the variable with\n-- an empty fila created by\n-- `fila()`\nlocal ks = {}\nfor k, p in\n    old_penguin:iter_knots() do\n    ks[#ks+1] = k\nend\nassert(#ks == 0)\nassert(old_penguin:get_parent()\n    == nil)\n    \n-- reset is recursive\nassert(old_penguin:get_children_count()\n    == 0)\nassert(old_penguin_2:get_parent()\n    == nil)\n\n-- old_penguin and old_penguin-\n-- _2 now are totally dead, but\n-- you can reuse those empty\n-- filae left by them and\n-- * reattach * them to other\n-- fila, which, in a romantic\n-- interpretation, is analogous \n-- to the reincarnation of life\nlocal plant = life()\nlocal angiosperm = plant()\nangiosperm:knot("has_flower")\n\nlocal rose = old_penguin\nrose:reattach(angiosperm)\nassert(rose:is(plant))\nassert(rose:find("has_flower"))\n\nlocal patchouli = old_penguin_2\npatchouli:reattach(angiosperm)\nassert(patchouli:is(plant))\nassert(patchouli:find("has_flower"))\n\n-- ===========================\n\n-- it is possible to lift a\n-- fila to the same level as\n-- its parent using lift method\n\nlocal super_penguin = penguin()\nsuper_penguin:knot(\n    "can_fly", true)\n\nlocal super_penguin_2 =\n    super_penguin()\n    \nassert(super_penguin_2:get_parent()\n    == super_penguin)\nassert(super_penguin_2:get(\n    "can_fly") == true)\n    \nsuper_penguin_2:lift()\n\nassert(super_penguin_2:get_parent()\n    == penguin)\n    \n-- when lifting, all knots\n-- owned by fila\'s parent will\n-- be copied to the fila\nassert(super_penguin_2:get(\n    "can_fly") == true)\n    \n-- ===========================\n\n-- detach method repeats\n-- lifting the fila until it\n-- has no more parent (at top\n-- level)\n\nlocal super_penguin_template =\n    fila()\n\nsuper_penguin_template\n    :knot("can_fly", true)\n    \nlocal mega_super_penguin_template =\n    super_penguin_template()\n    \nmega_super_penguin_template\n    :knot("can_fly_into_space")\n    \nlocal the_penguin =\n    mega_super_penguin_template()\n\nthe_penguin:detach()\n\nassert(the_penguin:get_parent()\n    == nil)\nassert(the_penguin:get(\n    "can_fly") == true)\nassert(the_penguin:find(\n    "can_fly_into_space"))\n\n-- using reattach to attach the\n-- penguin to penguin fila\nthe_penguin:reattach(penguin)\nassert(the_penguin:get_parent()\n    == penguin)\n\n-- reattach will automatically\n-- invoke detach method if the\n-- fila has non-nil parent, so\n-- you can use it directly\nlocal the_penguin_2 =\n    mega_super_penguin_template()\nthe_penguin_2:reattach(penguin)\n\nassert(the_penguin_2:get(\n    "can_fly") == true)\nassert(the_penguin_2:find(\n    "can_fly_into_space"))\nassert(the_penguin_2:get_parent()\n    == penguin)\n```'