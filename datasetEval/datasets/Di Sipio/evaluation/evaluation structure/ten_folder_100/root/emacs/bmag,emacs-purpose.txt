b'# Purpose\n\n[![MELPA](http://melpa.org/packages/window-purpose-badge.svg)](http://melpa.org/#/window-purpose)\n[![MELPA Stable](http://stable.melpa.org/packages/window-purpose-badge.svg)](http://stable.melpa.org/#/window-purpose)\n[![Build Status](https://travis-ci.org/bmag/emacs-purpose.svg?branch=master)](https://travis-ci.org/bmag/emacs-purpose)\n[![Coverage Status](https://coveralls.io/repos/bmag/emacs-purpose/badge.svg?branch=master)](https://coveralls.io/r/bmag/emacs-purpose?branch=master)\n\n**Note: a full explanation can be found in the [GitHub wiki](https://github.com/bmag/emacs-purpose/wiki).**\n\n## Introduction\n\nPurpose ("window-purpose" on MELPA) provides a new window management system for\nEmacs, which gives you a better control over where Emacs displays buffers.\n\nWith Purpose, each buffer has a configurable "purpose" and each window\ncan interactively be dedicated to a certain "purpose". When you dedicate\na window (<kbd>C-c , d</kbd>), Purpose makes sure that this window will be used\nonly for buffers which have the same purpose as the buffer that is\ncurrently displayed in that window. The purpose of a buffer can be\ncustomized via the variables `purpose-user-mode-purposes`,\n`purpose-user-name-purposes`, `purpose-user-regexp-purposes` and\n`purpose-use-default-configuration` (see the\n[wiki](https://github.com/bmag/emacs-purpose/wiki/Purpose-Configuration)).\n\n### Supported Emacs Versions\nPurpose is tested with Emacs versions 24.3, 24.4 and 24.5. Backward-compatibility for earlier versions might be added in the future - if you want such support, contact me.\n\n## Quickstart\n\n### Activate Purpose\nManually: <kbd>M-x purpose-mode</kbd>\n\nIn your init file:\n```elisp\n(require \'window-purpose)\n(purpose-mode)\n```\n\n### Configure Purpose\nManually: <kbd>M-x customize-group purpose</kbd>. Look at:\n- "Purpose User Mode Purposes": recognize purpose according to major mode\n- "Purpose User Name Purposes": recognize purpose according to buffer\n  name (for exact names)\n- "Purpose User Regexp Purposes": recognize purpose according to buffer\n  name (for name patterns)\n- "Purpose Use Default Configuration": toggle default configuration\n  on/off\n\nIn init file:\n```elisp\n(add-to-list \'purpose-user-mode-purposes \'(<major-mode> . <purpose>))\n(add-to-list \'purpose-user-name-purposes \'(<name> . <purpose>))\n(add-to-list \'purpose-user-regexp-purposes \'(<pattern> . <purpose>))\n(setq purpose-use-default-configuration t) ; not really necessary, default is t\n(purpose-compile-user-configuration) ; activates your changes\n```\n\n### Useful Commands\n| Key         | Command                                                                                                                   |\n| :---------- | :------------------------------------------------------------------------------------------------------------------------ |\n| <kbd>C-c , b</kbd>   | `purpose-switch-buffer-with-purpose`: switch to a buffer with the same purpose as the current one                         |\n| <kbd>C-u C-x b</kbd> | `switch-buffer-without-purpose`: switch to a buffer, but don\'t use Purpose for it. Handy for changing the current layout. |\n| <kbd>C-c , d</kbd>   | `purpose-toggle-window-purpose-dedicated`                                                                                 |\n| <kbd>C-c , D</kbd>   | `purpose-toggle-window-buffer-dedicated`                                                                                  |\n| <kbd>C-c , 1</kbd>   | `purpose-delete-non-dedicated-windows`                                                                                    |\n|             | `purpose-save-window-layout`: save current layout (by name)                                                                |\n|             | `purpose-load-window-layout`: load layout (by name)                                                                       |\n|             | `purpose-save-window-layout-file`: save current layout directly to file                                                                |\n|             | `purpose-load-window-layout-file`: load layout directly from file                                                                  |\n|             | `purpose-reset-window-layout`: reload previously loaded layout                                                            |\n\n### Example: Simple Python Layout\nHow to get a simple and persistent layout for coding in Python that\nlooks like this:\n\n![simple python layout](https://github.com/bmag/emacs-purpose/blob/master/images/simple-python-layout.png)\n\n#### step 1: configuration\n```elisp\n(add-to-list \'purpose-user-mode-purposes \'(python-mode . py))\n(add-to-list \'purpose-user-mode-purposes \'(inferior-python-mode . py-repl))\n(purpose-compile-user-configuration)\n```\n\n#### step 2: change window layout\nIf you have a previously saved layout, you can load it with\n`purpose-load-window-layout` and skip step 2 and step 3.\n\n1. open a Python file\n2. <kbd>C-c , d</kbd> (`purpose-toggle-window-purpose-dedicated`) so window is\n   dedicated ("[py]" in the status bar will change to "[py!]")\n3. <kbd>C-x 1</kbd> (`delete-other-windows`)\n4. <kbd>C-x 2</kbd> (`split-window-below`)\n5. <kbd>C-c C-z</kbd> (`python-shell-switch-to-shell`)\n6. <kbd>C-c , d</kbd> so window is dedicated\n7. <kbd>C-x o</kbd> (`other-window`) to select the python file\'s window\n8. <kbd>C-x ^</kbd> (`enlarge-window`) until you like the sizes of the windows\n\n#### step 3: save window layout\n<kbd>M-x purpose-save-window-layout</kbd>\n\n## Using Purpose\n\n### Dedicating windows\nDedicating a window limits which buffers will be displayed in it. There are two\ntypes of window dedication: buffer-dedication and purpose-dedication.\n\nUse `purpose-toggle-window-buffer-dedicated` to dedicate a window to its buffer.\nThis window will not display any other buffer while it is buffer-dedicated. A\n"#" in the mode-line next to the window\'s purpose indicates that the window is\nbuffer-dedicated.\n\nUse `purpose-toggle-window-purpose-dedicated` to dedicate a window to its\npurpose. This window will only display buffers with the same purpose. A "!" in\nthe mode-line next to the window\'s purpose indicates that the window is\npurpose-dedicated.\n\nYou can delete all non-dedicated windows by using\n`purpose-delete-non-dedicated-windows`.\n\n### Switching buffers\nWhen switching buffers, Purpose will display the new buffer in the correct\nwindow, according to the current configuration.\n\nUse `switch-to-buffer` to switch to any buffer. The buffer will be displayed\naccording to the current purpose-configuration.\n\nUse `purpose-switch-buffer-with-purpose` to switch to another buffer with the\nsame purpose as the current buffer.\n\nUse `purpose-switch-buffer-with-some-purpose` to select a purpose and then\nswitch to a buffer with that purpose.\n\nUse `switch-buffer-without-purpose` to switch to any buffer. The buffer will be\ndisplayed using Emacs\' original behavior. This is useful when you want to change\nthe window layout.\n\nUse `purpose-set-window-purpose` to switch the purpose of the current window. If\nthere is a buffer with the chosen purpose, that buffer will be displayed in the\ncurrent window. Otherwise, a dummy buffer will be created and used.\n\n### Changing layout\nPurpose lets you save, load and reset the window layout.\n\nUse `purpose-save-window-layout` to save the current window layout. The layout\nwill be saved in a directory of your choice, in a file named\n`<layout-name>.window-layout`.\n\nUse `purpose-load-window-layout` to load a window layout. The available layouts\nare located the directories specified in customizable variable `purpose-layout-dirs`.\n\nUse `purpose-save-window-layout-file` to save the current window layout directly to\na file of your choice.\n\nUse `purpose-load-window-layout-file` to load a window layout directly from a file\nof your choice.\n\nUse `purpose-reset-window-layout` to reset the window layout to the latest\nlayout that you loaded.\n\nIn addition to window layouts, Purpose also lets save, load and reset the frame\nlayout. A "frame layout" consists of the window layouts of multiple frames.\nAll of the window layout commands have frame layout equivalents, e.g.\n`purpose-load-frame-layout` is equivalent to `purpose-load-window-layout`.\n\n## Customizing Purpose\n\n### Prompts\nIn the past, the variable `purpose-preferred-prompt`, allowed you to choose whether you want Purpose to use\nIDO or Helm when it needs information from the user. This variable has been removed. Instead, the prompt\nrelies on the normal mechanism. For Helm prompts enable `helm-mode`, for Ivy mode enable `ivy-mode`, for\nIDO prompts enable `ido-mode`, etc. If using `ido-mode`, note that because how IDO works it doesn\'t\ncover all commands, and some commands won\'t have an IDO prompt. To work around that, please see the\npackage [ido-completion-read+](https://github.com/DarwinAwardWinner/ido-completing-read-plus) (formerly\nido-ubiquitous).\n\n### Changing purpose configuration\nPurpose lets you define your own purposes. You can do so by using the variables\n`purpose-user-mode-purposes`, `purpose-user-name-purposes` and\n`purpose-user-regexp-purposes`. You can also deactivate the default purpose\nconfiguration if it bothers you, by setting `purpose-use-default-configuration`\nto nil.\n\n### Changing display rules\nIf you want, you can the rules of how certain buffers are displayed. To do so,\nuse the variable `purpose-special-action-sequences`. Let\'s explain this with an\nexample. The following code makes all help buffers appear in a separate\nframe. This means you will get a "popup" frame for help buffers.\n\n```elisp\n(setq pop-up-frames t) ; allows emacs to popup new frames\n;; give help buffers the \'popup-frame purpose\n(add-to-list \'purpose-user-mode-purposes\n             \'(help-mode . popup-frame))\n(purpose-compile-user-configuration)\n;; new rules for buffers with the \'popup-frame purpose\n(add-to-list \'purpose-special-action-sequences\n             \'(popup-frame\n               purpose-display-reuse-window-buffer\n               purpose-display-reuse-window-purpose\n               purpose-display-pop-up-frame))\n```\n\n### Respect purposes when killing a buffer\nWhen killing a visible buffer, Emacs has to decide which buffer to show instead.\nEnabling the `purpose-x-kill` extension will make Emacs consider the purpose of\nthe window that needs to show a new buffer. If the window is purpose-dedicated,\nthe killed buffer is replaced with another buffer with the same purpose. If there\nare no buffers with the same purpose as the killed buffer, the window is deleted.\nTo enable the `purpose-x-kill` extension:\n\n```elisp\n(require \'window-purpose-x)\n(purpose-x-kill-setup)\n```\n\n### Location of Layout Files\nWindow layout and frame layout files are stored in the directories specified by\n`purpose-layout-dirs`. By default, its value is `("~/.emacs.d/layouts/")`. To store\nlayouts in a different location, simply change the value of this variable.\n\n## Using Purpose with other packages\nSee [Integration With Other Packages](https://github.com/bmag/emacs-purpose/wiki/Integration-With-Other-Packages)\nfor information about how some packages relate to Purpose.\n'