b'[![License GPL 3][badge-license]][copying]\n[![MELPA][melpa-badge]][melpa-package]\n[![MELPA Stable][melpa-stable-badge]][melpa-stable-package]\n[![circleci][badge-circleci]][circleci]\n\n# Clojure Mode\n\nProvides Emacs font-lock, indentation, navigation and refactoring for the\n[Clojure(Script) programming language](http://clojure.org).\n\nThis document assumes you\'re familiar with Emacs.  More thorough walkthroughs,\ntargeting Emacs beginners, are available at\n[clojure-doc.org](http://clojure-doc.org/articles/tutorials/emacs.html) and\n[Clojure for the Brave and the True](http://www.braveclojure.com/basic-emacs/).\nKeep in mind, however, that they might be out-of-date.\n\n**This documentation tracks the `master` branch of `clojure-mode`. Some of\nthe features and settings discussed here might not be available in\nolder releases (including the current stable release). Please, consult\nthe relevant git tag (e.g. 5.1.0) if you need documentation for a\nspecific `clojure-mode` release.**\n\n***\n\n- [Installation](#installation)\n- [Bundled major modes](#bundled-major-modes)\n- [Configuration](#configuration)\n  - [Indentation options](#indentation-options)\n    - [Indentation of function forms](#indentation-of-function-forms)\n    - [Indentation of macro forms](#indentation-of-macro-forms)\n  - [Vertical alignment](#vertical-alignment)\n- [Refactoring support](#refactoring-support)\n  - [Threading macros](#threading-macros-related-features)\n  - [Cycling things](#cycling-things)\n  - [Convert collection](#convert-collection)\n  - [Let expression](#let-expression)\n  - [Rename ns alias](#rename-ns-alias)\n  - [Add arity to a function](#add-arity-to-a-function)\n- [Related packages](#related-packages)\n- [REPL Interaction](#repl-interaction)\n  - [Basic REPL](#basic-repl)\n  - [CIDER](#cider)\n- [Changelog](#changelog)\n- [License](#license)\n\n## Installation\n\nAvailable on the major `package.el` community maintained repos -\n[MELPA Stable][] and [MELPA][] repos.\n\nMELPA Stable is the recommended repo as it has the latest stable\nversion.  MELPA has a development snapshot for users who don\'t mind\n(infrequent) breakage but don\'t want to run from a git checkout.\n\nYou can install `clojure-mode` using the following command:\n\n<kbd>M-x package-install [RET] clojure-mode [RET]</kbd>\n\nor if you\'d rather keep it in your dotfiles:\n\n```el\n(unless (package-installed-p \'clojure-mode)\n  (package-install \'clojure-mode))\n```\n\nIf the installation doesn\'t work try refreshing the package list:\n\n<kbd>M-x package-refresh-contents</kbd>\n\n## Bundled major modes\n\nThe `clojure-mode` package actually bundles together several major modes:\n\n* `clojure-mode` is a major mode for editing Clojure code\n* `clojurescript-mode` is a major mode for editing ClojureScript code\n* `clojurec-mode` is a major mode for editing `.cljc` source files\n\nAll the major modes derive from `clojure-mode` and provide more or less the same\nfunctionality.  Differences can be found mostly in the font-locking -\ne.g. ClojureScript has some built-in constructs that are not present in Clojure.\n\nThe proper major mode is selected automatically based on the extension of the\nfile you\'re editing.\n\nHaving separate major modes gives you the flexibility to attach different hooks\nto them and to alter their behavior individually (e.g. add extra font-locking\njust to `clojurescript-mode`) .\n\nNote that all modes derive from `clojure-mode`, so things you add to\n`clojure-mode-hook` and `clojure-mode-map` will affect all the derived modes as\nwell.\n\n## Configuration\n\nIn the spirit of Emacs, pretty much everything you can think of in `clojure-mode` is configurable.\n\nTo see a list of available configuration options do `M-x customize-group RET clojure`.\n\n### Indentation options\n\nThe default indentation rules in `clojure-mode` are derived from the\n[community Clojure Style Guide](https://github.com/bbatsov/clojure-style-guide).\nPlease, refer to the guide for the general Clojure indentation rules.\n\n#### Indentation of docstrings\n\nBy default multi-line docstrings are indented with 2 spaces, as this is a\nsomewhat common standard in the Clojure community. You can however adjust this\nby modifying `clojure-docstring-fill-prefix-width`. Set it to 0 if you don\'t\nwant multi-line docstrings to be indented at all (which is pretty common in most lisps).\n\n#### Indentation of function forms\n\nThe indentation of function forms is configured by the variable\n`clojure-indent-style`. It takes three possible values:\n\n- `always-align` (the default)\n\n```clj\n(some-function\n 10\n 1\n 2)\n(some-function 10\n               1\n               2)\n```\n\n- `always-indent`\n\n```clj\n(some-function\n  10\n  1\n  2)\n(some-function 10\n  1\n  2)\n```\n\n- `align-arguments`\n\n```clj\n(some-function\n  10\n  1\n  2)\n(some-function 10\n               1\n               2)\n```\n\n**Note:** Prior to clojure-mode 5.10 the configuration options for `clojure-indent-style` used to be\nkeywords, but now they are symbols. Keywords will still be supported at least until clojure-mode 6.\n\n#### Indentation of macro forms\n\nThe indentation of special forms and macros with bodies is controlled via\n`put-clojure-indent`, `define-clojure-indent` and `clojure-backtracking-indent`.\nNearly all special forms and built-in macros with bodies have special indentation\nsettings in `clojure-mode`. You can add/alter the indentation settings in your\npersonal config. Let\'s assume you want to indent `->>` and `->` like this:\n\n```clojure\n(->> something\n  ala\n  bala\n  portokala)\n```\n\nYou can do so by putting the following in your config:\n\n```el\n(put-clojure-indent \'-> 1)\n(put-clojure-indent \'->> 1)\n```\n\nThis means that the body of the `->/->>` is after the first argument.\n\nA more compact way to do the same thing is:\n\n```el\n(define-clojure-indent\n  (-> 1)\n  (->> 1))\n```\n\nYou can also specify different indentation settings for symbols\nprefixed with some ns (or ns alias):\n\n```el\n(put-clojure-indent \'do 0)\n(put-clojure-indent \'my-ns/do 1)\n```\n\nThe bodies of certain more complicated macros and special forms\n(e.g. `letfn`, `deftype`, `extend-protocol`, etc) are indented using\na contextual backtracking indentation method, require more sophisticated\nindent specifications. Here are a few examples:\n\n```el\n(define-clojure-indent\n  (implement \'(1 (1)))\n  (letfn     \'(1 ((:defn)) nil))\n  (proxy     \'(2 nil nil (1)))\n  (reify     \'(:defn (1)))\n  (deftype   \'(2 nil nil (1)))\n  (defrecord \'(2 nil nil (1)))\n  (specify   \'(1 (1)))\n  (specify   \'(1 (1))))\n```\n\nThese follow the same rules as the `:style/indent` metadata specified by [cider-nrepl][].\nFor instructions on how to write these specifications, see\n[this document](https://docs.cider.mx/cider/indent_spec.html).\nThe only difference is that you\'re allowed to use lists instead of vectors.\n\n### Vertical alignment\n\nYou can vertically align sexps with `C-c SPC`. For instance, typing\nthis combo on the following form:\n\n```clj\n(def my-map\n  {:a-key 1\n   :other-key 2})\n```\n\nLeads to the following:\n\n```clj\n(def my-map\n  {:a-key     1\n   :other-key 2})\n```\n\nThis can also be done automatically (as part of indentation) by\nturning on `clojure-align-forms-automatically`. This way it will\nhappen whenever you select some code and hit `TAB`.\n\n## Refactoring support\n\nThe available refactorings were originally created and maintained by the\n`clj-refactor.el` team. The ones implemented in Elisp only are gradually migrated\nto `clojure-mode`.\n\n### Threading macros related features\n\n`clojure-thread`: Thread another form into the surrounding thread. Both `->>`\nand `->` variants are supported.\n\n<img width="512" src="/doc/clojure-thread.gif">\n\n`clojure-unwind`: Unwind a threaded expression. Supports both `->>` and `->`.\n\n<img width="512" src="/doc/clojure-unwind.gif">\n\n`clojure-thread-first-all`: Introduce the thread first macro (`->`) and rewrite\nthe entire form. With a prefix argument do not thread the last form.\n\n<img width="512" src="/doc/clojure-thread-first-all.gif">\n\n`clojure-thread-last-all`: Introduce the thread last macro and rewrite the\nentire form. With a prefix argument do not thread the last form.\n\n<img width="512" src="/doc/clojure-thread-last-all.gif">\n\n`clojure-unwind-all`: Fully unwind a threaded expression removing the threading\nmacro.\n\n<img width="512" src="/doc/clojure-unwind-all.gif">\n\n### Cycling things\n\n`clojure-cycle-privacy`: Cycle privacy of `def`s or `defn`s. Use metadata\nexplicitly with setting `clojure-use-metadata-for-privacy` to `t` for `defn`s\ntoo.\n\n<img width="512" src="/doc/clojure-cycle-privacy.gif">\n\n`clojure-cycle-not`: Add or remove a `not` form around the current form.\n\n<img width="512" src="/doc/clojure-cycle-not.gif">\n\n`clojure-cycle-when`: Find the closest `when` or `when-not` up the syntax tree\nand toggle it.\n\n<img width="512" src="/doc/clojure-cycle-when.gif">\n\n`clojure-cycle-if`: Find the closest `if` or `if-not` up the syntax tree and\ntoggle it. Also transpose the `else` and `then` branches, keeping the semantics\nthe same as before.\n\n<img width="512" src="/doc/clojure-cycle-if.gif">\n\n### Convert collection\n\nConvert any given collection at point to list, quoted list, map, vector or set.\n\n### Let expression\n\n`clojure-introduce-let`: Introduce a new `let` form. Put the current form into\nits binding form with a name provided by the user as a bound name. If called\nwith a numeric prefix put the let form Nth level up in the form hierarchy.\n\n<img width="512" src="/doc/clojure-introduce-let.gif">\n\n`clojure-move-to-let`: Move the current form to the closest `let`\'s binding\nform. Replace all occurrences of the form in the body of the let.\n\n<img width="512" src="/doc/clojure-move-to-let.gif">\n\n`clojure-let-forward-slurp-sexp`: Slurp the next form after the `let` into the\n`let`. Replace all occurrences of the bound forms in the form added to the `let`\nform. If called with a prefix argument slurp the next n forms.\n\n<img width="512" src="/doc/clojure-let-forward-slurp-sexp.gif">\n\n`clojure-let-backward-slurp-sexp`: Slurp the form before the `let` into the\n`let`. Replace all occurrences of the bound forms in the form added to the `let`\nform. If called with a prefix argument slurp the previous n forms.\n\n<img width="512" src="/doc/clojure-let-backward-slurp-sexp.gif">\n\n`paredit-convolute-sexp` is advised to replace occurrences of bound forms with their bound names when convolute is used on a let form.\n\n### Rename ns alias\n\n`clojure-rename-ns-alias`: Rename an alias inside a namespace declaration.\n\n<img width="512" src="/doc/clojure-rename-ns-alias.gif">\n\n### Add arity to a function\n\n`clojure-add-arity`: Add a new arity to an existing single-arity or multi-arity function.\n\n<img width="512" src="/doc/clojure-add-arity.gif">\n\n## Related packages\n\n* [clojure-mode-extra-font-locking][] provides additional font-locking\nfor built-in methods and macros.  The font-locking is pretty\nimprecise, because it doesn\'t take namespaces into account and it\nwon\'t font-lock a function at all possible positions in a sexp, but\nif you don\'t mind its imperfections you can easily enable it:\n\n```el\n(require \'clojure-mode-extra-font-locking)\n```\n\nThe code in `clojure-mode-font-locking` used to be bundled with\n`clojure-mode` before version 3.0.\n\nYou can also use the code in this package as a basis for extending the\nfont-locking further (e.g. functions/macros from more\nnamespaces). Generally you should avoid adding special font-locking\nfor things that don\'t have fairly unique names, as this will result in\nplenty of incorrect font-locking. CIDER users should avoid this package,\nas CIDER does its own dynamic font-locking, which is namespace-aware\nand doesn\'t produce almost any false positives.\n\n* [clj-refactor][] provides refactoring support.\n\n* Enabling `CamelCase` support for editing commands(like\n`forward-word`, `backward-word`, etc) in `clojure-mode` is quite\nuseful since we often have to deal with Java class and method\nnames. The built-in Emacs minor mode `subword-mode` provides such\nfunctionality:\n\n```el\n(add-hook \'clojure-mode-hook #\'subword-mode)\n```\n\n* The use of [paredit][] when editing Clojure (or any other Lisp) code\nis highly recommended. It helps ensure the structure of your forms is\nnot compromised and offers a number of operations that work on code\nstructure at a higher level than just characters and words. To enable\nit for Clojure buffers:\n\n```el\n(add-hook \'clojure-mode-hook #\'paredit-mode)\n```\n\n* [smartparens][] is an excellent\n  (newer) alternative to paredit. Many Clojure hackers have adopted it\n  recently and you might want to give it a try as well. To enable\n  `smartparens` use the following code:\n\n```el\n(add-hook \'clojure-mode-hook #\'smartparens-strict-mode)\n```\n\n* [RainbowDelimiters][] is a\n  minor mode which highlights parentheses, brackets, and braces\n  according to their depth. Each successive level is highlighted in a\n  different color. This makes it easy to spot matching delimiters,\n  orient yourself in the code, and tell which statements are at a\n  given depth. Assuming you\'ve already installed `RainbowDelimiters` you can\n  enable it like this:\n\n```el\n(add-hook \'clojure-mode-hook #\'rainbow-delimiters-mode)\n```\n\n* [aggressive-indent-mode][] automatically adjust the indentation of your code,\nwhile you\'re writing it. Using it together with `clojure-mode` is highly\nrecommended. Provided you\'ve already installed `aggressive-indent-mode` you can\nenable it like this:\n\n```el\n(add-hook \'clojure-mode-hook #\'aggressive-indent-mode)\n```\n\n## REPL Interaction\n\nOne of the fundamental aspects of Lisps in general, and Clojure in\nparticular, is the notion of interactive programming - building your\nprograms by continuously changing the state of the running Lisp\nprogram (as opposed to doing something more traditional like making a\nchange and re-running the program afterwards to see the changes in\naction). To get the most of clojure-mode you\'ll have to combine it\nwith some tool which will allow you to interact with your Clojure program\n(a.k.a. process/REPL).\n\nA number of options exist for connecting to a\nrunning Clojure process and evaluating code interactively.\n\n### Basic REPL\n\n[inf-clojure][] provides basic interaction with a Clojure REPL process.\nIt\'s very similar in nature and supported functionality to `inferior-lisp-mode`\nfor Common Lisp.\n\n### CIDER\n\n[CIDER][] is a powerful Clojure interactive development environment,\nsimilar to SLIME for Common Lisp.\n\nIf you\'re into Clojure and Emacs you should definitely check it out.\n\n## Changelog\n\nAn extensive changelog is available [here](CHANGELOG.md).\n\n## License\n\nCopyright \xc2\xa9 2007-2019 Jeffrey Chu, Lennart Staflin, Phil Hagelberg, Bozhidar\nBatsov, Artur Malabarba and [contributors][].\n\nDistributed under the GNU General Public License; type <kbd>C-h C-c</kbd> to view it.\n\n[badge-license]: https://img.shields.io/badge/license-GPL_3-green.svg\n[melpa-badge]: http://melpa.org/packages/clojure-mode-badge.svg\n[melpa-stable-badge]: http://stable.melpa.org/packages/clojure-mode-badge.svg\n[melpa-package]: http://melpa.org/#/clojure-mode\n[melpa-stable-package]: http://stable.melpa.org/#/clojure-mode\n[COPYING]: http://www.gnu.org/copyleft/gpl.html\n[badge-circleci]: https://circleci.com/gh/clojure-emacs/clojure-mode.svg?style=svg\n[circleci]: https://circleci.com/gh/clojure-emacs/clojure-mode\n[CIDER]: https://github.com/clojure-emacs/cider\n[cider-nrepl]: https://github.com/clojure-emacs/cider-nrepl\n[inf-clojure]: https://github.com/clojure-emacs/inf-clojure\n[contributors]: https://github.com/clojure-emacs/clojure-mode/contributors\n[melpa]: http://melpa.org\n[melpa stable]: http://stable.melpa.org\n[clojure-mode-extra-font-locking]: https://github.com/clojure-emacs/clojure-mode/blob/master/clojure-mode-extra-font-locking.el\n[clj-refactor]: https://github.com/clojure-emacs/clj-refactor.el\n[paredit]: http://mumble.net/~campbell/emacs/paredit.html\n[smartparens]: https://github.com/Fuco1/smartparens\n[RainbowDelimiters]: https://github.com/Fanael/rainbow-delimiters\n[aggressive-indent-mode]: https://github.com/Malabarba/aggressive-indent-mode\n'