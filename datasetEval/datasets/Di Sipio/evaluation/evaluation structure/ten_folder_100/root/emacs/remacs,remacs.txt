b'# Rust :heart: Emacs\n\n[![Join the chat at https://gitter.im/remacs-discuss/Lobby](https://badges.gitter.im/remacs-discuss/Lobby.svg)](https://gitter.im/remacs-discuss/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Build Status](https://travis-ci.org/remacs/remacs.svg?branch=master)](https://travis-ci.org/remacs/remacs)\n\nA community-driven port of [Emacs](https://www.gnu.org/software/emacs/) to [Rust](https://www.rust-lang.org).\n\n<!-- markdown-toc start - Don\'t edit this section. Run M-x markdown-toc-refresh-toc -->\n**Table of Contents**\n\n- [Why Emacs?](#why-emacs)\n- [Why Rust?](#why-rust)\n- [Why A Fork?](#why-a-fork)\n- [Getting Started](#getting-started)\n    - [Requirements](#requirements)\n    - [Dockerized development environment](#dockerized-development-environment)\n    - [Building Remacs](#building-remacs)\n    - [Running Remacs](#running-remacs)\n- [Design Goals](#design-goals)\n- [Progress](#progress)\n- [Porting Elisp Primitive Functions](#porting-elisp-primitive-functions)\n- [Contributing](#contributing)\n\n<!-- markdown-toc end -->\n\n\n# Why Emacs?\n\nEmacs will change how you think about programming.\n\nEmacs is **totally introspectable**. You can always find out \'what\ncode runs when I press this button?\'.\n\nEmacs is an **incremental programming environment**. There\'s no\nedit-compile-run cycle. There isn\'t even an edit-run cycle. You can\nexecute snippets of code and gradually turn them into a finished\nproject. There\'s no distinction between your editor and your\ninterpreter.\n\nEmacs is a **mutable environment**. You can set variables, tweak\nfunctions with advice, or redefine entire functions. Nothing is\noff-limits.\n\nEmacs **provides functionality without applications**. Rather than\nseparate applications, functionality is all integrated into your Emacs\ninstance. Amazingly, this works. Ever wanted to use the same snippet\ntool for writing C++ classes as well as emails?\n\nEmacs is full of **incredible software concepts that haven\'t hit the\nmainstream yet**. For example:\n\n* Many platforms have a single item clipboard. Emacs has an **infinite\n  clipboard**.\n* If you undo a change, and then continue editing, you can\'t redo the\n  original change. Emacs allows **undoing to any historical state**, even\n  allowing tree-based exploration of history.\n* Emacs supports a **reverse variable search**: you can find variables\n  with a given value.\n* You can perform **structural editing** of code, allowing you to make\n  changes without breaking syntax. This works for lisps (paredit) and\n  non-lisps (smartparens).\n* Many applications use a modal GUI: for example, you can\'t do other\n  edits during a find-and-replace operation. Emacs provides\n  **recursive editing** that allow you to suspend what you\'re\n  currently doing, perform other edits, then continue the original\n  task.\n\nEmacs has a **documentation culture**. Emacs includes a usage manual,\na lisp programming manual, pervasive docstrings and even an\ninteractive tutorial.\n\nEmacs has **a broad ecosystem**. If you want to edit code in a\nniche language, there\'s probably an Emacs package for it.\n\nEmacs doesn\'t have a monopoly on good ideas, and there are other great\ntools out there. Nonetheless, we believe the [Emacs learning curve pays\noff](https://i.stack.imgur.com/7Cu9Z.jpg).\n\n# Why Rust?\n\nRust is a great alternative to C.\n\nRust has **a fantastic learning curve**. [The documentation is superb](https://doc.rust-lang.org/),\nand the community is very helpful if you get stuck.\n\nRust has **excellent tooling**. The compiler makes great suggestions,\nthe unit test framework is good, and `rustfmt` helps ensure formatting\nis beautiful and consistent.\n\nThe Rust **packaging story is excellent**. It\'s easy to reuse\nthe great libraries available, and just as easy to factor out code for\nthe benefit of others. We can replace entire C files in Emacs with\nwell-maintained Rust libraries.\n\nCode written in Rust **easily interoperates with C**. This means we\ncan **port to Rust incrementally**, and having a working Emacs at each\nstep of the process.\n\nRust provides **many compile-time checks**, making it much easier to write\nfast, correct code (even when using multithreading). This also makes\nit much easier for newcomers to contribute.\n\nGive it a try. We think you\'ll like it.\n\n# Why A Fork?\n\nEmacs is a widely used tool with a long history, broad platform\nsupport and strong backward compatibility requirements. The core team\nis understandably cautious in making far-reaching changes.\n\nForking is a longstanding tradition in the Emacs community for trying\ndifferent approaches. Notable Emacs forks include [XEmacs](http://www.xemacs.org/),\n[Guile Emacs](https://www.emacswiki.org/emacs/GuileEmacs),\nand [emacs-jit](https://github.com/burtonsamograd/emacs-jit).\n\nThere have also been separate elisp implementations, such as\n[Deuce](https://github.com/hraberg/deuce),\n[JEmacs](http://jemacs.sourceforge.net/) and\n[El Compilador](https://github.com/tromey/el-compilador).\n\nBy forking, we can **explore new development approaches**. We can\nuse a pull request workflow with integrated CI.\n\nWe can **drop legacy platforms and compilers**. Remacs will never run\non MS-DOS, and that\'s OK.\n\nThere\'s a difference between **the idea of Emacs** and the **current\nimplementation of Emacs**. Forking allows us to explore being even\nmore Emacs-y.\n\n# Getting Started\n\n## Requirements\n\n1. You will need\n   [Rust installed](https://www.rust-lang.org/en-US/install.html). \n   The file `rust-toolchain` indicates the version that gets installed.\n   This happens automatically, so don\'t override the toolchain manually.\n   IMPORTANT: Whenever the toolchain updates, you have to reinstall\n   rustfmt manually.\n\n2. You will need a C compiler and toolchain. On Linux, you can do\n   something like:\n\n        apt install build-essential automake clang libclang-dev\n\n   On macOS, you\'ll need Xcode.\n\n3. Linux:\n\n        apt install texinfo libjpeg-dev libtiff-dev \\\n          libgif-dev libxpm-dev libgtk-3-dev gnutls-dev \\\n          libncurses5-dev libxml2-dev libxt-dev\n\n   macOS:\n   \n        brew install gnutls texinfo autoconf\n        \n    To use the installed version of `makeinfo` instead of the built-in \n    (`/usr/bin/makeinfo`) one, you\'ll need to make sure `/usr/local/opt/texinfo/bin` \n    is before `/usr/bin` in `PATH`.\n    Mojave install libxml2 headers with: `open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg`\n\n## Dockerized development environment\n\nIf you don\'t want to bother with the above setup you can use the\nprovided Docker environment. Make sure you have\n[docker](https://www.docker.com/) 1.12+ and\n[docker-compose](https://github.com/docker/compose) 1.8+ available.\n\nTo spin up the environment run\n\n``` shell\ndocker-compose up -d\n```\n\nThe first time you run this command, Docker will build the image. After\nthat any subsequent startups will happen in less than a second. If\nthis command fails because of needing absolute paths, make sure to set\nthe PWD environment variable before calling the command like so:\n\n```shell\nPWD=$(pwd) docker-compose up -d\n```\n\nThe working directory with remacs will be mounted under the same path\nin the container so editing the files on your host machine will\nautomatically be reflected inside the container. To build remacs use\nthe steps from [Building Remacs](#building-remacs) prefixed with\n`docker-compose exec remacs`, this will ensure the commands are\nexecuted inside the container.\n\n## Building Remacs\n\n```\n$ ./autogen.sh\n$ ./configure --enable-rust-debug\n$ make\n```\n\nFor a release build, don\'t pass `--enable-rust-debug`.\n\nThe Makefile obeys cargo\'s RUSTFLAGS variable and additional options\ncan be passed to cargo with CARGO_FLAGS.\n\nFor example:\n\n``` bash\n$ make CARGO_FLAGS="-vv" RUSTFLAGS="-Zunstable-options --cfg MARKER_DEBUG"\n```\n\n## Running Remacs\n\nYou can now run your shiny new Remacs build!\n\n```bash\n# Using -q to ignore your .emacs.d, so Remacs starts up quickly.\n# RUST_BACKTRACE is optional, but useful if your instance crashes.\n$ RUST_BACKTRACE=1 src/remacs -q\n```\n\n# Design Goals\n\n**Compatibility**: Remacs should not break existing elisp code, and\nideally provide the same FFI too.\n\n**Leverage Rust itself**: Remacs should make best use of Rust to\nensure code is robust and performant.\n\n**Leverage the Rust ecosystem**: Remacs should use existing Rust\ncrates wherever possible, and create new, separate crates where our\ncode could benefit others.\n\n**Great docs**: Emacs has excellent documentation, Remacs should be no\ndifferent.\n\n# Progress\n\nAt this point we focus on porting lisp functions from C to Rust.\nCurrently there are 642 functions in Rust and 823 in C (May 2019).\n\nWe have a [progress section](https://github.com/Wilfred/remacs/wiki/Progress) in our wiki\nand there\'s also a list of [long-term goals](https://github.com/Wilfred/remacs/projects/1) \nunder projects.\n\n# Porting Elisp Primitive Functions\n\nThe first thing to look at is the C implementation for the `atan` function. It takes an optional second argument, which makes it interesting. The complicated mathematical bits, on the other hand, are handled by the standard library. This allows us to focus on the porting process without getting distracted by the math.\n\nThe Lisp values we are given as arguments are tagged pointers; in this case they are pointers to doubles. The code has to check the tag and follow the pointer to retrieve the real values. Note that this code invokes a C macro (called `DEFUN`) that reduces some of the boilerplate. The macro declares a static variable called `Satan` that holds the metadata the Lisp compiler will need in order to successfully call this function, such as the docstring and the pointer to the `Fatan` function, which is what the C implementation is named:\n\n``` c\nDEFUN ("atan", Fatan, Satan, 1, 2, 0,\n       doc: /* Return the inverse tangent of the arguments.\nIf only one argument Y is given, return the inverse tangent of Y.\nIf two arguments Y and X are given, return the inverse tangent of Y\ndivided by X, i.e. the angle in radians between the vector (X, Y)\nand the x-axis.  */)\n  (Lisp_Object y, Lisp_Object x)\n{\n  double d = extract_float (y);\n  if (NILP (x))\n    d = atan (d);\n  else\n    {\n      double d2 = extract_float (x);\n      d = atan2 (d, d2);\n    }\n  return make_float (d);\n}\n```\n\n`extract_float` checks the tag (signalling an "invalid argument" error if it\'s not the tag for a double), and returns the actual value. `NILP` checks to see if the tag indicates that this is a null value, indicating that the user didn\'t supply a second argument at all.\n\nNext take a look at the current Rust implementation. It must also take an optional argument, and it also invokes a (Rust) macro to reduce the boilerplate of declaring the static data for the function. However, it also takes care of all of the type conversions and checks that we need to do in order to handle the arguments and return value:\n\n``` rust\n/// Return the inverse tangent of the arguments.\n/// If only one argument Y is given, return the inverse tangent of Y.\n/// If two arguments Y and X are given, return the inverse tangent of Y\n/// divided by X, i.e. the angle in radians between the vector (X, Y)\n/// and the x-axis\n#[lisp_fn(min = "1")]\npub fn atan(y: EmacsDouble, x: Option<EmacsDouble>) -> EmacsDouble {\n    match x {\n        None => y.atan(),\n        Some(x) => y.atan2(x)\n    }\n}\n```\n\nYou can see that we don\'t have to check to see if our arguments are of the correct type, the code generated by the `lisp_fn` macro does this for us. We also asked for the second argument to be an `Option<EmacsDouble>`. This is the Rust type for a value which is either a valid double or isn\'t specified at all. We use a match statement to handle both cases.\n\nThis code is so much better that it\'s hard to believe just how simple the implementation of the macro is. It just calls `.into()` on the arguments and the return value; the compiler does the rest when it dispatches this method call to the correct implementation.\n\n# Contributing\n\nPull requests welcome, no copyright assignment required. This project is under the\n[Rust code of conduct](https://www.rust-lang.org/policies/code-of-conduct).\n\nThere\'s lots to do! We keep a list of [low hanging fruit](https://github.com/Wilfred/remacs/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22) here so you can easily choose\none. You can find information in the [Porting cookbook](https://github.com/Wilfred/remacs/wiki/Porting-cookbook) or ask for help in our [Gitter channel](https://gitter.im/remacs-discuss/Lobby).\n'