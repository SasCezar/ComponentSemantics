b'cmake-ide\n==========\n\n[![Build Status](https://travis-ci.org/atilaneves/cmake-ide.svg?branch=master)](https://travis-ci.org/atilaneves/cmake-ide)\n[![Coverage Status](https://coveralls.io/repos/github/atilaneves/cmake-ide/badge.svg?branch=master)](https://coveralls.io/github/atilaneves/cmake-ide?branch=master)\n[![Melpa Status](http://melpa.milkbox.net/packages/cmake-ide-badge.svg)](http://melpa.milkbox.net/#/cmake-ide)\n\nCppCon 2015 Lightning talk on cmake-ide:\n----------------------------------------\n\n[![CppCon 2015 Lightning talk on cmake-ide](http://img.youtube.com/vi/5FQwQ0QWBTU/0.jpg)](http://www.youtube.com/watch?v=5FQwQ0QWBTU "Emacs as a C++ IDE")\n\nIntroduction\n------------\n\n`cmake-ide` is a package to enable IDE-like features on Emacs for\n[CMake](http://www.cmake.org/) projects. It also supports non-CMake\nprojects as long as a\n[compilation database](http://clang.llvm.org/docs/JSONCompilationDatabase.html)\nis generated out-of-band.This includes autocompletion and on-the-fly\nsyntax checking in Emacs for CMake projects with minimal\nconfiguration. It uses other packages to do its heavy lifting, in a\ncombination of:\n\n* [rtags](https://github.com/Andersbakken/rtags)\n* [flycheck](https://github.com/flycheck/flycheck)\n* [auto-complete-clang](https://github.com/brianjcj/auto-complete-clang)\n* [company-clang](https://github.com/company-mode/company-mode/blob/master/company-clang.el)\n* [irony](https://github.com/Sarcasm/irony-mode)\n\n`cmake-ide` will set variables and call functions for the installed\ndependent packages.\n\nIt works by running CMake in Emacs in order to obtain the necessary\ncompiler flags to pass to the other tools. Since all\nthe dependencies are specified in the CMake scripts, there is no\nneed to maintain a parallel dependency tracking system for Emacs.\nJust ask CMake.\n\nFeatures\n--------\n* Sets variables for `auto-complete-clang`, `flycheck` and others for a CMake\n  project automagically. Hardly any configuration necessary.\n* Automatically reruns CMake when a file is saved. Great when using\nCMake file globs to pick up newly created files, but needs\n`cmake-ide-build-dir` to be set.\n* `cmake-ide-delete-file` allows you to have the same convenience when\ndeleting files. I can\'t figure out a better way to do this. Obviously\nsimply deleting the file means having to run CMake again manually for\nit to register the change in the list of files to be compiled.\n* If `cmake-ide-build-dir` is set, it is considered to be the build\ndirectory to run CMake in. Additionally, this will cause\n`cmake-ide-compile` to compile the project there. It automatically\ndetects Ninja and Make builds and sets the compile command\naccordingly. The command to use can be customised by setting\nthe `cmake-compile-command` variable.\n* `cmake-ide` can make usage of\n[rtags](https://github.com/Andersbakken/rtags) for finding\ndefinitions, also using clang. If `(require \'rtags)` is called before\n`cmake-ide-setup`, it will automatically start the rtags server (`rdm`)\nand call `rc -J` to index the project files for 0-config "jump to\ndefinition" and everything else rtags offers.  This only works if both\n`rdm` and `rc` and in the system path or if `cmake-ide-rdm-executable`\nand `cmake-ide-rc-executable` are customized correctly.\n\nBuild Pool Directories and Persistent Naming of Automatic Build Directories\n-----------------------------------------------------------------------------------\n\n`cmake-ide` can automatically create build directories for you -- either in the system\'s\ntmp-directory or under `cmake-ide-build-pool-dir` (if set). By default, all automatically\ncreated build directories (no matter where created) will have temporary and unique names,\nthat will change with each new session and are thus not reusable. You can, however, by\nsetting `cmake-ide-build-pool-use-persistent-naming` use a reproducible naming scheme that\nis based on the project\'s path and will not change as long as the project\'s path is the\nsame. This way, you can reuse the build directory.\n\nBy using both `cmake-ide-build-pool-dir` and `cmake-ide-build-pool-use-persistent-naming`,\nyou can fully do away with the need to configure a build directory per project with directory\nlocal variables (for example).\n\nNon-CMake projects\n------------------\n\nUse `.dir-locals.el` to set the `cmake-ide-project-dir` and `cmake-ide-build-dir` variables\n(use absolute paths).\n\n.dir-locals.el:\n  ((nil . ((cmake-ide-build-dir . "/path/to/build/dir")\n         (cmake-ide-project-dir . "/path/to/project/dir"))))\n\nIf a file called `compile_commands.json` exists in `cmake-ide-build-dir`,\nit will work just as well as for CMake projects. Bear (https://github.com/rizsotto/Bear)\ncan be used to generate a compile_commands.json from a make command.\n\n\nInstallation\n------------\n\nInstall from [MELPA](https://melpa.org) or [MELPA Stable](https://stable.melpa.org/) with:\n\n    M-x package-install RET cmake-ide.\n\n\nUsage\n-----\n\nAdd this to your `.emacs` / `init.el`:\n\n    (require \'rtags) ;; optional, must have rtags installed\n    (cmake-ide-setup)\n\nIf `cmake-ide-flags-c` or `cmake-ide-flags-c++` are set, they will be\nadded to `ac-clang-flags` and `company-clang-arguments`.  These\nvariables should be set. Particularly, they should contain the system\ninclude paths (e.g. `\'("-I/usr/include/c++/4.9.1" "...")`. For a\nsystem with gcc, you can get this information by running `gcc -v -xc++\n/dev/null -fsyntax-only` (it\'s the same prerequisite for\n`auto-complete-clang` to work, since that\'s how clang itself works).\n\nAnd... that\'s it. It works by calling cmake and parsing the resulting\nJSON file with compiler flags.  Set `cmake-ide-build-dir` to where your\nproject is being built and you won\'t have to call CMake manually again (except\nfor the first time to specify options). Best done with\n[directory local variables](https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html).\n\n\nRelated Projects:\n----------------\n* [cpputils-cmake](https://github.com/redguardtoo/cpputils-cmake).\n'