b'# <img align="right" src="https://raw.githubusercontent.com/nashamri/elsa-logo/master/elsa-logo-transparent.png" width="133" height="100"> Elsa - Emacs Lisp Static Analyser [![Build Status](https://travis-ci.org/emacs-elsa/Elsa.svg?branch=master)](https://travis-ci.org/emacs-elsa/Elsa)\n\n<p align="center">(Your favourite princess now in Emacs!)</p>\n\n[![Coverage Status](https://coveralls.io/repos/github/Fuco1/Elsa/badge.svg?branch=master)](https://coveralls.io/github/Fuco1/Elsa?branch=master) [![Paypal logo](https://img.shields.io/badge/PayPal-Donate-orange.svg?logo=paypal)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=A5PMGVKCQBT88) [![Patreon](https://img.shields.io/badge/Patreon-Become%20a%20patron-orange.svg?logo=patreon)](https://www.patreon.com/user?u=3282358)\n\nElsa is a tool that analyses your code without loading or running it.\nIt can track types and provide helpful hints when things don\'t match\nup before you even try to run the code.\n\n<!-- markdown-toc start - Don\'t edit this section. Run M-x markdown-toc-generate-toc again -->\n**Table of Contents**\n\n- [State of the project](#state-of-the-project)\n- [Non-exhaustive list of features](#non-exhaustive-list-of-features)\n    - [Detect dead code](#detect-dead-code)\n    - [Enforce style rules](#enforce-style-rules)\n    - [Look for suspicious code](#look-for-suspicious-code)\n    - [Track types of expressions](#track-types-of-expressions)\n- [How do I run it](#how-do-i-run-it)\n    - [Flycheck integration](#flycheck-integration)\n- [Configuration](#configuration)\n    - [Analysis extension](#analysis-extension)\n    - [Rulesets](#rulesets)\n- [Type annotations](#type-annotations)\n- [How can I contribute to this project](#how-can-i-contribute-to-this-project)\n- [F.A.Q.](#faq)\n    - [What\'s up with the logo?](#whats-up-with-the-logo)\n- [For developers](#for-developers)\n    - [How to write an extension for your-favourite-package](#how-to-write-an-extension-for-your-favourite-package)\n    - [How to write a ruleset](#how-to-write-a-ruleset)\n\n<!-- markdown-toc end -->\n\n# State of the project\n\nWe are currently in a very early *ALPHA* phase.  API is somewhat\nstable but the type system and annotations are under constant\ndevelopment.  Things might break at any point.\n\n# Non-exhaustive list of features\n\nHere comes a non-exhaustive list of some more interesting features.\n\nThe error highlightings in the screenshots are provided by [Elsa\nFlycheck extension](https://github.com/emacs-elsa/flycheck-elsa).\n\nEverything you see here actually works, this is not just for show!\n\n## Detect dead code\n\n### Detect suspicious branching logic\n\n![](./images/dead-code-1.png)\n\n![](./images/dead-code-2.png)\n\n### Find unreachable code in short-circuiting forms\n\n![](./images/unreachable-code-1.png)\n\n## Enforce style rules\n\n### Provide helpful tips for making code cleaner\n\n![](./images/useless-code-1.png)\n\n![](./images/useless-code-2.png)\n\n### Add custom rules for your own project with rulesets\n\n![](./images/custom-ruleset-1.png)\n\n### Make formatting consistent\n\n![](./images/formatting-1.png)\n\n## Look for suspicious code\n\n### Find references to free/unbound variables\n\n![](./images/unbound-variable-1.png)\n\n### Don\'t assign to free variables\n\n![](./images/unbound-variable-2.png)\n\n### Detect conditions which are always true or false\n\n![](./images/always-nil-1.png)\n\n![](./images/always-non-nil-1.png)\n\n### Make sure functions are passed enough arguments\n\n![](./images/number-of-args-1.png)\n\n### Make sure functions are not passed too many arguments\n\n![](./images/number-of-args-2.png)\n\n## Track types of expressions\n\n### Check types of arguments passed to functions for compatibility\n\n![](./images/type-inference-1.png)\n\n![](./images/type-inference-2.png)\n\n![](./images/type-inference-3.png)\n\n# How do I run it\n\nCurrently we only support running Elsa with [Cask](https://github.com/cask/cask).\n\n### [RECOMMENDED] Using packaged version\n\nThe easiest and fastest way to install Elsa is through\n[MELPA](http://melpa.org/#/) and [Cask](https://github.com/cask/cask).\n\n1. Add `(depends-on "elsa")` to `Cask` file of your project.\n2. Run `cask install`.\n3. `cask exec elsa FILE-TO-ANALYSE [ANOTHER-FILE...]` to analyse the file.\n\n### Using development version\n\nTo use the development version you can clone the repository and use\n`cask link` feature to use the code from the clone.\n\n1. `git clone https://github.com/emacs-elsa/Elsa.git` somewhere to your computer.\n2. Add `(depends-on "elsa")` to `Cask` file of your project.\n3. Run `cask link elsa <path-to-elsa-repo>`.\n4. `cask exec elsa FILE-TO-ANALYSE [ANOTHER-FILE...]` to analyse the file.\n\n## Flycheck integration\n\nIf you use [flycheck](https://github.com/flycheck/flycheck) you can\nuse the [flycheck-elsa](https://github.com/emacs-elsa/flycheck-elsa)\npackage which integrates Elsa with Flycheck.\n\n# Configuration\n\nBy default Elsa core comes with very little built-in logic, only\nunderstanding the elisp [special\nforms](https://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Forms.html).\n\nHowever, we ship a large number of extensions for popular packages\nsuch as `eieio`, `cl`, `dash` or even `elsa` itself.\n\nYou can configure Elsa by adding an `Elsafile.el` to your project.\nThe `Elsafile.el` should be located next to the `Cask` file.\n\nThere are multiple ways to extend the capabilities of Elsa.\n\n## Analysis extension\n\nOne is by providing special analysis rules for more forms and\nfunctions where we can exploit the knowledge of how the function\nbehaves to narrow the analysis down more.\n\nFor example, we can say that if the input of `not` is `t`, the return\nvalue is always `nil`.  This encodes our domain knowledge in form of\nan analysis rule.\n\nAll the rules are added in form of extensions.  Elsa has few core\nextensions for most common built-in functions such as list\nmanipulation (`car`, `nth`...), predicates (`stringp`, `atomp`...),\nlogical functions (`not`, ...) and so on.  These are automatically\nloaded because the functions are so common virtually every project is\ngoing to use them.\n\nAdditional extensions are provided for popular external packages such\nas [dash.el](https://github.com/magnars/dash.el).  To use them, add to\nyour `Elsafile.el` the `register-extensions` form, like so\n\n``` emacs-lisp\n(register-extensions\n dash\n ;; more extensions here\n )\n```\n\n## Rulesets\n\nAfter analysis of the forms is done we have all the type information\nand the AST ready to be further processed by various checks and rules.\n\nThese can be (non-exhaustive list):\n\n* Stylistic, such as checking that a variable uses `lisp-case` for\n  naming instead of `snake_case`.\n* Syntactic, such as checking we are not wrapping the else branch of\n  `if` with a useless `progn`.\n* Semantic, such as checking that the condition of `if` does not\n  always evaluate to `non-nil` (in which case the `if` form is\n  useless).\n\nElsa provides some built-in rulesets and more can also be used by loading extensions.\n\nTo register a ruleset, add the following form to `Elsafile.el`\n\n``` emacs-lisp\n(register-ruleset\n dead-code\n style\n ;; more rulesets here\n )\n```\n\n# Type annotations\n\nIn Elisp users are not required to provide type annotations to their\ncode.  While at many places the types can be inferred there are\nplaces, especially in user-defined functions, where we can not guess\nthe correct type (we can only infer what we see during runtime).\n\nUsers can annotate their `defun` definitions like this:\n\n``` emacs-lisp\n;; (elsa-pluralize :: String -> Int -> String)\n(defun elsa-pluralize (word n)\n  "Return singular or plural of WORD based on N."\n  (if (= n 1)\n      word\n    (concat word "s")))\n```\n\nThe `(elsa-pluralise :: ...)` inside a comment form provides\nadditional information to the Elsa analysis.  Here we say that the\nfunction following such a comment takes two arguments, string and int,\nand returns a string.\n\nThe syntax of the type annotation is somewhat modeled after Haskell\nbut there are some special constructs available to Elsa\n\nHere are general guidelines on how the types are constructed.\n\n- For built-in types with test predicates, drop the `p` or `-p` suffix and PascalCase to get the type:\n    - `stringp` \xe2\x86\x92 `String`\n    - `integerp` \xe2\x86\x92 `Integer` (`Int` is also accepted)\n    - `markerp` \xe2\x86\x92 `Marker`\n    - `hash-table-p` \xe2\x86\x92 `HashTable`\n- A type for everything is called `Mixed`.  It accepts anything and is\n  always nullable.  This is the default type for when we lack type\n  information.\n- Sum types can be specified with `|` syntax, so `String | Integer` is\n  a type accepting both strings or integers.\n- Cons types are specified by prefixing wrapping the `car` and `cdr`\n  types with a `Cons` constructor, so `Cons Int Int` is a type where\n  the `car` is an int and `cdr` is also an int, for example `(1 . 3)`.\n- List types are specified by wrapping a type in a vector `[]`\n  constructor, so `[Int]` is a list of integers and `[String | Int]`\n  is a list of items where each item is either a string or an integer.\n  A type constructor `List` is also supported.\n- Function types are created by separating argument types and the\n  return type with `->` token.\n- To make variadic types (for the `&rest` keyword) add three dots\n  `...` after the type, so `String... -> String` is a function taking\n  any number of strings and returning a string, such as `concat`.\n  Note: a variadic type is internally just a list of the same base\n  type but it has a flag that allows the function be of variable\n  arity.  A `Variadic` type constructor is also available to construct\n  complex types.\n- To mark type as nullable you can attach `?` to the end of it, so\n  that `Int?` accepts any integer and also a `nil`.  A `Maybe` type\n  constructor is also available to construct complex types.\n\nSome type constructors have optional arguments, for example writing\njust `Cons` will assume the `car` and `cdr` are of type `Mixed`.\n\n# How can I contribute to this project\n\nOpen an issue if you want to work on something (not necessarily listed\nbelow in the roadmap) so we won\'t duplicate work.  Or just give us\nfeedback or helpful tips.\n\nYou can provide type definitions for built-in functions by extending\n`elsa-typed-builtin.el`.  There is plenty to go.  Some of the types\nnecessary to express what we want might not exist or be supported yet,\nopen an issue so we can discuss how to model things.\n\n# F.A.Q.\n\n## What\'s up with the logo?\n\nSee the [discussion](https://github.com/emacs-elsa/Elsa/issues/80).\n\n# For developers\n\nAfter calling `(require \'elsa-font-lock)` there is a function\n`elsa-setup-font-lock` which can be called from `emacs-lisp-mode-hook`\nto set up some additional font-locking for Elsa types.\n\n## How to write an extension for your-favourite-package\n\n## How to write a ruleset\n'