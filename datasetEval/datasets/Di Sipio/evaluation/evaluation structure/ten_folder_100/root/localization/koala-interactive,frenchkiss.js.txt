b'<div align="center">\n  <h1>\xf0\x9f\x92\x8b FrenchKiss.js</h1>\n\n[![Build Status](https://travis-ci.com/koala-interactive/frenchkiss.js.svg?branch=master)](https://travis-ci.com/koala-interactive/frenchkiss.js)\n[![File size](https://img.shields.io/badge/GZIP%20size-1.1%20kB-brightgreen.svg)](./dist/umd/frenchkiss.js)\n![](https://img.shields.io/badge/dependencies-none-brightgreen.svg)\n![](https://img.shields.io/snyk/vulnerabilities/github/koala-interactive/frenchkiss.js.svg)\n[![License: MIT](https://img.shields.io/badge/License-MIT-brightgreen.svg)](https://opensource.org/licenses/MIT)\n\n</div>\n\nFrenchKiss.js is a blazing fast lightweight i18n library written in JavaScript, working both in the browser and NodeJS environments. It provides a simple and really fast solution for handling internationalization.\n\nFrenchKiss is by now, _the fastest i18n JS package_ out there, working **5 to 1000 times faster** than any others by **JIT compiling** the translations, try it by running the benchmarks !\n\n> #### Minimum requirements:\n>\n> ![Node 0.10](https://img.shields.io/badge/node-0.10-blue.svg) ![IE 9](https://img.shields.io/badge/IE-9-blue.svg)\n\n\xe2\x9a\xa0\xef\xb8\x8f  Frenchkiss is internaly using `new Function()` to create optimized functions. Therefore it can conflict when using [CSP (Content Security Policy)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) rules.\nYou can bypass it by disabling it by using the CSP keyword `unsafe-eval`, but it is generally not recommended as it would weaken the protections offered by CSP.\nWe will eventually work on a new version offering pre-compilation.\n\n---\n\n## \xf0\x9f\x9a\x80 Installation\n\nInstall with [yarn](https://yarnpkg.com):\n\n    $ yarn add frenchkiss\n\nOr install using [npm](https://npmjs.org):\n\n    $ npm i frenchkiss\n\n---\n\n## \xe2\x8f\xb3 Running the tests\n\n    $ npm test\n\n---\n\n## \xe2\x9a\x99\xef\xb8\x8f Running the benchmarks\n\n    $ cd benchmark\n    $ yarn\n    $ yarn start\n    $ open ./result.html\n\n![i18n benchmark](./benchmark/benchmark.jpg)\n\n---\n\n## \xf0\x9f\x93\x96 Documentation\n\n- [frenchkiss.locale()](#frenchkisslocalelanguage-string-string)\n- [frenchkiss.set()](#frenchkisssetlanguage-string-table-object)\n- [frenchkiss.t()](#frenchkisstkey-string-params-object-lang-string-string)\n- [frenchkiss.extend()](#frenchkissextendlanguage-string-table-object)\n- [frenchkiss.unset()](#frenchkiss.unsetlanguage-string)\n- [frenchkiss.fallback()](#frenchkissfallbacklanguage-string-string)\n- [frenchkiss.onMissingKey()](#frenchkissonMissingKeyfn-Function)\n- [frenchkiss.onMissingVariable()](#frenchkissonMissingVariablefn-Function)\n- [Nested keys](#nested-keys)\n- [SELECT expression](#select-expression)\n- [PLURAL expression](#plural-expression)\n- [Plural category](#plural-category)\n- [Nested expressions](#nested-expressions)\n\n### Minimal code\n\nTell FrenchKiss what to return by simply giving it a table object, where the key is the search reference and the value is the already-translated string.\n\n```js\nimport frenchkiss from \'frenchkiss\';\n\n// Define the locale language\nfrenchkiss.locale(\'en\');\n\n// Add translations in each languages\nfrenchkiss.set(\'en\', {\n  hello: \'Hello {name} !\',\n  fruits: {\n    apple: \'apples\'\n  },\n  // and other sentences...\n});\n\nfrenchkiss.t(\'hello\', {\n  name: \'John\',\n}); // => \'Hello John !\'\n\nfrenchkiss.t(\'fruits.apple\'); // => \'apples\'\n```\n\n---\n\n### frenchkiss.locale(language?: string): string\n\nGet or set the locale, it will define what table FrenchKiss have to work with.\n\n> **Note:** If you are working with NodeJS and concurrent requests, you can use the third parameter (language) of `t()` to avoid language collision.\n\n---\n\n### frenchkiss.set(language: string, table: object)\n\nDefine the translation table for the language. Any call to the specified language erase all the previously stored data.\n\n```js\nfrenchkiss.set(\'en\', {\n  hello: \'Hi, \',\n  howareyou: \'How are you ?\',\n  // ...\n});\n```\n\n---\n\n### frenchkiss.t(key: string, params?: object, lang?: string): string\n\nThe most used method to returns translation. It\'s built with performance in mind.\nHere is what you should know about it :\n\n- \xe2\x9c\x85 It does support multiple interpolation variable\n- \xe2\x9c\x85 It supports interpolation.\n- \xe2\x9c\x85 It supports `PLURAL`.\n- \xe2\x9c\x85 It supports `SELECT`.\n- \xe2\x9c\x85 It supports nested `PLURAL`, `SELECT` and `variables`.\n- \xe2\x9c\x85 It supports nested keys (using dots in keys).\n- \xe2\x9d\x8c It does not support date, number, currency formatting (maybe check for [Intl.NumberFormat](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/NumberFormat) and [Intl.DateTimeFormat](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/DateTimeFormat)).\n\n```js\nset(\'en\', {\n  hello: \'Hello {name} !\',\n});\n\nt(\'hello\'); // => \'Hello  !\'\nt(\'hello\', { name: \'John\' }); // => \'Hello John !\'\nt(\'hello\', { name: \'Anna\' }); // => \'Hello Anna !\'\n```\n\n> **Note:** By default, if no parameters are given it will be interpreted as an empty string.\n\nIf you are working with concurrent connections it\'s also possible to use the third parameter `lang` to force the language to use.\nDoing a generator that forces the language use and pass it to your function can be what you are looking for.\n\n```js\nfrenchkiss.locale(\'fr\');\nfrenchkiss.set(\'en\', {\n  hello: \'Hello {name} !\',\n});\n\n// Helper\nconst generateLanguageTranslator = lang => {\n  return (key, params) => frenchkiss.t(key, params, lang);\n};\n\n// Generate t that force language\nconst t = generateLanguageTranslator(\'en\');\n\n// Force result in english\nt(\'hello\'); // => \'Hello  !\'\nt(\'hello\', { name: \'John\' }); // => \'Hello John !\'\nt(\'hello\', { name: \'Anna\' }); // => \'Hello Anna !\'\n```\n\n---\n\n### frenchkiss.extend(language: string, table: object)\n\nExtend the translation table for the language. In contrary of `set()`, the previously stored data will be kept.\n\n---\n\n### frenchkiss.unset(language: string)\n\nIf you need to clean the data of a stored language for memory optimizations, unset is all you need.\n\n---\n\n### frenchkiss.fallback(language?: string): string\n\nGet or set the fallback. Define what table FrenchKiss will use to fallback in case the locale table doesn\'t have the required translation.\n\n```js\nimport { locale, fallback, set, t } from \'frenchkiss\';\n\nset(\'fr\', {\n  hello: \'Bonjour, \',\n});\n\nset(\'en\', {\n  hello: \'Hi, \',\n  howareyou: \'How are you ?\',\n});\n\nlocale(\'fr\');\nfallback(\'en\');\n\nt(\'hello\'); // => \'Bonjour, \' <- from \'fr\' locale\nt(\'howareyou\'); // => \'How are you ?\' <- from \'en\' fallback\n```\n\n---\n\n### frenchkiss.onMissingKey(fn: Function)\n\nWhen the client requests a missing key, frenchKiss will returns the key as result. It\'s possible to handle it and return what you want or just send an event to your error reporting system.\n\n```js\nfrenchkiss.t(\'missingkey\'); // => \'missingkey\'\n\nfrenchkiss.onMissingKey((key, params, locale) => {\n  // Send error to your server\n  sendReport(`Missing the key "${key}" in ${frenchkiss.locale()} language.`);\n\n  // Returns the text you want\n  return `An error happened (${key})`;\n});\n\nfrenchkiss.t(\'missingkey\'); // => \'An error happened (missingkey)\'\n```\n\n---\n\n### frenchkiss.onMissingVariable(fn: Function)\n\nIt\'s possible to handle missing variables, sending errors to your monitoring server or handle it directly by returning something to replace with.\n\n```js\nfrenchkiss.set(\'en\', {\n  hello: \'Hello {name} !\',\n});\nfrenchkiss.locale(\'en\');\n\nfrenchkiss.t(\'hello\'); // => \'Hello  !\'\n\nfrenchkiss.onMissingVariable((variable, key, language) => {\n  // Send error to your server\n  sendReport(`Missing the variable "${variable}" in ${language}->${key}.`);\n\n  // Returns the text you want\n  return `[missing:${variable}]`;\n});\n\nfrenchkiss.t(\'hello\'); // => \'Hello [missing:name] !\'\n```\n\n---\n\n### Nested keys\n\nUnder the hood, frenchkiss allows you to handle nested keys, by using `\'.\'` inside key names.\n\n```js\nfrenchkiss.set(\'en\', {\n  fruits: {\n    apple: \'An apple\',\n    banana: \'A banana\'\n  },\n  vegetables: {\n    carrot: \'A carrot\',\n    daikon: \'A daikon\'\n  }\n});\n\nfrenchkiss.t(\'fruits.apple\') // => \'An apple\'\n```\n\nAccessing an object directly will result on the `onMissingKey` method to be called:\n\n```js\nfrenchkiss.set(\'en\', {\n  fruits: {\n    apple: \'An apple\',\n    banana: \'A banana\'\n  }\n});\n\nfrenchkiss.onMissingKey(key => `[notfound:${key}]`);\nfrenchkiss.t(\'fruits\'); // => \'[notfound:fruits]\'\n```\n\nIn case of duplicate names on key and objects, do not expect the result to be uniform (in fact, just don\'t do it).\n\n```js\nfrenchkiss.set(\'en\', {\n  \'fruits.apple.green\': 1,\n  \'fruits.apple\': {\n    \'green\': 2\n  },\n  \'fruits\': {\n    \'apple.green\': 3\n    \'apple\': {\n      \'green\': 4\n    }\n  }\n});\n\nfrenchkiss.t(\'fruits.apple.green\'); // => \'1\' or \'2\' or \'3\' or \'4\'\n```\n\n---\n\n### SELECT expression\n\nIf you need to display different text messages depending on the value of a variable, you need to translate all of those text messages... or you can handle this with a select ICU expression.\n\n```js\nset(\'en\', {\n  your_pet:\n    \'You own {pet, select, dog{a good boy} cat{an evil cat} other{a {pet} ! What is that?}}!\',\n});\n\nt(\'your_pet\', { pet: \'dog\' }); // => \'You own a good boy!\'\nt(\'your_pet\', { pet: \'cat\' }); // => \'You own an evil cat!\'\nt(\'your_pet\', { pet: \'rat\' }); // => \'You own a rat ! What is that?!\'\n```\n\n- The first parameter is the variable you want to check (`pet`).\n- The second parameter identifies this as a `select` expression type.\n- The third parameter is a pattern consisting of keys and their matching values.\n\n> Phrases support select expression, based on [ICU FormatMessage](http://userguide.icu-project.org/formatparse/messages).\n\n---\n\n### PLURAL expression\n\nIt\'s basically the same as select, except you have to use the "=" symbol for direct checking.\n\n```js\nset(\'en\', {\n  bought_apple:\n    \'I {count, plural, =0{bought no apples} =1{bought one apple} other{bought {count} apples}}!\',\n});\n\nt(\'bought_apple\', { count: 0 }); // => \'I bought no apples!\'\nt(\'bought_apple\', { count: 1 }); // => \'I bought one apple!\'\nt(\'bought_apple\', { count: 5 }); // => \'I bought 5 apples!\'\n```\n\n- The first parameter is the variable you want to check.\n- The second parameter identifies this as a `plural` expression type.\n- The third parameter is a pattern consisting of keys and their matching values.\n\n> \xe2\x9a\xa0\xef\xb8\x8f Like the select expression, the plural is a lightweight version of [ICU FormatMessage](http://userguide.icu-project.org/formatparse/messages) (`offset:1` and `#` are not integrated).\n\n---\n\n### Plural Category\n\nIt\'s also possible to work with plural category. Multiple languages have multiple pluralization rules. You\'ll have to write a function returning the type to check.\nThe functions are not included by default in the package (not needed in most cases). But you can get some of them from [PLURAL.md](./PLURAL.md) file.\n\n```js\nimport { locale, set, t, plural } from \'frenchkiss\';\n\nset(\'en\', {\n  takemymoney:\n    \'Take {N} dollar{N, plural, one{} =5{s! Take it} other{s}} please.\',\n});\nset(\'fr\', {\n  takemymoney:\n    "Prenez {N} dollar{N, plural, one{} =5{s! Prenez le} other{s}} s\'il vous plait.",\n});\n\n// Set here your plural category function\nplural(\'en\', n => {\n  const i = Math.floor(Math.abs(n));\n  const v = n.toString().replace(/^[^.]*\\.?/, \'\').length;\n  return i === 1 && v === 0 ? \'one\' : \'other\';\n});\n\nplural(\'fr\', n => {\n  const i = Math.floor(Math.abs(n));\n  return i === 0 || i === 1 ? \'one\' : \'other\';\n});\n// etc.\n\nlocale(\'en\'); // rules to locale = \'en\'\nt(\'takemymoney\', { N: 0 }); // => "Take 0 dollars please."\nt(\'takemymoney\', { N: 1 }); // => "Take 1 dollar please."\nt(\'takemymoney\', { N: 2 }); // => "Take 2 dollars please."\nt(\'takemymoney\', { N: 5 }); // => "Take 5 dollars! Take it please."\n\nlocale(\'fr\'); // rules to locale = \'fr\'\nt(\'takemymoney\', { N: 0 }); // => "Prenez 0 dollar s\'il vous plait."\nt(\'takemymoney\', { N: 1 }); // => "Prenez 1 dollar s\'il vous plait."\nt(\'takemymoney\', { N: 2 }); // => "Prenez 2 dollars s\'il vous plait."\nt(\'takemymoney\', { N: 5 }); // => "Prenez 5 dollars! Prenez le s\'il vous plait."\n```\n\n---\n\n### Nested expressions\n\nFor advanced usage, it\'s also possible to do nested select, plural and interpolations.\n\n```js\nset(\'fr\', {\n  timeago: `Updated: {minutes, plural,\n    =0 {just now}\n    =1 {one minute ago}\n    other {\n      {minutes} minutes ago by {gender, select,\n        male {male}\n        female {female}\n        other {other}\n      }\n    }\n  }`,\n});\n\nt(\'timeago\', { minutes: 0, gender: \'male\' }); // => \'Updated: just now\'\nt(\'timeago\', { minutes: 1, gender: \'male\' }); // => \'Updated: one minute ago\'\nt(\'timeago\', { minutes: 5, gender: \'male\' }); // => \'Updated: 5 minutes ago by male\'\n```\n\n---\n\n## \xf0\x9f\x94\x97 Related projects\n\n- [i18next-scanner](https://github.com/i18next/i18next-scanner): Scan your code, extract translation keys/values, and merge them into i18n resource files.\n- [i18n-extract](https://github.com/oliviertassinari/i18n-extract): Manage localization with static analysis. (report unused/missing/duplicated key, extract them).\n'