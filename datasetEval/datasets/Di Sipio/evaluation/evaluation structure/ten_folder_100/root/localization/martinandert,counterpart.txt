b'# Counterpart\n\nA translation and localization library for Node.js and the browser. The project is inspired by Ruby\'s famous [I18n gem](https://github.com/svenfuchs/i18n).\n\nFeatures:\n\n-  translation and localization\n-  interpolation of values to translations (sprintf-style with named arguments)\n-  pluralization (CLDR compatible)\n\n\n## Installation\n\nInstall via npm:\n\n```bash\n% npm install counterpart\n```\n\n\n## Usage\n\nRequire the counterpart module to get a reference to the `translate` function:\n\n```js\nvar translate = require(\'counterpart\');\n```\n\nThis function expects a `key` and `options` as arguments and translates, pluralizes and interpolates a given key using a given locale, scope, and fallback, as well as interpolation values.\n\n### Lookup\n\nTranslation data is organized as a nested object using the top-level key as namespace. *E.g.*, the [damals package](https://github.com/martinandert/damals) ships with the translation:\n\n```js\n{\n  damals: {\n    about_x_hours_ago: {\n      one:   \'about one hour ago\',\n      other: \'about %(count)s hours ago\'\n    }\n    /* ... */\n  }\n}\n```\n\nTranslations can be looked up at any level of this object using the `key` argument and the `scope` option. *E.g.*, in the following example, a whole translation object is returned:\n\n```js\ntranslate(\'damals\')  // => { about_x_hours_ago: { one: \'...\', other: \'...\' } }\n```\n\nThe `key` argument can be either a single key, a dot-separated key or an array of keys or dot-separated keys. So these examples will all look up the same translation:\n\n```js\ntranslate(\'damals.about_x_hours_ago.one\')          // => \'about one hour ago\'\ntranslate([\'damals\', \'about_x_hours_ago\', \'one\'])  // => \'about one hour ago\'\ntranslate([\'damals\', \'about_x_hours_ago.one\'])     // => \'about one hour ago\'\n```\n\nThe `scope` option can be either a single key, a dot-separated key or an array of keys or dot-separated keys. Keys and scopes can be combined freely. Again, these examples will all look up the same translation:\n\n```js\ntranslate(\'damals.about_x_hours_ago.one\')\ntranslate(\'about_x_hours_ago.one\', { scope: \'damals\' })\ntranslate(\'one\', { scope: \'damals.about_x_hours_ago\' })\ntranslate(\'one\', { scope: [\'damals\', \'about_x_hours_ago\'] })\n```\n\nThe `separator` option allows you to change what the key gets split via for nested objects. It also allows you to stop counterpart splitting keys if you have a flat object structure:\n\n```js\ntranslate(\'damals.about_x_hours_ago.one\', { separator: \'*\' })\n// => \'missing translation: en*damals.about_x_hours_ago.one\'\n```\n\nSince we changed what our key should be split by counterpart will be looking for the following object structure:\n\n```js\n{\n  \'damals.about_x_hours_ago.one\': \'about one hour ago\'\n}\n```\n\nThe `setSeparator` function allows you to globally change the default separator used to split translation keys:\n\n```js\ntranslate.setSeparator(\'*\') // => \'.\' (returns the previous separator)\n```\n\nThere is also a `getSeparator` function which returns the currently set default separator.\n\n### Interpolation\n\nTranslations can contain interpolation variables which will be replaced by values passed to the function as part of the options object, with the keys matching the interpolation variable names.\n\n*E.g.*, with a translation `{ foo: \'foo %(bar)s\' }` the option value for the key `bar` will be interpolated into the translation:\n\n```js\ntranslate(\'foo\', { bar: \'baz\' }) // => \'foo baz\'\n```\n\n### Pluralization\n\nTranslation data can contain pluralized translations. Pluralized translations are provided as a sub-object to the translation key containing the keys `one`, `other` and optionally `zero`:\n\n```js\n{\n  x_items: {\n    zero:  \'No items.\',\n    one:   \'One item.\',\n    other: \'%(count)s items.\'\n  }\n}\n```\n\nThen use the `count` option to select a specific pluralization:\n\n```js\ntranslate(\'x_items\', { count: 0  })  // => \'No items.\'\ntranslate(\'x_items\', { count: 1  })  // => \'One item.\'\ntranslate(\'x_items\', { count: 42 })  // => \'42 items.\'\n```\n\nThe name of the option to select a pluralization is always `count`, don\'t use `itemsCount` or anything like that.\n\nNote that this library currently only supports an algorithm for English-like pluralization rules (see [locales/en.js](locales/en.js). You can easily add  pluralization algorithms for other locales by [adding custom translation data](#adding-translation-data) to the "counterpart" namespace. Pull requests are welcome.\n\nAs seen above, the `count` option can be used both for pluralization and interpolation.\n\n### Fallbacks\n\nIf for a key no translation could be found, `translate` returns an error string of the form "translation missing: %(key)s".\n\nTo mitigate this, provide the `fallback` option with an alternate text. The following example returns the translation for "baz" or "default" if no translation was found:\n\n```js\ntranslate(\'baz\', { fallback: \'default\' })\n```\n\n### Dealing with missing translations\n\nWhen a translation key cannot be resolved to a translation, regardless of whether a fallback is provided or not, `translate` will emit an event you can listen to:\n\n```js\ntranslate.onTranslationNotFound(function(locale, key, fallback, scope) {\n  // do important stuff here...\n});\n```\n\nUse `translate.offTranslationNotFound(myHandler)` to stop listening to missing key events.\n\nAs stated in the Fallbacks section, if for a key no translation could be found, `translate` returns an error string of the form "translation missing: %(key)s".\n\nYou can customize this output by providing your own missing entry generator function:\n\n```js\ntranslate.setMissingEntryGenerator(function(key) {\n  // console.error(\'Missing translation: \' + key);\n  return \'OMG! No translation available for \' + key;\n});\n```\n\n### Locales\n\nThe default locale is English ("en"). To change this, call the `setLocale` function:\n\n```js\ntranslate.getLocale()     // => \'en\'\ntranslate.setLocale(\'de\') // => \'en\' (returns the previous locale)\ntranslate.getLocale()     // => \'de\'\n```\n\nNote that it is advised to call `setLocale` only once at the start of the application or when the user changes her language preference. A library author integrating the counterpart package in a library should not call `setLocale` at all and leave that to the developer incorporating the library.\n\nIn case of a locale change, the `setLocale` function emits an event you can listen to:\n\n```js\ntranslate.onLocaleChange(function(newLocale, oldLocale) {\n  // do important stuff here...\n}, [callbackContext]);\n```\n\nUse `translate.offLocaleChange(myHandler)` to stop listening to locale changes.\n\nYou can temporarily change the current locale with the `withLocale` function:\n\n```js\ntranslate.withLocale(otherLocale, myCallback, [myCallbackContext]);\n```\n\n`withLocale` does not emit the locale change event. The function returns the return value of the supplied callback argument.\n\nAnother way to temporarily change the current locale is by using the `locale` option on `translate` itself:\n\n```js\ntranslate(\'foo\', { locale: \'de\' });\n```\n\nThere are also `withScope` and `withSeparator` functions that behave exactly the same as `withLocale`.\n\n### Fallback Locales\n\nYou can provide entire fallback locales as alternatives to hard-coded fallbacks.\n\n```js\ntranslate(\'baz\', { fallbackLocale: \'en\' });\n```\n\nFallback locales can also contain multiple potential fallbacks. These will be tried sequentially until a key returns a successful value, or the fallback locales have been exhausted.\n\n```js\ntranslate(\'baz\', { fallbackLocale: [ \'foo\', \'bar\', \'default\' ] })\n```\n\nGlobally, fallback locales can be set via the `setFallbackLocale` method.\n\n```js\ntranslate.setFallbackLocale(\'en\')\ntranslate.setFallbackLocale([ \'bar\', \'en\' ]) // Can also take multiple fallback locales\n```\n\n### Adding Translation Data\n\nYou can use the `registerTranslations` function to deep-merge data for a specific locale into the global translation object:\n\n```js\ntranslate.registerTranslations(\'de\', require(\'counterpart/locales/de\'));\ntranslate.registerTranslations(\'de\', require(\'./locales/de.json\'));\n```\n\nThe data object to merge should contain a namespace (e.g. the name of your app/library) as top-level key. The namespace ensures that there are no merging conflicts between different projects. Example (./locales/de.json):\n\n```json\n{\n  "my_project": {\n    "greeting": "Hallo, %(name)s!",\n    "x_items": {\n      "one":   "1 St\xc3\xbcck",\n      "other": "%(count)s St\xc3\xbccke"\n    }\n  }\n}\n```\n\nThe translations are instantly made available:\n\n```js\ntranslate(\'greeting\', { scope: \'my_project\', name: \'Martin\' })  // => \'Hallo, Martin!\'\n```\n\nNote that library authors should preload their translations only for the default ("en") locale, since tools like [webpack](http://webpack.github.io/) or [browserify](http://browserify.org/) will recursively bundle up all the required modules of a library into a single file. This will include even unneeded translations and so unnecessarily bloat the bundle.\n\nInstead, you as a library author should advise end-users to on-demand-load translations for other locales provided by your package:\n\n```js\n// Execute this code to load the \'de\' translations:\nrequire(\'counterpart\').registerTranslations(\'de\', require(\'my_package/locales/de\'));\n```\n\n### Registering Default Interpolations\n\nSince v0.11, Counterpart allows you to register default interpolations using the `registerInterpolations` function. Here is an example:\n\n```js\ntranslate.registerTranslations(\'en\', {\n  my_namespace: {\n    greeting: \'Welcome to %(app_name)s, %(visitor)s!\'\n  }\n});\n\ntranslate.registerInterpolations({ app_name: \'My Cool App\' });\n\ntranslate(\'my_namespace.greeting\', { visitor: \'Martin\' })\n// => \'Welcome to My Cool App, Martin!\'\n\ntranslate(\'my_namespace.greeting\', { visitor: \'Martin\', app_name: \'The Foo App\' })\n// => \'Welcome to The Foo App, Martin!\'\n```\n\nAs you can see in the last line of the example, interpolations you give as options to the `translate` function take precedence over registered interpolations.\n\n### Using a key transformer\n\nSometimes it is necessary to adjust the given translation key before the actual translation is made, e.g. when keys are passed in mixed case and you expect them to be all lower case. Use `setKeyTransformer` to provide your own transformation function:\n\n```js\ntranslate.setKeyTransformer(function(key, options) {\n  return key.toLowerCase();\n});\n```\n\nCounterpart\'s built-in key transformer just returns the given key argument.\n\n### Localization\n\nThe counterpart package comes with support for localizing JavaScript Date objects. The `localize` function expects a date and options as arguments. The following example demonstrates the possible options.\n\n```js\nvar date = new Date(\'Fri Feb 21 2014 13:46:24 GMT+0100 (CET)\');\n\ntranslate.localize(date)                       // => \'Fri, 21 Feb 2014 13:46\'\ntranslate.localize(date, { format: \'short\' })  // => \'21 Feb 13:46\'\ntranslate.localize(date, { format: \'long\' })   // => \'Friday, February 21st, 2014 13:46:24 +01:00\'\n\ntranslate.localize(date, { type: \'date\' })                  // => \'Fri, 21 Feb 2014\'\ntranslate.localize(date, { type: \'date\', format: \'short\' }) // => \'Feb 21\'\ntranslate.localize(date, { type: \'date\', format: \'long\' })  // => \'Friday, February 21st, 2014\'\n\ntranslate.localize(date, { type: \'time\' })                  // => \'13:46\'\ntranslate.localize(date, { type: \'time\', format: \'short\' }) // => \'13:46\'\ntranslate.localize(date, { type: \'time\', format: \'long\' })  // => \'13:46:24 +01:00\'\n\ntranslate.registerTranslations(\'de\', require(\'counterpart/locales/de\'));\ntranslate.localize(date, { locale: \'de\' })  // => \'Fr, 21. Feb 2014, 13:46 Uhr\'\n```\n\nSure, you can integrate custom localizations by adding to or overwriting the "counterpart" namespace. See [locales/en.js](locales/en.js) and [locales/de.js](locales/de.js) for example localization files.\n\n### As an instance\n\nYou can invoke an instance of Counterpart should you need various locales displayed at once in your application:\n\n```js\nvar Counterpart = require(\'counterpart\').Instance;\n\nvar instance = new Counterpart();\n\ninstance.registerTranslations(\'en\', { foo: \'bar\' });\ninstance.translate(\'foo\');\n```\n\n### Error handling\n\nWhen a translation fails, `translate` will emit an event you can listen to:\n\n```js\ntranslate.onError(function(err, entry, values) {\n  // do some error handling here...\n});\n```\n\nUse `translate.offError(myHandler)` to stop listening for errors.\n\n## Contributing\n\nHere\'s a quick guide:\n\n1. Fork the repo and `make install`.\n1. Run the tests. We only take pull requests with passing tests, and it\'s great to know that you have a clean slate: `make test`.\n1. Add a test for your change. Only refactoring and documentation changes require no new tests. If you are adding functionality or are fixing a bug, we need a test!\n1. Make the test pass.\n1. Push to your fork and submit a pull request.\n\n\n## License\n\nReleased under The MIT License.\n'