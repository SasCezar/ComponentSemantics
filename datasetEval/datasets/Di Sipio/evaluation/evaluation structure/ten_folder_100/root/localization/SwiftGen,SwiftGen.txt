b'# SwiftGen\n\n[![CircleCI](https://circleci.com/gh/SwiftGen/SwiftGen/tree/master.svg?style=svg)](https://circleci.com/gh/SwiftGen/SwiftGen/tree/master)\n[![CocoaPods Compatible](https://img.shields.io/cocoapods/v/SwiftGen.svg)](https://img.shields.io/cocoapods/v/SwiftGen.svg)\n[![Platform](https://img.shields.io/cocoapods/p/SwiftGen.svg?style=flat)](http://cocoadocs.org/docsets/SwiftGen)\n\nSwiftGen is a tool to auto-generate Swift code for resources of your projects, to make them type-safe to use.\n\n<table border="0"><tr>\n  <td>\n    <img alt="SwiftGen Logo" src="https://github.com/SwiftGen/Eve/raw/master/logo/logo-256.png" />\n  </td><td>\n    <ul>\n        <li><a href="#installation">Installation</a>\n        <li><a href="#usage">Usage</a>\n        <li><a href="#choosing-your-template">Choosing your template</a>\n        <li><a href="#additional-documentation">Additional documentation</a>\n    </ul>\n    Then generate constants for:\n    <ul>\n      <li><a href="#asset-catalog">Assets Catalogs</a>\n      <li><a href="#colors">Colors</a>\n      <li><a href="#core-data">Core Data</a>\n      <li><a href="#fonts">Fonts</a>\n      <li><a href="#interface-builder">Interface Builder files</a>\n      <li><a href="#json-and-yaml">JSON and YAML files</a>\n      <li><a href="#plists">Plists</a>\n      <li><a href="#strings">Localizable strings</a>\n    </ul>\n  </td>\n</tr></table>\n\n<span style="float:none" />\n\nThere are multiple benefits in using this:\n\n* Avoid any typo you could have when using a String\n* Free auto-completion\n* Avoid the risk to use an non-existing asset name\n* All this will be ensured by the compiler.\n\nAlso, it\'s fully customizable thanks to Stencil templates, so even if it comes with predefined templates, you can make your own to generate whatever code fits your needs and your guidelines!\n\n## Installation\n\nThere are multiple possibilities to install SwiftGen on your machine or in your project, depending on your preferences and needs:\n\n<details>\n<summary><strong>Download the ZIP</strong> for the latest release</summary>\n\n* [Go to the GitHub page for the latest release](https://github.com/SwiftGen/SwiftGen/releases/latest)\n* Download the `swiftgen-x.y.z.zip` file associated with that release\n* Extract the content of the zip archive in your project directory\n\nWe recommend that you **unarchive the ZIP inside your project directory** and **commit its content** to git. This way, **all coworkers will use the same version of SwiftGen for this project**.\n\nIf you unarchived the ZIP file in a folder e.g. called `swiftgen` at the root of your project directory, you can then invoke SwiftGen in your Script Build Phase using:\n\n```sh\n"$PROJECT_DIR"/swiftgen/bin/swiftgen \xe2\x80\xa6\n```\n\n---\n</details>\n<details>\n<summary>Via <strong>CocoaPods</strong></summary>\n\nIf you\'re using CocoaPods, simply add `pod \'SwiftGen\', \'~> 6.0\'` to your `Podfile`.\n\nThen execute `pod install --repo-update` (or `pod update SwiftGen` if you want to update an existing SwiftGen installation) to download and install the `SwiftGen` binaries and dependencies in `Pods/SwiftGen/bin/swiftgen` next to your project.\n\nGiven that you can specify an exact version for `SwiftGen` in your `Podfile`, this allows you to ensure **all coworkers will use the same version of SwiftGen for this project**.\n\nYou can then invoke SwiftGen in your Script Build Phase using:\n\n```sh\n$PODS_ROOT/SwiftGen/bin/swiftgen \xe2\x80\xa6\n```\n\n> Similarly, be sure to use `Pods/SwiftGen/bin/swiftgen` instead of just `swiftgen` where we mention commands with `swiftgen` in the rest of the documentation.\n\n_Note: SwiftGen isn\'t really a pod, as it\'s not a library your code will depend on at runtime; so the installation via CocoaPods is just a trick that installs the SwiftGen binaries in the Pods/ folder, but you won\'t see any swift files in the Pods/SwiftGen group in your Xcode\'s Pods.xcodeproj. That\'s normal: the SwiftGen binary is still present in that folder in the Finder._\n\n---\n</details>\n<details>\n<summary>Via <strong>Homebrew</strong> <em>(system-wide installation)</em></summary>\n\nTo install SwiftGen via [Homebrew](http://brew.sh), simply use:\n\n```sh\n$ brew update\n$ brew install swiftgen\n```\n\nThis will install SwiftGen **system-wide**. The same version of SwiftGen will be used for all projects on that machine, and you should make sure all your coworkers have the same version of SwiftGen installed on their machine too.\n\nYou can then invoke `swiftgen` directly in your Script Build Phase (as it will be in your `$PATH` already):\n\n```sh\nswiftgen \xe2\x80\xa6 \n```\n\n_Note: SwiftGen needs Xcode 8.3 to build, so installing via Homebrew requires you to have Xcode 8.3 installed (which in turn requires macOS 10.12). If you use an earlier version of macOS, you\'ll have to use one of the other installation methods instead._\n\n---\n</details>\n<details>\n<summary>Via <strong>Mint</strong> <em>(system-wide installation)</em></summary>\n\n> \xe2\x9d\x97\xef\xb8\x8fSwiftGen 6.0 or higher only.\n\nTo install SwiftGen via [Mint](https://github.com/yonaskolb/Mint), simply use:\n\n```sh\n$ brew install libxml2\n$ mint install SwiftGen/SwiftGen\n```\n---\n</details>\n\n<details>\n<summary><strong>Compile from source</strong> <em>(only recommended if you need features from master or want to test a PR)</em></summary>\n\nThis solution is when you want to build and install the latest version from `master` and have access to features which might not have been released yet.\n\n* If you have `homebrew` installed, you can use the following command to build and install the latest commit:\n\n```sh\nbrew install swiftgen --HEAD\n```\n\n* Alternatively, you can clone the repository and use `rake cli:install` to build the tool and install it from any branch, which could be useful to test SwiftGen in a fork or a Pull Request branch.\n\nSome Ruby tools are used in the build process, and the system Ruby works well if you are running a recent macOS.  However, if you are using `rbenv` you can run `rbenv install` to make sure you have a matching version of Ruby installed.  \n\nThen install the Ruby Gems:\n\n```sh\n# Install bundle if it isn\'t installed\ngem install bundle\n# Install the Ruby gems from Gemfile\nbundle install\n```\n\nYou can now install to the default locations (no parameter) or to custom locations:\n\n```sh\n# Binary is installed in `./build/swiftgen/bin`, frameworks in `./build/swiftgen/lib` and templates in `./build/swiftgen/templates`\n$ rake cli:install\n# - OR -\n# Binary will be installed in `~/swiftgen/bin`, frameworks in `~/swiftgen/fmk` and templates in `~/swiftgen/tpl`\n$ rake cli:install[~/swiftgen/bin,~/swiftgen/fmk,~/swiftgen/tpl]\n```\n\nYou can then invoke SwiftGen using the path to the binary where you installed it:\n\n```sh\n~/swiftgen/bin/swiftgen \xe2\x80\xa6\n```\n\nOr add the path to the `bin` folder to your `$PATH` and invoke `swiftgen` directly.\n\n---\n</details>\n\n## Usage\n\n> \xe2\x9d\x97\xef\xb8\x8f If you\'re migrating from older SwiftGen versions, don\'t forget to [read the Migration Guide](Documentation/MigrationGuide.md).\n\nSwiftGen is provided as a single command-line tool which uses a configuration file to run various actions (subcommands).\n\nEach action described in the configuration file (`strings`, `fonts`, `ib`, \xe2\x80\xa6) typically corresponds to a type of input resources to parse (strings files, IB files, Font files, JSON files, \xe2\x80\xa6), allowing you to generate constants for each types of those input files.\n\nTo use SwiftGen, simply create a `swiftgen.yml` YAML file to list all the subcommands to invoke, and for each subcommand, the list of arguments to pass to it. For example:\n\n```yaml\nstrings:\n  inputs: Resources/Base.lproj\n  filter: .+\\.strings$\n  outputs:\n    - templateName: structured-swift4\n      output: Generated/strings.swift\nxcassets:\n  inputs:\n    - Resources/Images.xcassets\n    - Resources/MoreImages.xcassets\n  outputs:\n    - templateName: swift4\n      output: Generated/assets-images.swift\n```\n\nThen you just have to invoke `swiftgen config run`, or even just `swiftgen` for short, and it will execute what\'s described in the configuration file\n\nTo learn more about the configuration file \xe2\x80\x94 its more detailed syntax and possibilities, how to pass custom parameters, using `swiftgen config lint` to validate it, how to use alternate config files, and other tips \xe2\x80\x94 [see the dedicated documentation](Documentation/ConfigFile.md).\n\nThere are also additional subcommands you can invoke from the command line to manage and configure SwiftGen:\n\n* The  `swiftgen config` subcommand to help you with the configuration file, especially `swiftgen config lint` to validate that your Config file is valid and has no errors\n* The `swiftgen templates` subcommands helps you print, duplicate, find and manage templates (both bundled and custom)\n\nLastly, you can use `--help` on `swiftgen` or one of its subcommand to see the detailed usage.\n\n<details>\n<summary><strong>Directly invoking a subcommand</strong></summary>\n\nWhile we highly recommend the use a configuration file for performance reasons (especially if you have multiple outputs, but also because it\'s more flexible), it\'s also possible to directly invoke the available subcommands to parse various resource types:\n\n* `swiftgen colors [OPTIONS] DIRORFILE1 \xe2\x80\xa6`\n* `swiftgen coredata [OPTIONS] DIRORFILE1 \xe2\x80\xa6`\n* `swiftgen fonts [OPTIONS] DIRORFILE1 \xe2\x80\xa6`\n* `swiftgen ib [OPTIONS] DIRORFILE1 \xe2\x80\xa6`\n* `swiftgen json [OPTIONS] DIRORFILE1 \xe2\x80\xa6`\n* `swiftgen plist [OPTIONS] DIRORFILE1 \xe2\x80\xa6`\n* `swiftgen strings [OPTIONS] DIRORFILE1 \xe2\x80\xa6`\n* `swiftgen xcassets [OPTIONS] DIRORFILE1 \xe2\x80\xa6`\n* `swiftgen yaml [OPTIONS] DIRORFILE1 \xe2\x80\xa6`\n\nOne rare cases where this might be useful \xe2\x80\x94 as opposed to using a config file \xe2\x80\x94 is if you are working on a custom template and want to quickly test the specific subcommand you\'re working on at each iteration/version of your custom template, until you\'re happy with it.\n\nEach subcommand generally accepts the same options and syntax, and they mirror the options and parameters from the configuration file:\n\n* `--output FILE` or `-o FILE`: set the file where to write the generated code. If omitted, the generated code will be printed on `stdout`.\n* `--templateName NAME` or `-n NAME`: define the Stencil template to use (by name, see [here for more info](Documentation/templates)) to generate the output.\n* `--templatePath PATH` or `-p PATH`: define the Stencil template to use, using a full path.\n* Note: you should specify one and only one template when invoking SwiftGen. You have to use either `-t` or `-p` but should not use both at the same time (it wouldn\'t make sense anyway and you\'ll get an error if you try)\n* `--filter REGEX` or `-f REGEX`: the filter to apply to each input path. Filters are applied to actual (relative) paths, not just the filename. Each command has a default filter that you can override with this option.\n* Note: use `.+` to match multiple characters (at least one), and don\'t forget to escape the dot (`\\.`) if you want to match a literal dot like for an extension. Add `$` at the end to ensure the path ends with the extension you want. Regular expressions will be case sensitive by default, and not anchored to the start/end of a path. For example, use `.+\\.xib$` to match files with a `.xib` extension. Use a tool such as [RegExr](https://regexr.com) to ensure you\'re using a valid regular expression.\n* Each command supports multiple input files (or directories where applicable).\n* You can always use the `--help` flag to see what options a command accept, e.g. `swiftgen xcassets --help`.\n\n</details>\n\n## Choosing your template\n\nSwiftGen is based on templates (it uses [Stencil](https://github.com/kylef/Stencil) as its template engine). This means that **you can choose the template that fits the Swift version you\'re using** \xe2\x80\x94 and also the one that best fits your preferences \xe2\x80\x94 to **adapt the generated code to your own conventions and Swift version**.\n\n### Bundled templates vs. Custom ones\n\nSwiftGen comes bundled with some templates for each of the subcommand (`colors`, `coredata`, `fonts`, `ib`, `json`, `plist`, `strings`, `xcassets`, `yaml`), which will fit most needs. But you can also create your own templates if the bundled ones don\'t suit your coding conventions or needs. Simply either use the `templateName` output option to specify the name of the template to use, or store them somewhere else (like in your project repository) and use `templatePath` output option to specify a full path.\n\n\xf0\x9f\x92\xa1 You can use the `swiftgen templates list` command to list all the available templates (both custom and bundled templates) for each subcommand, list the template content and dupliate them to create your own.\n\nFor more information about how to create your own templates, [see the dedicated documentation](Documentation/Creating-your-templates.md).\n\n### Templates bundled with SwiftGen:\n\nAs explained above, you can use `swiftgen templates list` to list all templates bundled with SwiftGen. For most SwiftGen subcommands, we provide, among others:\n\n* A `swift3` template, compatible with Swift 3\n* A `swift4` template, compatible with Swift 4\n* Other variants, like `flat-swift3/4` and `structured-swift3/4` templates for Strings, etc.\n\nYou can **find the documentation for each bundled template [here in the repo](Documentation/templates)**, with documentation organized as one folder per SwiftGen subcommand, then one MarkDown file per template.  \nEach MarkDown file documents the Swift Version it\'s aimed for, the use case for that template (in which cases you might favor that template over others), the available parameters to customize it on invocation (using the `params:` key in your config file), and some code examples.\n\n> Don\'t hesitate to make PRs to share your improvements suggestions on the bundled templates \xf0\x9f\x98\x89\n\n## Additional documentation\n\n### Playground\n\nThe `SwiftGen.playground` available in this repository will allow you to play with the code that the tool typically generates, and see some examples of how you can take advantage of it.\n\nThis allows you to have a quick look at how typical code generated by SwiftGen looks like, and how you will then use the generated constants in your code.\n\n### Dedicated Documentation in Markdown\n\nThere is a lot of documentation in the form of Markdown files in this repository, and in the related [StencilSwiftKit](https://github.com/SwiftGen/StencilSwiftKit) repository as well.\n\nBe sure to [check the "Documentation" folder](Documentation/) of each repository.\n\nEspecially, in addition to the previously mentioned [Migration Guide](Documentation/MigrationGuide.md) and [Configuration File](Documentation/ConfigFile.md) documentation, the `Documentation/` folder in the SwiftGen repository also includes:\n\n* A [`templates` subdirectory](Documentation/templates/) that details the documentation for each of the templates bundled with SwiftGen (when to use each template, what the output will look like, and custom parameters to adjust them, \xe2\x80\xa6)\n* A [`SwiftGenKit Contexts` subdirectory](Documentation/SwiftGenKit%20Contexts/) that details the structure of the "Stencil Contexts", i.e. the Dictionary/YAML representation resulting of parsing your input files. This documentation is useful for people wanting to write their own templates, so that they know the structure and various keys available when writing their template, to construct the wanted generated output accordingly.\n* [Various articles](Documentation/Articles/) to provide best practices & tips on how to better take advantage of SwiftGen in your projects:\n  * [Integrate SwiftGen in your Xcode project](Documentation/Articles/Xcode-Integration.md) \xe2\x80\x94 so it rebuilds the constants every time you build\n  * [Configure SwiftLint to help your developers use constants generated by SwiftGen](Documentation/Articles/SwiftLint-Integration.md)\n  * [Create a custom template](Documentation/Creating-your-templates.md), and [watch a folder to auto-regenerate an output every time you save the template you\'re working on](Documentation/Articles/Watch-a-folder-for-changes.md)\n  * \xe2\x80\xa6and more\n\n### Tutorials\n\nYou can also find other help & tutorial material on the internet, like [this classroom about Code Generation I gave at FrenchKit in Sept\'17](https://github.com/FrenchKit/Mastering-code-generation-Classroom) \xe2\x80\x94 and its wiki detailing a step-by-step tutorial about installing and using SwiftGen (and Sourcery too)\n\n---\n\n## Asset Catalog\n\n```yaml\nxcassets:\n  inputs: /dir/to/search/for/imageset/assets\n  outputs:\n    templateName: swift4\n    output: Assets.swift\n```\n\nThis will generate an `enum Asset` with one `case` per image set in your assets catalog, so that you can use them as constants.\n\n<details>\n<summary>Example of code generated by the bundled template</summary>\n\n```swift\nenum Asset {\n  enum Exotic {\n    static let banana: AssetType = "Exotic/Banana"\n    static let mango: AssetType = "Exotic/Mango"\n  }\n  static let `private`: AssetType = "private"\n}\n\n```\n</details>\n\n### Usage Example\n\n```swift\n// You can create new images with the convenience constructor like this:\nlet bananaImage = UIImage(asset: Asset.Exotic.banana)  // iOS\nlet privateImage = NSImage(asset: Asset.private)  // macOS\n\n// Or as an alternative, you can refer to enum instance and call .image on it:\nlet sameBananaImage = Asset.Exotic.banana.image\nlet samePrivateImage = Asset.private.image\n```\n\n## Colors\n\n```yaml\ncolors:\n  inputs: /path/to/colors-file.txt\n  outputs:\n    templateName: swift4\n    output: Colors.swift\n```\n\nThis will generate a `enum ColorName` with one `case` per color listed in the text file passed as argument.\n\nThe input file is expected to be either:\n\n* a [plain text file](Tests/Fixtures/Resources/Colors/extra.txt), with one line per color to register, each line being composed by the Name to give to the color, followed by ":", followed by the Hex representation of the color (like `rrggbb` or `rrggbbaa`, optionally prefixed by `#` or `0x`) or the name of another color in the file. Whitespaces are ignored.\n* a [JSON file](Tests/Fixtures/Resources/Colors/colors.json), representing a dictionary of names -> values, each value being the hex representation of the color\n* a [XML file](Tests/Fixtures/Resources/Colors/colors.xml), expected to be the same format as the Android colors.xml files, containing tags `<color name="AColorName">AColorHexRepresentation</color>`\n* a [`*.clr` file](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/DrawColor/Concepts/AboutColorLists.html#//apple_ref/doc/uid/20000757-BAJHJEDI) used by Apple\'s Color Palettes.\n\nFor example you can use this command to generate colors from one of your system color lists:\n\n```yaml\ncolors:\n  inputs: ~/Library/Colors/MyColors.clr\n  outputs:\n    templateName: swift4\n    output: Colors.swift\n```\n\nGenerated code will look the same as if you\'d use a text file.\n\n<details>\n<summary>Example of code generated by the bundled template</summary>\n\nGiven the following `colors.txt` file:\n\n```\nCyan-Color       : 0xff66ccff\nArticleTitle     : #33fe66\nArticleBody      : 339666\nArticleFootnote  : ff66ccff\nTranslucent      : ffffffcc\n```\n\nThe generated code will look like this:\n\n```swift\nstruct ColorName {\n  let rgbaValue: UInt32\n  var color: Color { return Color(named: self) }\n\n  /// <span style="display:block;width:3em;height:2em;border:1px solid black;background:#339666"></span>\n  /// Alpha: 100% <br/> (0x339666ff)\n  static let articleBody = ColorName(rgbaValue: 0x339666ff)\n  /// <span style="display:block;width:3em;height:2em;border:1px solid black;background:#ff66cc"></span>\n  /// Alpha: 100% <br/> (0xff66ccff)\n  static let articleFootnote = ColorName(rgbaValue: 0xff66ccff)\n\n  ...\n}\n```\n</details>\n\n### Usage Example\n\n```swift\n// You can create colors with the convenience constructor like this:\nlet title = UIColor(named: .articleBody)  // iOS\nlet footnote = NSColor(named: .articleFootnote) // macOS\n\n// Or as an alternative, you can refer to enum instance and call .color on it:\nlet sameTitle = ColorName.articleBody.color\nlet sameFootnote = ColorName.articleFootnote.color\n```\n\nThis way, no need to enter the color red, green, blue, alpha values each time and create ugly constants in the global namespace for them.\n\n## Core Data\n\n```yaml\ncoredata:\n  inputs: /path/to/model.xcdatamodeld\n  outputs:\n    templateName: swift4\n    output: CoreData.swift\n```\n\nThis will parse the specified core data model(s), generate a class for each entity in your model containing all the attributes, and a few extensions if needed for relationships and predefined fetch requests.\n\n<details>\n<summary>Example of code generated by the bundled template</summary>\n\n```swift\ninternal class MainEntity: NSManagedObject {\n  internal class func entityName() -> String {\n    return "MainEntity"\n  }\n\n  internal class func entity(in managedObjectContext: NSManagedObjectContext) -> NSEntityDescription? {\n    return NSEntityDescription.entity(forEntityName: entityName(), in: managedObjectContext)\n  }\n\n  @nonobjc internal class func fetchRequest() -> NSFetchRequest<MainEntity> {\n    return NSFetchRequest<MainEntity>(entityName: entityName())\n  }\n\n  @NSManaged internal var attributedString: NSAttributedString?\n  @NSManaged internal var binaryData: Data?\n  @NSManaged internal var boolean: Bool\n  @NSManaged internal var date: Date?\n  @NSManaged internal var float: Float\n  @NSManaged internal var int64: Int64\n  @NSManaged internal var manyToMany: Set<SecondaryEntity>\n}\n\n// MARK: Relationship ManyToMany\n\nextension MainEntity {\n  @objc(addManyToManyObject:)\n  @NSManaged public func addToManyToMany(_ value: SecondaryEntity)\n\n  @objc(removeManyToManyObject:)\n  @NSManaged public func removeFromManyToMany(_ value: SecondaryEntity)\n\n  @objc(addManyToMany:)\n  @NSManaged public func addToManyToMany(_ values: Set<SecondaryEntity>)\n\n  @objc(removeManyToMany:)\n  @NSManaged public func removeFromManyToMany(_ values: Set<SecondaryEntity>)\n}\n```\n</details>\n\n### Usage Example\n\n```swift\n// Fetch all the instances of MainEntity\nlet request = MainEntity.fetchRequest()\nlet mainItems = try myContext.execute(request)\n\n// Type-safe relationships: `relatedItem` will be a `SecondaryEntity?` in this case\nlet relatedItem = myMainItem.manyToMany.first\n```\n\n## Fonts\n\n```yaml\nfonts:\n  inputs: /path/to/font/dir\n  outputs:\n    templateName: swift4\n    output: Fonts.swift\n```\n\nThis will recursively go through the specified directory, finding any typeface files (TTF, OTF, \xe2\x80\xa6), defining a `struct FontFamily` for each family, and an enum nested under that family that will represent the font styles.\n\n<details>\n<summary>Example of code generated by the bundled template</summary>\n\n```swift\nenum FontFamily {\n  enum SFNSDisplay: String, FontConvertible {\n    static let regular = FontConvertible(name: ".SFNSDisplay-Regular", family: ".SF NS Display", path: "SFNSDisplay-Regular.otf")\n  }\n  enum ZapfDingbats: String, FontConvertible {\n    static let regular = FontConvertible(name: "ZapfDingbatsITC", family: "Zapf Dingbats", path: "ZapfDingbats.ttf")\n  }\n}\n```\n</details>\n\n### Usage Example\n\n```swift\n// You can create fonts with the convenience constructor like this:\nlet displayRegular = UIFont(font: FontFamily.SFNSDisplay.regular, size: 20.0) // iOS\nlet dingbats = NSFont(font: FontFamily.ZapfDingbats.regular, size: 20.0)  // macOS\n\n// Or as an alternative, you can refer to enum instance and call .font on it:\nlet sameDisplayRegular = FontFamily.SFNSDisplay.regular.font(size: 20.0)\nlet sameDingbats = FontFamily.ZapfDingbats.regular.font(size: 20.0)\n```\n\n## Interface Builder\n\n```yaml\nib:\n  inputs: /dir/to/search/for/storyboards\n  outputs:\n    - templateName: scenes-swift4\n      output: Storyboard Scenes.swift\n    - templateName: segues-swift4\n      output: Storyboard Segues.swift\n```\n\nThis will generate an `enum` for each of your `NSStoryboard`/`UIStoryboard`, with respectively one `case` per storyboard scene or segue.\n\n<details>\n<summary>Example of code generated by the bundled template</summary>\n\nThe generated code will look like this:\n\n```swift\n// output from the scenes template\n\nenum StoryboardScene {\n  enum Dependency: StoryboardType {\n    static let storyboardName = "Dependency"\n\n    static let dependent = SceneType<UIViewController>(storyboard: Dependency.self, identifier: "Dependent")\n  }\n  enum Message: StoryboardType {\n    static let storyboardName = "Message"\n\n    static let messagesList = SceneType<UITableViewController>(storyboard: Message.self, identifier: "MessagesList")\n  }\n}\n\n// output from the segues template\n\nenum StoryboardSegue {\n  enum Message: String, SegueType {\n    case customBack = "CustomBack"\n    case embed = "Embed"\n    case nonCustom = "NonCustom"\n    case showNavCtrl = "Show-NavCtrl"\n  }\n}\n```\n</details>\n\n### Usage Example\n\n```swift\n// You can instantiate scenes using the `instantiate` method:\nlet vc = StoryboardScene.Dependency.dependent.instantiate()\n\n// You can perform segues using:\nvc.perform(segue: StoryboardSegue.Message.embed)\n\n// or match them (in prepareForSegue):\noverride func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n  switch StoryboardSegue.Message(segue) {\n  case .embed?:\n    // Prepare for your custom segue transition, passing information to the destionation VC\n  case .customBack?:\n    // Prepare for your custom segue transition, passing information to the destionation VC\n  default:\n    // Other segues from other scenes, not handled by this VC\n    break\n  }\n}\n```\n\n## JSON and YAML\n\n```yaml\njson:\n  inputs: /path/to/json/dir-or-file\n  outputs:\n    templateName: runtime-swift4\n    output: JSON.swift\nyaml:\n  inputs: /path/to/yaml/dir-or-file\n  outputs:\n    templateName: inline-swift4\n    output: YAML.swift\n```\n\nThis will parse the given file, or when given a directory, recursively search for JSON and YAML files. It will define an `enum` for each file (and documents in a file where needed), and type-safe constants for the content of the file.\n\nUnlike other subcommands, this parser is intended to allow you to use more custom inputs (as the formats are quite open to your needs) to generate your code. This means that for these subcommands (and the `plist` one), you\'ll probably be more likely to use custom templates to generate code properly adapted/tuned to your inputs, rather than using the bundled templates. To read more about writing your own custom templates, see [see the dedicated documentation](Documentation/Creating-your-templates.md).\n\n<details>\n<summary>Example of code generated by the bundled template</summary>\n\n```swift\ninternal enum JSONFiles {\n  internal enum Info {\n    private static let _document = JSONDocument(path: "info.json")\n    internal static let key1: String = _document["key1"]\n    internal static let key2: String = _document["key2"]\n    internal static let key3: [String: Any] = _document["key3"]\n  }\n  internal enum Sequence {\n    internal static let items: [Int] = objectFromJSON(at: "sequence.json")\n  }\n}\n```\n</details>\n\n### Usage Example\n\n```swift\n// This will be an dictionary\nlet foo = JSONFiles.Info.key3\n\n// This will be an [Int]\nlet bar = JSONFiles.Sequence.items\n```\n\n## Plists\n\n```yaml\nplist:\n  inputs: /path/to/plist/dir-or-file\n  outputs:\n    templateName: runtime-swift4\n    output: Plist.swift\n```\n\nThis will parse the given file, or when given a directory, recursively search for Plist files. It will define an `enum` for each file (and documents in a file where needed), and type-safe constants for the content of the file.\n\nUnlike other subcommands, this parser is intended to allow you to use more custom inputs (as the format is quite open to your needs) to generate your code. This means that for this subcommand (and the `json` and `yaml` ones), you\'ll probably be more likely to use custom templates to generate code properly adapted/tuned to your inputs, rather than using the bundled templates. To read more about writing your own custom templates, see [see the dedicated documentation](Documentation/Creating-your-templates.md).\n\n<details>\n<summary>Example of code generated by the bundled template</summary>\n\n```swift\ninternal enum PlistFiles {\n  internal enum Test {\n    internal static let items: [String] = arrayFromPlist(at: "array.plist")\n  }\n  internal enum Stuff {\n    private static let _document = PlistDocument(path: "dictionary.plist")\n    internal static let key1: Int = _document["key1"]\n    internal static let key2: [String: Any] = _document["key2"]\n  }\n}\n```\n</details>\n\n### Usage Example\n\n```swift\n// This will be an array\nlet foo = PlistFiles.Test.items\n\n// This will be an Int\nlet bar = PlistFiles.Stuff.key1\n```\n\n## Strings\n\n```yaml\nstrings:\n  inputs: /path/to/Localizable.strings\n  outputs:\n    templateName: structured-swift4\n    output: Strings.swift\n```\n\nThis will generate a Swift `enum L10n` that will map all your `Localizable.strings` (or other tables) keys to a `static let` constant. And if it detects placeholders like `%@`,`%d`,`%f`, it will generate a `static func` with the proper argument types instead, to provide type-safe formatting. Note that all dots within the key are converted to dots in code.\n\n<details>\n<summary>Example of code generated by the structured bundled template</summary>\n\nGiven the following `Localizable.strings` file:\n\n```swift\n"alert_title" = "Title of the alert";\n"alert_message" = "Some alert body there";\n"apples.count" = "You have %d apples";\n"bananas.owner" = "Those %d bananas belong to %@.";\n```\n\n> _Reminder: Don\'t forget to end each line in your `*.strings` files with a semicolon `;`! Now that in Swift code we don\'t need semi-colons, it\'s easy to forget it\'s still required by the `Localizable.strings` file format \xf0\x9f\x98\x89_\n\nThe generated code will contain this:\n\n```swift\nenum L10n {\n  /// Some alert body there\n  static let alertMessage = L10n.tr("alert_message")\n  /// Title of the alert\n  static let alertTitle = L10n.tr("alert_title")\n\n  enum Apples {\n    /// You have %d apples\n    static func count(_ p1: Int) -> String {\n      return L10n.tr("apples.count", p1)\n    }\n  }\n\n  enum Bananas {\n    /// Those %d bananas belong to %@.\n    static func owner(_ p1: Int, _ p2: String) -> String {\n      return L10n.tr("bananas.owner", p1, p2)\n    }\n  }\n}\n```\n</details>\n\n### Usage Example\n\nOnce the code has been generated by the script, you can use it this way in your Swift code:\n\n```swift\n// Simple strings\nlet message = L10n.alertMessage\nlet title = L10n.alertTitle\n\n// with parameters, note that each argument needs to be of the correct type\nlet apples = L10n.Apples.count(3)\nlet bananas = L10n.Bananas.owner(5, "Olivier")\n```\n\n### Flat Strings Support\n\nSwiftGen also has a template to support flat strings files (i.e. no dot syntax). The advantage is that your keys won\'t be mangled in any way, the disadvantage is worse auto-completion.\n\n<details>\n<summary>Example of code generated by the flat bundled template</summary>\n\n```swift\nenum L10n {\n  /// Some alert body there\n  case alertMessage\n  /// Title of the alert\n  case alertTitle\n  /// You have %d apples\n  case applesCount(Int)\n  /// Those %d bananas belong to %@.\n  case bananasOwner(Int, String)\n}\n```\n</details>\n\nGiven the same `Localizable.strings` as above the usage will now be:\n\n```swift\n// Simple strings\nlet message = L10n.alertMessage\nlet title = L10n.alertTitle\n\n// with parameters, note that each argument needs to be of the correct type\nlet apples = L10n.applesCount(3)\nlet bananas = L10n.bananasOwner(5, "Olivier")\n```\n\n---\n\n# Licence\n\nThis code and tool is under the MIT Licence. See the `LICENCE` file in this repository.\n\n## Attributions\n\nThis tool is powered by\n\n- [Stencil](https://github.com/kylef/Stencil) and few other libs by [Kyle Fuller](https://github.com/kylef)\n- SwiftGenKit and [StencilSwiftKit](https://github.com/SwiftGen/StencilSwiftKit), our internal frameworks at SwiftGen\n\nIt is currently mainly maintained by [@AliSoftware](https://github.com/AliSoftware) and [@djbe](https://github.com/djbe). But I couldn\'t thank enough all the other [contributors](https://github.com/SwiftGen/SwiftGen/graphs/contributors) to this tool along the different versions which helped make SwiftGen awesome! \xf0\x9f\x8e\x89\n\nIf you want to contribute, don\'t hesitate to open a Pull Request, or even join the team!\n\n## Other Libraries / Tools\n\nIf you want to also get rid of String-based APIs not only for your ressources, but also for `UITableViewCell`, `UICollectionViewCell` and XIB-based views, you should take a look at my Mixin [Reusable](https://github.com/AliSoftware/Reusable).\n\nIf you want to generate Swift code from your own Swift code (so meta!), like generate `Equatable` conformance to your types and a lot of other similar things, use [Sourcery](https://github.com/krzysztofzablocki/Sourcery).\n\n_SwiftGen and Sourcery are complementary tools. In fact, Sourcery uses `Stencil` too, as well as SwiftGen\'s `StencilSwiftKit` so you can use the exact same syntax for your templates for both!_\n\nYou can also [follow me on twitter](http://twitter.com/aligatr) for news/updates about other projects I am creating, or [read my blog](https://alisoftware.github.io).\n'