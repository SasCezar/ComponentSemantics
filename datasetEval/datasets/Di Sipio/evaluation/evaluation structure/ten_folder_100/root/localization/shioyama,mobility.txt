b'Mobility\n========\n\n[![Gem Version](https://badge.fury.io/rb/mobility.svg)][gem]\n[![Build Status](https://travis-ci.com/shioyama/mobility.svg?branch=master)][travis]\n[![Code Climate](https://api.codeclimate.com/v1/badges/72200f2b00c339ec4537/maintainability.svg)][codeclimate]\n[![Gitter Chat](https://badges.gitter.im/mobility-ruby/mobility.svg)](https://gitter.im/mobility-ruby/mobility)\n\n[gem]: https://rubygems.org/gems/mobility\n[travis]: https://travis-ci.com/shioyama/mobility\n[codeclimate]: https://codeclimate.com/github/shioyama/mobility\n[docs]: http://www.rubydoc.info/gems/mobility\n[wiki]: https://github.com/shioyama/mobility/wiki\n\nMobility is a gem for storing and retrieving translations as attributes on a\nclass. These translations could be the content of blog posts, captions on\nimages, tags on bookmarks, or anything else you might want to store in\ndifferent languages. For examples of what Mobility can do, see the\n<a href="#companies-using-mobility">Companies using Mobility</a> section below.\n\nStorage of translations is handled by customizable "backends" which encapsulate\ndifferent storage strategies. The default way to store translations\nis to put them all in a set of two shared tables, but many alternatives are\nalso supported, including [translatable\ncolumns](http://dejimata.com/2017/3/3/translating-with-mobility#strategy-1) and\n[model translation\ntables](http://dejimata.com/2017/3/3/translating-with-mobility#strategy-2), as\nwell as database-specific storage solutions such as\n[json/jsonb](https://www.postgresql.org/docs/current/static/datatype-json.html) and\n[Hstore](https://www.postgresql.org/docs/current/static/hstore.html) (for\nPostgreSQL).\n\nMobility is a cross-platform solution, currently supporting both\n[ActiveRecord](http://api.rubyonrails.org/classes/ActiveRecord/Base.html)\nand [Sequel](http://sequel.jeremyevans.net/) ORM, with support for other\nplatforms planned.\n\nFor a detailed introduction to Mobility, see [Translating with\nMobility](http://dejimata.com/2017/3/3/translating-with-mobility). See also my\ntalk at RubyConf 2018, [Building Generic\nSoftware](https://www.youtube.com/watch?v=RZkemV_-__A), where I explain the\nthinking behind Mobility\'s design.\n\nIf you\'re coming from Globalize, be sure to also read the [Migrating from\nGlobalize](https://github.com/shioyama/mobility/wiki/Migrating-from-Globalize)\nsection of the wiki.\n\nInstallation\n------------\n\nAdd this line to your application\'s Gemfile:\n\n```ruby\ngem \'mobility\', \'~> 0.8.9\'\n```\n\nMobility is cryptographically signed. To be sure the gem you install hasn\'t\nbeen tampered with, add my public key as a trusted certificate and install:\n\n```\ngem cert --add <(curl -Ls https://raw.github.com/shioyama/mobility/master/certs/shioyama.pem)\ngem install mobility -P MediumSecurity\n```\n\nThe MediumSecurity trust profile will verify signed gems, but allow the\ninstallation of unsigned dependencies.\n\n### ActiveRecord (Rails)\n\nRequirements:\n- ActiveRecord >= 5.0 (including 6.0)\n\n(Support for most backends and features is also supported with\nActiveRecord/Rails 4.2, but there are some tests still failing. To see exactly\nwhat might not work, check pending specs in Rails 4.2 Travis builds.)\n\nTo translate attributes on a model, extend `Mobility`, then call `translates`\npassing in one or more attributes as well as a hash of options (see below).\n\nIf using Mobility in a Rails project, you can run the generator to create an\ninitializer and a migration to create shared translation tables for the\ndefault `KeyValue` backend:\n\n```\nrails generate mobility:install\n```\n\n(If you do not plan to use the default backend, you may want to use\nthe `--without_tables` option here to skip the migration generation.)\n\nThe generator will create an initializer file `config/initializers/mobility.rb`\nwith the lines:\n\n```ruby\nMobility.configure do |config|\n  config.default_backend = :key_value\n  config.accessor_method = :translates\n  config.query_method    = :i18n\nend\n```\n\nTo use a different default backend, set `default_backend` to another value (see\npossibilities [below](#backends)).\n\nYou will likely also want to set default values for the various translation\noptions described below. You can set these defaults by assigning values to keys\non the `config.default_options` hash. Below, we turn on the Dirty plugin by\ndefault, so it will be enabled for all models.\n\nYou can also set defaults for backend-specific options. Below, we set the\ndefault `type` option for the KeyValue backend to `:string` (this is\nunnecessary and will be ignored if you are using a different backend).\n\n```diff\n Mobility.configure do |config|\n   config.default_backend = :key_value\n   config.accessor_method = :translates\n   config.query_method    = :i18n\n+  config.default_options[:dirty] = true\n+  config.default_options[:type]  = :string\nend\n```\n\nWe will assume the configuration above in the examples that follow. Other\nconfiguration options are described in the [API\ndocs](http://www.rubydoc.info/gems/mobility/Mobility/Configuration).\n\nSee [Getting Started](#quickstart) to get started translating your models.\n\n### Sequel\n\nRequirements:\n- Sequel >= 4.0\n\nYou can extend `Mobility` just like in ActiveRecord, or you can use the\n`mobility` plugin, which does the same thing:\n\n```ruby\nclass Word < ::Sequel::Model\n  plugin :mobility\n  translates :name, :meaning\nend\n```\n\nOtherwise everything is (almost) identical to AR, with the exception that there\nis no equivalent to a Rails generator (so you will need to create the migration\nfor any translation table(s) yourself, using Rails generators as a reference).\n\nThe models in examples below all inherit from `ApplicationRecord`, but\neverything works exactly the same if the parent class is `Sequel::Model`.\n\nUsage\n-----\n\n### <a name="quickstart"></a>Getting Started\n\nOnce the install generator has been run to generate translation tables, using\nMobility is as easy as adding a few lines to any class you want to translate.\nSimply pass one or more attribute names to the `translates` method with a hash\nof options, like this:\n\n```ruby\nclass Word < ApplicationRecord\n  extend Mobility\n  translates :name, :meaning\nend\n```\n\nNote: When using the KeyValue backend, use the options hash to pass each attribute\'s type:\n\n```ruby\nclass Word < ApplicationRecord\n  extend Mobility\n  translates :name,    type: :string\n  translates :meaning, type: :text\nend\n```\n\nThis is important because this is how Mobility knows to which of the [two translation tables](https://github.com/shioyama/mobility/wiki/KeyValue-Backend) it should save your translation.\n\nYou now have translated attributes `name` and `meaning` on the model `Word`.\nYou can set their values like you would any other attribute:\n\n```ruby\nword = Word.new\nword.name = "mobility"\nword.meaning = "(noun): quality of being changeable, adaptable or versatile"\nword.name\n#=> "mobility"\nword.meaning\n#=> "(noun): quality of being changeable, adaptable or versatile"\nword.save\nword = Word.first\nword.name\n#=> "mobility"\nword.meaning\n#=> "(noun): quality of being changeable, adaptable or versatile"\n```\n\nPresence methods are also supported:\n\n```ruby\nword.name?\n#=> true\nword.name = nil\nword.name?\n#=> false\nword.name = ""\nword.name?\n#=> false\n```\n\nWhat\'s different here is that the value of these attributes changes with the\nvalue of `I18n.locale`:\n\n```ruby\nI18n.locale = :ja\nword.name\n#=> nil\nword.meaning\n#=> nil\n```\n\nThe `name` and `meaning` of this word are not defined in any locale except\nEnglish. Let\'s define them in Japanese and save the model:\n\n```ruby\nword.name = "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3"\nword.meaning = "(\xe5\x90\x8d\xe8\xa9\x9e):\xe5\x8b\x95\xe3\x81\x8d\xe3\x82\x84\xe3\x81\x99\xe3\x81\x95\xe3\x80\x81\xe5\x8f\xaf\xe5\x8b\x95\xe6\x80\xa7"\nword.name\n#=> "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3"\nword.meaning\n#=> "(\xe5\x90\x8d\xe8\xa9\x9e):\xe5\x8b\x95\xe3\x81\x8d\xe3\x82\x84\xe3\x81\x99\xe3\x81\x95\xe3\x80\x81\xe5\x8f\xaf\xe5\x8b\x95\xe6\x80\xa7"\nword.save\n```\n\nNow our word has names and meanings in two different languages:\n\n```ruby\nword = Word.first\nI18n.locale = :en\nword.name\n#=> "mobility"\nword.meaning\n#=> "(noun): quality of being changeable, adaptable or versatile"\nI18n.locale = :ja\nword.name\n#=> "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3"\nword.meaning\n#=> "(\xe5\x90\x8d\xe8\xa9\x9e):\xe5\x8b\x95\xe3\x81\x8d\xe3\x82\x84\xe3\x81\x99\xe3\x81\x95\xe3\x80\x81\xe5\x8f\xaf\xe5\x8b\x95\xe6\x80\xa7"\n```\n\nInternally, Mobility is mapping the values in different locales to storage\nlocations, usually database columns. By default these values are stored as keys\n(attribute names) and values (attribute translations) on a set of translation\ntables, one for strings and one for text columns, but this can be easily\nchanged and/or customized (see the [Backends](#backends) section below).\n\n### <a name="getset"></a> Getting and Setting Translations\n\nThe easiest way to get or set a translation is to use the getter and setter\nmethods described above (`word.name` and `word.name=`), but you may want to\naccess the value of an attribute in a specific locale, independent of the\ncurrent value of `I18n.locale` (or `Mobility.locale`). There are a few ways to\ndo this.\n\nThe first way is to define locale-specific methods, one for each locale you\nwant to access directly on a given attribute. These are called "locale\naccessors" in Mobility, and they can be defined by passing a `locale_accessors`\noption when defining translated attributes on the model class:\n\n```ruby\nclass Word < ApplicationRecord\n  extend Mobility\n  translates :name, locale_accessors: [:en, :ja]\nend\n```\n\nSince we have enabled locale accessors for English and Japanese, we can access\ntranslations for these locales with `name_en` and `name_ja`:\n\n```ruby\nword.name_en\n#=> "mobility"\nword.name_ja\n#=> "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3"\nword.name_en = "foo"\nword.name\n#=> "foo"\n```\n\nOther locales, however, will not work:\n\n```ruby\nword.name_ru\n#=> NoMethodError: undefined method `name_ru\' for #<Word id: ... >\n```\n\nTo generate methods for all locales in `I18n.available_locales` (at the time\nthe model is first loaded), use `locale_accessors: true`.\n\nAn alternative to using the `locale_accessors` option is to use the\n`fallthrough_accessors` option, with `fallthrough_accessors: true`. This uses\nRuby\'s [`method_missing`](http://apidock.com/ruby/BasicObject/method_missing)\nmethod to implicitly define the same methods as above, but supporting any\nlocale without any method definitions. (Locale accessors and fallthrough\nlocales can be used together without conflict, with locale accessors taking\nprecedence if defined for a given locale.)\n\nFor example, if we define `Word` this way:\n\n```ruby\nclass Word < ApplicationRecord\n  extend Mobility\n  translates :name, fallthrough_accessors: true\nend\n```\n\n... then we can access any locale we want, without specifying them upfront:\n\n```ruby\nword = Word.new\nword.name_fr = "mobilit\xc3\xa9"\nword.name_fr\n#=> "mobilit\xc3\xa9"\nword.name_ja = "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3"\nword.name_ja\n#=> "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3"\n```\n\n(Note however that Mobility will complain if you have\n`I18n.enforce_available_locales` set to `true` and you try accessing a locale\nnot present in `I18n.available_locales`; set it to `false` if you want to allow\n*any* locale.)\n\nAnother way to fetch values in a locale is to pass the `locale` option to the\ngetter method, like this:\n\n```ruby\nword.name(locale: :en)\n#=> "mobility"\nword.name(locale: :fr)\n#=> "mobilit\xc3\xa9"\n```\n\nNote that setting the locale this way will pass an option `locale: true` to the\nbackend and all plugins. Plugins may use this option to change their behavior\n(passing the locale explicitly this way, for example, disables\n[fallbacks](#fallbacks), see below for details).\n\nYou can also *set* the value of an attribute this way; however, since the\n`word.name = <value>` syntax does not accept any options, the only way to do this is to\nuse `send` (this is included mostly for consistency):\n\n```ruby\nword.send(:name=, "mobiliteit", locale: :nl)\nword.name_nl\n#=> "mobiliteit"\n```\n\nYet another way to get and set translated attributes is to call `read` and\n`write` on the storage backend, which can be accessed using the method\n`<attribute>_backend`. Without worrying too much about the details of\nhow this works for now, the syntax for doing this is simple:\n\n```ruby\nword.name_backend.read(:en)\n#=> "mobility"\nword.name_backend.read(:nl)\n#=> "mobiliteit"\nword.name_backend.write(:en, "foo")\nword.name_backend.read(:en)\n#=> "foo"\n```\n\nInternally, all methods for accessing translated attributes ultimately end up\nreading and writing from the backend instance this way.  (The `write` methods\ndo not call underlying backend\'s methods to persist the change. This is up to\nthe user, so e.g. with ActiveRecord you should call `save` write the changes to\nthe database).\n\nNote that accessor methods are defined in an included module, so you can wrap\nreads or writes in custom logic:\n\n```ruby\nclass Post < ApplicationRecord\n  extend Mobility\n  translates :title\n\n  def title(*)\n    super.reverse\n  end\nend\n```\n\n### Setting the Locale\n\nIt may not always be desirable to use `I18n.locale` to set the locale for\ncontent translations. For example, a user whose interface is in English\n(`I18n.locale` is `:en`) may want to see content in Japanese. If you use\n`I18n.locale` exclusively for the locale, you will have a hard time showing\nstored translations in one language while showing the interface in another\nlanguage.\n\nFor these cases, Mobility also has its own locale, which defaults to\n`I18n.locale` but can be set independently:\n\n```ruby\nI18n.locale = :en\nMobility.locale              #=> :en\nMobility.locale = :fr\nMobility.locale              #=> :fr\nI18n.locale                  #=> :en\n```\n\nTo set the Mobility locale in a block, you can use `Mobility.with_locale` (like\n`I18n.with_locale`):\n\n```ruby\nMobility.locale = :en\nMobility.with_locale(:ja) do\n  Mobility.locale            #=> :ja\nend\nMobility.locale              #=> :en\n```\n\nMobility uses [RequestStore](https://github.com/steveklabnik/request_store) to\nreset these global variables after every request, so you don\'t need to worry\nabout thread safety. If you\'re not using Rails, consult RequestStore\'s\n[README](https://github.com/steveklabnik/request_store#no-rails-no-problem) for\ndetails on how to configure it for your use case.\n\n### <a name="fallbacks"></a>Fallbacks\n\nMobility offers basic support for translation fallbacks. To enable fallbacks,\npass a hash with fallbacks for each locale as an option when defining\ntranslated attributes on a class:\n\n```ruby\nclass Word < ApplicationRecord\n  extend Mobility\n  translates :name,    fallbacks: { de: :ja, fr: :ja }, locale_accessors: true\n  translates :meaning, fallbacks: { de: :ja, fr: :ja }, locale_accessors: true\nend\n```\n\nInternally, Mobility assigns the fallbacks hash to an instance of\n`I18n::Locale::Fallbacks.new` (this can be customized by setting the\n`fallbacks_generator` configuration option, see the [API documentation on\nconfiguration](http://www.rubydoc.info/gems/mobility/Mobility/Configuration)).\n\nBy setting fallbacks for German and French to Japanese, values will fall\nthrough to the Japanese value if none is present for either of these locales,\nbut not for other locales:\n\n```ruby\nMobility.locale = :ja\nword = Word.create(name: "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3", meaning: "(\xe5\x90\x8d\xe8\xa9\x9e):\xe5\x8b\x95\xe3\x81\x8d\xe3\x82\x84\xe3\x81\x99\xe3\x81\x95\xe3\x80\x81\xe5\x8f\xaf\xe5\x8b\x95\xe6\x80\xa7")\nMobility.locale = :de\nword.name\n#=> "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3"\nword.meaning\n#=> "(\xe5\x90\x8d\xe8\xa9\x9e):\xe5\x8b\x95\xe3\x81\x8d\xe3\x82\x84\xe3\x81\x99\xe3\x81\x95\xe3\x80\x81\xe5\x8f\xaf\xe5\x8b\x95\xe6\x80\xa7"\nMobility.locale = :fr\nword.name\n#=> "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3"\nword.meaning\n#=> "(\xe5\x90\x8d\xe8\xa9\x9e):\xe5\x8b\x95\xe3\x81\x8d\xe3\x82\x84\xe3\x81\x99\xe3\x81\x95\xe3\x80\x81\xe5\x8f\xaf\xe5\x8b\x95\xe6\x80\xa7"\nMobility.locale = :ru\nword.name\n#=> nil\nword.meaning\n#=> nil\n```\n\nYou can optionally disable fallbacks to get the real value for a given locale\n(for example, to check if a value in a particular locale is set or not) by\npassing `fallback: false` (*singular*, not plural) to the getter method:\n\n```ruby\nMobility.locale = :de\nword.meaning(fallback: false)\n#=> nil\nMobility.locale = :fr\nword.meaning(fallback: false)\n#=> nil\nMobility.locale = :ja\nword.meaning(fallback: false)\n#=> "(\xe5\x90\x8d\xe8\xa9\x9e):\xe5\x8b\x95\xe3\x81\x8d\xe3\x82\x84\xe3\x81\x99\xe3\x81\x95\xe3\x80\x81\xe5\x8f\xaf\xe5\x8b\x95\xe6\x80\xa7"\n```\n\nYou can also set the fallback locales for a single read by passing one or more\nlocales:\n\n```ruby\nMobility.with_locale(:fr) do\n  word.meaning = "(nf): aptitude \xc3\xa0 bouger, \xc3\xa0 se d\xc3\xa9placer, \xc3\xa0 changer, \xc3\xa0 \xc3\xa9voluer"\nend\nword.save\nMobility.locale = :de\nword.meaning(fallback: false)\n#=> nil\nword.meaning(fallback: :fr)\n#=> "(nf): aptitude \xc3\xa0 bouger, \xc3\xa0 se d\xc3\xa9placer, \xc3\xa0 changer, \xc3\xa0 \xc3\xa9voluer"\nword.meaning(fallback: [:ja, :fr])\n#=> "(\xe5\x90\x8d\xe8\xa9\x9e):\xe5\x8b\x95\xe3\x81\x8d\xe3\x82\x84\xe3\x81\x99\xe3\x81\x95\xe3\x80\x81\xe5\x8f\xaf\xe5\x8b\x95\xe6\x80\xa7"\n```\n\nAlso note that passing a `locale` option into an attribute reader or writer, or\nusing [locale accessors or fallthrough accessors](#getset) to get or set\nany attribute value, will disable fallbacks (just like `fallback: false`).\n(This will take precedence over any value of the `fallback` option.)\n\nContinuing from the last example:\n\n```ruby\nword.meaning(locale: :de)\n#=> nil\nword.meaning_de\n#=> nil\nMobility.with_locale(:de) { word.meaning }\n#=> "(\xe5\x90\x8d\xe8\xa9\x9e):\xe5\x8b\x95\xe3\x81\x8d\xe3\x82\x84\xe3\x81\x99\xe3\x81\x95\xe3\x80\x81\xe5\x8f\xaf\xe5\x8b\x95\xe6\x80\xa7"\n```\n\nFor more details, see the [API documentation on\nfallbacks](http://www.rubydoc.info/gems/mobility/Mobility/Plugins/Fallbacks)\nand [this article on I18n\nfallbacks](https://github.com/svenfuchs/i18n/wiki/Fallbacks).\n\n### <a name="default"></a>Default values\n\nAnother option is to assign a default value, which will be used if the result of a fetch would otherwise be `nil`:\n\n```ruby\nclass Word < ApplicationRecord\n  extend Mobility\n  translates :name, default: \'foo\'\nend\n\nMobility.locale = :ja\nword = Word.create(name: "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3")\nword.name\n#=> "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3"\nMobility.locale = :de\nword.name\n#=> "foo"\n```\n\nYou can override the default by passing a `default` option to the attribute reader:\n\n```ruby\nword.name\n#=> \'foo\'\nword.name(default: nil)\n#=> nil\nword.name(default: \'bar\')\n#=> \'bar\'\n```\n\nThe default can also be a `Proc`, which will be called with the context as the\nmodel itself, and passed optional arguments (attribute, locale and options\npassed to accessor) which can be used to customize behaviour. See the [API\ndocs][docs] for details.\n\n### <a name="dirty"></a>Dirty Tracking\n\nDirty tracking (tracking of changed attributes) can be enabled for models which\nsupport it. Currently this is models which include\n[ActiveModel::Dirty](http://api.rubyonrails.org/classes/ActiveModel/Dirty.html)\n(like `ActiveRecord::Base`) and Sequel models (through the\n[dirty](http://sequel.jeremyevans.net/rdoc-plugins/classes/Sequel/Plugins/Dirty.html)\nplugin).\n\nEnabling dirty tracking is as simple as sending the `dirty: true` option when\ndefining a translated attribute. The way dirty tracking works is somewhat\ndependent on the model class (ActiveModel or Sequel); we will describe the\nActiveModel implementation here.\n\nFirst, enable dirty tracking (note that this is a persisted AR model, although\ndirty tracking is not specific to AR and works for non-persisted models as well):\n\n```ruby\nclass Post < ApplicationRecord\n  extend Mobility\n  translates :title, dirty: true\nend\n```\n\n(If you want to enable dirty tracking on all models, set the\n`config.default_options[:dirty]` option in your Mobility configuration.)\n\nLet\'s assume we start with a post with a title in English and Japanese:\n\n```ruby\npost = Post.create(title: "Introducing Mobility")\nMobility.with_locale(:ja) { post.title = "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3\xe3\x81\xae\xe7\xb4\xb9\xe4\xbb\x8b" }\npost.save\n```\n\nNow let\'s change the title:\n\n```ruby\npost = Post.first\npost.title                      #=> "Introducing Mobility"\npost.title = "a new title"\nMobility.with_locale(:ja) do\n  post.title                    #=> "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3\xe3\x81\xae\xe7\xb4\xb9\xe4\xbb\x8b"\n  post.title = "\xe6\x96\xb0\xe3\x81\x97\xe3\x81\x84\xe3\x82\xbf\xe3\x82\xa4\xe3\x83\x88\xe3\x83\xab"\n  post.title                    #=> "\xe6\x96\xb0\xe3\x81\x97\xe3\x81\x84\xe3\x82\xbf\xe3\x82\xa4\xe3\x83\x88\xe3\x83\xab"\nend\n```\n\nNow you can use dirty methods as you would any other (untranslated) attribute:\n\n```ruby\npost.title_was\n#=> "Introducing Mobility"\nMobility.locale = :ja\npost.title_was\n#=> "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3\xe3\x81\xae\xe7\xb4\xb9\xe4\xbb\x8b"\npost.changed\n["title_en", "title_ja"]\npost.save\n```\n\nYou can also access `previous_changes`:\n\n```ruby\npost.previous_changes\n#=>\n{\n  "title_en" =>\n    [\n      "Introducing Mobility",\n      "a new title"\n    ],\n  "title_ja" =>\n    [\n      "\xe3\x83\xa2\xe3\x83\x93\xe3\x83\xaa\xe3\x83\x86\xe3\x82\xa3\xe3\x81\xae\xe7\xb4\xb9\xe4\xbb\x8b",\n      "\xe6\x96\xb0\xe3\x81\x97\xe3\x81\x84\xe3\x82\xbf\xe3\x82\xa4\xe3\x83\x88\xe3\x83\xab"\n    ]\n}\n```\n\nNotice that Mobility uses locale suffixes to indicate which locale has changed;\ndirty tracking is implemented this way to ensure that it is clear what\nhas changed in which locale, avoiding any possible ambiguity.\n\nFor performance reasons, it is highly recommended that when using the Dirty\nplugin, you also enable [locale accessors](#getset) for all locales which will\nbe used, so that methods like `title_en` above are defined; otherwise they will\nbe caught by `method_missing` (using fallthrough accessors), which is much slower.\nThe easiest way to do this is to set `config.default_options[:locale_accessors]\n= true` in your Mobility config, and make sure that `I18n.available_locales`\nincludes all locales you use in production.\n\nFor more details on dirty tracking, see the [API\ndocumentation](http://www.rubydoc.info/gems/mobility/Mobility/Plugins/Dirty).\n\n### Cache\n\nThe Mobility cache caches localized values that have been fetched once so they\ncan be quickly retrieved again. The cache is enabled by default and should\ngenerally only be disabled when debugging; this can be done by passing `cache:\nfalse` when defining an attribute, like this:\n\n```ruby\nclass Word < ApplicationRecord\n  extend Mobility\n  translates :name, cache: false\nend\n```\n\nYou can also turn off the cache for a single fetch by passing `cache: false` to\nthe getter method, i.e. `post.title(cache: false)`.\n\nThe cache is normally just a hash with locale keys and string (translation)\nvalues, but some backends (e.g. KeyValue and Table backends) have slightly more\ncomplex implementations.\n\n### <a name="querying"></a>Querying\n\nMobility backends also support querying on translated attributes, in two\ndifferent ways. The first is via query methods like `where` (and `not` and\n`find_by` in ActiveRecord, and `except` in Sequel). To query this way, use the\n`i18n` class method, which will return a model relation or dataset extended\nwith Mobility-specific query method overrides.\n\nSo for ActiveRecord, assuming a model using KeyValue as its default backend:\n\n```ruby\nclass Post < ApplicationRecord\n  extend Mobility\n  translates :title,   type: :string\n  translates :content, type: :text\nend\n```\n\n... we can query for posts with title "foo" and content "bar" just as we would\nquery on untranslated attributes, and Mobility will convert the queries to\nwhatever the backend requires to actually return the correct results:\n\n```ruby\nPost.i18n.find_by(title: "foo", content: "bar")\n```\n\nresults in the SQL:\n\n```sql\nSELECT "posts".* FROM "posts"\nINNER JOIN "mobility_string_translations" "Post_title_en_string_translations"\n  ON "Post_title_en_string_translations"."key" = \'title\'\n  AND "Post_title_en_string_translations"."locale" = \'en\'\n  AND "Post_title_en_string_translations"."translatable_type" = \'Post\'\n  AND "Post_title_en_string_translations"."translatable_id" = "posts"."id"\nINNER JOIN "mobility_text_translations" "Post_content_en_text_translations"\n  ON "Post_content_en_text_translations"."key" = \'content\'\n  AND "Post_content_en_text_translations"."locale" = \'en\'\n  AND "Post_content_en_text_translations"."translatable_type" = \'Post\'\n  AND "Post_content_en_text_translations"."translatable_id" = "posts"."id"\nWHERE "Post_title_en_string_translations"."value" = \'foo\'\n  AND "Post_content_en_text_translations"."value" = \'bar\'\n```\n\nAs can be seen in the query above, behind the scenes Mobility joins two tables,\none with string translations and one with text translations, and aliases the\njoins for each attribute so as to match the particular model, attribute(s),\nlocale(s) and value(s) passed in to the query. Details of how this is done can\nbe found in the [Wiki page for the KeyValue\nbackend](https://github.com/shioyama/mobility/wiki/KeyValue-Backend#querying).\n\nYou can also use methods like `order`, `select`, `pluck` and `group` on\ntranslated attributes just as you would with normal attributes, and Mobility\nwill handle generating the appropriate SQL:\n\n```ruby\nPost.i18n.pluck(:title)\n#=> ["foo", "bar", ...]\n```\n\nIf you would prefer to avoid the `i18n` scope everywhere, you can define it as\na default scope on your model:\n\n```ruby\nclass Post < ApplicationRecord\n  extend Mobility\n  translates :title,   type: :string\n  translates :content, type: :text\n  default_scope { i18n }\nend\n```\n\nNow translated attributes can be queried just like normal attributes:\n\n```ruby\nPost.find_by(title: "Introducing Mobility")\n#=> finds post with English title "Introducing Mobility"\n```\n\nIf you want more fine-grained control over your queries, you can alternatively\npass a block to the query method and call attribute names from the block scope\nto build Arel predicates:\n\n```ruby\nPost.i18n do\n  title.matches("foo").and(content.matches("bar"))\nend\n```\n\nwhich generates the same SQL as above, except the `WHERE` clause becomes:\n\n```sql\nSELECT "posts".* FROM "posts"\n  ...\nWHERE "Post_title_en_string_translations"."value" ILIKE \'foo\'\n  AND "Post_content_en_text_translations"."value" ILIKE \'bar\'\n```\n\nThe block-format query format is very powerful and allows you to build complex\nbackend-independent queries on translated and untranslated attributes without\nhaving to deal with the details of how these translations are stored. The same\ninterface is supported with Sequel to build datasets.\n\n<a name="backends"></a>Backends\n--------\n\nMobility supports different storage strategies, called "backends". The default\nbackend is the `KeyValue` backend, which stores translations in two tables, by\ndefault named `mobility_text_translations` and `mobility_string_translations`.\n\nYou can set the default backend to a different value in the global\nconfiguration, or you can set it explicitly when defining a translated\nattribute, like this:\n\n```ruby\nclass Word < ApplicationRecord\n  translates :name, backend: :table\nend\n```\n\nThis would set the `name` attribute to use the `Table` backend (see below).\nThe `type` option (`type: :string` or `type: :text`) is missing here because\nthis is an option specific to the KeyValue backend (specifying which shared\ntable to store translations on). Backends have their own specific options; see\nthe [Wiki][wiki] and [API documentation][docs] for which options are available\nfor each.\n\nEverything else described above (fallbacks, dirty tracking, locale accessors,\ncaching, querying, etc) is the same regardless of which backend you use.\n\n### Table Backend (like Globalize)\n\nThe `Table` backend stores translations as columns on a model-specific table. If\nyour model uses the table `posts`, then by default this backend will store an\nattribute `title` on a table `post_translations`, and join the table to\nretrieve the translated value.\n\nTo use the table backend on a model, you will need to first create a\ntranslation table for the model, which (with Rails) you can do using the\n`mobility:translations` generator:\n\n```\nrails generate mobility:translations post title:string content:text\n```\n\nThis will generate the `post_translations` table with columns `title` and\n`content`, and all other necessary columns and indices. For more details see\nthe [Table\nBackend](https://github.com/shioyama/mobility/wiki/Table-Backend) page of the\nwiki and API documentation on the [`Mobility::Backend::Table`\nclass](http://www.rubydoc.info/gems/mobility/Mobility/Backends/Table).\n\n### Column Backend (like Traco)\n\nThe `Column` backend stores translations as columns with locale suffixes on\nthe model table. For an attribute `title`, these would be of the form\n`title_en`, `title_fr`, etc.\n\nUse the `mobility:translations` generator to add columns for locales in\n`I18n.available_locales` to your model:\n\n```\nrails generate mobility:translations post title:string content:text\n```\n\nFor more details, see the [Column\nBackend](https://github.com/shioyama/mobility/wiki/Column-Backend) page of the\nwiki and API documentation on the [`Mobility::Backend::Column`\nclass](http://www.rubydoc.info/gems/mobility/Mobility/Backends/Column).\n\n### PostgreSQL-specific Backends\n\nMobility also supports JSON and Hstore storage options, if you are using\nPostgreSQL as your database. To use this option, create column(s) on the model\ntable for each translated attribute, and set your backend to `:json`, `:jsonb`\nor `:hstore`. If you are using Sequel, note that you\nwill need to enable the [pg_json](http://sequel.jeremyevans.net/rdoc-plugins/files/lib/sequel/extensions/pg_json_rb.html)\nor\n[pg_hstore](http://sequel.jeremyevans.net/rdoc-plugins/files/lib/sequel/extensions/pg_hstore_rb.html)\nextensions with `DB.extension :pg_json` or `DB.extension :pg_hstore` (where\n`DB` is your database instance).\n\nAnother option is to store all your translations on a single jsonb column (one\nper model). This is called the "container" backend.\n\nFor details on these backends, see the [Postgres\nBackend](https://github.com/shioyama/mobility/wiki/Postgres-Backends-%28Column-Attribute%29)\nand [Container\nBackend](https://github.com/shioyama/mobility/wiki/Container-Backend)\npages of the wiki and in the API documentation\n([`Mobility::Backend::Jsonb`](http://www.rubydoc.info/gems/mobility/Mobility/Backends/Jsonb)\nand\n[`Mobility::Backend::Hstore`](http://www.rubydoc.info/gems/mobility/Mobility/Backends/Hstore)).\n\n*Note: The Json backend (`:json`) may also work with recent versions of MySQL\nwith JSON column support, although this backend/db combination is not tested.\nSee [this issue](https://github.com/shioyama/mobility/issues/226) for details.*\n\nDevelopment\n-----------\n\n### Custom Backends\n\nAlthough Mobility is primarily oriented toward storing ActiveRecord model\ntranslations, it can potentially be used to handle storing translations in\nother formats. In particular, the features mentioned above (locale accessors,\ncaching, fallbacks, dirty tracking to some degree) are not specific to database\nstorage.\n\nTo use a custom backend, simply pass the name of a class which includes\n`Mobility::Backend` to `translates`:\n\n```ruby\nclass MyBackend\n  include Mobility::Backend\n  # ...\nend\n\nclass MyClass\n  extend Mobility\n  translates :foo, backend: MyBackend\nend\n```\n\nFor details on how to define a backend class, see the [Introduction to Mobility\nBackends](https://github.com/shioyama/mobility/wiki/Introduction-to-Mobility-Backends)\npage of the wiki and the [API documentation on the `Mobility::Backend`\nmodule](http://www.rubydoc.info/gems/mobility/Mobility/Backend).\n\n### Testing Backends\n\nAll included backends are tested against a suite of shared specs which ensure\nthey conform to the same expected behaviour. These examples can be found in:\n\n- `spec/support/shared_examples/accessor_examples.rb` (minimal specs testing\n  translation setting/getting)\n- `spec/support/shared_examples/querying_examples.rb` (specs for\n  [querying](#querying))\n- `spec/support/shared_examples/serialization_examples.rb` (specialized specs\n  for backends which store translations as a Hash: `serialized`, `hstore`,\n  `json` and `jsonb` backends)\n\nA minimal test can simply define a model class and use helpers defined in\n`spec/support/helpers.rb` to run these examples, by extending either\n`Helpers::ActiveRecord` or `Helpers::Sequel`:\n\n```ruby\ndescribe MyBackend do\n  extend Helpers::ActiveRecord\n\n  before do\n    stub_const \'MyPost\', Class.new(ActiveRecord::Base)\n    MyPost.extend Mobility\n    MyPost.translates :title, :content, backend: MyBackend\n  end\n\n  include_accessor_examples \'MyPost\'\n  include_querying_examples \'MyPost\'\n  # ...\nend\n```\n\nShared examples expect the model class to have translated attributes `title`\nand `content`, and an untranslated boolean column `published`. These defaults\ncan be changed, see the shared examples for details.\n\nBackends are also each tested against specialized specs targeted at their\nparticular implementations.\n\nIntegrations\n------------\n\n* [friendly_id-mobility](https://github.com/shioyama/friendly_id-mobility): Use\n  Mobility with [FriendlyId](https://github.com/norman/friendly_id).\n* [mobility-ransack](https://github.com/shioyama/mobility-ransack): Search\n  attributes translated by Mobility with\n  [Ransack](https://github.com/activerecord-hackery/ransack).\n\nTutorials\n---------\n\n- [Polyglot content in a rails\n  app](https://revs.runtime-revolution.com/polyglot-content-in-a-rails-app-aed823854955)\n- [Translating with\n  Mobility](https://dejimata.com/2017/3/3/translating-with-mobility)\n- [JSONify your Ruby\n  Translations](https://dejimata.com/2018/3/20/jsonify-your-ruby-translations)\n\nMore Information\n----------------\n\n- [Github repository](https://www.github.com/shioyama/mobility)\n- [API documentation][docs]\n- [Wiki][wiki]\n\n<a name="#companies-using-mobility"></a>Companies using Mobility\n------------------------\n\n<img alt="Logos of companies using Mobility" src="./img/companies-using-mobility.png" style="width: 100%" />\n\n- [Doorkeeper](https://www.doorkeeper.jp/)\n- [Oreegano](https://www.oreegano.com/)\n- [Venuu](https://venuu.fi)\n- ... <sup>&#10033;</sup>\n\n<sup>&#10033;</sup> <small>Post an issue or email me to add your company\'s name to this list.</small>\n\nLicense\n-------\n\nThe gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\n'