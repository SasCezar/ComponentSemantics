b'# Spyke\n\n<p align="center">\n  <img src="http://upload.wikimedia.org/wikipedia/en/thumb/2/21/Spyke.jpg/392px-Spyke.jpg" width="20%" />\n  <br/>\n  Interact with remote <strong>REST services</strong> in an <strong>ActiveRecord-like</strong> manner.\n  <br /><br />\n  <a href="https://rubygems.org/gems/spyke"><img src="https://badge.fury.io/rb/spyke.svg?style=flat" alt="Gem Version"></a>\n  <a href="https://codeclimate.com/github/balvig/spyke"><img src="https://codeclimate.com/github/balvig/spyke/badges/gpa.svg" /></a>\n  <a href=\'https://coveralls.io/r/balvig/spyke?branch=master\'><img src=\'https://img.shields.io/coveralls/balvig/spyke.svg?style=flat\' /></a>\n  <a href="https://travis-ci.org/balvig/spyke"><img src="https://travis-ci.org/balvig/spyke.svg?branch=master" /></a>\n</p>\n\n---\n\nSpyke basically ~~rips off~~ takes inspiration :innocent: from [Her](https://github.com/remiprev/her), a gem which we sadly had to abandon as it gave us some performance problems and maintenance seemed to have gone stale.\n\nWe therefore made Spyke which adds a few fixes/features needed for our projects:\n\n- Fast handling of even large amounts of JSON\n- Proper support for scopes\n- Ability to define custom URIs for associations\n- ActiveRecord-like log output\n- Handling of API-side validations\n- Googlable name! :)\n\n## Configuration\n\nAdd this line to your application\'s Gemfile:\n\n```ruby\ngem \'spyke\'\ngem \'multi_json\' # or whatever is needed to parse responses\n```\n\nSpyke uses Faraday to handle requests and expects it to parse the response body into a hash in the following format:\n\n```ruby\n{ data: { id: 1, name: \'Bob\' }, metadata: {}, errors: {} }\n```\n\nSo, for example for an API that returns JSON like this:\n\n```json\n{ "result": { "id": 1, "name": "Bob" }, "extra": {}, "errors": {} }\n```\n\n...the simplest possible configuration that could work is something like this:\n\n```ruby\n# config/initializers/spyke.rb\n\nclass JSONParser < Faraday::Response::Middleware\n  def parse(body)\n    json = MultiJson.load(body, symbolize_keys: true)\n    {\n      data: json[:result],\n      metadata: json[:extra],\n      errors: json[:errors]\n    }\n  end\nend\n\nSpyke::Base.connection = Faraday.new(url: \'http://api.com\') do |c|\n  c.request   :json\n  c.use       JSONParser\n  c.adapter   Faraday.default_adapter\nend\n```\n\n## Usage\n\nAdding a class and inheriting from `Spyke::Base` will allow you to interact with the remote service:\n\n```ruby\nclass User < Spyke::Base\n  has_many :posts\n  scope :active, -> { where(active: true) }\nend\n\nUser.all\n# => GET http://api.com/users\n\nUser.active\n# => GET http://api.com/users?active=true\n\nUser.where(age: 3).active\n# => GET http://api.com/users?active=true&age=3\n\nuser = User.find(3)\n# => GET http://api.com/users/3\n\nuser.posts\n# => find embedded in returned data or GET http://api.com/users/3/posts\n\nuser.update(name: \'Alice\')\n# => PUT http://api.com/users/3 - { user: { name: \'Alice\' } }\n\nuser.destroy\n# => DELETE http://api.com/users/3\n\nUser.create(name: \'Bob\')\n# => POST http://api.com/users - { user: { name: \'Bob\' } }\n```\n\n### Custom URIs\n\nYou can specify custom URIs on both the class and association level.\nSet uri to `nil` for associations you only want to use data embedded\nin the response and never call out to the API.\n\n```ruby\nclass User < Spyke::Base\n  uri \'people(/:id)\' # id optional, both /people and /people/4 are valid\n\n  has_many :posts, uri: \'posts/for_user/:user_id\' # user_id is required\n  has_one :image, uri: nil # only use embedded data\nend\n\nclass Post < Spyke::Base\nend\n\nuser = User.find(3) # => GET http://api.com/people/3\nuser.image # Will only use embedded data and never call out to api\nuser.posts # => GET http://api.com/posts/for_user/3\nPost.find(4) # => GET http://api.com/posts/4\n```\n\n### Custom requests\n\nCustom request methods and the `with` scope methods allow you to\nperform requests for non-REST actions:\n\nThe `.with` scope:\n\n```ruby\nPost.with(\'posts/recent\') # => GET http://api.com/posts/recent\nPost.with(:recent) # => GET http://api.com/posts/recent\nPost.with(:recent).where(status: \'draft\') # => GET http://api.com/posts/recent?status=draft\nPost.with(:recent).post # => POST http://api.com/posts/recent\n```\n\nCustom requests from instance:\n\n```ruby\nPost.find(3).put(:publish) # => PUT http://api.com/posts/3/publish\n```\n\nArbitrary requests (returns plain Result object):\n\n```ruby\nPost.request(:post, \'posts/3/log\', time: \'12:00\')\n# => POST http://api.com/posts/3/log - { time: \'12:00\' }\n```\n\n### Custom primary keys\n\nCustom primary keys can be defined with `self.primary_key = :custom_key`:\n\n```ruby\nclass User < Spyke::Base\n  self.primary_key = :user_id\n\n  # When using custom URIs the :id parameter also has to be adjusted\n  uri \'people(/:user_id)\'\nend\n```\n\n### API-side validations\n\nSpyke expects errors to be formatted in the same way as the\n[ActiveModel::Errors details hash](https://cowbell-labs.com/2015-01-22-active-model-errors-details.html), ie:\n\n```ruby\n{ title: [{ error: \'blank\'}, { error: \'too_short\', count: 10 }]}\n```\n\nIf the API you\'re using returns errors in a different format you can\nremap it in Faraday to match the above. Doing this will allow you to\nshow errors returned from the server in forms and f.ex using\n`@post.errors.full_messages` just like ActiveRecord.\n\n### Error handling and fallbacks\n\nShould the API fail to connect or time out, a `Spyke::ConnectionError` will be raised.\nIf you need to recover gracefully from connection problems, you can\neither rescue that exception or use the `with_fallback` feature:\n\n```ruby\n# API is down\nArticle.all # => Spyke::ConnectionError\nArticle.with_fallback.all # => []\n\nArticle.find(1) # => Spyke::ConnectionError\nArticle.with_fallback.find(1) # => nil\n\narticle = Article.with_fallback(Article.new(title: "Dummy")).find(1)\narticle.title # => "Dummy"\n```\n\n### Attributes-wrapping\n\nSpyke, like Rails, by default wraps sent attributes in a root element,\nbut this can be disabled or customized:\n\n```ruby\nclass Article < Spyke::Base\n  # Default\n  include_root_in_json  true # { article: { title: ...} }\n\n  # Custom\n  include_root_in_json :post # { post: { title: ...} }\n\n  # Disabled\n  include_root_in_json false # { title: ... }\nend\n```\n\n### Using multiple APIs\n\nIf you need to use different APIs, instead of configuring `Spyke::Base`\nyou can configure each class individually:\n\n```ruby\nclass Post < Spyke::Base\n  self.connection = Faraday.new(url: \'http://sashimi.com\') do |faraday|\n    # middleware\n  end\nend\n```\n\n### Log output\n\nWhen used with Rails, Spyke will automatically output helpful\nActiveRecord-like messages to the main log:\n\n```bash\nStarted GET "/posts" for 127.0.0.1 at 2014-12-01 14:31:20 +0000\nProcessing by PostsController#index as HTML\n  Parameters: {}\n  Spyke (40.3ms)  GET http://api.com/posts [200]\nCompleted 200 OK in 75ms (Views: 64.6ms | Spyke: 40.3ms | ActiveRecord: 0ms)\n```\n\n### Other examples\n\nFor more examples of how Spyke can be used, check out [fixtures.rb](https://github.com/balvig/spyke/blob/master/test/support/fixtures.rb) and the\n[test suite](https://github.com/balvig/spyke/tree/master/test).\n\n\n## Contributing\n\nIf possible please take a look at the [tests marked "wishlisted"](https://github.com/balvig/spyke/search?l=ruby&q=wishlisted&utf8=%E2%9C%93)!\nThese are features/fixes I\'d like to implement but haven\'t gotten around to doing yet :)\n'