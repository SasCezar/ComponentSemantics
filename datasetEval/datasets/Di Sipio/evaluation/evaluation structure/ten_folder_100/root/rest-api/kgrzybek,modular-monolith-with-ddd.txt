b'# Modular Monolith with DDD\n\nFull Modular Monolith .NET application with Domain-Driven Design approach.\n\n[![Build Status](https://dev.azure.com/kgr0189/kgr/_apis/build/status/kgrzybek.modular-monolith-with-ddd?branchName=master)](https://dev.azure.com/kgr0189/kgr/_build/latest?definitionId=1&branchName=master)\n\n## Table of contents\n\n[1. Introduction](#1-Introduction)\n\n&nbsp;&nbsp;[1.1 Purpose of this Repository](#11-purpose-of-this-repository)\n\n&nbsp;&nbsp;[1.2 Out of Scope](#12-out-of-scope)\n\n&nbsp;&nbsp;[1.3 Reason](#13-reason)\n\n&nbsp;&nbsp;[1.4 Disclaimer](#14-disclaimer)\n\n&nbsp;&nbsp;[1.5 Give a Star](#15-give-a-star)\n\n&nbsp;&nbsp;[1.6 Share It](#16-share-it)\n\n[2. Domain](#2-Domain)\n\n&nbsp;&nbsp;[2.1 Description](#21-description)\n\n&nbsp;&nbsp;[2.2 Conceptual Model](#22-conceptual-model)\n\n&nbsp;&nbsp;[2.3 Event Storming](#23-event-storming)\n\n[3. Architecture](#3-Architecture)\n\n&nbsp;&nbsp;[3.1 High Level View](#31-high-level-view)\n\n&nbsp;&nbsp;[3.2 Module Level View](#32-module-level-view)\n\n&nbsp;&nbsp;[3.3 API and Module Communication](#33-api-and-module-communication)\n\n&nbsp;&nbsp;[3.4 Module Requests Processing via CQRS](#34-module-requests-processing-via-cqrs)\n\n&nbsp;&nbsp;[3.5 Domain Model Principles and Attributes](#35-domain-model-principles-and-attributes)\n\n&nbsp;&nbsp;[3.6 Cross-Cutting Concerns](#36-cross-cutting-concerns)\n\n&nbsp;&nbsp;[3.7 Modules Integration](#37-modules-integration)\n\n&nbsp;&nbsp;[3.8 Internal Processing](#38-internal-processing)\n\n&nbsp;&nbsp;[3.9 Security](#39-security)\n\n&nbsp;&nbsp;[3.10 Unit Tests](#310-unit-tests)\n\n&nbsp;&nbsp;[3.11 Architecture Decision Log](#311-architecture-decision-log)\n\n&nbsp;&nbsp;[3.12 Architecture Unit Tests](#312-architecture-unit-tests)\n\n[4. Technology](#4-technology)\n\n[5. How to Run](#5-how-to-run)\n\n[6. Contribution](#6-contribution)\n\n[7. Roadmap](#7-roadmap)\n\n[8. Author](#8-author)\n\n[9. License](#9-license)\n\n[10. Inspirations and Recommendations](#10-inspirations-and-recommendations)\n\n## 1. Introduction\n\n### 1.1 Purpose of this Repository\n\nThis is a list of the main goals of this repository:\n\n- Showing how you can implement a **monolith** application in a **modular** way\n- Presentation of the **full implementation** of an application\n  - This is not another simple application\n  - This is not another proof of concept (PoC)\n  - The goal is to present the implementation of an application that would be ready to run in production\n- Showing the application of **best practices** and **object-oriented programming principles**\n- Presentation of the use of **design patterns**. When, how and why they can be used\n- Presentation of some **architectural** considerations, decisions, approaches\n- Presentation of the implementation using **Domain-Driven Design** approach (**tactical** patterns)\n- Presentation of the implementation of **Unit Tests** for Domain Model (Testable Design in mind)\n\n### 1.2 Out of Scope\n\nThis is a list of subjects which are out of scope for this repository:\n- Business requirements gathering and analysis\n- System analysis\n- Domain exploration\n- Domain distillation\n- Domain-Driven Design **strategic** patterns\n- Architecture evaluation, quality attributes analysis\n- Integration, system tests\n- Project management\n- Infrastructure\n- Containerization\n- Software engineering process, CI/CD\n- Deployment process\n- Maintenance\n- Documentation\n\n### 1.3 Reason\n\nThe reason for creating this repository is the lack of something similar. Most sample applications on GitHub have at least one of the following issues:\n- Very, very simple - few entities and use cases implemented\n- Not finished (for example there is no authentication, logging, etc..)\n- Poorly designed (in my opinion)\n- Poorly implemented (in my opinion)\n- Not well described\n- Assumptions and decisions are not clearly explained\n- Implements "Orders" domain - yes, everyone knows this domain, but something different is needed\n- Implemented in old technology\n- Not maintained\n\nTo sum up, there are some very good examples, but there are far too few of them. This repository has the task of filling this gap at some level.\n\n### 1.4 Disclaimer\n\nSoftware architecture should always be created to resolve specific **business problems**. Software architecture always supports some quality attributes and at the same time does not support others. A lot of other factors influence your software architecture - your team, opinions, preferences, experiences, technical constraints, time, budget, etc.\n\nAlways functional requirements, quality attributes, technical constraints and other factors should be considered before an architectural decision is made.\n\nBecause of the above, the architecture and implementation presented in this repository is **one of the many ways** to solve some problems. Take from this repository as much as you want, use it as you like but remember to **always pick the best solution which is appropriate to the problem class you have**.\n\n### 1.5 Give a Star\n\nMy primary focus in this project is on quality. Creating a good quality product involves a lot of analysis, research and work. It takes a lot of time. If you like this project, learned something or you are using it in your applications, please give it a star :star:.  This is the best motivation for me to continue this work. Thanks!\n\n### 1.6 Share It\n\nThere are very few really good examples of this type of application. If you think this repository makes a difference and is worth it, please share it with your friends and on social networks. I will be extremely grateful.\n\n## 2. Domain\n\n### 2.1 Description\n\n**Definition:**\n\n> Domain - A sphere of knowledge, influence, or activity. The subject area to which the user applies a program is the domain of the software. [Domain-Driven Design Reference](http://domainlanguage.com/ddd/reference/), Eric Evans\n\nThe **Meeting Groups** domain was selected for the purposes of this project based on the [Meetup.com](https://www.meetup.com/) system.\n\n**Main reasons for selecting this domain:**\n\n- It is common, a lot of people use the Meetup site to organize or attend meetings\n- There is a system for it, so everyone can check this implementation against a working site which supports this domain\n- It is not complex so it is easy to understand\n- It is not trivial - there are some business rules and logic and it is not just CRUD operations\n- You don\'t need much specific domain knowledge unlike other domains like financing, banking, medical\n- It is not big so it is easier to implement\n\n**Meetings**\n\nThe main business entities are `Member`, `Meeting Group` and `Meeting`. A `Member` can create a `Meeting Group`, be part of a `Meeting Group` or can attend a `Meeting`.\n\nA `Meeting Group Member` can be an `Organizer` of this group or a normal `Member`.\n\nOnly an `Organizer` of a `Meeting Group` can create a new `Meeting`.\n\nA `Meeting` has attendees, not attendees (`Members` which declare they will not attend the `Meeting`) and `Members` on the `Waitlist`.\n\nA `Meeting` can have an attendee limit. If the limit is reached, `Members` can only sign up to the `Waitlist`.\n\nA `Meeting Attendee` can bring guests to the `Meeting`. The number of guests allowed is an attribute of the `Meeting`. Bringing guests can be unallowed.\n\nA `Meeting Attendee` can have one of two roles: `Attendee` or `Host`. A `Meeting` must have at least one `Host`. The `Host` is a special role which grants permission to edit `Meeting` information or change the attendees list.\n\n**Administration**\n\nTo create a new `Meeting Group`, a `Member` needs to propose the group. A `Meeting Group Proposal` is sent to `Administrators`. An `Administrator` can accept or reject a `Meeting Group Proposal`. If a `Meeting Group Proposal` is accepted, a `Meeting Group` is created.\n\n**Payments**\n\nTo be able to organize `Meetings`, the `Meeting Group` must be paid for. The `Meeting Group` `Organizer` who is the `Payer`, must pay some fee according to a payment plan.\n\nAdditionally, Meeting organizer can set an `Event Fee`. Each `Meeting Attendee` is obliged to pay the fee. All guests should be paid by `Meeting Attendee` too.\n\n**Users**\n\nEach `Administrator`, `Member` and `Payer` is a `User`. To be a `User`, `User Registration` is required and confirmed.\n\nEach `User` is assigned one or more `User Role`.\n\nEach `User Role` has set of `Permissions`. A `Permission` defines whether `User` can invoke a particular action.\n\n\n### 2.2 Conceptual Model\n\n**Definition:**\n\n> Conceptual Model - A conceptual model is a representation of a system, made of the composition of concepts that are used to help people know, understand, or simulate a subject the model represents. [Wikipedia - Conceptual model](https://en.wikipedia.org/wiki/Conceptual_model)\n\n**Conceptual Model**\n\n![](docs/Images/Conceptual_Model.png)\n\n### 2.3 Event Storming\n\nWhile a Conceptual Model focuses on structures and relationships between them, **behavior** and **events** that occur in our domain are more important.\n\nThere are many ways to show behavior and events. One of them is a light technique called [Event Storming](https://www.eventstorming.com/) which is becoming more popular. Below are presented 3 main business processes using this technique: user registration, meeting group creation and meeting organization.\n\nNote: Event Storming is a light, live workshop. One of the possible outputs of this workshop is presented here. Even if you are not doing Event Storming workshops, this type of process presentation can be very valuable to you and your stakeholders.\n\n**User Registration process**\n\n------\n\n![](docs/Images/User_Registration.jpg)\n\n------\n\n**Meeting Group creation**\n![](docs/Images/Meeting_Group_Creation.jpg)\n\n------\n\n**Meeting organization**\n![](docs/Images/Meeting_Organization.jpg)\n\n------\n\n## 3. Architecture\n\n### 3.1 High Level View\n\n![](docs/Images/Architecture_high_level.png)\n\n**Module descriptions:**\n\n- **API** - Very thin ASP.NET MVC Core REST API application. Main responsibilities are:\n  1. Accept request\n  2. Authenticate and authorize request (using User Access module)\n  3. Delegate work to specific module sending Command or Query\n  4. Return response\n- **User Access** - responsible for user authentication, authorization and registration\n- **Meetings** - implements Meetings Bounded Context: creating meeting groups, meetings\n- **Administration** - implements Administration Bounded Context: implements administrative tasks like meeting group proposal verification\n- **Payments** - implements Payments Bounded Context: implements all functionalities associated with payments\n- **In Memory Events Bus** - Publish/Subscribe implementation to asynchronously integrate all modules using events ([Event Driven Architecture](https://en.wikipedia.org/wiki/Event-driven_architecture)).\n\n**Key assumptions:**\n\n1. API contains no application logic\n2. API communicates with Modules using a small interface to send Queries and Commands\n3. Each Module has its own interface which is used by API\n4. **Modules communicate each other only asynchronously using Events Bus** - direct method calls are not allowed\n5. Each Module **has it\'s own data** in a separate schema - shared data is not allowed\n   - Module data could be moved into separate databases if desired\n6. Modules can only have a dependency on the integration events assembly of other Module (see [Module level view](#32-module-level-view))\n7. Each Module has its own [Composition Root](https://freecontent.manning.com/dependency-injection-in-net-2nd-edition-understanding-the-composition-root/), which implies that each Module has its own Inversion-of-Control container\n8. API as a host needs to initialize each module and each module has an initialization method\n9. Each Module is **highly encapsulated** - only required types and members are public, the rest are internal or private\n\n### 3.2 Module Level View\n\n![](docs/Images/Module_level_diagram.png)\n\nEach Module consists of the following submodules (assemblies):\n\n- **Application** - the main submodule which is responsible for initialization, processing all requests, internal commands and integration events\n- **Domain** - Domain Model in Domain-Driven Design terms implements the applicable [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html)\n- **Infrastructure** - infrastructural code like Entity Framework configuration and mappings\n- **IntegrationEvents** - **Contracts** published to the Events Bus; only this assembly can be called by other modules\n\n![](docs/Images/VSSolution.png)\n\n**Note:** Application, Domain and Infrastructure assemblies could be merged into one assembly. Some people like horizontal layering or more decomposition, some don\'t. Implementing the Domain Model or Infrastructure in separate assembly allows encapsulation using the [`internal`](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal) keyword. Sometimes Bounded Context logic is not worth it because it is too simple. As always, be pragmatic and take whatever approach you like.\n\n### 3.3 API and Module Communication\n\nThe API only communicates with Modules in two ways: during module initialization and request processing.\n\n**Module initialization**\n\nEach module has a static ``Initialize`` method which is invoked in the API ``Startup`` class. All configuration needed by this module should be provided as arguments to this method. All services are configured during initialization and the Composition Root is created using the Inversion-of-Control Container.\n\n```csharp\npublic static void Initialize(\n    string connectionString,\n    IExecutionContextAccessor executionContextAccessor,\n    ILogger logger,\n    EmailsConfiguration emailsConfiguration)\n{\n    var moduleLogger = logger.ForContext("Module", "Meetings");\n\n    ConfigureCompositionRoot(connectionString, executionContextAccessor, moduleLogger, emailsConfiguration);\n\n    QuartzStartup.Initialize(moduleLogger);\n\n    EventsBusStartup.Initialize(moduleLogger);\n}\n```\n\n**Request processing**\n\nEach module has the same interface signature exposed to the API. It contains 3 methods: command with result, command without result and query.\n\n```csharp\npublic interface IMeetingsModule\n{\n    Task<TResult> ExecuteCommandAsync<TResult>(ICommand<TResult> command);\n\n    Task ExecuteCommandAsync(ICommand command);\n\n    Task<TResult> ExecuteQueryAsync<TResult>(IQuery<TResult> query);\n}\n```\n\n**Note:** Some people say that processing a command should not return a result. This is an understandable approach but sometimes impractical, especially when you want to immediately return the ID of a newly created resource. Sometimes the boundary between Command and Query is blurry. One example is ``AuthenticateCommand`` - it returns a token but it is not a query because it has a side effect.\n\n### 3.4 Module Requests Processing via CQRS\n\nProcessing of Commands and Queries is separated by applying the architectural style/pattern [Command Query Responsibility Segregation (CQRS)](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs).\n\n![](docs/Images/CQRS.jpg)\n\nCommands are processed using *Write Model* which is implemented using DDD tactical patterns:\n\n```csharp\ninternal class CreateNewMeetingGroupCommandHandler : ICommandHandler<CreateNewMeetingGroupCommand>\n{\n    private readonly IMeetingGroupRepository _meetingGroupRepository;\n    private readonly IMeetingGroupProposalRepository _meetingGroupProposalRepository;\n\n    internal CreateNewMeetingGroupCommandHandler(\n        IMeetingGroupRepository meetingGroupRepository,\n        IMeetingGroupProposalRepository meetingGroupProposalRepository)\n    {\n        _meetingGroupRepository = meetingGroupRepository;\n        _meetingGroupProposalRepository = meetingGroupProposalRepository;\n    }\n\n    public async Task<Unit> Handle(CreateNewMeetingGroupCommand request, CancellationToken cancellationToken)\n    {\n        var meetingGroupProposal = await _meetingGroupProposalRepository.GetByIdAsync(request.MeetingGroupProposalId);\n\n        var meetingGroup = meetingGroupProposal.CreateMeetingGroup();\n\n        await _meetingGroupRepository.AddAsync(meetingGroup);\n\n        return Unit.Value;\n    }\n}\n```\n\nQueries are processed using *Read Model* which is implemented by executing raw SQL statements on database views:\n\n```csharp\ninternal class GetAllMeetingGroupsQueryHandler : IQueryHandler<GetAllMeetingGroupsQuery, List<MeetingGroupDto>>\n{\n    private readonly ISqlConnectionFactory _sqlConnectionFactory;\n\n    internal GetAllMeetingGroupsQueryHandler(ISqlConnectionFactory sqlConnectionFactory)\n    {\n        _sqlConnectionFactory = sqlConnectionFactory;\n    }\n\n    public async Task<List<MeetingGroupDto>> Handle(GetAllMeetingGroupsQuery request, CancellationToken cancellationToken)\n    {\n        var connection = _sqlConnectionFactory.GetOpenConnection();\n\n        const string sql = "SELECT " +\n                           "[MeetingGroup].[Id], " +\n                           "[MeetingGroup].[Name], " +\n                           "[MeetingGroup].[Description], " +\n                           "[MeetingGroup].[LocationCountryCode], " +\n                           "[MeetingGroup].[LocationCity]" +\n                           "FROM [meetings].[v_MeetingGroups] AS [MeetingGroup]";\n        var meetingGroups = await connection.QueryAsync<MeetingGroupDto>(sql);\n\n        return meetingGroups.AsList();\n    }\n}\n```\n\n**Key advantages:**\n\n- Solution is appropriate to the problem - reading and writing needs are usually different\n- Supports [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single_responsibility_principle) (SRP) - one handler does one thing\n- Supports [Interface Segregation Principle](https://en.wikipedia.org/wiki/Interface_segregation_principle) (ISP) - each handler implements interface with exactly one method\n- Supports [Parameter Object pattern](https://refactoring.com/catalog/introduceParameterObject.html) - Commands and Queries are objects which are easy to serialize/deserialize\n- Easy way to apply [Decorator pattern](https://en.wikipedia.org/wiki/Decorator_pattern) to handle cross-cutting concerns\n- Supports Loose Coupling by use of the [Mediator pattern](https://en.wikipedia.org/wiki/Mediator_pattern) - separates invoker of request from handler of request\n\n**Disadvantage:**\n- Mediator pattern introduces extra indirection and is harder to reason about which class handles the request\n\nFor more information: [Simple CQRS implementation with raw SQL and DDD](https://www.kamilgrzybek.com/design/simple-cqrs-implementation-with-raw-sql-and-ddd/)\n\n### 3.5 Domain Model Principles and Attributes\n\nThe Domain Model, which is the central and most critical part in the system, should be designed with special attention. Here are some key principles and attributes which are applied to Domain Models of each module:\n\n1. **High level of encapsulation**\n\n    All members are ``private`` by default, then ``internal`` - only ``public`` at the very edge.\n\n2. **High level of PI (Persistence Ignorance)**\n\n    No dependencies to infrastructure, databases, etc. All classes are [POCOs](https://en.wikipedia.org/wiki/Plain_old_CLR_object).\n\n3. **Rich in behavior**\n\n    All business logic is located in the Domain Model. No leaks to the application layer or elsewhere.\n\n4. **Low level of Primitive Obsession**\n\n    Primitive attributes of Entites grouped together using ValueObjects.\n\n5. **Business language**\n\n    All classes, methods and other members are named in business language used in this Bounded Context.\n\n6. **Testable**\n\n    The Domain Model is a critical part of the system so it should be easy to test (Testable Design).\n\n```csharp\npublic class MeetingGroup : Entity, IAggregateRoot\n{\n    public MeetingGroupId Id { get; private set; }\n\n    private string _name;\n\n    private string _description;\n\n    private MeetingGroupLocation _location;\n\n    private MemberId _creatorId;\n\n    private List<MeetingGroupMember> _members;\n\n    private DateTime _createDate;\n\n    private DateTime? _paymentDateTo;\n\n    internal static MeetingGroup CreateBasedOnProposal(\n        MeetingGroupProposalId meetingGroupProposalId,\n        string name,\n        string description,\n        MeetingGroupLocation location, MemberId creatorId)\n    {\n        return new MeetingGroup(meetingGroupProposalId, name, description, location, creatorId);\n    }\n\n     public Meeting CreateMeeting(\n            string title,\n            MeetingTerm term,\n            string description,\n            MeetingLocation location,\n            int? attendeesLimit,\n            int guestsLimit,\n            Term rsvpTerm,\n            MoneyValue eventFee,\n            List<MemberId> hostsMembersIds,\n            MemberId creatorId)\n        {\n            this.CheckRule(new MeetingCanBeOrganizedOnlyByPayedGroupRule(_paymentDateTo));\n\n            this.CheckRule(new MeetingHostMustBeAMeetingGroupMemberRule(creatorId, hostsMembersIds, _members));\n\n            return new Meeting(this.Id,\n                title,\n                term,\n                description,\n                location,\n                attendeesLimit,\n                guestsLimit,\n                rsvpTerm,\n                eventFee,\n                hostsMembersIds,\n                creatorId);\n        }\n```\n\n### 3.6 Cross-Cutting Concerns\n\nTo support [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single_responsibility_principle) and [Don\'t Repeat Yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principles, the implementation of cross-cutting concerns is done using the [Decorator Pattern](https://en.wikipedia.org/wiki/Decorator_pattern). Each Command processor is decorated by 3 decorators: logging, validation and unit of work.\n\n![](docs/Images/Decorator.jpg)\n\n**Logging**\n\nThe Logging decorator logs execution, arguments and processing of each Command. This way each log inside a processor has the log context of the processing command.\n\n```csharp\ninternal class LoggingCommandHandlerDecorator<T> : ICommandHandler<T> where T:ICommand\n{\n    private readonly ILogger _logger;\n    private readonly IExecutionContextAccessor _executionContextAccessor;\n    private readonly ICommandHandler<T> _decorated;\n\n    public LoggingCommandHandlerDecorator(\n        ILogger logger,\n        IExecutionContextAccessor executionContextAccessor,\n        ICommandHandler<T> decorated)\n    {\n        _logger = logger;\n        _executionContextAccessor = executionContextAccessor;\n        _decorated = decorated;\n    }\n    public async Task<Unit> Handle(T command, CancellationToken cancellationToken)\n    {\n        if (command is IRecurringCommand)\n        {\n            return await _decorated.Handle(command, cancellationToken);\n        }\n        using (\n            LogContext.Push(\n                new RequestLogEnricher(_executionContextAccessor),\n                new CommandLogEnricher(command)))\n        {\n            try\n            {\n                this._logger.Information(\n                    "Executing command {Command}",\n                    command.GetType().Name);\n\n                var result = await _decorated.Handle(command, cancellationToken);\n\n                this._logger.Information("Command {Command} processed successful", command.GetType().Name);\n\n                return result;\n            }\n            catch (Exception exception)\n            {\n                this._logger.Error(exception, "Command {Command} processing failed", command.GetType().Name);\n                throw;\n            }\n        }\n    }\n\n    private class CommandLogEnricher : ILogEventEnricher\n    {\n        private readonly ICommand _command;\n\n        public CommandLogEnricher(ICommand command)\n        {\n            _command = command;\n        }\n        public void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory)\n        {\n            logEvent.AddOrUpdateProperty(new LogEventProperty("Context", new ScalarValue($"Command:{_command.Id.ToString()}")));\n        }\n    }\n\n    private class RequestLogEnricher : ILogEventEnricher\n    {\n        private readonly IExecutionContextAccessor _executionContextAccessor;\n        public RequestLogEnricher(IExecutionContextAccessor executionContextAccessor)\n        {\n            _executionContextAccessor = executionContextAccessor;\n        }\n        public void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory)\n        {\n            if (_executionContextAccessor.IsAvailable)\n            {\n                logEvent.AddOrUpdateProperty(new LogEventProperty("CorrelationId", new ScalarValue(_executionContextAccessor.CorrelationId)));\n            }\n        }\n    }\n}\n```\n\n**Validation**\n\nThe Validation decorator performs Command data validation. It checks rules against Command arguments using the FluentValidation library.\n\n```csharp\ninternal class ValidationCommandHandlerDecorator<T> : ICommandHandler<T> where T:ICommand\n{\n    private readonly IList<IValidator<T>> _validators;\n    private readonly ICommandHandler<T> _decorated;\n\n    public ValidationCommandHandlerDecorator(\n        IList<IValidator<T>> validators,\n        ICommandHandler<T> decorated)\n    {\n        this._validators = validators;\n        _decorated = decorated;\n    }\n\n    public Task<Unit> Handle(T command, CancellationToken cancellationToken)\n    {\n        var errors = _validators\n            .Select(v => v.Validate(command))\n            .SelectMany(result => result.Errors)\n            .Where(error => error != null)\n            .ToList();\n\n        if (errors.Any())\n        {\n            var errorBuilder = new StringBuilder();\n\n            errorBuilder.AppendLine("Invalid command, reason: ");\n\n            foreach (var error in errors)\n            {\n                errorBuilder.AppendLine(error.ErrorMessage);\n            }\n\n            throw new InvalidCommandException(errorBuilder.ToString(), null);\n        }\n\n        return _decorated.Handle(command, cancellationToken);\n    }\n}\n```\n\n**Unit Of Work**\n\nAll Command processing has side effects. To avoid calling commit on every handler, `UnitOfWorkCommandHandlerDecorator` is used. It additionally marks `InternalCommand` as processed (if it is Internal Command) and dispatches all Domain Events (as part of [Unit Of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html)).\n\n```csharp\npublic class UnitOfWorkCommandHandlerDecorator<T> : ICommandHandler<T> where T:ICommand\n{\n    private readonly ICommandHandler<T> _decorated;\n    private readonly IUnitOfWork _unitOfWork;\n    private readonly MeetingsContext _meetingContext;\n\n    public UnitOfWorkCommandHandlerDecorator(\n        ICommandHandler<T> decorated,\n        IUnitOfWork unitOfWork,\n        MeetingsContext meetingContext)\n    {\n        _decorated = decorated;\n        _unitOfWork = unitOfWork;\n        _meetingContext = meetingContext;\n    }\n\n    public async Task<Unit> Handle(T command, CancellationToken cancellationToken)\n    {\n        await this._decorated.Handle(command, cancellationToken);\n\n        if (command is InternalCommandBase)\n        {\n            var internalCommand =\n                await _meetingContext.InternalCommands.FirstOrDefaultAsync(x => x.Id == command.Id,\n                    cancellationToken: cancellationToken);\n\n            if (internalCommand != null)\n            {\n                internalCommand.ProcessedDate = DateTime.UtcNow;\n            }\n        }\n\n        await this._unitOfWork.CommitAsync(cancellationToken);\n\n        return Unit.Value;\n    }\n}\n```\n\n### 3.7 Modules Integration\n\nIntegration between modules is strictly **asynchronous** using Integration Events and the In Memory Event Bus as broker. In this way coupling between modules is minimal and exists only on the structure of Integration Events.\n\n**Modules don\'t share data** so it is not possible nor desirable to create a transaction which spans more than one module. To ensure maximum reliability, the [Outbox / Inbox pattern](http://www.kamilgrzybek.com/design/the-outbox-pattern/) is used. This pattern provides accordingly *"At-Least-Once delivery"* and *"At-Least-Once processing"*.\n\n![](docs/Images/OutboxInbox.jpg)\n\nThe Outbox and Inbox is implemented using two SQL tables and a background worker for each module. The background worker is implemented using the Quartz.NET library.\n\n**Saving to Outbox:**\n\n![](docs/Images/OutboxSave.png)\n\n**Processing Outbox:**\n\n![](docs/Images/OutboxProcessing.png)\n\n### 3.8 Internal Processing\n\nThe main principle of this system is that you can change its state only by calling a specific Command.\n\nCommands can be called not only by the API, but by the processing module itself. The main use case which implements this mechanism is data processing in eventual consistency mode when we want to process something in a different process and transaction. This applies, for example, to Inbox processing because we want to do something (calling a Command) based on an Integration Event from the Inbox.\n\nThis idea is taken from Alberto\'s Brandolini\'s Event Storming picture called "The picture that explains \xe2\x80\x9calmost\xe2\x80\x9d everything" which shows that every side effect (domain event) is created by invoking a Command on Aggregate. See [EventStorming cheat sheet](https://xebia.com/blog/eventstorming-cheat-sheet/) article for more details.\n\nImplementation of internal processing is very similar to implementation of the Outbox and Inbox. One SQL table and one background worker for processing. Each internally processing Command must inherit from `InternalCommandBase` class:\n\n```csharp\ninternal abstract class InternalCommandBase : ICommand\n{\n    public Guid Id { get; }\n\n    protected InternalCommandBase(Guid id)\n    {\n        this.Id = id;\n    }\n}\n```\n\nThis is important because the `UnitOfWorkCommandHandlerDecorator` must mark an internal Command as processed during committing:\n\n```csharp\npublic async Task<Unit> Handle(T command, CancellationToken cancellationToken)\n{\n    await this._decorated.Handle(command, cancellationToken);\n\n    if (command is InternalCommandBase)\n    {\n        var internalCommand =\n            await _meetingContext.InternalCommands.FirstOrDefaultAsync(x => x.Id == command.Id,\n                cancellationToken: cancellationToken);\n\n        if (internalCommand != null)\n        {\n            internalCommand.ProcessedDate = DateTime.UtcNow;\n        }\n    }\n\n    await this._unitOfWork.CommitAsync(cancellationToken);\n\n    return Unit.Value;\n}\n```\n\n### 3.9 Security\n\n**Authentication**\n\nAuthentication is implemented using JWT Token and Bearer scheme using IdentityServer. For now, only one authentication method is implemented: forms style authentication (username and password) via the OAuth2 [Resource Owner Password Grant Type](https://www.oauth.com/oauth2-servers/access-tokens/password-grant/). It requires implementation of the `IResourceOwnerPasswordValidator` interface:\n\n```csharp\npublic class ResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator\n{\n    private readonly IUserAccessModule _userAccessModule;\n\n    public ResourceOwnerPasswordValidator(IUserAccessModule userAccessModule)\n    {\n        _userAccessModule = userAccessModule;\n    }\n\n    public async Task ValidateAsync(ResourceOwnerPasswordValidationContext context)\n    {\n        var authenticationResult = await _userAccessModule.ExecuteCommandAsync(new AuthenticateCommand(context.UserName, context.Password));\n        if (!authenticationResult.IsAuthenticated)\n        {\n            context.Result = new GrantValidationResult(\n                TokenRequestErrors.InvalidGrant,\n                authenticationResult.AuthenticationError);\n            return;\n        }\n        context.Result = new GrantValidationResult(\n            authenticationResult.User.Id.ToString(),\n            "forms",\n            authenticationResult.User.Claims);\n    }\n}\n```\n\n**Authorization**\n\nAuthorization is achieved by implementing [RBAC (Role Based Access Control)](https://en.wikipedia.org/wiki/Role-based_access_control) using Permissions. Permissions are more granular and a much better way to secure your application than Roles alone. Each User has a set of Roles and each Role contains one or more Permission. The User\'s set of Permissions is extracted from all Roles the User belongs to. Permissions are always checked on `Controller` level - never Roles:\n\n```csharp\n[HttpPost]\n[Route("")]\n[HasPermission(MeetingsPermissions.ProposeMeetingGroup)]\npublic async Task<IActionResult> ProposeMeetingGroup(ProposeMeetingGroupRequest request)\n{\n    await _meetingsModule.ExecuteCommandAsync(\n        new ProposeMeetingGroupCommand(\n            request.Name,\n            request.Description,\n            request.LocationCity,\n            request.LocationCountryCode));\n\n    return Ok();\n}\n```\n### 3.10 Unit Tests\n\n**Definition:**\n\n>A unit test is an automated piece of code that invokes the unit of work being tested, and then checks some assumptions about a single end result of that unit. A unit test is almost always written using a unit testing framework. It can be written easily and runs quickly. It\xe2\x80\x99s trustworthy, readable, and maintainable. It\xe2\x80\x99s consistent in its results as long as production code hasn\xe2\x80\x99t changed. [Art of Unit Testing 2nd Edition](https://www.manning.com/books/the-art-of-unit-testing-second-edition) Roy Osherove\n\n**Attributes of good unit test**\n\n- Automated\n- Maitainable\n- Runs very fast (in ms)\n- Consistent, Deterministic (always the same result)\n- Isolated from other tests\n- Readable\n- Can be executed by anyone\n- Testing public API, not internal behavior (overspecification)\n- Looks like production code\n- Treated as production code\n\n**Implementation**\n\nEach unit test has 3 standard sections: Arrange, Act and Assert\n\n![](docs/Images/UnitTestsGeneral.jpg)\n\n**1\\. Arrange**\n\nThe Arrange section is responsible for preparing the Aggregate for testing the public method that we want to test. This public method is often called (from the unit tests perspective) the SUT (system under test).\n\nCreating an Aggregate ready for testing involves **calling one or more other public constructors/methods** on the Domain Model. At first it may seem that we are testing too many things at the same time, but this is not true. We need to be one hundred percent sure that the Aggregate is in a state exactly as it will be in production. This can only be ensured when we:\n\n- **Use only public API of Domain Model**\n- Don\'t use [InternalsVisibleToAttribute](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.internalsvisibletoattribute?view=netframework-4.8) class\n  - This exposes the Domain Model to the Unit Tests library, removing encapsulation so our tests and production code are treated differently and it is a very bad thing\n- Don\'t use [ConditionalAttribute](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute?view=netframework-4.8) classes - it reduces readability and increases complexity\n- Don\'t create any special constructors/factory methods for tests (even with conditional compilation symbols)\n  - Special constructor/factory method only for unit tests causes duplication of business logic in the test itself and focuses on state - this kind of approach causes the test to be very sensitive to changes and hard to maintain\n- Don\'t remove encapsulation from Domain Model (for example: change keywords from `internal`/`private` to `public`)\n- Don\'t make methods `protected` to inherit from tested class and in this way provide access to internal methods/properties\n\n**Isolation of external dependencies**\n\nThere are 2 main concepts - stubs and mocks:\n\n> A stub is a controllable replacement for an existing dependency (or collaborator) in the system. By using a stub, you can test your code without dealing with the dependency directly.\n\n>A mock object is a fake object in the system that decides whether the unit test has passed or failed. It does so by verifying whether the object under test called the fake object as expected. There\xe2\x80\x99s usually no more than one mock per test.\n>[Art of Unit Testing 2nd Edition](https://www.manning.com/books/the-art-of-unit-testing-second-edition) Roy Osherove\n\nGood advice: use stubs if you need to, but try to avoid mocks. Mocking causes us to test too many internal things and leads to overspecification.\n\n**2\\. Act**\n\nThis section is very easy - we execute **exactly one** public method on aggregate (SUT).\n\n**3\\. Assert**\n\nIn this section we check expectations. There are only 2 possible outcomes:\n\n- Method completed and Domain Event(s) published\n- Business rule was broken\n\nSimple example:\n\n```csharp\n[Test]\npublic void NewUserRegistration_WithUniqueLogin_IsSuccessful()\n{\n    // Arrange\n    var usersCounter = Substitute.For<IUsersCounter>();\n\n    // Act\n    var userRegistration =\n        UserRegistration.RegisterNewUser(\n            "login", "password", "test@email",\n            "firstName", "lastName", usersCounter);\n\n    // Assert\n    var newUserRegisteredDomainEvent = AssertPublishedDomainEvent<NewUserRegisteredDomainEvent>(userRegistration);\n    Assert.That(newUserRegisteredDomainEvent.UserRegistrationId, Is.EqualTo(userRegistration.Id));\n}\n\n[Test]\npublic void NewUserRegistration_WithoutUniqueLogin_BreaksUserLoginMustBeUniqueRule()\n{\n    // Arrange\n    var usersCounter = Substitute.For<IUsersCounter>();\n    usersCounter.CountUsersWithLogin("login").Returns(x => 1);\n\n    // Assert\n    AssertBrokenRule<UserLoginMustBeUniqueRule>(() =>\n    {\n        // Act\n        UserRegistration.RegisterNewUser(\n            "login", "password", "test@email",\n            "firstName", "lastName", usersCounter);\n    });\n}\n```\n\nAdvanced example:\n\n```csharp\n[Test]\npublic void AddAttendee_WhenMemberIsAlreadyAttendeeOfMeeting_IsNotPossible()\n{\n    // Arrange\n    var creatorId = new MemberId(Guid.NewGuid());\n    var meetingTestData = CreateMeetingTestData(new MeetingTestDataOptions\n    {\n        CreatorId = creatorId\n    });\n    var newMemberId = new MemberId(Guid.NewGuid());\n    meetingTestData.MeetingGroup.JoinToGroupMember(newMemberId);\n    meetingTestData.Meeting.AddAttendee(meetingTestData.MeetingGroup, newMemberId, 0);\n\n    // Assert\n    AssertBrokenRule<MemberCannotBeAnAttendeeOfMeetingMoreThanOnceRule>(() =>\n    {\n        // Act\n        meetingTestData.Meeting.AddAttendee(meetingTestData.MeetingGroup, newMemberId, 0);\n    });\n}\n```\n\n`CreateMeetingTestData` method is an implementation of [SUT Factory](https://blog.ploeh.dk/2009/02/13/SUTFactory/) described by Mark Seemann which allows keeping common creation logic in one place:\n\n```csharp\nprotected MeetingTestData CreateMeetingTestData(MeetingTestDataOptions options)\n{\n    var proposalMemberId = options.CreatorId ?? new MemberId(Guid.NewGuid());\n    var meetingProposal = MeetingGroupProposal.ProposeNew(\n        "name", "description",\n        new MeetingGroupLocation("Warsaw", "PL"), proposalMemberId);\n\n    meetingProposal.Accept();\n\n    var meetingGroup = meetingProposal.CreateMeetingGroup();\n\n    meetingGroup.UpdatePaymentInfo(DateTime.Now.AddDays(1));\n\n    var meetingTerm = options.MeetingTerm ??\n                      new MeetingTerm(DateTime.UtcNow.AddDays(1), DateTime.UtcNow.AddDays(2));\n\n    var rsvpTerm = options.RvspTerm ?? Term.NoTerm;\n    var meeting = meetingGroup.CreateMeeting("title",\n        meetingTerm,\n        "description",\n        new MeetingLocation("Name", "Address", "PostalCode", "City"),\n        options.AttendeesLimit,\n        options.GuestsLimit,\n        rsvpTerm,\n        MoneyValue.Zero,\n        new List<MemberId>(),\n        proposalMemberId);\n\n    DomainEventsTestHelper.ClearAllDomainEvents(meetingGroup);\n\n    return new MeetingTestData(meetingGroup, meeting);\n}\n```\n\n### 3.11 Architecture Decision Log\n\nAll Architectural Decisions (AD) are documented in the [Architecture Decision Log (ADL)](docs/architecture-decision-log).\n\nMore information about documenting architecture-related decisions in this way : [https://github.com/joelparkerhenderson/architecture_decision_record](https://github.com/joelparkerhenderson/architecture_decision_record)\n\n### 3.12 Architecture Unit Tests\n\nIn some cases it is not possible to enforce the application architecture, design or established conventions using compiler (compile-time). For this reason, code implementations can diverge from the original design and architecture. We want to minimize this behavior, not only by code review.</br>\n\nTo do this, unit tests of system architecture, design, major conventions and assumptions  have been written. In .NET there is special library for this task: [NetArchTest](https://github.com/BenMorris/NetArchTest). This library has been written based on the very popular JAVA architecture unit tests library - [ArchUnit](https://www.archunit.org/).</br>\n\nUsing this kind of tests we can test proper layering of our application, dependencies, encapsulation, immutability, DDD correct implementation, naming, conventions and so on - everything what we need to test. Example:</br>\n\n![](docs/Images/architecture_unit_tests.png)\n\nMore information about architecture unit tests here: [https://blogs.oracle.com/javamagazine/unit-test-your-architecture-with-archunit](https://blogs.oracle.com/javamagazine/unit-test-your-architecture-with-archunit)\n\n\n## 4. Technology\n\nList of technologies, frameworks and libraries used for implementation:\n\n- [.NET Core 2.2](https://dotnet.microsoft.com/download) (platform)\n- [MS SQL Server Express](https://www.microsoft.com/en-us/sql-server/sql-server-editions-express) (database)\n- [Entity Framework Core 2.2](https://docs.microsoft.com/en-us/ef/core/) (ORM Write Model implementation for DDD)\n- [Autofac](https://autofac.org/) (Inversion of Control Container)\n- [IdentityServer4](http://docs.identityserver.io) (Authentication and Authorization)\n- [Serilog](https://serilog.net/) (structured logging)\n- [Hellang.Middleware.ProblemDetails](https://github.com/khellang/Middleware/tree/master/src/ProblemDetails) (API Problem Details support)\n- [Swashbuckle](https://github.com/domaindrivendev/Swashbuckle) (Swagger automated documentation)\n- [Dapper](https://github.com/StackExchange/Dapper) (micro ORM for Read Model)\n- [Newtonsoft.Json](https://www.newtonsoft.com/json) (serialization/deserialization to/from JSON)\n- [Quartz.NET](https://www.quartz-scheduler.net/) (background processing)\n- [FluentValidation](https://fluentvalidation.net/) (data validation)\n- [MediatR](https://github.com/jbogard/MediatR) (mediator implementation)\n- [Postman](https://www.getpostman.com/) (API tests)\n- [NUnit](https://nunit.org/) (Testing framework)\n- [NSubstitute](https://nsubstitute.github.io/) (Testing isolation framework)\n- [Visual Paradigm Community Edition](https://www.visual-paradigm.com/download/community.jsp) (CASE tool for modeling and documentation)\n- [NetArchTest](https://github.com/BenMorris/NetArchTest) (Architecture Unit Tests library)\n\n## 5. How to Run\n\n- Download and install .NET Core 2.2 SDK\n- Download and install MS SQL Server Express or other\n- Create an empty database and run [InitializeDatabase.sql](src/Database/InitializeDatabase.sql) script\n  \n  - 2 test users will be created - check the script for usernames and passwords\n- Set a database connection string called `MeetingsConnectionString` in the root of the API project\'s appsettings.json or use [Secrets](https://blogs.msdn.microsoft.com/mihansen/2017/09/10/managing-secrets-in-net-core-2-0-apps/)\n\n  Example config setting in appsettings.json for a database called `ModularMonolith`:\n  ```json\n  {\n\t  "MeetingsConnectionString": "Server=(localdb)\\\\mssqllocaldb;Database=ModularMonolith;Trusted_Connection=True;"\n  }\n  ```\n\n- Set the Startup Item in your IDE to the API Project, not IIS Express\n- Once it is running you\'ll need a token to make API calls. This is done via OAuth2 [Resource Owner Password Grant Type](https://www.oauth.com/oauth2-servers/access-tokens/password-grant/). By default IdentityServer is configured with the following:\n  - `client_id = ro.client`\n  - `client_secret = secret` **(this is literally the value - not a statement that this value is secret!)**\n  - `scope = myMeetingsAPI openid profile`\n  - `grant_type = password`\n  \n  Include the credentials of a test user created in the [InitializeDatabase.sql](src/Database/InitializeDatabase.sql) script - for example:\n  - `username = testMember@mail.com`\n  - `password = testMemberPass`\n\n**Example HTTP Request for an Access Token:**\n```http\nPOST /connect/token HTTP/1.1\nHost: localhost:5000\n \ngrant_type=password\n&username=testMember@mail.com\n&password=testMemberPass\n&client_id=ro.client\n&client_secret=secret\n```\n\nThis will fetch an access token for this user to make authorized API requests using the HTTP request header `Authorization: Bearer <access_token>`\n\nIf you use a tool such as Postman to test your API, the token can be fetched and stored within the tool itself and appended to all API calls. Check your tool documentation for instructions.\n\n## 6. Contribution\n\nThis project is still under analysis and development. I assume its maintenance for a long time and I would appreciate your contribution to it. Please let me know by creating an Issue or Pull Request.\n\n## 7. Roadmap\n\nList of features/tasks/approaches to add:\n\n| Name                     | Priority | Status | Release date |\n| ------------------------ | -------- | -------- | -------- |\n| Domain Model Unit Tests | High     | Completed | 2019-09-10 |\n| Architecture Decision Log update | High     | Completed | 2019-11-09 |\n| API automated tests      | Normal   |    |    |\n| FrontEnd SPA application | Normal   |    |    |\n| Meeting comments feature | Low   |    |    |\n| Notifications feature | Low   |    |    |\n| Messages feature | Low   |    |    |\n| Migration to .NET Core 3.0 | Low   |    |    |\n| More advanced Payments module | Low   |    |    |\n\nNOTE: Please don\'t hesitate to suggest something else or a change to the existing code. All proposals will be considered.\n\n## 8. Author\n\nKamil Grzybek\n\nBlog: [https://kamilgrzybek.com](https://kamilgrzybek.com)\n\nTwitter: [https://twitter.com/kamgrzybek](https://twitter.com/kamgrzybek)\n\nLinkedIn: [https://www.linkedin.com/in/kamilgrzybek/](https://www.linkedin.com/in/kamilgrzybek/)\n\nGitHub: [https://github.com/kgrzybek](https://github.com/kgrzybek)\n\n## 9. License\n\nThe project is under [MIT license](https://opensource.org/licenses/MIT).\n\n## 10. Inspirations and Recommendations\n\n### Modular Monolith\n- ["Modular Monoliths"](https://www.youtube.com/watch?v=5OjqD-ow8GE) presentation, Simon Brown\n- ["Majestic Modular Monoliths"](https://www.youtube.com/watch?v=BOvxJaklcr0) presentation, Axel Fontaine\n- ["Building Better Monoliths \xe2\x80\x93 Modulithic Applications with Spring Boot"](https://speakerdeck.com/olivergierke/building-better-monoliths-modulithic-applications-with-spring-boot-cd16e6ec-d334-497d-b9f6-3f92d5db035a) slides, Oliver Drotbohm\n- ["MonolithFirst"](https://martinfowler.com/bliki/MonolithFirst.html) article, Martin Fowler\n- ["Pattern: Monolithic Architecture"](https://microservices.io/patterns/monolithic.html) pattern description, Chris Richardson\n\n### Domain-Driven Design\n- ["Domain-Driven Design: Tackling Complexity in the Heart of Software"](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) book, Eric Evans\n- ["Implementing Domain-Driven Design"](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577) book, Vaughn Vernon\n- ["Domain-Driven Design Distilled"](https://www.amazon.com/dp/0134434420) book, Vaughn Vernon\n- ["Patterns, Principles, and Practices of Domain-Driven Design"](https://www.amazon.com/Patterns-Principles-Practices-Domain-Driven-Design-ebook/dp/B00XLYUA0W) book, Scott Millett, Nick Tune\n- ["Secure By Design"](https://www.amazon.com/Secure-Design-Daniel-Deogun/dp/1617294357) book, Daniel Deogun, Dan Bergh Johnsson, Daniel Sawano\n- ["Hands-On Domain-Driven Design with .NET Core: Tackling complexity in the heart of software by putting DDD principles into practice"](https://www.amazon.com/Hands-Domain-Driven-Design-NET-ebook/dp/B07C5WSR9B) book, Alexey Zimarev\n- ["Domain Modeling Made Functional: Tackle Software Complexity with Domain-Driven Design and F#"](https://www.amazon.com/Domain-Modeling-Made-Functional-Domain-Driven-ebook/dp/B07B44BPFB) book, Scott Wlaschin\n- ["DDD by examples - library"](https://github.com/ddd-by-examples/library) GH repository, Jakub Pilimon, Bart\xc5\x82omiej S\xc5\x82ota\n- ["IDDD_Samples"](https://github.com/VaughnVernon/IDDD_Samples) GH repository, Vaughn Vernon\n- ["IDDD_Samples_NET"](https://github.com/VaughnVernon/IDDD_Samples_NET) GH repository, Vaughn Vernon\n- ["Awesome Domain-Driven Design"](https://github.com/heynickc/awesome-ddd) GH repository, Nick Chamberlain\n\n### Application Architecture\n- ["Patterns of Enterprise Application Architecture"](https://martinfowler.com/books/eaa.html) book, Martin Fowler\n- ["Dependency Injection Principles, Practices, and Patterns"](https://www.manning.com/books/dependency-injection-principles-practices-patterns) book, Steven van Deursen, Mark Seemann\n- ["Clean Architecture: A Craftsman\'s Guide to Software Structure and Design (Robert C. Martin Series"](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164) book, Robert C. Martin\n- ["The Clean Architecture"](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) article, Robert C. Martin\n- ["The Onion Architecture"](https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/) article series, Jeffrey Palermo\n- ["Hexagonal/Ports & Adapters Architecture"](https://web.archive.org/web/20180822100852/http://alistair.cockburn.us/Hexagonal+architecture) article, Alistair Cockburn\n- ["DDD, Hexagonal, Onion, Clean, CQRS, \xe2\x80\xa6 How I put it all together"](https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/) article, Herberto Graca\n\n### Software Architecture\n- ["Software Architecture in Practice (3rd Edition)"](https://www.amazon.com/Software-Architecture-Practice-3rd-Engineering/dp/0321815734) book, Len Bass, Paul Clements, Rick Kazman\n- ["Software Architecture for Developers Vol 1 & 2"](https://softwarearchitecturefordevelopers.com/) book, Simon Brown\n- ["Just Enough Software Architecture: A Risk-Driven Approach"](https://www.amazon.com/Just-Enough-Software-Architecture-Risk-Driven/dp/0984618104) book, George H. Fairbanks\n- ["Software Systems Architecture: Working With Stakeholders Using Viewpoints and Perspectives (2nd Edition)"](https://www.amazon.com/Software-Systems-Architecture-Stakeholders-Perspectives/dp/032171833X/) book, Nick Rozanski, E\xc3\xb3in Woods\n- ["Design It!: From Programmer to Software Architect (The Pragmatic Programmers)"](https://www.amazon.com/Design-Programmer-Architect-Pragmatic-Programmers/dp/1680502093) book, Michael Keeling\n\n### System Architecture\n- ["Enterprise Integration Patterns : Designing, Building, and Deploying Messaging Solutions"](https://www.enterpriseintegrationpatterns.com/) book and catalogue, Gregor Hohpe, Bobby Woolf\n- ["Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems "](https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321) book, Martin Kleppman\n- ["Building Evolutionary Architectures: Support Constant Change"](https://www.amazon.com/Building-Evolutionary-Architectures-Support-Constant/dp/1491986360) book, Neal Ford\n- ["Building Microservices: Designing Fine-Grained Systems"](https://www.amazon.com/Building-Microservices-Designing-Fine-Grained-Systems/dp/1491950358) book, Sam Newman\n\n### Design\n- ["Refactoring: Improving the Design of Existing Code"](https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672) book, Martin Fowler, Kent Beck, John Brant, William Opdyke, Don Roberts\n- ["Clean Code: A Handbook of Agile Software Craftsmanship"](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) book, Robert C. Martin\n- ["Agile Principles, Patterns, and Practices in C#"](https://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258) book, Robert C. Martin\n- ["Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development (3rd Edition)"](https://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062) book, Craig Larman\n- ["Working Effectively with Legacy Code"](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052) book, Michael Feathers \n- ["Code Complete: A Practical Handbook of Software Construction, Second Edition"](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670) book, Steve McConnell\n- ["Design Patterns: Elements of Reusable Object-Oriented Software"](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612) book, Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides\n\n### Craftsmanship\n- ["The Clean Coder: A Code of Conduct for Professional Programmers"](https://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073) book, Robert C. Martin\n- ["The Pragmatic Programmer: From Journeyman to Master"](https://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X) book, Andrew Hunt\n\n### Testing\n- ["The Art of Unit Testing: with examples in C#"](https://www.amazon.com/Art-Unit-Testing-examples/dp/1617290890) book, Roy Osherove\n- ["Unit Test Your Architecture with ArchUnit"](https://blogs.oracle.com/javamagazine/unit-test-your-architecture-with-archunit) article, Jonas Havers\n\n### UML\n- ["UML Distilled: A Brief Guide to the Standard Object Modeling Language (3rd Edition)"](https://www.amazon.com/UML-Distilled-Standard-Modeling-Language/dp/0321193687) book, Martin Fowler\n\n### Event Storming\n- ["Introducing EventStorming"](https://leanpub.com/introducing_eventstorming) book, Alberto Brandolini\n- ["Awesome EventStorming"](https://github.com/mariuszgil/awesome-eventstorming) GH repository, Mariusz Gil\n'