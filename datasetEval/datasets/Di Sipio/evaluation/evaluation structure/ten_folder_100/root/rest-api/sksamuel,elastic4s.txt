b'elastic4s - Elasticsearch Scala Client\n=========\n\n[![Build Status](https://travis-ci.org/sksamuel/elastic4s.png?branch=master)](https://travis-ci.org/sksamuel/elastic4s)\n[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12.svg?label=latest%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)\n[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.13.svg?label=latest%20release%20for%202.13"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.13%22)\n\nElastic4s is a concise, idiomatic, reactive, type safe Scala client for Elasticsearch. The official Elasticsearch Java client can of course be used in Scala, but due to Java\'s syntax it is more verbose and it naturally doesn\'t support classes in the core Scala core library nor Scala idioms such as typeclass support.\n\nElastic4s\'s DSL allows you to construct your requests programatically, with syntactic and semantic errors manifested at compile time, and uses standard Scala futures to enable you to easily integrate into an asynchronous workflow. The aim of the DSL is that requests are written in a builder-like way, while staying broadly similar to the Java API or Rest API. Each request is an immutable object, so you can create requests and safely reuse them, or further copy them for derived requests. Because each request is strongly typed your IDE or editor can use the type information to show you what operations are available for any request type.\n\nElastic4s supports Scala collections so you don\'t have to do tedious conversions from your Scala domain classes into Java collections. It also allows you to index and read classes directly using typeclasses so you don\'t have to set fields or json documents manually. These typeclasses are generated using your favourite json library - modules exist for Jackson, Circe, Json4s, PlayJson and Spray Json. The client also uses standard Scala durations to avoid the use of strings or primitives for duration lengths.\n\n#### Key points\n\n* Type safe concise DSL\n* Integrates with standard Scala futures or other effects libraries\n* Uses Scala collections library over Java collections\n* Returns `Option` where the java methods would return null\n* Uses Scala `Duration`s instead of strings/longs for time values\n* Supports typeclasses for indexing, updating, and search backed by Jackson, Circe, Json4s, PlayJson and Spray Json implementations\n* Provides [reactive-streams](#elastic-reactive-streams) implementation\n* Provides a testkit subproject ideal for your tests\n\n### Release\n\nCurrent Elastic4s versions support Scala 2.12 and 2.13. Scala 2.10 support has been dropped starting with 5.0.x and Scala 2.11 has been dropped starting with 7.2.0. For releases that are compatible with earlier versions of Elasticsearch,\n[search maven central](http://search.maven.org/#search|ga|1|g%3A%22com.sksamuel.elastic4s%22).\n\n| Elastic Version | Scala 2.11 | Scala 2.12 | Scala 2.13 |\n|-----------------|------------|------------|------------|\n|7.3.x||[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/7.3.svg?label=latest%207.3%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.13/7.3.svg?label=latest%207.3%20release%20for%202.13"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.13%22)|\n|7.2.x||[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/7.2.svg?label=latest%207.2%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.13/7.2.svg?label=latest%207.2%20release%20for%202.13"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.13%22)|\n|7.1.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/7.1.svg?label=latest%207.1%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/7.1.svg?label=latest%207.1%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.13/7.1.svg?label=latest%207.1%20release%20for%202.13"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.13%22)|\n|7.0.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/7.0.svg?label=latest%207.0%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/7.0.svg?label=latest%207.0%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.13/7.0.svg?label=latest%207.0%20release%20for%202.13"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.13%22)|\n|6.7.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/6.7.svg?label=latest%206.7%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/6.7.svg?label=latest%206.7%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.13/6.7.svg?label=latest%206.7%20release%20for%202.13"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.13%22)|\n|6.6.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/6.6.svg?label=latest%206.6%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/6.6.svg?label=latest%206.6%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|6.5.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/6.5.svg?label=latest%206.5%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/6.5.svg?label=latest%206.5%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|6.4.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/6.4.svg?label=latest%206.4%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/6.4.svg?label=latest%206.4%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|6.3.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/6.3.svg?label=latest%206.3%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/6.3.svg?label=latest%206.3%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|6.2.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/6.2.svg?label=latest%206.2%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/6.2.svg?label=latest%206.2%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|6.1.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/6.1.svg?label=latest%206.1%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/6.1.svg?label=latest%206.1%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|6.0.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/6.0.svg?label=latest%206.0%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/6.0.svg?label=latest%206.0%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|5.6.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/5.6.svg?label=latest%205.6%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/5.6.svg?label=latest%205.6%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|5.5.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/5.5.svg?label=latest%205.5%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/5.5.svg?label=latest%205.5%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|5.4.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/5.4.svg?label=latest%205.4%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/5.4.svg?label=latest%205.4%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|5.3.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/5.3.svg?label=latest%205.3%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/5.3.svg?label=latest%205.3%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|5.2.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/5.2.svg?label=latest%205.2%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/5.2.svg?label=latest%205.2%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|5.1.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/5.1.svg?label=latest%205.1%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/5.1.svg?label=latest%205.1%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n|5.0.x|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.11/5.0.svg?label=latest%205.0%20release%20for%202.11"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.11%22)|[<img src="https://img.shields.io/maven-central/v/com.sksamuel.elastic4s/elastic4s-core_2.12/5.0.svg?label=latest%205.0%20release%20for%202.12"/>](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elastic4s-core_2.12%22)||\n\nFor release prior to 5.0 search maven central.\n\n## Quick Start\n\nWe have created sample projects in both sbt, maven and gradle. Check them out here:\nhttps://github.com/sksamuel/elastic4s/tree/master/samples\n\nTo get started you will need to add a dependency:\n\n* [elastic4s-client-esjava](https://mvnrepository.com/artifact/com.sksamuel.elastic4s/a:elastic4s-client-esjava)\n\nThe basic usage is that you create an instance of a client and then invoke the `execute` method with the requests you\nwant to perform. The execute method is asynchronous and will return a standard Scala `Future[T]`\n(or use one of the [Alternative executors](#alternative-executors)) where T is the response\ntype appropriate for your request type. For example a _search_ request will return a response of type `SearchResponse`\nwhich contains the results of the search.\n\nTo create an instance of the HTTP client, use the `ElasticClient` companion object methods.\nRequests are created using the elastic4s DSL. For example to create a search request, you would do:\n\n```scala\nsearch("index" / "type").query("findthistext")\n```\n\nThe DSL methods are located in the `ElasticDsl` trait which needs to be imported or extended. \n\n### Alternative Executors\nThe default `Executor` uses scala `Future`s to execute requests, but there are alternate Executors that can be used by\nadding appropriate imports. The imports will create an implicit `Executor[F]` and a `Functor[F]`,\nwhere `F` is some effect type.\n\n#### Cats-Effect IO\n`import com.sksamuel.elastic4s.cats.effect.instances._` will provide implicit instances for `cats.effect.IO`\n\n#### Monix Task\n`import com.sksamuel.elastic4s.monix.instances._` will provide implicit instances for `monix.eval.Task`\n\n#### Scalaz Task\n`import com.sksamuel.elastic4s.scalaz.instances._` will provide implicit instances for `scalaz.concurrent.Task` \n\n#### ZIO Task\n`import com.sksamuel.elastic4s.zio.instances._` will provide implicit instances for `zio.Task` \n\n### Example SBT Setup\n\n```scala\n// major.minor are in sync with the elasticsearch releases\nval elastic4sVersion = "x.x.x"\nlibraryDependencies ++= Seq(\n  "com.sksamuel.elastic4s" %% "elastic4s-core" % elastic4sVersion,\n\n  // for the default http client\n  "com.sksamuel.elastic4s" %% "elastic4s-client-esjava" % elastic4sVersion,\n\n  // if you want to use reactive streams\n  "com.sksamuel.elastic4s" %% "elastic4s-http-streams" % elastic4sVersion,\n\n  // testing\n  "com.sksamuel.elastic4s" %% "elastic4s-testkit" % elastic4sVersion % "test"\n)\n```\n\n### Example Application\n\nAn example is worth 1000 characters so here is a quick example of how to connect to a node with a client, create an\nindex and index a one field document. Then we will search for that document using a simple text query.\n\n```scala\nimport com.sksamuel.elastic4s.RefreshPolicy\nimport com.sksamuel.elastic4s.embedded.LocalNode\nimport com.sksamuel.elastic4s.http.search.SearchResponse\nimport com.sksamuel.elastic4s.http.{RequestFailure, RequestSuccess}\n\nobject ArtistIndex extends App {\n\n  // spawn an embedded node for testing\n  val localNode = LocalNode("mycluster", "/tmp/datapath")\n\n  // in this example we create a client attached to the embedded node, but\n  // in a real application you would provide the HTTP address to the ElasticClient constructor.\n  val client = localNode.client(shutdownNodeOnClose = true)\n\n  // we must import the dsl\n  import com.sksamuel.elastic4s.http.ElasticDsl._\n\n  // Next we create an index in advance ready to receive documents.\n  // await is a helper method to make this operation synchronous instead of async\n  // You would normally avoid doing this in a real program as it will block\n  // the calling thread but is useful when testing\n  client.execute {\n    createIndex("artists").mappings(\n      mapping("modern").fields(\n        textField("name")\n      )\n    )\n  }.await\n\n  // Next we index a single document which is just the name of an Artist.\n  // The RefreshPolicy.Immediate means that we want this document to flush to the disk immediately.\n  // see the section on Eventual Consistency.\n  client.execute {\n    indexInto("artists" / "modern").fields("name" -> "L.S. Lowry").refresh(RefreshPolicy.Immediate)\n  }.await\n\n  // now we can search for the document we just indexed\n  val resp = client.execute {\n    search("artists") query "lowry"\n  }.await\n\n  // resp is a Response[+U] ADT consisting of either a RequestFailure containing the\n  // Elasticsearch error details, or a RequestSuccess[U] that depends on the type of request.\n  // In this case it is a RequestSuccess[SearchResponse]\n\n  println("---- Search Results ----")\n  resp match {\n    case failure: RequestFailure => println("We failed " + failure.error)\n    case results: RequestSuccess[SearchResponse] => println(results.result.hits.hits.toList)\n    case results: RequestSuccess[_] => println(results.result)\n  }\n\n  // Response also supports familiar combinators like map / flatMap / foreach:\n  resp foreach (search => println(s"There were ${search.totalHits} total hits"))\n\n  client.close()\n}\n```\n\n## Near Real-time search results\n\nWhen you index a document in Elasticsearch, it is not normally immediately available to be searched, as a refresh has to happen to make it available for the search API. By default a refresh occurs every second but this can be increased if needed. Note that this impacts only the visibility of newly indexed documents when using the search API and has nothing \nto do with data consistency and durability.\nAnother option, which you saw in the quick start guide, was to set the refresh policy to `IMMEDIATE` which will force a refresh straight after the index operation.\nYou shouldn\'t use IMMEDIATE for heavy loads as you\'ll cause contention with Elasticsearch refreshing too often. It is also possible to use `WAIT_UNTIL` so that no refresh is forced, but the index request will return only after the new document is available for search.\n\nFor more in depth examples keep reading.\n\n## Syntax\n\nHere is a list of the common requests and the syntax used to create them and whether they are supported by the TCP or HTTP client. If the HTTP client does not support them, you will need to fall back to the TCP, or use the Java client and build the JSON yourself. Or even better, raise a PR with the addition. For more details on each request click\nthrough to the readme page. For options that are not yet documented, refer to the Elasticsearch documentation asthe DSL closely mirrors the standard Java API / REST API.\n\n| Operation                                 | Syntax | HTTP | TCP |\n|-------------------------------------------|--------|------|-----|\n| [Add Alias]                               | `addAlias(alias, index)`                  | yes | yes |\n| [Bulk]                                    | `bulk(query1, query2, query3...)`         | yes | yes |\n| Cancel Tasks                              | `cancelTasks(<nodeIds>)`                  | yes | yes |\n| Cat Aliases                               | `catAliases()`                            | yes | |\n| Cat Allocation                            | `catAllocation()`                         | yes | |\n| Cat Counts                                | `catCount()` or `catCount(<indexes>`      | yes | |\n| Cat Indices                               | `catIndices()`                            | yes | |\n| Cat Master                                | `catMaster()`                             | yes | |\n| Cat Nodes                                 | `catNodes()`                              | yes | |\n| Cat Plugins                               | `catPlugins()`                            | yes | |\n| Cat Segments                              | `catSegments(indices)`                    | yes | |\n| Cat Shards                                | `catShards()`                             | yes | |\n| Cat Thread Pools                          | `catThreadPool()`                         | yes | |\n| Clear index cache                         | `clearCache(<index>)`                     | yes | yes |\n| Close index                               | `closeIndex(<name>)`                      | yes | yes |\n| Cluster health                            | `clusterHealth()`                         | yes | yes |\n| Cluster stats                             | `clusterStats()`                          | yes | yes |\n| [Create Index]                            | `createIndex(<name>).mappings( mapping(<name>).as( ... fields ... ) )`| yes  | yes |\n| [Create Repository]                       | `createRepository(name, type)`            | yes | yes |\n| [Create Snapshot]                         | `createSnapshot(name, repo)`              | yes | yes |\n| Create Template                           | `createTemplate(<name>).pattern(<pattern>).mappings {...}`| yes | yes |\n| [Delete by id]                            | `deleteById(index, type, id)`             | yes | yes |\n| Delete by query                           | `deleteByQuery(index, type, query)`       | yes | yes |\n| [Delete index]                            | `deleteIndex(index) [settings]`           | yes | yes |\n| [Delete Snapshot]                         | `deleteSnapshot(name, repo)`              | yes | yes |\n| Delete Template                           | `deleteTemplate(<name>)`                  | yes | yes |\n| Document Exists                           | `exists(id, index, type)`                 | yes | |\n| [Explain]                                 | `explain(<index>, <type>, <id>)`          | yes | yes |\n| Field stats                               | `fieldStats(<indexes>)`                   |     | yes |\n| Flush Index                               | `flushIndex(<index>)`                     | yes | yes |\n| [Force Merge]                             | `forceMerge(<indexes>)`                   | yes | yes |\n| [Get]                                     | `get(index, type, id)`                    | yes | yes |\n| Get All Aliases                           | `getAliases()`                            | yes | yes |\n| Get Alias                                 | `getAlias(<name>).on(<index>)`            | yes | yes |\n| Get Mapping                               | `getMapping(<index> / <type>)`            | yes | yes |\n| Get Segments                              | `getSegments(<indexes>)`                  | yes | yes |\n| Get Snapshot                              | `getSnapshot(name, repo)`                 | yes | yes |\n| Get Template                              | `getTemplate(<name>)`                     | yes | yes |\n| [Index]                                   | `indexInto(<index> / <type>).doc(<doc>)`  | yes | yes |\n| Index exists                              | `indexExists(<name>)`                     | yes | yes |\n| Index stats                               | `indexStats(indices)`                     | yes | |\n| List Tasks                                | `listTasks(nodeIds)`                      | yes | yes |\n| Lock Acquire                              | `acquireGlobalLock()`                     | yes | |\n| Lock Release                              | `releaseGlobalLock()`                     | yes | |\n| [Multiget]                                | `multiget( get(1).from(<index> / <type>), get(2).from(<index> / <type>) )` |  yes | yes |\n| [Multisearch]                             | `multi( search(...), search(...) )`       | yes | yes |\n| Node Info                                 | `nodeInfo(<optional node list>`           | yes | |\n| Node Stats                                | `nodeStats(<optional node list>).stats(<stats>`| yes | |\n| Open index                                | `openIndex(<name>)`                       | yes | yes |\n| Put mapping                               | `putMapping(<index> / <type>) as { mappings block }` | yes | yes |\n| Recover Index                             | `recoverIndex(<name>)`                    | yes | yes |\n| Refresh index                             | `refreshIndex(<name>)`                    | yes | yes |\n| Register Query                            | `register(<query>).into(<index> / <type>, <field>)` |   | yes |\n| [Remove Alias]                            | `removeAlias(<alias>).on(<index>)`        | yes | yes |\n| [Restore Snapshot]                        | `restoreSnapshot(name, repo)`             | yes | yes |\n| Rollover                                  | `rolloverIndex(alias)`                    | yes | |\n| [Search]                                  | `search(index).query(<query>)`            | yes | yes |\n| Search scroll                             | `searchScroll(<scrollId>)`                | yes | yes |\n| Shrink Index                              | `shrinkIndex(source, target)`             | yes | |\n| Term Vectors                              | `termVectors(<index>, <type>, <id>)`      | yes | yes |\n| Type Exists                               | `typesExists(<types>) in <index>`         | yes | yes |\n| [Update By Id]                            | `updateById(index, type, id)`             | yes | yes |\n| Update by query                           | `updateByQuery(index, type, query)`       | yes | yes |\n| [Validate]                                | `validateIn(<index/type>).query(<query>)` | yes | yes |\n\nPlease also note [some java interoperability notes](https://sksamuel.github.io/elastic4s/docs/misc/javainterop.html).\n\n\n## Connecting to a Cluster\n\nTo connect to a stand alone elasticsearch cluster we use the methods on the HttpClient or TcpClient companion objects.\nFor example, `TcpClient.transport` or `HttpClient.apply`. These methods accept an instance of `ElasticsearchClientUri`\nwhich specifies the host, port and cluster name of the cluster. The cluster name does not need to be specified if it is the\ndefault, which is "elasticsearch" but if you changed it you must specify it in the uri.\n\nPlease note that the TCP interface uses port 9300 and HTTP uses 9200 (unless of course you have changed these in your cluster).\n\nHere is an example of connecting to a TCP cluster with the standard settings.\n\n```scala\nval client = TcpClient.transport(ElasticsearchClientUri("host1", 9300))\n```\n\nFor multiple nodes it\'s better to use the elasticsearch client uri connection string.\nThis is in the format `"elasticsearch://host1:port2,host2:port2,...?param=value&param2=value2"`. For example:\n\n```scala\nval uri = ElasticsearchClientUri("elasticsearch://foo:1234,boo:9876?cluster.name=mycluster")\nval client = TcpClient.transport(uri)\n```\n\nIf you need to pass settings to the client, then you need to invoke `transport` with a settings object.\nFor example to specify the cluster name (if you changed the default then you must specify the cluster name).\n\n```scala\nimport org.elasticsearch.common.settings.Settings\nval settings = Settings.builder().put("cluster.name", "myClusterName").build()\nval client = TcpClient.transport(settings, ElasticsearchClientUri("elasticsearch://somehost:9300"))\n```\n\nIf you already have a handle to a Node in the Java API then you can create a client from it easily:\n```scala\nval node = ... // node from the java API somewhere\nval client = TcpClient.fromNode(node)\n```\n\nHere is an example of connecting to a HTTP cluster.\n\n```scala\nval client = HttpClient(ElasticsearchClientUri("localhost", 9200))\n```\n\nThe http client internally uses the Apache Http Client, which we can customize by passing in two callbacks.\n\n```scala\nval client = HttpClient(ElasticsearchClientUri("localhost", 9200), new RequestConfigCallback {\n    override def customizeRequestConfig(requestConfigBuilder: Builder) = ...\n    }\n  }, new HttpClientConfigCallback {\n    override def customizeHttpClient(httpClientBuilder: HttpAsyncClientBuilder) = ...\n  })\n```\n\n## Create Index\n\nAll documents in Elasticsearch are stored in an index. We do not need to tell Elasticsearch in advance what an index\nwill look like (eg what fields it will contain) as Elasticsearch will adapt the index dynamically as more documents are added, but we must at least create the index first.\n\nTo create an index called "places" that is fully dynamic we can simply use:\n\n```scala\nclient.execute { createIndex("places") }\n```\n\nWe can optionally set the number of shards and / or replicas\n\n```scala\nclient.execute { createIndex("places") shards 3 replicas 2 }\n```\n\nSometimes we want to specify the properties of the fields in the index in advance.\nThis allows us to manually set the type of the field (where Elasticsearch might infer something else) or set the analyzer used,\nor multiple other options\n\nTo do this we add mappings:\n\n```scala\nimport com.sksamuel.elastic4s.mappings.FieldType._\nimport com.sksamuel.elastic4s.analyzers.StopAnalyzer\n\nclient.execute {\n  createIndex("places") mappings (\n    mapping("cities") as (\n      keywordField("id"),\n      textField("name") boost 4,\n      textField("content") analyzer StopAnalyzer\n    )\n  )\n}\n```\n\nThen Elasticsearch is configured with those mappings for those fields only.\nIt is still fully dynamic and other fields will be created as needed with default options. Only the fields specified will have their type preset.\n\nMore examples on the create index syntax can be [found here](https://sksamuel.github.io/elastic4s/docs/indices/createindex.html).\n\n## Analyzers\n\nAnalyzers control how Elasticsearch parses the fields for indexing. For example, you might decide that you want\nwhitespace to be important, so that "band of brothers" is indexed as a single "word" rather than the default which is\nto split on whitespace. There are many advanced options available in analayzers. Elasticsearch also allows us to create\ncustom analyzers. For more details [read about the DSL support for analyzers](https://sksamuel.github.io/elastic4s/docs/misc/analyzers.html).\n\n## Indexing\n\nTo index a document we need to specify the index and type and optionally we can set an id.\nIf we don\'t include an id then elasticsearch will generate one for us.\nWe must also include at least one field. Fields are specified as standard tuples.\n\n```scala\nclient.execute {\n  indexInto("places" / "cities") id "uk" fields (\n    "name" -> "London",\n    "country" -> "United Kingdom",\n    "continent" -> "Europe",\n    "status" -> "Awesome"\n  )\n}\n```\n\nThere are many additional options we can set such as routing, version, parent, timestamp and op type.\nSee [official documentation](http://www.elasticsearch.org/guide/reference/api/index_/) for additional options, all of\nwhich exist in the DSL as keywords that reflect their name in the official API.\n\n## Indexing Typeclass\n\nSometimes it is useful to index directly from your domain model, and not have to create maps of fields inline. For this\nelastic4s provides the `Indexable` typeclass. Simply provide an implicit instance of `Indexable[T]` in scope for any\nclass T that you wish to index, and then you can use `doc(t)` on the index request. For example:\n\n```scala\n// a simple example of a domain model\ncase class Character(name: String, location: String)\n\n// how you turn the type into json is up to you\nimplicit object CharacterIndexable extends Indexable[Character] {\n  override def json(t: Character): String = s""" { "name" : "${t.name}", "location" : "${t.location}" } """\n}\n\n// now the index request reads much cleaner\nval jonsnow = Character("jon snow", "the wall")\nclient.execute {\n  indexInto("gameofthrones" / "characters").doc(jonsnow)\n}\n```\n\nSome people prefer to write typeclasses manually for the types they need to support. Other people like to just have\nit done automagically. For those people, elastic4s provides extensions for the well known Scala Json libraries that\ncan be used to generate Json generically.\n\nSimply add the import for your chosen library below and then with those implicits in scope, you can now pass any type\n you like to `doc` and an Indexable will be derived automatically.\n\n| Library | Elastic4s Module | Import |\n|---------|------------------|--------|\n|[Jackson](https://github.com/FasterXML/jackson-module-scala)|[elastic4s-json-jackson](http://search.maven.org/#search%7Cga%7C1%7Celastic4s-json-jackson)|import ElasticJackson.Implicits._|\n|[Json4s](http://json4s.org/)|[elastic4s-json-json4s](http://search.maven.org/#search%7Cga%7C1%7Celastic4s-json-json4s)|import ElasticJson4s.Implicits._|\n|[Circe](https://github.com/travisbrown/circe)|[elastic4-json-circe](http://search.maven.org/#search%7Cga%7C1%7Celastic4s-json-circe)|import io.circe.generic.auto._ <br/>import com.sksamuel.elastic4s.circe._|\n|[PlayJson](https://github.com/playframework/play-json)|[elastic4s-json-play](http://search.maven.org/#search%7Cga%7C1%7Celastic4s-json-play)|import com.sksamuel.elastic4s.playjson._|\n|[Spray Json](https://github.com/spray/spray-json)|[elastic4s-json-spray](http://search.maven.org/#search%7Cga%7C1%7Celastic4s-json-spray)|import com.sksamuel.elastic4s.sprayjson._|\n\n## Searching\n\nSearching is naturally the most involved operation.\nThere are many ways to do [searching in Elasticsearch](http://www.elasticsearch.org/guide/reference/api/search/) and that is reflected\nin the higher complexity of the query DSL.\n\nTo do a simple text search, where the query is parsed from a single string\n```scala\nsearch("places" / "cities").query("London")\n```\n\nThat is actually an example of a SimpleStringQueryDefinition. The string is implicitly converted to that type of query.\nIt is the same as specifying the query type directly:\n\n```scala\nsearch("places" / "cities").query(simpleStringQuery("London"))\n```\n\nThe simple string example is the only time we don\'t need to specify the query type.\nWe can search for everything by not specifying a query at all.\n```scala\nsearch("places" / "cities")\n```\n\nWe might want to limit the number of results and / or set the offset.\n```scala\nsearch("places" / "cities") query "paris" start 5 limit 10\n```\n\nWe can search against certain fields only:\n```scala\nsearch("places" / "cities") query termQuery("country", "France")\n```\n\nOr by a prefix:\n```scala\nsearch("places" / "cities") query prefixQuery("country", "France")\n```\n\nOr by a regular expression (slow, but handy sometimes!):\n```scala\nsearch("places" / "cities") query regexQuery("country", "France")\n```\n\nThere are many other types, such as range for numeric fields, wildcards, distance, geo shapes, matching.\n\nRead more about search syntax: [Search]\nRead about [Multisearch].\nRead about [Suggestions].\n\n## HitReader Typeclass\n\nBy default Elasticsearch search responses contain an array of `SearchHit` instances which contain things like the id,\nindex, type, version, etc as well as the document source as a string or map. Elastic4s provides a means to convert these\nback to meaningful domain types quite easily using the `HitReader[T]` typeclass.\n\nProvide an implementation of this typeclass, as an in scope implicit, for whatever type you wish to marshall search responses into, and then you can call `to[T]` or `safeTo[T]` on the response.\nThe difference between to and safeTo is that to will drop any errors and just return successful conversions, whereas safeTo returns\na sequence of `Either[Throwable, T]`.\n\nA full example:\n\n```scala\ncase class Character(name: String, location: String)\n\nimplicit object CharacterHitReader extends HitReader[Character] {\n  override def read(hit: Hit): Either[Throwable, Character] = {\n    Right(Character(hit.sourceAsMap("name").toString, hit.sourceAsMap("location").toString))\n  }\n}\n\nval resp = client.execute {\n  search("gameofthrones" / "characters").query("kings landing")\n}.await // don\'t block in real code\n\n// .to[Character] will look for an implicit HitReader[Character] in scope\n// and then convert all the hits into Characters for us.\nval characters: Seq[Character] = resp.to[Character]\n```\n\nThis is basically the inverse of the `Indexable` typeclass. And just like Indexable, the json modules provide implementations\nout of the box for any types. The imports are the same as for the Indexable typeclasses.\n\nAs a bonus feature of the Jackson implementation, if your domain object has fields called `_timestamp`, `_id`, `_type`, `_index`, or\n`_version` then those special fields will be automatically populated as well.\n\n## Highlighting\n\nElasticsearch can annotate results to show which part of the results matched the queries by using highlighting.\nJust think when you\'re in google and you see the snippets underneath your results - that\'s what highlighting does.\n\nWe can use this very easily, just add a highlighting definition to your search request, where you set the field or fields to be highlighted. Viz:\n\n```scala\nsearch in "music" / "bios" query "kate bush" highlighting (\n  highlight field "body" fragmentSize 20\n)\n```\n\nAll very straightforward. There are many options you can use to tweak the results. In the example above I have\nsimply set the snippets to be taken from the field called "body" and to have max length 20. You can set the number of fragments to return, seperate queries to generate them and other things. See the elasticsearch page on [highlighting](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-highlighting.html) for more info.\n\n## Get\n\nSometimes we don\'t want to search and want to retrieve a document directly from the index by id.\nIn this example we are retrieving the document with id \'coldplay\' from the bands/rock index and type.\n\n```scala\nclient.execute {\n get("coldplay").from("bands" / "rock")\n}\n```\n\nWe can get multiple documents at once too. Notice the following multiget wrapping block.\n\n```scala\nclient.execute {\n  multiget(\n    get("coldplay").from("bands" / "rock"),\n    get("keane").from("bands" / "rock")\n  )\n}\n```\n\nSee more [get examples] and usage of [Multiget] here.\n\n## Deleting\n\nIn the rare case that we become tired of a band we might want to remove them. Naturally we wouldn\'t want to remove Chris Martin and boys so we\'re going to remove U2 instead.\nWe think they\'re a little past their best (controversial). This operation assumes the id of the document is "u2".\n\n```scala\nclient.execute {\n  delete("u2").from("bands/rock")\n}\n```\n\nWe can take this a step further by deleting by a query rather than id.\nIn this example we\'re deleting all bands where their type is pop.\n\n```scala\nclient.execute {\n  deleteIn("bands").by(termQuery("type", "pop"))\n}\n```\n\nSee more about delete on the [delete page]\n\n## Updates\n\nWe can update existing documents without having to do a full index, by updating a partial set of fields.\n\n```scala\nclient.execute {\n  update("25").in("scifi" / "starwars").docAsUpsert (\n    "character" -> "chewie",\n    "race" -> "wookie"\n  )\n}\n```\n\nFor more examples see the [Update] page.\n\n## More like this\n\nIf you want to return documents that are "similar" to  a current document we can do that very easily with the more like this query.\n\n```scala\nclient.execute {\n  search("drinks" / "beer") query {\n    moreLikeThisQuery("name").likeTexts("coors", "beer", "molson") minTermFreq 1 minDocFreq 1\n  }\n}\n```\n\nFor all the options see [here](http://www.elasticsearch.org/guide/reference/query-dsl/mlt-query/).\n\n## Bulk Operations\n\nElasticsearch is fast. Roundtrips are not. Sometimes we want to wrestle every last inch of performance and a useful way\nto do this is to batch up requests. Elastic has guessed our wishes and created the bulk API. To do this we simply\nwrap index, delete and update requests using the `bulk` keyword and pass to the `execute` method in the client.\n\n```scala\nclient.execute {\n  bulk (\n    indexInto("bands" / "rock") fields "name"->"coldplay",\n    indexInto("bands" / "rock") fields "name"->"kings of leon",\n    indexInto("bands" / "pop") fields (\n      "name" -> "elton john",\n      "best_album" -> "tumbleweed connection"\n    )\n  )\n}\n```\nA single HTTP or TCP request is now needed for 4 operations. In addition Elasticsearch can now optimize the requests,\nby combinging inserts or using aggressive caching.\n\nThe example above uses simple documents just for clarity of reading; the usual optional settings can still be used.\nSee more information on the [Bulk].\n\n## Json Output\n\nIt can be useful to see the json output of requests in case you wish to tinker with the request in a REST client or your browser. It can be much easier to tweak a complicated query when you have the instant feedback of the HTTP interface.\n\nElastic4s makes it easy to get this json where possible. Simply invoke the `show` method on the client with a request to get back a json string. Eg:\n\n```scala\nval json = client.show {\n  search("music" / "bands") query "coldplay"\n}\nprintln(json)\n```\n\nNot all requests have a json body. For example _get-by-id_ is modelled purely by http query parameters, there is no json body to output. And some requests aren\'t supported by the show method - you will get an implicit not found error during compliation if that is the case\n\nAlso, as a reminder, the TCP client does not send JSON to the nodes, it uses a binary protocol, so the provided JSON should be used as a debugging tool only. For the HTTP client the output is exactly what is sent.\n\n## Synchronous Operations\n\nAll operations are normally asynchronous. Sometimes though you might want to block - for example when doing snapshots or when creating the initial index. You can call `.await` on any operation to block until the result is ready. This is especially useful when testing.\n\n```scala\nval resp = client.execute {\n  index("bands" / "rock") fields ("name"->"coldplay", "debut"->"parachutes")\n}.await\n```\n\n## Search Iterator\n\nSometimes you may wish to iterate over all the results in a search, without worrying too much about handling futures, and re-requesting\nvia a scroll. The `SearchIterator` will do this for you, although it will block between requests. A search iterator is just an implementation\nof `scala.collection.Iterator` backed by elasticsearch queries.\n\nTo create one, use the iterate method on the companion object, passing in the http client, and a search request to execute. The\nsearch request must specify a keep alive value (which is used by elasticsearch for scrolling).\n\n```scala\nimplicit val reader : HitReader[MyType] =  ...\nval iterator = SearchIterator.iterate[MyType](client, search(index).matchAllQuery.keepAlive("1m").size(50))\niterator.foreach(println)\n```\n\nFor instance, in the above we are bringing back all documents in the index, 50 results at a time, marshalled into\ninstances of `MyType` using the implicit `HitReader` (see the section on HitReaders). If you want just the raw\nelasticsearch `Hit` object, then use `SearchIterator.hits`\n\nNote: Whenever the results in a particular\nbatch have been iterated on, the `SearchIterator` will then execute another query for the next batch and block waiting on that query.\nSo if you are looking for a pure non blocking solution, consider the reactive streams implementation. However, if you just want a\nquick and simple way to iterate over some data without bringing back all the results at once `SearchIterator` is perfect.\n\n## DSL Completeness\n\nAs it stands the Scala DSL covers all of the common operations - index, create, delete, delete by query, search, validate, percolate, update, explain, get, and bulk operations.\nThere is good support for the various settings for each of these - more so than the Java client provides in the sense that more settings are provided in a type safe manner.\n\nHowever there are settings and operations (mostly admin / cluster related) that the DSL does not yet cover (pull requests welcome!).\nIn these cases it is necessary to drop back to the Java API.\nThis can be done by calling .java on the client object to get the underlying java elastic client,\n\n```scala\nclient.java.admin.cluster.prepareHealth.setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet\n```\n\nThis way you can still access everything the normal Java client covers in the cases\nwhere the Scala DSL is missing a construct, or where there is no need to provide a DSL.\n\n## Elastic Reactive Streams\n\nElastic4s has an implementation of the [reactive streams](http://www.reactive-streams.org) api for both publishing and subscribing that is built\nusing Akka. To use this, you need to add a dependency on the elastic4s-streams module.\n\nThere are two things you can do with the reactive streams implementation. You can create an elastic subscriber, and have that\nstream data from some publisher into elasticsearch. Or you can create an elastic publisher and have documents streamed out to subscribers.\n\n### Integrate\n\nFirst you have to add an additional dependency to your `build.sbt`\n\n```scala\nlibraryDependencies += "com.sksamuel.elastic4s" %% "elastic4s-streams" % "x.x.x"\n```\n\nor\n\n```scala\nlibraryDependencies += "com.sksamuel.elastic4s" %% "elastic4s-http-streams" % "x.x.x"\n```\n\nImport the new API with\n\n```scala\nimport com.sksamuel.elastic4s.streams.ReactiveElastic._\n```\n\n### Publisher\n\nAn elastic publisher can be created for any arbitrary query you wish, and then using the efficient search scroll API, the entire dataset that matches your query is streamed out to subscribers.\n\nAnd make sure you have an Akka Actor System in implicit scope\n\n`implicit val system = ActorSystem()`\n\nThen create a publisher from the client using any query you want. You must specify the scroll parameter, as the publisher\nuses the scroll API.\n\n`val publisher = client.publisher(search in "myindex" query "sometext" scroll "1m")`\n\nNow you can add subscribers to this publisher. They can of course be any type that adheres to the reactive-streams api,\nso you could stream out to a mongo database, or a filesystem, or whatever custom type you want.\n\n`publisher.subscribe(someSubscriber)`\n\nIf you just want to stream out an entire index then you can use the overloaded form:\n\n`val publisher = client.publisher("index1", keepAlive = "1m")`\n\n### Subscription\n\nAn elastic subcriber can be created that will stream a request to elasticsearch for each item produced by a publisher.\nThe subscriber can create index, update, or delete requests, so is a good way to synchronize datasets.\n\n`import ReactiveElastic._`\n\nAnd make sure you have an Akka Actor System in implicit scope.\n\n`implicit val system = ActorSystem()`\n\nThen create a subscriber, specifying the following parameters:\n\n* A type parameter that is the type of object that the publisher will provide\n* How many documents should be included per index batch (10-100 is usually good)\n* How many concurrent batches should be in flight (usually around the number of cores)\n* An optional `ResponseListener` that will be notified for each item that was successfully acknowledged by the es cluster\n* An optional function that will be called once the subscriber has received all data. Defaults to a no-op\n* An optional function to call if the subscriber encouters an error. Defaults to a no-op.\n\nIn addition there should be a further implicit in scope of type `RequestBuilder[T]` that will accept objects of T (the type produced by your publisher) and build an index, update, or delete request suitable for dispatchin to elasticsearch.\n\n```scala\nimplicit val builder = new RequestBuilder[SomeType] {\n  import ElasticDsl._\n  // the request returned doesn\'t have to be an index - it can be anything supported by the bulk api\n  def request(t: T): BulkCompatibleRequest =  index into "index" / "type" fields ....\n}\n```\nThen the subscriber can be created, and attached to a publisher:\n\n```scala\nval subscriber = client.subscriber[SomeType](batchSize, concurrentBatches, () => println "all done")\npublisher.subscribe(subscriber)\n```\n\n## Using Elastic4s in your project\n\nFor gradle users, add (replace 2.12 with 2.11 for Scala 2.11):\n\n```groovy\ncompile \'com.sksamuel.elastic4s:elastic4s-core_2.12:x.x.x\'\n```\n\nFor SBT users simply add:\n\n```scala\nlibraryDependencies += "com.sksamuel.elastic4s" %% "elastic4s-core" % "x.x.x"\n```\n\nFor Maven users simply add (replace 2.12 with 2.11 for Scala 2.11):\n\n```xml\n<dependency>\n    <groupId>com.sksamuel.elastic4s</groupId>\n    <artifactId>elastic4s-core_2.12</artifactId>\n    <version>x.x.x</version>\n</dependency>\n```\n\nCheck for the latest released versions on [maven central](http://search.maven.org/#search|ga|1|g%3A%22com.sksamuel.elastic4s%22)\n\n## Building and Testing\n\nThis project is built with SBT. So to build\n```scala\nsbt compile\n```\n\nAnd to test\n```scala\nsbt test\n```\n\nFor the tests to work you will need to run a local elastic instance on port 9200, _with security enabled_. One easy way of doing this is to use docker (via docker-compose):\n`docker-compose up`\n\n## Used By\n* Barclays Bank\n* HSBC\n* Shazaam\n* Lenses\n* Iterable\n* Graphflow\n* Hotel Urbano\n* Immobilien Scout\n* Deutsche Bank\n* Goldman Sachs\n* HMRC\n* Canal+\n* AOE\n* Starmind\n* ShopRunner\n* Soundcloud\n* Rostelecom-Solar\n\n_Raise a PR to add your company here_\n\n![youkit logo](https://www.yourkit.com/images/yklogo.png) YourKit supports open source projects with its full-featured Java Profiler.\nYourKit, LLC is the creator of <a href="https://www.yourkit.com/java/profiler/index.jsp">YourKit Java Profiler</a>\nand <a href="https://www.yourkit.com/.net/profiler/index.jsp">YourKit .NET Profiler</a>,\ninnovative and intelligent tools for profiling Java and .NET applications.\n\n## Contributions\nContributions to elastic4s are always welcome. Good ways to contribute include:\n\n* Raising bugs and feature requests\n* Fixing bugs and enhancing the DSL\n* Improving the performance of elastic4s\n* Adding to the documentation\n\n## License\n```\nThis software is licensed under the Apache 2 license, quoted below.\n\nCopyright 2013-2016 Stephen Samuel\n\nLicensed under the Apache License, Version 2.0 (the "License"); you may not\nuse this file except in compliance with the License. You may obtain a copy of\nthe License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\nLicense for the specific language governing permissions and limitations under\nthe License.\n```\n\n[Add Alias]: https://sksamuel.github.io/elastic4s/docs/indices/aliases.html\n[Bulk]: https://sksamuel.github.io/elastic4s/docs/document/bulk.html\n[Create Index]: https://sksamuel.github.io/elastic4s/docs/indices/createindex.html\n[Create Repository]: https://sksamuel.github.io/elastic4s/docs/misc/snapshot.html\n[Create Snapshot]: https://sksamuel.github.io/elastic4s/docs/misc/snapshot.html\n[Delete by id]: https://sksamuel.github.io/elastic4s/docs/document/delete.html\n[Delete index]: https://sksamuel.github.io/elastic4s/docs/document/delete.html\n[Delete index]: https://sksamuel.github.io/elastic4s/docs/document/delete.html\n[delete page]: https://sksamuel.github.io/elastic4s/docs/document/delete.html\n[Delete Snapshot]: https://sksamuel.github.io/elastic4s/docs/misc/snapshot.html\n[Explain]: https://sksamuel.github.io/elastic4s/docs/search/explain.html\n[Get]: https://sksamuel.github.io/elastic4s/docs/document/get.html\n[get examples]: https://sksamuel.github.io/elastic4s/docs/document/get.html\n[Index]: https://sksamuel.github.io/elastic4s/docs/document/index.html\n[Multiget]: https://sksamuel.github.io/elastic4s/docs/document/multiget.html\n[Multisearch]: https://sksamuel.github.io/elastic4s/docs/search/multisearch.html\n[Force Merge]: https://sksamuel.github.io/elastic4s/docs/indices/optimize.html\n[Remove Alias]: https://sksamuel.github.io/elastic4s/docs/indices/aliases.html\n[Restore Snapshot]: https://sksamuel.github.io/elastic4s/docs/misc/snapshot.html\n[Search]: https://sksamuel.github.io/elastic4s/docs/search/search.html\n[Suggestions]: https://sksamuel.github.io/elastic4s/docs/search/suggestions.html\n[Update]: https://sksamuel.github.io/elastic4s/docs/document/update.html\n[Validate]: https://sksamuel.github.io/elastic4s/docs/search/validate.html\n'