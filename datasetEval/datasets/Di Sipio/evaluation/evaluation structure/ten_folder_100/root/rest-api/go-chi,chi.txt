b'<p align="center">\n<a href="https://codefund.io/properties/450/visit-sponsor">\n<img src="https://codefund.io/properties/450/sponsor" />\n</a>\n</p>\n\n\n# <img alt="chi" src="https://cdn.rawgit.com/go-chi/chi/master/_examples/chi.svg" width="220" />\n\n\n[![GoDoc Widget]][GoDoc] [![Travis Widget]][Travis]\n\n`chi` is a lightweight, idiomatic and composable router for building Go HTTP services. It\'s\nespecially good at helping you write large REST API services that are kept maintainable as your\nproject grows and changes. `chi` is built on the new `context` package introduced in Go 1.7 to\nhandle signaling, cancelation and request-scoped values across a handler chain.\n\nThe focus of the project has been to seek out an elegant and comfortable design for writing\nREST API servers, written during the development of the Pressly API service that powers our\npublic API service, which in turn powers all of our client-side applications.\n\nThe key considerations of chi\'s design are: project structure, maintainability, standard http\nhandlers (stdlib-only), developer productivity, and deconstructing a large system into many small\nparts. The core router `github.com/go-chi/chi` is quite small (less than 1000 LOC), but we\'ve also\nincluded some useful/optional subpackages: [middleware](/middleware), [render](https://github.com/go-chi/render) and [docgen](https://github.com/go-chi/docgen). We hope you enjoy it too!\n\n## Install\n\n`go get -u github.com/go-chi/chi`\n\n\n## Features\n\n* **Lightweight** - cloc\'d in ~1000 LOC for the chi router\n* **Fast** - yes, see [benchmarks](#benchmarks)\n* **100% compatible with net/http** - use any http or middleware pkg in the ecosystem that is also compatible with `net/http`\n* **Designed for modular/composable APIs** - middlewares, inline middlewares, route groups and subrouter mounting\n* **Context control** - built on new `context` package, providing value chaining, cancelations and timeouts\n* **Robust** - in production at Pressly, CloudFlare, Heroku, 99Designs, and many others (see [discussion](https://github.com/go-chi/chi/issues/91))\n* **Doc generation** - `docgen` auto-generates routing documentation from your source to JSON or Markdown\n* **No external dependencies** - plain ol\' Go stdlib + net/http\n\n\n## Examples\n\nSee [_examples/](https://github.com/go-chi/chi/blob/master/_examples/) for a variety of examples.\n\n\n**As easy as:**\n\n```go\npackage main\n\nimport (\n\t"net/http"\n\t"github.com/go-chi/chi"\n)\n\nfunc main() {\n\tr := chi.NewRouter()\n\tr.Get("/", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte("welcome"))\n\t})\n\thttp.ListenAndServe(":3000", r)\n}\n```\n\n**REST Preview:**\n\nHere is a little preview of how routing looks like with chi. Also take a look at the generated routing docs\nin JSON ([routes.json](https://github.com/go-chi/chi/blob/master/_examples/rest/routes.json)) and in\nMarkdown ([routes.md](https://github.com/go-chi/chi/blob/master/_examples/rest/routes.md)).\n\nI highly recommend reading the source of the [examples](https://github.com/go-chi/chi/blob/master/_examples/) listed\nabove, they will show you all the features of chi and serve as a good form of documentation.\n\n```go\nimport (\n  //...\n  "context"\n  "github.com/go-chi/chi"\n  "github.com/go-chi/chi/middleware"\n)\n\nfunc main() {\n  r := chi.NewRouter()\n\n  // A good base middleware stack\n  r.Use(middleware.RequestID)\n  r.Use(middleware.RealIP)\n  r.Use(middleware.Logger)\n  r.Use(middleware.Recoverer)\n\n  // Set a timeout value on the request context (ctx), that will signal\n  // through ctx.Done() that the request has timed out and further\n  // processing should be stopped.\n  r.Use(middleware.Timeout(60 * time.Second))\n\n  r.Get("/", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte("hi"))\n  })\n\n  // RESTy routes for "articles" resource\n  r.Route("/articles", func(r chi.Router) {\n    r.With(paginate).Get("/", listArticles)                           // GET /articles\n    r.With(paginate).Get("/{month}-{day}-{year}", listArticlesByDate) // GET /articles/01-16-2017\n\n    r.Post("/", createArticle)                                        // POST /articles\n    r.Get("/search", searchArticles)                                  // GET /articles/search\n\n    // Regexp url parameters:\n    r.Get("/{articleSlug:[a-z-]+}", getArticleBySlug)                // GET /articles/home-is-toronto\n\n    // Subrouters:\n    r.Route("/{articleID}", func(r chi.Router) {\n      r.Use(ArticleCtx)\n      r.Get("/", getArticle)                                          // GET /articles/123\n      r.Put("/", updateArticle)                                       // PUT /articles/123\n      r.Delete("/", deleteArticle)                                    // DELETE /articles/123\n    })\n  })\n\n  // Mount the admin sub-router\n  r.Mount("/admin", adminRouter())\n\n  http.ListenAndServe(":3333", r)\n}\n\nfunc ArticleCtx(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    articleID := chi.URLParam(r, "articleID")\n    article, err := dbGetArticle(articleID)\n    if err != nil {\n      http.Error(w, http.StatusText(404), 404)\n      return\n    }\n    ctx := context.WithValue(r.Context(), "article", article)\n    next.ServeHTTP(w, r.WithContext(ctx))\n  })\n}\n\nfunc getArticle(w http.ResponseWriter, r *http.Request) {\n  ctx := r.Context()\n  article, ok := ctx.Value("article").(*Article)\n  if !ok {\n    http.Error(w, http.StatusText(422), 422)\n    return\n  }\n  w.Write([]byte(fmt.Sprintf("title:%s", article.Title)))\n}\n\n// A completely separate router for administrator routes\nfunc adminRouter() http.Handler {\n  r := chi.NewRouter()\n  r.Use(AdminOnly)\n  r.Get("/", adminIndex)\n  r.Get("/accounts", adminListAccounts)\n  return r\n}\n\nfunc AdminOnly(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    ctx := r.Context()\n    perm, ok := ctx.Value("acl.permission").(YourPermissionType)\n    if !ok || !perm.IsAdmin() {\n      http.Error(w, http.StatusText(403), 403)\n      return\n    }\n    next.ServeHTTP(w, r)\n  })\n}\n```\n\n\n## Router design\n\nchi\'s router is based on a kind of [Patricia Radix trie](https://en.wikipedia.org/wiki/Radix_tree).\nThe router is fully compatible with `net/http`.\n\nBuilt on top of the tree is the `Router` interface:\n\n```go\n// Router consisting of the core routing methods used by chi\'s Mux,\n// using only the standard net/http.\ntype Router interface {\n\thttp.Handler\n\tRoutes\n\n\t// Use appends one or more middlewares onto the Router stack.\n\tUse(middlewares ...func(http.Handler) http.Handler)\n\n\t// With adds inline middlewares for an endpoint handler.\n\tWith(middlewares ...func(http.Handler) http.Handler) Router\n\n\t// Group adds a new inline-Router along the current routing\n\t// path, with a fresh middleware stack for the inline-Router.\n\tGroup(fn func(r Router)) Router\n\n\t// Route mounts a sub-Router along a `pattern`` string.\n\tRoute(pattern string, fn func(r Router)) Router\n\n\t// Mount attaches another http.Handler along ./pattern/*\n\tMount(pattern string, h http.Handler)\n\n\t// Handle and HandleFunc adds routes for `pattern` that matches\n\t// all HTTP methods.\n\tHandle(pattern string, h http.Handler)\n\tHandleFunc(pattern string, h http.HandlerFunc)\n\n\t// Method and MethodFunc adds routes for `pattern` that matches\n\t// the `method` HTTP method.\n\tMethod(method, pattern string, h http.Handler)\n\tMethodFunc(method, pattern string, h http.HandlerFunc)\n\n\t// HTTP-method routing along `pattern`\n\tConnect(pattern string, h http.HandlerFunc)\n\tDelete(pattern string, h http.HandlerFunc)\n\tGet(pattern string, h http.HandlerFunc)\n\tHead(pattern string, h http.HandlerFunc)\n\tOptions(pattern string, h http.HandlerFunc)\n\tPatch(pattern string, h http.HandlerFunc)\n\tPost(pattern string, h http.HandlerFunc)\n\tPut(pattern string, h http.HandlerFunc)\n\tTrace(pattern string, h http.HandlerFunc)\n\n\t// NotFound defines a handler to respond whenever a route could\n\t// not be found.\n\tNotFound(h http.HandlerFunc)\n\n\t// MethodNotAllowed defines a handler to respond whenever a method is\n\t// not allowed.\n\tMethodNotAllowed(h http.HandlerFunc)\n}\n\n// Routes interface adds two methods for router traversal, which is also\n// used by the github.com/go-chi/docgen package to generate documentation for Routers.\ntype Routes interface {\n\t// Routes returns the routing tree in an easily traversable structure.\n\tRoutes() []Route\n\n\t// Middlewares returns the list of middlewares in use by the router.\n\tMiddlewares() Middlewares\n\n\t// Match searches the routing tree for a handler that matches\n\t// the method/path - similar to routing a http request, but without\n\t// executing the handler thereafter.\n\tMatch(rctx *Context, method, path string) bool\n}\n```\n\nEach routing method accepts a URL `pattern` and chain of `handlers`. The URL pattern\nsupports named params (ie. `/users/{userID}`) and wildcards (ie. `/admin/*`). URL parameters\ncan be fetched at runtime by calling `chi.URLParam(r, "userID")` for named parameters\nand `chi.URLParam(r, "*")` for a wildcard parameter.\n\n\n### Middleware handlers\n\nchi\'s middlewares are just stdlib net/http middleware handlers. There is nothing special\nabout them, which means the router and all the tooling is designed to be compatible and\nfriendly with any middleware in the community. This offers much better extensibility and reuse\nof packages and is at the heart of chi\'s purpose.\n\nHere is an example of a standard net/http middleware handler using the new request context\navailable in Go. This middleware sets a hypothetical user identifier on the request\ncontext and calls the next handler in the chain.\n\n```go\n// HTTP middleware setting a value on the request context\nfunc MyMiddleware(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    ctx := context.WithValue(r.Context(), "user", "123")\n    next.ServeHTTP(w, r.WithContext(ctx))\n  })\n}\n```\n\n\n### Request handlers\n\nchi uses standard net/http request handlers. This little snippet is an example of a http.Handler\nfunc that reads a user identifier from the request context - hypothetically, identifying\nthe user sending an authenticated request, validated+set by a previous middleware handler.\n\n```go\n// HTTP handler accessing data from the request context.\nfunc MyRequestHandler(w http.ResponseWriter, r *http.Request) {\n  user := r.Context().Value("user").(string)\n  w.Write([]byte(fmt.Sprintf("hi %s", user)))\n}\n```\n\n\n### URL parameters\n\nchi\'s router parses and stores URL parameters right onto the request context. Here is\nan example of how to access URL params in your net/http handlers. And of course, middlewares\nare able to access the same information.\n\n```go\n// HTTP handler accessing the url routing parameters.\nfunc MyRequestHandler(w http.ResponseWriter, r *http.Request) {\n  userID := chi.URLParam(r, "userID") // from a route like /users/{userID}\n\n  ctx := r.Context()\n  key := ctx.Value("key").(string)\n\n  w.Write([]byte(fmt.Sprintf("hi %v, %v", userID, key)))\n}\n```\n\n\n## Middlewares\n\nchi comes equipped with an optional `middleware` package, providing a suite of standard\n`net/http` middlewares. Please note, any middleware in the ecosystem that is also compatible\nwith `net/http` can be used with chi\'s mux.\n\n### Core middlewares\n\n-----------------------------------------------------------------------------------------------------------\n| chi/middleware Handler | description                                                                     |\n|:----------------------|:---------------------------------------------------------------------------------\n| AllowContentType      | Explicit whitelist of accepted request Content-Types                            |\n| Compress              | Gzip compression for clients that accept compressed responses                   |\n| GetHead               | Automatically route undefined HEAD requests to GET handlers                     |\n| Heartbeat             | Monitoring endpoint to check the servers pulse                                  |\n| Logger                | Logs the start and end of each request with the elapsed processing time         |\n| NoCache               | Sets response headers to prevent clients from caching                           |\n| Profiler              | Easily attach net/http/pprof to your routers                                    |\n| RealIP                | Sets a http.Request\'s RemoteAddr to either X-Forwarded-For or X-Real-IP         |\n| Recoverer             | Gracefully absorb panics and prints the stack trace                             |\n| RequestID             | Injects a request ID into the context of each request                           |\n| RedirectSlashes       | Redirect slashes on routing paths                                               |\n| SetHeader             | Short-hand middleware to set a response header key/value                        |\n| StripSlashes          | Strip slashes on routing paths                                                  |\n| Throttle              | Puts a ceiling on the number of concurrent requests                             |\n| Timeout               | Signals to the request context when the timeout deadline is reached             |\n| URLFormat             | Parse extension from url and put it on request context                          |\n| WithValue             | Short-hand middleware to set a key/value on the request context                 |\n-----------------------------------------------------------------------------------------------------------\n\n### Auxiliary middlewares & packages\n\nPlease see https://github.com/go-chi for additional packages.\n\n--------------------------------------------------------------------------------------------------------------------\n| package                                            | description                                                 |\n|:---------------------------------------------------|:-------------------------------------------------------------\n| [cors](https://github.com/go-chi/cors)             | Cross-origin resource sharing (CORS)                        |\n| [docgen](https://github.com/go-chi/docgen)         | Print chi.Router routes at runtime                          |\n| [jwtauth](https://github.com/go-chi/jwtauth)       | JWT authentication                                          |\n| [hostrouter](https://github.com/go-chi/hostrouter) | Domain/host based request routing                           |\n| [httpcoala](https://github.com/go-chi/httpcoala)   | HTTP request coalescer                                      |\n| [chi-authz](https://github.com/casbin/chi-authz)   | Request ACL via https://github.com/hsluoyz/casbin           |\n| [phi](https://github.com/fate-lovely/phi)          | Port chi to [fasthttp](https://github.com/valyala/fasthttp) |\n--------------------------------------------------------------------------------------------------------------------\n\nplease [submit a PR](./CONTRIBUTING.md) if you\'d like to include a link to a chi-compatible middleware\n\n\n## context?\n\n`context` is a tiny pkg that provides simple interface to signal context across call stacks\nand goroutines. It was originally written by [Sameer Ajmani](https://github.com/Sajmani)\nand is available in stdlib since go1.7.\n\nLearn more at https://blog.golang.org/context\n\nand..\n* Docs: https://golang.org/pkg/context\n* Source: https://github.com/golang/go/tree/master/src/context\n\n\n## Benchmarks\n\nThe benchmark suite: https://github.com/pkieltyka/go-http-routing-benchmark\n\nResults as of Jan 9, 2019 with Go 1.11.4 on Linux X1 Carbon laptop\n\n```shell\nBenchmarkChi_Param            3000000         475 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_Param5           2000000         696 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_Param20          1000000        1275 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_ParamWrite       3000000         505 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_GithubStatic     3000000         508 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_GithubParam      2000000         669 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_GithubAll          10000      134627 ns/op     87699 B/op    609 allocs/op\nBenchmarkChi_GPlusStatic      3000000         402 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_GPlusParam       3000000         500 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_GPlus2Params     3000000         586 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_GPlusAll          200000        7237 ns/op      5616 B/op     39 allocs/op\nBenchmarkChi_ParseStatic      3000000         408 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_ParseParam       3000000         488 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_Parse2Params     3000000         551 ns/op       432 B/op      3 allocs/op\nBenchmarkChi_ParseAll          100000       13508 ns/op     11232 B/op     78 allocs/op\nBenchmarkChi_StaticAll          20000       81933 ns/op     67826 B/op    471 allocs/op\n```\n\nComparison with other routers: https://gist.github.com/pkieltyka/123032f12052520aaccab752bd3e78cc\n\nNOTE: the allocs in the benchmark above are from the calls to http.Request\'s\n`WithContext(context.Context)` method that clones the http.Request, sets the `Context()`\non the duplicated (alloc\'d) request and returns it the new request object. This is just\nhow setting context on a request in Go works.\n\n\n## Credits\n\n* Carl Jackson for https://github.com/zenazn/goji\n  * Parts of chi\'s thinking comes from goji, and chi\'s middleware package\n    sources from goji.\n* Armon Dadgar for https://github.com/armon/go-radix\n* Contributions: [@VojtechVitek](https://github.com/VojtechVitek)\n\nWe\'ll be more than happy to see [your contributions](./CONTRIBUTING.md)!\n\n\n## Beyond REST\n\nchi is just a http router that lets you decompose request handling into many smaller layers.\nMany companies use chi to write REST services for their public APIs. But, REST is just a convention\nfor managing state via HTTP, and there\'s a lot of other pieces required to write a complete client-server\nsystem or network of microservices.\n\nLooking beyond REST, I also recommend some newer works in the field:\n* [webrpc](https://github.com/webrpc/webrpc) - Web-focused RPC client+server framework with code-gen\n* [gRPC](https://github.com/grpc/grpc-go) - Google\'s RPC framework via protobufs\n* [graphql](https://github.com/99designs/gqlgen) - Declarative query language\n* [NATS](https://nats.io) - lightweight pub-sub\n\n\n## License\n\nCopyright (c) 2015-present [Peter Kieltyka](https://github.com/pkieltyka)\n\nLicensed under [MIT License](./LICENSE)\n\n[GoDoc]: https://godoc.org/github.com/go-chi/chi\n[GoDoc Widget]: https://godoc.org/github.com/go-chi/chi?status.svg\n[Travis]: https://travis-ci.org/go-chi/chi\n[Travis Widget]: https://travis-ci.org/go-chi/chi.svg?branch=master\n'