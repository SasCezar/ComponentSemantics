b'<div align="center">\n\n  [![NPM version](https://img.shields.io/npm/v/latex.js.svg?style=plastic)](https://www.npmjs.org/package/latex.js)\n  [![NPM downloads](https://img.shields.io/npm/dm/latex.js.svg?style=plastic)](https://www.npmjs.org/package/latex.js)\n  [![CircleCI](https://img.shields.io/circleci/project/github/michael-brade/LaTeX.js.svg?style=plastic)](https://circleci.com/gh/michael-brade/LaTeX.js)\n  [![codecov](https://codecov.io/gh/michael-brade/LaTeX.js/branch/master/graph/badge.svg)](https://codecov.io/gh/michael-brade/LaTeX.js)\n  [![Maintainability](https://api.codeclimate.com/v1/badges/f2ab8b70a87a9da55189/maintainability)](https://codeclimate.com/github/michael-brade/LaTeX.js/maintainability)\n  [![Greenkeeper badge](https://badges.greenkeeper.io/michael-brade/LaTeX.js.svg)](https://greenkeeper.io/)\n  [![License](https://img.shields.io/github/license/michael-brade/LaTeX.js.svg?style=plastic)](https://github.com/michael-brade/LaTeX.js/blob/master/LICENSE)\n\n</div>\n\n\n# LaTeX to HTML5 translator using a PEG.js parser\n\nThis is a LaTeX to HTML5 translator written in JavaScript using PEG.js.\n`latex.js` for LaTeX is similar in spirit to `marked` for Markdown.\n\nLaTeX.js tries to be absolutely and uncompromisingly exact and compatible with LaTeX.\nThe generated HTML is exactly what is meant to be output, down to the last\nspace. The CSS makes it look like LaTeX output&mdash;except where impossible in principle,\nsee limitations.\n\nYou can play with it here:\n[http://latex.js.org/playground.html](http://latex.js.org/playground.html)\n\n\n## Installation\n\nFor CLI usage install it globally:\n\n```\nnpm install -g latex.js\n```\n\nFor library usage add it to your project:\n\n```\nnpm install --save-prod latex.js\n```\n\n\n\n## Usage\n\nLaTeX.js has a command line interface (CLI), it can be embedded in a website using the provided webcomponent, or it can be\nused to directly obtain and possibly modify the generated HTML/DOM by accessing the low-level classes. Each of those\nuse-cases is explained in the following subsections.\n\nLaTeX.js can parse full LaTeX documents as well as documents without a preamble and only the text that comes between\n`\\begin{document}` and `\\end{document}` in a full LaTeX document. In that latter case, the default documentclass is\nused, which is `article` unless specified otherwise.\n\n\n### CLI\n\nThe CLI has the following options:\n\n```\nUsage: latex.js [options] [files...]\n\nJavaScript LaTeX to HTML5 translator\n\nOptions:\n\n  -V, --version          output the version number\n  -o, --output <file>    specify output file, otherwise STDOUT will be used\n  -a, --assets [dir]     copy CSS and fonts to the directory of the output file, unless dir is given (default: no assets are copied)\n  -u, --url <base URL>   set the base URL to use for the assets (default: use relative URLs)\n  -b, --body             don\'t include HTML boilerplate and CSS, only output the contents of body\n  -e, --entities         encode HTML entities in the output instead of using UTF-8 characters\n  -p, --pretty           beautify the html (this may add/remove spaces unintentionally)\n  -c, --class <class>    set a default documentclass for documents without a preamble (default: article)\n  -m, --macros <file>    load a JavaScript file with additional custom macros\n  -s, --stylesheet <url> specify an additional style sheet to use (can be repeated)\n  -n, --no-hyphenation   don\'t insert soft hyphens (disables automatic hyphenation in the browser)\n  -l, --language <lang>  set hyphenation language (default: en)\n  -h, --help             output usage information\n\nIf no input files are given, STDIN is read.\n```\n\n### WebComponent\n\nLaTeX.js can be used as a web component:\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="content-type" content="text/html; charset=UTF-8">\n  <meta http-equiv="content-language" content="en">\n\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n\n  <script type="module">\n  import latexjs from "https://cdn.jsdelivr.net/npm/latex.js/dist/latex.component.esm.js"\n  customElements.define(\'latex-js\', latexjs)\n  </script>\n\n  <style>\n    latex-js {\n      display: inline-block;\n      width: 40%;\n      border: 1px solid red;\n      margin-right: 2em;\n    }\n  </style>\n\n  <title>LaTeX.js Web Component Test</title>\n</head>\n\n<body>\n  <h1>Compiling LaTeX</h1>\n\n  <latex-js baseURL="https://cdn.jsdelivr.net/npm/latex.js@0.11.1/dist/">\n    \\documentclass{article}\n\n    \\begin{document}\n    Hello World.\n    \\end{document}\n  </latex-js>\n\n\n  <latex-js hyphenate="false">\n    Another.\n  </latex-js>\n\n</body>\n\n</html>\n```\n\nThis, however, requires a browser with support for the shadow DOM.\n\nThen you need to decide how to embed the `<latex-js>` element and style it accordingly with CSS; most importantly, set\nthe `display:` property. It is `inline` by default.\n\nThe `<latex-js>` element supports a few attributes to configure LaTeX.js:\n\n- `baseURL`: if you want the LaTeX.js component to use a different set of stylesheets than the ones delivered along\n  with the `latex.component.js`, then you need to set the base using this attribute.\n\n- `hyphenate`: enable or disable hyphenation (default: enabled)\n\n\n### Library\n\nThis is the low-level use-case which gives the greatest control over the translation process.\n\nLaTeX.js is divided into a parser and a generator, so that in theory you could switch the generator to create e.g. plain\ntext instead of HTML. Currently, only a HTML generator exists.\n\nImport the parser and generator, then parse and translate to HTML:\n\n```js\nimport { parse, HtmlGenerator } from \'latex.js\'\n\nlet latex = "Hi, this is a line of text."\n\n\nlet generator = new HtmlGenerator({ hyphenate: false })\n\nlet doc = parse(latex, { generator: generator }).htmlDocument()\n\nconsole.log(doc.outerHTML)\n```\n\nThe `HtmlGenerator` takes several options, see the API section below.\n\n\n### In the Browser\n\nIf you want to use the parser and the generator manually, you can either use your own build or use a link directly to\nthe jsDelivr CDN:\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n\n  <meta charset="UTF-8">\n  <meta http-equiv="content-type" content="text/html; charset=UTF-8">\n  <meta http-equiv="content-language" content="en">\n\n  <meta http-equiv="X-UA-Compatible" content="ie=edge">\n\n  <!-- <script src="node_modules/latex.js/dist/latex.min.js"></script> -->\n  <script src="https://cdn.jsdelivr.net/npm/latex.js@0.11.1/dist/latex.min.js"></script>\n\n  <title>LaTeX.js API Test</title>\n</head>\n\n<body>\n  <h1>Compiling LaTeX</h1>\n\n  <script>\n    // or ES Modules\n    // import latexjs from "https://cdn.jsdelivr.net/npm/latex.js@0.11.1/dist/latex.esm.js"\n    var text = "Hi, this is a line of text."\n\n    var generator = new latexjs.HtmlGenerator({ hyphenate: false })\n\n    generator = latexjs.parse(text, { generator: generator })\n\n    document.body.appendChild(generator.stylesAndScripts("https://cdn.jsdelivr.net/npm/latex.js@0.11.1/dist/"))\n    document.body.appendChild(generator.domFragment())\n  </script>\n</body>\n\n</html>\n```\n\nNote that in this case the styles and scripts are not encapsulated, so they clash with the text and style of the\ncontaining page.\n\n\n## Tests\n\nTo build it and run the tests, clone this repository and execute:\n\n```\nnpm install\nnpm run build   # or devbuild\nnpm test\n```\n\nTo verify the screenshots (the CSS tests), ImageMagick needs to be installed. Screenshots are taken\nwith Chromium using `puppeteer`.\n\n\n\n\n## Playground\n\nTo build the playground, execute:\n\n```\nnpm run docs\n```\n\n\n\n## Directory Structure\n\nGeneral structure:\n\n- `src`: all the LaTeX.js sources\n- `bin`: the compiled CLI\n- `dist`: the compiled and minified source\n- `docs`: the webpage and (compiled) playground\n- `test`: unit tests and test driver\n\n\nFiles and classes needed to translate LaTeX documents to HTML documents:\n\n- the parser: `src/latex-parser.pegjs`\n- the generator: `src/html-generator.ls`\n- macros and documentclasses: `src/macros.ls`, `src/symbols.ls`, `src/documentclasses/*.ls`\n- packages: `src/packages/*.ls`\n\n- the CLI: `src/latex.js.ls`\n- the webcomponent: `src/latex.component.js`\n- the library API: `src/index.js`\n\nFiles needed to display the generated HTML document:\n\n- `src/js/` (and thus `dist/js/`): JavaScript that is needed by the resulting HTML document\n- `src/css/` (and thus `dist/js/`): CSS needed by translated HTML document\n- `src/fonts/` (and thus `dist/fonts`): fonts included by the translated HTML document\n\n\n\n\n## Architecture\n\nThe generated PEG parser parses the LaTeX code. While doing so, it calls appropriate generator functions.\nThe generator then uses the Macros class to execute the macros that the parser encounters.\n\nBoth, the parser and the macros create the resulting HTML DOM tree by calling the HtmlGenerator functions.\n\nThe generator also holds the stack, the lengths, counters, fonts, references, etc. It provides some of\nTeX\'s primitives and basic functionality, so to speak.\n\n## Definition of Custom Macros\n\nTo define your own LaTeX macros in JavaScript and extend LaTeX.js, you have to create a class that contains these macros\nand pass it to the `HtmlGenerator` constructor in the `options` object as `CustomMacros` property. For instance:\n\n```js\nvar generator = new latexjs.HtmlGenerator({\n  CustomMacros: (function() {\n    var args      = CustomMacros.args = {},\n        prototype = CustomMacros.prototype;\n\n    function CustomMacros(generator) {\n      this.g = generator;\n    }\n\n    args[\'bf\'] = [\'HV\']\n    prototype[\'bf\'] = function() {\n      this.g.setFontWeight(\'bf\')\n    };\n\n    return CustomMacros;\n  }())\n});\n```\n\nto define the LaTeX2.09 macro `\\bf`.\n\nIf you are going to define custom macros in an external file and you want to use that with the CLI, you will have to\nname the file just like the class, or you will have to default export it.\n\n\n### Macro Arguments\n\n`CustomMacros.args` above is a <[Map]<[string], [Array]<[string]>>>, mapping the macro name to the type and arguments of\nthe macro. If a macro doesn\'t take arguments and is a horizontal-mode macro, `args` can be left undefined for it.\n\nThe first array entry of `args[<macro name>]` declares the macro type:\n\n| type | meaning |\n| ---- | ------- |\n| `H`  | horizontal-mode macro |\n| `V`  | vertical-mode macro - ends the current paragraph |\n| `HV` | horizontal-vertical-mode macro: must return nothing, i.e., doesn\'t create output |\n| `P`  | only in preamble |\n| `X`  | special entry, may be used multiple times; execute action (macro body) already now with whatever arguments have been parsed so far; this is needed when things should be done before the next arguments are parsed - no value should be returned by the macro in this case, for it will just be ignored |\n\nThe rest of the list (array entries) declares the arguments:\n\n| arg  | delimiters | meaning                       | content | output |\n| ---- | --- |--------------------------------------|------|-----|\n| `s`  |     | optional star                        |||\n|||||\n|  `g` | { } | LaTeX code group (possibly long)     | TeX allows `\\endgraf`, but not `\\par`... so allow `\\par` as well | |\n| `hg` | { } | restricted horizontal mode material  |||\n| `o?` | [ ] | optional arg                         | LaTeX code |  |\n|||||\n|  `h` |     | restricted horizontal mode material  ||  |\n|||||\n|  `i` | { } | id                                   | letters only |  |\n| `i?` | [ ] | optional id                          | letters only |  |\n|  `k` | { } | key                                  | anything but = and , | |\n| `k?` | [ ] | optional key                         | anything but = and , | |\n|`csv` | { } | comma-separated values               || |\n|`csv?`| [ ] | optional comma-separated values      ||  |\n|`kv?` | [ ] | optional key-value list              ||  |\n|  `u` | { } | url                                  | a URL as specified by RFC3986 |  |\n|  `c` | { } | color specification                  | *name* or *float* or *float,float,float* |  |\n|  `m` | { } | macro                                | `\\macro` | |\n|  `l` | { } | length                               ||  |\n|`lg?` | { } | optional length group                ||  |\n| `l?` | [ ] | optional length                      |||\n| `cl` | { } | coordinate/length                    | `<float>` or TeX length |  |\n|`cl?` | [ ] | optional coordinate/length           ||  |\n|  `n` | { } | num expression                       ||  |\n| `n?` | [ ] | optional num expression              ||  |\n|  `f` | { } | float expression                     ||  |\n|  `v` | ( ) | vector, a pair of coordinates        | (float/length, float/length) |\n| `v?` |     | optional vector                      |||\n|||||\n| `is` |     | ignore (following) spaces            |||\n\nSo, in the following example, the macro `\\title` would be a horizontal-vertical-mode macro that takes one mandatory\nTeX-group argument:\n\n```js\nargs[\'title\'] = [\'HV\', \'g\'];\n```\n\n\nMacros with types `H` or `V` have to return an array.\n\nEnvironments take the return value of the corresponding macro and add their content as child/children to it.\n\n\n## API\n\nThis section is going to describe the low-level API of the generator and the parser. You will only need it if you\nimplement your own macros, or if you want to access parts of the result and keep processing them.\n\n\n### Parser\n\n#### `parser.parse(latex, { generator: <HtmlGenerator> })`\n\nThis function parses the given input LaTeX document and returns a generator that creates the output document.\n\nArguments:\n\n- `latex` is the LaTeX source document\n- options object: must contain a `generator` property with an instance of `HtmlGenerator`\n\nReturns the `HtmlGenerator` instance.\n\n\n\n### class: HtmlGenerator\n\n#### CTOR: `new HtmlGenerator(options)`\n\nCreate a new HTML generator. `options` is an <[Object]> that can have the following properties:\n\n- `documentClass`: <[string]> the default document class if a document without preamble is parsed\n- `CustomMacros`: a <[constructor]>/<[function]> with additional custom macros\n- `hyphenate`: <[boolean]> enable or disable automatic hyphenation\n- `languagePatterns`: language patterns object to use for hyphenation if it is enabled\n- `styles`: <[Array]<[string]>> additional CSS stylesheets\n\n\n#### `htmlGenerator.reset()`\n\nReset the generator. Needs to be called before the generator is used for creating a second document.\n\n\n#### `htmlGenerator.htmlDocument(baseURL)`\n\nReturns the full DOM `HTMLDocument` representation of the LaTeX source, including `<head>` and `<body`>. This is meant\nto be used as its own standalone webpage or in an `<iframe>`.\n\n`baseURL` will be used as base for the scripts and stylesheets; if omitted, the base will be `window.location.href` or,\nif not available, scripts and stylesheets will have relative URLs.\n\nTo serialize it, use `htmlGenerator.htmlDocument().outerHTML`.\n\n#### `htmlGenerator.stylesAndScripts(baseURL)`\n\nReturns a `DocumentFragment` with `<link>` and `<script>` elements. This usually is part of the `<head>` element.\n\nIf `baseURL` is given, the files will be referenced with absolute URLs, otherwise with relative URLs.\n\n\n#### `htmlGenerator.domFragment()`\n\nReturns the DOM `DocumentFragment`. This does not include the scripts and stylesheets and is meant for testing and\nlow-level embedding.\n\n\n#### `htmlGenerator.documentTitle()`\n\nThe title of the document.\n\n\n\n\n## Limitations\n\n- I haven\'t created an intermediate AST yet, so TeX\'s conditional expressions are impossible\n- deprecated macros, or macros that are not supposed to be used in LaTeX, won\'t even exist in LaTeX.js.\n  Examples include: `eqnarray`, the old LaTeX 2.09 font macros `\\it`, `\\sl`, etc. Also missing are most of the plainTeX macros.\n  See also [`l2tabuen.pdf`](ftp://ftp.dante.de/tex-archive/info/l2tabu/english/l2tabuen.pdf).\n- incorrect but legal markup in LaTeX won\'t produce the same result in LaTeX.js - like when using `\\raggedleft` in the\n  middle of a paragraph; but the LaTeX.js result should be intuitively correct.\n- because of the limitations when parsing TeX as a context-free grammar (see [below](#parsing-tex)), native LaTeX packages\n  cannot be parsed and loaded. Instead, the macros those packages (and documentclasses) provide have to be implemented in\n  JavaScript.\n\n\n## Limitations of LaTeX.js due to HTML and CSS\n\nThe following features in LaTeX just cannot be translated to HTML, not even when using JavaScript:\n\n- TeX removes any whitespace from the beginning and end of a line, even consecutive ones that would be printed in the middle\n  of a line, like `\\ ` or `~` or ^^0020. This is not possible in HTML (yet - maybe it will be with CSS4).\n- horizontal glue, like `\\hfill` in a paragraph of text, is not possible\n- vertical glue makes no sense in HTML, and is impossible to emulate, except in boxes with fixed height\n- `\\vspace{}` with a negative value in horizontal mode, i.e. in the middle of a paragraph of text, is not possible\n  (but this feature is useless anyway)\n\nAnd the concept of pages does not really apply to HTML, so any macro related to pagebreaks will be ignored. One\ncould say that splitting a HTML file into multiple files is like a pagebreak, but then, still, it would be much\neasier to handle: just choose a break before a new section or paragraph. There is no absolute space limitation\nlike on a real page.\n\n\n\n## <a name="parsing-tex"></a> Limitations when parsing TeX as a context-free grammar\n\nThis is a PEG parser, which means it interprets LaTeX as a context-free language. However, TeX (and therefore LaTeX) is\nTuring complete, so TeX can only really be parsed by a complete Turing machine. It is not possible to parse the full\nTeX language with a static parser. See\n[here](https://tex.stackexchange.com/questions/4201/is-there-a-bnf-grammar-of-the-tex-language) for some interesting\nexamples.\n\nIt is even undecidable whether a TeX program has a parse tree. There has been done some research\non the problem of parsing TeX, see [here](http://www.mathematik.uni-marburg.de/~seba/publications/sle10.pdf).\n\nTo quote the four problems of TeX:\n\n- Since TeX has dynamic scoping, it is not possible to determine statically\n  wheather `a` is an argument to `\\app` in `\\app a` or just another letter. It depends on the definition of `\\app` at\n  runtime.\n\n- Macros can be passed as arguments to other macros, further complicating this problem. E.g.:\n  ```tex\n  \\def\\app #1 #2 {#1 #2}\n  \\def\\id #1 {#1}\n  \\app a b\n  \\app \\id c\n  ```\n  Thus, targets of macro calls can in general not be determined statically.\n\n- TeX has a lexical macro system, which means macro bodies do not have to be syntactically correct pieces\n  of TeX code. Also, macros can expand to new macro definitions.\n\n- Tex allows custom macro call syntax. Basically, any syntax could be changed.\n\n\nI therefore take a slightly different approach:\n\n- First, I don\'t care about TeX, but only LaTeX, and most LaTeX documents do not use TeX syntax, or `\\def` in\n  particular. Therefore, this parser assumes standard LaTeX syntax and catcodes.\n\n- Second, for now there is no way of defining macros, only expanding macros is supported. So if a new\n  LaTeX macro is needed, reimplement it in JavaScript directly, thus circumventing the problem altogether.\n\n\n### Expansion and Execution\n\nAdditionally, this parser does not implement TeX\'s distinction of expansion and\nexecution. I am not yet sure if I need to implement it at all. Right now, there is only one phase that takes a macro\nand returns an HTML fragment.\n\nSkipped spaces and macros that expand to a macro taking a parameter further down in the input provide a good\nillustration of why TeX makes this distinction. Consider the commands\n```tex\n\\def\\a{\\penalty200}\n\\a 0\n```\nThis is not equivalent to\n```tex\n\\penalty200 0\n```\nwhich would place a penalty of 200, and typeset the digit 0. Instead, it expands to\n```tex\n\\penalty2000\n```\nbecause the space after \\a is skipped in the input processor. Later stages of processing then receive the sequence\n```tex\n\\a0\n```\nHowever, LaTeX documents themselves usually don\'t rely on or need this feature--that is, until I\'m convinced otherwise.\n\nThis also means that you cannot use `\\vs^^+ip` to have LaTeX.js interpret it as `\\vskip`. Again, this is a feature\nthat most people will probably never need.\n\n\n\n## Alternatives\n\nIf you need a LaTeX to HTML translator that also understands TeX to some extent, take a look at:\n\n* [TeX4ht](https://tug.org/applications/tex4ht/mn.html) (TeX)\n* [LaTeXML](https://github.com/brucemiller/LaTeXML) (Perl)\n* [LaTeX2HTML](https://github.com/latex2html/latex2html) (Perl)\n* ~~[HEVEA](http://hevea.inria.fr/) (OCaml)~~\n* ~~[plasTeX](https://github.com/tiarno/plastex) (Python)~~\n\nUpdate: sadly, those last two are nowhere near the quality of LaTeX.js.\n\nThere is no such alternative in JavaScript yet, though, which is why I started this project. I want to use it in my\n`derby-entities-lib` project.\n\n\n## License\n\n[![License](https://img.shields.io/github/license/michael-brade/LaTeX.js.svg?style=plastic)](https://github.com/michael-brade/LaTeX.js/blob/master/LICENSE)\n\nCopyright (c) 2015-2019 Michael Brade\n\n\n[boolean]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type "Boolean"\n[string]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type "String"\n[number]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type "Number"\n[constructor]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor "Class"\n[function]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function "Function"\n[Object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object"\n[Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array "Array"\n[Map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map "Map"\n'