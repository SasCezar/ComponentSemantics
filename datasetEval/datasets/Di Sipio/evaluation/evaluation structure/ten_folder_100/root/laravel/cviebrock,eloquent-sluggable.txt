b'# Eloquent-Sluggable\n\nEasy creation of slugs for your Eloquent models in Laravel.\n\n> **NOTE**: These instructions are for Laravel 6.0.  If you are using Laravel 5.8, please\n> see the [previous version\'s docs](https://github.com/cviebrock/eloquent-sluggable/tree/4.8).\n\n[![Build Status](https://travis-ci.org/cviebrock/eloquent-sluggable.svg?branch=master&format=flat)](https://travis-ci.org/cviebrock/eloquent-sluggable)\n[![Total Downloads](https://poser.pugx.org/cviebrock/eloquent-sluggable/downloads?format=flat)](https://packagist.org/packages/cviebrock/eloquent-sluggable)\n[![Latest Stable Version](https://poser.pugx.org/cviebrock/eloquent-sluggable/v/stable?format=flat)](https://packagist.org/packages/cviebrock/eloquent-sluggable)\n[![Latest Unstable Version](https://poser.pugx.org/cviebrock/eloquent-sluggable/v/unstable?format=flat)](https://packagist.org/packages/cviebrock/eloquent-sluggable)\n[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/cviebrock/eloquent-sluggable/badges/quality-score.png?format=flat)](https://scrutinizer-ci.com/g/cviebrock/eloquent-sluggable)\n[![SensioLabsInsight](https://insight.sensiolabs.com/projects/0b966e13-6a6a-4d17-bcea-61037f04cfe7/mini.png)](https://insight.sensiolabs.com/projects/0b966e13-6a6a-4d17-bcea-61037f04cfe7)\n[![License: MIT](https://img.shields.io/badge/License-MIT-brightgreen.svg?style=flat-square)](https://opensource.org/licenses/MIT)\n\n\n* [Background: What is a slug](#background-what-is-a-slug)\n* [Installation](#installation)\n* [Updating your Eloquent Models](#updating-your-eloquent-models)\n* [Usage](#usage)\n* [The SlugService Class](#the-slugservice-class)\n* [Events](#events)\n* [Configuration](#configuration)\n    * [includeTrashed](#includetrashed)\n    * [maxLength](#maxlength)\n    * [maxLengthKeepWords](#maxlengthkeepwords)\n    * [method](#method)\n    * [onUpdate](#onupdate)\n    * [reserved](#reserved)\n    * [separator](#separator)\n    * [source](#source)\n    * [unique](#unique)\n    * [uniqueSuffix](#uniquesuffix)\n* [Extending Sluggable](#extending-sluggable)\n    * [customizeSlugEngine](#customizeslugengine)\n    * [scopeWithUniqueSlugConstraints](#scopewithuniqueslugconstraints)\n    * [scopeFindSimilarSlugs](#scopefindsimilarslugs)\n* [SluggableScopeHelpers Trait](#sluggablescopehelpers-trait)\n* [Route Model Binding](#route-model-binding)\n* [Bugs, Suggestions, Contributions and Support](#bugs-suggestions-contributions-and-support)\n* [Copyright and License](#copyright-and-license)\n\n\n## Background: What is a slug?\n\nA slug is a simplified version of a string, typically URL-friendly. The act of "slugging" \na string usually involves converting it to one case, and removing any non-URL-friendly \ncharacters (spaces, accented letters, ampersands, etc.). The resulting string can \nthen be used as an identifier for a particular resource.\n\nFor example, if you have a blog with posts, you could refer to each post via the ID:\n\n    http://example.com/post/1\n    http://example.com/post/2\n\n... but that\'s not particularly friendly (especially for \n[SEO](http://en.wikipedia.org/wiki/Search_engine_optimization)). You probably would \nprefer to use the post\'s title in the URL, but that becomes a problem if your post \nis titled "My Dinner With Andr\xc3\xa9 & Fran\xc3\xa7ois", because this is pretty ugly too:\n\n    http://example.com/post/My+Dinner+With+Andr%C3%A9+%26+Fran%C3%A7ois\n\nThe solution is to create a slug for the title and use that instead. You might want \nto use Laravel\'s built-in `Str::slug()` method to convert that title into something \nfriendlier:\n\n    http://example.com/post/my-dinner-with-andre-francois\n\nA URL like that will make users happier (it\'s readable, easier to type, etc.).\n\nFor more information, you might want to read \n[this](http://en.wikipedia.org/wiki/Slug_(web_publishing)#Slug) description on Wikipedia.\n\nSlugs tend to be unique as well. So if you write another post with the same title, \nyou\'d want to distinguish between them somehow, typically with an incremental counter \nadded to the end of the slug:\n\n    http://example.com/post/my-dinner-with-andre-francois\n    http://example.com/post/my-dinner-with-andre-francois-1\n    http://example.com/post/my-dinner-with-andre-francois-2\n\nThis keeps the URLs unique.\n\nThe **Eloquent-Sluggable** package for Laravel aims to handle all of this for you \nautomatically, with minimal configuration.\n\n\n## Installation\n\nDepending on your version of Laravel, you should install a different\nversion of the package.  **NOTE**: As of version 6.0, the package\'s \nversion should match the Laravel version.\n\n| Laravel Version | Package Version |\n|:---------------:|:---------------:|\n|       6.0       |      6.0.*      |\n|       5.8       |      4.8.*      |\n|       5.7       |   4.6.*|4.7.*   |\n|       5.6       |      4.5.*      |\n|       5.5       |   4.3.*|4.4.*   |\n|       5.4       |      4.2.*      |\n\nOlder versions of Laravel can use older versions of the package, although they \nare no longer supported or maintained.  See [CHANGELOG.md](CHANGELOG.md) and\n[UPGRADING.md](UPGRADING.md) for specifics, and be sure that you are reading \nthe correct README.md for your version (Github displays the version in \nthe _master_ branch by default, which might not be what you want).\n\n\n1. Install the package via Composer:\n\n    ```sh\n    $ composer require cviebrock/eloquent-sluggable\n    ```\n\n    The package will automatically register its service provider.\n\n2. Optionally, publish the configuration file if you want to change any defaults:\n\n    ```sh\n    php artisan vendor:publish --provider="Cviebrock\\EloquentSluggable\\ServiceProvider"\n    ```\n\n\n## Updating your Eloquent Models\n\nYour models should use the Sluggable trait, which has an abstract method `sluggable()`\nthat you need to define.  This is where any model-specific configuration is set \n(see [Configuration](#configuration) below for details):\n\n```php\nuse Cviebrock\\EloquentSluggable\\Sluggable;\n\nclass Post extends Model\n{\n    use Sluggable;\n\n    /**\n     * Return the sluggable configuration array for this model.\n     *\n     * @return array\n     */\n    public function sluggable()\n    {\n        return [\n            \'slug\' => [\n                \'source\' => \'title\'\n            ]\n        ];\n    }\n}\n```\n\nOf course, your model and database will need a column in which to store the slug. \nYou can use `slug` or any other appropriate name you want; your configuration array\nwill determine to which field the data will be stored.  You will need to add the \ncolumn manually via your own migration.\n\nThat\'s it ... your model is now "sluggable"!\n\n\n\n## Usage\n\nSaving a model is easy:\n\n```php\n$post = new Post([\n    \'title\' => \'My Awesome Blog Post\',\n]);\n\n$post->save();\n```\n\nAnd so is retrieving the slug:\n\n```php\necho $post->slug;\n```\n\nAlso note that if you are replicating your models using Eloquent\'s `replicate()` method, \nthe package will automatically re-slug the model afterwards to ensure uniqueness.\n\n```php\n$post = new Post([\n    \'title\' => \'My Awesome Blog Post\',\n]);\n\n$post->save();\n// $post->slug is "my-awesome-blog-post"\n\n$newPost = $post->replicate();\n// $newPost->slug is "my-awesome-blog-post-1"\n```\n\nNote that empty strings, non-strings or other "odd" source values will result in different slugs:\n\n| Source Value | Resulting Slug        |\n|--------------|-----------------------|\n| string       | string                |\n| empty string | _no slug will be set_ |\n| `null`       | _no slug will be set_ |\n| `0`          | `"0"`                 |\n| `1`          | `"1"`                 |\n| `false`      | `"0"`                 |\n| `true`       | `"1"`                 |\n\n(The above values would be subject to any unique or other checks as well.)\n\n## The SlugService Class \n\nAll the logic to generate slugs is handled\nby the `\\Cviebrock\\EloquentSluggable\\Services\\SlugService` class.\n\nGenerally, you don\'t need to access this class directly, although there is one \nstatic method that can be used to generate a slug for a given string without actually\ncreating or saving an associated model.\n\n```php\nuse \\Cviebrock\\EloquentSluggable\\Services\\SlugService;\n\n$slug = SlugService::createSlug(Post::class, \'slug\', \'My First Post\');\n```\n\nThis would be useful for Ajax-y controllers or the like, where you want to show a \nuser what the unique slug _would_ be for a given test input, before actually creating\na model.  The first two arguments to the method are the model and slug field being\ntested, and the third argument is the source string to use for testing the slug.\n\nYou can also pass an optional array of configuration values as the fourth argument.\nThese will take precedence over the normal configuration values for the slug field\nbeing tested.  For example, if your model is configured to use unique slugs, but you \nwant to generate the "base" version of a slug for some reason, you could do:\n\n```php\n$slug = SlugService::createSlug(Post::class, \'slug\', \'My First Post\', [\'unique\' => false]);\n```\n\n\n\n## Events\n\n> **NOTE:** Events should be working but are not fully tested yet.\n> [Please help me out!](#bugs-suggestions-and-contributions)\n\nSluggable models will fire two Eloquent model events: "slugging" and "slugged".\n  \nThe "slugging" event is fired just before the slug is generated.  If the callback\nfrom this event returns `false`, then the slugging is not performed. If anything\nelse is returned, including `null`, then the slugging will be performed.\n\nThe "slugged" event is fired just after a slug is generated.  It won\'t be called\nin the case where the model doesn\'t need slugging (as determined by the `needsSlugging()`\nmethod).\n\nYou can hook into either of these events just like any other Eloquent model event:\n\n```php\nPost::registerModelEvent(\'slugging\', function($post) {\n    if ($post->someCondition()) {\n        // the model won\'t be slugged\n        return false;\n    }\n});\n\nPost::registerModelEvent(\'slugged\', function($post) {\n    Log::info(\'Post slugged: \' . $post->getSlug());\n});\n```\n\n\n\n## Configuration\n\nConfiguration was designed to be as flexible as possible. You can set up defaults \nfor all of your Eloquent models, and then override those settings for individual \nmodels.\n\nBy default, global configuration is set in the `config/sluggable.php` file. \nIf a configuration isn\'t set, then the package defaults are used. \nHere is an example configuration, with all the default settings shown:\n\n```php\nreturn [\n    \'source\'             => null,\n    \'maxLength\'          => null,\n    \'maxLengthKeepWords\' => true,\n    \'method\'             => null,\n    \'separator\'          => \'-\',\n    \'unique\'             => true,\n    \'uniqueSuffix\'       => null,\n    \'includeTrashed\'     => false,\n    \'reserved\'           => null,\n    \'onUpdate\'           => false,\n];\n```\n\nFor individual models, configuration is handled in the `sluggable()` method that you\nneed to implement.  That method should return an indexed array where the keys represent\nthe fields where the slug value is stored and the values are the configuration for that\nfield.  This means you can create multiple slugs for the same model, based on different\nsource strings and with different configuration options.\n\n```php\npublic function sluggable()\n{\n    return [\n        \'title-slug\' => [\n            \'source\' => \'title\'\n        ],\n        \'author-slug\' => [\n            \'source\' => [\'author.lastname\', \'author.firstname\'],\n            \'separator\' => \'_\'\n        ],\n    ];\n}\n```\n  \n\n### source\n\nThis is the field or array of fields from which to build the slug. Each `$model->field` \nis concatenated (with space separation) to build the sluggable string. These can be \nmodel attributes (i.e. fields in the database), relationship attributes, or custom getters.\n \nTo reference fields from related models, use dot-notation. For example, the \nslug for the following book will be generated from its author\'s name and the book\'s title:\n\n```php\nclass Book extends Eloquent\n{\n    use Sluggable;\n\n    protected $fillable = [\'title\'];\n\n    public function sluggable() {\n        return [\n            \'slug\' => [\n                \'source\' => [\'author.name\', \'title\']\n            ]\n        ];\n    }\n    \n    public function author() {\n        return $this->belongsTo(Author::class);\n    }\n}\n...\nclass Author extends Eloquent\n{\n    protected $fillable = [\'name\'];\n}\n```\n\nAn example using a custom getter:\n\n```php\nclass Person extends Eloquent\n{\n    use Sluggable;\n\n    public function sluggable()\n    {\n        return [\n            \'slug\' => [\n                \'source\' => \'fullname\'\n            ]\n        ];\n    }\n\n    public function getFullnameAttribute() {\n        return $this->firstname . \' \' . $this->lastname;\n    }\n}\n```\n\nIf `source` is empty, false or null, then the value of `$model->__toString()` is used\nas the source for slug generation.\n\n### maxLength\n\nSetting this to a positive integer will ensure that your generated slugs are restricted \nto a maximum length (e.g. to ensure that they fit within your database fields). By default, \nthis value is null and no limit is enforced.\n\nNote: If `unique` is enabled (which it is by default), and you anticipate having \nseveral models with the same slug, then you should set this value to a few characters \nless than the length of your database field. The reason why is that the class will \nappend "-1", "-2", "-3", etc., to subsequent models in order to maintain uniqueness. \nThese incremental extensions aren\'t included in part of the `maxLength` calculation.\n\n### maxLengthKeepWords\n\nIf you are truncating your slugs with the `maxLength` setting, than you probably\nwant to ensure that your slugs don\'t get truncated in the middle of a word.  For\nexample, if your source string is "My First Post", and your `maxLength` is 10,\nthe generated slug would end up being "my-first-p", which isn\'t ideal.\n\nBy default, the `maxLengthKeepWords` value is set to true which would trim the\npartial words off the end of the slug, resulting in "my-first" instead of "my-first-p".\n\nIf you want to keep partial words, then set this configuration to false.\n\n### method\n\nDefines the method used to turn the sluggable string into a slug. There are three \npossible options for this configuration:\n\n1. When `method` is null (the default setting), the package uses the default slugging\nengine -- [cocur/slugify](https://github.com/cocur/slugify) -- to create the slug.\n\n2. When `method` is a callable, then that function or class method is used. The function/method \nshould expect two parameters: the string to process, and a separator string. \nFor example, to use Laravel\'s `Str::slug`, you could do:\n\n```php\n\'method\' => [\'Illuminate\\\\Support\\\\Str\', \'slug\'],\n```\n\n3. You can also define `method` as a closure (again, expecting two parameters):\n\n```php\n\'method\' => function ($string, $separator) {\n    return strtolower(preg_replace(\'/[^a-z]+/i\', $separator, $string));\n},\n```\n\nAny other values for `method` will throw an exception.\n\nFor more complex slugging requirements, see [Extending Sluggable](#extending-sluggable) below.\n\n### onUpdate\n\nBy default, updating a model will not try and generate a new slug value.  It is assumed\nthat once your slug is generated, you won\'t want it to change (this may be especially\ntrue if you are using slugs for URLs and don\'t want to mess up your SEO mojo).\n\nIf you want to regenerate one or more of your model\'s slug fields, you can set those\nfields to null or an empty string before the update:\n\n```php\n$post->slug = null;\n$post->update([\'title\' => \'My New Title\']);\n```\n\nIf this is the behaviour you want every time you update a model, then set the `onUpdate`\noption to true.\n\n### separator\n\nThis defines the separator used when building a slug, and is passed to the `method` \ndefined above. The default value is a hyphen.\n\n### unique\n\nThis is a boolean defining whether slugs should be unique among all models of the given type. \nFor example, if you have two blog posts and both are called "My Blog Post", then they \nwill both sluggify to "my-blog-post" if `unique` is false. This could be a problem, e.g. \nif you use the slug in URLs.\n\nBy setting `unique` to true, then the second Post model will sluggify to "my-blog-post-1". \nIf there is a third post with the same title, it will sluggify to "my-blog-post-2" \nand so on. Each subsequent model will get an incremental value appended to the end \nof the slug, ensuring uniqueness.\n\n### uniqueSuffix\n\nIf you want to use a different way of identifying uniqueness (other than auto-incrementing\nintegers), you can set the `uniqueSuffix` configuration to a function or callable that \ngenerates the "unique" values for you.\n \nThe function should take three parameters: the base slug (i.e. the non-unique slug), the\nseparator string, and an `\\Illuminate\\Support\\Collection` of all the other slug strings\nthat start with the same slug.  You can then do whatever you want to create a new suffix\nthat hasn\'t been used by any of the slugs in the collection.  For example, if you wanted\nto use letters instead of numbers as a suffix, this is one way to achieve that:\n\n```php\n\'uniqueSuffix\' => function ($slug, $separator, Collection $list) {\n    $size = count($list);\n\n    return chr($size + 96);\n}\n```\n\n### includeTrashed\n\nSetting this to `true` will also check deleted models when trying to enforce uniqueness. \nThis only affects Eloquent models that are using the \n[softDelete](http://laravel.com/docs/eloquent#soft-deleting) feature. Default is `false`, \nso soft-deleted models don\'t count when checking for uniqueness.\n\n### reserved\n\nAn array of values that will never be allowed as slugs, e.g. to prevent collisions \nwith existing routes or controller methods, etc.. This can be an array, or a closure \nthat returns an array. Defaults to `null`: no reserved slug names.\n\n\n\n## Short Configuration\n\nThe package supports a really short configuration syntax, if you are truly lazy:\n\n```php\npublic function sluggable() {\n    return [\n        \'slug\'\n    ];\n}\n```\n\nThis will use all the default options from `config/sluggable.php`, use the model\'s\n`__toString()` method as the source, and store the slug in the `slug` field.\n\n\n\n## Extending Sluggable\n\nSometimes the configuration options aren\'t sufficient for complex needs (e.g. maybe \nthe uniqueness test needs to take other attributes into account).\n\nIn instances like these, the package offers hooks into the slugging workflow where you\ncan use your own functions, either on a per-model basis, or in your own trait that extends \nthe package\'s trait.\n\n### customizeSlugEngine\n\n```php\n/**\n * @param \\Cocur\\Slugify\\Slugify $engine\n * @param string $attribute\n * @return \\Cocur\\Slugify\\Slugify\n */\npublic function customizeSlugEngine(Slugify $engine, $attribute)\n{\n    ...\n}\n```\n\nIf this method exists on your model, the Slugify engine can be customized before slugging occurs.\nThis might be where you change the character mappings that are used, or alter language files, etc..\n\nYou can customize the engine on a per-model and per-attribute basis (maybe your model has \ntwo slug fields, and one of them needs customization).\n\nTake a look at `tests/Models/PostWithCustomEngine.php` for an example.\n\n### scopeWithUniqueSlugConstraints\n\n```php\n/**\n * @param \\Illuminate\\Database\\Eloquent\\Builder $query\n * @param \\Illuminate\\Database\\Eloquent\\Model $model\n * @param string $attribute\n * @param array $config\n * @param string $slug\n * @return \\Illuminate\\Database\\Eloquent\\Builder\n */\npublic function scopeWithUniqueSlugConstraints(Builder $query, Model $model, $attribute, $config, $slug)\n{\n    ...\n}\n```\n\nIf this scope exists on your model, then it will also be applied to the query used to determine \nif a given slug is unique.  The arguments passed to the scope are:\n\n* `$model` -- the object being slugged\n* `$attribute` -- the slug field being generated,\n* `$config` -- the configuration array for the given model and attribute\n* `$slug` -- the "base" slug (before any unique suffixes are applied)\n\nFeel free to use these values anyway you like in your query scope.  As an example, look at \n`tests/Models/PostWithUniqueSlugConstraints.php` where the slug is generated for a post from it\'s title, but\nthe slug is scoped to the author.  So Bob can have a post with the same title as Pam\'s post, but both\nwill have the same slug.\n\n### scopeFindSimilarSlugs\n\n```php\n/**\n * Query scope for finding "similar" slugs, used to determine uniqueness.\n *\n * @param \\Illuminate\\Database\\Eloquent\\Builder $query\n * @param string $attribute\n * @param array $config\n * @param string $slug\n * @return \\Illuminate\\Database\\Eloquent\\Builder\n */\npublic function scopeFindSimilarSlugs(Builder $query, $attribute, $config, $slug)\n{\n    ...\n}\n```\n\nThis is the default scope for finding "similar" slugs for a model.  Basically, the package looks for existing\nslugs that are the same as the `$slug` argument, or that start with `$slug` plus the separator string.\nThe resulting collection is what is passed to the `uniqueSuffix` handler.\n\nGenerally, this query scope (which is defined in the Sluggable trait) should be left alone.\nHowever, you are free to overload it in your models.\n\n\n\n## SluggableScopeHelpers Trait\n\nAdding the optional `SluggableScopeHelpers` trait to your model allows you to work with models\nand their slugs.  For example:\n\n```php\n$post = Post::whereSlug($slugString)->get();\n\n$post = Post::findBySlug($slugString);\n\n$post = Post::findBySlugOrFail($slugString);\n```\n\nBecause models can have more than one slug, this requires a bit more configuration.\nSee [SCOPE-HELPERS.md](SCOPE-HELPERS.md) for all the details.\n\n\n\n## Route Model Binding\n\nSee [ROUTE-MODEL-BINDING.md](ROUTE-MODEL-BINDING.md) for details.\n\n\n\n## Bugs, Suggestions, Contributions and Support\n\nThanks to [everyone](https://github.com/cviebrock/eloquent-taggable/graphs/contributors)\nwho has contributed to this project!  Special thanks to \n[JetBrains](https://www.jetbrains.com/?from=cviebrock/eloquent-sluggable) for their \nOpen Source License Program ... and the excellent PHPStorm IDE, of course!\n\n[![JetBrains](./.github/jetbrains.svg)](https://www.jetbrains.com/?from=cviebrock/eloquent-sluggable)\n\nPlease use [Github](https://github.com/cviebrock/eloquent-sluggable) for reporting bugs, \nand making comments or suggestions.\n \nSee [CONTRIBUTING.md](CONTRIBUTING.md) for how to contribute changes.\n\n\n\n## Copyright and License\n\n[eloquent-sluggable](https://github.com/cviebrock/eloquent-sluggable)\nwas written by [Colin Viebrock](http://viebrock.ca) and is released under the \n[MIT License](LICENSE.md).\n\nCopyright (c) 2013 Colin Viebrock\n'