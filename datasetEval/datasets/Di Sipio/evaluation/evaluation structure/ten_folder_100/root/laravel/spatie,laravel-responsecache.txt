b'# Speed up an app by caching the entire response\n\n[![Latest Version on Packagist](https://img.shields.io/packagist/v/spatie/laravel-responsecache.svg?style=flat-square)](https://packagist.org/packages/spatie/laravel-responsecache)\n[![MIT Licensed](https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat-square)](LICENSE.md)\n[![Build Status](https://img.shields.io/travis/spatie/laravel-responsecache/master.svg?style=flat-square)](https://travis-ci.org/spatie/laravel-responsecache)\n[![Quality Score](https://img.shields.io/scrutinizer/g/spatie/laravel-responsecache.svg?style=flat-square)](https://scrutinizer-ci.com/g/spatie/laravel-responsecache)\n[![Total Downloads](https://img.shields.io/packagist/dt/spatie/laravel-responsecache.svg?style=flat-square)](https://packagist.org/packages/spatie/laravel-responsecache)\n\nThis Laravel package can cache an entire response. By default it will cache all successful get-requests that return text based content (such as html and json) for a week. This could potentially speed up the response quite considerably.\n\nSo the first time a request comes in the package will save the response before sending it to the users. When the same request comes in again we\'re not going through the entire application but just respond with the saved response.\n\nSpatie is a webdesign agency in Antwerp, Belgium. You\'ll find an overview of all our open source projects [on our website](https://spatie.be/opensource).\n\n## Installation\n\nYou can install the package via composer:\n``` bash\ncomposer require spatie/laravel-responsecache\n```\n\nThe package will automatically register itself.\n\nYou can publish the config file with:\n```bash\nphp artisan vendor:publish --provider="Spatie\\ResponseCache\\ResponseCacheServiceProvider"\n```\n\nThis is the contents of the published config file:\n\n```php\n// config/responsecache.php\n\nreturn [\n    /*\n     * Determine if the response cache middleware should be enabled.\n     */\n    \'enabled\' => env(\'RESPONSE_CACHE_ENABLED\', true),\n\n    /*\n     *  The given class will determinate if a request should be cached. The\n     *  default class will cache all successful GET-requests.\n     *\n     *  You can provide your own class given that it implements the\n     *  CacheProfile interface.\n     */\n    \'cache_profile\' => Spatie\\ResponseCache\\CacheProfiles\\CacheAllSuccessfulGetRequests::class,\n\n    /*\n     * When using the default CacheRequestFilter this setting controls the\n     * default number of seconds responses must be cached.\n     */\n    \'cache_lifetime_in_seconds\' => env(\'RESPONSE_CACHE_LIFETIME\', 60 * 24 * 7),\n\n    /*\n     * This setting determines if a http header named with the cache time\n     * should be added to a cached response. This can be handy when\n     * debugging.\n     */\n    \'add_cache_time_header\' => env(\'APP_DEBUG\', true),\n\n    /*\n     * This setting determines the name of the http header that contains\n     * the time at which the response was cached\n     */\n    \'cache_time_header_name\' => env(\'RESPONSE_CACHE_HEADER_NAME\', \'laravel-responsecache\'),\n\n    /*\n     * Here you may define the cache store that should be used to store\n     * requests. This can be the name of any store that is\n     * configured in app/config/cache.php\n     */\n    \'cache_store\' => env(\'RESPONSE_CACHE_DRIVER\', \'file\'),\n\n    /*\n     * Here you may define replacers that dynamically replace content from the response.\n     * Each replacer must implement the Replacer interface.\n     */\n    \'replacers\' => [\n        \\Spatie\\ResponseCache\\Replacers\\CsrfTokenReplacer::class,\n    ],\n\n    /*\n     * If the cache driver you configured supports tags, you may specify a tag name\n     * here. All responses will be tagged. When clearing the responsecache only\n     * items with that tag will be flushed.\n     *\n     * You may use a string or an array here.\n     */\n    \'cache_tag\' => \'\',\n\n    /*\n     * This class is responsible for generating a hash for a request. This hash\n     * is used to look up an cached response.\n     */\n    \'hasher\' => \\Spatie\\ResponseCache\\Hasher\\DefaultHasher::class,\n\n    /*\n     * This class serializes cache data and expands it.\n     * Serialization can save the data to be returned in an appropriate form.\n     */\n    \'serializer\' => \\Spatie\\ResponseCache\\Serializer\\DefaultSerializer::class,\n];\n```\n\nAnd finally you should install the provided middlewares `\\Spatie\\ResponseCache\\Middlewares\\CacheResponse::class` and `\\Spatie\\ResponseCache\\Middlewares\\DoNotCacheResponse` in the http kernel.\n\n\n```php\n// app/Http/Kernel.php\n\n...\n\nprotected $middlewareGroups = [\n   \'web\' => [\n       ...\n       \\Spatie\\ResponseCache\\Middlewares\\CacheResponse::class,\n   ],\n\n...\n\nprotected $routeMiddleware = [\n   ...\n   \'doNotCacheResponse\' => \\Spatie\\ResponseCache\\Middlewares\\DoNotCacheResponse::class,\n];\n\n```\n\n## Usage\n\n### Basic usage\n\nBy default, the package will cache all successful `get`-requests for a week.\nLogged in users will each have their own separate cache. If this behaviour is what you\n need, you\'re done: installing the `ResponseCacheServerProvider` was enough.\n\n### Clearing the cache\n\n#### Manually\n\nThe entire cache can be cleared with:\n```php\nResponseCache::clear();\n```\nThis will clear everything from the cache store specified in the config-file.\n\n\n#### Using a console command\n\nThe same can be accomplished by issuing this artisan command:\n\n```bash\nphp artisan responsecache:clear\n```\n\n#### Using model events\n\nYou can leverage model events to clear the cache whenever a model is saved or deleted. Here\'s an example.\n```php\nnamespace App\\Traits;\n\nuse Spatie\\ResponseCache\\Facades\\ResponseCache;\n\ntrait ClearsResponseCache\n{\n    public static function bootClearsResponseCache()\n    {\n        self::created(function () {\n            ResponseCache::clear();\n        });\n\n        self::updated(function () {\n            ResponseCache::clear();\n        });\n\n        self::deleted(function () {\n            ResponseCache::clear();\n        });\n    }\n}\n```\n\n### Forget one or several specific URI(s)\n\nYou can forget specific URIs with:\n```php\n// Forget one URI\nResponseCache::forget(\'/some-uri\');\n\n// Forget several URIs\nResponseCache::forget([\'/some-uri\', \'/other-uri\']);\n\n// Alternatively\nResponseCache::forget(\'/some-uri\', \'/other-uri\');\n```\n\nThe `forget` method only works when you\'re not using a `cacheNameSuffix` in your cache profile. \n\n### Preventing a request from being cached\nRequests can be ignored by using the `doNotCacheResponse`-middleware.\nThis middleware [can be assigned to routes and controllers](http://laravel.com/docs/master/controllers#controller-middleware).\n\nUsing the middleware are route could be exempt from being cached.\n\n```php\n// app/Http/routes.php\n\nRoute::get(\'/auth/logout\', [\'middleware\' => \'doNotCacheResponse\', \'uses\' => \'AuthController@getLogout\']);\n```\n\nAlternatively, you can add the middleware to a controller:\n\n```php\nclass UserController extends Controller\n{\n    public function __construct()\n    {\n        $this->middleware(\'doNotCacheResponse\', [\'only\' => [\'fooAction\', \'barAction\']]);\n    }\n}\n```\n\n### Creating a custom cache profile\nTo determine which requests should be cached, and for how long, a cache profile class is used.\nThe default class that handles these questions is `Spatie\\ResponseCache\\CacheProfiles\\CacheAllSuccessfulGetRequests`.\n\nYou can create your own cache profile class by implementing the `\nSpatie\\ResponseCache\\CacheProfiles\\CacheProfile`-interface. Let\'s take a look at the interface:\n\n```php\ninterface CacheProfile\n{\n    /*\n     * Determine if the response cache middleware should be enabled.\n     */\n    public function enabled(Request $request): bool;\n\n    /*\n     * Determine if the given request should be cached.\n     */\n    public function shouldCacheRequest(Request $request): bool;\n\n    /*\n     * Determine if the given response should be cached.\n     */\n    public function shouldCacheResponse(Response $response): bool;\n\n    /*\n     * Return the time when the cache must be invalidated.\n     */\n    public function cacheRequestUntil(Request $request): DateTime;\n\n    /**\n     * Return a string to differentiate this request from others.\n     *\n     * For example: if you want a different cache per user you could return the id of\n     * the logged in user.\n     *\n     * @param \\Illuminate\\Http\\Request $request\n     *\n     * @return mixed\n     */\n    public function useCacheNameSuffix(Request $request);\n}\n```\n\n### Caching specific routes\nInstead of registering the `cacheResponse` middleware globally, you can also register it as route middleware.\n\n```php\nprotected $routeMiddleware = [\n   ...\n   \'cacheResponse\' => \\Spatie\\ResponseCache\\Middlewares\\CacheResponse::class,\n];\n```\n\nWhen using the route middleware you can specify the number of seconds these routes should be cached:\n\n```php\n// cache this route for 5 minutes\nRoute::get(\'/my-special-snowflake\', \'SnowflakeController@index\')->middleware(\'cacheResponse:300\');\n\n// cache all these routes for 10 minutes\nRoute::group(function() {\n   Route::get(\'/another-special-snowflake\', \'AnotherSnowflakeController@index\');\n\n   Route::get(\'/yet-another-special-snowflake\', \'YetAnotherSnowflakeController@index\');\n})->middleware(\'cacheResponse:600\');\n```\n\n### Using tags\n\nIf the [cache driver you configured supports tags](https://laravel.com/docs/5.8/cache#cache-tags), you can specify a list of tags when applying the middleware.\n\n```php\n// add a "foo" tag to this route with a 300 second lifetime\nRoute::get(\'/test1\', \'SnowflakeController@index\')->middleware(\'cacheResponse:300,foo\');\n\n// add a "bar" tag to this route\nRoute::get(\'/test2\', \'SnowflakeController@index\')->middleware(\'cacheResponse:bar\');\n\n// add both "foo" and "bar" tags to these routes\nRoute::group(function() {\n   Route::get(\'/test3\', \'AnotherSnowflakeController@index\');\n\n   Route::get(\'/test4\', \'YetAnotherSnowflakeController@index\');\n})->middleware(\'cacheResponse:foo,bar\');\n```\n\n#### Clearing tagged content\n\nYou can clear responses which are assigned a tag or list of tags. For example, this statement would remove all routes \nspecified above:\n\n```php\nResponseCache::clear([\'foo\', \'bar\']);\n```\n\nIn contrast, this statement would remove all of the routes except the `\'/test1\'` route:\n\n```php\nResponseCache::clear([\'bar\']);\n```\n\nNote that this uses [Laravel\'s built in cache tags](https://laravel.com/docs/master/cache#cache-tags) functionality, meaning \nroutes can also be cleared in the usual way:\n\n```php\nCache::tags(\'special\')->flush();\n```\n\n### Events\n\nThere are several events you can use to monitor and debug response caching in your application.\n\n#### ResponseCacheHit\n\n`Spatie\\ResponseCache\\Events\\ResponseCacheHit`\n\nThis event is fired when a request passes through the `ResponseCache` middleware and a cached response was found and returned.\n\n#### CacheMissed\n\n`Spatie\\ResponseCache\\Events\\CacheMissed`\n\nThis event is fired when a request passes through the `ResponseCache` middleware but no cached response was found or returned.\n\n#### ClearingResponseCache and ClearedResponseCache\n\n`Spatie\\ResponseCache\\Events\\ClearingResponseCache`\n\n`Spatie\\ResponseCache\\Events\\ClearedResponseCache`\n\nThese events are fired respectively when the `responsecache:clear` is started and finished.\n\n### Creating a Replacer\n\nTo replace cached content by dynamic content, you can create a replacer.\nBy default we add a `CsrfTokenReplacer` in the config file.\n\nYou can create your own replacers by implementing the `Spatie\\ResponseCache\\Replacers\\Replacer`-interface. Let\'s take a look at the interface:\n\n```php\ninterface Replacer\n{\n    /*\n     * Transform the initial response before it gets cached.\n     *\n     * For example: replace a generated csrf_token by \'<csrf-token-here>\' that you can\n     * replace with its dynamic counterpart when the cached response is returned.\n     */\n    public function transformInitialResponse(Response $response): void;\n\n    /*\n     * Replace any data you want in the cached response before it gets\n     * sent to the browser.\n     *\n     * For example: replace \'<csrf-token-here>\' by a call to csrf_token()\n     */\n    public function replaceCachedResponse(Response $response): void;\n}\n```\n\nAfterwards you can define your replacer in the `responsecache.php` config file:\n\n```\n/*\n * Here you may define replacers that dynamically replace content from the response.\n * Each replacer must implement the Replacer interface.\n */\n\'replacers\' => [\n    \\Spatie\\ResponseCache\\Replacers\\CsrfTokenReplacer::class,\n],\n```\n\n### Customizing the serializer\n\nA serializer is responsible from serializing a response so it can be stored in the cache. It is also responsible for rebuilding the response from the cache.\n\nThe default serializer `Spatie\\ResponseCache\\Serializer\\DefaultSerializer` will just work in most cases.\n\nIf you have some special serialization needs you can specify a custom serializer in the `serializer` key of the config file. Any class that implements `Spatie\\ResponseCache\\Serializers\\Serializer` can be used. This is how that interface looks like:\n\n```php\nnamespace Spatie\\ResponseCache\\Serializers;\n\nuse Symfony\\Component\\HttpFoundation\\Response;\n\ninterface Serializer\n{\n    public function serialize(Response $response): string;\n\n    public function unserialize(string $serializedResponse): Response;\n}\n```\n\n\n## Changelog\n\nPlease see [CHANGELOG](CHANGELOG.md) for more information what has changed recently.\n\n## Testing\n\nYou can run the tests with:\n``` bash\ncomposer test\n```\n\n## Alternatives\n\n- [Barry Vd. Heuvel](https://twitter.com/barryvdh) made [a package that caches responses by leveraging HttpCache](https://github.com/barryvdh/laravel-httpcache).\n- [Joseph Silber](https://twitter.com/joseph_silber) created [Laravel Page Cache](https://github.com/JosephSilber/page-cache) that can write it\'s cache to disk and let Nginx read them, so PHP doesn\'t even have to start up anymore.\n\n## Contributing\n\nPlease see [CONTRIBUTING](CONTRIBUTING.md) for details.\n\n## Security\n\nIf you discover any security related issues, please email freek@spatie.be instead of using the issue tracker.\n\n## Postcardware\n\nYou\'re free to use this package, but if it makes it to your production environment we highly appreciate you sending us a postcard from your hometown, mentioning which of our package(s) you are using.\n\nOur address is: Spatie, Samberstraat 69D, 2060 Antwerp, Belgium.\n\nWe publish all received postcards [on our company website](https://spatie.be/en/opensource/postcards).\n\n## Credits\n\n- [Freek Van der Herten](https://github.com/freekmurze)\n- [All Contributors](../../contributors)\n\n## Support us\n\nSpatie is a webdesign agency based in Antwerp, Belgium. You\'ll find an overview of all our open source projects [on our website](https://spatie.be/opensource).\n\nDoes your business depend on our contributions? Reach out and support us on [Patreon](https://www.patreon.com/spatie).\nAll pledges will be dedicated to allocating workforce on maintenance and new awesome stuff.\n\n## License\n\nThe MIT License (MIT). Please see [License File](LICENSE.md) for more information.\n'