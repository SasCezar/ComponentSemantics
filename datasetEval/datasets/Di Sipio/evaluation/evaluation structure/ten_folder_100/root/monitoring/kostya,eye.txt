b'Eye\n===\n[![Gem Version](https://badge.fury.io/rb/eye.png)](http://rubygems.org/gems/eye)\n[![Build Status](https://secure.travis-ci.org/kostya/eye.png?branch=master)](http://travis-ci.org/kostya/eye)\n[![Coverage Status](https://coveralls.io/repos/kostya/eye/badge.png?branch=master)](https://coveralls.io/r/kostya/eye?branch=master)\n\nProcess monitoring tool. Inspired from Bluepill and God. Requires Ruby(MRI) >= 1.9.3-p194. Uses Celluloid and Celluloid::IO.\n\nLittle demo, shows general commands and how chain works:\n\n[![Eye](https://raw.github.com/kostya/stuff/master/eye/eye.png)](https://raw.github.com/kostya/stuff/master/eye/eye.gif)\n\nInstallation:\n\n    $ gem install eye\n\n\n###  Why?\n\nWe have used god and bluepill in production and always ran into bugs (segfaults, crashes, lost processes, kill not-related processes, load problems, deploy problems, ...)\n\nWe wanted something more robust and production stable.\n\nWe wanted the features of bluepill and god, with a few extras like chains, nested configuring, mask matching, easy debug configs\n\nI hope we\'ve succeeded, we\'re using eye in production and are quite happy.\n\n###  Config example\n\nexamples/test.eye ([more examples](https://github.com/kostya/eye/tree/master/examples))\n```ruby\n# load submodules, here just for example\nEye.load(\'./eye/*.rb\')\n\n# Eye self-configuration section\nEye.config do\n  logger \'/tmp/eye.log\'\nend\n\n# Adding application\nEye.application \'test\' do\n  # All options inherits down to the config leafs.\n  # except `env`, which merging down\n\n  # uid "user_name" # run app as a user_name (optional) - available only on ruby >= 2.0\n  # gid "group_name" # run app as a group_name (optional) - available only on ruby >= 2.0\n\n  working_dir File.expand_path(File.join(File.dirname(__FILE__), %w[ processes ]))\n  stdall \'trash.log\' # stdout,err logs for processes by default\n  env \'APP_ENV\' => \'production\' # global env for each processes\n  trigger :flapping, times: 10, within: 1.minute, retry_in: 10.minutes\n  check :cpu, every: 10.seconds, below: 100, times: 3 # global check for all processes\n\n  group \'samples\' do\n    chain grace: 5.seconds # chained start-restart with 5s interval, one by one.\n\n    # eye daemonized process\n    process :sample1 do\n      pid_file \'1.pid\' # pid_path will be expanded with the working_dir\n      start_command \'ruby ./sample.rb\'\n\n      # when no stop_command or stop_signals, default stop is [:TERM, 0.5, :KILL]\n      # default `restart` command is `stop; start`\n\n      daemonize true\n      stdall \'sample1.log\'\n\n      # ensure the CPU is below 30% at least 3 out of the last 5 times checked\n      check :cpu, below: 30, times: [3, 5]\n    end\n\n    # self daemonized process\n    process :sample2 do\n      pid_file \'2.pid\'\n      start_command \'ruby ./sample.rb -d --pid 2.pid --log sample2.log\'\n      stop_command \'kill -9 {PID}\'\n\n      # ensure the memory is below 300Mb the last 3 times checked\n      check :memory, every: 20.seconds, below: 300.megabytes, times: 3\n    end\n  end\n\n  # daemon with 3 children\n  process :forking do\n    pid_file \'forking.pid\'\n    start_command \'ruby ./forking.rb start\'\n    stop_command \'ruby forking.rb stop\'\n    stdall \'forking.log\'\n\n    start_timeout 10.seconds\n    stop_timeout 5.seconds\n\n    monitor_children do\n      restart_command \'kill -2 {PID}\' # for this child process\n      check :memory, below: 300.megabytes, times: 3\n    end\n  end\n\n  # eventmachine process, daemonized with eye\n  process :event_machine do\n    pid_file \'em.pid\'\n    start_command \'ruby em.rb\'\n    stdout \'em.log\'\n    daemonize true\n    stop_signals [:QUIT, 2.seconds, :KILL]\n\n    check :socket, addr: \'tcp://127.0.0.1:33221\', every: 10.seconds, times: 2,\n                   timeout: 1.second, send_data: \'ping\', expect_data: /pong/\n  end\n\n  # thin process, self daemonized\n  process :thin do\n    pid_file \'thin.pid\'\n    start_command \'bundle exec thin start -R thin.ru -p 33233 -d -l thin.log -P thin.pid\'\n    stop_signals [:QUIT, 2.seconds, :TERM, 1.seconds, :KILL]\n\n    check :http, url: \'http://127.0.0.1:33233/hello\', pattern: /World/,\n                 every: 5.seconds, times: [2, 3], timeout: 1.second\n  end\nend\n```\n\n### Start eye daemon and/or load config:\n\n    $ eye l(oad) examples/test.eye\n\nload folder with configs:\n\n    $ eye l examples/\n    $ eye l examples/*.rb\n\nforeground load:\n\n    $ eye l CONF -f\n\nIf the eye daemon has already started and you call the `load` command, the config will be updated (into eye daemon). New objects(applications, groups, processes) will be added and monitored. Processes removed from the config will be removed (and stopped if the process has `stop_on_delete true`). Other objects will update their configs.\n\nTwo global configs loaded by default, if they exist (with the first eye load):\n\n    /etc/eye.conf\n    ~/.eyeconfig\n\nProcess statuses:\n\n    $ eye i(nfo)\n\n```\ntest\n  samples\n    sample1 ....................... up  (21:52, 0%, 13Mb, <4107>)\n    sample2 ....................... up  (21:52, 0%, 12Mb, <4142>)\n  event_machine ................... up  (21:52, 3%, 26Mb, <4112>)\n  forking ......................... up  (21:52, 0%, 41Mb, <4203>)\n    child-4206 .................... up  (21:52, 0%, 41Mb, <4206>)\n    child-4211 .................... up  (21:52, 0%, 41Mb, <4211>)\n    child-4214 .................... up  (21:52, 0%, 41Mb, <4214>)\n  thin ............................ up  (21:53, 2%, 54Mb, <4228>)\n```\n\n    $ eye i -j # show info in JSON format\n\n### Commands:\n\n    start, stop, restart, delete, monitor, unmonitor\n\nCommand params (with restart for example):\n\n    $ eye r(estart) all\n    $ eye r test\n    $ eye r samples\n    $ eye r sample1\n    $ eye r sample*\n    $ eye r test:samples\n    $ eye r test:samples:sample1\n    $ eye r test:samples:sample*\n    $ eye r test:*sample*\n\nCheck config syntax:\n\n    $ eye c(heck) examples/test.eye\n\nConfig explain (for debug):\n\n    $ eye e(xplain) examples/test.eye\n\nLog tracing (tail and grep):\n\n    $ eye t(race)\n    $ eye t test\n    $ eye t sample\n\nQuit monitoring:\n\n    $ eye q(uit)\n    $ eye q -s # stop all processes and quit\n\nInteractive info:\n\n    $ eye w(atch)\n\nProcess statuses history:\n\n    $ eye hi(story)\n\nEye daemon info:\n\n    $ eye x(info)\n    $ eye x -c # for show current config\n\nLocal Eye version LEye (like foreman):\n\n[LEye](https://github.com/kostya/eye/wiki/What-is-loader_eye-and-leye)\n\nProcess states and events:\n\n[![Eye](https://raw.github.com/kostya/stuff/master/eye/mprocess.png)](https://raw.github.com/kostya/stuff/master/eye/process.png)\n\nHow to write Eye extensions, plugins, gems:\n\n[Eye-http](https://github.com/kostya/eye-http) [Eye-rotate](https://github.com/kostya/eye-rotate) [Eye-hipchat](https://github.com/tmeinlschmidt/eye-hipchat) [Plugin example](https://github.com/kostya/eye/tree/master/examples/plugin)\n\n[Eye related projects](https://github.com/kostya/eye/wiki/Related-projects)\n\n[Articles](https://github.com/kostya/eye/wiki/Articles)\n\n[Wiki](https://github.com/kostya/eye/wiki)\n\n\nThanks `Bluepill` for the nice config ideas.\n'