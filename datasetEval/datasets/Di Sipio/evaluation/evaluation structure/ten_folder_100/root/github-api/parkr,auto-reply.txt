b'# auto-reply\n\nAn open source gardener. This is a technology for powering GitHub bots. It\'s really rough around the edges but it currently powers [@jekyllbot](https://github.com/jekyllbot).\n\n[![Build Status](https://travis-ci.org/parkr/auto-reply.svg?branch=master)](https://travis-ci.org/parkr/auto-reply)\n\n## Configuring\n\nIf you want to configure a secret to validate your payload from GitHub,\nthen set it as the environment variable `GITHUB_WEBHOOK_SECRET`. This is\nthe same value you enter in the web interface when setting up the "Secret"\nfor your webhook.\n\nI could use [your thoughts on this!](https://github.com/parkr/auto-reply/issues/4) Currently, it\'s a hodge-podge. The documentation for each package will provide more details on this. Currently we have the following packages, with varying levels of configuration:\n\n- `affinity` \xe2\x80\x93 assigns issues based on team mentions and those team captains. See [Jekyll\'s docs for more info.](https://github.com/jekyll/jekyll/blob/master/docs/affinity-team-captain.md)\n- `autopull` \xe2\x80\x93 detects pushes to branches which start with `pull/` and automatically creates a PR for them\n- `chlog` \xe2\x80\x93 creates GitHub releases when a new tag is pushed, and powers "@jekyllbot: merge (+category)"\n- `jekyll/deprecate` \xe2\x80\x93 comments on and closes issues to issues on certain repos with a per-repo stock message\n- `jekyll/issuecomment` \xe2\x80\x93 provides handlers for removing `pending-feedback` and `stale` labels when a comment comes through\n- `labeler` \xe2\x80\x93 removes `pending-rebase` label when a PR is pushed to and is mergeable (and helper functions for manipulating labels)\n- `lgtm` \xe2\x80\x93 adds a `jekyllbot/lgtm` CI status and handles `LGTM` counting\n\n## Installing\n\nThis is intended for use with servers, so you\'d do something like:\n\n```go\npackage main\n\nimport (\n\t"flag"\n\t"log"\n\t"net/http"\n\n\t"github.com/parkr/auto-reply/affinity"\n\t"github.com/parkr/auto-reply/ctx"\n\t"github.com/parkr/auto-reply/hooks"\n)\n\nvar context *ctx.Context\n\nfunc main() {\n\tvar port string\n\tflag.StringVar(&port, "port", "8080", "The port to serve to")\n\tflag.Parse()\n\tcontext = ctx.NewDefaultContext()\n\n\thttp.HandleFunc("/_ping", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set("Content-Type", "text/plain")\n\t\tw.Write([]byte("ok\\n"))\n\t}))\n\n\t// Add your event handlers. Check out the documentation for the\n\t// github.com/parkr/auto-reply/hooks package to see all supported events.\n\teventHandlers := hooks.EventHandlerMap{}\n\n\t// Build the affinity handler.\n\taff := &affinity.Handler{}\n\taff.AddRepo("myorg", "myproject")\n\taff.AddTeam(context, 123) // @myorg/performance\n\taff.AddTeam(context, 456) // @myorg/documentation\n\n\t// Add the affinity handler\'s various event handlers to the event handlers map :)\n\teventHandlers.AddHandler(hooks.IssuesEvent, aff.AssignIssueToAffinityTeamCaptain)\n\teventHandlers.AddHandler(hooks.IssueCommentEvent, aff.AssignIssueToAffinityTeamCaptainFromComment)\n\teventHandlers.AddHandler(hooks.PullRequestEvent, aff.RequestReviewFromAffinityTeamCaptain)\n\n\t// Create the webhook handler. GlobalHandler takes the list of event handlers from\n\t// its configuration and fires each of them based on the X-GitHub-Event header from\n\t// the webhook payload.\n\tmyOrgHandler := &hooks.GlobalHandler{\n\t\tContext:       context,\n\t\tEventHandlers: eventHandlers,\n\t}\n\thttp.Handle("/_github/myproject", myOrgHandler)\n\n\tlog.Printf("Listening on :%s", port)\n\tlog.Fatal(http.ListenAndServe(":"+port, nil))\n}\n```\n\n## Writing Custom Handlers\n\nFor now, all you have to do is write a function which satisfies the `hooks.EventHandler` type. At the moment, each handler can accept only **one** type of event. If you want to accept the `issue_comment` event, then you should be able to perform a successful type assertion:\n\n```go\nfunc MyIssueCommentHandler(context *ctx.Context, payload interface{}) error {\n    event, err := payload.(*github.IssueCommentEvent)\n    if err != nil {\n        return context.NewError("MyIssueCommentHandler: hm, didn\'t get an IssueCommentEvent: %v", err)\n    }\n\n    // Handle your issue comment event in a type-safe way here.\n}\n```\n\nThen you register that with your project. Taking the two examples above, you\'d add `MyIssueCommentHandler` to the `eventHandlers[hooks.IssueCommentEvent]` array:\n\n```go\neventHandlers := hooks.EventHandlerMap{}\neventHandlers.AddHandler(hooks.IssueCommentEvent, MyIssueCommentHandler)\n```\n\nAnd it should work!\n\n## Optional: Mark-and-sweep Stale Issues\n\nOne big issue we have in Jekyll is "stale" issues, that is, issues which were opened and abandoned after a few months of activity. The code in `cmd/mark-and-sweep-stale-issues` is still Jekyll-specific but I\'d love a PR which abstracts out the configuration into a file or something!\n\n## License\n\nThis code is licensed under BSD 3-clause as specified in the [LICENSE](LICENSE) file in this repository.\n'