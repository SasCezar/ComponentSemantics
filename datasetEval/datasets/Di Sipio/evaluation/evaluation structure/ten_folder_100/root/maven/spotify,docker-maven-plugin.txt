b'# docker-maven-plugin\n[![Build Status](https://travis-ci.com/spotify/docker-maven-plugin.svg?branch=master)](https://travis-ci.com/spotify/docker-maven-plugin)\n[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.spotify/docker-maven-plugin/badge.svg?style=flat-square)](https://maven-badges.herokuapp.com/maven-central/com.spotify/docker-maven-plugin/)\n[![License](https://img.shields.io/github/license/spotify/dockerfile-maven.svg)](LICENSE)\n\n\nA Maven plugin for building and pushing Docker images.\n\n## Status: inactive\n\n**We recommend you use [dockerfile-maven][] instead.**\n\n### The future of docker-maven-plugin\n\nThis plugin was the initial Maven plugin used at Spotify for building Docker\nimages out of Java services. It was initially created in 2014 when we first\nbegan experimenting with Docker. This plugin is capable of generating a\n`Dockerfile` for you based on configuration in the pom.xml file for things like\nthe `FROM` image, resources to add with `ADD`/`COPY`, etc.\n\nOver time at Spotify we have realized that the simplest way to build a Docker\nimage from a Java project is to have the developer write the `Dockerfile`.  The\nbehavior of this plugin around generating Dockerfiles, copying your project\ndirectory to a "staging" directory to use as the Docker build context, etc.,\nultimately led to a lot of unnecessary confusion with our users that stemmed\nfrom introducing extra abstractions and a need for configuration on top of what\nDocker is providing.\n\nThis led to the creation of a second Maven plugin for building docker images,\n[dockerfile-maven][], which we think offers a simpler mental model of working\nwith Docker from Maven, for all of the reasons outlined in dockerfile-maven\'s\nREADME.\n\n\n[dockerfile-maven]: https://github.com/spotify/dockerfile-maven\n* [The future of docker-maven-plugin](#the-future-of-docker-maven-plugin)\n* [Purpose](#purpose)\n* [Setup](#setup)\n  * [Specify build info in the POM](#specify-build-info-in-the-pom)\n  * [Use a Dockerfile](#use-a-dockerfile)\n* [Usage](#usage)\n  * [Bind Docker commands to Maven phases](#bind-docker-commands-to-maven-phases)\n  * [Using with Private Registries](#using-with-private-registries)\n  * [Authentication](#authentication)\n    * [Using encrypted passwords for authentication](#using-encrypted-passwords-for-authentication)\n* [Testing](#testing)\n* [Releasing](#releasing)\n* [Known Issues](#known-issues)\n\n\n## Purpose\n\nYou can use this plugin to create a Docker image with artifacts built from your Maven project. For\nexample, the build process for a Java service can output a Docker image that runs the service.\n\n## Setup\n\nYou can specify the base image, entry point, cmd, maintainer and files you want to add to your\nimage directly in the pom, without needing a separate `Dockerfile`.\nIf you need `VOLUME` command(or any other not supported dockerfile command), then you will need\nto create a `Dockerfile` and use the `dockerDirectory` element.\n\nBy default the plugin will try to connect to docker on localhost:2375. Set the DOCKER_HOST \nenvironment variable to connect elsewhere.\n\n    DOCKER_HOST=tcp://<host>:2375\n\nOther docker-standard environment variables are honored too such as TLS and certificates.\n\n### Specify build info in the POM\n\nThis example creates a new image named `example`, copies the project\'s jar file into the image,\nand sets an entrypoint which runs the jar. Change `VERSION GOES HERE` to the latest tagged version.\n\n    <build>\n      <plugins>\n        ...\n        <plugin>\n          <groupId>com.spotify</groupId>\n          <artifactId>docker-maven-plugin</artifactId>\n          <version>VERSION GOES HERE</version>\n          <configuration>\n            <imageName>example</imageName>\n            <baseImage>java</baseImage>\n            <entryPoint>["java", "-jar", "/${project.build.finalName}.jar"]</entryPoint>\n            <!-- copy the service\'s jar file from target into the root directory of the image --> \n            <resources>\n               <resource>\n                 <targetPath>/</targetPath>\n                 <directory>${project.build.directory}</directory>\n                 <include>${project.build.finalName}.jar</include>\n               </resource>\n            </resources>\n          </configuration>\n        </plugin>\n        ...\n      </plugins>\n    </build>\n\n### Use a Dockerfile\n\nTo use a `Dockerfile`, you must specify the `dockerDirectory` element. If specified, the \n`baseImage`, `maintainer`, `cmd` and `entryPoint` elements will be ignored. The contents of the\n`dockerDirectory` will be copied into `${project.build.directory}/docker`. Use the `resources`\nelement to copy additional files, such as the service\'s jar file.\n\n    <build>\n      <plugins>\n        ...\n        <plugin>\n          <groupId>com.spotify</groupId>\n          <artifactId>docker-maven-plugin</artifactId>\n          <version>VERSION GOES HERE</version>\n          <configuration>\n            <imageName>example</imageName>\n            <dockerDirectory>docker</dockerDirectory>\n            <resources>\n               <resource>\n                 <targetPath>/</targetPath>\n                 <directory>${project.build.directory}</directory>\n                 <include>${project.build.finalName}.jar</include>\n               </resource>\n            </resources>\n          </configuration>\n        </plugin>\n        ...\n      </plugins>\n    </build>\n\n## Usage\n\nYou can build an image with the above configurations by running this command.\n\n    mvn clean package docker:build\n\nTo push the image you just built to the registry, specify the `pushImage` flag.\n\n    mvn clean package docker:build -DpushImage\n\nTo push only specific tags of the image to the registry, specify the `pushImageTag` flag.\n\n    mvn clean package docker:build -DpushImageTag\n\nIn order for this to succeed, at least one imageTag must be present in the config, multiple tags can be used.\n\n    <build>\n      <plugins>\n        ...\n        <plugin>\n          <configuration>\n            ...\n            <imageTags>\n               <imageTag>${project.version}</imageTag>\n               <imageTag>latest</imageTag>\n            </imageTags>\n          </configuration>\n        </plugin>\n        ...\n      </plugins>\n    </build>\n\nOptionally, you can force docker to overwrite your image tags on each new build:\n\n    <build>\n      <plugins>\n        ...\n        <plugin>\n          <configuration>\n            ...\n            <!-- optionally overwrite tags every time image is built with docker:build -->\n            <forceTags>true</forceTags>\n            <imageTags>\n               ...\n            </imageTags>\n          </configuration>\n        </plugin>\n        ...\n      </plugins>\n    </build>\n\nTags-to-be-pushed can also be specified directly on the command line with\n\n    mvn ... docker:build -DpushImageTag -DdockerImageTags=latest,another-tag\n\n### Bind Docker commands to Maven phases\n\nYou can also bind the build, tag & push goals to the Maven phases, so the container will be built, tagged and pushed \nwhen you run just `mvn deploy`. If you have a multi-module project where a sub-module builds an image, you\nwill need to do this binding so the image gets built when maven is run from the parent project. \n\n    <plugin>\n      <groupId>com.spotify</groupId>\n      <artifactId>docker-maven-plugin</artifactId>\n      <version>VERSION GOES HERE</version>\n      <executions>\n        <execution>\n          <id>build-image</id>\n          <phase>package</phase>\n          <goals>\n            <goal>build</goal>\n          </goals>\n        </execution>\n        <execution>\n          <id>tag-image</id>\n          <phase>package</phase>\n          <goals>\n            <goal>tag</goal>\n          </goals>\n          <configuration>\n            <image>my-image:${project.version}</image>\n            <newName>registry.example.com/my-image:${project.version}</newName>\n          </configuration>\n        </execution>\n        <execution>\n          <id>push-image</id>\n          <phase>deploy</phase>\n          <goals>\n            <goal>push</goal>\n          </goals>\n          <configuration>\n            <imageName>registry.example.com/my-image:${project.version}</imageName>\n          </configuration>\n        </execution>        \n      </executions>\n    </plugin>\n\nYou can skip Docker goals bound to Maven phases with:\n\n* `-DskipDockerBuild` to skip image build\n* `-DskipDockerTag` to skip image tag\n* `-DskipDockerPush` to skip image push\n* `-DskipDocker` to skip any Docker goals\n\nTo remove the image named `foobar` run the following command:\n\n    mvn docker:removeImage -DimageName=foobar\n\nFor a complete list of configuration options run:\n`mvn com.spotify:docker-maven-plugin:<version>:help -Ddetail=true`\n\n### Using with Private Registries\n\nTo push an image to a private registry, Docker requires that the image tag\nbeing pushed is prefixed with the hostname and port of the registry. For\nexample to push `my-image` to `registry.example.com`, the image needs to be\ntagged as `registry.example.com/my-image`.\n\nThe simplest way to do this with docker-maven-plugin is to put the registry\nname in the `<imageName>` field, for example\n\n```xml\n<plugin>\n  <groupId>com.spotify</groupId>\n  <artifactId>docker-maven-plugin</artifactId>\n  <configuration>\n    <imageName>registry.example.com/my-image</imageName>\n    ...\n```\n\nThen when pushing the image with either `docker:build -DpushImage` or\n`docker:push`, the docker daemon will push to `registry.example.com`.\n\nAlternatively, if you wish to use a short name in `docker:build` you can use\n`docker:tag -DpushImage` to tag the just-built image with the full registry\nhostname and push it. It\'s important to use the `pushImage` flag as using\n`docker:push` independently will attempt to push the original image.\n\nFor example:\n\n```xml\n<plugin>\n  <groupId>com.spotify</groupId>\n  <artifactId>docker-maven-plugin</artifactId>\n  <configuration>\n    <imageName>my-image</imageName>\n    ...\n  </configuration>\n  <executions>\n    <execution>\n      <id>build-image</id>\n      <phase>package</phase>\n      <goals>\n        <goal>build</goal>\n      </goals>\n    </execution>\n    <execution>\n      <id>tag-image</id>\n      <phase>package</phase>\n      <goals>\n        <goal>tag</goal>\n      </goals>\n      <configuration>\n        <image>my-image</image>\n        <newName>registry.example.com/my-image</newName>\n      </configuration>\n    </execution>\n  </executions>\n</plugin>\n```\n\n### Authentication\n\nSince version 1.0.0, the docker-maven-plugin will automatically use any\nauthentication present in the docker-cli configuration file at `~/.dockercfg`\nor `~/.docker/config.json`, without the need to configure anything (in earlier\nversions of the plugin this behavior had to be enabled with\n`<useConfigFile>true</useConfigFile>`, but now it is always active).\n\nAdditionally the plugin will enable support for Google Container Registry if it\nis able to successfully load [Google\'s "Application Default Credentials"][ADC].\nThe plugin will also load Google credentials from the file pointed to by the\nenvironment variable `DOCKER_GOOGLE_CREDENTIALS` if it is defined. Since GCR\nauthentication requires retrieving short-lived access codes for the given\ncredentials, support for this registry is baked into the underlying\ndocker-client rather than having to first populate the docker config file\nbefore running the plugin.\n\n[ADC]: https://developers.google.com/identity/protocols/application-default-credentials\n\nLastly, authentication credentials can be explicitly configured in your pom.xml\nand in your Maven installation\'s `settings.xml` file as part of the\n`<servers></servers>` block.\n\n    <servers>\n      <server>\n        <id>docker-hub</id>\n        <username>foo</username>\n        <password>secret-password</password>\n        <configuration>\n          <email>foo@foo.bar</email>\n        </configuration>\n      </server>\n    </servers>\n\nNow use the server id in your project `pom.xml`.\n\n    <plugin>\n      <plugin>\n        <groupId>com.spotify</groupId>\n        <artifactId>docker-maven-plugin</artifactId>\n        <version>VERSION GOES HERE</version>\n        <configuration>\n          [...]\n          <serverId>docker-hub</serverId>\n          <registryUrl>https://index.docker.io/v1/</registryUrl>\n        </configuration>\n      </plugin>\n    </plugins>\n\nThe plugin gives priority to any credentials in the docker-cli config file\nbefore explicitly configured credentials.\n\n#### Using encrypted passwords for authentication\n\nCredentials can be encrypted using [Maven\'s built in encryption function.](https://maven.apache.org/guides/mini/guide-encryption.html)\nOnly passwords enclosed in curly braces will be considered as encrypted.\n\n    <servers>\n      <server>\n        <id>docker-hub</id>\n        <username>foo</username>\n        <password>{gc4QPLrlgPwHZjAhPw8JPuGzaPitzuyjeBojwCz88j4=}</password>\n      </server>\n    </servers>\n\n## Testing\n\nMake sure Docker daemon is running and that you can do `docker ps`. Then run `mvn clean test`.\n\n## Releasing\n\nCommits to the master branch will trigger our continuous integration agent to build the jar and\nrelease by uploading to Sonatype. If you are a project maintainer with the necessary credentials,\nyou can also build and release locally by running the below.\n\n```sh\nmvn release:clean\nmvn release:prepare\nmvn release:perform\n```\n\n## Known Issues\n\n### Exception caught: system properties: docker has type STRING rather than OBJECT\n\nBecause the plugin uses Maven properties named like\n`docker.build.defaultProfile`, if you declare any other Maven property with the\nname `docker` you will get a rather strange-looking error from Maven:\n\n```\n[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.0.21:build (default) on project <....>: \nException caught: system properties: docker has type STRING rather than OBJECT\n```\n\nTo fix this, rename the `docker` property in your pom.xml.\n\n### InternalServerErrorException: HTTP 500 Internal Server Error\n\nProblem: when building the Docker image, Maven outputs an exception with a\nstacktrace like:\n\n> Caused by: com.spotify.docker.client.shaded.javax.ws.rs.InternalServerErrorException: HTTP 500 Internal Server Error\n\ndocker-maven-plugin communicates with your local Docker daemon using the HTTP\nRemote API and any unexpected errors that the daemon encounters will be\nreported as `500 Internal Server Error`.\n\nCheck the Docker daemon log (typically at `/var/log/docker.log` or\n`/var/log/upstart/docker.log`) for more details.\n\n#### Invalid repository name ... only [a-z0-9-\\_.] are allowed\n\nOne common cause of `500 Internal Server Error` is attempting to build an image\nwith a repository name containing uppercase characters, such as if the\n`<imageName>` in the plugin\'s configuration refers to `${project.version}` when\nthe Maven project version is ending in `SNAPSHOT`.\n\nConsider putting the project version in an image tag (instead of repository\nname) with the `<dockerImageTags>` configuration option instead.\n'