b'# rules_jvm_external\n\nTransitive Maven artifact resolver as a repository rule.\n\n[![Build\nStatus](https://badge.buildkite.com/26d895f5525652e57915a607d0ecd3fc945c8280a0bdff83d9.svg?branch=master)](https://buildkite.com/bazel/rules-jvm-external)\n\n## Features\n\n* WORKSPACE configuration\n* JAR, AAR, source JARs\n* Custom Maven repositories\n* Private Maven repositories with HTTP Basic Authentication\n* Artifact version resolution with Coursier\n* Integration with Bazel\'s downloader and caching mechanisms for sharing artifacts across Bazel workspaces\n* Pin resolved artifacts with their SHA-256 checksums into a version-controllable JSON file\n* Versionless target labels for simpler dependency management\n* Ability to declare multiple sets of versioned artifacts\n* Supported on Windows, macOS, Linux\n\nGet the [latest release\nhere](https://github.com/bazelbuild/rules_jvm_external/releases/latest).\n\n## Usage\n\nList the top-level Maven artifacts and servers in the WORKSPACE:\n\n```python\nload("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")\n\nRULES_JVM_EXTERNAL_TAG = "2.10"\nRULES_JVM_EXTERNAL_SHA = "1bbf2e48d07686707dd85357e9a94da775e1dbd7c464272b3664283c9c716d26"\n\nhttp_archive(\n    name = "rules_jvm_external",\n    strip_prefix = "rules_jvm_external-%s" % RULES_JVM_EXTERNAL_TAG,\n    sha256 = RULES_JVM_EXTERNAL_SHA,\n    url = "https://github.com/bazelbuild/rules_jvm_external/archive/%s.zip" % RULES_JVM_EXTERNAL_TAG,\n)\n\nload("@rules_jvm_external//:defs.bzl", "maven_install")\n\nmaven_install(\n    artifacts = [\n        "junit:junit:4.12",\n        "androidx.test.espresso:espresso-core:3.1.1",\n        "org.hamcrest:hamcrest-library:1.3",\n    ],\n    repositories = [\n        # Private repositories are supported through HTTP Basic auth\n        "http://username:password@localhost:8081/artifactory/my-repository",\n        "https://jcenter.bintray.com/",\n        "https://maven.google.com",\n        "https://repo1.maven.org/maven2",\n    ],\n)\n```\n\nCredentials for private repositories can also be specified using a property file\nor environment variables. See the [Coursier\ndocumentation](https://get-coursier.io/docs/other-credentials.html#property-file)\nfor more information.\n\nNext, reference the artifacts in the BUILD file with their versionless label:\n\n```python\njava_library(\n    name = "java_test_deps",\n    exports = [\n        "@maven//:junit_junit"\n        "@maven//:org_hamcrest_hamcrest_library",\n    ],\n)\n\nandroid_library(\n    name = "android_test_deps",\n    exports = [\n        "@maven//:junit_junit"\n        "@maven//:androidx_test_espresso_espresso_core",\n    ],\n)\n```\n\nThe default label syntax for an artifact `foo.bar:baz-qux:1.2.3` is `@maven//:foo_bar_baz_qux`. That is, \n\n* All non-alphanumeric characters are substituted with underscores.\n* Only the group and artifact IDs are required.\n* The target is located in the `@maven` top level package (`@maven//`).\n\n## API Reference\n\nYou can find the complete API reference at [docs/api.md](docs/api.md).\n\n## Pinning artifacts and integration with Bazel\'s downloader\n\n`rules_jvm_external` supports pinning artifacts and their SHA-256 checksums into\na `maven_install.json` file that can be checked into your repository. \n\nWithout artifact pinning, in a clean checkout of your project, `rules_jvm_external` \nexecutes the full artifact resolution and fetching steps (which can take a bit of time) \nand does not verify the integrity of the artifacts against their checksums. The \ndownloaded artifacts also cannot be shared across Bazel workspaces.\n\nBy pinning artifact versions, you can get improved artifact resolution and build times,\nsince using `maven_install.json` enables `rules_jvm_external` to integrate with Bazel\'s \ndownloader that caches files on their sha256 checksums. It also improves resiliency and\nintegrity by tracking the sha256 checksums and original artifact urls in the\nJSON file.\n\nSince all artifacts are persisted locally in Bazel\'s cache, it means that\n**fully offline builds are possible** after the initial `bazel fetch @maven//...`.\n\nTo get started with pinning artifacts, run the following command to generate the\ninitial `maven_install.json` at the root of your Bazel workspace:\n\n```\n$ bazel run @maven//:pin\n```\n\nThen, specify `maven_install_json` in `maven_install` and load\n`pinned_maven_install` from `@maven//:defs.bzl`:\n\n```python\nmaven_install(\n    # artifacts, repositories, ...\n    maven_install_json = "//:maven_install.json",\n)\n\nload("@maven//:defs.bzl", "pinned_maven_install")\npinned_maven_install()\n```\n\n**Note:** The `//:maven_install.json` label assumes you have a BUILD file in\nyour project\'s root directory. If you do not have one, create an empty BUILD\nfile to fix issues you may see. See\n[#242](https://github.com/bazelbuild/rules_jvm_external/issues/242)\n\n### Updating `maven_install.json`\n\nWhenever you make a change to the list of `artifacts` or `repositories` and want\nto update `maven_install.json`, run this command to re-pin the unpinned `@maven`\nrepository:\n\n```\n$ bazel run @unpinned_maven//:pin\n```\n\nWithout re-pinning, `maven_install` will not pick up the changes made to the\nWORKSPACE, as `maven_install.json` is now the source of truth.\n\nNote that the repository is `@unpinned_maven` instead of `@maven`. When using\nartifact pinning, each `maven_install` repository (e.g. `@maven`) will be\naccompanied by an unpinned repository. This repository name has the `@unpinned_`\nprefix (e.g.`@unpinned_maven` or `@unpinned_<your_maven_install_name>`). For\nexample, if your `maven_install` is named `@foo`, `@unpinned_foo` will be\ncreated.\n\n### Custom location for `maven_install.json`\n\nYou can specify a custom location for `maven_install.json` by changing the\n`maven_install_json` attribute value to point to the new file label. For example:\n\n```python\nmaven_install(\n    name = "maven_install_in_custom_location",\n    artifacts = ["com.google.guava:guava:27.0-jre"],\n    repositories = ["https://repo1.maven.org/maven2"],\n    maven_install_json = "@rules_jvm_external//tests/custom_maven_install:maven_install.json",\n)\n\nload("@maven_install_in_custom_location//:defs.bzl", "pinned_maven_install")\npinned_maven_install()\n```\n\nFuture artifact pinning updates to `maven_install.json` will overwrite the file\nat the specified path instead of creating a new one at the default root\ndirectory location.\n\n### Multiple `maven_install.json` files\n\nIf you have multiple `maven_install` declarations, you have to alias \n`pinned_maven_install` to another name to prevent redefinitions:\n\n```python\nmaven_install(\n    name = "foo",\n    maven_install_json = "//:foo_maven_install.json",\n    # ...\n)\n\nload("@foo//:defs.bzl", foo_pinned_maven_install = "pinned_maven_install")\nfoo_pinned_maven_install()\n\nmaven_install(\n    name = "bar",\n    maven_install_json = "//:bar_maven_install.json",\n    # ...\n)\n\nload("@bar//:defs.bzl", bar_pinned_maven_install = "pinned_maven_install")\nbar_pinned_maven_install()\n```\n\n## Generated targets\n\nFor the `junit:junit` example, using `bazel query @maven//:all --output=build`, we can see that the rule generated these targets:\n\n```python\nalias(\n  name = "junit_junit_4_12",\n  actual = "@maven//:junit_junit",\n)\n\njvm_import(\n  name = "junit_junit",\n  jars = ["@maven//:https/repo1.maven.org/maven2/junit/junit/4.12/junit-4.12.jar"],\n  srcjar = "@maven//:https/repo1.maven.org/maven2/junit/junit/4.12/junit-4.12-sources.jar",\n  deps = ["@maven//:org_hamcrest_hamcrest_core"],\n  tags = ["maven_coordinates=junit:junit:4.12"],\n)\n\njvm_import(\n  name = "org_hamcrest_hamcrest_core",\n  jars = ["@maven//:https/repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar"],\n  srcjar = "@maven//:https/repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3-sources.jar",\n  deps = [],\n  tags = ["maven_coordinates=org.hamcrest:hamcrest.library:1.3"],\n)\n```\n\nThese targets can be referenced by:\n\n*   `@maven//:junit_junit`\n*   `@maven//:org_hamcrest_hamcrest_core`\n\n**Transitive classes**: To use a class from `hamcrest-core` in your test, it\'s not sufficient to just \ndepend on `@maven//:junit_junit` even though JUnit depends on Hamcrest. The compile classes are not exported \ntransitively, so your test should also depend on `@maven//:org_hamcrest_hamcrest_core`.\n\n**Original coordinates**: The generated `tags` attribute value also contains the original coordinates of\nthe artifact, which integrates with rules like [bazel-common\'s\n`pom_file`](https://github.com/google/bazel-common/blob/f1115e0f777f08c3cdb115526c4e663005bec69b/tools/maven/pom_file.bzl#L177)\nfor generating POM files. See the [`pom_file_generation`\nexample](examples/pom_file_generation/) for more information.\n\n## Advanced usage\n\n### Fetch source JARs\n\nTo download the source JAR alongside the main artifact JAR, set `fetch_sources =\nTrue` in `maven_install`:\n\n```python\nmaven_install(\n    artifacts = [\n        # ...\n    ],\n    repositories = [\n        # ...\n    ],\n    fetch_sources = True,\n)\n```\n\n### Checksum verification\n\nArtifact resolution will fail if a `SHA-1` or `MD5` checksum file for the\nartifact is missing in the repository. To disable this behavior, set\n`fail_on_missing_checksum = False` in `maven_install`:\n\n```python\nmaven_install(\n    artifacts = [\n        # ...\n    ],\n    repositories = [\n        # ...\n    ],\n    fail_on_missing_checksum = False,\n)\n```\n\n### Using a persistent artifact cache\n\n> NOTE: Prefer using artifact pinning / maven_install.json instead. This\n> is a caching mechanism that was implemented before artifact pinning,\n> which uses Coursier\'s own persistent cache. With artifact pinning and\n> maven_install.json, the persistent cache is integrated directly into\n> Bazel\'s own cache.\n\nTo download artifacts into a shared and persistent directory in your home\ndirectory, set `use_unsafe_shared_cache = True` in `maven_install`.\n\n```python\nmaven_install(\n    artifacts = [\n        # ...\n    ],\n    repositories = [\n        # ...\n    ],\n    use_unsafe_shared_cache = True,\n)\n```\n\nThis is **not safe** as Bazel is currently not able to detect changes in the\nshared cache. For example, if an artifact is deleted from the shared cache,\nBazel will not re-run the repository rule automatically.\n\nThe default value of `use_unsafe_shared_cache` is `False`. This means that Bazel\nwill create independent caches for each `maven_install` repository, located at\n`$(bazel info output_base)/external/@repository_name/v1`.\n\n### `artifact` helper macro\n\nThe `artifact` macro translates the artifact\'s `group:artifact` coordinates to\nthe label of the versionless target. This target is an\n[alias](https://docs.bazel.build/versions/master/be/general.html#alias) that\npoints to the `java_import`/`aar_import` target in the `@maven` repository,\nwhich includes the transitive dependencies specified in the top level artifact\'s\nPOM file.\n\nFor example, `@maven//:junit_junit` is equivalent to `artifact("junit:junit")`.\n\nTo use it, add the load statement to the top of your BUILD file:\n\n```python\nload("@rules_jvm_external//:defs.bzl", "artifact")\n```\n\nNote that usage of this macro makes BUILD file refactoring with tools like\n`buildozer` more difficult, because the macro hides the actual target label at\nthe syntax level.\n\n### Multiple `maven_install` declarations for isolated artifact version trees\n\nIf your WORKSPACE contains several projects that use different versions of the\nsame artifact, you can specify multiple `maven_install` declarations in the\nWORKSPACE, with a unique repository name for each of them.\n\nFor example, if you want to use the JRE version of Guava for a server app, and\nthe Android version for an Android app, you can specify two `maven_install`\ndeclarations:\n\n```python\nmaven_install(\n    name = "server_app",\n    artifacts = [\n        "com.google.guava:guava:27.0-jre",\n    ],\n    repositories = [\n        "https://repo1.maven.org/maven2",\n    ],\n)\n\nmaven_install(\n    name = "android_app",\n    artifacts = [\n        "com.google.guava:guava:27.0-android",\n    ],\n    repositories = [\n        "https://repo1.maven.org/maven2",\n    ],\n)\n```\n\nThis way, `rules_jvm_external` will invoke coursier to resolve artifact versions for\nboth repositories independent of each other. Coursier will fail if it encounters\nversion conflicts that it cannot resolve. The two Guava targets can then be used\nin BUILD files like so:\n\n```python\njava_binary(\n    name = "my_server_app",\n    srcs = ...\n    deps = [\n        # a versionless alias to @server_app//:com_google_guava_guava_27_0_jre\n        "@server_app//:com_google_guava_guava",\n    ]\n)\n\nandroid_binary(\n    name = "my_android_app",\n    srcs = ...\n    deps = [\n        # a versionless alias to @android_app//:com_google_guava_guava_27_0_android\n        "@android_app//:com_google_guava_guava",\n    ]\n)\n```\n\n### Detailed dependency information specifications\n\nAlthough you can always give a dependency as a Maven coordinate string,\noccasionally special handling is required in the form of additional directives\nto properly situate the artifact in the dependency tree. For example, a given\nartifact may need to have one of its dependencies excluded to prevent a\nconflict.\n\nThis situation is provided for by allowing the artifact to be specified as a map\ncontaining all of the required information. This map can express more\ninformation than the coordinate strings can, so internally the coordinate\nstrings are parsed into the artifact map with default values for the additional\nitems. To assist in generating the maps, you can pull in the file `specs.bzl`\nalongside `defs.bzl` and import the `maven` struct, which provides several\nhelper functions to assist in creating these maps. An example:\n\n```python\nload("@rules_jvm_external//:defs.bzl", "artifact")\nload("@rules_jvm_external//:specs.bzl", "maven")\n\nmaven_install(\n    artifacts = [\n        maven.artifact(\n            group = "com.google.guava",\n            artifact = "guava",\n            version = "27.0-android",\n            exclusions = [\n                ...\n            ]\n        ),\n        "junit:junit:4.12",\n        ...\n    ],\n    repositories = [\n        maven.repository(\n            "https://some.private.maven.re/po",\n            user = "johndoe",\n            password = "example-password"\n        ),\n        "https://repo1.maven.org/maven2",\n        ...\n    ],\n)\n```\n\n### Artifact exclusion\n\nIf you want to exclude an artifact from the transitive closure of a top level\nartifact, specify its `group-id:artifact-id` in the `exclusions` attribute of\nthe `maven.artifact` helper:\n\n```python\nload("@rules_jvm_external//:specs.bzl", "maven")\n\nmaven_install(\n    artifacts = [\n        maven.artifact(\n            group = "com.google.guava",\n            artifact = "guava",\n            version = "27.0-jre",\n            exclusions = [\n                maven.exclusion(\n                    group = "org.codehaus.mojo",\n                    artifact = "animal-sniffer-annotations"\n                ),\n                "com.google.j2objc:j2objc-annotations",\n            ]\n        ),\n        # ...\n    ],\n    repositories = [\n        # ...\n    ],\n)\n```\n\nYou can specify the exclusion using either the `maven.exclusion` helper or the\n`group-id:artifact-id` string directly.\n\nYou can also exclude artifacts globally using the `excluded_artifacts`\nattribute in `maven_install`:\n\n\n```python\nmaven_install(\n    artifacts = [\n        # ...\n    ],\n    repositories = [\n        # ...\n    ],\n    excluded_artifacts = [\n        "com.google.guava:guava",\n    ],\n)\n```\n\n### Compile-only dependencies\n\nIf you want to mark certain artifacts as compile-only dependencies, use the\n`neverlink` attribute in the `maven.artifact` helper:\n\n```python\nload("@rules_jvm_external//:specs.bzl", "maven")\n\nmaven_install(\n    artifacts = [\n        maven.artifact("com.squareup", "javapoet", "1.11.0", neverlink = True),\n    ],\n    # ...\n)\n```\n\nThis instructs `rules_jvm_external` to mark the generated target for\n`com.squareup:javapoet` with the `neverlink = True` attribute, making the\nartifact available only for compilation and not at runtime.\n\n### Resolving user-specified and transitive dependency version conflicts\n\nUse the `version_conflict_policy` attribute to decide how to resolve conflicts\nbetween artifact versions specified in your `maven_install` rule and those\nimplicitly picked up as transitive dependencies.\n\nThe attribute value can be either `default` or `pinned`. \n\n`default`: use [Coursier\'s default algorithm](https://get-coursier.io/docs/other-version-handling) \nfor version handling.\n\n`pinned`: pin the versions of the artifacts that are explicitly specified in `maven_install`.\n\nFor example, pulling in guava transitively via google-cloud-storage resolves to \nguava-26.0-android.\n\n```python\nmaven_install(\n    name = "pinning",\n    artifacts = [\n        "com.google.cloud:google-cloud-storage:1.66.0",\n    ],\n    repositories = [\n        "https://repo1.maven.org/maven2",\n    ]\n)\n```\n\n```\n$ bazel query @pinning//:all | grep guava_guava\n@pinning//:com_google_guava_guava\n@pinning//:com_google_guava_guava_26_0_android\n```\n\nPulling in guava-27.0-android directly works as expected.\n\n```python\nmaven_install(\n    name = "pinning",\n    artifacts = [\n        "com.google.cloud:google-cloud-storage:1.66.0",\n        "com.google.guava:guava:27.0-android",\n    ],\n    repositories = [\n        "https://repo1.maven.org/maven2",\n    ]\n)\n```\n\n```\n$ bazel query @pinning//:all | grep guava_guava\n@pinning//:com_google_guava_guava\n@pinning//:com_google_guava_guava_27_0_android\n```\n\nPulling in guava-25.0-android (a lower version), resolves to guava-26.0-android. This is the default version conflict policy in action, where artifacts are resolved to the highest version.\n\n```python\nmaven_install(\n    name = "pinning",\n    artifacts = [\n        "com.google.cloud:google-cloud-storage:1.66.0",\n        "com.google.guava:guava:25.0-android",\n    ],\n    repositories = [\n        "https://repo1.maven.org/maven2",\n    ]\n)\n```\n\n```\n$ bazel query @pinning//:all | grep guava_guava\n@pinning//:com_google_guava_guava\n@pinning//:com_google_guava_guava_26_0_android\n```\n\nNow, if we add `version_conflict_policy = "pinned"`, we should see guava-25.0-android getting pulled instead. The rest of non-specified artifacts still resolve to the highest version in the case of version conflicts.\n\n```python\nmaven_install(\n    name = "pinning",\n    artifacts = [\n        "com.google.cloud:google-cloud-storage:1.66.0",\n        "com.google.guava:guava:25.0-android",\n    ],\n    repositories = [\n        "https://repo1.maven.org/maven2",\n    ]\n    version_conflict_policy = "pinned",\n)\n```\n\n```\n$ bazel query @pinning//:all | grep guava_guava\n@pinning//:com_google_guava_guava\n@pinning//:com_google_guava_guava_25_0_android\n```\n\n### Overriding generated targets\n\nYou can override the generated targets for artifacts with a target label of your\nchoice. For instance, if you want to provide your own definition of\n`@maven//:com_google_guava_guava` at `//third_party/guava:guava`, specify the\nmapping in the `override_targets` attribute:\n\n```python\nmaven_install(\n    name = "pinning",\n    artifacts = [\n        "com.google.guava:guava:27.0-jre",\n    ],\n    repositories = [\n        "https://repo1.maven.org/maven2",\n    ],\n    override_targets = {\n        "com.google.guava:guava": "@//third_party/guava:guava",\n    },\n)\n```\n\nNote that the target label contains `@//`, which tells Bazel to reference the\ntarget relative to your main workspace, instead of the `@maven` workspace.\n\n### Proxies\n\nAs with other Bazel repository rules, the standard `http_proxy`, `https_proxy`\nand `no_proxy` environment variables (and their uppercase counterparts) are\nsupported.\n\n### Repository aliases\n\nMaven artifact rules like `maven_jar` and `jvm_import_external` generate targets\nlabels in the form of `@group_artifact//jar`, like `@com_google_guava_guava//jar`. This\nis different from the `@maven//:group_artifact` naming style used in this project.\n\nAs some Bazel projects depend on the `@group_artifact//jar` style labels, we\nprovide a `generate_compat_repositories` attribute in `maven_install`. If\nenabled, JAR artifacts can also be referenced using the `@group_artifact//jar`\ntarget label. For example, `@maven//:com_google_guava_guava` can also be\nreferenced using `@com_google_guava_guava//jar`.\n\nThe artifacts can also be referenced using the style used by\n`java_import_external` as `@group_artifact//:group_artifact` or\n`@group_artifact` for short.\n\n```python\nmaven_install(\n    artifacts = [\n        # ...\n    ],\n    repositories = [\n        # ...\n    ],\n    generate_compat_repositories = True\n)\n\nload("@maven//:compat.bzl", "compat_repositories")\ncompat_repositories()\n```\n\n#### Repository remapping\n\nIf the `maven_jar` or `jvm_import_external` is not named according to `rules_jvm_external`\'s \nconventions, you can apply\n[repository remapping](https://docs.bazel.build/versions/master/external.html#shadowing-dependencies)\nfrom the expected name to the new name for compatibility.\n\nFor example, if an external dependency uses `@guava//jar`, and `rules_jvm_external` \ngenerates `@com_google_guava_guava//jar`, apply the `repo_mapping` attribute to the external \nrepository WORKSPACE rule, like `http_archive` in this example:\n\n```python\nhttp_archive(\n    name = "my_dep",\n    repo_mapping = {\n        "@guava": "@com_google_guava_guava",\n    }\n    # ...\n)\n```\n\nWith `repo_mapping`, all references to `@guava//jar` in `@my_dep`\'s BUILD files will be mapped \nto `@com_google_guava_guava//jar` instead.\n\n### Hiding transitive dependencies\n\nAs a convenience, transitive dependencies are visible to your build rules.\nHowever, this can lead to surprises when updating `maven_install`\'s `artifacts`\nlist, since doing so may eliminate transitive dependencies from the build\ngraph.  To force rule authors to explicitly declare all directly referenced\nartifacts, use the `strict_visibility` attribute in `maven_install`:\n\n```python\nmaven_install(\n    artifacts = [\n        # ...\n    ],\n    repositories = [\n        # ...\n    ],\n    strict_visibility = True\n)\n```\n\n### Fetch and resolve timeout\n\nThe default timeout to fetch and resolve artifacts is 600 seconds.  If you need\nto change this to resolve a large number of artifacts you can set the\n`resolve_timeout` attribute in `maven_install`:\n\n```python\nmaven_install(\n    artifacts = [\n        # ...\n    ],\n    repositories = [\n        # ...\n    ],\n    resolve_timeout = 900\n)\n```\n\n## Exporting and consuming artifacts from external repositories\n\nIf you\'re writing a library that has dependencies, you should define a constant that\nlists all of the artifacts that your library requires. For example:\n\n```python\n# my_library/BUILD\n# Public interface of the library\njava_library(\n  name = "my_interface",\n  deps = [\n    "@maven//:junit_junit",\n    "@maven//:com_google_inject_guice",\n  ],\n)\n```\n\n```python\n# my_library/library_deps.bzl\n# All artifacts required by the library\nMY_LIBRARY_ARTIFACTS = [\n  "junit:junit:4.12",\n  "com.google.inject:guice:4.0",\n]\n```\n\nUsers of your library can then load the constant in their `WORKSPACE` and add the\nartifacts to their `maven_install`. For example:\n\n```python\n# user_project/WORKSPACE\nload("@my_library//:library_deps.bzl", "MY_LIBRARY_ARTIFACTS")\n\nmaven_install(\n  artifacts = [\n        "junit:junit:4.11",\n        "com.google.guava:guava:26.0-jre",\n  ] + MY_LIBRARY_ARTIFACTS,\n)\n```\n\n```python\n# user_project/BUILD\njava_library(\n  name = "user_lib",\n  deps = [\n    "@my_library//:my_interface",\n    "@maven//:junit_junit",\n  ],\n)\n```\n\nAny version conflicts or duplicate artifacts will resolved automatically.\n\n## Demo\n\nYou can find demos in the [`examples/`](./examples/) directory.\n\n## Projects using rules_jvm_external\n\nFind other GitHub projects using `rules_jvm_external` \n[with this search query](https://github.com/search?p=1&q=rules_jvm_external+filename%3A%2FWORKSPACE+filename%3A%5C.bzl&type=Code).\n\n## Generating documentation\n\nUse [Stardoc](https://skydoc.bazel.build/docs/getting_started_stardoc.html) to\ngenerate API documentation in the [docs](docs/) directory using\n[generate_docs.sh](scripts/generate_docs.sh). \n\nNote that this script has a dependency on the `doctoc` NPM package to automate\ngenerating the table of contents. Install it with `npm -g i doctoc`.\n'