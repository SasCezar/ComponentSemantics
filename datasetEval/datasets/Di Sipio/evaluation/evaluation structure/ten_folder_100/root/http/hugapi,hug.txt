b'[![HUG](https://raw.github.com/hugapi/hug/develop/artwork/logo.png)](http://hug.rest)\n===================\n\n[![PyPI version](https://badge.fury.io/py/hug.svg)](http://badge.fury.io/py/hug)\n[![Build Status](https://travis-ci.org/hugapi/hug.svg?branch=develop)](https://travis-ci.org/hugapi/hug)\n[![Windows Build Status](https://ci.appveyor.com/api/projects/status/0h7ynsqrbaxs7hfm/branch/master?svg=true)](https://ci.appveyor.com/project/TimothyCrosley/hug)\n[![Coverage Status](https://coveralls.io/repos/hugapi/hug/badge.svg?branch=develop&service=github)](https://coveralls.io/github/hugapi/hug?branch=master)\n[![License](https://img.shields.io/github/license/mashape/apistatus.svg)](https://pypi.python.org/pypi/hug/)\n[![Join the chat at https://gitter.im/timothycrosley/hug](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/timothycrosley/hug?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n_________________\n\n[Read Latest Documentation](https://hugapi.github.io/hug/) - [Browse GitHub Code Repository](https://github.com/hugapi/hug)\n_________________\n\nhug aims to make developing Python driven APIs as simple as possible, but no simpler. As a result, it drastically simplifies Python API development.\n\nhug\'s Design Objectives:\n\n- Make developing a Python driven API as succinct as a written definition.\n- The framework should encourage code that self-documents.\n- It should be fast. A developer should never feel the need to look somewhere else for performance reasons.\n- Writing tests for APIs written on-top of hug should be easy and intuitive.\n- Magic done once, in an API framework, is better than pushing the problem set to the user of the API framework.\n- Be the basis for next generation Python APIs, embracing the latest technology.\n\nAs a result of these goals, hug is Python 3+ only and built upon [Falcon\'s](https://github.com/falconry/falcon) high performance HTTP library\n\n[![HUG Hello World Example](https://raw.github.com/hugapi/hug/develop/artwork/example.gif)](https://github.com/hugapi/hug/blob/develop/examples/hello_world.py)\n\nSupporting hug development\n===================\n[Get professionally supported hug with the Tidelift Subscription](https://tidelift.com/subscription/pkg/pypi-hug?utm_source=pypi-hug&utm_medium=referral&utm_campaign=readme)\n\nProfessional support for hug is available as part of the [Tidelift\nSubscription](https://tidelift.com/subscription/pkg/pypi-hug?utm_source=pypi-hug&utm_medium=referral&utm_campaign=readme).\nTidelift gives software development teams a single source for\npurchasing and maintaining their software, with professional grade assurances\nfrom the experts who know it best, while seamlessly integrating with existing\ntools.\n\nInstalling hug\n===================\n\nInstalling hug is as simple as:\n\n```bash\npip3 install hug --upgrade\n```\n\nIdeally, within a [virtual environment](http://docs.python-guide.org/en/latest/dev/virtualenvs/).\n\nGetting Started\n===================\n\nBuild an example API with a simple endpoint in just a few lines.\n\n```py\n# filename: happy_birthday.py\n"""A basic (single function) API written using hug"""\nimport hug\n\n\n@hug.get(\'/happy_birthday\')\ndef happy_birthday(name, age:hug.types.number=1):\n \xc2\xa0 \xc2\xa0"""Says happy birthday to a user"""\n    return "Happy {age} Birthday {name}!".format(**locals())\n```\n\nTo run, from the command line type:\n\n```bash\nhug -f happy_birthday.py\n```\n\nYou can access the example in your browser at:\n`localhost:8000/happy_birthday?name=hug&age=1`. Then check out the\ndocumentation for your API at `localhost:8000/documentation`\n\nParameters can also be encoded in the URL (check\nout [`happy_birthday.py`](examples/happy_birthday.py) for the whole\nexample).\n\n```py\n@hug.get(\'/greet/{event}\')\ndef greet(event: str):\n    """Greets appropriately (from http://blog.ketchum.com/how-to-write-10-common-holiday-greetings/)  """\n    greetings = "Happy"\n    if event == "Christmas":\n        greetings = "Merry"\n    if event == "Kwanzaa":\n        greetings = "Joyous"\n    if event == "wishes":\n        greetings = "Warm"\n\n    return "{greetings} {event}!".format(**locals())\n```\n\nWhich, once you are running the server as above, you can use this way:\n\n```\ncurl http://localhost:8000/greet/wishes\n"Warm wishes!"\n```\n\nVersioning with hug\n===================\n\n```py\n# filename: versioning_example.py\n"""A simple example of a hug API call with versioning"""\nimport hug\n\n@hug.get(\'/echo\', versions=1)\ndef echo(text):\n    return text\n\n\n@hug.get(\'/echo\', versions=range(2, 5))\ndef echo(text):\n    return "Echo: {text}".format(**locals())\n```\n\nTo run the example:\n\n```bash\nhug -f versioning_example.py\n```\n\nThen you can access the example from `localhost:8000/v1/echo?text=Hi` / `localhost:8000/v2/echo?text=Hi` Or access the documentation for your API from `localhost:8000`\n\nNote: versioning in hug automatically supports both the version header as well as direct URL based specification.\n\nTesting hug APIs\n===================\n\nhug\'s `http` method decorators don\'t modify your original functions. This makes testing hug APIs as simple as testing any other Python functions. Additionally, this means interacting with your API functions in other Python code is as straight forward as calling Python only API functions. hug makes it easy to test the full Python stack of your API by using the `hug.test` module:\n\n```python\nimport hug\nimport happy_birthday\n\nhug.test.get(happy_birthday, \'happy_birthday\', {\'name\': \'Timothy\', \'age\': 25}) # Returns a Response object\n```\n\nYou can use this `Response` object for test assertions (check\nout [`test_happy_birthday.py`](examples/test_happy_birthday.py) ):\n\n```python\ndef tests_happy_birthday():\n    response = hug.test.get(happy_birthday, \'happy_birthday\', {\'name\': \'Timothy\', \'age\': 25})\n    assert response.status == HTTP_200\n    assert response.data is not None\n```\n\nRunning hug with other WSGI based servers\n===================\n\nhug exposes a `__hug_wsgi__` magic method on every API module automatically. Running your hug based API on any standard wsgi server should be as simple as pointing it to `module_name`: `__hug_wsgi__`.\n\nFor Example:\n\n```bash\nuwsgi --http 0.0.0.0:8000 --wsgi-file examples/hello_world.py --callable __hug_wsgi__\n```\n\nTo run the hello world hug example API.\n\nBuilding Blocks of a hug API\n===================\n\nWhen building an API using the hug framework you\'ll use the following concepts:\n\n**METHOD Decorators** `get`, `post`, `update`, etc HTTP method decorators that expose your Python function as an API while keeping your Python method unchanged\n\n```py\n@hug.get() # <- Is the hug METHOD decorator\ndef hello_world():\n    return "Hello"\n```\n\nhug uses the structure of the function you decorate to automatically generate documentation for users of your API. hug always passes a request, response, and api_version variable to your function if they are defined params in your function definition.\n\n**Type Annotations** functions that optionally are attached to your methods arguments to specify how the argument is validated and converted into a Python type\n\n```py\n@hug.get()\ndef math(number_1:int, number_2:int): #The :int after both arguments is the Type Annotation\n    return number_1 + number_2\n```\n\nType annotations also feed into `hug`\'s automatic documentation\ngeneration to let users of your API know what data to supply.\n\n**Directives** functions that get executed with the request / response data based on being requested as an argument in your api_function.\nThese apply as input parameters only, and can not be applied currently as output formats or transformations.\n\n```py\n@hug.get()\ndef test_time(hug_timer):\n    return {\'time_taken\': float(hug_timer)}\n```\n\nDirectives may be accessed via an argument with a `hug_` prefix, or by using Python 3 type annotations. The latter is the more modern approach, and is recommended. Directives declared in a module can be accessed by using their fully qualified name as the type annotation (ex: `module.directive_name`).\n\nAside from the obvious input transformation use case, directives can be used to pipe data into your API functions, even if they are not present in the request query string, POST body, etc. For an example of how to use directives in this way, see the authentication example in the examples folder.\n\nAdding your own directives is straight forward:\n\n```py\n@hug.directive()\ndef square(value=1, **kwargs):\n    \'\'\'Returns passed in parameter multiplied by itself\'\'\'\n    return value * value\n\n@hug.get()\n@hug.local()\ndef tester(value: square=10):\n    return value\n\ntester() == 100\n```\n\nFor completeness, here is an example of accessing the directive via the magic name approach:\n\n```py\n@hug.directive()\ndef multiply(value=1, **kwargs):\n    \'\'\'Returns passed in parameter multiplied by itself\'\'\'\n    return value * value\n\n@hug.get()\n@hug.local()\ndef tester(hug_multiply=10):\n    return hug_multiply\n\ntester() == 100\n```\n\n**Output Formatters** a function that takes the output of your API function and formats it for transport to the user of the API.\n\n```py\n@hug.default_output_format()\ndef my_output_formatter(data):\n    return "STRING:{0}".format(data)\n\n@hug.get(output=hug.output_format.json)\ndef hello():\n    return {\'hello\': \'world\'}\n```\n\nas shown, you can easily change the output format for both an entire API as well as an individual API call\n\n**Input Formatters** a function that takes the body of data given from a user of your API and formats it for handling.\n\n```py\n@hug.default_input_format("application/json")\ndef my_input_formatter(data):\n    return (\'Results\', hug.input_format.json(data))\n```\n\nInput formatters are mapped based on the `content_type` of the request data, and only perform basic parsing. More detailed parsing should be done by the Type Annotations present on your `api_function`\n\n**Middleware** functions that get called for every request a hug API processes\n\n```py\n@hug.request_middleware()\ndef process_data(request, response):\n    request.env[\'SERVER_NAME\'] = \'changed\'\n\n@hug.response_middleware()\ndef process_data(request, response, resource):\n    response.set_header(\'MyHeader\', \'Value\')\n```\n\nYou can also easily add any Falcon style middleware using:\n\n```py\n__hug__.http.add_middleware(MiddlewareObject())\n```\n\n**Parameter mapping** can be used to override inferred parameter names, eg. for reserved keywords:\n\n```py\nimport marshmallow.fields as fields\n...\n\n@hug.get(\'/foo\', map_params={\'from\': \'from_date\'})  # API call uses \'from\'\ndef get_foo_by_date(from_date: fields.DateTime()):\n    return find_foo(from_date)\n```\n\nInput formatters are mapped based on the `content_type` of the request data, and only perform basic parsing. More detailed parsing should be done by the Type Annotations present on your `api_function`\n\nSplitting APIs over multiple files\n===================\n\nhug enables you to organize large projects in any manner you see fit. You can import any module that contains hug decorated functions (request handling, directives, type handlers, etc) and extend your base API with that module.\n\nFor example:\n\n`something.py`\n\n```py\nimport hug\n\n@hug.get(\'/\')\ndef say_hi():\n    return \'hello from something\'\n```\n\nCan be imported into the main API file:\n\n`__init__.py`\n\n```py\nimport hug\nfrom . import something\n\n@hug.get(\'/\')\ndef say_hi():\n    return "Hi from root"\n\n@hug.extend_api(\'/something\')\ndef something_api():\n    return [something]\n```\n\nOr alternatively - for cases like this - where only one module is being included per a URL route:\n\n```py\n#alternatively\nhug.API(__name__).extend(something, \'/something\')\n```\n\nConfiguring hug 404\n===================\n\nBy default, hug returns an auto generated API spec when a user tries to access an endpoint that isn\'t defined. If you would not like to return this spec you can turn off 404 documentation:\n\nFrom the command line application:\n\n```bash\nhug -nd -f {file} #nd flag tells hug not to generate documentation on 404\n```\n\nAdditionally, you can easily create a custom 404 handler using the `hug.not_found` decorator:\n\n```py\n@hug.not_found()\ndef not_found_handler():\n    return "Not Found"\n```\n\nThis decorator works in the same manner as the hug HTTP method decorators, and is even version aware:\n\n```py\n@hug.not_found(versions=1)\ndef not_found_handler():\n    return ""\n\n@hug.not_found(versions=2)\ndef not_found_handler():\n    return "Not Found"\n```\n\nAsyncio support\n===============\n\nWhen using the `get` and `cli` method decorator on coroutines, hug will schedule\nthe execution of the coroutine.\n\nUsing asyncio coroutine decorator\n\n```py\n@hug.get()\n@asyncio.coroutine\ndef hello_world():\n    return "Hello"\n```\n\nUsing Python 3.5 async keyword.\n\n```py\n@hug.get()\nasync def hello_world():\n    return "Hello"\n```\n\nNOTE: Hug is running on top Falcon which is not an asynchronous server. Even if using\nasyncio, requests will still be processed synchronously.\n\nUsing Docker\n===================\n\nIf you like to develop in Docker and keep your system clean, you can do that but you\'ll need to first install [Docker Compose](https://docs.docker.com/compose/install/).\n\nOnce you\'ve done that, you\'ll need to `cd` into the `docker` directory and run the web server (Gunicorn) specified in `./docker/gunicorn/Dockerfile`, after which you can preview the output of your API in the browser on your host machine.\n\n```bash\n$ cd ./docker\n# This will run Gunicorn on port 8000 of the Docker container.\n$ docker-compose up gunicorn\n\n# From the host machine, find your Dockers IP address.\n# For Windows & Mac:\n$ docker-machine ip default\n\n# For Linux:\n$ ifconfig docker0 | grep \'inet\' | cut -d: -f2 | awk \'{ print $1}\' | head -n1\n```\n\nBy default, the IP is 172.17.0.1. Assuming that\'s the IP you see, as well, you would then go to `http://172.17.0.1:8000/` in your browser to view your API.\n\nYou can also log into a Docker container that you can consider your work space. This workspace has Python and Pip installed so you can use those tools within Docker. If you need to test the CLI interface, for example, you would use this.\n\n```bash\n$ docker-compose run workspace bash\n```\n\nOn your Docker `workspace` container, the `./docker/templates` directory on your host computer is mounted to `/src` in the Docker container. This is specified under `services` > `app` of `./docker/docker-compose.yml`.\n\n```bash\nbash-4.3# cd /src\nbash-4.3# tree\n.\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 __init__.py\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 handlers\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 birthday.py\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 hello.py\n\n1 directory, 3 files\n```\n\nSecurity contact information\n===================\n\nhug takes security and quality seriously. This focus is why we depend only on thoroughly tested components and utilize static analysis tools (such as bandit and safety) to verify the security of our code base.\nIf you find or encounter any potential security issues, please let us know right away so we can resolve them.\n\nTo report a security vulnerability, please use the\n[Tidelift security contact](https://tidelift.com/security).\nTidelift will coordinate the fix and disclosure.\n\nWhy hug?\n===================\n\nHUG simply stands for Hopefully Useful Guide. This represents the project\'s goal to help guide developers into creating well written and intuitive APIs.\n\n--------------------------------------------\n\nThanks and I hope you find *this* hug helpful as you develop your next Python API!\n\n~Timothy Crosley\n'