b'# inlets\n\nExpose your local endpoints to the Internet\n\n[![Build Status](https://travis-ci.org/inlets/inlets.svg?branch=master)](https://travis-ci.org/inlets/inlets) [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT) [![Go Report Card](https://goreportcard.com/badge/github.com/inlets/inlets)](https://goreportcard.com/report/github.com/inlets/inlets) [![Documentation](https://godoc.org/github.com/inlets/inlets?status.svg)](http://godoc.org/github.com/inlets/inlets) [![Derek App](https://alexellis.o6s.io/badge?owner=inlets&repo=inlets)](https://github.com/alexellis/derek/)\n[![Setup Automated](https://img.shields.io/badge/setup-automated-blue?logo=gitpod)](https://gitpod.io/from-referrer/)\n\n## Intro\n\ninlets combines a reverse proxy and websocket\xc2\xa0tunnels to expose your internal and development endpoints to the public Internet via an exit-node. An exit-node may be a 5-10 USD VPS or any other computer with an IPv4 IP address.\n\nWhy do we need this project? Similar tools such as [ngrok](https://ngrok.com/) or [Argo Tunnel](https://developers.cloudflare.com/argo-tunnel/) from [Cloudflare](https://www.cloudflare.com/) are closed-source, have limits built-in, can work out expensive, and have limited support for arm/arm64. Ngrok is also often banned by corporate firewall policies meaning it can be unusable. Other open-source tunnel tools are designed to only set up a single static tunnel. inlets aims to dynamically bind and discover your local services to DNS entries with automated TLS certificates to a public IP address over a websocket tunnel.\n\nWhen combined with SSL - inlets can be used with any corporate HTTP proxy which supports `CONNECT`.\n\n![](docs/inlets.png)\n\n*Conceptual diagram for inlets*\n\n## License & terms\n\n**Important**\n\nDevelopers wishing to use inlets within a corporate network are advised to seek approval from their administrators or management before using the tool. By downloading, using, or distributing inlets, you agree to the [LICENSE](./LICENSE) terms & conditions. No warranty or liability is provided.\n\n### Who is behind this project?\n\ninlets is brought to you by [Alex Ellis](https://twitter.com/alexellisuk). Alex is a [CNCF Ambassador](https://www.cncf.io/people/ambassadors/) and the founder of [OpenFaaS](https://github.com/openfaas/faas/).\n\n> [OpenFaaS&reg;](https://github.com/openfaas/faas) makes it easy for developers to deploy event-driven functions and microservices to Kubernetes without repetitive, boiler-plate coding. Package your code or an existing binary in a Docker image to get a highly scalable endpoint with auto-scaling and metrics. The project has around 19k GitHub stars, over 240 contributors and a growing number of end-users in production.\n\n### Backlog & goals\n\n#### Completed\n\n* automatically create endpoints on exit-node based upon client definitions\n  * multiplex sites on same port and websocket through the use of DNS / host entries\n* link encryption using SSL over websockets (`wss://`)\n* automatic reconnect\n* authentication using service account or basic auth\n* automatic TLS provisioning for endpoints using [cert-magic](https://github.com/mholt/certmagic)\n  * configure staging or production LetsEncrypt issuer using HTTP01 challenge\n* native multi-arch with ARMHF/ARM64 support\n* Dockerfile and Kubernetes YAML files\n* discover and implement `Service` type of `LoadBalancer` for Kubernetes - [inlets-operator](https://github.com/inlets/inlets-operator)\n* tunnelling websocket traffic in addition to HTTP(s)\n* [get a logo for the project](https://github.com/inlets/inlets/issues/46)\n\n#### Stretch goals\n\n* automatic configuration of DNS / A records\n* configuration to run "exit-node" as serverless container with Azure ACI / AWS Fargate\n* configure staging or production LetsEncrypt issuer using DNS01 challenge\n\n#### Non-goals\n\n* tunnelling plain TCP traffic over the websocket\n\n  This use-case is covered by inlets-pro, ask me about early access to [inlets-pro](mailto:alex@openfaas.com).\n\n### Status\n\nUnlike HTTP 1.1 which follows a synchronous request/response model websockets use an asynchronous pub/sub model for sending and receiving messages. This presents a challenge for tunneling a *synchronous protocol* over an *asynchronous bus*.\n\ninlets 2.0 introduces performance enhancements and leverages parts of the Kubernetes and Rancher API. It uses the same tunnelling packages that enable node-to-node communication in [Rancher\'s k3s project](https://k3s.io). It is suitable for development and may be useful in production. Before deploying `inlets` into production, it is advised that you do adequate testing.\n\nFeel free to open issues if you have comments, suggestions or contributions.\n\n* The tunnel link is secured via `--token` flag using a shared secret\n* The default configuration uses websockets without SSL `ws://`, but to enable encryption you could enable SSL `wss://`\n* A timeout for requests can be configured via args on the server\n* ~~The upstream URL has to be configured on both server and client until a discovery or service advertisement mechanism is added~~ The client can advertise upstream URLs, which it can serve\n* The tunnel transport is wrapped by default which strips CORS headers from responses, but you can disable it with the `--disable-transport-wrapping` flag on the server\n\n### Related projects\n\nInlets is [listed on the Cloud Native Landscape](https://landscape.cncf.io/category=service-proxy&format=card-mode&grouping=category&sort=stars) as a Service Proxy\n\n* [inlets](https://github.com/inlets/inlets) - open-source L7 HTTP tunnel and reverse proxy\n* [inlets-pro](https://github.com/inlets/inlets-pro-pkg) - L4 TCP load-balancer\n* [inlets-operator](https://github.com/inlets/inlets-operator) - deep integration for inlets in Kubernetes, expose Service type LoadBalancer\n* [inletsctl](https://github.com/inlets/inletsctl) - CLI tool to provision exit-nodes for use with inlets or inlets-pro\n\n### What are people saying about inlets?\n\n> You can share about inlets using `@inletsdev`, `#inletsdev`, and `https://inlets.dev`.\n\ninlets has trended on the front page of Hacker News twice.\n\n* [inlets 1.0](https://news.ycombinator.com/item?id=19189455) - 146 points, 48 comments\n* [inlets 2.0](https://news.ycombinator.com/item?id=20410552) - 218 points, 66 comments\n\nTutorials:\n* [Get a LoadBalancer for your private Kubernetes cluster with inlets-operator by Alex Ellis](https://blog.alexellis.io/ingress-for-your-local-kubernetes-cluster/)\n* [Blog post - webhooks, great when you can get them by Alex Ellis](https://blog.alexellis.io/webhooks-are-great-when-you-can-get-them/)\n* [Micro-tutorial inlets with KinD by Alex Ellis](https://gist.github.com/alexellis/c29dd9f1e1326618f723970185195963)\n* [The Awesomeness of Inlets by Ruan Bekker](https://sysadmins.co.za/the-awesomeness-of-inlets/)\n* [K8Spin - What does fit in a low resources namespace? Inlets](https://medium.com/k8spin/what-does-fit-in-a-low-resources-namespace-3rd-part-inlets-6cc278835e57)\n* [Exposing Magnificent Image Classifier with inlets](https://blog.baeke.info/2019/07/17/exposing-a-local-endpoint-with-inlets/)\n* ["Securely access external applications as Kubernetes Services, from your laptop or from any other host, using inlets"](https://twitter.com/BanzaiCloud/status/1164168218954670080)\n\nTwitter:\n\n* ["I just transferred a 70Gb disk image from a NATed NAS to a remote NATed server with @alexellisuk inlets tunnels and a one-liner python web server" by Roman Dodin](https://twitter.com/ntdvps/status/1143071544203186176)\n* ["Really amazed by inlets by @alexellisuk - "Up and running in 15min - I will be able to watch my #RaspberryPi servers running at home while staying on the beach \xf0\x9f\x8f\x84\xe2\x80\x8d\xe2\x99\x82\xef\xb8\x8f\xf0\x9f\x8c\xb4\xf0\x9f\x8d\xb8\xf0\x9f\x91\x8f\xf0\x9f\x91\x8f\xf0\x9f\x91\x8f" by Florian Dambrine](https://twitter.com/DambrineF/status/1158364581624012802?s=20)\n* [Testing an OAuth proxy by Vivek Singh](https://twitter.com/viveksyngh/status/1142054203478564864)\n* [inlets used at KubeCon to power a live IoT demo at a booth](https://twitter.com/tobruzh/status/1130421702914129921)\n* [PR to support Risc-V by Carlos Eduardo](https://twitter.com/carlosedp/status/1140740494617645061)\n* [Recommended by Michael Hausenblas for use with local Kubernetes](https://twitter.com/mhausenblas/status/1143020953380753409)\n* [5 top facts about inlets by Alex Ellis](https://twitter.com/alexellisuk/status/1140552115204608001)\n* ["Cool! I hadn\'t heard of inlets until now, but I love the idea of exposing internal services this way. I\'ve been using TOR to do this!" by Stephen Doskett, Tech Field Day](https://twitter.com/SFoskett/status/1108989190912524288)\n* ["Learn how to set up HTTPS for your local endpoints with inlets, Caddy, and DigitalOcean thanks to @alexellisuk!" by @DigitalOcean](https://twitter.com/digitalocean/status/1113440166310502400)\n* ["See how Inlets helped me to expose my local endpoints for my homelab that sits behind a Carrier-Grade NAT"](https://twitter.com/ruanbekker/status/1161399537417801728)\n\n> Note: add a PR to send your story or use-case, I\'d love to hear from you.\n\nSee [ADOPTERS.md](./ADOPTERS.md) for what companies are doing with inlets today.\n\n## Get started\n\nYou can install the CLI with a `curl` utility script, `brew` or by downloading the binary from the releases page. Once installed you\'ll get the `inlets` command.\n\n### Install the CLI\n\n> Note: `inlets` is made available free-of-charge, but you can support its ongoing development through [GitHub Sponsors](https://insiders.openfaas.io/) \xf0\x9f\x92\xaa\n\nUtility script with `curl`:\n\n```bash\n# Install to local directory\ncurl -sLS https://get.inlets.dev | sh\n\n# Install to /usr/local/bin/\ncurl -sLS https://get.inlets.dev | sudo sh\n```\n\nVia `brew`:\n\n```bash\nbrew install inlets\n```\n\n> Note: the `brew` distribution is maintained by the brew team, so it may lag a little behind the GitHub release.\n\nBinaries are made available on the [releases page](https://github.com/inlets/inlets/releases) for Linux (x86_64, armhf & arm64), Windows (experimental), and for Darwin (MacOS). You will also find SHA checksums available if you want to verify your download.\n\nWindows users are encouraged to use [git bash](https://git-scm.com/downloads) to install the inlets binary.\n\n### Quickstart tutorial\n\nYou can run inlets between any two computers with connectivity, these could be containers, VMs, bare metal or even "loop-back" on your own laptop.\n\nSee [how to provision an "exit-node" with a public IPv4 address using a VPS](./docs/vps.md).\n\n* On the *exit-node* (or server)\n\nStart the tunnel server on a machine with a publicly-accessible IPv4 IP address such as a VPS.\n\nExample with a token for client authentication:\n\n```bash\nexport token=$(head -c 16 /dev/urandom | shasum | cut -d" " -f1)\ninlets server --port=8090 --token="$token"\n```\n\n> Note: You can pass the `--token` argument followed by a token value to both the server and client to prevent unauthorized connections to the tunnel.\n\n\n```bash\ninlets server --port=8090\n```\n\nYou can also run unprotected, but this is not recommended.\n\nNote down your public IPv4 IP address.\n\n* Head over to your machine where you are running a sample service, or something you want to expose.\n\nYou can use my hash-browns service for instance which generates hashes.\n\nInstall hash-browns or run your own HTTP server\n\n```sh\nexport GO111MODULE=off\nexport GOPATH=$HOME/go/\n\ngo get -u github.com/alexellis/hash-browns\ncd $GOPATH/src/github.com/alexellis/hash-browns\n\nport=3000 go run server.go\n```\n\nIf you don\'t have Go installed, then you could run [Python\'s built-in HTTP server](https://docs.python.org/2/library/simplehttpserver.html):\n\n```sh\nmkdir -p /tmp/inlets-test/\ncd /tmp/inlets-test/\ntouch hello-world\npython -m SimpleHTTPServer 3000\n```\n\n* On the same machine, start the inlets client\n\nStart the tunnel client:\n\n```sh\nexport REMOTE="127.0.0.1:8090"    # for testing inlets on your laptop, replace with the public IPv4\nexport TOKEN="CLIENT-TOKEN-HERE"  # the client token is found on your VPS or on start-up of "inlets server"\ninlets client \\\n --remote=$REMOTE \\\n --upstream=http://127.0.0.1:3000 \\\n --token $TOKEN\n```\n\n* Replace the `--remote` with the address where your exit-node is running `inlets server`.\n* Replace the `--token` with the value from your server\n\nWe now have three processes:\n* example service running (hash-browns) or Python\'s webserver\n* an exit-node running the tunnel server (`inlets server`)\n* a client running the tunnel client (`inlets client`)\n\nSo send a request to the inlets server - use its domain name or IP address:\n\nAssuming `gateway.mydomain.tk` points to `127.0.0.1` in `/etc/hosts` or your DNS server.\n\n```sh\ncurl -d "hash this" http://127.0.0.1:8090/hash -H "Host: gateway.mydomain.tk"\n# or\ncurl -d "hash this" http://127.0.0.1:8090/hash\n# or\ncurl -d "hash this" http://gateway.mydomain.tk/hash\n```\n\nYou will see the traffic pass between the exit node / server and your development machine. You\'ll see the hash message appear in the logs as below:\n\n```sh\n~/go/src/github.com/alexellis/hash-browns$ port=3000 go run server.go\n2018/12/23 20:15:00 Listening on port: 3000\n"hash this"\n```\n\nNow check the metrics endpoint which is built-into the hash-browns example service:\n\n```sh\ncurl $REMOTE/metrics | grep hash\n```\n\nYou can also use multiple domain names and tie them back to different internal services.\n\nHere we start the Python server on two different ports, serving content from two different locations and then map it to two different Host headers, or domain names:\n\n```sh\nmkdir -p /tmp/store1\ncd /tmp/store1/\ntouch hello-store-1\npython -m SimpleHTTPServer 8001 &\n\n\nmkdir -p /tmp/store2\ncd /tmp/store2/\ntouch hello-store-2\npython -m SimpleHTTPServer 8002 &\n```\n\n```sh\nexport REMOTE="127.0.0.1:8090"    # for testing inlets on your laptop, replace with the public IPv4\nexport TOKEN="CLIENT-TOKEN-HERE"  # the client token is found on your VPS or on start-up of "inlets server"\ninlets client \\\n --remote=$REMOTE \\\n --token $TOKEN \\\n --upstream="store1.example.com=http://127.0.0.1:8001,store2.example.com=http://127.0.0.1:8002"\n```\n\nYou can now create two DNS entries or `/etc/hosts` file entries for `store1.example.com` and `store2.example.com`, then connet through your browser.\n\n## Going further\n\n### Docs & Featured tutorials\n\nTutorial: [HTTPS for your local endpoints with inlets and Caddy](https://blog.alexellis.io/https-inlets-local-endpoints/)\n\nDocs: [Inlets & Kubernetes recipes](./docs/kubernetes.md)\n\nDocs: [Run Inlets on a VPS](./docs/vps.md)\n\nTutorial: [Get a LoadBalancer for your private Kubernetes cluster with inlets-operator](https://blog.alexellis.io/ingress-for-your-local-kubernetes-cluster/)\n\n### Video demo\n\nUsing inlets I was able to set up a public endpoint (with a custom domain name) for my JavaScript & Webpack [Create React App](https://github.com/facebook/create-react-app).\n\n[![https://img.youtube.com/vi/jrAqqe8N3q4/hqdefault.jpg](https://img.youtube.com/vi/jrAqqe8N3q4/maxresdefault.jpg)](https://youtu.be/jrAqqe8N3q4)\n\n### Docker\n\nDocker images are published as multi-arch for `x86_64`, `arm64` and `armhf`\n\n* `inlets/inlets:2.6.1\n\n### Multiple services with on exit-node\n\nYou can expose an OpenFaaS or OpenFaaS Cloud deployment with `inlets` - just change `--upstream=http://127.0.0.1:3000` to `--upstream=http://127.0.0.1:8080` or `--upstream=http://127.0.0.1:31112`. You can even point at an IP address inside or outside your network for instance: `--upstream=http://192.168.0.101:8080`.\n\nWhen using the scripts in `hack` to configure inlets with system, the process will restart if the tunnel crashes.\n\n### Bind a different port for the control-plane\n\nYou can bind two separate TCP ports for the user-facing port and the tunnel.\n\n* `--port` - the port for users to connect to and for serving data, i.e. the *Data Plane*\n* `--control-port` - the port for the websocket to connect to i.e. the *Control Plane*\n\n## Development\n\nFor development you will need Golang 1.10 or 1.11 on both the exit-node or server and the client.\n\nYou can get the code like this:\n\n```bash\ngo get -u github.com/inlets/inlets\ncd $GOPATH/src/github.com/inlets/inlets\n```\n\nAlternatively, you can get everything setup right in the browser with a single click using [Gitpod](https://gitpod.io):\n\n[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/inlets/inlets)\n\nContributions are welcome. All commits must be signed-off with `git commit -s` to accept the [Developer Certificate of Origin](https://developercertificate.org).\n'