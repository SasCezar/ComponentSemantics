b"# Go HTTP tunnel [![GoDoc](http://img.shields.io/badge/go-documentation-blue.svg)](http://godoc.org/github.com/mmatczuk/go-http-tunnel) [![Go Report Card](https://goreportcard.com/badge/github.com/mmatczuk/go-http-tunnel)](https://goreportcard.com/report/github.com/mmatczuk/go-http-tunnel) [![Build Status](http://img.shields.io/travis/mmatczuk/go-http-tunnel.svg?branch=master)](https://travis-ci.org/mmatczuk/go-http-tunnel) [![Github All Releases](https://img.shields.io/github/downloads/mmatczuk/go-http-tunnel/total.svg)](https://github.com/mmatczuk/go-http-tunnel/releases)\n\nGo HTTP tunnel is a reverse tunnel based on HTTP/2. It enables you to share your localhost when you don't have a public IP.\n\nFeatures:\n\n* HTTP proxy with [basic authentication](https://en.wikipedia.org/wiki/Basic_access_authentication)\n* TCP proxy\n* [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) vhost proxy\n* Client auto reconnect\n* Client management and eviction\n* Easy to use CLI\n\nCommon use cases:\n\n* Hosting a game server from home\n* Developing webhook integrations\n* Managing IoT devices\n\n## Installation\n\nBuild the latest version.\n\n```bash\n$ go get -u github.com/mmatczuk/go-http-tunnel/cmd/...\n```\n\nAlternatively [download the latest release](https://github.com/mmatczuk/go-http-tunnel/releases/latest).\n\n## Running\n\nThere are two executables:\n\n* `tunneld` - the tunnel server, to be run on publicly available host like AWS or GCE\n* `tunnel` - the tunnel client, to be run on your local machine or in your private network\n\nTo get help on the command parameters run `tunneld -h` or `tunnel -h`.\n\nTunnel requires TLS certificates for both client and server.\n\n```bash\n$ openssl req -x509 -nodes -newkey rsa:2048 -sha256 -keyout client.key -out client.crt\n$ openssl req -x509 -nodes -newkey rsa:2048 -sha256 -keyout server.key -out server.crt\n```\n\nRun client:\n\n* Install `tunnel` binary\n* Make `.tunnel` directory in your project directory\n* Copy `client.key`, `client.crt` to `.tunnel`\n* Create configuration file `tunnel.yml` in `.tunnel`\n* Start all tunnels\n\n```bash\n$ tunnel -config ./tunnel/tunnel.yml start-all\n```\n\nRun server:\n\n* Install `tunneld` binary\n* Make `.tunneld` directory\n* Copy `server.key`, `server.crt` to `.tunneld`\n* Start tunnel server\n\n```bash\n$ tunneld -tlsCrt .tunneld/server.crt -tlsKey .tunneld/server.key\n```\n\nThis will run HTTP server on port `80` and HTTPS (HTTP/2) server on port `443`. If you want to use HTTPS it's recommended to get a properly signed certificate to avoid security warnings.\n\n### Run Server as a Service on Ubuntu using Systemd:\n\n* After completing the steps above successfully, create a new file for your service (you can name it whatever you want, just replace the name below with your chosen name).\n\n``` bash\n$ vim tunneld.service\n```\n\n* Add the following configuration to the file\n\n```\n[Unit]\nDescription=Go-Http-Tunnel Service\nAfter=network.target\nAfter=network-online.target\n\n[Service]\nExecStart=/path/to/your/tunneld -tlsCrt /path/to/your/folder/.tunneld/server.crt -tlsKey /path/to/your/folder/.tunneld/server.key\nTimeoutSec=30\nRestart=on-failure\nRestartSec=30\n\n[Install]\nWantedBy=multi-user.target\n```\n\n* Save and exit this file.\n* Move this new file to /etc/systemd/system/\n\n```bash\n$ sudo mv tunneld.service /etc/systemd/system/\n```\n\n* Change the file permission to allow it to run.\n\n```bash\n$ sudo chmod u+x /etc/systemd/system/tunneld.service\n```\n\n* Start the new service and make sure you don't get any errors, and that your client is able to connect.\n\n```bash\n$ sudo systemctl start tunneld.service\n```\n\n* You can stop the service with:\n\n```bash\n$ sudo systemctl stop tunneld.service\n```\n\n* Finally, if you want the service to start automatically when the server is rebooted, you need to enable it.\n\n```bash\n$ sudo systemctl enable tunneld.service\n```\n\nThere are many more options for systemd services, and this is by not means an exhaustive configuration file.\n\n## Configuration\n\nThe tunnel client `tunnel` requires configuration file, by default it will try reading `tunnel.yml` in your current working directory. If you want to specify other file use `-config` flag.\n\nSample configuration that exposes:\n\n* `localhost:8080` as `webui.my-tunnel-host.com`\n* host in private network for ssh connections\n\nlooks like this\n\n```yaml\n    server_addr: SERVER_IP:5223\n    tunnels:\n      webui:\n        proto: http\n        addr: localhost:8080\n        auth: user:password\n        host: webui.my-tunnel-host.com\n      ssh:\n        proto: tcp\n        addr: 192.168.0.5:22\n        remote_addr: 0.0.0.0:22\n      tls:\n  \t    proto: sni\n  \t    addr: localhost:443\n  \t    host: tls.my-tunnel-host.com\n```\n\nConfiguration options:\n\n* `server_addr`: server TCP address, i.e. `54.12.12.45:5223`\n* `tls_crt`: path to client TLS certificate, *default:* `client.crt` *in the config file directory*\n* `tls_key`: path to client TLS certificate key, *default:* `client.key` *in the config file directory*\n* `root_ca`: path to trusted root certificate authority pool file, if empty any server certificate is accepted\n*  `tunnels / [name]`\n    * `proto`: tunnel protocol, `http`, `tcp` or `sni`\n    * `addr`: forward traffic to this local port number or network address, for `proto=http` this can be full URL i.e. `https://machine/sub/path/?plus=params`, supports URL schemes `http` and `https`\n    * `auth`: (`proto=http`) (optional) basic authentication credentials to enforce on tunneled requests, format `user:password`\n    * `host`: (`proto=http`, `proto=sni`) hostname to request (requires reserved name and DNS CNAME)\n    * `remote_addr`: (`proto=tcp`) bind the remote TCP address\n* `backoff`\n    * `interval`: how long client would wait before redialing the server if connection was lost, exponential backoff initial interval, *default:* `500ms`\n    * `multiplier`: interval multiplier if reconnect failed, *default:* `1.5`\n    * `max_interval`: maximal time client would wait before redialing the server, *default:* `1m`\n    * `max_time`: maximal time client would try to reconnect to the server if connection was lost, set `0` to never stop trying, *default:* `15m`\n\n## How it works\n\nA client opens TLS connection to a server. The server accepts connections from known clients only. The client is recognized by its TLS certificate ID. The server is publicly available and proxies incoming connections to the client. Then the connection is further proxied in the client's network.\n\nThe tunnel is based HTTP/2 for speed and security. There is a single TCP connection between client and server and all the proxied connections are multiplexed using HTTP/2.\n\n## Donation\n\nIf this project help you reduce time to develop, you can give me a cup of coffee.\n\n[![paypal](https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=RMM46NAEY7YZ6&lc=US&item_name=go%2dhttp%2dtunnel&currency_code=USD&bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHosted)\n\nA GitHub star is always appreciated!\n\n## License\n\nCopyright (C) 2017 Micha\xc5\x82 Matczuk\n\nThis project is distributed under the AGPL-3 license. See the [LICENSE](https://github.com/mmatczuk/go-http-tunnel/blob/master/LICENSE) file for details. If you need an enterprice license contact me directly.\n"