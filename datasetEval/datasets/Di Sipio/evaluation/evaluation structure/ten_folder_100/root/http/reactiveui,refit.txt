b'![Refit](refit_logo.png)\n\n## Refit: The automatic type-safe REST library for .NET Core, Xamarin and .NET\n\n[![Build Status](https://dev.azure.com/dotnet/ReactiveUI/_apis/build/status/Refit-CI?branchName=master)](https://dev.azure.com/dotnet/ReactiveUI/_build/latest?definitionId=17)\n\n||Refit|Refit.HttpClientFactory|\n|-|-|-|\n|*NuGet*|[![NuGet](https://img.shields.io/nuget/v/Refit.svg)](https://www.nuget.org/packages/Refit/)|[![NuGet](https://img.shields.io/nuget/v/Refit.HttpClientFactory.svg)](https://www.nuget.org/packages/Refit.HttpClientFactory/)|\n|*Azure<br />Artifacts*|[![Refit package in Refit feed in Azure Artifacts](https://feeds.dev.azure.com/dotnet/a5852744-a77d-4d76-a9d2-81ac1fdd5744/_apis/public/Packaging/Feeds/6368ad76-9653-4c2f-a6c6-da8c790ae826/Packages/2f65cb3b-df09-4050-a84e-b868ed95fd28/Badge)](https://dev.azure.com/dotnet/ReactiveUI/_packaging?_a=package&feed=6368ad76-9653-4c2f-a6c6-da8c790ae826&package=2f65cb3b-df09-4050-a84e-b868ed95fd28&preferRelease=true)|[![Refit.HttpClientFactory package in Refit feed in Azure Artifacts](https://feeds.dev.azure.com/dotnet/a5852744-a77d-4d76-a9d2-81ac1fdd5744/_apis/public/Packaging/Feeds/6368ad76-9653-4c2f-a6c6-da8c790ae826/Packages/d87934cb-2f7b-44b7-83b8-3872ac965ef2/Badge)](https://dev.azure.com/dotnet/ReactiveUI/_packaging?_a=package&feed=6368ad76-9653-4c2f-a6c6-da8c790ae826&package=d87934cb-2f7b-44b7-83b8-3872ac965ef2&preferRelease=true)|\n\nCI Feed: `https://pkgs.dev.azure.com/dotnet/ReactiveUI/_packaging/Refit/nuget/v3/index.json`\n\nRefit is a library heavily inspired by Square\'s\n[Retrofit](http://square.github.io/retrofit) library, and it turns your REST\nAPI into a live interface:\n\n```csharp\npublic interface IGitHubApi\n{\n    [Get("/users/{user}")]\n    Task<User> GetUser(string user);\n}\n```\n\nThe `RestService` class generates an implementation of `IGitHubApi` that uses\n`HttpClient` to make its calls:\n\n```csharp\nvar gitHubApi = RestService.For<IGitHubApi>("https://api.github.com");\n\nvar octocat = await gitHubApi.GetUser("octocat");\n```\n\n### Where does this work?\n\nRefit currently supports the following platforms and any .NET Standard 1.4 target:\n\n* UWP\n* Xamarin.Android\n* Xamarin.Mac\n* Xamarin.iOS \n* Desktop .NET 4.6.1 \n* .NET Core\n* Uno Platform\n\n#### Note about .NET Core\nFor .NET Core build-time support, you must use the .NET Core 2 SDK. You can target any supported platform in your library, long as the 2.0+ SDK is used at build-time.\n\n### API Attributes\n\nEvery method must have an HTTP attribute that provides the request method and\nrelative URL. There are six built-in annotations: Get, Post, Put, Delete, Patch and\nHead. The relative URL of the resource is specified in the annotation.\n\n```csharp\n[Get("/users/list")]\n```\n\nYou can also specify query parameters in the URL:\n\n```csharp\n[Get("/users/list?sort=desc")]\n```\n\nA request URL can be updated dynamically using replacement blocks and\nparameters on the method. A replacement block is an alphanumeric string\nsurrounded by { and }. \n\nIf the name of your parameter doesn\'t match the name in the URL path, use the\n`AliasAs` attribute.\n\n```csharp\n[Get("/group/{id}/users")]\nTask<List<User>> GroupList([AliasAs("id")] int groupId);\n```\n\nA request url can also bind replacement blocks to a custom object\n\n```csharp\n[Get("/group/{request.groupId}/users/{request.userId}")]\nTask<List<User>> GroupList(UserGroupRequest request);\n\nclass UserGroupRequest{\n    int groupId { get;set; }\n    int userId { get;set; }\n}\n\n```\n\nParameters that are not specified as a URL substitution will automatically be\nused as query parameters. This is different than Retrofit, where all\nparameters must be explicitly specified.\n\nThe comparison between parameter name and URL parameter is *not*\ncase-sensitive, so it will work correctly if you name your parameter `groupId`\nin the path `/group/{groupid}/show` for example.\n\n```csharp\n[Get("/group/{id}/users")]\nTask<List<User>> GroupList([AliasAs("id")] int groupId, [AliasAs("sort")] string sortOrder);\n\nGroupList(4, "desc");\n>>> "/group/4/users?sort=desc"\n```\n\nRound-tripping route parameter syntax: Forward slashes aren\'t encoded when using a double-asterisk (\\*\\*) catch-all parameter syntax.\n\nDuring link generation, the routing system encodes the value captured in a double-asterisk (\\*\\*) catch-all parameter (for example, {**myparametername}) except the forward slashes.\n\nThe type of round-tripping route parameter must be string.\n\n```csharp\n[Get("/search/{**page}")]\nTask<List<Page>> Search(string page);\n\nSearch("admin/products");\n>>> "/search/admin/products"\n```\n\n### Dynamic Querystring Parameters\n\nIf you specify an `object` as a query parameter, all public properties which are not null are used as query parameters.\nThis previously only applied to GET requests, but has now been expanded to all HTTP request methods, partly thanks to Twitter\'s hybrid API that insists on non-GET requests with querystring parameters.\nUse the `Query` attribute the change the behavior to \'flatten\' your query parameter object. If using this Attribute you can specify values for the Delimiter and the Prefix which are used to \'flatten\' the object.\n\n```csharp\npublic class MyQueryParams\n{\n    [AliasAs("order")]\n    public string SortOrder { get; set; }\n\n    public int Limit { get; set; }\n}\n\n\n[Get("/group/{id}/users")]\nTask<List<User>> GroupList([AliasAs("id")] int groupId, MyQueryParams params);\n\n[Get("/group/{id}/users")]\nTask<List<User>> GroupListWithAttribute([AliasAs("id")] int groupId, [Query(".","search")] MyQueryParams params);\n\n\nparams.SortOrder = "desc";\nparams.Limit = 10;\n\nGroupList(4, params)\n>>> "/group/4/users?order=desc&Limit=10"\n\nGroupListWithAttribute(4, params)\n>>> "/group/4/users?search.order=desc&search.Limit=10"\n```\n\nA similar behavior exists if using a Dictionary, but without the advantages of the `AliasAs` attributes and of course no intellisense and/or type safety.\n\nYou can also specify querystring parameters with [Query] and have them flattened in non-GET requests, similar to:\n```csharp\n[Post("/statuses/update.json")]\nTask<Tweet> PostTweet([Query]TweetParams params);\n```\n\nWhere `TweetParams` is a POCO, and properties will also support `[AliasAs]` attributes.\n\n### Collections as Querystring parameters\n\nUse the `Query` attribute to specify format in which collections should be formatted in query string\n\n```csharp\n[Get("/users/list")]\nTask Search([Query(CollectionFormat.Multi)]int[] ages);\n\nSearch(new [] {10, 20, 30})\n>>> "/users/list?ages=10&ages=20&ages=30"\n\n[Get("/users/list")]\nTask Search([Query(CollectionFormat.Csv)]int[] ages);\n\nSearch(new [] {10, 20, 30})\n>>> "/users/list?ages=10%2C20%2C30"\n```\n\n### Body content\n\nOne of the parameters in your method can be used as the body, by using the\nBody attribute:\n\n```csharp\n[Post("/users/new")]\nTask CreateUser([Body] User user);\n```\n\nThere are four possibilities for supplying the body data, depending on the\ntype of the parameter:\n\n* If the type is `Stream`, the content will be streamed via `StreamContent`\n* If the type is `string`, the string will be used directly as the content unless `[Body(BodySerializationMethod.Json)]` is set which will send it as a `StringContent`\n* If the parameter has the attribute `[Body(BodySerializationMethod.UrlEncoded)]`, \n  the content will be URL-encoded (see [form posts](#form-posts) below)\n* For all other types, the object will be serialized using the content serializer specified in \nRefitSettings (JSON is the default).\n\n#### Buffering and the `Content-Length` header\n\nBy default, Refit streams the body content without buffering it. This means you can\nstream a file from disk, for example, without incurring the overhead of loading \nthe whole file into memory. The downside of this is that no `Content-Length` header \nis set _on the request_. If your API needs you to send a `Content-Length` header with\nthe request, you can disable this streaming behavior by setting the `buffered` argument \nof the `[Body]` attribute to `true`:\n\n```csharp\nTask CreateUser([Body(buffered: true)] User user);\n```\n\n#### JSON content\n\nJSON requests and responses are serialized/deserialized using Json.NET. \nBy default, Refit will use the serializer settings that can be configured \nby setting _Newtonsoft.Json.JsonConvert.DefaultSettings_:\n\n```csharp\nJsonConvert.DefaultSettings = \n    () => new JsonSerializerSettings() { \n        ContractResolver = new CamelCasePropertyNamesContractResolver(),\n        Converters = {new StringEnumConverter()}\n    };\n\n// Serialized as: {"day":"Saturday"}\nawait PostSomeStuff(new { Day = DayOfWeek.Saturday });\n```\n\nAs these are global settings they will affect your entire application. It\nmight be beneficial to isolate the settings for calls to a particular API. \nWhen creating a Refit generated live interface, you may optionally pass a \n`RefitSettings` that will allow you to specify what serializer settings you \nwould like. This allows you to have different serializer settings for separate\nAPIs:\n\n```csharp\nvar gitHubApi = RestService.For<IGitHubApi>("https://api.github.com",\n    new RefitSettings {\n        ContentSerializer = new JsonContentSerializer( \n            new JsonSerializerSettings {\n                ContractResolver = new SnakeCasePropertyNamesContractResolver()\n        }\n    )});\n\nvar otherApi = RestService.For<IOtherApi>("https://api.example.com",\n    new RefitSettings {\n        ContentSerializer = new JsonContentSerializer( \n            new JsonSerializerSettings {\n                ContractResolver = new CamelCasePropertyNamesContractResolver()\n        }\n    )});\n```\n\nProperty serialization/deserialization can be customised using Json.NET\'s \nJsonProperty attribute:\n\n```csharp \npublic class Foo \n{\n    // Works like [AliasAs("b")] would in form posts (see below)\n    [JsonProperty(PropertyName="b")] \n    public string Bar { get; set; }\n} \n```\n\n#### XML Content\n\nXML requests and responses are serialized/deserialized using _System.Xml.Serialization.XmlSerializer_. \nBy default, Refit will use JSON content serialization, to use XML content configure the ContentSerializer to use the `XmlContentSerializer`:\n\n```csharp\nvar gitHubApi = RestService.For<IXmlApi>("https://www.w3.org/XML",\n    new RefitSettings {\n        ContentSerializer = new XmlContentSerializer()\n    });\n```\n\nProperty serialization/deserialization can be customised using   attributes found in the _System.Xml.Serialization_ namespace:\n\n```csharp\n    public class Foo\n    {\n        [XmlElement(Namespace = "https://www.w3.org/XML")]\n        public string Bar { get; set; }\n    }\n```\n\nThe _System.Xml.Serialization.XmlSerializer_ provides many options for serializing, those options can be set by providing an `XmlContentSerializerSettings` to the `XmlContentSerializer` constructor:\n\n```csharp\nvar gitHubApi = RestService.For<IXmlApi>("https://www.w3.org/XML",\n    new RefitSettings {\n        ContentSerializer = new XmlContentSerializer(\n            new XmlContentSerializerSettings\n            {\n                XmlReaderWriterSettings = new XmlReaderWriterSettings()\n                {\n                    ReaderSettings = new XmlReaderSettings\n                    {\n                        IgnoreWhitespace = true\n                    }\n                }\n            }\n        )\n    });\n```\n\n#### <a name="form-posts"></a>Form posts\n\nFor APIs that take form posts (i.e. serialized as `application/x-www-form-urlencoded`),\ninitialize the Body attribute with `BodySerializationMethod.UrlEncoded`.\n\nThe parameter can be an `IDictionary`:\n\n```csharp\npublic interface IMeasurementProtocolApi\n{\n    [Post("/collect")]\n    Task Collect([Body(BodySerializationMethod.UrlEncoded)] Dictionary<string, object> data);\n}\n\nvar data = new Dictionary<string, object> {\n    {"v", 1}, \n    {"tid", "UA-1234-5"}, \n    {"cid", new Guid("d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c")}, \n    {"t", "event"},\n};\n\n// Serialized as: v=1&tid=UA-1234-5&cid=d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&t=event\nawait api.Collect(data);\n```\n\nOr you can just pass any object and all _public, readable_ properties will \nbe serialized as form fields in the request. This approach allows you to alias \nproperty names using `[AliasAs("whatever")]` which can help if the API has\ncryptic field names:\n\n```csharp\npublic interface IMeasurementProtocolApi\n{\n    [Post("/collect")]\n    Task Collect([Body(BodySerializationMethod.UrlEncoded)] Measurement measurement);\n}\n\npublic class Measurement\n{\n    // Properties can be read-only and [AliasAs] isn\'t required\n    public int v { get { return 1; } }\n \n    [AliasAs("tid")]\n    public string WebPropertyId { get; set; }\n\n    [AliasAs("cid")]\n    public Guid ClientId { get; set; }\n\n    [AliasAs("t")] \n    public string Type { get; set; }\n\n    public object IgnoreMe { private get; set; }\n}\n\nvar measurement = new Measurement { \n    WebPropertyId = "UA-1234-5", \n    ClientId = new Guid("d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c"), \n    Type = "event" \n}; \n\n// Serialized as: v=1&tid=UA-1234-5&cid=d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&t=event\nawait api.Collect(measurement);\n``` \n\nIf you have a type that has `[JsonProperty(PropertyName)]` attributes setting property aliases, Refit will use those too (`[AliasAs]` will take precedence where you have both). \nThis means that the following type will serialize as `one=value1&two=value2`:\n\n```csharp\n\npublic class SomeObject\n{\n    [JsonProperty(PropertyName = "one")]\n    public string FirstProperty { get; set; }\n\n    [JsonProperty(PropertyName = "notTwo")]\n    [AliasAs("two")]\n    public string SecondProperty { get; set; }\n}\n\n```\n\n**NOTE:** This use of `AliasAs` applies to querystring parameters and form body posts, but not to response objects; for aliasing fields on response objects, you\'ll still need to use `[JsonProperty("full-property-name")]`.\n\n### Setting request headers\n\n#### Static headers\n\nYou can set one or more static request headers for a request applying a `Headers` \nattribute to the method:\n\n```csharp\n[Headers("User-Agent: Awesome Octocat App")]\n[Get("/users/{user}")]\nTask<User> GetUser(string user);\n```\n\nStatic headers can also be added to _every request in the API_ by applying the \n`Headers` attribute to the interface:\n\n```csharp\n[Headers("User-Agent: Awesome Octocat App")]\npublic interface IGitHubApi\n{\n    [Get("/users/{user}")]\n    Task<User> GetUser(string user);\n    \n    [Post("/users/new")]\n    Task CreateUser([Body] User user);\n}\n```\n\n#### Dynamic headers\n\nIf the content of the header needs to be set at runtime, you can add a header\nwith a dynamic value to a request by applying a `Header` attribute to a parameter:\n\n```csharp\n[Get("/users/{user}")]\nTask<User> GetUser(string user, [Header("Authorization")] string authorization);\n\n// Will add the header "Authorization: token OAUTH-TOKEN" to the request\nvar user = await GetUser("octocat", "token OAUTH-TOKEN"); \n```\n\n#### Authorization (Dynamic Headers redux)\nThe most common reason to use headers is for authorization. Today most API\'s use some flavor of oAuth with access tokens that expire and refresh tokens that are longer lived.\n\nOne way to encapsulate these kinds of token usage, a custom `HttpClientHandler` can be inserted instead.  \nThere are two classes for doing this: one is `AuthenticatedHttpClientHandler`, which takes a `Func<Task<string>>` parameter, where a signature can be generated without knowing about the request.\nThe other is `AuthenticatedParameterizedHttpClientHandler`, which takes a `Func<HttpRequestMessage, Task<string>>` parameter, where the signature requires information about the request (see earlier notes about Twitter\'s API)\n\nFor example:\n```csharp\nclass AuthenticatedHttpClientHandler : HttpClientHandler\n{\n    private readonly Func<Task<string>> getToken;\n\n    public AuthenticatedHttpClientHandler(Func<Task<string>> getToken)\n    {\n        if (getToken == null) throw new ArgumentNullException(nameof(getToken));\n        this.getToken = getToken;\n    }\n\n    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n    {\n        // See if the request has an authorize header\n        var auth = request.Headers.Authorization;\n        if (auth != null)\n        {\n            var token = await getToken().ConfigureAwait(false);\n            request.Headers.Authorization = new AuthenticationHeaderValue(auth.Scheme, token);\n        }\n\n        return await base.SendAsync(request, cancellationToken).ConfigureAwait(false);\n    }\n}\n```\n\nOr:\n\n```csharp\nclass AuthenticatedParameterizedHttpClientHandler : DelegatingHandler\n    {\n        readonly Func<HttpRequestMessage, Task<string>> getToken;\n\n        public AuthenticatedParameterizedHttpClientHandler(Func<HttpRequestMessage, Task<string>> getToken, HttpMessageHandler innerHandler = null)\n            : base(innerHandler ?? new HttpClientHandler())\n        {\n            this.getToken = getToken ?? throw new ArgumentNullException(nameof(getToken));\n        }\n\n        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            // See if the request has an authorize header\n            var auth = request.Headers.Authorization;\n            if (auth != null)\n            {\n                var token = await getToken(request).ConfigureAwait(false);\n                request.Headers.Authorization = new AuthenticationHeaderValue(auth.Scheme, token);\n            }\n\n            return await base.SendAsync(request, cancellationToken).ConfigureAwait(false);\n        }\n    }\n```\n\nWhile HttpClient contains a nearly identical method signature, it is used differently. HttpClient.SendAsync is not called by Refit. The HttpClientHandler must be modified instead.\n\nThis class is used like so (example uses the [ADAL](http://msdn.microsoft.com/en-us/library/azure/jj573266.aspx) library to manage auto-token refresh but the principal holds for Xamarin.Auth or any other library:\n\n```csharp\nclass LoginViewModel\n{\n    AuthenticationContext context = new AuthenticationContext(...);\n    \n    private async Task<string> GetToken()\n    {\n        // The AcquireTokenAsync call will prompt with a UI if necessary\n        // Or otherwise silently use a refresh token to return\n        // a valid access token\t\n        var token = await context.AcquireTokenAsync("http://my.service.uri/app", "clientId", new Uri("callback://complete"));\n        \n        return token;\n    }\n\n    public async Task LoginAndCallApi()\n    {\n        var api = RestService.For<IMyRestService>(new HttpClient(new AuthenticatedHttpClientHandler(GetToken)) { BaseAddress = new Uri("https://the.end.point/") });\n        var location = await api.GetLocationOfRebelBase();\n    }\n}\n\ninterface IMyRestService\n{\n    [Get("/getPublicInfo")]\n    Task<Foobar> SomePublicMethod();\n\n    [Get("/secretStuff")]\n    [Headers("Authorization: Bearer")]\n    Task<Location> GetLocationOfRebelBase();\n}\n```\n\nIn the above example, any time a method that requires authentication is called, the `AuthenticatedHttpClientHandler` will try to get a fresh access token. It\'s up to the app to provide one, checking the expiration time of an existing access token and obtaining a new one if needed. \n\n#### Redefining headers\n\nUnlike Retrofit, where headers do not overwrite each other and are all added to \nthe request regardless of how many times the same header is defined, Refit takes \na similar approach to the approach ASP.NET MVC takes with action filters &mdash; \n**redefining a header will replace it**, in the following order of precedence:\n\n* `Headers` attribute on the interface _(lowest priority)_\n* `Headers` attribute on the method\n* `Header` attribute on a method parameter _(highest priority)_\n\n```csharp\n[Headers("X-Emoji: :rocket:")]\npublic interface IGitHubApi\n{\n    [Get("/users/list")]\n    Task<List> GetUsers();\n    \n    [Get("/users/{user}")]\n    [Headers("X-Emoji: :smile_cat:")]\n    Task<User> GetUser(string user);\n    \n    [Post("/users/new")]\n    [Headers("X-Emoji: :metal:")]\n    Task CreateUser([Body] User user, [Header("X-Emoji")] string emoji);\n}\n\n// X-Emoji: :rocket:\nvar users = await GetUsers();\n\n// X-Emoji: :smile_cat:\nvar user = await GetUser("octocat");\n\n// X-Emoji: :trollface:\nawait CreateUser(user, ":trollface:");\n```\n\n**Note:** This redefining behavior only applies to headers _with the same name_. Headers with different names are not replaced. The following code will result in all headers being included:\n\n```csharp\n[Headers("Header-A: 1")]\npublic interface ISomeApi\n{\n    [Headers("Header-B: 2")]\n    [Post("/post")]\n    Task PostTheThing([Header("Header-C")] int c);\n}\n\n// Header-A: 1\n// Header-B: 2\n// Header-C: 3\nvar user = await api.PostTheThing(3);\n```\n\n#### Removing headers\n\nHeaders defined on an interface or method can be removed by redefining \na static header without a value (i.e. without `: <value>`) or passing `null` for \na dynamic header. _Empty strings will be included as empty headers._\n\n```csharp\n[Headers("X-Emoji: :rocket:")]\npublic interface IGitHubApi\n{\n    [Get("/users/list")]\n    [Headers("X-Emoji")] // Remove the X-Emoji header\n    Task<List> GetUsers();\n    \n    [Get("/users/{user}")]\n    [Headers("X-Emoji:")] // Redefine the X-Emoji header as empty\n    Task<User> GetUser(string user);\n    \n    [Post("/users/new")]\n    Task CreateUser([Body] User user, [Header("X-Emoji")] string emoji);\n}\n\n// No X-Emoji header\nvar users = await GetUsers();\n\n// X-Emoji: \nvar user = await GetUser("octocat");\n\n// No X-Emoji header\nawait CreateUser(user, null); \n\n// X-Emoji: \nawait CreateUser(user, ""); \n```\n\n### Multipart uploads\n\nMethods decorated with `Multipart` attribute will be submitted with multipart content type.\nAt this time, multipart methods support the following parameter types:\n\n - string (parameter name will be used as name and string value as value)\n - byte array\n - Stream\n - FileInfo\n\nThe parameter name will be used as the name of the field in the multipart data. This can be overridden with the `AliasAs` attribute.\nA custom boundary can be specified with an optional string parameter to the `Multipart` attribute. If left empty, this defaults to `----MyGreatBoundary`.\n\nTo specify the file name and content type for byte array (`byte[]`), `Stream` and `FileInfo` parameters, use of a wrapper class is required.\nThe wrapper classes for these types are `ByteArrayPart`, `StreamPart` and `FileInfoPart`.\n\n```csharp\npublic interface ISomeApi\n{\n    [Multipart]\n    [Post("/users/{id}/photo")]\n    Task UploadPhoto(int id, [AliasAs("myPhoto")] StreamPart stream);\n}\n```\n\nTo pass a Stream to this method, construct a StreamPart object like so:\n\n```csharp\nsomeApiInstance.UploadPhoto(id, new StreamPart(myPhotoStream, "photo.jpg", "image/jpeg"));\n```\n\nNote: The AttachmentName attribute that was previously described in this section has been deprecated and its use is not recommended.\n\n### Retrieving the response\n\nNote that in Refit unlike in Retrofit, there is no option for a synchronous\nnetwork request - all requests must be async, either via `Task` or via\n`IObservable`. There is also no option to create an async method via a Callback\nparameter unlike Retrofit, because we live in the async/await future.\n\nSimilarly to how body content changes via the parameter type, the return type\nwill determine the content returned.\n\nReturning Task without a type parameter will discard the content and solely\ntell you whether or not the call succeeded:\n\n```csharp\n[Post("/users/new")]\nTask CreateUser([Body] User user);\n\n// This will throw if the network call fails\nawait CreateUser(someUser);\n```\n\nIf the type parameter is \'HttpResponseMessage\' or \'string\', the raw response\nmessage or the content as a string will be returned respectively.\n\n```csharp\n// Returns the content as a string (i.e. the JSON data)\n[Get("/users/{user}")]\nTask<string> GetUser(string user);\n\n// Returns the raw response, as an IObservable that can be used with the\n// Reactive Extensions\n[Get("/users/{user}")]\nIObservable<HttpResponseMessage> GetUser(string user);\n```\n\n### Using generic interfaces\n\nWhen using something like ASP.NET Web API, it\'s a fairly common pattern to have a whole stack of CRUD REST services. Refit now supports these, allowing you to define a single API interface with a generic type:\n\n```csharp\npublic interface IReallyExcitingCrudApi<T, in TKey> where T : class\n{\n    [Post("")]\n    Task<T> Create([Body] T payload);\n\n    [Get("")]\n    Task<List<T>> ReadAll();\n\n    [Get("/{key}")]\n    Task<T> ReadOne(TKey key);\n\n    [Put("/{key}")]\n    Task Update(TKey key, [Body]T payload);\n\n    [Delete("/{key}")]\n    Task Delete(TKey key);\n}\n```\n\nWhich can be used like this:\n\n```csharp\n// The "/users" part here is kind of important if you want it to work for more \n// than one type (unless you have a different domain for each type)\nvar api = RestService.For<IReallyExcitingCrudApi<User, string>>("http://api.example.com/users"); \n``` \n### Interface inheritance\n\nWhen multiple services that need to be kept separate share a number of APIs, it is possible to leverage interface inheritance to avoid having to define the same Refit methods multiple times in different services:\n\n```csharp\npublic interface IBaseService\n{\n    [Get("/resources")]\n    Task<Resource> GetResource(string id);\n}\n\npublic interface IDerivedServiceA : IBaseService\n{\n    [Delete("/resources")]\n    Task DeleteResource(string id);\n}\n\npublic interface IDerivedServiceB : IBaseService\n{\n    [Post("/resources")]\n    Task<string> AddResource([Body] Resource resource);\n}\n```\n\nIn this example, the `IDerivedServiceA` interface will expose both the `GetResource` and `DeleteResource` APIs, while `IDerivedServiceB` will expose `GetResource` and `AddResource`.\n\n#### Headers inheritance\n\nWhen using inheritance, existing header attributes will passed along as well, and the inner-most ones will have precedence:\n\n```csharp\n[Headers("User-Agent: AAA")]\npublic interface IAmInterfaceA\n{\n    [Get("/get?result=Ping")]\n    Task<string> Ping();\n}\n\n[Headers("User-Agent: BBB")]\npublic interface IAmInterfaceB : IAmInterfaceA\n{\n    [Get("/get?result=Pang")]\n    [Headers("User-Agent: PANG")]\n    Task<string> Pang();\n\n    [Get("/get?result=Foo")]\n    Task<string> Foo();\n}\n```\n\nHere, `IAmInterfaceB.Pang()` will use `PANG` as its user agent, while `IAmInterfaceB.Foo` and `IAmInterfaceB.Ping` will use `BBB`.\nNote that if `IAmInterfaceB` didn\'t have a header attribute, `Foo` would then use the `AAA` value inherited from `IAmInterfaceA`.\nIf an interface is inheriting more than one interface, the order of precedence is the same as the one in which the inherited interfaces are declared:\n\n```csharp\npublic interface IAmInterfaceC : IAmInterfaceA, IAmInterfaceB\n{\n    [Get("/get?result=Foo")]\n    Task<string> Foo();\n}\n```\n\nHere `IAmInterfaceC.Foo` would use the header attribute inherited from `IAmInterfaceA`, if present, or the one inherited from `IAmInterfaceB`, and so on for all the declared interfaces.\n\n### Using HttpClientFactory\n\nRefit has first class support for the ASP.Net Core 2.1 HttpClientFactory. Add a reference to `Refit.HttpClientFactory` and call \nthe provided extension method in your `ConfigureServices` method to configure your Refit interface:\n\n```csharp\nservices.AddRefitClient<IWebApi>()\n        .ConfigureHttpClient(c => c.BaseAddress = new Uri("https://api.example.com"));\n        // Add additional IHttpClientBuilder chained methods as required here:\n        // .AddHttpMessageHandler<MyHandler>()\n        // .SetHandlerLifetime(TimeSpan.FromMinutes(2));\n```\n\nOptionally, a `RefitSettings` object can be included: \n```csharp\nvar settings = new RefitSettings(); \n// Configure refit settings here\n\nservices.AddRefitClient<IWebApi>(settings)\n        .ConfigureHttpClient(c => c.BaseAddress = new Uri("https://api.example.com"));\n        // Add additional IHttpClientBuilder chained methods as required here:\n        // .AddHttpMessageHandler<MyHandler>()\n        // .SetHandlerLifetime(TimeSpan.FromMinutes(2));\n```\nNote that some of the properties of `RefitSettings` will be ignored because the `HttpClient` and `HttpClientHandlers` will be managed by the `HttpClientFactory` instead of Refit.\n\nYou can then get the api interface using constructor injection:\n\n```csharp\npublic class HomeController : Controller\n{\n    public HomeController(IWebApi webApi)\n    {\n        _webApi = webApi;\n    }\n\n    private readonly IWebApi _webApi;\n\n    public async Task<IActionResult> Index(CancellationToken cancellationToken)\n    {\n        var thing = await _webApi.GetSomethingWeNeed(cancellationToken);\n        return View(thing);\n    }\n}\n```\n\n### Handling exceptions\n\nTo encapsulate any exceptions that may come from a service, you can catch an `ApiException` which contains request- and response information. Refit also supports the catching of validation exceptions that are thrown by a service implementing the RFC 7807 specification for problem details due to bad requests. For specific information on the problem details of the validation exception, simply catch `ValidationApiException`:\n\n```csharp\n// ...\ntry\n{\n   var result = await awesomeApi.GetFooAsync("bar");\n}\ncatch (ValidationApiException validationException)\n{\n   // handle validation here by using validationException.Content,\n   // which is type of ProblemDetails according to RFC 7807\n\n   // If the response contains additional properties on the problem details,\n   // they will be added to the validationException.Content.Extensions collection.\n}\ncatch (ApiException exception)\n{\n   // other exception handling\n}\n// ...\n```\n'