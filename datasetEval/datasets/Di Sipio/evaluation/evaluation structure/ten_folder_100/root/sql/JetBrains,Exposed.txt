b'[![JetBrains team project](https://jb.gg/badges/team.svg)](https://confluence.jetbrains.com/display/ALL/JetBrains+on+GitHub)\n[![TC Build status](https://teamcity.jetbrains.com/app/rest/builds/buildType:(id:KotlinTools_Exposed_Build)/statusIcon)](https://teamcity.jetbrains.com/viewType.html?buildTypeId=KotlinTools_Exposed_Build&guest=1)  [![Download](https://api.bintray.com/packages/kotlin/exposed/exposed/images/download.svg) ](https://bintray.com/kotlin/exposed/exposed/_latestVersion)\n[![GitHub License](https://img.shields.io/badge/license-Apache%20License%202.0-blue.svg?style=flat)](https://www.apache.org/licenses/LICENSE-2.0)\n\nExposed - Kotlin SQL Library\n==================\n\n_Exposed_ is a lightweight SQL library written for [Kotlin](https://github.com/JetBrains/kotlin) language.\nIt does have two layers of database access: typesafe SQL wrapping DSL and lightweight data access objects.\n\nExposed is currently available for maven/gradle builds at https://bintray.com/kotlin/exposed/exposed/view#\n\nYou can inspect project [roadmap](ROADMAP.md) to see what\'s coming next or look into [Change log](ChangeLog.md) for list of bug fixes and improvements.\n\n## Dialects\n\nCurrently supported database dialects:\n* PostgreSQL\n* MySQL\n* MariaDB\n* [Oracle](ORACLE.md)\n* SQLite\n* H2\n* [SQL Server](SQLServer.md)\n\n## SQL DSL sample:\n```kotlin\nimport org.jetbrains.exposed.sql.*\nimport org.jetbrains.exposed.sql.transactions.transaction\n\nobject Users : Table() {\n    val id = varchar("id", 10).primaryKey() // Column<String>\n    val name = varchar("name", length = 50) // Column<String>\n    val cityId = (integer("city_id") references Cities.id).nullable() // Column<Int?>\n}\n\nobject Cities : Table() {\n    val id = integer("id").autoIncrement().primaryKey() // Column<Int>\n    val name = varchar("name", 50) // Column<String>\n}\n\nfun main(args: Array<String>) {\n    Database.connect("jdbc:h2:mem:test", driver = "org.h2.Driver")\n\n    transaction {\n        SchemaUtils.create (Cities, Users)\n\n        val saintPetersburgId = Cities.insert {\n            it[name] = "St. Petersburg"\n        } get Cities.id\n\n        val munichId = Cities.insert {\n            it[name] = "Munich"\n        } get Cities.id\n\n        Cities.insert {\n            it[name] = "Prague"\n        }\n\n        Users.insert {\n            it[id] = "andrey"\n            it[name] = "Andrey"\n            it[cityId] = saintPetersburgId\n        }\n\n        Users.insert {\n            it[id] = "sergey"\n            it[name] = "Sergey"\n            it[cityId] = munichId\n        }\n\n        Users.insert {\n            it[id] = "eugene"\n            it[name] = "Eugene"\n            it[cityId] = munichId\n        }\n\n        Users.insert {\n            it[id] = "alex"\n            it[name] = "Alex"\n            it[cityId] = null\n        }\n\n        Users.insert {\n            it[id] = "smth"\n            it[name] = "Something"\n            it[cityId] = null\n        }\n\n        Users.update({Users.id eq "alex"}) {\n            it[name] = "Alexey"\n        }\n\n        Users.deleteWhere{Users.name like "%thing"}\n\n        println("All cities:")\n\n        for (city in Cities.selectAll()) {\n            println("${city[Cities.id]}: ${city[Cities.name]}")\n        }\n\n        println("Manual join:")\n        (Users innerJoin Cities).slice(Users.name, Cities.name).\n            select {(Users.id.eq("andrey") or Users.name.eq("Sergey")) and\n                    Users.id.eq("sergey") and Users.cityId.eq(Cities.id)}.forEach {\n            println("${it[Users.name]} lives in ${it[Cities.name]}")\n        }\n\n        println("Join with foreign key:")\n\n\n        (Users innerJoin Cities).slice(Users.name, Users.cityId, Cities.name).\n                select {Cities.name.eq("St. Petersburg") or Users.cityId.isNull()}.forEach {\n            if (it[Users.cityId] != null) {\n                println("${it[Users.name]} lives in ${it[Cities.name]}")\n            }\n            else {\n                println("${it[Users.name]} lives nowhere")\n            }\n        }\n\n        println("Functions and group by:")\n\n        ((Cities innerJoin Users).slice(Cities.name, Users.id.count()).selectAll().groupBy(Cities.name)).forEach {\n            val cityName = it[Cities.name]\n            val userCount = it[Users.id.count()]\n\n            if (userCount > 0) {\n                println("$userCount user(s) live(s) in $cityName")\n            } else {\n                println("Nobody lives in $cityName")\n            }\n        }\n\n        SchemaUtils.drop (Users, Cities)\n\n    }\n}\n\n```\n\nOutputs:\n```\n    SQL: CREATE TABLE IF NOT EXISTS Cities (id INT AUTO_INCREMENT NOT NULL, name VARCHAR(50) NOT NULL, CONSTRAINT pk_Cities PRIMARY KEY (id))\n    SQL: CREATE TABLE IF NOT EXISTS Users (id VARCHAR(10) NOT NULL, name VARCHAR(50) NOT NULL, city_id INT NULL, CONSTRAINT pk_Users PRIMARY KEY (id))\n    SQL: ALTER TABLE Users ADD FOREIGN KEY (city_id) REFERENCES Cities(id)\n    SQL: INSERT INTO Cities (name) VALUES (\'St. Petersburg\')\n    SQL: INSERT INTO Cities (name) VALUES (\'Munich\')\n    SQL: INSERT INTO Cities (name) VALUES (\'Prague\')\n    SQL: INSERT INTO Users (id, name, city_id) VALUES (\'andrey\', \'Andrey\', 1)\n    SQL: INSERT INTO Users (id, name, city_id) VALUES (\'sergey\', \'Sergey\', 2)\n    SQL: INSERT INTO Users (id, name, city_id) VALUES (\'eugene\', \'Eugene\', 2)\n    SQL: INSERT INTO Users (id, name, city_id) VALUES (\'alex\', \'Alex\', NULL)\n    SQL: INSERT INTO Users (id, name, city_id) VALUES (\'smth\', \'Something\', NULL)\n    SQL: UPDATE Users SET name=\'Alexey\' WHERE Users.id = \'alex\'\n    SQL: DELETE FROM Users WHERE Users.name LIKE \'%thing\'\n    All cities:\n    SQL: SELECT Cities.id, Cities.name FROM Cities\n    1: St. Petersburg\n    2: Munich\n    3: Prague\n    Manual join:\n    SQL: SELECT Users.name, Cities.name FROM Users INNER JOIN Cities ON Cities.id = Users.city_id WHERE ((Users.id = \'andrey\') or (Users.name = \'Sergey\')) and Users.id = \'sergey\' and Users.city_id = Cities.id\n    Sergey lives in Munich\n    Join with foreign key:\n    SQL: SELECT Users.name, Users.city_id, Cities.name FROM Users INNER JOIN Cities ON Cities.id = Users.city_id WHERE (Cities.name = \'St. Petersburg\') or (Users.city_id IS NULL)\n    Andrey lives in St. Petersburg\n    Functions and group by:\n    SQL: SELECT Cities.name, COUNT(Users.id) FROM Cities INNER JOIN Users ON Cities.id = Users.city_id GROUP BY Cities.name\n    1 user(s) live(s) in St. Petersburg\n    2 user(s) live(s) in Munich\n    SQL: DROP TABLE Users\n    SQL: DROP TABLE Cities\n```\n\n## DAO sample\n```kotlin\nimport org.jetbrains.exposed.sql.*\nimport org.jetbrains.exposed.sql.transactions.transaction\nimport org.jetbrains.exposed.dao.*\n\nobject Users : IntIdTable() {\n    val name = varchar("name", 50).index()\n    val city = reference("city", Cities)\n    val age = integer("age")\n}\n\nobject Cities: IntIdTable() {\n    val name = varchar("name", 50)\n}\n\nclass User(id: EntityID<Int>) : IntEntity(id) {\n    companion object : IntEntityClass<User>(Users)\n\n    var name by Users.name\n    var city by City referencedOn Users.city\n    var age by Users.age\n}\n\nclass City(id: EntityID<Int>) : IntEntity(id) {\n    companion object : IntEntityClass<City>(Cities)\n\n    var name by Cities.name\n    val users by User referrersOn Users.city\n}\n\nfun main(args: Array<String>) {\n    Database.connect("jdbc:h2:mem:test", driver = "org.h2.Driver")\n\n    transaction {\n        addLogger(StdOutSqlLogger)\n\n        SchemaUtils.create (Cities, Users)\n\n        val stPete = City.new {\n            name = "St. Petersburg"\n        }\n\n        val munich = City.new {\n            name = "Munich"\n        }\n\n        User.new {\n            name = "a"\n            city = stPete\n            age = 5\n        }\n\n        User.new {\n            name = "b"\n            city = stPete\n            age = 27\n        }\n\n        User.new {\n            name = "c"\n            city = munich\n            age = 42\n        }\n\n        println("Cities: ${City.all().joinToString {it.name}}")\n        println("Users in ${stPete.name}: ${stPete.users.joinToString {it.name}}")\n        println("Adults: ${User.find { Users.age greaterEq 18 }.joinToString {it.name}}")\n    }\n}\n```\n\nOutputs:\n```\n    SQL: CREATE TABLE IF NOT EXISTS Cities (id INT AUTO_INCREMENT NOT NULL, name VARCHAR(50) NOT NULL, CONSTRAINT pk_Cities PRIMARY KEY (id))\n    SQL: CREATE TABLE IF NOT EXISTS Users (id INT AUTO_INCREMENT NOT NULL, name VARCHAR(50) NOT NULL, city INT NOT NULL, age INT NOT NULL, CONSTRAINT pk_Users PRIMARY KEY (id))\n    SQL: CREATE INDEX Users_name ON Users (name)\n    SQL: ALTER TABLE Users ADD FOREIGN KEY (city) REFERENCES Cities(id)\n    SQL: INSERT INTO Cities (name) VALUES (\'St. Petersburg\'),(\'Munich\')\n    SQL: SELECT Cities.id, Cities.name FROM Cities\n    Cities: St. Petersburg, Munich\n    SQL: INSERT INTO Users (name, city, age) VALUES (\'a\', 1, 5),(\'b\', 1, 27),(\'c\', 2, 42)\n    SQL: SELECT Users.id, Users.name, Users.city, Users.age FROM Users WHERE Users.city = 1\n    Users in St. Petersburg: a, b\n    SQL: SELECT Users.id, Users.name, Users.city, Users.age FROM Users WHERE Users.age >= 18\n    Adults: b, c\n```\n\nFind more examples and documentation on the [wiki](https://github.com/JetBrains/Exposed/wiki).\n'