b'![requery](http://requery.github.io/logo.png)\n\nA light but powerful object mapping and SQL generator for Java/Kotlin/Android with RxJava and Java 8 support.\nEasily map to or create databases, perform queries and updates from any platform that uses Java.\n\n[![Build Status](https://travis-ci.org/requery/requery.svg?branch=master)](https://travis-ci.org/requery/requery)\n[![Download](https://api.bintray.com/packages/requery/requery/requery/images/download.svg)](https://bintray.com/requery/requery/requery/_latestVersion)\n\nExamples\n--------\n\nDefine entities from an abstract class:\n\n```java\n@Entity\nabstract class AbstractPerson {\n\n    @Key @Generated\n    int id;\n\n    @Index("name_index")                     // table specification\n    String name;\n\n    @OneToMany                               // relationships 1:1, 1:many, many to many\n    Set<Phone> phoneNumbers;\n\n    @Converter(EmailToStringConverter.class) // custom type conversion\n    Email email;\n\n    @PostLoad                                // lifecycle callbacks\n    void afterLoad() {\n        updatePeopleList();\n    }\n    // getter, setters, equals & hashCode automatically generated into Person.java\n}\n\n```\nor from an interface:\n\n```java\n@Entity\npublic interface Person {\n\n    @Key @Generated\n    int getId();\n\n    String getName();\n\n    @OneToMany\n    Set<Phone> getPhoneNumbers();\n\n    String getEmail();\n}\n```\nor use immutable types such as those generated by [@AutoValue](https://github.com/google/auto/tree/master/value):\n\n```java\n@AutoValue\n@Entity\nabstract class Person {\n\n    @AutoValue.Builder\n    static abstract class Builder {\n        abstract Builder setId(int id);\n        abstract Builder setName(String name);\n        abstract Builder setEmail(String email);\n        abstract Person build();\n    }\n\n    static Builder builder() {\n        return new AutoValue_Person.Builder();\n    }\n\n    @Key\n    abstract int getId();\n\n    abstract String getName();\n    abstract String getEmail();\n}\n```\n(Note some features will not be available when using immutable types, see [here](https://github.com/requery/requery/wiki/Immutable-types))\n\n**Queries:** dsl based query that maps to SQL\n\n```java\nResult<Person> query = data\n    .select(Person.class)\n    .where(Person.NAME.lower().like("b%")).and(Person.AGE.gt(20))\n    .orderBy(Person.AGE.desc())\n    .limit(5)\n    .get();\n```\n\n**Relationships:** represent relations more efficiently with Java 8 Streams, RxJava Observables or\nplain iterables. (sets and lists are supported to)\n\n```java\n@Entity\nabstract class AbstractPerson {\n\n    @Key @Generated\n    int id;\n\n    @ManyToMany\n    Result<Group> groups;\n    // equivalent to:\n    // data.select(Group.class)\n    // .join(Group_Person.class).on(Group_ID.equal(Group_Person.GROUP_ID))\n    // .join(Person.class).on(Group_Person.PERSON_ID.equal(Person.ID))\n    // .where(Person.ID.equal(id))\n}\n```\n\n**[Kotlin](https://github.com/requery/requery/wiki/Kotlin) specific support using property references and infix functions:**\n\n```kotlin\ndata {\n    val result = select(Person::class) where (Person::age gt 21) and (Person::name eq "Bob") limit 10\n}\n```\n\n**Java 8 [streams](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html):**\n\n```java\ndata.select(Person.class)\n    .orderBy(Person.AGE.desc())\n    .get()\n    .stream().forEach(System.out::println);\n```\n\n**Java 8 optional and time support:**\n\n```java\npublic interface Person {\n\n    @Key @Generated\n    int getId();\n\n    String getName();\n    Optional<String> getEmail();\n    ZonedDateTime getBirthday();\n}\n```\n\n**[RxJava](https://github.com/ReactiveX/RxJava) [Observables](http://reactivex.io/documentation/observable.html):**\n\n```java\nObservable<Person> observable = data\n    .select(Person.class)\n    .orderBy(Person.AGE.desc())\n    .get()\n    .observable();\n```\n\n**[RxJava](https://github.com/ReactiveX/RxJava) observe query on table changes:**\n\n```java\nObservable<Person> observable = data\n    .select(Person.class)\n    .orderBy(Person.AGE.desc())\n    .get()\n    .observableResult().subscribe(::updateFromResult);\n```\n\n**Read/write separation** Along with immutable types optionally separate queries (reading)\nand updates (writing):\n\n```java\nint rows = data.update(Person.class)\n    .set(Person.ABOUT, "student")\n    .where(Person.AGE.lt(21)).get().value();\n```\n\nFeatures\n--------\n\n- No Reflection\n- Fast startup & performance\n- No dependencies (RxJava is optional)\n- Typed query language\n- Table generation\n- Supports JDBC and most popular databases (MySQL, Oracle, SQL Server, Postgres and more)\n- Supports Android (SQLite, RecyclerView, Databinding, SQLCipher)\n- Blocking and non-blocking API\n- Partial objects/refresh\n- Upsert support\n- Caching\n- Lifecycle callbacks\n- Custom type converters\n- Compile time entity validation\n- JPA annotations (however requery is not a JPA provider)\n\nReflection free\n---------------\n\nrequery uses compile time annotation processing to generate entity model classes and mapping\nattributes. On Android this means you get about the same performance reading objects from a query\nas if it was populated using the standard Cursor and ContentValues API.\n\nQuery with Java\n---------------\n\nThe compiled classes work with the query API to take advantage of compile time generated attributes.\nCreate type safe queries and avoid hard to maintain, error prone string concatenated queries.\n\nRelationships\n-------------\n\nYou can define One-to-One, One-to-Many, Many-to-One, and Many-to-Many relations in your models using\nannotations. Relationships can be navigated in both directions. Of many type relations can be loaded\ninto standard java collection objects or into a more efficient\n[Result](http://requery.github.io/javadoc/io/requery/query/Result.html) type.\nFrom a [Result](http://requery.github.io/javadoc/io/requery/query/Result.html)\neasily create a Stream, RxJava Observable, Iterator, List or Map.\n\nMany-to-Many junction tables can be generated automatically. Additionally the relation model is\nvalidated at compile time eliminating runtime errors.\n\nvs JPA\n------\n\nrequery provides a modern set of interfaces for persisting and performing queries. Some key\ndifferences between requery and JPA providers like Hibernate or EclipseLink:\n\n- Queries maps directly to SQL as opposed to JPQL.\n- Dynamic Queries easily done through a DSL as opposed to the verbose `CriteriaQuery` API.\n- Uses easily understandable extended/generated code instead of reflection/bytecode weaving for\n  state tracking and member access\n\nAndroid\n-------\n\nDesigned specifically with Android support in mind. See [requery-android/example](https://github.com/requery/requery/tree/master/requery-android/example)\nfor an example Android project using databinding and interface based entities. For more information\nsee the [Android](https://github.com/requery/requery/wiki/Android) page.\n\nSupported Databases\n-------------------\nTested on some of the most popular databases:\n\n- PostgresSQL (9.1+)\n- MySQL 5.x\n- Oracle 12c+\n- Microsoft SQL Server 2012 or later\n- SQLite (Android or with the [xerial](https://github.com/xerial/sqlite-jdbc) JDBC driver)\n- Apache Derby 10.11+\n- H2 1.4+\n- HSQLDB 2.3+\n\nJPA Annotations\n---------------\n\nA subset of the JPA annotations that map onto the requery annotations are supported.\nSee [here](https://github.com/requery/requery/wiki/JPA-Annotations) for more information.\n\nUpserts\n-------\n\nUpserts are generated with the appropriate database specific query statements:\n- Oracle/SQL Server/HSQL: `merge into when matched/not matched`\n- PostgresSQL: `on conflict do update` (requires 9.5 or later)\n- MySQL: `on duplicate key update`\n\nUsing it\n--------\n\nVersions are available on bintray jcenter / maven central.\n\n```gradle\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    compile \'io.requery:requery:1.6.1\'\n    compile \'io.requery:requery-android:1.6.1\' // for android\n    annotationProcessor \'io.requery:requery-processor:1.6.1\'\n}\n```\n\nFor information on gradle and annotation processing & gradle see the [wiki](https://github.com/requery/requery/wiki/Gradle-&-Annotation-processing#annotation-processing).\n\nLicense\n-------\n\n    Copyright (C) 2019 requery.io\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n'