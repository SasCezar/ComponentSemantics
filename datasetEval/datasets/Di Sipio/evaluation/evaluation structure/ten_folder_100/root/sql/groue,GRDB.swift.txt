b'GRDB 4 [![Swift 4.2](https://img.shields.io/badge/swift-4.2-orange.svg?style=flat)](https://developer.apple.com/swift/) [![Swift 5](https://img.shields.io/badge/swift-5-orange.svg?style=flat)](https://developer.apple.com/swift/) [![Platforms](https://img.shields.io/cocoapods/p/GRDB.swift.svg)](https://developer.apple.com/swift/) [![License](https://img.shields.io/github/license/groue/GRDB.swift.svg?maxAge=2592000)](/LICENSE) [![Build Status](https://travis-ci.org/groue/GRDB.swift.svg?branch=master)](https://travis-ci.org/groue/GRDB.swift)\n==========\n\n### A toolkit for SQLite databases, with a focus on application development\n\n---\n\n**Latest release**: November 20, 2019 \xe2\x80\xa2 version 4.6.2 \xe2\x80\xa2 [CHANGELOG](CHANGELOG.md) \xe2\x80\xa2 [Migrating From GRDB 3 to GRDB 4](Documentation/GRDB3MigrationGuide.md)\n\n**Requirements**: iOS 9.0+ / macOS 10.9+ / tvOS 9.0+ / watchOS 2.0+ &bull; Swift 4.2+ / Xcode 10.0+\n\n| Swift version | GRDB version                                                |\n| ------------- | ----------------------------------------------------------- |\n| **Swift 5**   | **v4.6.2**                                                  |\n| **Swift 4.2** | **v4.6.2**                                                  |\n| Swift 4.1     | [v3.7.0](https://github.com/groue/GRDB.swift/tree/v3.7.0)   |\n| Swift 4       | [v2.10.0](https://github.com/groue/GRDB.swift/tree/v2.10.0) |\n| Swift 3.2     | [v1.3.0](https://github.com/groue/GRDB.swift/tree/v1.3.0)   |\n| Swift 3.1     | [v1.3.0](https://github.com/groue/GRDB.swift/tree/v1.3.0)   |\n| Swift 3       | [v1.0](https://github.com/groue/GRDB.swift/tree/v1.0)       |\n| Swift 2.3     | [v0.81.2](https://github.com/groue/GRDB.swift/tree/v0.81.2) |\n| Swift 2.2     | [v0.80.2](https://github.com/groue/GRDB.swift/tree/v0.80.2) |\n\n**Contact**:\n\n- Release announcements and usage tips: follow [@groue](http://twitter.com/groue) on Twitter.\n- Report bugs in a [Github issue](https://github.com/groue/GRDB.swift/issues/new). Make sure you check the [existing issues](https://github.com/groue/GRDB.swift/issues?q=is%3Aopen) first.\n- A question? Looking for advice? Do you wonder how to contribute? Fancy a chat? Go to the [GRDB forums](https://forums.swift.org/c/related-projects/grdb), or open a [Github issue](https://github.com/groue/GRDB.swift/issues/new).\n\n\n## What is this?\n\nGRDB provides raw access to SQL and advanced SQLite features, because one sometimes enjoys a sharp tool. It has robust concurrency primitives, so that multi-threaded applications can efficiently use their databases. It grants your application models with persistence and fetching methods, so that you don\'t have to deal with SQL and raw database rows when you don\'t want to.\n\nCompared to [SQLite.swift](http://github.com/stephencelis/SQLite.swift) or [FMDB](http://github.com/ccgus/fmdb), GRDB can spare you a lot of glue code. Compared to [Core Data](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/) or [Realm](http://realm.io), it can simplify your multi-threaded applications.\n\nIt comes with [up-to-date documentation](#documentation), [general guides](#general-guides--good-practices), and it is [fast](https://github.com/groue/GRDB.swift/wiki/Performance).\n\nSee [Why Adopt GRDB?](Documentation/WhyAdoptGRDB.md) if you are looking for your favorite database library.\n\n\n---\n\n<p align="center">\n    <a href="#features">Features</a> &bull;\n    <a href="#usage">Usage</a> &bull;\n    <a href="#installation">Installation</a> &bull;\n    <a href="#documentation">Documentation</a> &bull;\n    <a href="#demo-application">Demo Application</a> &bull;\n    <a href="#faq">FAQ</a>\n</p>\n\n---\n\n\n## Features\n\nGRDB ships with:\n\n- [Access to raw SQL and SQLite](#sqlite-api)\n- [Records](#records): Fetching and persistence methods for your custom structs and class hierarchies.\n- [Query Interface](#the-query-interface): A swift way to avoid the SQL language.\n- [Associations](Documentation/AssociationsBasics.md): Relations and joins between record types.\n- [WAL Mode Support](#database-pools): Extra performance for multi-threaded applications.\n- [Migrations](#migrations): Transform your database as your application evolves.\n- [Database Observation](#database-changes-observation): Observe database changes and transactions.\n- [Full-Text Search]\n- [Encryption](#encryption)\n- [Support for Custom SQLite Builds](Documentation/CustomSQLiteBuilds.md)\n\nCompanion libraries that enhance and extend GRDB:\n\n- [GRDBCombine]: track database changes in a reactive way, with [Combine](https://developer.apple.com/documentation/combine).\n- [RxGRDB]: track database changes in a reactive way, with [RxSwift](https://github.com/ReactiveX/RxSwift).\n- [GRDBObjc](https://github.com/groue/GRDBObjc): FMDB-compatible bindings to GRDB.\n\n\n## Usage\n\n<details open>\n  <summary>Connect to an SQLite database</summary>\n\n```swift\nimport GRDB\n\n// Simple database connection\nlet dbQueue = try DatabaseQueue(path: "/path/to/database.sqlite")\n\n// Enhanced multithreading based on SQLite\'s WAL mode\nlet dbPool = try DatabasePool(path: "/path/to/database.sqlite")\n```\n    \nSee [Database Connections](#database-connections)\n\n</details>\n\n<details>\n    <summary>Execute SQL statements</summary>\n\n```swift\ntry dbQueue.write { db in\n    try db.execute(sql: """\n        CREATE TABLE place (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          title TEXT NOT NULL,\n          favorite BOOLEAN NOT NULL DEFAULT 0,\n          latitude DOUBLE NOT NULL,\n          longitude DOUBLE NOT NULL)\n        """)\n\n    try db.execute(sql: """\n        INSERT INTO place (title, favorite, latitude, longitude)\n        VALUES (?, ?, ?, ?)\n        """, arguments: ["Paris", true, 48.85341, 2.3488])\n    \n    let parisId = db.lastInsertedRowID\n    \n    // Swift 5 only\n    try db.execute(literal: """\n        INSERT INTO place (title, favorite, latitude, longitude)\n        VALUES (\\("Madrid"), \\(true), \\(40.41678), \\(-3.70379))\n        """)\n}\n```\n\nSee [Executing Updates](#executing-updates)\n\n</details>\n\n<details>\n    <summary>Fetch database rows and values</summary>\n\n```swift\ntry dbQueue.read { db in\n    // Fetch database rows\n    let rows = try Row.fetchCursor(db, sql: "SELECT * FROM place")\n    while let row = try rows.next() {\n        let title: String = row["title"]\n        let isFavorite: Bool = row["favorite"]\n        let coordinate = CLLocationCoordinate2D(\n            latitude: row["latitude"],\n            longitude: row["longitude"])\n    }\n    \n    // Fetch values\n    let placeCount = try Int.fetchOne(db, sql: "SELECT COUNT(*) FROM place")! // Int\n    let placeTitles = try String.fetchAll(db, sql: "SELECT title FROM place") // [String]\n}\n\nlet placeCount = try dbQueue.read { db in\n    try Int.fetchOne(db, sql: "SELECT COUNT(*) FROM place")!\n}\n```\n\nSee [Fetch Queries](#fetch-queries)\n\n</details>\n\n<details>\n    <summary>Store custom models aka "records"</summary>\n\n```swift\nstruct Place {\n    var id: Int64?\n    var title: String\n    var isFavorite: Bool\n    var coordinate: CLLocationCoordinate2D\n}\n\n// snip: turn Place into a "record" by adopting the protocols that\n// provide fetching and persistence methods.\n\ntry dbQueue.write { db in\n    // Create database table\n    try db.create(table: "place") { t in\n        t.autoIncrementedPrimaryKey("id")\n        t.column("title", .text).notNull()\n        t.column("favorite", .boolean).notNull().defaults(to: false)\n        t.column("longitude", .double).notNull()\n        t.column("latitude", .double).notNull()\n    }\n    \n    var berlin = Place(\n        id: nil,\n        title: "Berlin",\n        isFavorite: false,\n        coordinate: CLLocationCoordinate2D(latitude: 52.52437, longitude: 13.41053))\n    \n    try berlin.insert(db)\n    berlin.id // some value\n    \n    berlin.isFavorite = true\n    try berlin.update(db)\n}\n```\n\nSee [Records](#records)\n\n</details>\n\n<details>\n    <summary>Fetch records and values with the Swift query interface</summary>\n\n```swift\ntry dbQueue.read { db in\n    // Place?\n    let paris = try Place.fetchOne(db, key: 1)\n    \n    // Place?\n    let berlin = try Place.filter(Column("title") == "Berlin").fetchOne(db)\n    \n    // [Place]\n    let favoritePlaces = try Place\n        .filter(Column("favorite") == true)\n        .order(Column("title"))\n        .fetchAll(db)\n    \n    // Int\n    let favoriteCount = try Place.filter(Column("favorite")).fetchCount(db)\n    \n    // SQL is always welcome\n    let places = try Place.fetchAll(db, sql: "SELECT * FROM place")\n}\n```\n\nSee the [Query Interface](#the-query-interface)\n\n</details>\n\n<details>\n    <summary>Be notified of database changes</summary>\n\n```swift\nlet observation = ValueObservation.tracking { db in\n    try Place.fetchAll(db)\n}\nobservation.start(\n    in: dbQueue,\n    onError: { error in\n        print("fresh places could not be fetched")\n    }\n    onChange: { (places: [Place]) in\n        print("Places have changed.")\n    })\n```\n\nSee [Database Changes Observation](#database-changes-observation)\n\n</details>\n\n\nDocumentation\n=============\n\n**GRDB runs on top of SQLite**: you should get familiar with the [SQLite FAQ](http://www.sqlite.org/faq.html). For general and detailed information, jump to the [SQLite Documentation](http://www.sqlite.org/docs.html).\n\n#### Reference\n\n- [GRDB Reference](http://groue.github.io/GRDB.swift/docs/4.6/index.html) (generated by [Jazzy](https://github.com/realm/jazzy))\n\n#### Getting Started\n\n- [Installation](#installation)\n- [Demo Application](#demo-application)\n- [Database Connections](#database-connections): Connect to SQLite databases\n\n#### SQLite and SQL\n\n- [SQLite API](#sqlite-api): The low-level SQLite API &bull; [executing updates](#executing-updates) &bull; [fetch queries](#fetch-queries) &bull; [SQL Interpolation]\n\n#### Records and the Query Interface\n\n- [Records](#records): Fetching and persistence methods for your custom structs and class hierarchies\n- [Query Interface](#the-query-interface): A swift way to generate SQL &bull; [table creation](#database-schema) &bull; [requests](#requests) \xe2\x80\xa2 [associations between record types](Documentation/AssociationsBasics.md)\n\n#### Application Tools\n\n- [Migrations](#migrations): Transform your database as your application evolves.\n- [Full-Text Search]: Perform efficient and customizable full-text searches.\n- [Joined Queries Support](#joined-queries-support): Consume complex joined queries.\n- [Database Changes Observation](#database-changes-observation): Observe database changes and transactions.\n- [Encryption](#encryption): Encrypt your database with SQLCipher.\n- [Backup](#backup): Dump the content of a database to another.\n\n#### Good to Know\n\n- [Avoiding SQL Injection](#avoiding-sql-injection)\n- [Error Handling](#error-handling)\n- [Unicode](#unicode)\n- [Memory Management](#memory-management)\n- [Data Protection](#data-protection)\n- [Concurrency](#concurrency)\n- [Performance](#performance)\n\n#### General Guides & Good Practices\n\n- :bulb: [Good Practices for Designing Record Types](Documentation/GoodPracticesForDesigningRecordTypes.md)\n- :bulb: [Migrating From GRDB 3 to GRDB 4](Documentation/GRDB3MigrationGuide.md)\n- :bulb: [Issues tagged "best practices"](https://github.com/groue/GRDB.swift/issues?q=is%3Aissue+label%3A%22best+practices%22)\n- :question: [Issues tagged "question"](https://github.com/groue/GRDB.swift/issues?utf8=\xe2\x9c\x93&q=is%3Aissue%20label%3Aquestion)\n- :blue_book: [Why Adopt GRDB?](Documentation/WhyAdoptGRDB.md)\n- :blue_book: [How to build an iOS application with SQLite and GRDB.swift](https://medium.com/@gwendal.roue/how-to-build-an-ios-application-with-sqlite-and-grdb-swift-d023a06c29b3)\n- :blue_book: [Four different ways to handle SQLite concurrency](https://medium.com/@gwendal.roue/four-different-ways-to-handle-sqlite-concurrency-db3bcc74d00e)\n- :blue_book: [Unexpected SQLite with Swift](https://hackernoon.com/unexpected-sqlite-with-swift-ddc6343bcbfc)\n\n\n**[FAQ](#faq)**\n\n**[Sample Code](#sample-code)**\n\n\nInstallation\n============\n\n**The installation procedures below have GRDB use the version of SQLite that ships with the target operating system.**\n\nSee [Encryption](#encryption) for the installation procedure of GRDB with SQLCipher.\n\nSee [Custom SQLite builds](Documentation/CustomSQLiteBuilds.md) for the installation procedure of GRDB with a customized build of SQLite 3.28.0.\n\nSee [Enabling FTS5 Support](Documentation/FullTextSearch.md#enabling-fts5-support) for the installation procedure of GRDB with support for the FTS5 full-text engine.\n\n\n## CocoaPods\n\n[CocoaPods](http://cocoapods.org/) is a dependency manager for Xcode projects. To use GRDB with CocoaPods (version 1.2 or higher), specify in your `Podfile`:\n\n```ruby\npod \'GRDB.swift\'\n```\n\nGRDB can be installed as a framework, or a static library.\n\n## Swift Package Manager\n\nThe [Swift Package Manager](https://swift.org/package-manager/) automates the distribution of Swift code. To use GRDB with SPM, add a dependency to your `Package.swift` file:\n\n```swift\nlet package = Package(\n    dependencies: [\n        .package(url: "https://github.com/groue/GRDB.swift.git", ...)\n    ]\n)\n```\n\nNote that Linux is not currently supported.\n\n\n## Carthage\n\n[Carthage](https://github.com/Carthage/Carthage) is **unsupported**. For some context about this decision, see [#433](https://github.com/groue/GRDB.swift/issues/433).\n\n\n## Manually\n\n1. [Download](https://github.com/groue/GRDB.swift/releases) a copy of GRDB, or clone its repository and make sure you checkout the latest tagged version.\n\n2. Embed the `GRDB.xcodeproj` project in your own project.\n\n3. Add the `GRDBOSX`, `GRDBiOS`, `GRDBtvOS`, or `GRDBWatchOS` target in the **Target Dependencies** section of the **Build Phases** tab of your application target (extension target for WatchOS).\n\n4. Add the `GRDB.framework` from the targetted platform to the **Embedded Binaries** section of the **General**  tab of your application target (extension target for WatchOS).\n\n> :bulb: **Tip**: see the [Demo Application] for an example of such integration.\n\n\nDemo Application\n================\n\nThe repository comes with a [Demo Application] that shows you:\n\n- how to setup a database in an iOS app\n- how to define a simple [Codable Record](#codable-records)\n- how to track database changes with [ValueObservation].\n\n\nDatabase Connections\n====================\n\nGRDB provides two classes for accessing SQLite databases: `DatabaseQueue` and `DatabasePool`:\n\n```swift\nimport GRDB\n\n// Pick one:\nlet dbQueue = try DatabaseQueue(path: "/path/to/database.sqlite")\nlet dbPool = try DatabasePool(path: "/path/to/database.sqlite")\n```\n\nThe differences are:\n\n- Database pools allow concurrent database accesses (this can improve the performance of multithreaded applications).\n- Database pools open your SQLite database in the [WAL mode](https://www.sqlite.org/wal.html) (unless read-only).\n- Database queues support [in-memory databases](https://www.sqlite.org/inmemorydb.html).\n\n**If you are not sure, choose DatabaseQueue.** You will always be able to switch to DatabasePool later.\n\n- [Database Queues](#database-queues)\n- [Database Pools](#database-pools)\n\n\n## Database Queues\n\n**Open a database queue** with the path to a database file:\n\n```swift\nimport GRDB\n\nlet dbQueue = try DatabaseQueue(path: "/path/to/database.sqlite")\nlet inMemoryDBQueue = DatabaseQueue()\n```\n\nSQLite creates the database file if it does not already exist. The connection is closed when the database queue gets deallocated.\n\n**A database queue can be used from any thread.** The `write` and `read` methods are synchronous, and block the current thread until your database statements are executed in a protected dispatch queue:\n\n```swift\n// Modify the database:\ntry dbQueue.write { db in\n    try db.create(table: "place") { ... }\n    try Place(...).insert(db)\n}\n\n// Read values:\ntry dbQueue.read { db in\n    let places = try Place.fetchAll(db)\n    let placeCount = try Place.fetchCount(db)\n}\n```\n\nDatabase access methods can return values:\n\n```swift\nlet placeCount = try dbQueue.read { db in\n    try Place.fetchCount(db)\n}\n\nlet newPlaceCount = try dbQueue.write { db -> Int in\n    try Place(...).insert(db)\n    return try Place.fetchCount(db)\n}\n```\n\n**A database queue serializes accesses to the database**, which means that there is never more than one thread that uses the database.\n\n- When you don\'t need to modify the database, prefer the `read` method. It prevents any modification to the database.\n\n- The `write` method wraps your database statements in a transaction that commits if and only if no error occurs. On the first unhandled error, all changes are reverted, the whole transaction is rollbacked, and the error is rethrown.\n    \n    When precise transaction handling is required, see [Transactions and Savepoints](#transactions-and-savepoints).\n\n**A database queue needs your application to follow rules in order to deliver its safety guarantees.** Please refer to the [Concurrency](#concurrency) chapter.\n\n> :bulb: **Tip**: see the [Demo Application] for a sample code that sets up a database queue on iOS.\n\n\n### DatabaseQueue Configuration\n\n```swift\nvar config = Configuration()\nconfig.readonly = true\nconfig.foreignKeysEnabled = true // Default is already true\nconfig.trace = { print($0) }     // Prints all SQL statements\nconfig.label = "MyDatabase"      // Useful when your app opens multiple databases\n\nlet dbQueue = try DatabaseQueue(\n    path: "/path/to/database.sqlite",\n    configuration: config)\n```\n\nSee [Configuration](http://groue.github.io/GRDB.swift/docs/4.6/Structs/Configuration.html) for more details.\n\n\n## Database Pools\n\n**A database pool allows concurrent database accesses.**\n\n```swift\nimport GRDB\nlet dbPool = try DatabasePool(path: "/path/to/database.sqlite")\n```\n\nSQLite creates the database file if it does not already exist. The connection is closed when the database pool gets deallocated.\n\n> :point_up: **Note**: unless read-only, a database pool opens your database in the SQLite "WAL mode". The WAL mode does not fit all situations. Please have a look at https://www.sqlite.org/wal.html.\n\n**A database pool can be used from any thread.** The `write` and `read` methods are synchronous, and block the current thread until your database statements are executed in a protected dispatch queue:\n\n```swift\n// Modify the database:\ntry dbPool.write { db in\n    try db.create(table: "place") { ... }\n    try Place(...).insert(db)\n}\n\n// Read values:\ntry dbPool.read { db in\n    let places = try Place.fetchAll(db)\n    let placeCount = try Place.fetchCount(db)\n}\n```\n\nDatabase access methods can return values:\n\n```swift\nlet placeCount = try dbPool.read { db in\n    try Place.fetchCount(db)\n}\n\nlet newPlaceCount = try dbPool.write { db -> Int in\n    try Place(...).insert(db)\n    return try Place.fetchCount(db)\n}\n```\n\n**Database pools allow several threads to access the database at the same time:**\n\n- When you don\'t need to modify the database, prefer the `read` method, because several threads can perform reads in parallel.\n    \n    Reads are generally non-blocking, unless the maximum number of concurrent reads has been reached. In this case, a read has to wait for another read to complete. That maximum number can be [configured](#databasepool-configuration).\n\n- Reads are guaranteed an immutable view of the last committed state of the database, regardless of concurrent writes. This kind of isolation is called [snapshot isolation](https://sqlite.org/isolation.html).\n\n- Unlike reads, writes are serialized. There is never more than a single thread that is writing into the database.\n\n- The `write` method wraps your database statements in a transaction that commits if and only if no error occurs. On the first unhandled error, all changes are reverted, the whole transaction is rollbacked, and the error is rethrown.\n    \n    When precise transaction handling is required, see [Transactions and Savepoints](#transactions-and-savepoints).\n\n- Database pools can take [snapshots](#database-snapshots) of the database.\n\n**A database pool needs your application to follow rules in order to deliver its safety guarantees.** See the [Concurrency](#concurrency) chapter for more details about database pools, how they differ from database queues, and advanced use cases.\n\n> :bulb: **Tip**: see the [Demo Application] for a sample code that sets up a database queue on iOS, and just replace DatabaseQueue with DatabasePool.\n\n\n### DatabasePool Configuration\n\n```swift\nvar config = Configuration()\nconfig.readonly = true\nconfig.foreignKeysEnabled = true // Default is already true\nconfig.trace = { print($0) }     // Prints all SQL statements\nconfig.label = "MyDatabase"      // Useful when your app opens multiple databases\nconfig.maximumReaderCount = 10   // The default is 5\n\nlet dbPool = try DatabasePool(\n    path: "/path/to/database.sqlite",\n    configuration: config)\n```\n\nSee [Configuration](http://groue.github.io/GRDB.swift/docs/4.6/Structs/Configuration.html) for more details.\n\n\nDatabase pools are more memory-hungry than database queues. See [Memory Management](#memory-management) for more information.\n\n\nSQLite API\n==========\n\n**In this section of the documentation, we will talk SQL.** Jump to the [query interface](#the-query-interface) if SQL is not your cup of tea.\n\n- [Executing Updates](#executing-updates)\n- [Fetch Queries](#fetch-queries)\n    - [Fetching Methods](#fetching-methods)\n    - [Row Queries](#row-queries)\n    - [Value Queries](#value-queries)\n- [Values](#values)\n    - [Data](#data-and-memory-savings)\n    - [Date and DateComponents](#date-and-datecomponents)\n    - [NSNumber and NSDecimalNumber](#nsnumber-and-nsdecimalnumber)\n    - [Swift enums](#swift-enums)\n    - [Custom Value Types](#custom-value-types)\n- [Transactions and Savepoints](#transactions-and-savepoints)\n- [SQL Interpolation]\n\nAdvanced topics:\n\n- [Prepared Statements](#prepared-statements)\n- [Custom SQL Functions and Aggregates](#custom-sql-functions-and-aggregates)\n- [Database Schema Introspection](#database-schema-introspection)\n- [Row Adapters](#row-adapters)\n- [Raw SQLite Pointers](#raw-sqlite-pointers)\n\n\n## Executing Updates\n\nOnce granted with a [database connection](#database-connections), the `execute` method executes the SQL statements that do not return any database row, such as `CREATE TABLE`, `INSERT`, `DELETE`, `ALTER`, etc.\n\nFor example:\n\n```swift\ntry dbQueue.write { db in\n    try db.execute(sql: """\n        CREATE TABLE player (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL,\n            score INT)\n        """)\n    \n    try db.execute(\n        sql: "INSERT INTO player (name, score) VALUES (?, ?)",\n        arguments: ["Barbara", 1000])\n    \n    try db.execute(\n        sql: "UPDATE player SET score = :score WHERE id = :id",\n        arguments: ["score": 1000, "id": 1])\n    }\n}\n```\n\nThe `?` and colon-prefixed keys like `:score` in the SQL query are the **statements arguments**. You pass arguments with arrays or dictionaries, as in the example above. See [Values](#values) for more information on supported arguments types (Bool, Int, String, Date, Swift enums, etc.), and [StatementArguments](http://groue.github.io/GRDB.swift/docs/4.6/Structs/StatementArguments.html) for a detailed documentation of SQLite arguments.\n\nIn Swift 5, you can embed query arguments right into your SQL queries, with the `literal` argument label, as in the example below. See [SQL Interpolation] for more details.\n\n```swift\n// Swift 5\ntry dbQueue.write { db in\n    try db.execute(literal: """\n        INSERT INTO player (name, score)\n        VALUES (\\("O\'Brien"), \\(550))\n        """)\n}\n```\n\n**Never ever embed values directly in your raw SQL strings**. See [Avoiding SQL Injection](#avoiding-sql-injection) for more information:\n\n```swift\n// WRONG: don\'t embed values in raw SQL strings\nlet id = 123\nlet name = textField.text\ntry db.execute(\n    sql: "UPDATE player SET name = \'\\(name)\' WHERE id = \\(id)")\n\n// CORRECT: use SQL Interpolation (Swift 5)\ntry db.execute(\n    literal: "UPDATE player SET name = \\(name) WHERE id = \\(id)")\n\n// CORRECT: use arguments dictionary\ntry db.execute(\n    sql: "UPDATE player SET name = :name WHERE id = :id",\n    arguments: ["name": name, "id": id])\n\n// CORRECT: use arguments array\ntry db.execute(\n    sql: "UPDATE player SET name = ? WHERE id = ?",\n    arguments: [name, id])\n```\n\n**Join multiple statements with a semicolon**:\n\n```swift\ntry db.execute(sql: """\n    INSERT INTO player (name, score) VALUES (?, ?);\n    INSERT INTO player (name, score) VALUES (?, ?);\n    """, arguments: ["Arthur", 750, "Barbara", 1000])\n\n// Swift 5\ntry db.execute(literal: """\n    INSERT INTO player (name, score) VALUES (\\("Arthur"), \\(750));\n    INSERT INTO player (name, score) VALUES (\\("Barbara"), \\(1000));\n    """)\n```\n\nWhen you want to make sure that a single statement is executed, use [Prepared Statements](#prepared-statements).\n\n**After an INSERT statement**, you can get the row ID of the inserted row:\n\n```swift\ntry db.execute(\n    sql: "INSERT INTO player (name, score) VALUES (?, ?)",\n    arguments: ["Arthur", 1000])\nlet playerId = db.lastInsertedRowID\n```\n\nDon\'t miss [Records](#records), that provide classic **persistence methods**:\n\n```swift\nvar player = Player(name: "Arthur", score: 1000)\ntry player.insert(db)\nlet playerId = player.id\n```\n\n\n## Fetch Queries\n\n[Database connections](#database-connections) let you fetch database rows, plain values, and custom models aka "records".\n\n**Rows** are the raw results of SQL queries:\n\n```swift\ntry dbQueue.read { db in\n    if let row = try Row.fetchOne(db, sql: "SELECT * FROM wine WHERE id = ?", arguments: [1]) {\n        let name: String = row["name"]\n        let color: Color = row["color"]\n        print(name, color)\n    }\n}\n```\n\n\n**Values** are the Bool, Int, String, Date, Swift enums, etc. stored in row columns:\n\n```swift\ntry dbQueue.read { db in\n    let urls = try URL.fetchCursor(db, sql: "SELECT url FROM wine")\n    while let url = try urls.next() {\n        print(url)\n    }\n}\n```\n\n\n**Records** are your application objects that can initialize themselves from rows:\n\n```swift\nlet wines = try dbQueue.read { db in\n    try Wine.fetchAll(db, sql: "SELECT * FROM wine")\n}\n```\n\n- [Fetching Methods](#fetching-methods) and [Cursors](#cursors)\n- [Row Queries](#row-queries)\n- [Value Queries](#value-queries)\n- [Records](#records)\n\n\n### Fetching Methods\n\n**Throughout GRDB**, you can always fetch *cursors*, *arrays*, or *single values* of any fetchable type (database [row](#row-queries), simple [value](#value-queries), or custom [record](#records)):\n\n```swift\ntry Row.fetchCursor(...) // A Cursor of Row\ntry Row.fetchAll(...)    // [Row]\ntry Row.fetchOne(...)    // Row?\n```\n\n- `fetchCursor` returns a **[cursor](#cursors)** over fetched values:\n    \n    ```swift\n    let rows = try Row.fetchCursor(db, sql: "SELECT ...") // A Cursor of Row\n    ```\n    \n- `fetchAll` returns an **array**:\n    \n    ```swift\n    let players = try Player.fetchAll(db, sql: "SELECT ...") // [Player]\n    ```\n\n- `fetchOne` returns a **single optional value**, and consumes a single database row (if any).\n    \n    ```swift\n    let count = try Int.fetchOne(db, sql: "SELECT COUNT(*) ...") // Int?\n    ```\n\n\n### Cursors\n\n**Whenever you consume several rows from the database, you can fetch an Array, or a Cursor**.\n\nThe `fetchAll()` method returns a regular Swift array, that you iterate like all other arrays:\n\n```swift\ntry dbQueue.read { db in\n    // [Player]\n    let players = try Player.fetchAll(db, sql: "SELECT ...")\n    for player in players {\n        // use player\n    }\n}\n```\n\nUnlike arrays, cursors returned by `fetchCursor()` load their results step after step:\n\n```swift\ntry dbQueue.read { db in\n    // Cursor of Player\n    let players = try Player.fetchCursor(db, sql: "SELECT ...")\n    while let player = try players.next() {\n        // use player\n    }\n}\n```\n\nBoth arrays and cursors can iterate over database results. How do you choose one or the other? Look at the differences:\n\n- **Cursors can not be used on any thread**: you must consume a cursor on the dispatch queue it was created in. Particularly, don\'t extract a cursor out of a database access method:\n    \n    ```swift\n    // Wrong\n    let cursor = try dbQueue.read { db in\n        try Player.fetchCursor(db, ...)\n    }\n    while let player = try cursor.next() { ... }\n    ```\n    \n    Conversely, arrays may be consumed on any thread:\n    \n    ```swift\n    // OK\n    let array = try dbQueue.read { db in\n        try Player.fetchAll(db, ...)\n    }\n    for player in array { ... }\n    ```\n    \n- **Cursors can be iterated only one time.** Arrays can be iterated many times.\n\n- **Cursors iterate database results in a lazy fashion**, and don\'t consume much memory. Arrays contain copies of database values, and may take a lot of memory when there are many fetched results.\n\n- **Cursors are granted with direct access to SQLite,** unlike arrays that have to take the time to copy database values. If you look after extra performance, you may prefer cursors over arrays.\n\n- **Cursors adopt the [Cursor](http://groue.github.io/GRDB.swift/docs/4.6/Protocols/Cursor.html) protocol, which looks a lot like standard [lazy sequences](https://developer.apple.com/reference/swift/lazysequenceprotocol) of Swift.** As such, cursors come with many convenience methods: `compactMap`, `contains`, `dropFirst`, `dropLast`, `drop(while:)`, `enumerated`, `filter`, `first`, `flatMap`, `forEach`, `joined`, `joined(separator:)`, `max`, `max(by:)`, `min`, `min(by:)`, `map`, `prefix`, `prefix(while:)`, `reduce`, `reduce(into:)`, `suffix`:\n    \n    ```swift\n    // Prints all Github links\n    try URL\n        .fetchCursor(db, sql: "SELECT url FROM link")\n        .filter { url in url.host == "github.com" }\n        .forEach { url in print(url) }\n    \n    // An efficient cursor of coordinates:\n    let locations = try Row.\n        .fetchCursor(db, sql: "SELECT latitude, longitude FROM place")\n        .map { row in\n            CLLocationCoordinate2D(latitude: row[0], longitude: row[1])\n        }\n    \n    // Turn cursors into arrays or sets:\n    let array = try Array(cursor)\n    let set = try Set(cursor)\n    ```\n    \n- **Cursors are not Swift sequences.** That\'s because Swift sequences can\'t handle iteration errors, when reading SQLite results may fail at any time. SQL functions may throw errors. On iOS, [data protection](#data-protection) may block access to the database file in the background. On macOS, your application users may mess with the file system.\n\n- **Cursors require a little care**:\n    \n    - Don\'t modify the results during a cursor iteration:\n        \n        ```swift\n        // Undefined behavior\n        while let player = try players.next() {\n            try db.execute(sql: "DELETE ...")\n        }\n        ```\n    \n    - Don\'t turn a cursor of `Row` into an array. You would not get the distinct rows you expect. To get a array of rows, use `Row.fetchAll(...)`. Generally speaking, make sure you copy a row whenever you extract it from a cursor for later use: `row.copy()`.\n\nIf you don\'t see, or don\'t care about the difference, use arrays. If you care about memory and performance, use cursors when appropriate.\n\n\n### Row Queries\n\n- [Fetching Rows](#fetching-rows)\n- [Column Values](#column-values)\n- [DatabaseValue](#databasevalue)\n- [Rows as Dictionaries](#rows-as-dictionaries)\n\n\n#### Fetching Rows\n\nFetch **cursors** of rows, **arrays**, or **single** rows (see [fetching methods](#fetching-methods)):\n\n```swift\ntry dbQueue.read { db in\n    try Row.fetchCursor(db, sql: "SELECT ...", arguments: ...) // A Cursor of Row\n    try Row.fetchAll(db, sql: "SELECT ...", arguments: ...)    // [Row]\n    try Row.fetchOne(db, sql: "SELECT ...", arguments: ...)    // Row?\n    \n    let rows = try Row.fetchCursor(db, sql: "SELECT * FROM wine")\n    while let row = try rows.next() {\n        let name: String = row["name"]\n        let color: Color = row["color"]\n        print(name, color)\n    }\n}\n\nlet rows = try dbQueue.read { db in\n    try Row.fetchAll(db, sql: "SELECT * FROM player")\n}\n```\n\nArguments are optional arrays or dictionaries that fill the positional `?` and colon-prefixed keys like `:name` in the query:\n\n```swift\nlet rows = try Row.fetchAll(db,\n    sql: "SELECT * FROM player WHERE name = ?",\n    arguments: ["Arthur"])\n\nlet rows = try Row.fetchAll(db,\n    sql: "SELECT * FROM player WHERE name = :name",\n    arguments: ["name": "Arthur"])\n```\n\nSee [Values](#values) for more information on supported arguments types (Bool, Int, String, Date, Swift enums, etc.), and [StatementArguments](http://groue.github.io/GRDB.swift/docs/4.6/Structs/StatementArguments.html) for a detailed documentation of SQLite arguments.\n\nUnlike row arrays that contain copies of the database rows, row cursors are close to the SQLite metal, and require a little care:\n\n> :point_up: **Don\'t turn a cursor of `Row` into an array**. You would not get the distinct rows you expect. To get a array of rows, use `Row.fetchAll(...)`. Generally speaking, make sure you copy a row whenever you extract it from a cursor for later use: `row.copy()`.\n\n\n#### Column Values\n\n**Read column values** by index or column name:\n\n```swift\nlet name: String = row[0]      // 0 is the leftmost column\nlet name: String = row["name"] // Leftmost matching column - lookup is case-insensitive\nlet name: String = row[Column("name")] // Using query interface\'s Column\n```\n\nMake sure to ask for an optional when the value may be NULL:\n\n```swift\nlet name: String? = row["name"]\n```\n\nThe `row[]` subscript returns the type you ask for. See [Values](#values) for more information on supported value types:\n\n```swift\nlet bookCount: Int     = row["bookCount"]\nlet bookCount64: Int64 = row["bookCount"]\nlet hasBooks: Bool     = row["bookCount"] // false when 0\n\nlet string: String     = row["date"]      // "2015-09-11 18:14:15.123"\nlet date: Date         = row["date"]      // Date\nself.date = row["date"] // Depends on the type of the property.\n```\n\nYou can also use the `as` type casting operator:\n\n```swift\nrow[...] as Int\nrow[...] as Int?\n```\n\n> :warning: **Warning**: avoid the `as!` and `as?` operators:\n> \n> ```swift\n> if let int = row[...] as? Int { ... } // BAD - doesn\'t work\n> if let int = row[...] as Int? { ... } // GOOD\n> ```\n\nGenerally speaking, you can extract the type you need, provided it can be converted from the underlying SQLite value:\n\n- **Successful conversions include:**\n    \n    - All numeric SQLite values to all numeric Swift types, and Bool (zero is the only false boolean).\n    - Text SQLite values to Swift String.\n    - Blob SQLite values to Foundation Data.\n    \n    See [Values](#values) for more information on supported types (Bool, Int, String, Date, Swift enums, etc.)\n    \n- **NULL returns nil.**\n    \n    ```swift\n    let row = try Row.fetchOne(db, sql: "SELECT NULL")!\n    row[0] as Int? // nil\n    row[0] as Int  // fatal error: could not convert NULL to Int.\n    ```\n    \n    There is one exception, though: the [DatabaseValue](#databasevalue) type:\n    \n    ```swift\n    row[0] as DatabaseValue // DatabaseValue.null\n    ```\n    \n- **Missing columns return nil.**\n    \n    ```swift\n    let row = try Row.fetchOne(db, sql: "SELECT \'foo\' AS foo")!\n    row["missing"] as String? // nil\n    row["missing"] as String  // fatal error: no such column: missing\n    ```\n    \n    You can explicitly check for a column presence with the `hasColumn` method.\n\n- **Invalid conversions throw a fatal error.**\n    \n    ```swift\n    let row = try Row.fetchOne(db, sql: "SELECT \'Mom\xe2\x80\x99s birthday\'")!\n    row[0] as String // "Mom\xe2\x80\x99s birthday"\n    row[0] as Date?  // fatal error: could not convert "Mom\xe2\x80\x99s birthday" to Date.\n    row[0] as Date   // fatal error: could not convert "Mom\xe2\x80\x99s birthday" to Date.\n    \n    let row = try Row.fetchOne(db, sql: "SELECT 256")!\n    row[0] as Int    // 256\n    row[0] as UInt8? // fatal error: could not convert 256 to UInt8.\n    row[0] as UInt8  // fatal error: could not convert 256 to UInt8.\n    ```\n    \n    Those conversion fatal errors can be avoided with the [DatabaseValue](#databasevalue) type:\n    \n    ```swift\n    let row = try Row.fetchOne(db, sql: "SELECT \'Mom\xe2\x80\x99s birthday\'")!\n    let dbValue: DatabaseValue = row[0]\n    if dbValue.isNull {\n        // Handle NULL\n    } else if let date = Date.fromDatabaseValue(dbValue) {\n        // Handle valid date\n    } else {\n        // Handle invalid date\n    }\n    ```\n    \n    This extra verbosity is the consequence of having to deal with an untrusted database: you may consider fixing the content of your database instead. See [Fatal Errors](#fatal-errors) for more information.\n    \n- **SQLite has a weak type system, and provides [convenience conversions](https://www.sqlite.org/c3ref/column_blob.html) that can turn String to Int, Double to Blob, etc.**\n    \n    GRDB will sometimes let those conversions go through:\n    \n    ```swift\n    let rows = try Row.fetchCursor(db, sql: "SELECT \'20 small cigars\'")\n    while let row = try rows.next() {\n        row[0] as Int   // 20\n    }\n    ```\n    \n    Don\'t freak out: those conversions did not prevent SQLite from becoming the immensely successful database engine you want to use. And GRDB adds safety checks described just above. You can also prevent those convenience conversions altogether by using the [DatabaseValue](#databasevalue) type.\n\n\n#### DatabaseValue\n\n**DatabaseValue is an intermediate type between SQLite and your values, which gives information about the raw value stored in the database.**\n\nYou get DatabaseValue just like other value types:\n\n```swift\nlet dbValue: DatabaseValue = row[0]\nlet dbValue: DatabaseValue? = row["name"] // nil if and only if column does not exist\n\n// Check for NULL:\ndbValue.isNull // Bool\n\n// The stored value:\ndbValue.storage.value // Int64, Double, String, Data, or nil\n\n// All the five storage classes supported by SQLite:\nswitch dbValue.storage {\ncase .null:                 print("NULL")\ncase .int64(let int64):     print("Int64: \\(int64)")\ncase .double(let double):   print("Double: \\(double)")\ncase .string(let string):   print("String: \\(string)")\ncase .blob(let data):       print("Data: \\(data)")\n}\n```\n\nYou can extract regular [values](#values) (Bool, Int, String, Date, Swift enums, etc.) from DatabaseValue with the [DatabaseValueConvertible.fromDatabaseValue()](#custom-value-types) method:\n\n```swift\nlet dbValue: DatabaseValue = row["bookCount"]\nlet bookCount   = Int.fromDatabaseValue(dbValue)   // Int?\nlet bookCount64 = Int64.fromDatabaseValue(dbValue) // Int64?\nlet hasBooks    = Bool.fromDatabaseValue(dbValue)  // Bool?, false when 0\n\nlet dbValue: DatabaseValue = row["date"]\nlet string = String.fromDatabaseValue(dbValue)     // "2015-09-11 18:14:15.123"\nlet date   = Date.fromDatabaseValue(dbValue)       // Date?\n```\n\n`fromDatabaseValue` returns nil for invalid conversions:\n\n```swift\nlet row = try Row.fetchOne(db, sql: "SELECT \'Mom\xe2\x80\x99s birthday\'")!\nlet dbValue: DatabaseValue = row[0]\nlet string = String.fromDatabaseValue(dbValue) // "Mom\xe2\x80\x99s birthday"\nlet int    = Int.fromDatabaseValue(dbValue)    // nil\nlet date   = Date.fromDatabaseValue(dbValue)   // nil\n```\n\n\n#### Rows as Dictionaries\n\nRow adopts the standard [RandomAccessCollection](https://developer.apple.com/documentation/swift/randomaccesscollection) protocol, and can be seen as a dictionary of [DatabaseValue](#databasevalue):\n\n```swift\n// All the (columnName, dbValue) tuples, from left to right:\nfor (columnName, dbValue) in row {\n    ...\n}\n```\n\n**You can build rows from dictionaries** (standard Swift dictionaries and NSDictionary). See [Values](#values) for more information on supported types:\n\n```swift\nlet row: Row = ["name": "foo", "date": nil]\nlet row = Row(["name": "foo", "date": nil])\nlet row = Row(/* [AnyHashable: Any] */) // nil if invalid dictionary\n```\n\nYet rows are not real dictionaries: they may contain duplicate columns:\n\n```swift\nlet row = try Row.fetchOne(db, sql: "SELECT 1 AS foo, 2 AS foo")!\nrow.columnNames    // ["foo", "foo"]\nrow.databaseValues // [1, 2]\nrow["foo"]         // 1 (leftmost matching column)\nfor (columnName, dbValue) in row { ... } // ("foo", 1), ("foo", 2)\n```\n\n**When you build a dictionary from a row**, you have to disambiguate identical columns, and choose how to present database values. For example:\n\n- A `[String: DatabaseValue]` dictionary that keeps leftmost value in case of duplicated column name:\n\n    ```swift\n    let dict = Dictionary(row, uniquingKeysWith: { (left, _) in left })\n    ```\n\n- A `[String: AnyObject]` dictionary which keeps rightmost value in case of duplicated column name. This dictionary is identical to FMResultSet\'s resultDictionary from FMDB. It contains NSNull values for null columns, and can be shared with Objective-C:\n\n    ```swift\n    let dict = Dictionary(\n        row.map { (column, dbValue) in\n            (column, dbValue.storage.value as AnyObject)\n        },\n        uniquingKeysWith: { (_, right) in right })\n    ```\n\n- A `[String: Any]` dictionary that can feed, for example, JSONSerialization:\n    \n    ```swift\n    let dict = Dictionary(\n        row.map { (column, dbValue) in\n            (column, dbValue.storage.value)\n        },\n        uniquingKeysWith: { (left, _) in left })\n    ```\n\nSee the documentation of [`Dictionary.init(_:uniquingKeysWith:)`](https://developer.apple.com/documentation/swift/dictionary/2892961-init) for more information.\n\n\n### Value Queries\n\nInstead of rows, you can directly fetch **[values](#values)**. Like rows, fetch them as **cursors**, **arrays**, or **single** values (see [fetching methods](#fetching-methods)). Values are extracted from the leftmost column of the SQL queries:\n\n```swift\ntry dbQueue.read { db in\n    try Int.fetchCursor(db, sql: "SELECT ...", arguments: ...) // A Cursor of Int\n    try Int.fetchAll(db, sql: "SELECT ...", arguments: ...)    // [Int]\n    try Int.fetchOne(db, sql: "SELECT ...", arguments: ...)    // Int?\n    \n    // When database may contain NULL:\n    try Optional<Int>.fetchCursor(db, sql: "SELECT ...", arguments: ...) // A Cursor of Int?\n    try Optional<Int>.fetchAll(db, sql: "SELECT ...", arguments: ...)    // [Int?]\n}\n\nlet playerCount = try dbQueue.read { db in\n    try Int.fetchOne(db, sql: "SELECT COUNT(*) FROM player")!\n}\n```\n\n`fetchOne` returns an optional value which is nil in two cases: either the SELECT statement yielded no row, or one row with a NULL value.\n\nThere are many supported value types (Bool, Int, String, Date, Swift enums, etc.). See [Values](#values) for more information:\n\n```swift\nlet count = try Int.fetchOne(db, sql: "SELECT COUNT(*) FROM player")! // Int\nlet urls = try URL.fetchAll(db, sql: "SELECT url FROM link")          // [URL]\n```\n\n\n## Values\n\nGRDB ships with built-in support for the following value types:\n\n- **Swift Standard Library**: Bool, Double, Float, all signed and unsigned integer types, String, [Swift enums](#swift-enums).\n    \n- **Foundation**: [Data](#data-and-memory-savings), [Date](#date-and-datecomponents), [DateComponents](#date-and-datecomponents), NSNull, [NSNumber](#nsnumber-and-nsdecimalnumber), NSString, URL, [UUID](#uuid).\n    \n- **CoreGraphics**: CGFloat.\n\n- **[DatabaseValue](#databasevalue)**, the type which gives information about the raw value stored in the database.\n\n- **Full-Text Patterns**: [FTS3Pattern](Documentation/FullTextSearch.md#fts3pattern) and [FTS5Pattern](Documentation/FullTextSearch.md#fts5pattern).\n\n- Generally speaking, all types that adopt the [DatabaseValueConvertible](#custom-value-types) protocol.\n\nValues can be used as [statement arguments](http://groue.github.io/GRDB.swift/docs/4.6/Structs/StatementArguments.html):\n\n```swift\nlet url: URL = ...\nlet verified: Bool = ...\ntry db.execute(\n    sql: "INSERT INTO link (url, verified) VALUES (?, ?)",\n    arguments: [url, verified])\n```\n\nValues can be [extracted from rows](#column-values):\n\n```swift\nlet rows = try Row.fetchCursor(db, sql: "SELECT * FROM link")\nwhile let row = try rows.next() {\n    let url: URL = row["url"]\n    let verified: Bool = row["verified"]\n}\n```\n\nValues can be [directly fetched](#value-queries):\n\n```swift\nlet urls = try URL.fetchAll(db, sql: "SELECT url FROM link")  // [URL]\n```\n\nUse values in [Records](#records):\n\n```swift\nstruct Link: FetchableRecord {\n    var url: URL\n    var isVerified: Bool\n    \n    init(row: Row) {\n        url = row["url"]\n        isVerified = row["verified"]\n    }\n}\n```\n\nUse values in the [query interface](#the-query-interface):\n\n```swift\nlet url: URL = ...\nlet link = try Link.filter(Column("url") == url).fetchOne(db)\n```\n\n\n### Data (and Memory Savings)\n\n**Data** suits the BLOB SQLite columns. It can be stored and fetched from the database just like other [values](#values):\n\n```swift\nlet rows = try Row.fetchCursor(db, sql: "SELECT data, ...")\nwhile let row = try rows.next() {\n    let data: Data = row["data"]\n}\n```\n\nAt each step of the request iteration, the `row[]` subscript creates *two copies* of the database bytes: one fetched by SQLite, and another, stored in the Swift Data value.\n\n**You have the opportunity to save memory** by not copying the data fetched by SQLite:\n\n```swift\nwhile let row = try rows.next() {\n    let data = row.dataNoCopy(named: "data") // Data?\n}\n```\n\nThe non-copied data does not live longer than the iteration step: make sure that you do not use it past this point.\n\n\n### Date and DateComponents\n\n[**Date**](#date) and [**DateComponents**](#datecomponents) can be stored and fetched from the database.\n\nHere is how GRDB supports the various [date formats](https://www.sqlite.org/lang_datefunc.html) supported by SQLite:\n\n| SQLite format                | Date         | DateComponents |\n|:---------------------------- |:------------:|:--------------:|\n| YYYY-MM-DD                   |     Read \xc2\xb9   |   Read/Write   |\n| YYYY-MM-DD HH:MM             |     Read \xc2\xb9   |   Read/Write   |\n| YYYY-MM-DD HH:MM:SS          |     Read \xc2\xb9   |   Read/Write   |\n| YYYY-MM-DD HH:MM:SS.SSS      | Read/Write \xc2\xb9 |   Read/Write   |\n| YYYY-MM-DD**T**HH:MM         |     Read \xc2\xb9   |      Read      |\n| YYYY-MM-DD**T**HH:MM:SS      |     Read \xc2\xb9   |      Read      |\n| YYYY-MM-DD**T**HH:MM:SS.SSS  |     Read \xc2\xb9   |      Read      |\n| HH:MM                        |              |   Read/Write   |\n| HH:MM:SS                     |              |   Read/Write   |\n| HH:MM:SS.SSS                 |              |   Read/Write   |\n| Timestamps since unix epoch  |     Read \xc2\xb2   |                |\n| `now`                        |              |                |\n\n\xc2\xb9 Dates are stored and read in the UTC time zone. Missing components are assumed to be zero.\n\n\xc2\xb2 GRDB 2+ interprets numerical values as timestamps that fuel `Date(timeIntervalSince1970:)`. Previous GRDB versions used to interpret numbers as [julian days](https://en.wikipedia.org/wiki/Julian_day). Julian days are still supported, with the `Date(julianDay:)` initializer.\n\n\n#### Date\n\n**Date** can be stored and fetched from the database just like other [values](#values):\n\n```swift\ntry db.execute(\n    sql: "INSERT INTO player (creationDate, ...) VALUES (?, ...)",\n    arguments: [Date(), ...])\n\nlet row = try Row.fetchOne(db, ...)!\nlet creationDate: Date = row["creationDate"]\n```\n\nDates are stored using the format "YYYY-MM-DD HH:MM:SS.SSS" in the UTC time zone. It is precise to the millisecond.\n\n> :point_up: **Note**: this format was chosen because it is the only format that is:\n> \n> - Comparable (`ORDER BY date` works)\n> - Comparable with the SQLite keyword CURRENT_TIMESTAMP (`WHERE date > CURRENT_TIMESTAMP` works)\n> - Able to feed [SQLite date & time functions](https://www.sqlite.org/lang_datefunc.html)\n> - Precise enough\n\nWhen the default format does not fit your needs, customize date conversions. For example:\n\n```swift\ntry db.execute(\n    sql: "INSERT INTO player (creationDate, ...) VALUES (?, ...)",\n    arguments: [Date().timeIntervalSinceReferenceDate, ...])\n\nlet row = try Row.fetchOne(db, ...)!\nlet creationDate = Date(timeIntervalSinceReferenceDate: row["creationDate"])\n```\n\nSee [Codable Records] for more date customization options.\n\n\n#### DateComponents\n\nDateComponents is indirectly supported, through the **DatabaseDateComponents** helper type.\n\nDatabaseDateComponents reads date components from all [date formats supported by SQLite](https://www.sqlite.org/lang_datefunc.html), and stores them in the format of your choice, from HH:MM to YYYY-MM-DD HH:MM:SS.SSS.\n\nDatabaseDateComponents can be stored and fetched from the database just like other [values](#values):\n\n```swift\nlet components = DateComponents()\ncomponents.year = 1973\ncomponents.month = 9\ncomponents.day = 18\n\n// Store "1973-09-18"\nlet dbComponents = DatabaseDateComponents(components, format: .YMD)\ntry db.execute(\n    sql: "INSERT INTO player (birthDate, ...) VALUES (?, ...)",\n    arguments: [dbComponents, ...])\n\n// Read "1973-09-18"\nlet row = try Row.fetchOne(db, sql: "SELECT birthDate ...")!\nlet dbComponents: DatabaseDateComponents = row["birthDate"]\ndbComponents.format         // .YMD (the actual format found in the database)\ndbComponents.dateComponents // DateComponents\n```\n\n\n### NSNumber and NSDecimalNumber\n\n**NSNumber** can be stored and fetched from the database just like other [values](#values). Floating point NSNumbers are stored as Double. Integer and boolean, as Int64. Integers that don\'t fit Int64 won\'t be stored: you\'ll get a fatal error instead. Be cautious when an NSNumber contains an UInt64, for example.\n\nNSDecimalNumber deserves a longer discussion:\n\n**SQLite has no support for decimal numbers.** Given the table below, SQLite will actually store integers or doubles:\n\n```sql\nCREATE TABLE transfer (\n    amount DECIMAL(10,5) -- will store integer or double, actually\n)\n```\n\nThis means that computations will not be exact:\n\n```swift\ntry db.execute(sql: "INSERT INTO transfer (amount) VALUES (0.1)")\ntry db.execute(sql: "INSERT INTO transfer (amount) VALUES (0.2)")\nlet sum = try NSDecimalNumber.fetchOne(db, sql: "SELECT SUM(amount) FROM transfer")!\n\n// Yikes! 0.3000000000000000512\nprint(sum)\n```\n\nDon\'t blame SQLite or GRDB, and instead store your decimal numbers differently.\n\nA classic technique is to store *integers* instead, since SQLite performs exact computations of integers. For example, don\'t store Euros, but store cents instead:\n\n```swift\n// Write\nlet amount = NSDecimalNumber(string: "0.10")\nlet integerAmount = amount.multiplying(byPowerOf10: 2).int64Value\ntry db.execute(sql: "INSERT INTO transfer (amount) VALUES (?)", arguments: [integerAmount])\n\n// Read\nlet integerAmount = try Int64.fetchOne(db, sql: "SELECT SUM(amount) FROM transfer")!\nlet amount = NSDecimalNumber(value: integerAmount).multiplying(byPowerOf10: -2) // 0.10\n```\n\n\n### UUID\n\n**UUID** can be stored and fetched from the database just like other [values](#values).\n\nGRDB stores uuids as 16-bytes data blobs, and decodes them from both 16-bytes data blobs and strings such as "E621E1F8-C36C-495A-93FC-0C247A3E6E5F".\n\n\n### Swift Enums\n\n**Swift enums** and generally all types that adopt the [RawRepresentable](https://developer.apple.com/library/tvos/documentation/Swift/Reference/Swift_RawRepresentable_Protocol/index.html) protocol can be stored and fetched from the database just like their raw [values](#values):\n\n```swift\nenum Color : Int {\n    case red, white, rose\n}\n\nenum Grape : String {\n    case chardonnay, merlot, riesling\n}\n\n// Declare empty DatabaseValueConvertible adoption\nextension Color : DatabaseValueConvertible { }\nextension Grape : DatabaseValueConvertible { }\n\n// Store\ntry db.execute(\n    sql: "INSERT INTO wine (grape, color) VALUES (?, ?)",\n    arguments: [Grape.merlot, Color.red])\n\n// Read\nlet rows = try Row.fetchCursor(db, sql: "SELECT * FROM wine")\nwhile let row = try rows.next() {\n    let grape: Grape = row["grape"]\n    let color: Color = row["color"]\n}\n```\n\n**When a database value does not match any enum case**, you get a fatal error. This fatal error can be avoided with the [DatabaseValue](#databasevalue) type:\n\n```swift\nlet row = try Row.fetchOne(db, sql: "SELECT \'syrah\'")!\n\nrow[0] as String  // "syrah"\nrow[0] as Grape?  // fatal error: could not convert "syrah" to Grape.\nrow[0] as Grape   // fatal error: could not convert "syrah" to Grape.\n\nlet dbValue: DatabaseValue = row[0]\nif dbValue.isNull {\n    // Handle NULL\n} else if let grape = Grape.fromDatabaseValue(dbValue) {\n    // Handle valid grape\n} else {\n    // Handle unknown grape\n}\n```\n\n\n### Custom Value Types\n\nConversion to and from the database is based on the `DatabaseValueConvertible` protocol:\n\n```swift\nprotocol DatabaseValueConvertible {\n    /// Returns a value that can be stored in the database.\n    var databaseValue: DatabaseValue { get }\n    \n    /// Returns a value initialized from dbValue, if possible.\n    static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?\n}\n```\n\nAll types that adopt this protocol can be used like all other [values](#values) (Bool, Int, String, Date, Swift enums, etc.)\n\nThe `databaseValue` property returns [DatabaseValue](#databasevalue), a type that wraps the five values supported by SQLite: NULL, Int64, Double, String and Data. Since DatabaseValue has no public initializer, use `DatabaseValue.null`, or another type that already adopts the protocol: `1.databaseValue`, `"foo".databaseValue`, etc. Conversion to DatabaseValue *must not* fail.\n\nThe `fromDatabaseValue()` factory method returns an instance of your custom type if the database value contains a suitable value. If the database value does not contain a suitable value, such as "foo" for Date, `fromDatabaseValue` *must* return nil (GRDB will interpret this nil result as a conversion error, and react accordingly).\n\n\n## Transactions and Savepoints\n\n- [Transactions and Safety](#transactions-and-safety)\n- [Explicit Transactions](#explicit-transactions)\n- [Savepoints](#savepoints)\n- [Transaction Kinds](#transaction-kinds)\n\n\n### Transactions and Safety\n\n**A transaction** is a fundamental tool of SQLite that guarantees [data consistency](https://www.sqlite.org/transactional.html) as well as [proper isolation](https://sqlite.org/isolation.html) between application threads and database connections.\n\nGRDB generally opens transactions for you, as a way to enforce its [concurrency guarantees](#concurrency), and provide maximal security for both your application data and application logic:\n\n```swift\n// BEGIN TRANSACTION\n// INSERT INTO credit ...\n// INSERT INTO debit ...\n// COMMIT\ntry dbQueue.write { db in\n    try Credit(destinationAccount, amount).insert(db)\n    try Debit(sourceAccount, amount).insert(db)\n}\n\n// BEGIN TRANSACTION\n// INSERT INTO credit ...\n// INSERT INTO debit ...\n// COMMIT\ntry dbPool.write { db in\n    try Credit(destinationAccount, amount).insert(db)\n    try Debit(sourceAccount, amount).insert(db)\n}\n```\n\nYet you may need to exactly control when transactions take place:\n\n\n### Explicit Transactions\n\n`DatabaseQueue.inDatabase()` and `DatabasePool.writeWithoutTransaction()` execute your database statements outside of any transaction:\n\n```swift\n// INSERT INTO credit ...\n// INSERT INTO debit ...\ntry dbQueue.inDatabase { db in\n    try Credit(destinationAccount, amount).insert(db)\n    try Debit(sourceAccount, amount).insert(db)\n}\n\n// INSERT INTO credit ...\n// INSERT INTO debit ...\ntry dbPool.writeWithoutTransaction { db in\n    try Credit(destinationAccount, amount).insert(db)\n    try Debit(sourceAccount, amount).insert(db)\n}\n```\n\n**Writing outside of any transaction is dangerous,** for two reasons:\n\n- In our credit/debit example, you may successfully insert a credit, but fail inserting the debit, and end up with unbalanced accounts (oops).\n\n    ```swift\n    // UNSAFE DATABASE INTEGRITY\n    try dbQueue.inDatabase { db in // or dbPool.writeWithoutTransaction\n        try Credit(destinationAccount, amount).insert(db) // may succeed\n        try Debit(sourceAccount, amount).insert(db)      // may fail\n    }\n    ```\n    \n    Transactions avoid this kind of bug.\n    \n- [Database pool](#database-pools) concurrent reads can see an inconsistent state of the database:\n    \n    ```swift\n    // UNSAFE CONCURRENCY\n    try dbPool.writeWithoutTransaction { db in\n        try Credit(destinationAccount, amount).insert(db)\n        // <- Concurrent dbPool.read sees a partial db update here\n        try Debit(sourceAccount, amount).insert(db)\n    }\n    ```\n    \n    Transactions avoid this kind of bug, too.\n\nTo open explicit transactions, use one of the `Database.inTransaction`, `DatabaseQueue.inTransaction`, or `DatabasePool.writeInTransaction` methods:\n\n```swift\n// BEGIN TRANSACTION\n// INSERT INTO credit ...\n// INSERT INTO debit ...\n// COMMIT\ntry dbQueue.inDatabase { db in  // or dbPool.writeWithoutTransaction\n    try db.inTransaction {\n        try Credit(destinationAccount, amount).insert(db)\n        try Debit(sourceAccount, amount).insert(db)\n        return .commit\n    }\n}\n\n// BEGIN TRANSACTION\n// INSERT INTO credit ...\n// INSERT INTO debit ...\n// COMMIT\ntry dbQueue.inTransaction { db in  // or dbPool.writeInTransaction\n    try Credit(destinationAccount, amount).insert(db)\n    try Debit(sourceAccount, amount).insert(db)\n    return .commit\n}\n```\n\nIf an error is thrown from the transaction block, the transaction is rollbacked and the error is rethrown by the `inTransaction` method. If you return `.rollback` instead of `.commit`, the transaction is also rollbacked, but no error is thrown.\n\nYou can also perform manual transaction management:\n\n```swift\ntry dbQueue.inDatabase { db in  // or dbPool.writeWithoutTransaction\n    try db.beginTransaction()\n    ...\n    try db.commit()\n    \n    try db.execute(sql: "BEGIN TRANSACTION")\n    ...\n    try db.execute(sql: "ROLLBACK")\n}\n```\n\nTransactions can\'t be left opened unless you set the [allowsUnsafeTransactions](http://groue.github.io/GRDB.swift/docs/4.6/Structs/Configuration.html) configuration flag:\n\n```swift\n// fatal error: A transaction has been left opened at the end of a database access\ntry dbQueue.inDatabase { db in\n    try db.execute(sql: "BEGIN TRANSACTION")\n    // <- no commit or rollback\n}\n```\n\nYou can ask if a transaction is currently opened:\n\n```swift\nfunc myCriticalMethod(_ db: Database) throws {\n    precondition(db.isInsideTransaction, "This method requires a transaction")\n    try ...\n}\n```\n\nYet, you have a better option than checking for transactions: critical database sections should use savepoints, described below:\n\n```swift\nfunc myCriticalMethod(_ db: Database) throws {\n    try db.inSavepoint {\n        // Here the database is guaranteed to be inside a transaction.\n        try ...\n    }\n}\n```\n\n\n### Savepoints\n\n**Statements grouped in a savepoint can be rollbacked without invalidating a whole transaction:**\n\n```swift\ntry dbQueue.write { db in\n    // Makes sure both inserts succeed, or none:\n    try db.inSavepoint {\n        try Credit(destinationAccount, amount).insert(db)\n        try Debit(sourceAccount, amount).insert(db)\n        return .commit\n    }\n    \n    // Other savepoints, etc...\n}\n```\n\nIf an error is thrown from the savepoint block, the savepoint is rollbacked and the error is rethrown by the `inSavepoint` method. If you return `.rollback` instead of `.commit`, the savepoint is also rollbacked, but no error is thrown.\n\n**Unlike transactions, savepoints can be nested.** They implicitly open a transaction if no one was opened when the savepoint begins. As such, they behave just like nested transactions. Yet the database changes are only written to disk when the outermost transaction is committed:\n\n```swift\ntry dbQueue.inDatabase { db in\n    try db.inSavepoint {\n        ...\n        try db.inSavepoint {\n            ...\n            return .commit\n        }\n        ...\n        return .commit  // writes changes to disk\n    }\n}\n```\n\nSQLite savepoints are more than nested transactions, though. For advanced uses, use [SQLite savepoint documentation](https://www.sqlite.org/lang_savepoint.html).\n\n\n### Transaction Kinds\n\nSQLite supports [three kinds of transactions](https://www.sqlite.org/lang_transaction.html): deferred (the default), immediate, and exclusive.\n\nThe transaction kind can be changed in the database configuration, or for each transaction:\n\n```swift\n// 1) Default configuration:\nlet dbQueue = try DatabaseQueue(path: "...")\n\n// BEGIN DEFERED TRANSACTION ...\ndbQueue.write { db in ... }\n\n// BEGIN EXCLUSIVE TRANSACTION ...\ndbQueue.inTransaction(.exclusive) { db in ... }\n\n// 2) Customized default transaction kind:\nvar config = Configuration()\nconfig.defaultTransactionKind = .immediate\nlet dbQueue = try DatabaseQueue(path: "...", configuration: config)\n\n// BEGIN IMMEDIATE TRANSACTION ...\ndbQueue.write { db in ... }\n\n// BEGIN EXCLUSIVE TRANSACTION ...\ndbQueue.inTransaction(.exclusive) { db in ... }\n```\n\n\n## Prepared Statements\n\n**Prepared Statements** let you prepare an SQL query and execute it later, several times if you need, with different arguments.\n\nThere are two kinds of prepared statements: **select statements**, and **update statements**:\n\n```swift\ntry dbQueue.write { db in\n    let updateSQL = "INSERT INTO player (name, score) VALUES (:name, :score)"\n    let updateStatement = try db.makeUpdateStatement(sql: updateSQL)\n    \n    let selectSQL = "SELECT * FROM player WHERE name = ?"\n    let selectStatement = try db.makeSelectStatement(sql: selectSQL)\n}\n```\n\nThe `?` and colon-prefixed keys like `:name` in the SQL query are the statement arguments. You set them with arrays or dictionaries (arguments are actually of type [StatementArguments](http://groue.github.io/GRDB.swift/docs/4.6/Structs/StatementArguments.html), which happens to adopt the ExpressibleByArrayLiteral and ExpressibleByDictionaryLiteral protocols).\n\n```swift\nupdateStatement.arguments = ["name": "Arthur", "score": 1000]\nselectStatement.arguments = ["Arthur"]\n```\n\nAfter arguments are set, you can execute the prepared statement:\n\n```swift\ntry updateStatement.execute()\n```\n\nSelect statements can be used wherever a raw SQL query string would fit (see [fetch queries](#fetch-queries)):\n\n```swift\nlet rows = try Row.fetchCursor(selectStatement)    // A Cursor of Row\nlet players = try Player.fetchAll(selectStatement) // [Player]\nlet player = try Player.fetchOne(selectStatement)  // Player?\n```\n\nYou can set the arguments at the moment of the statement execution:\n\n```swift\ntry updateStatement.execute(arguments: ["name": "Arthur", "score": 1000])\nlet player = try Player.fetchOne(selectStatement, arguments: ["Arthur"])\n```\n\n> :point_up: **Note**: it is a programmer error to reuse a prepared statement that has failed: GRDB may crash if you do so.\n\nSee [row queries](#row-queries), [value queries](#value-queries), and [Records](#records) for more information.\n\n\n### Prepared Statements Cache\n\nWhen the same query will be used several times in the lifetime of your application, you may feel a natural desire to cache prepared statements.\n\n**Don\'t cache statements yourself.**\n\n> :point_up: **Note**: This is because you don\'t have the necessary tools. Statements are tied to specific SQLite connections and dispatch queues which you don\'t manage yourself, especially when you use [database pools](#database-pools). A change in the database schema [may, or may not](https://www.sqlite.org/compile.html#max_schema_retry) invalidate a statement. On systems earlier than OSX 10.10 that don\'t have the [sqlite3_close_v2 function](https://www.sqlite.org/c3ref/close.html), SQLite connections won\'t close properly if statements have been kept alive.\n\nInstead, use the `cachedUpdateStatement` and `cachedSelectStatement` methods. GRDB does all the hard caching and [memory management](#memory-management) stuff for you:\n\n```swift\nlet updateStatement = try db.cachedUpdateStatement(sql: sql)\nlet selectStatement = try db.cachedSelectStatement(sql: sql)\n```\n\nShould a cached prepared statement throw an error, don\'t reuse it (it is a programmer error). Instead, reload it from the cache.\n\n\n## Custom SQL Functions and Aggregates\n\n**SQLite lets you define SQL functions and aggregates.**\n\nA custom SQL function or aggregate extends SQLite:\n\n```sql\nSELECT reverse(name) FROM player;   -- custom function\nSELECT maxLength(name) FROM player; -- custom aggregate\n```\n\n- [Custom SQL Functions](#custom-sql-functions)\n- [Custom Aggregates](#custom-aggregates)\n\n\n### Custom SQL Functions\n\n```swift\nlet reverse = DatabaseFunction("reverse", argumentCount: 1, pure: true) { (values: [DatabaseValue]) in\n    // Extract string value, if any...\n    guard let string = String.fromDatabaseValue(values[0]) else {\n        return nil\n    }\n    // ... and return reversed string:\n    return String(string.reversed())\n}\ndbQueue.add(function: reverse)   // Or dbPool.add(function: ...)\n\ntry dbQueue.read { db in\n    // "oof"\n    try String.fetchOne(db, sql: "SELECT reverse(\'foo\')")!\n}\n```\n\nThe *function* argument takes an array of [DatabaseValue](#databasevalue), and returns any valid [value](#values) (Bool, Int, String, Date, Swift enums, etc.) The number of database values is guaranteed to be *argumentCount*.\n\nSQLite has the opportunity to perform additional optimizations when functions are "pure", which means that their result only depends on their arguments. So make sure to set the *pure* argument to true when possible.\n\n\n**Functions can take a variable number of arguments:**\n\nWhen you don\'t provide any explicit *argumentCount*, the function can take any number of arguments:\n\n```swift\nlet averageOf = DatabaseFunction("averageOf", pure: true) { (values: [DatabaseValue]) in\n    let doubles = values.compactMap { Double.fromDatabaseValue($0) }\n    return doubles.reduce(0, +) / Double(doubles.count)\n}\ndbQueue.add(function: averageOf)\n\ntry dbQueue.read { db in\n    // 2.0\n    try Double.fetchOne(db, sql: "SELECT averageOf(1, 2, 3)")!\n}\n```\n\n\n**Functions can throw:**\n\n```swift\nlet sqrt = DatabaseFunction("sqrt", argumentCount: 1, pure: true) { (values: [DatabaseValue]) in\n    guard let double = Double.fromDatabaseValue(values[0]) else {\n        return nil\n    }\n    guard double >= 0 else {\n        throw DatabaseError(message: "invalid negative number")\n    }\n    return sqrt(double)\n}\ndbQueue.add(function: sqrt)\n\n// SQLite error 1 with statement `SELECT sqrt(-1)`: invalid negative number\ntry dbQueue.read { db in\n    try Double.fetchOne(db, sql: "SELECT sqrt(-1)")!\n}\n```\n\n\n**Use custom functions in the [query interface](#the-query-interface):**\n\n```swift\n// SELECT reverseString("name") FROM player\nPlayer.select(reverseString.apply(nameColumn))\n```\n\n\n**GRDB ships with built-in SQL functions that perform unicode-aware string transformations.** See [Unicode](#unicode).\n\n\n### Custom Aggregates\n\nBefore registering a custom aggregate, you need to define a type that adopts the `DatabaseAggregate` protocol:\n\n```swift\nprotocol DatabaseAggregate {\n    // Initializes an aggregate\n    init()\n    \n    // Called at each step of the aggregation\n    mutating func step(_ dbValues: [DatabaseValue]) throws\n    \n    // Returns the final result\n    func finalize() throws -> DatabaseValueConvertible?\n}\n```\n\nFor example:\n\n```swift\nstruct MaxLength : DatabaseAggregate {\n    var maxLength: Int = 0\n    \n    mutating func step(_ dbValues: [DatabaseValue]) {\n        // At each step, extract string value, if any...\n        guard let string = String.fromDatabaseValue(dbValues[0]) else {\n            return\n        }\n        // ... and update the result\n        let length = string.count\n        if length > maxLength {\n            maxLength = length\n        }\n    }\n    \n    func finalize() -> DatabaseValueConvertible? {\n        return maxLength\n    }\n}\n\nlet maxLength = DatabaseFunction(\n    "maxLength",\n    argumentCount: 1,\n    pure: true,\n    aggregate: MaxLength.self)\n\ndbQueue.add(function: maxLength)   // Or dbPool.add(function: ...)\n\ntry dbQueue.read { db in\n    // Some Int\n    try Int.fetchOne(db, sql: "SELECT maxLength(name) FROM player")!\n}\n```\n\nThe `step` method of the aggregate takes an array of [DatabaseValue](#databasevalue). This array contains as many values as the *argumentCount* parameter (or any number of values, when *argumentCount* is omitted).\n\nThe `finalize` method of the aggregate returns the final aggregated [value](#values) (Bool, Int, String, Date, Swift enums, etc.).\n\nSQLite has the opportunity to perform additional optimizations when aggregates are "pure", which means that their result only depends on their inputs. So make sure to set the *pure* argument to true when possible.\n\n\n**Use custom aggregates in the [query interface](#the-query-interface):**\n\n```swift\n// SELECT maxLength("name") FROM player\nlet request = Player.select(maxLength.apply(nameColumn))\ntry Int.fetchOne(db, request) // Int?\n```\n\n\n## Database Schema Introspection\n\nGRDB comes with a set of schema introspection methods:\n\n```swift\ntry dbQueue.read { db in\n    // Bool, true if the table exists\n    try db.tableExists("player")\n    \n    // [ColumnInfo], the columns in the table\n    try db.columns(in: "player")\n    \n    // PrimaryKeyInfo\n    try db.primaryKey("player")\n    \n    // [ForeignKeyInfo], the foreign keys defined on the table\n    try db.foreignKeys(on: "player")\n    \n    // [IndexInfo], the indexes defined on the table\n    try db.indexes(on: "player")\n    \n    // Bool, true if column(s) is a unique key (primary key or unique index)\n    try db.table("player", hasUniqueKey: ["email"])\n}\n\n// Bool, true if argument is the name of an internal SQLite table\nDatabase.isSQLiteInternalTable(...)\n\n// Bool, true if argument is the name of an internal GRDB table\nDatabase.isGRDBInternalTable(...)\n```\n\n\n## Row Adapters\n\n**Row adapters let you present database rows in the way expected by the row consumers.**\n\nThey basically help two incompatible row interfaces to work together. For example, a row consumer expects a column named "consumed", but the produced row has a column named "produced".\n\nIn this case, the `ColumnMapping` row adapter comes in handy:\n\n```swift\n// Fetch a \'produced\' column, and consume a \'consumed\' column:\nlet adapter = ColumnMapping(["consumed": "produced"])\nlet row = try Row.fetchOne(db, sql: "SELECT \'Hello\' AS produced", adapter: adapter)!\nrow["consumed"] // "Hello"\nrow["produced"] // nil\n```\n\nRow adapters are values that adopt the [RowAdapter](http://groue.github.io/GRDB.swift/docs/4.6/Protocols/RowAdapter.html) protocol. You can implement your own custom adapters ([**:fire: EXPERIMENTAL**](#what-are-experimental-features)), or use one of the four built-in adapters, described below.\n\nTo see how row adapters can be used, see [Joined Queries Support](#joined-queries-support).\n\n\n### ColumnMapping\n\nColumnMapping renames columns. Build one with a dictionary whose keys are adapted column names, and values the column names in the raw row:\n\n```swift\n// [newName:"Hello"]\nlet adapter = ColumnMapping(["newName": "oldName"])\nlet row = try Row.fetchOne(db, sql: "SELECT \'Hello\' AS oldName", adapter: adapter)!\n```\n\n### SuffixRowAdapter\n\n`SuffixRowAdapter` hides the first columns in a row:\n\n```swift\n// [b:1 c:2]\nlet adapter = SuffixRowAdapter(fromIndex: 1)\nlet row = try Row.fetchOne(db, sql: "SELECT 0 AS a, 1 AS b, 2 AS c", adapter: adapter)!\n```\n\n### RangeRowAdapter\n\n`RangeRowAdapter` only exposes a range of columns.\n\n```swift\n// [b:1]\nlet adapter = RangeRowAdapter(1..<2)\nlet row = try Row.fetchOne(db, sql: "SELECT 0 AS a, 1 AS b, 2 AS c", adapter: adapter)!\n```\n\n### EmptyRowAdapter\n\n`EmptyRowAdapter` hides all columns.\n\n```swift\nlet adapter = EmptyRowAdapter()\nlet row = try Row.fetchOne(db, sql: "SELECT 0 AS a, 1 AS b, 2 AS c", adapter: adapter)!\nrow.isEmpty // true\n```\n\nThis limit adapter may turn out useful in some narrow use cases. You\'ll be happy to find it when you need it.\n\n\n### ScopeAdapter\n\n`ScopeAdapter` defines *row scopes*:\n\n```swift\nlet adapter = ScopeAdapter([\n    "left": RangeRowAdapter(0..<2),\n    "right": RangeRowAdapter(2..<4)])\nlet row = try Row.fetchOne(db, sql: "SELECT 0 AS a, 1 AS b, 2 AS c, 3 AS d", adapter: adapter)!\n```\n\nScopeAdapter does not change the columns and values of the fetched row. Instead, it defines *scopes*, which you access through the `Row.scopes` property:\n\n```swift\nrow                   // [a:0 b:1 c:2 d:3]\nrow.scopes["left"]    // [a:0 b:1]\nrow.scopes["right"]   // [c:2 d:3]\nrow.scopes["missing"] // nil\n```\n\nScopes can be nested:\n\n```swift\nlet adapter = ScopeAdapter([\n    "left": ScopeAdapter([\n        "left": RangeRowAdapter(0..<1),\n        "right": RangeRowAdapter(1..<2)]),\n    "right": ScopeAdapter([\n        "left": RangeRowAdapter(2..<3),\n        "right": RangeRowAdapter(3..<4)])\n    ])\nlet row = try Row.fetchOne(db, sql: "SELECT 0 AS a, 1 AS b, 2 AS c, 3 AS d", adapter: adapter)!\n\nlet leftRow = row.scopes["left"]!\nleftRow.scopes["left"]  // [a:0]\nleftRow.scopes["right"] // [b:1]\n\nlet rightRow = row.scopes["right"]!\nrightRow.scopes["left"]  // [c:2]\nrightRow.scopes["right"] // [d:3]\n```\n\nAny adapter can be extended with scopes:\n\n```swift\nlet baseAdapter = RangeRowAdapter(0..<2)\nlet adapter = ScopeAdapter(base: baseAdapter, scopes: [\n    "remainder": SuffixRowAdapter(fromIndex: 2)])\nlet row = try Row.fetchOne(db, sql: "SELECT 0 AS a, 1 AS b, 2 AS c, 3 AS d", adapter: adapter)!\n\nrow // [a:0 b:1]\nrow.scopes["remainder"] // [c:2 d:3]\n```\n\n\n## Raw SQLite Pointers\n\n**If not all SQLite APIs are exposed in GRDB, you can still use the [SQLite C Interface](https://www.sqlite.org/c3ref/intro.html) and call [SQLite C functions](https://www.sqlite.org/c3ref/funclist.html).**\n\nThose functions are embedded right into the [GRDBCustom](Documentation/CustomSQLiteBuilds.md) module. Otherwise, you\'ll need to import `SQLite3`, `SQLCipher`, or `CSQLite`, depending on the GRDB flavor you are using:\n\n```swift\n// Swift Package Manager\nimport CSQLite\n\n// SQLCipher\nimport SQLCipher\n\n// System SQLite\nimport SQLite3\n\nlet sqliteVersion = String(cString: sqlite3_libversion())\n```\n\nRaw pointers to database connections and statements are available through the `Database.sqliteConnection` and `Statement.sqliteStatement` properties:\n\n```swift\ntry dbQueue.read { db in\n    // The raw pointer to a database connection:\n    let sqliteConnection = db.sqliteConnection\n\n    // The raw pointer to a statement:\n    let statement = try db.makeSelectStatement(sql: "SELECT ...")\n    let sqliteStatement = statement.sqliteStatement\n}\n```\n\n> :point_up: **Notes**\n>\n> - Those pointers are owned by GRDB: don\'t close connections or finalize statements created by GRDB.\n> - GRDB opens SQLite connections in the "[multi-thread mode](https://www.sqlite.org/threadsafe.html)", which (oddly) means that **they are not thread-safe**. Make sure you touch raw databases and statements inside their dedicated dispatch queues.\n> - Use the raw SQLite C Interface at your own risk. GRDB won\'t prevent you from shooting yourself in the foot.\n\n\nRecords\n=======\n\n**On top of the [SQLite API](#sqlite-api), GRDB provides protocols and a class** that help manipulating database rows as regular objects named "records":\n\n```swift\ntry dbQueue.write { db in\n    if var place = try Place.fetchOne(db, key: 1) {\n        place.isFavorite = true\n        try place.update(db)\n    }\n}\n```\n\nOf course, you need to open a [database connection](#database-connections), and [create database tables](#database-schema) first.\n\nTo define your custom records, you subclass the ready-made `Record` class, or you extend your structs and classes with protocols that come with focused sets of features: fetching methods, persistence methods, record comparison...\n\nExtending structs with record protocols is more "swifty". Subclassing the Record class is more "classic". You can choose either way. See some [examples of record definitions](#examples-of-record-definitions), and the [list of record methods](#list-of-record-methods) for an overview.\n\n> :point_up: **Note**: if you are familiar with Core Data\'s NSManagedObject or Realm\'s Object, you may experience a cultural shock: GRDB records are not uniqued, do not auto-update, and do not lazy-load. This is both a purpose, and a consequence of protocol-oriented programming. You should read [How to build an iOS application with SQLite and GRDB.swift](https://medium.com/@gwendal.roue/how-to-build-an-ios-application-with-sqlite-and-grdb-swift-d023a06c29b3) for a general introduction.\n>\n> :bulb: **Tip**: after you have read this chapter, check the [Good Practices for Designing Record Types](Documentation/GoodPracticesForDesigningRecordTypes.md) Guide.\n>\n> :bulb: **Tip**: see the [Demo Application] for a sample app that uses records.\n\n**Overview**\n\n- [Inserting Records](#inserting-records)\n- [Fetching Records](#fetching-records)\n- [Updating Records](#updating-records)\n- [Deleting Records](#deleting-records)\n- [Counting Records](#counting-records)\n\n**Protocols and the Record Class**\n\n- [Record Protocols Overview](#record-protocols-overview)\n- [FetchableRecord Protocol](#fetchablerecord-protocol)\n- [TableRecord Protocol](#tablerecord-protocol)\n- [PersistableRecord Protocol](#persistablerecord-protocol)\n    - [Persistence Methods](#persistence-methods)\n    - [Customizing the Persistence Methods]\n- [Codable Records]\n- [Record Class](#record-class)\n- [Record Comparison]\n- [Record Customization Options]\n\n**Records in a Glance**\n\n- [Examples of Record Definitions](#examples-of-record-definitions)\n- [List of Record Methods](#list-of-record-methods)\n\n\n### Inserting Records\n\nTo insert a record in the database, call the `insert` method:\n\n```swift\nlet player = Player(name: "Arthur", email: "arthur@example.com")\ntry player.insert(db)\n```\n\n:point_right: `insert` is available for subclasses of the [Record](#record-class) class, and types that adopt the [PersistableRecord] protocol.\n\n\n### Fetching Records\n\nTo fetch records from the database, call a [fetching method](#fetching-methods):\n\n```swift\nlet arthur = try Player.fetchOne(db,            // Player?\n    sql: "SELECT * FROM players WHERE name = ?",\n    arguments: ["Arthur"])\n\nlet bestPlayers = try Player                    // [Player]\n    .order(Column("score").desc)\n    .limit(10)\n    .fetchAll(db)\n    \nlet spain = try Country.fetchOne(db, key: "ES") // Country?\n```\n\n:point_right: Fetching from raw SQL is available for subclasses of the [Record](#record-class) class, and types that adopt the [FetchableRecord] protocol.\n\n:point_right: Fetching without SQL, using the [query interface](#the-query-interface), is available for subclasses of the [Record](#record-class) class, and types that adopt both [FetchableRecord] and [TableRecord] protocol.\n\n\n### Updating Records\n\nTo update a record in the database, call the `update` method:\n\n```swift\nif let player = try Player.fetchOne(db, key: 1) \n    player.score = 1000\n    try player.update(db)\n}\n```\n\nIt is possible to [avoid useless updates](#record-comparison):\n\n```swift\nif var player = try Player.fetchOne(db, key: 1) {\n    // does not hit the database if score has not changed\n    try player.updateChanges(db) {\n        $0.score = 1000\n    }\n}\n```\n\nFor batch updates, execute an [SQL query](#executing-updates), or see the [query interface](#the-query-interface):\n\n```swift\ntry db.execute(sql: "UPDATE player SET score = score + 1 WHERE team = \'red\'")\ntry Player\n    .filter(Column("team") == "red")\n    .updateAll(db, scoreColumn += 1)\n```\n\n:point_right: update methods are available for subclasses of the [Record](#record-class) class, and types that adopt the [PersistableRecord] protocol.\n\n\n### Deleting Records\n\nTo delete a record in the database, call the `delete` method:\n\n```swift\nif let player = try Player.fetchOne(db, key: 1) {\n    try player.delete(db)\n}\n```\n\nYou can also delete by primary key, or any unique index:\n\n```swift\ntry Player.deleteOne(db, key: 1)\ntry Player.deleteOne(db, key: ["email": "arthur@example.com"])\ntry Country.deleteAll(db, keys: ["FR", "US"])\n```\n\nFor batch deletes, execute an [SQL query](#executing-updates), or see the [query interface](#the-query-interface):\n\n```swift\ntry db.execute(sql: "DELETE player WHERE email IS NULL")\ntry Player\n    .filter(Column("email") == nil)\n    .deleteAll(db)\n```\n\n:point_right: delete methods are available for subclasses of the [Record](#record-class) class, and types that adopt the [PersistableRecord] protocol.\n\n\n### Counting Records\n\nTo count records, call the `fetchCount` method:\n\n```swift\nlet playerCount: Int = try Player.fetchCount(db)\n\nlet playerWithEmailCount: Int = try Player\n    .filter(Column("email") == nil)\n    .fetchCount(db)\n```\n\n:point_right: `fetchCount` is available for subclasses of the [Record](#record-class) class, and types that adopt the [TableRecord] protocol.\n\n\nDetails follow:\n\n- [Record Protocols Overview](#record-protocols-overview)\n- [FetchableRecord Protocol](#fetchablerecord-protocol)\n- [TableRecord Protocol](#tablerecord-protocol)\n- [PersistableRecord Protocol](#persistablerecord-protocol)\n- [Codable Records]\n- [Record Class](#record-class)\n- [Record Comparison]\n- [Record Customization Options]\n- [Examples of Record Definitions](#examples-of-record-definitions)\n- [List of Record Methods](#list-of-record-methods)\n\n\n## Record Protocols Overview\n\n**GRDB ships with three record protocols**. Your own types will adopt one or several of them, according to the abilities you want to extend your types with.\n\n- [FetchableRecord] is able to **decode database rows**.\n    \n    It is always possible to decode rows without this protocol:\n    \n    ```swift\n    struct Place { ... }\n    try dbQueue.read { db in\n        let rows = try Row.fetchAll(db, sql: "SELECT * FROM place")\n        let places: [Place] = rows.map { row in\n            return Place(\n                id: row["id"],\n                title: row["title"],\n                coordinate: CLLocationCoordinate2D(\n                    latitude: row["latitude"],\n                    longitude: row["longitude"]))\n            )\n        }\n    }\n    ```\n    \n    But FetchableRecord lets you write code that is easier to read, and more efficient as well, both in terms of performance and memory usage:\n    \n    ```swift\n    struct Place: FetchableRecord { ... }\n    try dbQueue.read { db in\n        let places = try Place.fetchAll(db, sql: "SELECT * FROM place")\n    }\n    ```\n    \n    > :bulb: **Tip**: FetchableRecord can derive its implementation from the standard Decodable protocol. See [Codable Records] for more information.\n    \n    FetchableRecord can decode database rows, but it is not able to build SQL requests for you. For that, you also need TableRecord:\n    \n- [TableRecord] is able to **generate SQL queries**:\n    \n    ```swift\n    struct Place: TableRecord { ... }\n    // SELECT * FROM place ORDER BY title\n    let request = Place.order(Column("title"))\n    ```\n    \n    When a type adopts both TableRecord and FetchableRecord, it can load from those requests:\n    \n    ```swift\n    struct Place: TableRecord, FetchableRecord { ... }\n    try dbQueue.read { db in\n        let places = try Place.order(Column("title")).fetchAll(db)\n        let paris = try Place.fetchOne(key: 1)\n    }\n    ```\n\n- [PersistableRecord] is able to **write**: it can create, update, and delete rows in the database:\n    \n    ```swift\n    struct Place : PersistableRecord { ... }\n    try dbQueue.write { db in\n        try Place.delete(db, key: 1)\n        try Place(...).insert(db)\n    }\n    ```\n    \n    A persistable record can also [compare](#record-comparison) itself against other records, and avoid useless database updates.\n    \n    > :bulb: **Tip**: PersistableRecord can derive its implementation from the standard Encodable protocol. See [Codable Records] for more information.\n\n\n## FetchableRecord Protocol\n\n**The FetchableRecord protocol grants fetching methods to any type** that can be built from a database row:\n\n```swift\nprotocol FetchableRecord {\n    /// Row initializer\n    init(row: Row)\n}\n```\n\n**To use FetchableRecord**, subclass the [Record](#record-class) class, or adopt it explicitly. For example:\n\n```swift\nstruct Place {\n    var id: Int64?\n    var title: String\n    var coordinate: CLLocationCoordinate2D\n}\n\nextension Place : FetchableRecord {\n    init(row: Row) {\n        id = row["id"]\n        title = row["title"]\n        coordinate = CLLocationCoordinate2D(\n            latitude: row["latitude"],\n            longitude: row["longitude"])\n    }\n}\n```\n\nRows also accept column enums:\n\n```swift\nextension Place : FetchableRecord {\n    enum Columns: String, ColumnExpression {\n        case id, title, latitude, longitude\n    }\n    \n    init(row: Row) {\n        id = row[Columns.id]\n        title = row[Columns.title]\n        coordinate = CLLocationCoordinate2D(\n            latitude: row[Columns.latitude],\n            longitude: row[Columns.longitude])\n    }\n}\n```\n\nSee [column values](#column-values) for more information about the `row[]` subscript.\n\nWhen your record type adopts the standard Decodable protocol, you don\'t have to provide the implementation for `init(row:)`. See [Codable Records] for more information:\n\n```swift\n// That\'s all\nstruct Player: Decodable, FetchableRecord {\n    var id: Int64\n    var name: String\n    var score: Int\n}\n```\n\nFetchableRecord allows adopting types to be fetched from SQL queries:\n\n```swift\ntry Place.fetchCursor(db, sql: "SELECT ...", arguments:...) // A Cursor of Place\ntry Place.fetchAll(db, sql: "SELECT ...", arguments:...)    // [Place]\ntry Place.fetchOne(db, sql: "SELECT ...", arguments:...)    // Place?\n```\n\nSee [fetching methods](#fetching-methods) for information about the `fetchCursor`, `fetchAll` and `fetchOne` methods. See [StatementArguments](http://groue.github.io/GRDB.swift/docs/4.6/Structs/StatementArguments.html) for more information about the query arguments.\n\n> :point_up: **Note**: for performance reasons, the same row argument to `init(row:)` is reused during the iteration of a fetch query. If you want to keep the row for later use, make sure to store a copy: `self.row = row.copy()`.\n\n> :point_up: **Note**: The `FetchableRecord.init(row:)` initializer fits the needs of most applications. But some application are more demanding than others. When FetchableRecord does not exactly provide the support you need, have a look at the [Beyond FetchableRecord] chapter.\n\n\n## TableRecord Protocol\n\n**The TableRecord protocol** generates SQL for you. To use TableRecord, subclass the [Record](#record-class) class, or adopt it explicitly:\n\n```swift\nprotocol TableRecord {\n    static var databaseTableName: String { get }\n    static var databaseSelection: [SQLSelectable] { get }\n}\n```\n\nThe `databaseSelection` type property is optional, and documented in the [Columns Selected by a Request] chapter.\n\nThe `databaseTableName` type property is the name of a database table. By default, it is derived from the type name:\n\n```swift\nstruct Place: TableRecord { }\nprint(Place.databaseTableName) // prints "place"\n```\n\nFor example:\n\n- Place: `place`\n- Country: `country`\n- PostalAddress: `postalAddress`\n- HTTPRequest: `httpRequest`\n- TOEFL: `toefl`\n\nYou can still provide a custom table name:\n\n```swift\nstruct Place: TableRecord {\n    static let databaseTableName = "location"\n}\nprint(Place.databaseTableName) // prints "location"\n```\n\nSubclasses of the [Record](#record-class) class must always override their superclass\'s `databaseTableName` property:\n\n```swift\nclass Place: Record {\n    override class var databaseTableName: String {\n        return "place"\n    }\n}\nprint(Place.databaseTableName) // prints "place"\n```\n\nWhen a type adopts both TableRecord and [FetchableRecord](#fetchablerecord-protocol), it can be fetched using the [query interface](#the-query-interface):\n\n```swift\n// SELECT * FROM place WHERE name = \'Paris\'\nlet paris = try Place.filter(nameColumn == "Paris").fetchOne(db)\n```\n\nTableRecord can also fetch records by primary key:\n\n```swift\ntry Player.fetchOne(db, key: 1)              // Player?\ntry Player.fetchAll(db, keys: [1, 2, 3])     // [Player]\n\ntry Country.fetchOne(db, key: "FR")          // Country?\ntry Country.fetchAll(db, keys: ["FR", "US"]) // [Country]\n```\n\nWhen the table has no explicit primary key, GRDB uses the [hidden "rowid" column](#the-implicit-rowid-primary-key):\n\n```swift\n// SELECT * FROM document WHERE rowid = 1\ntry Document.fetchOne(db, key: 1)            // Document?\n```\n\nFor multiple-column primary keys and unique keys defined by unique indexes, provide a dictionary:\n\n```swift\n// SELECT * FROM citizenship WHERE citizenId = 1 AND countryCode = \'FR\'\ntry Citizenship.fetchOne(db, key: ["citizenId": 1, "countryCode": "FR"]) // Citizenship?\n```\n\n\n## PersistableRecord Protocol\n\n**GRDB record types can create, update, and delete rows in the database.**\n\nThose abilities are granted by three protocols:\n\n```swift\n// Defines how a record encodes itself into the database\nprotocol EncodableRecord {\n    /// Defines the values persisted in the database\n    func encode(to container: inout PersistenceContainer)\n}\n\n// Adds persistence methods\nprotocol MutablePersistableRecord: TableRecord, EncodableRecord {\n    /// Optional method that lets your adopting type store its rowID upon\n    /// successful insertion. Don\'t call it directly: it is called for you.\n    mutating func didInsert(with rowID: Int64, for column: String?)\n}\n\n// Adds immutability\nprotocol PersistableRecord: MutablePersistableRecord {\n    /// Non-mutating version of the optional didInsert(with:for:)\n    func didInsert(with rowID: Int64, for column: String?)\n}\n```\n\nYes, three protocols instead of one. Here is how you pick one or the other:\n\n- **If your type is a class**, choose `PersistableRecord`. On top of that, implement `didInsert(with:for:)` if the database table has an auto-incremented primary key.\n\n- **If your type is a struct, and the database table has an auto-incremented primary key**, choose `MutablePersistableRecord`, and implement `didInsert(with:for:)`.\n\n- **Otherwise**, choose `PersistableRecord`, and ignore `didInsert(with:for:)`.\n\nThe `encode(to:)` method defines which [values](#values) (Bool, Int, String, Date, Swift enums, etc.) are assigned to database columns.\n\nThe optional `didInsert` method lets the adopting type store its rowID after successful insertion, and is only useful for tables that have an auto-incremented primary key. It is called from a protected dispatch queue, and serialized with all database updates.\n\n**To use the persistable protocols**, subclass the [Record](#record-class) class, or adopt one of them explicitly. For example:\n\n```swift\nextension Place : MutablePersistableRecord {\n    /// The values persisted in the database\n    func encode(to container: inout PersistenceContainer) {\n        container["id"] = id\n        container["title"] = title\n        container["latitude"] = coordinate.latitude\n        container["longitude"] = coordinate.longitude\n    }\n    \n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(with rowID: Int64, for column: String?) {\n        id = rowID\n    }\n}\n\nvar paris = Place(\n    id: nil,\n    title: "Paris",\n    coordinate: CLLocationCoordinate2D(latitude: 48.8534100, longitude: 2.3488000))\n\ntry paris.insert(db)\nparis.id   // some value\n```\n\nPersistence containers also accept column enums:\n\n```swift\nextension Place : MutablePersistableRecord {\n    enum Columns: String, ColumnExpression {\n        case id, title, latitude, longitude\n    }\n    \n    func encode(to container: inout PersistenceContainer) {\n        container[Columns.id] = id\n        container[Columns.title] = title\n        container[Columns.latitude] = coordinate.latitude\n        container[Columns.longitude] = coordinate.longitude\n    }\n}\n```\n\nWhen your record type adopts the standard Encodable protocol, you don\'t have to provide the implementation for `encode(to:)`. See [Codable Records] for more information:\n\n```swift\n// That\'s all\nstruct Player: Encodable, MutablePersistableRecord {\n    var id: Int64?\n    var name: String\n    var score: Int\n    \n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(with rowID: Int64, for column: String?) {\n        id = rowID\n    }\n}\n```\n\n\n### Persistence Methods\n\n[Record](#record-class) subclasses and types that adopt [PersistableRecord] are given default implementations for methods that insert, update, and delete:\n\n```swift\n// Instance methods\ntry place.save(db)                     // INSERT or UPDATE\ntry place.insert(db)                   // INSERT\ntry place.update(db)                   // UPDATE\ntry place.update(db, columns: ...)     // UPDATE\ntry place.updateChanges(db, from: ...) // Maybe UPDATE\ntry place.updateChanges(db) { ... }    // Maybe UPDATE\ntry place.updateChanges(db)            // Maybe UPDATE (Record class only)\ntry place.delete(db)                   // DELETE\ntry place.exists(db)\n\n// Type methods\ntry Place.deleteAll(db)                    // DELETE\ntry Place.deleteAll(db, keys:...)          // DELETE\ntry Place.deleteOne(db, key:...)           // DELETE\n```\n\n- `insert`, `update`, `save` and `delete` can throw a [DatabaseError](#error-handling).\n\n- `update` and `updateChanges` can also throw a [PersistenceError](#persistenceerror), should the update fail because there is no matching row in the database.\n    \n    When saving an object that may or may not already exist in the database, prefer the `save` method:\n\n- `save` makes sure your values are stored in the database.\n\n    It performs an UPDATE if the record has a non-null primary key, and then, if no row was modified, an INSERT. It directly perfoms an INSERT if the record has no primary key, or a null primary key.\n    \n    Despite the fact that it may execute two SQL statements, `save` behaves as an atomic operation: GRDB won\'t allow any concurrent thread to sneak in (see [concurrency](#concurrency)).\n\n- `delete` returns whether a database row was deleted or not.\n\n**All primary keys are supported**, including composite primary keys that span several columns, and the [implicit rowid primary key](#the-implicit-rowid-primary-key).\n\n\n### Customizing the Persistence Methods\n\nYour custom type may want to perform extra work when the persistence methods are invoked.\n\nFor example, it may want to have its UUID automatically set before inserting. Or it may want to validate its values before saving.\n\nWhen you subclass [Record](#record-class), you simply have to override the customized method, and call `super`:\n\n```swift\nclass Player : Record {\n    var uuid: UUID?\n    \n    override func insert(_ db: Database) throws {\n        if uuid == nil {\n            uuid = UUID()\n        }\n        try super.insert(db)\n    }\n}\n```\n\nIf you use the raw [PersistableRecord] protocol, use one of the *special methods* `performInsert`, `performUpdate`, `performSave`, `performDelete`, or `performExists`:\n\n```swift\nstruct Link : PersistableRecord {\n    var url: URL\n    \n    func insert(_ db: Database) throws {\n        try validate()\n        try performInsert(db)\n    }\n    \n    func update(_ db: Database, columns: Set<String>) throws {\n        try validate()\n        try performUpdate(db, columns: columns)\n    }\n    \n    func validate() throws {\n        if url.host == nil {\n            throw ValidationError("url must be absolute.")\n        }\n    }\n}\n```\n\n> :point_up: **Note**: the special methods `performInsert`, `performUpdate`, etc. are reserved for your custom implementations. Do not use them elsewhere. Do not provide another implementation for those methods.\n>\n> :point_up: **Note**: it is recommended that you do not implement your own version of the `save` method. Its default implementation forwards the job to `update` or `insert`: these are the methods that may need customization, not `save`.\n\n\n## Codable Records\n\nRecord types that adopt an archival protocol ([Codable, Encodable or Decodable](https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types)) get free database support just by declaring conformance to the desired [record protocols](#record-protocols-overview):\n\n```swift\n// Declare a record...\nstruct Player: Codable, FetchableRecord, PersistableRecord {\n    var name: String\n    var score: Int\n}\n\n// ...and there you go:\ntry dbQueue.write { db in\n    try Player(name: "Arthur", score: 100).insert(db)\n    let players = try Player.fetchAll(db)\n}\n```\n\nCodable records encode and decode their properties according to their own implementation of the Encodable and Decodable protocols. Yet databases have specific requirements:\n\n- Properties are always coded according to their preferred database representation, when they have one (all [values](#values) that adopt the [DatabaseValueConvertible](#custom-value-types) protocol).\n- You can customize the encoding and decoding of dates and uuids.\n- Complex properties (arrays, dictionaries, nested structs, etc.) are stored as JSON.\n\nFor more information about Codable records, see:\n\n- [JSON Columns]\n- [Date and UUID Coding Strategies]\n- [The userInfo Dictionary]\n- [Tip: Derive Columns from Coding Keys](#tip-derive-columns-from-coding-keys)\n\n> :bulb: **Tip**: see the [Demo Application] for a sample app that uses Codable records.\n\n\n### JSON Columns\n\nWhen a [Codable record](#codable-records) contains a property that is not a simple [value](#values) (Bool, Int, String, Date, Swift enums, etc.), that value is encoded and decoded as a **JSON string**. For example:\n\n```swift\nenum AchievementColor: String, Codable {\n    case bronze, silver, gold\n}\n\nstruct Achievement: Codable {\n    var name: String\n    var color: AchievementColor\n}\n\nstruct Player: Codable, FetchableRecord, PersistableRecord {\n    var name: String\n    var score: Int\n    var achievements: [Achievement] // stored in a JSON column\n}\n\ntry! dbQueue.write { db in\n    // INSERT INTO player (name, score, achievements)\n    // VALUES (\n    //   \'Arthur\',\n    //   100,\n    //   \'[{"color":"gold","name":"Use Codable Records"}]\')\n    let achievement = Achievement(name: "Use Codable Records", color: .gold)\n    let player = Player(name: "Arthur", score: 100, achievements: [achievement])\n    try player.insert(db)\n}\n```\n\nGRDB uses the standard [JSONDecoder](https://developer.apple.com/documentation/foundation/jsondecoder) and [JSONEncoder](https://developer.apple.com/documentation/foundation/jsonencoder) from Foundation. By default, Data values are handled with the `.base64` strategy, Date with the `.millisecondsSince1970` strategy, and non conforming floats with the `.throw` strategy.\n\nYou can customize the JSON format by implementing those methods:\n\n```swift\nprotocol FetchableRecord {\n    static func databaseJSONDecoder(for column: String) -> JSONDecoder\n}\n\nprotocol EncodableRecord {\n    static func databaseJSONEncoder(for column: String) -> JSONEncoder\n}\n```\n\n> :bulb: **Tip**: Make sure you set the JSONEncoder `sortedKeys` option, available from iOS 11.0+, macOS 10.13+, tvOS 9.0+ and watchOS 4.0+. This option makes sure that the JSON output is stable. This stability is required for [Record Comparison] to work as expected, and database observation tools such as [ValueObservation] to accurately recognize changed records.\n\n\n### Date and UUID Coding Strategies\n\nBy default, [Codable Records] encode and decode their Date and UUID properties as described in the general [Date and DateComponents](#date-and-datecomponents) and [UUID](#uuid) chapters.\n\nTo sum up: dates encode themselves in the "YYYY-MM-DD HH:MM:SS.SSS" format, in the UTC time zone, and decode a variety of date formats and timestamps. UUIDs encode themselves as 16-bytes data blobs, and decode both 16-bytes data blobs and strings such as "E621E1F8-C36C-495A-93FC-0C247A3E6E5F".\n\nThose behaviors can be overridden:\n\n```swift\nprotocol FetchableRecord {\n    static var databaseDateDecodingStrategy: DatabaseDateDecodingStrategy { get }\n}\n\nprotocol EncodableRecord {\n    static var databaseDateEncodingStrategy: DatabaseDateEncodingStrategy { get }\n    static var databaseUUIDEncodingStrategy: DatabaseUUIDEncodingStrategy { get }\n}\n```\n\nSee [DatabaseDateDecodingStrategy](https://groue.github.io/GRDB.swift/docs/4.6/Enums/DatabaseDateDecodingStrategy.html), [DatabaseDateEncodingStrategy](https://groue.github.io/GRDB.swift/docs/4.6/Enums/DatabaseDateEncodingStrategy.html), and [DatabaseUUIDEncodingStrategy](https://groue.github.io/GRDB.swift/docs/4.6/Enums/DatabaseUUIDEncodingStrategy.html) to learn about all available strategies.\n\n> :point_up: **Note**: there is no customization of uuid decoding, because UUID can already decode all its encoded variants (16-bytes blobs, and uuid strings).\n\n\n### The userInfo Dictionary\n\nYour [Codable Records] can be stored in the database, but they may also have other purposes. In this case, you may need to customize their implementations of `Decodable.init(from:)` and `Encodable.encode(to:)`, depending on the context.\n\nThe standard way to provide such context is the `userInfo` dictionary. Implement those properties:\n\n```swift\nprotocol FetchableRecord {\n    static var databaseDecodingUserInfo: [CodingUserInfoKey: Any] { get }\n}\n\nprotocol EncodableRecord {\n    static var databaseEncodingUserInfo: [CodingUserInfoKey: Any] { get }\n}\n```\n\nFor example, here is a Player type that customizes its decoding:\n\n```swift\n// A key that holds a decoder\'s name\nlet decoderName = CodingUserInfoKey(rawValue: "decoderName")!\n\nstruct Player: FetchableRecord, Decodable {\n    init(from decoder: Decoder) throws {\n        // Print the decoder name\n        let decoderName = decoder.userInfo[decoderName] as? String\n        print("Decoded from \\(decoderName ?? "unknown decoder")")\n        ...\n    }\n}\n```\n\nYou can have a specific decoding from JSON...\n\n```swift\n// prints "Decoded from JSON"\nlet decoder = JSONDecoder()\ndecoder.userInfo = [decoderName: "JSON"]\nlet player = try decoder.decode(Player.self, from: jsonData)\n```\n\n... and another one from database rows:\n\n```swift\nextension Player: FetchableRecord {\n    static let databaseDecodingUserInfo: [CodingUserInfoKey: Any] = [decoderName: "database row"]\n}\n\n// prints "Decoded from database row"\nlet player = try Player.fetchOne(db, ...)\n```\n\n> :point_up: **Note**: make sure the `databaseDecodingUserInfo` and `databaseEncodingUserInfo` properties are explicitly declared as `[CodingUserInfoKey: Any]`. If they are not, the Swift compiler may silently miss the protocol requirement, resulting in sticky empty userInfo.\n\n\n### Tip: Derive Columns from Coding Keys\n\nCodable types are granted with a [CodingKeys](https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types) enum. You can use them to safely define database columns:\n\n```swift\nstruct Player: Codable {\n    var id: Int64\n    var name: String\n    var score: Int\n}\n\nextension Player: FetchableRecord, PersistableRecord {\n    enum Columns {\n        static let id = Column(CodingKeys.id)\n        static let name = Column(CodingKeys.name)\n        static let score = Column(CodingKeys.score)\n    }\n}\n```\n\nSee the [query interface](#the-query-interface) and [Good Practices for Designing Record Types](Documentation/GoodPracticesForDesigningRecordTypes.md) for further information.\n\n\n## Record Class\n\n**Record** is a class that is designed to be subclassed. It inherits its features from the [FetchableRecord, TableRecord, and PersistableRecord](#record-protocols-overview) protocols. On top of that, Record instances can compare against previous versions of themselves in order to [avoid useless updates](#record-comparison).\n\nRecord subclasses define their custom database relationship by overriding database methods. For example:\n\n```swift\nclass Place: Record {\n    var id: Int64?\n    var title: String\n    var isFavorite: Bool\n    var coordinate: CLLocationCoordinate2D\n    \n    init(id: Int64?, title: String, isFavorite: Bool, coordinate: CLLocationCoordinate2D) {\n        self.id = id\n        self.title = title\n        self.isFavorite = isFavorite\n        self.coordinate = coordinate\n        super.init()\n    }\n    \n    /// The table name\n    override class var databaseTableName: String {\n        return "place"\n    }\n    \n    /// The table columns\n    enum Columns: String, ColumnExpression {\n        case id, title, favorite, latitude, longitude\n    }\n    \n    /// Creates a record from a database row\n    required init(row: Row) {\n        id = row[Columns.id]\n        title = row[Columns.title]\n        isFavorite = row[Columns.favorite]\n        coordinate = CLLocationCoordinate2D(\n            latitude: row[Columns.latitude],\n            longitude: row[Columns.longitude])\n        super.init(row: row)\n    }\n    \n    /// The values persisted in the database\n    override func encode(to container: inout PersistenceContainer) {\n        container[Columns.id] = id\n        container[Columns.title] = title\n        container[Columns.favorite] = isFavorite\n        container[Columns.latitude] = coordinate.latitude\n        container[Columns.longitude] = coordinate.longitude\n    }\n    \n    /// Update record ID after a successful insertion\n    override func didInsert(with rowID: Int64, for column: String?) {\n        id = rowID\n    }\n}\n```\n\n\n## Record Comparison\n\n**Records that adopt the [EncodableRecord] protocol can compare against other records, or against previous versions of themselves.**\n\nThis helps avoiding costly UPDATE statements when a record has not been edited.\n\n- [The `updateChanges` Methods](#the-updatechanges-methods)\n- [The `databaseEquals` Method](#the-databaseequals-method)\n- [The `databaseChanges` and `hasDatabaseChanges` Methods](#the-databasechanges-and-hasdatabasechanges-methods)\n\n\n### The `updateChanges` Methods\n\nThe `updateChanges` methods perform a database update of the changed columns only (and does nothing if record has no change).\n\n- `updateChanges(_:from:)`\n\n    This method lets you compare two records:\n\n    ```swift\n    if let oldPlayer = try Player.fetchOne(db, key: 42) {\n        var newPlayer = oldPlayer\n        newPlayer.score = 100\n        if try newPlayer.updateChanges(db, from: oldPlayer) {\n            print("player was modified, and updated in the database")\n        } else {\n            print("player was not modified, and database was not hit")\n        }\n    }\n    ```\n\n- `updateChanges(_:with:)`\n    \n    This method lets you update a record in place:\n    \n    ```swift\n    if var player = try Player.fetchOne(db, key: 42) {\n        let modified = try player.updateChanges(db) {\n            $0.score = 100\n        }\n        if modified {\n            print("player was modified, and updated in the database")\n        } else {\n            print("player was not modified, and database was not hit")\n        }\n    }\n    ```\n\n- `updateChanges(_:)` (Record class only)\n    \n    Instances of the [Record](#record-class) class are able to compare against themselves, and know if they have changes that have not been saved since the last fetch or saving:\n\n    ```swift\n    // Record class only\n    if let player = try Player.fetchOne(db, key: 42) {\n        player.score = 100\n        if try player.updateChanges(db) {\n            print("player was modified, and updated in the database")\n        } else {\n            print("player was not modified, and database was not hit")\n        }\n    }\n    ```\n\n\n### The `databaseEquals` Method\n\nThis method returns whether two records have the same database representation:\n\n```swift\nlet oldPlayer: Player = ...\nvar newPlayer: Player = ...\nif newPlayer.databaseEquals(oldPlayer) == false {\n    try newPlayer.save(db)\n}\n```\n\n> :point_up: **Note**: The comparison is performed on the database representation of records. As long as your record type adopts the EncodableRecord protocol, you don\'t need to care about Equatable.\n\n\n### The `databaseChanges` and `hasDatabaseChanges` Methods\n\n`databaseChanges(from:)` returns a dictionary of differences between two records:\n\n```swift\nlet oldPlayer = Player(id: 1, name: "Arthur", score: 100)\nlet newPlayer = Player(id: 1, name: "Arthur", score: 1000)\nfor (column, oldValue) in newPlayer.databaseChanges(from: oldPlayer) {\n    print("\\(column) was \\(oldValue)")\n}\n// prints "score was 100"\n```\n\nThe [Record](#record-class) class is able to compare against itself:\n\n```swift\n// Record class only\nlet player = Player(id: 1, name: "Arthur", score: 100)\ntry player.insert(db)\nplayer.score = 1000\nfor (column, oldValue) in player.databaseChanges {\n    print("\\(column) was \\(oldValue)")\n}\n// prints "score was 100"\n```\n\n[Record](#record-class) instances also have a `hasDatabaseChanges` property:\n\n```swift\n// Record class only\nplayer.score = 1000\nif player.hasDatabaseChanges {\n    try player.save(db)\n}\n```\n\n`Record.hasDatabaseChanges` is false after a Record instance has been fetched or saved into the database. Subsequent modifications may set it, or not: `hasDatabaseChanges` is based on value comparison. **Setting a property to the same value does not set the changed flag**:\n\n```swift\nlet player = Player(name: "Barbara", score: 750)\nplayer.hasDatabaseChanges // true\n\ntry player.insert(db)\nplayer.hasDatabaseChanges // false\n\nplayer.name = "Barbara"\nplayer.hasDatabaseChanges // false\n\nplayer.score = 1000\nplayer.hasDatabaseChanges // true\nplayer.databaseChanges    // ["score": 750]\n```\n\nFor an efficient algorithm which synchronizes the content of a database table with a JSON payload, check [JSONSynchronization.playground](Documentation/Playgrounds/JSONSynchronization.playground/Contents.swift).\n\n\n## Record Customization Options\n\nGRDB records come with many default behaviors, that are designed to fit most situations. Many of those defaults can be customized for your specific needs:\n\n- [Customizing the Persistence Methods]: define what happens when you call a persistance method such as `player.insert(db)`\n- [Conflict Resolution]: Run `INSERT OR REPLACE` queries, and generally define what happens when a persistence method violates a unique index.\n- [The Implicit RowID Primary Key]: all about the special `rowid` column.\n- [Columns Selected by a Request]: define which columns are selected by requests such as `Player.fetchAll(db)`.\n- [Beyond FetchableRecord]: the FetchableRecord protocol is not the end of the story.\n\n[Codable Records] have a few extra options:\n\n- [JSON Columns]: control the format of JSON columns.\n- [Date and UUID Coding Strategies]: control the format of Date and UUID properties in your Codable records.\n- [The userInfo Dictionary]: adapt your Codable implementation for the database.\n\n\n### Conflict Resolution\n\n**Insertions and updates can create conflicts**: for example, a query may attempt to insert a duplicate row that violates a unique index.\n\nThose conflicts normally end with an error. Yet SQLite let you alter the default behavior, and handle conflicts with specific policies. For example, the `INSERT OR REPLACE` statement handles conflicts with the "replace" policy which replaces the conflicting row instead of throwing an error.\n\nThe [five different policies](https://www.sqlite.org/lang_conflict.html) are: abort (the default), replace, rollback, fail, and ignore.\n\n**SQLite let you specify conflict policies at two different places:**\n\n- In the definition of the database table:\n    \n    ```swift\n    // CREATE TABLE player (\n    //     id INTEGER PRIMARY KEY AUTOINCREMENT,\n    //     email TEXT UNIQUE ON CONFLICT REPLACE\n    // )\n    try db.create(table: "player") { t in\n        t.autoIncrementedPrimaryKey("id")\n        t.column("email", .text).unique(onConflict: .replace) // <--\n    }\n    \n    // Despite the unique index on email, both inserts succeed.\n    // The second insert replaces the first row:\n    try db.execute(sql: "INSERT INTO player (email) VALUES (?)", arguments: ["arthur@example.com"])\n    try db.execute(sql: "INSERT INTO player (email) VALUES (?)", arguments: ["arthur@example.com"])\n    ```\n    \n- In each modification query:\n    \n    ```swift\n    // CREATE TABLE player (\n    //     id INTEGER PRIMARY KEY AUTOINCREMENT,\n    //     email TEXT UNIQUE\n    // )\n    try db.create(table: "player") { t in\n        t.autoIncrementedPrimaryKey("id")\n        t.column("email", .text).unique()\n    }\n    \n    // Again, despite the unique index on email, both inserts succeed.\n    try db.execute(sql: "INSERT OR REPLACE INTO player (email) VALUES (?)", arguments: ["arthur@example.com"])\n    try db.execute(sql: "INSERT OR REPLACE INTO player (email) VALUES (?)", arguments: ["arthur@example.com"])\n    ```\n\nWhen you want to handle conflicts at the query level, specify a custom `persistenceConflictPolicy` in your type that adopts the PersistableRecord protocol. It will alter the INSERT and UPDATE queries run by the `insert`, `update` and `save` [persistence methods](#persistence-methods):\n\n```swift\nprotocol MutablePersistableRecord {\n    /// The policy that handles SQLite conflicts when records are\n    /// inserted or updated.\n    ///\n    /// This property is optional: its default value uses the ABORT\n    /// policy for both insertions and updates, so that GRDB generate\n    /// regular INSERT and UPDATE queries.\n    static var persistenceConflictPolicy: PersistenceConflictPolicy { get }\n}\n\nstruct Player : MutablePersistableRecord {\n    static let persistenceConflictPolicy = PersistenceConflictPolicy(\n        insert: .replace,\n        update: .replace)\n}\n\n// INSERT OR REPLACE INTO player (...) VALUES (...)\ntry player.insert(db)\n```\n\n> :point_up: **Note**: the `ignore` policy does not play well at all with the `didInsert` method which notifies the rowID of inserted records. Choose your poison:\n>\n> - if you specify the `ignore` policy in the database table definition, don\'t implement the `didInsert` method: it will be called with some random id in case of failed insert.\n> - if you specify the `ignore` policy at the query level, the `didInsert` method is never called.\n>\n> :point_up: **Note**: The `replace` policy may have to delete rows so that inserts and updates can succeed. Those deletions are not reported to [transaction observers](#transactionobserver-protocol) (this might change in a future release of SQLite).\n\n\n### The Implicit RowID Primary Key\n\n**All SQLite tables have a primary key.** Even when the primary key is not explicit:\n\n```swift\n// No explicit primary key\ntry db.create(table: "event") { t in\n    t.column("message", .text)\n    t.column("date", .datetime)\n}\n\n// No way to define an explicit primary key\ntry db.create(virtualTable: "book", using: FTS4()) { t in\n    t.column("title")\n    t.column("author")\n    t.column("body")\n}\n```\n\nThe implicit primary key is stored in the hidden column `rowid`. Hidden means that `SELECT *` does not select it, and yet it can be selected and queried: `SELECT *, rowid ... WHERE rowid = 1`.\n\nSome GRDB methods will automatically use this hidden column when a table has no explicit primary key:\n\n```swift\n// SELECT * FROM event WHERE rowid = 1\nlet event = try Event.fetchOne(db, key: 1)\n\n// DELETE FROM book WHERE rowid = 1\ntry Book.deleteOne(db, key: 1)\n```\n\n\n#### Exposing the RowID Column\n\n**By default, a record type that wraps a table without any explicit primary key doesn\'t know about the hidden rowid column.**\n\nWithout primary key, records don\'t have any identity, and the [persistence method](#persistence-methods) can behave in undesired fashion: `update()` throws errors, `save()` always performs insertions and may break constraints, `exists()` is always false.\n\nWhen SQLite won\'t let you provide an explicit primary key (as in [full-text](Documentation/FullTextSearch.md) tables, for example), you may want to make your record type fully aware of the hidden rowid column:\n\n1. Have the `databaseSelection` static property (from the [TableRecord] protocol) return the hidden rowid column:\n    \n    ```swift\n    struct Event : TableRecord {\n        static let databaseSelection: [SQLSelectable] = [AllColumns(), Column.rowID]\n    }\n    \n    // When you subclass Record, you need an override:\n    class Book : Record {\n        override class var databaseSelection: [SQLSelectable] {\n            return [AllColums(), Column.rowID]\n        }\n    }\n    ```\n    \n    GRDB will then select the `rowid` column by default:\n    \n    ```swift\n    // SELECT *, rowid FROM event\n    let events = try Event.fetchAll(db)\n    ```\n\n2. Have `init(row:)` from the [FetchableRecord] protocol consume the "rowid" column:\n    \n    ```swift\n    struct Event : FetchableRecord {\n        var id: Int64?\n        \n        init(row: Row) {\n            id = row[Column.rowID]\n        }\n    }\n    ```\n    \n    Your fetched records will then know their ids:\n    \n    ```swift\n    let event = try Event.fetchOne(db)!\n    event.id // some value\n    ```\n\n3. Encode the rowid in `encode(to:)`, and keep it in the `didInsert(with:for:)` method (both from the [PersistableRecord and MutablePersistableRecord](#persistablerecord-protocol) protocols):\n    \n    ```swift\n    struct Event : MutablePersistableRecord {\n        var id: Int64?\n        \n        func encode(to container: inout PersistenceContainer) {\n            container[Column.rowID] = id\n            container["message"] = message\n            container["date"] = date\n        }\n        \n        // Update auto-incremented id upon successful insertion\n        mutating func didInsert(with rowID: Int64, for column: String?) {\n            id = rowID\n        }\n    }\n    ```\n    \n    You will then be able to track your record ids, update them, or check for their existence:\n    \n    ```swift\n    let event = Event(message: "foo", date: Date())\n    \n    // Insertion sets the record id:\n    try event.insert(db)\n    event.id // some value\n    \n    // Record can be updated:\n    event.message = "bar"\n    try event.update(db)\n    \n    // Record knows if it exists:\n    event.exists(db) // true\n    ```\n\n\n### Beyond FetchableRecord\n\n**Some GRDB users eventually discover that the [FetchableRecord] protocol does not fit all situations.** Use cases that are not well handled by FetchableRecord include:\n\n- Your application needs polymorphic row decoding: it decodes some type or another, depending on the values contained in a database row.\n\n- Your application needs to decode rows with a context: each decoded value should be initialized with some extra value that does not come from the database.\n\n- Your application needs a record type that supports untrusted databases, and may fail at decoding database rows (throw an error when a row contains invalid values).\n\nSince those use cases are not well handled by FetchableRecord, don\'t try to implement them on top of this protocol: you\'ll just fight the framework.\n\nInstead, please have a look at the [CustomizedDecodingOfDatabaseRows](Documentation/Playgrounds/CustomizedDecodingOfDatabaseRows.playground/Contents.swift) playground. You\'ll run some sample code, and learn how to escape FetchableRecord when you need. And remember that leaving FetchableRecord will not deprive you of [query interface requests](#requests) and generally all SQL generation features of the [TableRecord] and [PersistableRecord] protocols.\n\n\n## Examples of Record Definitions\n\nWe will show below how to declare a record type for the following database table:\n\n```swift\ntry dbQueue.write { db in\n    try db.create(table: "place") { t in\n        t.autoIncrementedPrimaryKey("id")\n        t.column("title", .text).notNull()\n        t.column("isFavorite", .boolean).notNull().defaults(to: false)\n        t.column("longitude", .double).notNull()\n        t.column("latitude", .double).notNull()\n    }\n}\n```\n\nEach one of the three examples below is correct. You will pick one or the other depending on your personal preferences and the requirements of your application:\n\n<details>\n  <summary>Define a Codable struct, and adopt the record protocols you need</summary>\n\nThis is the shortest way to define a record type.\n\nSee the [Record Protocols Overview](#record-protocols-overview), and [Codable Records] for more information.\n\n```swift\nstruct Place: Codable {\n    var id: Int64?\n    var title: String\n    var isFavorite: Bool\n    private var latitude: CLLocationDegrees\n    private var longitude: CLLocationDegrees\n    \n    var coordinate: CLLocationCoordinate2D {\n        get {\n            return CLLocationCoordinate2D(\n                latitude: latitude,\n                longitude: longitude)\n        }\n        set {\n            latitude = newValue.latitude\n            longitude = newValue.longitude\n        }\n    }\n}\n\n// SQL generation\nextension Place: TableRecord {\n    /// The table columns\n    enum Columns {\n        static let id = Column(CodingKeys.id)\n        static let title = Column(CodingKeys.title)\n        static let isFavorite = Column(CodingKeys.isFavorite)\n        static let latitude = Column(CodingKeys.latitude)\n        static let longitude = Column(CodingKeys.longitude)\n    }\n}\n\n// Fetching methods\nextension Place: FetchableRecord { }\n\n// Persistence methods\nextension Place: MutablePersistableRecord {\n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(with rowID: Int64, for column: String?) {\n        id = rowID\n    }\n}\n```\n\n</details>\n\n<details>\n  <summary>Define a plain struct, and adopt the record protocols you need</summary>\n\nSee the [Record Protocols Overview](#record-protocols-overview) for more information.\n    \n```swift\nstruct Place {\n    var id: Int64?\n    var title: String\n    var isFavorite: Bool\n    var coordinate: CLLocationCoordinate2D\n}\n\n// SQL generation\nextension Place: TableRecord {\n    /// The table columns\n    enum Columns: String, ColumnExpression {\n        case id, title, isFavorite, latitude, longitude\n    }\n}\n\n// Fetching methods\nextension Place: FetchableRecord {\n    /// Creates a record from a database row\n    init(row: Row) {\n        id = row[Columns.id]\n        title = row[Columns.title]\n        isFavorite = row[Columns.isFavorite]\n        coordinate = CLLocationCoordinate2D(\n            latitude: row[Columns.latitude],\n            longitude: row[Columns.longitude])\n    }\n}\n\n// Persistence methods\nextension Place: MutablePersistableRecord {\n    /// The values persisted in the database\n    func encode(to container: inout PersistenceContainer) {\n        container[Columns.id] = id\n        container[Columns.title] = title\n        container[Columns.isFavorite] = isFavorite\n        container[Columns.latitude] = coordinate.latitude\n        container[Columns.longitude] = coordinate.longitude\n    }\n    \n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(with rowID: Int64, for column: String?) {\n        id = rowID\n    }\n}\n```\n\n</details>\n\n<details>\n  <summary>Define a plain struct optimized for fetching performance</summary>\n\nThis struct derives is persistence methpds from the standard Encodable protocol (see [Codable Records]), but performs optimized row decoding by accessing database columns with numeric indexes.\n\nSee the [Record Protocols Overview](#record-protocols-overview) for more information.\n    \n```swift\nstruct Place: Encodable {\n    var id: Int64?\n    var title: String\n    var isFavorite: Bool\n    private var latitude: CLLocationDegrees\n    private var longitude: CLLocationDegrees\n    \n    var coordinate: CLLocationCoordinate2D {\n        get {\n            return CLLocationCoordinate2D(\n                latitude: latitude,\n                longitude: longitude)\n        }\n        set {\n            latitude = newValue.latitude\n            longitude = newValue.longitude\n        }\n    }\n}\n\n// SQL generation\nextension Place: TableRecord {\n    /// The table columns\n    enum Columns {\n        static let id = Column(CodingKeys.id)\n        static let title = Column(CodingKeys.title)\n        static let isFavorite = Column(CodingKeys.isFavorite)\n        static let latitude = Column(CodingKeys.latitude)\n        static let longitude = Column(CodingKeys.longitude)\n    }\n    \n    /// Arrange the selected columns and lock their order\n    static let databaseSelection: [SQLSelectable] = [\n        Columns.id,\n        Columns.title,\n        Columns.favorite,\n        Columns.latitude,\n        Columns.longitude]\n}\n\n// Fetching methods\nextension Place: FetchableRecord {\n    /// Creates a record from a database row\n    init(row: Row) {\n        // For high performance, use numeric indexes that match the\n        // order of Place.databaseSelection\n        id = row[0]\n        title = row[1]\n        isFavorite = row[2]\n        coordinate = CLLocationCoordinate2D(\n            latitude: row[3],\n            longitude: row[4])\n    }\n}\n\n// Persistence methods\nextension Place: MutablePersistableRecord {\n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(with rowID: Int64, for column: String?) {\n        id = rowID\n    }\n}\n```\n\n</details>\n\n<details>\n  <summary>Subclass the <code>Record</code> class</summary>\n\nSee the [Record class](#record-class) for more information.\n    \n```swift\nclass Place: Record {\n    var id: Int64?\n    var title: String\n    var isFavorite: Bool\n    var coordinate: CLLocationCoordinate2D\n    \n    init(id: Int64?, title: String, isFavorite: Bool, coordinate: CLLocationCoordinate2D) {\n        self.id = id\n        self.title = title\n        self.isFavorite = isFavorite\n        self.coordinate = coordinate\n        super.init()\n    }\n    \n    /// The table name\n    override class var databaseTableName: String {\n        return "place"\n    }\n    \n    /// The table columns\n    enum Columns: String, ColumnExpression {\n        case id, title, isFavorite, latitude, longitude\n    }\n    \n    /// Creates a record from a database row\n    required init(row: Row) {\n        id = row[Columns.id]\n        title = row[Columns.title]\n        isFavorite = row[Columns.isFavorite]\n        coordinate = CLLocationCoordinate2D(\n            latitude: row[Columns.latitude],\n            longitude: row[Columns.longitude])\n        super.init(row: row)\n    }\n    \n    /// The values persisted in the database\n    override func encode(to container: inout PersistenceContainer) {\n        container[Columns.id] = id\n        container[Columns.title] = title\n        container[Columns.isFavorite] = isFavorite\n        container[Columns.latitude] = coordinate.latitude\n        container[Columns.longitude] = coordinate.longitude\n    }\n    \n    // Update auto-incremented id upon successful insertion\n    override func didInsert(with rowID: Int64, for column: String?) {\n        id = rowID\n    }\n}\n```\n\n</details>\n\n\n## List of Record Methods\n\nThis is the list of record methods, along with their required protocols. The [Record](#record-class) class adopts all these protocols, and adds a few extra methods.\n\n| Method | Protocols | Notes |\n| ------ | --------- | :---: |\n| **Core Methods** | | |\n| `init(row:)` | [FetchableRecord] | |\n| `Type.databaseTableName` | [TableRecord] | |\n| `Type.databaseSelection` | [TableRecord] | [*](#columns-selected-by-a-request) |\n| `Type.persistenceConflictPolicy` | [PersistableRecord] | [*](#conflict-resolution) |\n| `record.encode(to:)` | [EncodableRecord] | |\n| `record.didInsert(with:for:)` | [PersistableRecord] | |\n| **Insert and Update Records** | | |\n| `record.insert(db)` | [PersistableRecord] | |\n| `record.save(db)` | [PersistableRecord] | |\n| `record.update(db)` | [PersistableRecord] | |\n| `record.update(db, columns:...)` | [PersistableRecord] | |\n| `record.updateChanges(db, from:...)` | [PersistableRecord] | [*](#record-comparison) |\n| `record.updateChanges(db) { ... }` | [PersistableRecord] | [*](#record-comparison) |\n| `record.updateChanges(db)` | [Record](#record-class) | [*](#record-comparison) |\n| `Type.updateAll(db, ...)` | [PersistableRecord] | |\n| `Type.filter(...).updateAll(db, ...)` | [PersistableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| **Delete Records** | | |\n| `record.delete(db)` | [PersistableRecord] | |\n| `Type.deleteOne(db, key:...)` | [PersistableRecord] | <a href="#list-of-record-methods-1">\xc2\xb9</a> |\n| `Type.deleteAll(db)` | [PersistableRecord] | |\n| `Type.deleteAll(db, keys:...)` | [PersistableRecord] | <a href="#list-of-record-methods-1">\xc2\xb9</a> |\n| `Type.filter(...).deleteAll(db)` | [PersistableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| **Check Record Existence** | | |\n| `record.exists(db)` | [PersistableRecord] | |\n| **Convert Record to Dictionary** | | |\n| `record.databaseDictionary` | [EncodableRecord] | |\n| **Count Records** | | |\n| `Type.fetchCount(db)` | [TableRecord] | |\n| `Type.filter(...).fetchCount(db)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| **Fetch Record [Cursors](#cursors)** | | |\n| `Type.fetchCursor(db)` | [FetchableRecord] & [TableRecord] | |\n| `Type.fetchCursor(db, keys:...)` | [FetchableRecord] & [TableRecord] | <a href="#list-of-record-methods-1">\xc2\xb9</a> |\n| `Type.fetchCursor(db, sql: sql)` | [FetchableRecord] | <a href="#list-of-record-methods-3">\xc2\xb3</a> |\n| `Type.fetchCursor(statement)` | [FetchableRecord] | <a href="#list-of-record-methods-4">\xe2\x81\xb4</a> |\n| `Type.filter(...).fetchCursor(db)` | [FetchableRecord] & [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| **Fetch Record Arrays** | | |\n| `Type.fetchAll(db)` | [FetchableRecord] & [TableRecord] | |\n| `Type.fetchAll(db, keys:...)` | [FetchableRecord] & [TableRecord] | <a href="#list-of-record-methods-1">\xc2\xb9</a> |\n| `Type.fetchAll(db, sql: sql)` | [FetchableRecord] | <a href="#list-of-record-methods-3">\xc2\xb3</a> |\n| `Type.fetchAll(statement)` | [FetchableRecord] | <a href="#list-of-record-methods-4">\xe2\x81\xb4</a> |\n| `Type.filter(...).fetchAll(db)` | [FetchableRecord] & [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| **Fetch Individual Records** | | |\n| `Type.fetchOne(db)` | [FetchableRecord] & [TableRecord] | |\n| `Type.fetchOne(db, key:...)` | [FetchableRecord] & [TableRecord] | <a href="#list-of-record-methods-1">\xc2\xb9</a> |\n| `Type.fetchOne(db, sql: sql)` | [FetchableRecord] | <a href="#list-of-record-methods-3">\xc2\xb3</a> |\n| `Type.fetchOne(statement)` | [FetchableRecord] | <a href="#list-of-record-methods-4">\xe2\x81\xb4</a> |\n| `Type.filter(...).fetchOne(db)` | [FetchableRecord] & [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| **[Codable Records]** | | |\n| `Type.databaseDecodingUserInfo` | [FetchableRecord] | [*](#the-userinfo-dictionary) |\n| `Type.databaseJSONDecoder(for:)` | [FetchableRecord] | [*](#json-columns) |\n| `Type.databaseDateDecodingStrategy` | [FetchableRecord] | [*](#date-and-uuid-coding-strategies) |\n| `Type.databaseEncodingUserInfo` | [EncodableRecord] | [*](#the-userinfo-dictionary) |\n| `Type.databaseJSONEncoder(for:)` | [EncodableRecord] | [*](#json-columns) |\n| `Type.databaseDateEncodingStrategy` | [EncodableRecord] | [*](#date-and-uuid-coding-strategies) |\n| `Type.databaseUUIDEncodingStrategy` | [EncodableRecord] | [*](#date-and-uuid-coding-strategies) |\n| **Define [Associations]** | | |\n| `Type.belongsTo(...)` | [TableRecord] | [*](Documentation/AssociationsBasics.md) |\n| `Type.hasMany(...)` | [TableRecord] | [*](Documentation/AssociationsBasics.md) |\n| `Type.hasOne(...)` | [TableRecord] | [*](Documentation/AssociationsBasics.md) |\n| `Type.hasManyThrough(...)` | [TableRecord] | [*](Documentation/AssociationsBasics.md) |\n| `Type.hasOneThrough(...)` | [TableRecord] | [*](Documentation/AssociationsBasics.md) |\n| **Building Query Interface [Requests](#requests)** | | |\n| `record.request(for:...)` | [TableRecord] & [EncodableRecord] | [*](Documentation/AssociationsBasics.md) |\n| `Type.all()` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.none()` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.select(...)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.select(..., as:...)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.annotated(with:...)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.filter(...)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.matching(...)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.including(all:)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.including(optional:)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.including(required:)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.joining(optional:)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.joining(required:)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.order(...)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.orderByPrimaryKey()` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.having(...)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| `Type.limit(...)` | [TableRecord] | <a href="#list-of-record-methods-2">\xc2\xb2</a> |\n| **[Record Comparison]** | | |\n| `record.databaseEquals(...)` | [EncodableRecord] | |\n| `record.databaseChanges(from:...)` | [EncodableRecord] | |\n| `record.updateChanges(db, from:...)` | [PersistableRecord] | |\n| `record.updateChanges(db) { ... }` | [PersistableRecord] | |\n| `record.hasDatabaseChanges` | [Record](#record-class) | |\n| `record.databaseChanges` | [Record](#record-class) | |\n| `record.updateChanges(db)` | [Record](#record-class) | |\n\n<a name="list-of-record-methods-1">\xc2\xb9</a> All unique keys are supported: primary keys (single-column, composite, [implicit RowID](#the-implicit-rowid-primary-key)) and unique indexes:\n\n```swift\ntry Player.fetchOne(db, key: 1)                               // Player?\ntry Player.fetchOne(db, key: ["email": "arthur@example.com"]) // Player?\ntry Country.fetchAll(db, keys: ["FR", "US"])                  // [Country]\n```\n\n<a name="list-of-record-methods-2">\xc2\xb2</a> See [Fetch Requests](#requests):\n\n```swift\nlet request = Player.filter(emailColumn != nil).order(nameColumn)\nlet players = try request.fetchAll(db)  // [Player]\nlet count = try request.fetchCount(db)  // Int\n```\n\n<a name="list-of-record-methods-3">\xc2\xb3</a> See [SQL queries](#fetch-queries):\n\n```swift\nlet player = try Player.fetchOne(db, sql: "SELECT * FROM player WHERE id = ?", arguments: [1]) // Player?\n```\n\n<a name="list-of-record-methods-4">\xe2\x81\xb4</a> See [Prepared Statements](#prepared-statements):\n\n```swift\nlet statement = try db.makeSelectStatement(sql: "SELECT * FROM player WHERE id = ?")\nlet player = try Player.fetchOne(statement, arguments: [1])  // Player?\n```\n\n\nThe Query Interface\n===================\n\n**The query interface lets you write pure Swift instead of SQL:**\n\n```swift\ntry dbQueue.write { db in\n    // Update database schema\n    try db.create(table: "wine") { t in ... }\n    \n    // Fetch records\n    let wines = try Wine\n        .filter(originColumn == "Burgundy")\n        .order(priceColumn)\n        .fetchAll(db)\n    \n    // Count\n    let count = try Wine\n        .filter(colorColumn == Color.red)\n        .fetchCount(db)\n    \n    // Update\n    try Wine\n        .filter(originColumn == "Burgundy")\n        .updateAll(db, priceColumn *= 0.75)\n    \n    // Delete\n    try Wine\n        .filter(corkedColumn == true)\n        .deleteAll(db)\n}\n```\n\nYou need to open a [database connection](#database-connections) before you can query the database.\n\nPlease bear in mind that the query interface can not generate all possible SQL queries. You may also *prefer* writing SQL, and this is just OK. From little snippets to full queries, your SQL skills are welcome:\n\n```swift\ntry dbQueue.write { db in\n    // Update database schema (with SQL)\n    try db.execute(sql: "CREATE TABLE wine (...)")\n    \n    // Fetch records (with SQL)\n    let wines = try Wine.fetchAll(db,\n        sql: "SELECT * FROM wine WHERE origin = ? ORDER BY price",\n        arguments: ["Burgundy"])\n    \n    // Count (with an SQL snippet)\n    let count = try Wine\n        .filter(sql: "color = ?", arguments: [Color.red])\n        .fetchCount(db)\n    \n    // Update (with SQL)\n    try db.execute(sql: "UPDATE wine SET price = price * 0.75 WHERE origin = \'Burgundy\'")\n    \n    // Delete (with SQL)\n    try db.execute(sql: "DELETE FROM wine WHERE corked")\n}\n```\n\nSo don\'t miss the [SQL API](#sqlite-api).\n\n> :point_up: **Note**: the generated SQL may change between GRDB releases, without notice: don\'t have your application rely on any specific SQL output.\n\n- [Database Schema](#database-schema)\n- [Requests](#requests)\n- [Expressions](#expressions)\n    - [SQL Operators](#sql-operators)\n    - [SQL Functions](#sql-functions)\n- [Fetching from Requests]\n- [Fetching by Key](#fetching-by-key)\n- [Fetching Aggregated Values](#fetching-aggregated-values)\n- [Delete Requests](#delete-requests)\n- [Update Requests](#update-requests)\n- [Custom Requests](#custom-requests)\n- [Associations and Joins](Documentation/AssociationsBasics.md)\n\n\n## Database Schema\n\nOnce granted with a [database connection](#database-connections), you can setup your database schema without writing SQL:\n\n- [Create Tables](#create-tables)\n- [Modify Tables](#modify-tables)\n- [Drop Tables](#drop-tables)\n- [Create Indexes](#create-indexes)\n\n\n### Create Tables\n\n```swift\n// CREATE TABLE place (\n//   id INTEGER PRIMARY KEY AUTOINCREMENT,\n//   title TEXT,\n//   favorite BOOLEAN NOT NULL DEFAULT 0,\n//   latitude DOUBLE NOT NULL,\n//   longitude DOUBLE NOT NULL\n// )\ntry db.create(table: "place") { t in\n    t.autoIncrementedPrimaryKey("id")\n    t.column("title", .text)\n    t.column("favorite", .boolean).notNull().defaults(to: false)\n    t.column("longitude", .double).notNull()\n    t.column("latitude", .double).notNull()\n}\n```\n\nThe `create(table:)` method covers nearly all SQLite table creation features. For virtual tables, see [Full-Text Search], or use raw SQL.\n\nSQLite itself has many reference documents about table creation: [CREATE TABLE](https://www.sqlite.org/lang_createtable.html), [Datatypes In SQLite Version 3](https://www.sqlite.org/datatype3.html), [SQLite Foreign Key Support](https://www.sqlite.org/foreignkeys.html), [ON CONFLICT](https://www.sqlite.org/lang_conflict.html), [The WITHOUT ROWID Optimization](https://www.sqlite.org/withoutrowid.html).\n\n**Configure table creation**:\n\n```swift\n// CREATE TABLE example ( ... )\ntry db.create(table: "example") { t in ... }\n    \n// CREATE TEMPORARY TABLE example IF NOT EXISTS (\ntry db.create(table: "example", temporary: true, ifNotExists: true) { t in ... }\n```\n\n> :bulb: **Tip**: database table names should be singular, and camel-cased. Make them look like Swift identifiers: `place`, `country`, `postalAddress`, \'httpRequest\'.\n>\n> This will help you using [Associations] when you need them. Database table names that follow another naming convention are totally OK, but you will need to perform extra configuration.\n\n**Add regular columns** with their name and eventual type (text, integer, double, numeric, boolean, blob, date and datetime) - see [SQLite data types](https://www.sqlite.org/datatype3.html):\n\n```swift\n// CREATE TABLE example (\n//   a,\n//   name TEXT,\n//   creationDate DATETIME,\ntry db.create(table: "example") { t in\n    t.column("a")\n    t.column("name", .text)\n    t.column("creationDate", .datetime)\n```\n\nDefine **not null** columns, and set **default** values:\n\n```swift\n    // email TEXT NOT NULL,\n    t.column("email", .text).notNull()\n    \n    // name TEXT NOT NULL DEFAULT \'Anonymous\',\n    t.column("name", .text).notNull().defaults(to: "Anonymous")\n```\n    \nUse an individual column as **primary**, **unique**, or **foreign key**. When defining a foreign key, the referenced column is the primary key of the referenced table (unless you specify otherwise):\n\n```swift\n    // id INTEGER PRIMARY KEY AUTOINCREMENT,\n    t.autoIncrementedPrimaryKey("id")\n    \n    // uuid TEXT PRIMARY KEY,\n    t.column("uuid", .text).primaryKey()\n    \n    // email TEXT UNIQUE,\n    t.column("email", .text).unique()\n    \n    // countryCode TEXT REFERENCES country(code) ON DELETE CASCADE,\n    t.column("countryCode", .text).references("country", onDelete: .cascade)\n```\n\n> :bulb: **Tip**: when you need an integer primary key that automatically generates unique values, it is highly recommended that you use the `autoIncrementedPrimaryKey` method:\n>\n> ```swift\n> try db.create(table: "example") { t in\n>     t.autoIncrementedPrimaryKey("id")\n>     ...\n> }\n> ```\n>\n> The reason for this recommendation is that auto-incremented primary keys prevent the reuse of ids. This prevents your app or [database observation tools](#database-changes-observation) to think that a row was updated, when it was actually deleted, then replaced. Depending on your application needs, this may be acceptable. But usually it is not.\n\n**Create an index** on the column:\n\n```swift\n    t.column("score", .integer).indexed()\n```\n\nFor extra index options, see [Create Indexes](#create-indexes) below.\n\n**Perform integrity checks** on individual columns, and SQLite will only let conforming rows in. In the example below, the `$0` closure variable is a column which lets you build any SQL [expression](#expressions).\n\n```swift\n    // name TEXT CHECK (LENGTH(name) > 0)\n    // score INTEGER CHECK (score > 0)\n    t.column("name", .text).check { length($0) > 0 }\n    t.column("score", .integer).check(sql: "score > 0")\n```\n\nOther **table constraints** can involve several columns:\n\n```swift\n    // PRIMARY KEY (a, b),\n    t.primaryKey(["a", "b"])\n    \n    // UNIQUE (a, b) ON CONFLICT REPLACE,\n    t.uniqueKey(["a", "b"], onConfict: .replace)\n    \n    // FOREIGN KEY (a, b) REFERENCES parents(c, d),\n    t.foreignKey(["a", "b"], references: "parents")\n    \n    // CHECK (a + b < 10),\n    t.check(Column("a") + Column("b") < 10)\n    \n    // CHECK (a + b < 10)\n    t.check(sql: "a + b < 10")\n}\n```\n\n### Modify Tables\n\nSQLite lets you rename tables, and add columns to existing tables:\n\n```swift\n// ALTER TABLE referer RENAME TO referrer\ntry db.rename(table: "referer", to: "referrer")\n\n// ALTER TABLE player ADD COLUMN url TEXT\ntry db.alter(table: "player") { t in\n    t.add(column: "url", .text)\n}\n```\n\n> :point_up: **Note**: SQLite restricts the possible table alterations, and may require you to recreate dependent triggers or views. See the documentation of the [ALTER TABLE](https://www.sqlite.org/lang_altertable.html) for details. See [Advanced Database Schema Changes](#advanced-database-schema-changes) for a way to lift restrictions.\n\n\n### Drop Tables\n\nDrop tables with the `drop(table:)` method:\n\n```swift\ntry db.drop(table: "obsolete")\n```\n\n### Create Indexes\n\nCreate indexes with the `create(index:)` method:\n\n```swift\n// CREATE UNIQUE INDEX byEmail ON users(email)\ntry db.create(index: "byEmail", on: "users", columns: ["email"], unique: true)\n```\n\nRelevant SQLite documentation:\n\n- [CREATE INDEX](https://www.sqlite.org/lang_createindex.html)\n- [Indexes On Expressions](https://www.sqlite.org/expridx.html)\n- [Partial Indexes](https://www.sqlite.org/partialindex.html)\n\n\n## Requests\n\n**The query interface requests** let you fetch values from the database:\n\n```swift\nlet request = Player.filter(emailColumn != nil).order(nameColumn)\nlet players = try request.fetchAll(db)  // [Player]\nlet count = try request.fetchCount(db)  // Int\n```\n\nAll requests start from **a type** that adopts the `TableRecord` protocol, such as a `Record` subclass (see [Records](#records)):\n\n```swift\nclass Player : Record { ... }\n```\n\nDeclare the table **columns** that you want to use for filtering, or sorting:\n\n```swift\nlet idColumn = Column("id")\nlet nameColumn = Column("name")\n```\n\nYou can also declare column enums, if you prefer:\n\n```swift\n// Columns.id and Columns.name can be used just as\n// idColumn and nameColumn declared above.\nenum Columns: String, ColumnExpression {\n    case id\n    case name\n}\n```\n\nYou can now build requests with the following methods: `all`, `none`, `select`, `distinct`, `filter`, `matching`, `group`, `having`, `order`, `reversed`, `limit`, `joining`, `including`. All those methods return another request, which you can further refine by applying another method: `Player.select(...).filter(...).order(...)`.\n\n- `all()`, `none()`: the requests for all rows, or no row.\n\n    ```swift\n    // SELECT * FROM player\n    Player.all()\n    ```\n    \n    The hidden `rowid` column can be selected as well [when you need it](#the-implicit-rowid-primary-key).\n\n- `select(...)` and `select(..., as:)` define the selected columns. See [Columns Selected by a Request].\n    \n    ```swift\n    // SELECT name FROM player\n    Player.select(nameColumn, as: String.self)\n    ```\n\n- `annotated(with: ...)` extends the selection with [association aggregates](Documentation/AssociationsBasics.md#association-aggregates).\n    \n    ```swift\n    // SELECT team.*, COUNT(DISTINCT player.rowid) AS playerCount\n    // FROM team\n    // LEFT JOIN player ON player.teamId = team.id\n    // GROUP BY team.id\n    Team.annotated(with: Team.players.count)\n    ```\n\n- `distinct()` performs uniquing.\n    \n    ```swift\n    // SELECT DISTINCT name FROM player\n    Player.select(nameColumn, as: String.self).distinct()\n    ```\n\n- `filter(expression)` applies conditions.\n    \n    ```swift\n    // SELECT * FROM player WHERE id IN (1, 2, 3)\n    Player.filter([1,2,3].contains(idColumn))\n    \n    // SELECT * FROM player WHERE (name IS NOT NULL) AND (height > 1.75)\n    Player.filter(nameColumn != nil && heightColumn > 1.75)\n    ```\n\n- `filter(key:)` and `filter(keys:)` apply conditions on primary keys and unique keys:\n    \n    ```swift\n    // SELECT * FROM player WHERE id = 1\n    Player.filter(key: 1)\n    \n    // SELECT * FROM country WHERE isoCode IN (\'FR\', \'US\')\n    Country.filter(keys: ["FR", "US"])\n    \n    // SELECT * FROM citizenship WHERE citizenId = 1 AND countryCode = \'FR\'\n    Citizenship.filter(key: ["citizenId": 1, "countryCode": "FR"])\n    \n    // SELECT * FROM player WHERE email = \'arthur@example.com\'\n    Player.filter(key: ["email": "arthur@example.com"])\n    ```\n\n- `matching(pattern)` performs [full-text search](Documentation/FullTextSearch.md).\n    \n    ```swift\n    // SELECT * FROM document WHERE document MATCH \'sqlite database\'\n    let pattern = FTS3Pattern(matchingAllTokensIn: "SQLite database")\n    Document.matching(pattern)\n    ```\n    \n    When the pattern is nil, no row will match.\n\n- `group(expression, ...)` groups rows.\n    \n    ```swift\n    // SELECT name, MAX(score) FROM player GROUP BY name\n    Player\n        .select(nameColumn, max(scoreColumn))\n        .group(nameColumn)\n    ```\n\n- `having(expression)` applies conditions on grouped rows.\n    \n    ```swift\n    // SELECT team, MAX(score) FROM player GROUP BY team HAVING MIN(score) >= 1000\n    Player\n        .select(teamColumn, max(scoreColumn))\n        .group(teamColumn)\n        .having(min(scoreColumn) >= 1000)\n    ```\n\n- `having(aggregate)` applies conditions on grouped rows, according to an [association aggregate](Documentation/AssociationsBasics.md#association-aggregates).\n    \n    ```swift\n    // SELECT team.*\n    // FROM team\n    // LEFT JOIN player ON player.teamId = team.id\n    // GROUP BY team.id\n    // HAVING COUNT(DISTINCT player.rowid) >= 5\n    Team.having(Team.players.count >= 5)\n    ```\n\n- `order(ordering, ...)` sorts.\n    \n    ```swift\n    // SELECT * FROM player ORDER BY name\n    Player.order(nameColumn)\n    \n    // SELECT * FROM player ORDER BY score DESC, name\n    Player.order(scoreColumn.desc, nameColumn)\n    ```\n    \n    Each `order` call clears any previous ordering:\n    \n    ```swift\n    // SELECT * FROM player ORDER BY name\n    Player.order(scoreColumn).order(nameColumn)\n    ```\n\n- `orderByPrimaryKey()` sorts by primary key:\n    \n    ```swift\n    // SELECT * FROM player ORDER BY id\n    Player.orderByPrimaryKey()\n    \n    // SELECT * FROM country ORDER BY code\n    Country.orderByPrimaryKey()\n    \n    // SELECT * FROM citizenship ORDER BY citizenId, countryCode\n    Citizenship.orderByPrimaryKey()\n    ```\n\n- `reversed()` reverses the eventual orderings.\n    \n    ```swift\n    // SELECT * FROM player ORDER BY score ASC, name DESC\n    Player.order(scoreColumn.desc, nameColumn).reversed()\n    ```\n    \n    If no ordering was already specified, this method has no effect:\n    \n    ```swift\n    // SELECT * FROM player\n    Player.all().reversed()\n    ```\n\n- `limit(limit, offset: offset)` limits and pages results.\n    \n    ```swift\n    // SELECT * FROM player LIMIT 5\n    Player.limit(5)\n    \n    // SELECT * FROM player LIMIT 5 OFFSET 10\n    Player.limit(5, offset: 10)\n    ```\n\n- `joining(...)` and `including(...)` fetch and join records through [Associations].\n    \n    ```swift\n    // SELECT player.*, team.*\n    // FROM player\n    // JOIN team ON team.id = player.teamId\n    Player.including(required: Player.team)\n    ```\n\nYou can refine requests by chaining those methods:\n\n```swift\n// SELECT * FROM player WHERE (email IS NOT NULL) ORDER BY name\nPlayer.order(nameColumn).filter(emailColumn != nil)\n```\n\nThe `select`, `order`, `group`, and `limit` methods ignore and replace previously applied selection, orderings, grouping, and limits. On the opposite, `filter`, `matching`, and `having` methods extend the query:\n\n```swift\nPlayer                          // SELECT * FROM player\n    .filter(nameColumn != nil)  // WHERE (name IS NOT NULL)\n    .filter(emailColumn != nil) //        AND (email IS NOT NULL)\n    .order(nameColumn)          // - ignored -\n    .reversed()                 // - ignored -\n    .order(scoreColumn)         // ORDER BY score\n    .limit(20, offset: 40)      // - ignored -\n    .limit(10)                  // LIMIT 10\n```\n\n\nRaw SQL snippets are also accepted, with eventual [arguments](http://groue.github.io/GRDB.swift/docs/4.6/Structs/StatementArguments.html):\n\n```swift\n// SELECT DATE(creationDate), COUNT(*) FROM player WHERE name = \'Arthur\' GROUP BY date(creationDate)\nPlayer\n    .select(sql: "DATE(creationDate), COUNT(*)")\n    .filter(sql: "name = ?", arguments: ["Arthur"])\n    .group(sql: "DATE(creationDate)")\n```\n\n\n### Columns Selected by a Request\n\nBy default, query interface requests select all columns:\n\n```swift\n// SELECT * FROM player\nlet request = Player.all()\n```\n\n**The selection can be changed for each individual requests, or for all requests built from a given type.**\n\nThe `select(...)` and `select(..., as:)` methods change the selection of a single request (see [Fetching from Requests] for detailed information):\n\n```swift\nlet request = Player.select(max(scoreColumn))\nlet maxScore: Int? = try Int.fetchOne(db, request)\n```\n\nThe default selection for a record type is controlled by the `databaseSelection` property:\n\n```swift\nstruct RestrictedPlayer : TableRecord {\n    static let databaseTableName = "player"\n    static let databaseSelection: [SQLSelectable] = [Column("id"), Column("name")]\n}\n\nstruct ExtendedPlayer : TableRecord {\n    static let databaseTableName = "player"\n    static let databaseSelection: [SQLSelectable] = [AllColumns(), Column.rowID]\n}\n\n// SELECT id, name FROM player\nlet request = RestrictedPlayer.all()\n\n// SELECT *, rowid FROM player\nlet request = ExtendedPlayer.all()\n```\n\n> :point_up: **Note**: make sure the `databaseSelection` property is explicitly declared as `[SQLSelectable]`. If it is not, the Swift compiler may silently miss the protocol requirement, resulting in sticky `SELECT *` requests. To verify your setup, see the [How do I print a request as SQL?](#how-do-i-print-a-request-as-sql) FAQ.\n\n\n## Expressions\n\nFeed [requests](#requests) with SQL expressions built from your Swift code:\n\n\n### SQL Operators\n\n- `=`, `<>`, `<`, `<=`, `>`, `>=`, `IS`, `IS NOT`\n    \n    Comparison operators are based on the Swift operators `==`, `!=`, `===`, `!==`, `<`, `<=`, `>`, `>=`:\n    \n    ```swift\n    // SELECT * FROM player WHERE (name = \'Arthur\')\n    Player.filter(nameColumn == "Arthur")\n    \n    // SELECT * FROM player WHERE (name IS NULL)\n    Player.filter(nameColumn == nil)\n    \n    // SELECT * FROM player WHERE (score IS 1000)\n    Player.filter(scoreColumn === 1000)\n    \n    // SELECT * FROM rectangle WHERE width < height\n    Rectangle.filter(widthColumn < heightColumn)\n    ```\n    \n    > :point_up: **Note**: SQLite string comparison, by default, is case-sensitive and not Unicode-aware. See [string comparison](#string-comparison) if you need more control.\n\n- `*`, `/`, `+`, `-`\n    \n    SQLite arithmetic operators are derived from their Swift equivalent:\n    \n    ```swift\n    // SELECT ((temperature * 1.8) + 32) AS farenheit FROM planet\n    Planet.select((temperatureColumn * 1.8 + 32).forKey("farenheit"))\n    ```\n    \n    > :point_up: **Note**: an expression like `nameColumn + "rrr"` will be interpreted by SQLite as a numerical addition (with funny results), not as a string concatenation.\n\n- `AND`, `OR`, `NOT`\n    \n    The SQL logical operators are derived from the Swift `&&`, `||` and `!`:\n    \n    ```swift\n    // SELECT * FROM player WHERE ((NOT verified) OR (score < 1000))\n    Player.filter(!verifiedColumn || scoreColumn < 1000)\n    ```\n    \n    When you want to join a sequence of expressions with `AND` or `OR` operators, use `joined(operator:)`:\n    \n    ```swift\n    // SELECT * FROM player WHERE (verified AND (score >= 1000) AND (name IS NOT NULL))\n    let conditions = [\n        verifiedColumn,\n        scoreColumn >= 1000,\n        nameColumn != nil]\n    Player.filter(conditions.joined(operator: .and))\n    ```\n    \n    When the sequence is empty, `joined(operator: .and)` returns true, and `joined(operator: .or)` returns false:\n    \n    ```swift\n    // SELECT * FROM player WHERE 1\n    Player.filter([].joined(operator: .and))\n    \n    // SELECT * FROM player WHERE 0\n    Player.filter([].joined(operator: .or))\n    ```\n\n- `BETWEEN`, `IN`, `NOT IN`\n    \n    To check inclusion in a Swift sequence (array, set, range\xe2\x80\xa6), call the `contains` method:\n    \n    ```swift\n    // SELECT * FROM player WHERE id IN (1, 2, 3)\n    Player.filter([1, 2, 3].contains(idColumn))\n    \n    // SELECT * FROM player WHERE id NOT IN (1, 2, 3)\n    Player.filter(![1, 2, 3].contains(idColumn))\n    \n    // SELECT * FROM player WHERE score BETWEEN 0 AND 1000\n    Player.filter((0...1000).contains(scoreColumn))\n    \n    // SELECT * FROM player WHERE (score >= 0) AND (score < 1000)\n    Player.filter((0..<1000).contains(scoreColumn))\n    \n    // SELECT * FROM player WHERE initial BETWEEN \'A\' AND \'N\'\n    Player.filter(("A"..."N").contains(initialColumn))\n    \n    // SELECT * FROM player WHERE (initial >= \'A\') AND (initial < \'N\')\n    Player.filter(("A"..<"N").contains(initialColumn))\n    ```\n    \n    > :point_up: **Note**: SQLite string comparison, by default, is case-sensitive and not Unicode-aware. See [string comparison](#string-comparison) if you need more control.\n\n- `LIKE`\n    \n    The SQLite LIKE operator is available as the `like` method:\n    \n    ```swift\n    // SELECT * FROM player WHERE (email LIKE \'%@example.com\')\n    Player.filter(emailColumn.like("%@example.com"))\n    ```\n    \n    > :point_up: **Note**: the SQLite LIKE operator is case-insensitive but not Unicode-aware. For example, the expression `\'a\' LIKE \'A\'` is true but `\'\xc3\xa6\' LIKE \'\xc3\x86\'` is false.\n\n- `MATCH`\n    \n    The full-text MATCH operator is available through [FTS3Pattern](Documentation/FullTextSearch.md#fts3pattern) (for FTS3 and FTS4 tables) and [FTS5Pattern](Documentation/FullTextSearch.md#fts5pattern) (for FTS5):\n    \n    FTS3 and FTS4:\n    \n    ```swift\n    let pattern = FTS3Pattern(matchingAllTokensIn: "SQLite database")\n    \n    // SELECT * FROM document WHERE document MATCH \'sqlite database\'\n    Document.matching(pattern)\n    \n    // SELECT * FROM document WHERE content MATCH \'sqlite database\'\n    Document.filter(contentColumn.match(pattern))\n    ```\n    \n    FTS5:\n    \n    ```swift\n    let pattern = FTS5Pattern(matchingAllTokensIn: "SQLite database")\n    \n    // SELECT * FROM document WHERE document MATCH \'sqlite database\'\n    Document.matching(pattern)\n    ```\n\n\n### SQL Functions\n\n- `ABS`, `AVG`, `COUNT`, `LENGTH`, `MAX`, `MIN`, `SUM`:\n    \n    Those are based on the `abs`, `average`, `count`, `length`, `max`, `min` and `sum` Swift functions:\n    \n    ```swift\n    // SELECT MIN(score), MAX(score) FROM player\n    Player.select(min(scoreColumn), max(scoreColumn))\n    \n    // SELECT COUNT(name) FROM player\n    Player.select(count(nameColumn))\n    \n    // SELECT COUNT(DISTINCT name) FROM player\n    Player.select(count(distinct: nameColumn))\n    ```\n\n- `IFNULL`\n    \n    Use the Swift `??` operator:\n    \n    ```swift\n    // SELECT IFNULL(name, \'Anonymous\') FROM player\n    Player.select(nameColumn ?? "Anonymous")\n    \n    // SELECT IFNULL(name, email) FROM player\n    Player.select(nameColumn ?? emailColumn)\n    ```\n\n- `LOWER`, `UPPER`\n    \n    The query interface does not give access to those SQLite functions. Nothing against them, but they are not unicode aware.\n    \n    Instead, GRDB extends SQLite with SQL functions that call the Swift built-in string functions `capitalized`, `lowercased`, `uppercased`, `localizedCapitalized`, `localizedLowercased` and `localizedUppercased`:\n    \n    ```swift\n    Player.select(nameColumn.uppercased())\n    ```\n    \n    > :point_up: **Note**: When *comparing* strings, you\'d rather use a [collation](#string-comparison):\n    >\n    > ```swift\n    > let name: String = ...\n    >\n    > // Not recommended\n    > nameColumn.uppercased() == name.uppercased()\n    >\n    > // Better\n    > nameColumn.collating(.caseInsensitiveCompare) == name\n    > ```\n\n- Custom SQL functions and aggregates\n    \n    You can apply your own [custom SQL functions and aggregates](#custom-functions-):\n    \n    ```swift\n    let f = DatabaseFunction("f", ...)\n    \n    // SELECT f(name) FROM player\n    Player.select(f.apply(nameColumn))\n    ```\n\n\n## Fetching from Requests\n\nOnce you have a request, you can fetch the records at the origin of the request:\n\n```swift\n// Some request based on `Player`\nlet request = Player.filter(...)... // QueryInterfaceRequest<Player>\n\n// Fetch players:\ntry request.fetchCursor(db) // A Cursor of Player\ntry request.fetchAll(db)    // [Player]\ntry request.fetchOne(db)    // Player?\n```\n\nFor example:\n\n```swift\nlet allPlayers = try Player.fetchAll(db)                            // [Player]\nlet arthur = try Player.filter(nameColumn == "Arthur").fetchOne(db) // Player?\n```\n\nSee [fetching methods](#fetching-methods) for information about the `fetchCursor`, `fetchAll` and `fetchOne` methods.\n\n**You sometimes want to fetch other values**.\n\nThe simplest way is to use the request as an argument to a fetching method of the desired type:\n\n```swift\n// Fetch an Int\nlet request = Player.select(max(scoreColumn))\nlet maxScore = try Int.fetchOne(db, request) // Int?\n\n// Fetch a Row\nlet request = Player.select(min(scoreColumn), max(scoreColumn))\nlet row = try Row.fetchOne(db, request)!     // Row\nlet minScore = row[0] as Int?\nlet maxScore = row[1] as Int?\n```\n\nYou can also change the request so that it knows the type it has to fetch:\n\n- With `asRequest(of:)`, useful when you use [Associations]:\n    \n    ```swift\n    struct BookInfo: FetchableRecord, Decodable {\n        var book: Book\n        var author: Author\n    }\n    \n    // A request of BookInfo\n    let request = Book\n        .including(required: Book.author)\n        .asRequest(of: BookInfo.self)\n    \n    let bookInfos = try dbQueue.read { db in\n        try request.fetchAll(db) // [BookInfo]\n    }\n    ```\n    \n- With `select(..., as:)`, which is handy when you change the selection:\n    \n    ```swift\n    // A request of Int\n    let request = Player.select(max(scoreColumn), as: Int.self)\n    \n    let maxScore = try dbQueue.read { db in\n        try request.fetchOne(db) // Int?\n    }\n    ```\n\n\n## Fetching By Key\n\n**Fetching records according to their primary key** is a very common task. It has a shortcut which accepts any single-column primary key:\n\n```swift\n// SELECT * FROM player WHERE id = 1\ntry Player.fetchOne(db, key: 1)              // Player?\n\n// SELECT * FROM player WHERE id IN (1, 2, 3)\ntry Player.fetchAll(db, keys: [1, 2, 3])     // [Player]\n\n// SELECT * FROM country WHERE isoCode = \'FR\'\ntry Country.fetchOne(db, key: "FR")          // Country?\n\n// SELECT * FROM country WHERE isoCode IN (\'FR\', \'US\')\ntry Country.fetchAll(db, keys: ["FR", "US"]) // [Country]\n```\n\nWhen the table has no explicit primary key, GRDB uses the [hidden "rowid" column](#the-implicit-rowid-primary-key):\n\n```swift\n// SELECT * FROM document WHERE rowid = 1\ntry Document.fetchOne(db, key: 1)            // Document?\n```\n\nFor multiple-column primary keys and unique keys defined by unique indexes, provide a dictionary:\n\n```swift\n// SELECT * FROM citizenship WHERE citizenId = 1 AND countryCode = \'FR\'\ntry Citizenship.fetchOne(db, key: ["citizenId": 1, "countryCode": "FR"]) // Citizenship?\n\n// SELECT * FROM player WHERE email = \'arthur@example.com\'\ntry Player.fetchOne(db, key: ["email": "arthur@example.com"])              // Player?\n```\n\n**When you want to build a request and plan to fetch from it later**, use the `filter(key:)` and `filter(keys:)` methods:\n\n```swift\n// SELECT * FROM player WHERE id = 1\nlet request = Player.filter(key: 1)\nlet player = try request.fetchOne(db)    // Player?\n\n// SELECT * FROM player WHERE id IN (1, 2, 3)\nlet request = Player.filter(keys: [1, 2, 3])\nlet players = try request.fetchAll(db)   // [Player]\n\n// SELECT * FROM country WHERE isoCode = \'FR\'\nlet request = Country.filter(key: "FR")\nlet country = try request.fetchOne(db)   // Country?\n\n// SELECT * FROM country WHERE isoCode IN (\'FR\', \'US\')\nlet request = Country.filter(keys: ["FR", "US"])\nlet countries = try request.fetchAll(db) // [Country]\n\n// SELECT * FROM citizenship WHERE citizenId = 1 AND countryCode = \'FR\'\nlet request = Citizenship.filter(key: ["citizenId": 1, "countryCode": "FR"])\nlet citizenship = request.fetchOne(db)   // Citizenship?\n\n// SELECT * FROM player WHERE email = \'arthur@example.com\'\nlet request = Player.filter(key: ["email": "arthur@example.com"])\nlet player = try request.fetchOne(db)    // Player?\n```\n\n\n## Fetching Aggregated Values\n\n**Requests can count.** The `fetchCount()` method returns the number of rows that would be returned by a fetch request:\n\n```swift\n// SELECT COUNT(*) FROM player\nlet count = try Player.fetchCount(db) // Int\n\n// SELECT COUNT(*) FROM player WHERE email IS NOT NULL\nlet count = try Player.filter(emailColumn != nil).fetchCount(db)\n\n// SELECT COUNT(DISTINCT name) FROM player\nlet count = try Player.select(nameColumn).distinct().fetchCount(db)\n\n// SELECT COUNT(*) FROM (SELECT DISTINCT name, score FROM player)\nlet count = try Player.select(nameColumn, scoreColumn).distinct().fetchCount(db)\n```\n\n\n**Other aggregated values** can also be selected and fetched (see [SQL Functions](#sql-functions)):\n\n```swift\nlet request = Player.select(max(scoreColumn))\nlet maxScore = try Int.fetchOne(db, request) // Int?\n\nlet request = Player.select(min(scoreColumn), max(scoreColumn))\nlet row = try Row.fetchOne(db, request)!     // Row\nlet minScore = row[0] as Int?\nlet maxScore = row[1] as Int?\n```\n\n\n## Delete Requests\n\n**Requests can delete records**, with the `deleteAll()` method:\n\n```swift\n// DELETE FROM player\ntry Player.deleteAll(db)\n\n// DELETE FROM player WHERE team = \'red\'\ntry Player\n    .filter(teamColumn == "red")\n    .deleteAll(db)\n\n// DELETE FROM player ORDER BY score LIMIT 10\ntry Player\n    .order(scoreColumn)\n    .limit(10)\n    .deleteAll(db)\n```\n\n> :point_up: **Note** Deletion methods are only available for records that adopts the [PersistableRecord] protocol.\n\n**Deleting records according to their primary key** is also quite common. It has a shortcut which accepts any single-column primary key:\n\n```swift\n// DELETE FROM player WHERE id = 1\ntry Player.deleteOne(db, key: 1)\n\n// DELETE FROM player WHERE id IN (1, 2, 3)\ntry Player.deleteAll(db, keys: [1, 2, 3])\n\n// DELETE FROM country WHERE isoCode = \'FR\'\ntry Country.deleteOne(db, key: "FR")\n\n// DELETE FROM country WHERE isoCode IN (\'FR\', \'US\')\ntry Country.deleteAll(db, keys: ["FR", "US"])\n```\n\nWhen the table has no explicit primary key, GRDB uses the [hidden "rowid" column](#the-implicit-rowid-primary-key):\n\n```swift\n// DELETE FROM document WHERE rowid = 1\ntry Document.deleteOne(db, key: 1)\n```\n\nFor multiple-column primary keys and unique keys defined by unique indexes, provide a dictionary:\n\n```swift\n// DELETE FROM citizenship WHERE citizenId = 1 AND countryCode = \'FR\'\ntry Citizenship.deleteOne(db, key: ["citizenId": 1, "countryCode": "FR"])\n\n// DELETE FROM player WHERE email = \'arthur@example.com\'\nPlayer.deleteOne(db, key: ["email": "arthur@example.com"])\n```\n\n\n## Update Requests\n\n**Requests can batch update records**. The `updateAll()` method accepts *column assignments* defined with the `<-` operator:\n\n```swift\n// UPDATE player SET score = 0, isHealthy = 1\ntry Player.updateAll(db, scoreColumn <- 0, isHealthyColumn <- true)\n\n// UPDATE player SET score = 0 WHERE team = \'red\'\ntry Player\n    .filter(teamColumn == "red")\n    .updateAll(db, scoreColumn <- 0)\n\n// UPDATE player SET top = 1 ORDER BY score DESC LIMIT 10\ntry Player\n    .order(scoreColumn.desc)\n    .limit(10)\n    .updateAll(db, topColumn <- true)\n```\n\nColumn assignments accept any expression:\n\n```swift\n// UPDATE player SET score = score + (bonus * 2)\ntry Player.updateAll(db, scoreColumn <- scoreColumn + bonusColumn * 2)\n```\n\nAs a convenience, you can also use the `+=`, `-=`, `*=`, or `/=` operators:\n\n```swift\n// UPDATE player SET score = score + (bonus * 2)\ntry Player.updateAll(db, scoreColumn += bonusColumn * 2)\n```\n\nDefault [Conflict Resolution] rules apply, and you may also provide a specific one:\n\n```swift\n// UPDATE OR IGNORE player SET ...\ntry Player.updateAll(db, onConflict: .ignore, /* assignments... */)\n```\n\n> :point_up: **Note** The `updateAll` method is only available for records that adopts the [PersistableRecord] protocol.\n\n\n## Custom Requests\n\nUntil now, we have seen [requests](#requests) created from any type that adopts the [TableRecord] protocol:\n\n```swift\nlet request = Player.all()  // QueryInterfaceRequest<Player>\n```\n\nThose requests of type `QueryInterfaceRequest` can fetch and count:\n\n```swift\ntry request.fetchCursor(db) // A Cursor of Player\ntry request.fetchAll(db)    // [Player]\ntry request.fetchOne(db)    // Player?\ntry request.fetchCount(db)  // Int\n```\n\n**When the query interface can not generate the SQL you need**, you can still fallback to [raw SQL](#fetch-queries):\n\n```swift\n// Custom SQL is always welcome\ntry Player.fetchAll(db, sql: "SELECT ...")   // [Player]\n```\n\nBut you may prefer to bring some elegance back in, and build custom requests:\n\n```swift\n// No custom SQL in sight\ntry Player.customRequest().fetchAll(db) // [Player]\n```\n\n- [FetchRequest Protocol](#fetchrequest-protocol)\n- [Building Custom Requests](#building-custom-requests)\n- [Fetching From Custom Requests](#fetching-from-custom-requests)\n\n\n### FetchRequest Protocol\n\n**FetchRequest** is the protocol for all requests that run from a single select statement, and know how fetched rows should be interpreted:\n\n```swift\nprotocol FetchRequest: DatabaseRegionConvertible {\n    /// The type that tells how fetched rows should be decoded\n    associatedtype RowDecoder\n    \n    /// Returns a PreparedRequest made of a prepared statement that is ready to\n    /// be executed, and an eventual row adapter.\n    func makePreparedRequest(_ db: Database, forSingleResult singleResult: Bool) throws -> PreparedRequest\n    \n    /// The number of rows fetched by the request.\n    func fetchCount(_ db: Database) throws -> Int\n}\n```\n\nWhen the `RowDecoder` associated type is [Row](#fetching-rows), or a [value](#value-queries), or a type that conforms to [FetchableRecord], the request can fetch: see [Fetching From Custom Requests](#fetching-from-custom-requests) below.\n\nThe `makePreparedRequest(_:forSingleResult:)` method accepts a database connection, a `singleResult` hint, and returns a "prepared request" made of a [prepared statement](#prepared-statements) and an optional [row adapter](#row-adapters). Conforming types can use the `singleResult` hint as an optimization opportunity, and return a statement that fetches at most one row, with a `LIMIT` SQL clause, when possible.\n\nThe `fetchCount` method has a default implementation that builds a correct but naive SQL query from the statement returned by `prepare`: `SELECT COUNT(*) FROM (...)`. Adopting types can refine the counting SQL by customizing their `fetchCount` implementation.\n\nThe base `DatabaseRegionConvertible` protocol is involved in [database observation](#database-changes-observation). For more information, see [DatabaseRegion], [DatabaseRegionObservation], and [ValueObservation].\n\nThe FetchRequest protocol is adopted, for example, by [query interface requests](#requests):\n\n```swift\n// A FetchRequest whose RowDecoder associated type is Player:\nlet request = Player.all()\n```\n\n\n### Building Custom Requests\n\n**To build custom requests**, you can use one of the built-in requests, derive requests from other requests, or create your own request type that adopts the [FetchRequest](#fetchrequest-protocol) protocol. \n\n- [SQLRequest](http://groue.github.io/GRDB.swift/docs/4.6/Structs/SQLRequest.html) is a fetch request built from raw SQL. For example:\n    \n    ```swift\n    extension Player {\n        static func filter(color: Color) -> SQLRequest<Player> {\n            return SQLRequest<Player>(\n                sql: "SELECT * FROM player WHERE color = ?"\n                arguments: [color])\n        }\n    }\n    \n    // [Player]\n    try Player.filter(color: .red).fetchAll(db)\n    ```\n    \n    In Swift 5, you can build SQLRequest with [SQL Interpolation]:\n    \n    ```swift\n    // Swift 5\n    extension Player {\n        static func filter(color: Color) -> SQLRequest<Player> {\n            return "SELECT * FROM player WHERE color = \\(color)"\n        }\n    }\n    ```\n    \n- The `asRequest(of:)` method changes the type fetched by the request. It is useful, for example, when you use [Associations]:\n\n    ```swift\n    struct BookInfo: FetchableRecord, Decodable {\n        var book: Book\n        var author: Author\n    }\n    \n    let request = Book\n        .including(required: Book.author)\n        .asRequest(of: BookInfo.self)\n    \n    // [BookInfo]\n    try request.fetchAll(db)\n    ```\n\n- The `adapted(_:)` method eases the consumption of complex rows with [row adapters](#row-adapters). See [Joined Queries Support](#joined-queries-support) for some sample code that uses this method.\n\n- [AnyFetchRequest](http://groue.github.io/GRDB.swift/docs/4.6/Structs/AnyFetchRequest.html): a [type-erased](http://chris.eidhof.nl/post/type-erasers-in-swift/) request.\n\n\n### Fetching From Custom Requests\n\nA type adopting [FetchRequest](#fetchrequest-protocol) knows exactly what it has to do when its RowDecoder associated type can decode database rows ([Row](#fetching-rows) itself, [values](#value-queries), or [FetchableRecord]):\n\n```swift\nlet rowRequest = ...        // Some FetchRequest that fetches Row\ntry request.fetchCursor(db) // A cursor of rows\n\nlet playerRequest = ...     // Some FetchRequest that fetches Player\ntry request.fetchAll(db)    // [Player]\n\nlet intRequest = ...        // Some FetchRequest that fetches Int\ntry request.fetchOne(db)    // Int?\n```\n\nFor example:\n\n```swift\nlet playerRequest = SQLRequest<Player>(\n    sql: "SELECT * FROM player WHERE color = ?"\n    arguments: [color])\ntry request.fetchAll(db)    // [Player]\n```\n\nSee [fetching methods](#fetching-methods) for information about the `fetchCursor`, `fetchAll` and `fetchOne` methods.\n\nThe RowDecoder type associated with the FetchRequest does not have to be Row, DatabaseValueConvertible, or FetchableRecord. See the [Beyond FetchableRecord] chapter for more information.\n\n\n## Migrations\n\n**Migrations** are a convenient way to alter your database schema over time in a consistent and easy way.\n\nMigrations run in order, once and only once. When a user upgrades your application, only non-applied migrations are run.\n\nInside each migration, you typically [define and update your database tables](#database-schema) according to your evolving application needs:\n\n```swift\nvar migrator = DatabaseMigrator()\n\n// 1st migration\nmigrator.registerMigration("v1") { db in\n    try db.create(table: "author") { t in ... }\n    try db.create(table: "book") { t in ... }\n    try db.create(index: ...)\n}\n\n// 2nd migration\nmigrator.registerMigration("v2") { db in\n    try db.alter(table: "author") { t in ... }\n}\n\n// Migrations for future versions will be inserted here:\n//\n// // 3rd migration\n// migrator.registerMigration("...") { db in\n//     ...\n// }\n```\n\n**Each migration runs in a separate transaction.** Should one throw an error, its transaction is rollbacked, subsequent migrations do not run, and the error is eventually thrown by `migrator.migrate(dbQueue)`.\n\n**The memory of applied migrations is stored in the database itself** (in a reserved table).\n\nYou migrate the database up to the latest version with the `migrate(_:)` method:\n\n```swift\ntry migrator.migrate(dbQueue) // or migrator.migrate(dbPool)\n```\n\nTo migrate a database up to a specific version, use `migrate(_:upTo:)`:\n\n```swift\ntry migrator.migrate(dbQueue, upTo: "v2")\n```\n\nMigrations can only run forward:\n\n```swift\ntry migrator.migrate(dbQueue, upTo: "v2")\ntry migrator.migrate(dbQueue, upTo: "v1")\n// fatal error: database is already migrated beyond migration "v1"\n```\n\nCheck if a migration has been applied:\n\n```swift\nlet appliedMigrations = try migrator.appliedMigrations(in: dbQueue)\nif appliedMigrations.contains("v2") {\n    // "v2" migration has been applied\n}\n```\n\n### The `eraseDatabaseOnSchemaChange` Option\n\nA DatabaseMigrator can automatically wipe out the full database content, and recreate the whole database from scratch, if it detects that a migration has changed its definition:\n\n```swift\nvar migrator = DatabaseMigrator()\nmigrator.eraseDatabaseOnSchemaChange = true\n```\n\nBeware! This flag can destroy your precious users\' data!\n\nYet it may be useful in those two situations:\n\n1. During application development, as you are still designing migrations, and the schema changes often.\n    \n    In this case, it is recommended that this flag does not ship in the distributed application:\n    \n    ```swift\n    var migrator = DatabaseMigrator()\n    #if DEBUG\n    // Speed up development by nuking the database when migrations change\n    migrator.eraseDatabaseOnSchemaChange = true\n    #endif\n    ```\n\n2. When the database content can easily be recreated, such as a cache for some downloaded data.\n\nThe `eraseDatabaseOnSchemaChange` option triggers a recreation of the database if the migrator detects a *schema change*. A schema change is any difference in the `sqlite_master` table, which contains the SQL used to create database tables, indexes, triggers, and views.\n\n\n### Advanced Database Schema Changes\n\nSQLite does not support many schema changes, and won\'t let you drop a table column with "ALTER TABLE ... DROP COLUMN ...", for example.\n\nYet any kind of schema change is still possible. The SQLite documentation explains in detail how to do so: https://www.sqlite.org/lang_altertable.html#otheralter. This technique requires the temporary disabling of foreign key checks, and is supported by the `registerMigrationWithDeferredForeignKeyCheck` function:\n\n```swift\n// Add a NOT NULL constraint on player.name:\nmigrator.registerMigrationWithDeferredForeignKeyCheck("AddNotNullCheckOnName") { db in\n    try db.create(table: "new_player") { t in\n        t.autoIncrementedPrimaryKey("id")\n        t.column("name", .text).notNull()\n    }\n    try db.execute(sql: "INSERT INTO new_player SELECT * FROM player")\n    try db.drop(table: "player")\n    try db.rename(table: "new_player", to: "player")\n}\n```\n\nWhile your migration code runs with disabled foreign key checks, those are re-enabled and checked at the end of the migration, regardless of eventual errors.\n\n\n## Joined Queries Support\n\n**GRDB helps consuming joined queries with complex selection.**\n\nIn this chapter, we will focus on the extraction of information from complex rows, such as the ones fetched by the query below:\n\n```sql\n-- How to consume the left, middle, and right parts of those rows?\nSELECT player.*, team.*, MAX(round.score) AS maxScore\nFROM player\nLEFT JOIN team ON ...\nLEFT JOIN round ON ...\nGROUP BY ...\n```\n\nWe will not talk about the *generation* of joined queries, which is covered in [Associations].\n\n**So what are we talking about?**\n\nIt is difficult to consume rows fetched from complex joined queries, because they often contain several columns with the same name: `id` from table `player`, `id` from table `team`, etc.\n\nWhen such ambiguity happens, GRDB row accessors always favor the leftmost matching column. This means that `row["id"]` would give a player id, whithout any obvious way to access the team id.\n\nA classical technique to avoid this ambiguity is to give each column a unique name. For example:\n\n```sql\n-- A classical technique\nSELECT player.id AS player_id, player.name AS player_name, team.id AS team_id, team.name AS team_name, team.color AS team_color, MAX(round.score) AS maxScore\nFROM player\nLEFT JOIN team ON ...\nLEFT JOIN round ON ...\nGROUP BY ...\n```\n\nThis technique works pretty well, but it has three drawbacks:\n\n1. The selection becomes hard to read and understand.\n2. Such queries are difficult to write by hand.\n3. The mangled names are a *very* bad fit for [FetchableRecord] types that expect specific column names. After all, if the `Team` record type can read `SELECT * FROM team ...`, it should be able to read `SELECT ..., team.*, ...` as well.\n\nWe thus need another technique. **Below we\'ll see how to split rows into slices, and preserve column names.**\n\n`SELECT player.*, team.*, MAX(round.score) AS maxScore FROM ...` will be splitted into three slices: one that contains player\'s columns, one that contains team\'s columns, and a remaining slice that contains remaining column(s). The Player record type will be able to read the first slice, which contains the colums expected by the `Player.init(row:)` initializer. In the same way, the Team record type could read the second slice.\n\nUnlike the name-mangling technique, splitting rows keeps SQL legible, accepts your hand-crafted SQL queries, and plays as nicely as possible with your existing [record types](#records).\n\n- [Splitting Rows, an Introduction](#splitting-rows-an-introduction)\n- [Splitting Rows, the Record Way](#splitting-rows-the-record-way)\n- [Splitting Rows, the Request Way](#splitting-rows-the-request-way)\n- [Splitting Rows, the Codable Way](#splitting-rows-the-codable-way)\n\n\n### Splitting Rows, an Introduction\n\nLet\'s first write some introductory code, hoping that this chapter will make you understand how pieces fall together. We\'ll see [later](#splitting-rows-the-record-way) how records will help us streamline the initial approach, how to track changes in joined requests, and how we can use the standard Decodable protocol.\n\nTo split rows, we will use [row adapters](#row-adapters). Row adapters adapt rows so that row consumers see exactly the columns they want. Among other things, row adapters can define several *row scopes* that give access to as many *row slices*. Sounds like a perfect match.\n\nAt the very beginning, there is an SQL query:\n\n```swift\ntry dbQueue.read { db in\n    let sql = """\n        SELECT player.*, team.*, MAX(round.score) AS maxScore\n        FROM player\n        LEFT JOIN team ON ...\n        LEFT JOIN round ON ...\n        GROUP BY ...\n        """\n```\n\nWe need an adapter that extracts player columns, in a slice that has as many columns as there are columns in the player table. That\'s [RangeRowAdapter](#rangerowadapter):\n\n```swift\n    // SELECT player.*, team.*, ...\n    //        <------>\n    let playerWidth = try db.columns(in: "player").count\n    let playerAdapter = RangeRowAdapter(0 ..< playerWidth)\n```\n\nWe also need an adapter that extracts team columns:\n\n```swift\n    // SELECT player.*, team.*, ...\n    //                  <---->\n    let teamWidth = try db.columns(in: "team").count\n    let teamAdapter = RangeRowAdapter(playerWidth ..< (playerWidth + teamWidth))\n```\n\nWe merge those two adapters in a single [ScopeAdapter](#scopeadapter) that will allow us to access both sliced rows:\n\n```swift\n    let playerScope = "player"\n    let teamScope = "team"\n    let adapter = ScopeAdapter([\n        playerScope: playerAdapter,\n        teamScope: teamAdapter])\n```\n\nAnd now we can fetch, and start consuming our rows. You already know [row cursors](#fetching-rows):\n\n```swift\n    let rows = try Row.fetchCursor(db, sql: sql, adapter: adapter)\n    while let row = try rows.next() {\n```\n\nFrom a fetched row, we can build a player:\n\n```swift\n        let player: Player = row[playerScope]\n```\n\nIn the SQL query, the team is joined with the `LEFT JOIN` operator. This means that the team may be missing: its slice may contain team values, or it may only contain NULLs. When this happens, we don\'t want to build a Team record, and we thus load an *optional* Team:\n\n```swift\n        let team: Team? = row[teamScope]\n```\n\nAnd finally, we can load the maximum score, assuming that the "maxScore" column is not ambiguous:\n\n```swift\n        let maxScore: Int = row["maxScore"]\n        \n        print("player: \\(player)")\n        print("team: \\(team)")\n        print("maxScore: \\(maxScore)")\n    }\n}\n```\n\n> :bulb: In this chapter, we have learned:\n> \n> - how to use `RangeRowAdapter` to extract a specific table\'s columns into a *row slice*.\n> - how to use `ScopeAdapter` to gives access to several row slices through named scopes.\n> - how to use Row subscripting to extract records from rows, or optional records in order to deal with left joins.\n\n\n### Splitting Rows, the Record Way\n\nOur introduction above has introduced important techniques. It uses [row adapters](#row-adapters) in order to split rows. It uses Row subscripting in order to extract records from row slices.\n\nBut we may want to make it more usable and robust:\n\n1. It\'s generally easier to consume records than raw rows.\n2. Joined records not always need all columns from a table (see `TableRecord.databaseSelection` in [Columns Selected by a Request]).\n3. Building row adapters is long and error prone.\n\nTo address the first bullet, let\'s define a record that holds our player, optional team, and maximum score. Since it can decode database rows, it adopts the [FetchableRecord] protocol:\n\n```swift\nstruct PlayerInfo {\n    var player: Player\n    var team: Team?\n    var maxScore: Int\n}\n\n/// PlayerInfo can decode rows:\nextension PlayerInfo: FetchableRecord {\n    private enum Scopes {\n        static let player = "player"\n        static let team = "team"\n    }\n    \n    init(row: Row) {\n        player = row[Scopes.player]\n        team = row[Scopes.team]\n        maxScore = row["maxScore"]\n    }\n}\n```\n\nLet\'s now write the method that fetches PlayerInfo records:\n\n```swift\nextension PlayerInfo {\n    static func fetchAll(_ db: Database) throws -> [PlayerInfo] {\n```\n\nTo acknowledge that both Player and Team records may customize their selection of the "player" and "team" columns, we\'ll write our SQL in a slightly different way:\n\n```swift\n        // Let Player and Team customize their selection:\n        let sql = """\n            SELECT\n                \\(Player.selectionSQL()), -- instead of player.*\n                \\(Team.selectionSQL()),   -- instead of team.*\n                MAX(round.score) AS maxScore\n            FROM player\n            LEFT JOIN team ON ...\n            LEFT JOIN round ON ...\n            GROUP BY ...\n            """\n```\n\n`Player.selectionSQL()` will output `player.*`, unless Player defines a [customized selection](#columns-selected-by-a-request).\n\n> :point_up: **Note**: you may also use SQL table aliases:\n>\n> ```swift\n> let sql = """\n>     SELECT\n>         \\(Player.selectionSQL(alias: "p")),\n>         \\(Team.selectionSQL(alias: "t")),\n>         MAX(r.score) AS maxScore\n>     FROM player p\n>     LEFT JOIN team t ON ...\n>     LEFT JOIN round r ON ...\n>     GROUP BY ...\n>     """\n> ```\n\nNow is the time to build adapters (taking in account the customized selection of both player and team). We use the `splittingRowAdapters` global function, which builds row adapters of desired widths:\n\n```swift\n        let adapters = try splittingRowAdapters(columnCounts: [\n            Player.numberOfSelectedColumns(db),\n            Team.numberOfSelectedColumns(db)])\n    \n        let adapter = ScopeAdapter([\n            Scopes.player: adapters[0],\n            Scopes.team: adapters[1]])\n```\n\n> :point_up: **Note**: `splittingRowAdapters` returns as many adapters as necessary to fully split a row. In the example above, it returns *three* adapters: one for player, one for team, and one for the remaining columns.\n\nAnd finally, we can fetch player infos:\n\n```swift\n        return try PlayerInfo.fetchAll(db, sql: sql, adapter: adapter)\n    }\n}\n```\n\nAnd when your app needs to fetch player infos, it now reads:\n\n```swift\n// Fetch player infos\nlet playerInfos = try dbQueue.read { db in\n    try PlayerInfo.fetchAll(db)\n}\n```\n\n\n> :bulb: In this chapter, we have learned:\n> \n> - how to define a `FetchableRecord` record that consumes rows fetched from a joined query.\n> - how to use `selectionSQL` and `numberOfSelectedColumns` in order to deal with nested record types that define custom selection.\n> - how to use `splittingRowAdapters` in order to streamline the definition of row slices.\n> - how to gather all relevant methods and constants in a record type, fully responsible of its relationship with the database.\n\n\n### Splitting Rows, the Request Way\n\nThe `PlayerInfo.fetchAll` method [above](#splitting-rows-the-record-way) directly fetches records. It\'s all good, but in order to profit from [database observation](#database-changes-observation), you\'ll need a [custom request](#custom-requests) that defines a database query.\n\nIt is recommended that you read the previous paragraphs before you dive in this sample code. We start with the same PlayerInfo record as above:\n\n```swift\nstruct PlayerInfo {\n    var player: Player\n    var team: Team?\n    var maxScore: Int\n}\n\n/// PlayerInfo can decode rows:\nextension PlayerInfo: FetchableRecord {\n    private enum Scopes {\n        static let player = "player"\n        static let team = "team"\n    }\n    \n    init(row: Row) {\n        player = row[Scopes.player]\n        team = row[Scopes.team]\n        maxScore = row["maxScore"]\n    }\n}\n```\n\nNow we write a method that returns a request, and build the fetching method on top of that request:\n\n```swift\nextension PlayerInfo {\n    /// The request for all player infos\n    static func all() -> AdaptedFetchRequest<SQLRequest<PlayerInfo>> {\n        let sql = """\n            SELECT\n                \\(Player.selectionSQL()),\n                \\(Team.selectionSQL()),\n                MAX(round.score) AS maxScore\n            FROM player\n            LEFT JOIN team ON ...\n            LEFT JOIN round ON ...\n            GROUP BY ...\n            """\n        return SQLRequest<PlayerInfo>(sql: sql).adapted { db in\n            let adapters = try splittingRowAdapters(columnCounts: [\n                Player.numberOfSelectedColumns(db),\n                Team.numberOfSelectedColumns(db)])\n            return ScopeAdapter([\n                Scopes.player: adapters[0],\n                Scopes.team: adapters[1]])\n        }\n    }\n    \n    /// Fetches all player infos\n    static func fetchAll(_ db: Database) throws -> [PlayerInfo] {\n        return try all().fetchAll(db)\n    }\n}\n```\n\nIt is now time to use our request:\n\n```swift\n// Fetch player infos\nlet playerInfos = try dbQueue.read { db in\n    try PlayerInfo.fetchAll(db)\n}\n\n// Track player infos with RxRGDB:\nPlayerInfo.all()\n    .rx.fetchAll(in: dbQueue)\n    .subscribe(onNext: { (playerInfos: [PlayerInfo]) in\n        print("Player infos have changed")\n    })\n```\n\n> :bulb: In this chapter, we have learned how to define a custom request that can both fetch records from joined queries, and feed database observation tools.\n\n\n### Splitting Rows, the Codable Way\n\n[Codable Records] build on top of the standard Decodable protocol in order to decode database rows.\n\nYou can consume complex joined queries with Codable records as well. As a demonstration, we\'ll rewrite the [above](#splitting-rows-the-request-way) sample code:\n\n```swift\nstruct Player: Decodable, FetchableRecord, TableRecord {\n    var id: Int64\n    var name: String\n}\nstruct Team: Decodable, FetchableRecord, TableRecord {\n    var id: Int64\n    var name: String\n    var color: Color\n}\nstruct PlayerInfo: Decodable, FetchableRecord {\n    var player: Player\n    var team: Team?\n    var maxScore: Int\n}\n\nextension PlayerInfo {\n    /// The request for all player infos\n    static func all() -> AdaptedFetchRequest<SQLRequest<PlayerInfo>> {\n        let sql = """\n            SELECT\n                \\(Player.selectionSQL()),\n                \\(Team.selectionSQL()),\n                MAX(round.score) AS maxScore\n            FROM player\n            LEFT JOIN team ON ...\n            LEFT JOIN round ON ...\n            GROUP BY ...\n            """\n        return SQLRequest<PlayerInfo>(sql: sql).adapted { db in\n            let adapters = try splittingRowAdapters(columnCounts: [\n                Player.numberOfSelectedColumns(db),\n                Team.numberOfSelectedColumns(db)])\n            return ScopeAdapter([\n                CodingKeys.player.stringValue: adapters[0],\n                CodingKeys.team.stringValue: adapters[1]])\n        }\n    }\n    \n    /// Fetches all player infos\n    static func fetchAll(_ db: Database) throws -> [PlayerInfo] {\n        return try all().fetchAll(db)\n    }\n}\n\n// Fetch player infos\nlet playerInfos = try dbQueue.read { db in\n    try PlayerInfo.fetchAll(db)\n}\n\n// Track player infos with RxRGDB:\nPlayerInfo.all()\n    .rx.fetchAll(in: dbQueue)\n    .subscribe(onNext: { (playerInfos: [PlayerInfo]) in\n        print("Player infos have changed")\n    })\n```\n\n> :bulb: In this chapter, we have learned how to use the `Decodable` protocol and its associated `CodingKeys` enum in order to dry up our code.\n\n\nDatabase Changes Observation\n============================\n\n**SQLite notifies its host application of changes performed to the database, as well of transaction commits and rollbacks.**\n\nGRDB puts this SQLite feature to some good use, and lets you observe the database in various ways:\n\n- [After Commit Hook](#after-commit-hook): Handle successful transactions one by one.\n- [ValueObservation and DatabaseRegionObservation]: Automated tracking of database requests.\n- [TransactionObserver Protocol](#transactionobserver-protocol): Low-level database observation.\n- [GRDBCombine]: Automated tracking of database changes, with [Combine](https://developer.apple.com/documentation/combine).\n- [RxGRDB]: Automated tracking of database changes, with [RxSwift](https://github.com/ReactiveX/RxSwift).\n\nDatabase observation requires that a single [database queue](#database-queues) or [pool](#database-pools) is kept open for all the duration of the database usage.\n\n\n## After Commit Hook\n\nWhen your application needs to make sure a specific database transaction has been successfully committed before it executes some work, use the `Database.afterNextTransactionCommit(_:)` method.\n\nIts closure argument is called right after database changes have been successfully written to disk:\n\n```swift\ntry dbQueue.write { db in\n    db.afterNextTransactionCommit { db in\n        print("success")\n    }\n    ...\n} // prints "success"\n```\n\nThe closure runs in a protected dispatch queue, serialized with all database updates.\n\n**This "after commit hook" helps synchronizing the database with other resources, such as files, or system sensors.**\n\nIn the example below, a [location manager](https://developer.apple.com/documentation/corelocation/cllocationmanager) starts monitoring a CLRegion if and only if it has successfully been stored in the database:\n\n```swift\n/// Inserts a region in the database, and start monitoring upon\n/// successful insertion.\nfunc startMonitoring(_ db: Database, region: CLRegion) throws {\n    // Make sure database is inside a transaction\n    try db.inSavepoint {\n        \n        // Save the region in the database\n        try insert(...)\n        \n        // Start monitoring if and only if the insertion is\n        // eventually committed\n        db.afterNextTransactionCommit { _ in\n            // locationManager prefers the main queue:\n            DispatchQueue.main.async {\n                locationManager.startMonitoring(for: region)\n            }\n        }\n        \n        return .commit\n    }\n}\n```\n\nThe method above won\'t trigger the location manager if the transaction is eventually rollbacked (explicitly, or because of an error), as in the sample code below:\n\n```swift\ntry dbQueue.write { db in\n    // success\n    try startMonitoring(db, region)\n    \n    // On error, the transaction is rollbacked, the region is not inserted, and\n    // the location manager is not invoked.\n    try failableMethod(db)\n}\n```\n\n\n## ValueObservation and DatabaseRegionObservation\n\n**ValueObservation and DatabaseRegionObservation** are two database observations tools that track changes in database [requests](#requests).\n\n```swift\n// Let\'s observe all players!\nlet request = Player.all()\n```\n\n[ValueObservation] notifies your application with **fresh values** (this is what most applications need :+1:):\n\n```swift\nlet observation = ValueObservation.tracking { db in\n    try request.fetchAll(db)\n}\nlet observer = observation.start(\n    in: dbQueue,\n    onError: { error in\n        print("fresh players could not be fetched")\n    },\n    onChange: { (players: [Player]) in\n        let names = players.map { $0.name }.joined(separator: ", ")\n        print("Fresh players: \\(names)")\n    })\n\ntry dbQueue.write { db in\n    try Player(name: "Arthur").insert(db)\n}\n// Prints "Fresh players: Arthur, ..."\n```\n\n[DatabaseRegionObservation] notifies your application with **database connections**, right after an impactful database transaction has been committed (reserved for more advanced use cases :nerd_face:):\n\n```swift\nlet observation = DatabaseRegionObservation(tracking: request)\nlet observer = try observation.start(in: dbQueue) { (db: Database) in\n    print("Players have changed.")\n}\n\ntry dbQueue.write { db in\n    try Player(name: "Barbara").insert(db)\n}\n// Prints "Players have changed."\n```\n\n- [ValueObservation]\n- [DatabaseRegionObservation]\n\n\n## ValueObservation\n\n**ValueObservation tracks changes in the results of database [requests](#requests), and notifies fresh values whenever the database changes.**\n\nChanges are only notified after they have been committed in the database. No insertion, update, or deletion in tracked tables is missed. This includes indirect changes triggered by [foreign keys](https://www.sqlite.org/foreignkeys.html#fk_actions) or [SQL triggers](https://www.sqlite.org/lang_createtrigger.html).\n\n\n- **[ValueObservation Usage](#valueobservation-usage)**\n- [ValueObservation.tracking(value:)](#valueobservationtrackingvalue)\n- [ValueObservation.tracking(_:fetch:)](#valueobservationtracking_fetch)\n- [observationForCount, observationForAll, observationForFirst](#observationforcount-observationforall-observationforfirst)\n- [ValueObservation Transformations](#valueobservation-transformations): [map](#valueobservationmap), [compactMap](#valueobservationcompactmap), ...\n- [ValueObservation Error Handling](#valueobservation-error-handling)\n- [ValueObservation Options](#valueobservation-options)\n- [Advanced: ValueObservation.tracking(_:reducer:)](#advanced-valueobservationtracking_reducer)\n\n\n### ValueObservation Usage\n\nHere is a typical UIViewController which observes the database in order to keep its view up-to-date:\n\n```swift\nclass PlayerViewController: UIViewController {\n    @IBOutlet weak var nameLabel: UILabel!\n    private var observer: TransactionObserver?\n    \n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        \n        // Define a ValueObservation which tracks a player\n        let observation = ValueObservation.tracking { db in\n            try Player.fetchOne(db, key: 42)\n        }\n        \n        // Start observing the database\n        observer = observation.start(\n            in: dbQueue,\n            onError: { error in\n                print("player could not be fetched")\n            },\n            onChange: { [weak self] (player: Player?) in\n                // Player has been refreshed: update view\n                guard let self = self else { return }\n                self.nameLabel.text = player?.name\n            })\n    }\n    \n    override func viewWillDisappear(_ animated: Bool) {\n        super.viewWillDisappear(animated)\n        \n        // Stop observing the database\n        observer = nil\n    }\n}\n```\n\nBy default, all values and errors are notified on the main queue. Views can be updated right from the `onChange` callback.\n\nBy default, an initial fetch is performed as soon as the observation starts: the view is set up and ready when the `viewWillAppear` method returns.\n\nThe observer returned by the `start` method is stored in a property of the view controller. This allows the view controller to control the duration of the observation. When the observer is deallocated, the observation stops. Meanwhile, all transactions that modify the observed player are notified, and the `nameLabel` is kept up-to-date.\n\n> :bulb: **Tip**: see the [Demo Application] for a sample app that uses ValueObservation.\n>\n> :bulb: **Tip**: When fetching values is slow, and should never ever block the main queue, opt in for async notifications:\n>\n> ```swift\n> override func viewWillAppear(_ animated: Bool) {\n>     super.viewWillAppear(animated)\n>     \n>     // Define a ValueObservation which tracks a player\n>     let observation = ValueObservation.tracking { db in\n>         try Player.fetchOne(db, key: 42)\n>     }\n>\n>     // Observation is asynchronous\n>     observation.scheduling = .async(onQueue: .main, startImmediately: true)\n>\n>     // Start observing the database\n>     observer = observation.start(\n>         in: dbQueue,\n>         onError: { error in\n>             print("player could not be fetched")\n>         },\n>         onChange: { [weak self] (player: Player?) in\n>             // Player has been refreshed: update view\n>             guard let self = self else { return }\n>             self.activityIndicator.stopAnimating()\n>             self.nameLabel.text = player?.name\n>         })\n>\n>     // Wait for player\n>     activityIndicator.startAnimating()\n>     nameLabel.text = nil\n> }\n> ```\n>\n> See [ValueObservation.scheduling](#valueobservationscheduling) for more information.\n\n\n### ValueObservation.tracking(value:)\n\nIn order to observe database values, you will generally define a **ValueObservation** which tracks the value you are interested in, and then start the observation.\n\nFor example:\n\n```swift\n// Track changes in a single player\nlet observation = ValueObservation.tracking { db in\n    try Player.fetchOne(db, key: 42)\n}\n\nobserver = observation.start(\n    in: dbQueue,\n    onError: { error in ... },\n    onChange: { (player: Player?) in\n        print("Fresh player: \\(player)")\n    })\n```\n\n**You can observe several requests and several tables if you need**: all writes that have an impact on the fetched values will trigger the observation, and call the `onChange` function.\n\n**It may happen that such an observation notifies identical consecutive values.** This is because it will fetch a fresh value whenever a change *could* happen. For example, the observation for the maximum player score will notify a fresh value everytime a score is changed, inserted, or deleted, even if the maximum score is unchanged:\n\n```swift\n// Track changes in the maximum player score\n// This observation may notify duplicate values\nlet observation = ValueObservation.tracking { db in\n    try Player.select(max(Column("score")), as: Int.self).fetchOne(db)\n}\n```\n\nYou can filter out those duplicates with the [ValueObservation.removeDuplicates](#valueobservationremoveduplicates) method. It requires the observed value to adopt the Equatable protocol:\n    \n```swift\nlet observation = ValueObservation\n    .tracking { db in\n        try Player.select(max(Column("score")), as: Int.self).fetchOne(db)\n    }\n    .removeDuplicates()\n```\n\n\nWe will see below other ways to define observations. They all add a little convenience, or optimization.\n\n\n### ValueObservation.tracking(_:fetch:)\n\nThe `ValueObservation.tracking(_:fetch:)` method is an **optimized** version of the [`ValueObservation.tracking(value:)`](#valueobservationtrackingvalue) method seen above. \n\nThe returned observation ouputs exactly the same results, but it can perform better when you use a [database pool](#database-pools), and the fetch is slow. It reduces write contention by fetching fresh values without blocking write accesses. When you use a [database queue](#database-queues), no optimization is applied.\n\nIt accepts two arguments:\n\n1. A list of observed requests.\n2. A closure that fetches a fresh value whenever one of the observed requests are modified.\n\nChanges that happen outside of the observed requests are ignored, so make sure you fully cover the database region you want to observe. This is the price you pay for the optimization.\n\nLet\'s give a practical example, and observe the "Hall of Fame":\n\n```swift\nstruct HallOfFame {\n    var totalPlayerCount: Int\n    var bestPlayers: [Player]\n}\n\nextension HallOfFame {\n    /// Fetch the HallOfFame\n    static fetch(_ db: Database) throws -> HallOfFame {\n        let totalPlayerCount = try Player.fetchCount(db)\n        let bestPlayers = try Player\n            .order(Column("score").desc)\n            .limit(10)\n            .fetchAll(db)\n        return HallOfFame(\n            totalPlayerCount: totalPlayerCount,\n            bestPlayers: bestPlayers)\n    }\n}\n```\n\nIn order to track changes in the Hall of Fame in an optimized way, we see that any change to the `player` table can impact the Hall of Fame. We thus track the request for all players, `Player.all()`, and fetch a new Hall of Fame whenever players change:\n\n```swift\nlet observation = ValueObservation.tracking(Player.all(), fetch: { db in\n    try HallOfFame.fetch(db)\n})\n```\n\n> :point_up: **Note**: the initial parameter of `ValueObservation.tracking(_:fetch:)` can be fed with requests, and generally speaking, values that adopt the [DatabaseRegionConvertible] protocol.\n\n\n### observationForCount, observationForAll, observationForFirst\n\nGiven a [request](#requests), even a [custom request](#custom-requests), you can observe its number of results, all results, or the first one:\n\n```swift\nrequest.observationForCount()\nrequest.observationForAll()\nrequest.observationForFirst()\n```\n\nThose observations are equivalent to the following ones, defined with [`ValueObservation.tracking(value:)`](#valueobservationtrackingvalue):\n\n```swift\nValueObservation.tracking { db in try request.fetchCount(db) }\nValueObservation.tracking { db in try request.fetchAll(db) }\nValueObservation.tracking { db in try request.fetchOne(db) }\n```\n\nYet they are **optimized**:\n\n- They perform a filtering of consecutive identical values, based on raw database values, so that you are not notified of database changes that do not impact the result of the request.\n- They can perform better when you use a [database pool](#database-pools), and the fetch is slow.\n\n\n### ValueObservation Transformations\n\n- [ValueObservation.map](#valueobservationmap)\n- [ValueObservation.compactMap](#valueobservationcompactmap)\n- [ValueObservation.removeDuplicates](#valueobservationremoveduplicates)\n- [ValueObservation.combine(...)](#valueobservationcombine)\n\n\n#### ValueObservation.map\n\nThe `map` method lets you transform the values notified by a ValueObservation.\n\nFor example:\n\n```swift\n// Observe a player\'s profile image\nlet observation = ValueObservation\n    .tracking { db in try Player.fetchOne(db, key: 42) }\n    .map { player in player?.image }\n\nlet observer = observation.start(\n    in: dbQueue,\n    onError: { error in ... },\n    onChange: { (image: UIImage?) in\n        print("Player picture has changed")\n    })\n```\n\nThe transformation closure does not run on the main queue, and is suitable for heavy computations.\n\n\n#### ValueObservation.compactMap\n\nThe `compactMap` method lets you transform and filter the values notified by a ValueObservation. Only non-nil transformed values are notified.\n\nFor example:\n\n```swift\n// Observe a player\nlet observation = ValueObservation\n    .tracking { db in try Player.fetchOne(db, key: 42) }\n    .compactMap { $0 }\n    \nlet observer = observation.start(\n    in: dbQueue,\n    onError: { error in ... },\n    onChange: { (player: Player) in\n        print("Player name: \\(player.name)")\n    })\n```\n\nThe transformation closure does not run on the main queue, and is suitable for heavy computations.\n\n\n#### ValueObservation.removeDuplicates\n\nThe `removeDuplicates` method filters out the consecutive equal values notified by a ValueObservation. The observed values must adopt the standard Equatable protocol.\n\nFor example:\n\n```swift\nlet observation = ValueObservation\n    .tracking { db in try Player.fetchOne(db, key: 42) }\n    .removeDuplicates()\n\nlet observer = observation.start(\n    in: dbQueue,\n    onError: { error in ... },\n    onChange: { (player: Player) in\n        print("Player: \\(player)")\n    })\n```\n\n> :point_up: **Note**: the observations returned by the [observationForCount, observationForAll, observationForFirst](#observationforcount-observationforall-observationforfirst) methods already perform a similar filtering, based on raw database values.\n\n\n#### ValueObservation.combine(...)\n\nThe `ValueObservation.combine(...)` method builds a single observation from several:\n\n```swift\n// Two base observations\nlet playerCountObservation = ValueObservation.tracking { db in\n    try Player.fetchCount(db)\n}\nlet bestPlayersObservation = ValueObservation.tracking { db in\n    try Player\n        .limit(10)\n        .order(Column("score").desc)\n        .fetchAll(db)\n}\n\n// The combined observation\nlet observation = ValueObservation.combine(\n    playerCountObservation, \n    bestPlayersObservation)\n    \n// Start tracking the hall of fame\nlet observer = observation.start(\n    in: dbQueue,\n    onError: { error in ... },\n    onChange: { (totalPlayerCount, bestPlayers) in\n        print("""\n            Best players out of \\(totalPlayerCount):\n            \\(bestPlayers)\n            """)\n    })\n```\n\n`combine` also exists as an instance method:\n\n```swift\nstruct HallOfFame {\n    var totalPlayerCount: Int\n    var bestPlayers: [Player]\n}\n\nlet observation = playerCountObservation.combine(bestPlayersObservation) {\n    HallOfFame(totalPlayerCount: $0, bestPlayers: $1)\n}\n```\n\nYou can combine up to eight observations together. They can feed from as many database tables as needed.\n\nCombining observations provides the guarantee that notified values are [**consistent**](https://en.wikipedia.org/wiki/Consistency_(database_systems)).\n\n> :point_up: **Note**: readers who are familiar with Reactive Programming will recognize the [CombineLatest](http://reactivex.io/documentation/operators/combinelatest.html) operator in the ValueObservation `combine` method. The reactive operator does not care about data consistency, though: if you use a Reactive layer such as [GRDBCombine] or [RxGRDB], make sure you compose observations with `ValueObservation.combine`, not with the CombineLatest operator.\n\n\n### ValueObservation Error Handling\n\nWhen you start an observation, the `onError` callback is called whenever fresh values could not be fetched. It is scheduled just like values (see [ValueObservation.scheduling](#valueobservationscheduling)):\n\n```swift\nlet observer = observation.start(\n    in: dbQueue,\n    onError: { error in\n        print("fresh value could not be fetched")\n    },\n    onChange: { value in\n        print("fresh value: \\(value)")\n    })\n```\n\nAn error does not stop the observation. After an error has been received, subsequent transactions may succeed in notifying fresh values. You may witness such temporary errors when the database becomes temporarily unreachable, for example due to [data protection](#data-protection).\n\nDepending on the way your application wants to deal with such errors, you may want to tighten your control on the scheduling of database accesses with [DatabaseRegionObservation]. See also the reactive companion libraries [GRDBCombine] and [RxGRDB], which stop observation whenever a ValueObservation error happens.\n\nThe `onError` callback can be omitted, but this is **not recommended**:\n\n```swift\n// Not recommended: omitting the onError callback\nlet observer = try observation.start(in: dbQueue) { value in\n    print("fresh value: \\(value)")\n}\n```\n\n\n### ValueObservation Options\n\nSome behaviors of value observations can be configured:\n\n- [ValueObservation.scheduling](#valueobservationscheduling): Control the dispatching of notified values.\n- [ValueObservation.requiresWriteAccess](#valueobservationrequireswriteaccess): Allow observations to write in the database.\n\n\n#### ValueObservation.scheduling\n    \nThe `scheduling` property lets you control how fresh values are notified:\n\n- `.mainQueue` (the default): all values are notified on the main queue.\n    \n    If the observation starts on the main queue, an initial value is notified right upon subscription, synchronously:\n    \n    ```swift\n    // On main queue\n    let observer = observation.start(\n        in: dbQueue,\n        onError: { error in ... },\n        onChange: { value in\n            // On main queue\n            print("fresh value: \\(value)")\n        })\n    // <- Here "fresh value" is already printed.\n    ```\n    \n    If the observation does not start on the main queue, an initial value is also notified on the main queue, but asynchronously:\n    \n    ```swift\n    // Not on the main queue\n    let observer = observation.start(\n        in: dbQueue,\n        onError: { error in ... },\n        onChange: { value in\n            // On main queue\n            print("fresh value: \\(value)")\n        })\n    ```\n    \n    After the initial value has been notified, all subsequent values are notified asynchronously:\n    \n    ```swift\n    try dbQueue.write { db in ... }\n    // <- Eventually prints "fresh value" on the main queue\n    ```\n\n- `.async(onQueue:startImmediately:)`: all values are asychronously notified on the specified queue.\n    \n    An initial value is fetched and notified if `startImmediately` is true.\n    \n    For example:\n    \n    ```swift\n    // On main queue\n    var observation = ...\n    observation.scheduling = .async(onQueue: .main, startImmediately: true)\n    let observer = observation.start(\n        in: dbQueue,\n        onError: { error in ... },\n        onChange: { value in\n            // On main queue\n            print("fresh value: \\(value)")\n        })\n    // <- Eventually prints "fresh value"\n    ```\n\n- `unsafe(startImmediately:)`: values are not all notified on the same dispatch queue.\n    \n    If `startImmediately` is true, an initial value is notified right upon subscription, synchronously, on the dispatch queue which starts the observation.\n    \n    ```swift\n    // On any queue\n    var observation = ...\n    observation.scheduling = .unsafe(startImmediately: true)\n    let observer = observation.start(\n        in: dbQueue,\n        onError: { error in ... },\n        onChange: { value in\n            print("fresh value: \\(value)")\n        })\n    // <- Here "fresh value" is already printed.\n    ```\n    \n    After the initial value has been notified, all subsequent values are notified on unspecified queues.\n    \n    > :point_up: **Note**: this unsafe mode is intended for third-party libraries that provide their own scheduling engine.\n\n\n#### ValueObservation.requiresWriteAccess\n\nThe `requiresWriteAccess` property is false by default. When true, a ValueObservation has a write access to the database, and its fetches are automatically wrapped in a [savepoint](#transactions-and-savepoints):\n\n```swift\nvar observation = ValueObservation.tracking { db in\n    // write access allowed\n    ...\n}\nobservation.requiresWriteAccess = true\n```\n\nWhen you use a [database pool](#database-pools), don\'t use this flag unless you really need it. Observations with write access are less efficient because they block all writes for the whole duration of a fetch.\n\n\n### Advanced: ValueObservation.tracking(_:reducer:)\n\nThe most low-level way to define a ValueObservation is to create one from an observed database region (see above), and a **reducer** that adopts the **ValueReducer** protocol ([**:fire: EXPERIMENTAL**](#what-are-experimental-features)):\n\n```swift\nprotocol ValueReducer {\n    associatedtype Fetched\n    associatedtype Value\n    \n    /// Fetches a database value\n    func fetch(_ db: Database) throws -> Fetched\n    \n    /// Returns a notified value\n    mutating func value(_ fetched: Fetched) -> Value?\n}\n```\n\nThe `fetch` method is called upon changes in the observed [database region](#databaseregion). It runs inside a protected dispatch queue and is guaranteed an immutable view of the last committed state of the database.\n\nThe `value` method transforms a fetched value into a notified value. It returns nil if the observer should not be notified. It runs inside a dispatch queue called the "reduce queue", which is not the main queue, and not a database queue.\n\nThe sample code below counts the number of times the player table is modified:\n\n```swift\nvar count = 0\nlet reducer = AnyValueReducer(\n    fetch: { _ in /* don\'t fetch anything */ },\n    value: { _ -> Int? in\n        defer { count += 1 }\n        return count })\nlet observation = ValueObservation.tracking(Player.all(), reducer: { _ in reducer })\nlet observer = observation.start(\n    in: dbQueue,\n    onError: { error in ... },\n    onChange: { (count: Int) in\n        print("Number of transactions that have modified players: \\(count)")\n    })\n// Prints "Number of transactions that have modified players: 0"\n\ntry dbQueue.write { db in\n    try Player(...).insert(db)\n}\n// Prints "Number of transactions that have modified players: 1"\n```\n\n\n## DatabaseRegionObservation\n\n**DatabaseRegionObservation tracks changes in database [requests](#requests), and notifies each impactful [transaction](#transactions-and-savepoints).**\n\nNo insertion, update, or deletion in the tracked tables is missed. This includes indirect changes triggered by [foreign keys](https://www.sqlite.org/foreignkeys.html#fk_actions) or [SQL triggers](https://www.sqlite.org/lang_createtrigger.html).\n\nDatabaseRegionObservation calls your application right after changes have been committed in the database, and before any other thread had any opportunity to perform further changes. *This is a pretty strong guarantee, that most applications do not really need.* Instead, most applications prefer to be notified with fresh values: make sure you check [ValueObservation] before using DatabaseRegionObservation.\n\n\n### DatabaseRegionObservation Usage\n\nDefine an observation by providing one or several requests to track:\n\n```swift\n// Track all players\nlet observation = DatabaseRegionObservation(tracking: Player.all())\n```\n\nThen start the observation from a [database queue](#database-queues) or [pool](#database-pools):\n\n```swift\nlet observer = try observation.start(in: dbQueue) { (db: Database) in\n    print("Players were changed")\n}\n```\n\nAnd enjoy the changes notifications:\n\n```swift\ntry dbQueue.write { db in\n    try Player(name: "Arthur").insert(db)\n}\n// Prints "Players were changed"\n```\n\nBy default, the observation lasts until the observer returned by the `start` method is deallocated. See [DatabaseRegionObservation.extent](#databaseregionobservationextent) for more details.\n\nYou can also feed DatabaseRegionObservation with [DatabaseRegion], or any type which conforms to the [DatabaseRegionConvertible] protocol. For example:\n\n```swift\n// Observe the full database\nlet observation = DatabaseRegionObservation(tracking: DatabaseRegion.fullDatabase)\nlet observer = try observation.start(in: dbQueue) { (db: Database) in\n    print("Database was changed")\n}\n```\n\n\n### DatabaseRegionObservation Use Cases\n\n**There are very few use cases for DatabaseRegionObservation**.\n\nFor example:\n\n- One needs to write in the database after an impactful transaction.\n\n- One needs to synchronize the content of the database file with some external resources, like other files, or system sensors like CLRegion monitoring.\n\n- On iOS, one needs to process a database transaction before the operating system had any opportunity to put the application in the suspended state.\n\n- One want to build a [database snapshot](#database-snapshots) with a guaranteed snapshot content.\n\nOutside of those use cases, it is much likely *wrong* to use a DatabaseRegionObservation. Please check other [Database Observation](#database-changes-observation) options.\n\n\n### DatabaseRegionObservation.extent\n\nThe `extent` property lets you specify the duration of the observation. See [Observation Extent](#observation-extent) for more details:\n\n```swift\n// This observation lasts until the database connection is closed\nvar observation = DatabaseRegionObservation...\nobservation.extent = .databaseLifetime\n_ = try observation.start(in: dbQueue) { db in ... }\n```\n\nThe default extent is `.observerLifetime`: the observation stops when the observer returned by `start` is deallocated.\n\nRegardless of the extent of an observation, you can always stop observation with the `remove(transactionObserver:)` method:\n\n```swift\n// Start\nlet observer = try observation.start(in: dbQueue) { db in ... }\n\n// Stop\ndbQueue.remove(transactionObserver: observer)\n```\n\n\n## TransactionObserver Protocol\n\nThe `TransactionObserver` protocol lets you **observe individual database changes and transactions**:\n\n```swift\nprotocol TransactionObserver : class {\n    /// Notifies a database change:\n    /// - event.kind (insert, update, or delete)\n    /// - event.tableName\n    /// - event.rowID\n    ///\n    /// For performance reasons, the event is only valid for the duration of\n    /// this method call. If you need to keep it longer, store a copy:\n    /// event.copy().\n    func databaseDidChange(with event: DatabaseEvent)\n    \n    /// Filters the database changes that should be notified to the\n    /// `databaseDidChange(with:)` method.\n    func observes(eventsOfKind eventKind: DatabaseEventKind) -> Bool\n    \n    /// An opportunity to rollback pending changes by throwing an error.\n    func databaseWillCommit() throws\n    \n    /// Database changes have been committed.\n    func databaseDidCommit(_ db: Database)\n    \n    /// Database changes have been rollbacked.\n    func databaseDidRollback(_ db: Database)\n}\n```\n\n- [Activate a Transaction Observer](#activate-a-transaction-observer)\n- [Database Changes And Transactions](#database-changes-and-transactions)\n- [Filtering Database Events](#filtering-database-events)\n- [Observation Extent](#observation-extent)\n- [DatabaseRegion]\n- [Support for SQLite Pre-Update Hooks](#support-for-sqlite-pre-update-hooks)\n\n\n### Activate a Transaction Observer\n\n**To activate a transaction observer, add it to the database queue or pool:**\n\n```swift\nlet observer = MyObserver()\ndbQueue.add(transactionObserver: observer)\n```\n\nBy default, database holds weak references to its transaction observers: they are not retained, and stop getting notifications after they are deallocated. See [Observation Extent](#observation-extent) for more options.\n\n\n### Database Changes And Transactions\n\n**A transaction observer is notified of all database changes**: inserts, updates and deletes. This includes indirect changes triggered by ON DELETE and ON UPDATE actions associated to [foreign keys](https://www.sqlite.org/foreignkeys.html#fk_actions), and [SQL triggers](https://www.sqlite.org/lang_createtrigger.html).\n\n> :point_up: **Note**: the changes that are not notified are changes to internal system tables (such as `sqlite_master`), changes to [`WITHOUT ROWID`](https://www.sqlite.org/withoutrowid.html) tables, and the deletion of duplicate rows triggered by [`ON CONFLICT REPLACE`](https://www.sqlite.org/lang_conflict.html) clauses (this last exception might change in a future release of SQLite).\n\nNotified changes are not actually written to disk until the [transaction](#transactions-and-savepoints) commits, and the `databaseDidCommit` callback is called. On the other side, `databaseDidRollback` confirms their invalidation:\n\n```swift\ntry dbQueue.write { db in\n    try db.execute(sql: "INSERT ...") // 1. didChange\n    try db.execute(sql: "UPDATE ...") // 2. didChange\n}                                     // 3. willCommit, 4. didCommit\n\ntry dbQueue.inTransaction { db in\n    try db.execute(sql: "INSERT ...") // 1. didChange\n    try db.execute(sql: "UPDATE ...") // 2. didChange\n    return .rollback                  // 3. didRollback\n}\n\ntry dbQueue.write { db in\n    try db.execute(sql: "INSERT ...") // 1. didChange\n    throw SomeError()\n}                                     // 2. didRollback\n```\n\nDatabase statements that are executed outside of any transaction do not drop off the radar:\n\n```swift\ntry dbQueue.inDatabase { db in\n    try db.execute(sql: "INSERT ...") // 1. didChange, 2. willCommit, 3. didCommit\n    try db.execute(sql: "UPDATE ...") // 4. didChange, 5. willCommit, 6. didCommit\n}\n```\n\nChanges that are on hold because of a [savepoint](https://www.sqlite.org/lang_savepoint.html) are only notified after the savepoint has been released. This makes sure that notified events are only events that have an opportunity to be committed:\n\n```swift\ntry dbQueue.inTransaction { db in\n    try db.execute(sql: "INSERT ...")            // 1. didChange\n    \n    try db.execute(sql: "SAVEPOINT foo")\n    try db.execute(sql: "UPDATE ...")            // delayed\n    try db.execute(sql: "UPDATE ...")            // delayed\n    try db.execute(sql: "RELEASE SAVEPOINT foo") // 2. didChange, 3. didChange\n    \n    try db.execute(sql: "SAVEPOINT foo")\n    try db.execute(sql: "UPDATE ...")            // not notified\n    try db.execute(sql: "ROLLBACK TO SAVEPOINT foo")\n    \n    return .commit                               // 4. willCommit, 5. didCommit\n}\n```\n\n\n**Eventual errors** thrown from `databaseWillCommit` are exposed to the application code:\n\n```swift\ndo {\n    try dbQueue.inTransaction { db in\n        ...\n        return .commit           // 1. willCommit (throws), 2. didRollback\n    }\n} catch {\n    // 3. The error thrown by the transaction observer.\n}\n```\n\n> :point_up: **Note**: all callbacks are called in a protected dispatch queue, and serialized with all database updates.\n>\n> :point_up: **Note**: the databaseDidChange(with:) and databaseWillCommit() callbacks must not touch the SQLite database. This limitation does not apply to databaseDidCommit and databaseDidRollback which can use their database argument.\n\n\n[DatabaseRegionObservation], [ValueObservation], [GRDBCombine], and [RxGRDB] are all based on the TransactionObserver protocol.\n\nSee also [TableChangeObserver.swift](https://gist.github.com/groue/2e21172719e634657dfd), which shows a transaction observer that notifies of modified database tables with NSNotificationCenter.\n\n\n### Filtering Database Events\n\n**Transaction observers can avoid being notified of database changes they are not interested in.**\n\nThe filtering happens in the `observes(eventsOfKind:)` method, which tells whether the observer wants notification of specific kinds of changes, or not. For example, here is how an observer can focus on the changes that happen on the "player" database table:\n\n```swift\nclass PlayerObserver: TransactionObserver {\n    func observes(eventsOfKind eventKind: DatabaseEventKind) -> Bool {\n        // Only observe changes to the "player" table.\n        return eventKind.tableName == "player"\n    }\n    \n    func databaseDidChange(with event: DatabaseEvent) {\n        // This method is only called for changes that happen to\n        // the "player" table.\n    }\n}\n```\n\nGenerally speaking, the `observes(eventsOfKind:)` method can distinguish insertions from deletions and updates, and is also able to inspect the columns that are about to be changed:\n\n```swift\nclass PlayerScoreObserver: TransactionObserver {\n    func observes(eventsOfKind eventKind: DatabaseEventKind) -> Bool {\n        // Only observe changes to the "score" column of the "player" table.\n        switch eventKind {\n        case .insert(let tableName):\n            return tableName == "player"\n        case .delete(let tableName):\n            return tableName == "player"\n        case .update(let tableName, let columnNames):\n            return tableName == "player" && columnNames.contains("score")\n        }\n    }\n}\n```\n\nWhen the `observes(eventsOfKind:)` method returns false for all event kinds, the observer is still notified of commits and rollbacks:\n\n```swift\nclass PureTransactionObserver: TransactionObserver {\n    func observes(eventsOfKind eventKind: DatabaseEventKind) -> Bool {\n        // Ignore all individual changes\n        return false\n    }\n    \n    func databaseDidChange(with event: DatabaseEvent) { /* Never called */ }\n    func databaseWillCommit() throws { /* Called before commit */ }\n    func databaseDidRollback(_ db: Database) { /* Called on rollback */ }\n    func databaseDidCommit(_ db: Database) { /* Called on commit */ }\n}\n```\n\nFor more information about event filtering, see [DatabaseRegion].\n\n\n### Observation Extent\n\n**You can specify how long an observer is notified of database changes and transactions.**\n\nThe `remove(transactionObserver:)` method explicitly stops notifications, at any time:\n\n```swift\n// From a database queue or pool:\ndbQueue.remove(transactionObserver: observer)\n\n// From a database connection:\ndbQueue.inDatabase { db in\n    db.remove(transactionObserver: observer)\n}\n```\n\nAlternatively, use the `extent` parameter of the `add(transactionObserver:extent:)` method:\n\n```swift\nlet observer = MyObserver()\n\n// On a database queue or pool:\ndbQueue.add(transactionObserver: observer) // default extent\ndbQueue.add(transactionObserver: observer, extent: .observerLifetime)\ndbQueue.add(transactionObserver: observer, extent: .nextTransaction)\ndbQueue.add(transactionObserver: observer, extent: .databaseLifetime)\n\n// On a database connection:\ndbQueue.inDatabase { db in\n    db.add(transactionObserver: ...)\n}\n```\n\n- The default extent is `.observerLifetime`: the database holds a weak reference to the observer, and the observation automatically ends when the observer is deallocated. Meanwhile, observer is notified of all changes and transactions.\n\n- `.nextTransaction` activates the observer until the current or next transaction completes. The database keeps a strong reference to the observer until its `databaseDidCommit` or `databaseDidRollback` method is eventually called. Hereafter the observer won\'t get any further notification.\n\n- `.databaseLifetime` has the database retain and notify the observer until the database connection is closed.\n\nFinally, an observer may ignore all database changes until the end of the current transaction:\n\n```swift\nclass PlayerObserver: TransactionObserver {\n    var playerTableWasModified = false\n    \n    func observes(eventsOfKind eventKind: DatabaseEventKind) -> Bool {\n        return eventKind.tableName == "player"\n    }\n    \n    func databaseDidChange(with event: DatabaseEvent) {\n        playerTableWasModified = true\n        \n        // It is pointless to keep on tracking further changes:\n        stopObservingDatabaseChangesUntilNextTransaction()\n    }\n}\n```\n\nAfter `stopObservingDatabaseChangesUntilNextTransaction()`, the `databaseDidChange(with:)` method will not be notified of any change for the remaining duration of the current transaction. This helps GRDB optimize database observation.\n\n\n### DatabaseRegion\n\n**[DatabaseRegion](https://groue.github.io/GRDB.swift/docs/4.6/Structs/DatabaseRegion.html) is a type that helps observing changes in the results of a database [request](#requests)**.\n\nA request knows which database modifications can impact its results. It can communicate this information to [transaction observers](#transactionobserver-protocol) by the way of a DatabaseRegion.\n\nDatabaseRegion fuels, for example, [ValueObservation and DatabaseRegionObservation].\n\n**A region notifies *potential* changes, not *actual* changes in the results of a request.** A change is notified if and only if a statement has actually modified the tracked tables and columns by inserting, updating, or deleting a row.\n\nFor example, if you observe the region of `Player.select(max(Column("score")))`, then you\'ll get be notified of all changes performed on the `score` column of the `player` table (updates, insertions and deletions), even if they do not modify the value of the maximum score. However, you will not get any notification for changes performed on other database tables, or updates to other columns of the player table.\n\nFor more details, see the [reference](http://groue.github.io/GRDB.swift/docs/4.6/Structs/DatabaseRegion.html#/s:4GRDB14DatabaseRegionV10isModified2bySbAA0B5EventV_tF).\n\n\n#### The DatabaseRegionConvertible Protocol\n\n**DatabaseRegionConvertible** is a protocol for all types that can turn into a [DatabaseRegion]:\n\n```swift\nprotocol DatabaseRegionConvertible {\n    func databaseRegion(_ db: Database) throws -> DatabaseRegion\n}\n```\n\nAll [requests](#requests) adopt this protocol, and this allows them to be observed with [DatabaseRegionObservation] and [ValueObservation].\n\nUse this protocol when you want to encapsulate your complex requests in a dedicated type, and still profit from optimized observation APIs. See [`ValueObservation.tracking(_:fetch:)`](#valueobservationtracking_fetch) for more information.\n\n\n### Support for SQLite Pre-Update Hooks\n\nWhen SQLite is built with the SQLITE_ENABLE_PREUPDATE_HOOK option, TransactionObserverType gets an extra callback which lets you observe individual column values in the rows modified by a transaction:\n\n```swift\nprotocol TransactionObserverType : class {\n    #if SQLITE_ENABLE_PREUPDATE_HOOK\n    /// Notifies before a database change (insert, update, or delete)\n    /// with change information (initial / final values for the row\'s\n    /// columns).\n    ///\n    /// The event is only valid for the duration of this method call. If you\n    /// need to keep it longer, store a copy: event.copy().\n    func databaseWillChange(with event: DatabasePreUpdateEvent)\n    #endif\n}\n```\n\nThis extra API can be activated in two ways:\n\n1. Use the GRDB.swift CocoaPod with a custom compilation option, as below. It uses the system SQLite, which is compiled with SQLITE_ENABLE_PREUPDATE_HOOK support, but only on iOS 11.0+ (we don\'t know the minimum version of macOS, tvOS, watchOS):\n\n    ```ruby\n    pod \'GRDB.swift\'\n    platform :ios, \'11.0\' # or above\n    \n    post_install do |installer|\n      installer.pods_project.targets.select { |target| target.name == "GRDB.swift" }.each do |target|\n        target.build_configurations.each do |config|\n          # Enable extra GRDB APIs\n          config.build_settings[\'OTHER_SWIFT_FLAGS\'] = "$(inherited) -D SQLITE_ENABLE_PREUPDATE_HOOK"\n          # Enable extra SQLite APIs\n          config.build_settings[\'GCC_PREPROCESSOR_DEFINITIONS\'] = "$(inherited) GRDB_SQLITE_ENABLE_PREUPDATE_HOOK=1"\n        end\n      end\n    end\n    ```\n    \n    > :warning: **Warning**: make sure you use the right platform version! You will get runtime errors on devices with a lower version.\n    \n    > :point_up: **Note**: the `GRDB_SQLITE_ENABLE_PREUPDATE_HOOK=1` option in `GCC_PREPROCESSOR_DEFINITIONS` defines some C function prototypes that are lacking from the system `<sqlite3.h>` header. When Xcode eventually ships with an SDK that includes a complete header, you may get a compiler error about duplicate function definitions. When this happens, just remove this `GRDB_SQLITE_ENABLE_PREUPDATE_HOOK=1` option.\n    \n2. Use a [custom SQLite build] and activate the `SQLITE_ENABLE_PREUPDATE_HOOK` compilation option.\n\n\nEncryption\n==========\n\n**GRDB can encrypt your database with [SQLCipher](http://sqlcipher.net) v3.4+.**\n\nUse [CocoaPods](http://cocoapods.org/), and specify in your `Podfile`:\n\n```ruby\n# GRDB with SQLCipher 4\npod \'GRDB.swift/SQLCipher\'\npod \'SQLCipher\', \'~> 4.0\'\n\n# GRDB with SQLCipher 3\npod \'GRDB.swift/SQLCipher\'\npod \'SQLCipher\', \'~> 3.4\'\n```\n\n- [Creating or Opening an Encrypted Database](#creating-or-opening-an-encrypted-database)\n- [Changing the Passphrase of an Encrypted Database](#changing-the-passphrase-of-an-encrypted-database)\n- [Exporting a Database to an Encrypted Database](#exporting-a-database-to-an-encrypted-database)\n- [Security Considerations](#security-considerations)\n\n\n### Creating or Opening an Encrypted Database\n\n**You create and open an encrypted database** by providing a passphrase to your [database connection](#database-connections):\n\n```swift\nvar config = Configuration()\nconfig.prepareDatabase = { db in\n    try db.usePassphrase("secret")\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\nIt is also in `prepareDatabase` that you perform other [SQLCipher configuration steps](https://www.zetetic.net/sqlcipher/sqlcipher-api/) that must happen early in the lifetime of a SQLCipher connection. For example:\n\n```swift\nvar config = Configuration()\nconfig.prepareDatabase = { db in\n    try db.usePassphrase("secret")\n    try db.execute(sql: "PRAGMA cipher_page_size = ...")\n    try db.execute(sql: "PRAGMA kdf_iter = ...")\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\nWhen you want to open an existing SQLCipher 3 database with SQLCipher 4, you may want to run the `cipher_compatibility` pragma:\n\n```swift\n// Open an SQLCipher 3 database with SQLCipher 4\nvar config = Configuration()\nconfig.prepareDatabase = { db in\n    try db.usePassphrase("secret")\n    try db.execute(sql: "PRAGMA cipher_compatibility = 3")\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\nSee [SQLCipher 4.0.0 Release](https://www.zetetic.net/blog/2018/11/30/sqlcipher-400-release/) and [Upgrading to SQLCipher 4](https://discuss.zetetic.net/t/upgrading-to-sqlcipher-4/3283) for more information.\n\n\n### Changing the Passphrase of an Encrypted Database\n\n**You can change the passphrase** of an already encrypted database.\n\nWhen you use a [database queue](#database-queues), open the database with the old passphrase, and then apply the new passphrase:\n\n```swift\ntry dbQueue.write { db in\n    try db.changePassphrase("newSecret")\n}\n```\n\nWhen you use a [database pool](#database-pools), make sure that no concurrent read can happen by changing the passphrase within the `barrierWriteWithoutTransaction` block. You must also ensure all future reads open a new database connection by calling the `invalidateReadOnlyConnections` method:\n\n```swift\ntry dbPool.barrierWriteWithoutTransaction { db in\n    try db.changePassphrase("newSecret")\n    dbPool.invalidateReadOnlyConnections()\n}\n```\n\n> :point_up: **Note**: When an application wants to keep on using a database queue or pool after the passphrase has changed, it is responsible for providing the correct passphrase to the `usePassphrase` method called in the database preparation function. Consider:\n>\n> ```swift\n> // WRONG: this won\'t work across a passphrase change\n> let passphrase = try getPassphrase()\n> var config = Configuration()\n> config.prepareDatabase = { db in\n>     try db.usePassphrase(passphrase)\n> }\n>\n> // CORRECT: get the latest passphrase when it is needed\n> var config = Configuration()\n> config.prepareDatabase = { db in\n>     let passphrase = try getPassphrase()\n>     try db.usePassphrase(passphrase)\n> }\n> ```\n\n> :point_up: **Note**: The `DatabasePool.barrierWriteWithoutTransaction` method does not prevent [database snapshots](#database-snapshots) from accessing the database during the passphrase change, or after the new passphrase has been applied to the database. Those database accesses may throw errors. Applications should provide their own mechanism for invalidating open snapshots before the passphrase is changed.\n\n> :point_up: **Note**: Instead of changing the passphrase "in place" as described here, you can also export the database in a new encrypted database that uses the new passphrase. See [Exporting a Database to an Encrypted Database](#exporting-a-database-to-an-encrypted-database).\n\n\n### Exporting a Database to an Encrypted Database\n\nProviding a passphrase won\'t encrypt a clear-text database that already exists, though. SQLCipher can\'t do that, and you will get an error instead: `SQLite error 26: file is encrypted or is not a database`.\n\nInstead, create a new encrypted database, at a distinct location, and export the content of the existing database. This can both encrypt a clear-text database, or change the passphrase of an encrypted databaase.\n\nThe technique to do that is [documented](https://discuss.zetetic.net/t/how-to-encrypt-a-plaintext-sqlite-database-to-use-sqlcipher-and-avoid-file-is-encrypted-or-is-not-a-database-errors/868/1) by SQLCipher.\n\nWith GRDB, it gives:\n\n```swift\n// The existing database\nlet existingDBQueue = try DatabaseQueue(path: "/path/to/existing.db")\n\n// The new encrypted database, at some distinct location:\nvar config = Configuration()\nconfig.prepareDatabase = { db in\n    try db.usePassphrase("secret")\n}\nlet newDBQueue = try DatabaseQueue(path: "/path/to/new.db", configuration: config)\n\ntry existingDBQueue.inDatabase { db in\n    try db.execute(\n        sql: """\n            ATTACH DATABASE ? AS encrypted KEY ?;\n            SELECT sqlcipher_export(\'encrypted\');\n            DETACH DATABASE encrypted;\n            """,\n        arguments: [newDBQueue.path, "secret"])\n}\n\n// Now the export is completed, and the existing database can be deleted.\n```\n\n\n### Security Considerations\n\n#### Managing the lifetime of the passphrase string\n\nIt is recommended to avoid keeping the passphrase in memory longer than necessary. To do this, make sure you load the passphrase from inside the `prepareDatabase` function:\n\n```swift\n// NOT RECOMMENDED: this keeps the passphrase in memory longer than necessary\nlet passphrase = try getPassphrase()\nvar config = Configuration()\nconfig.prepareDatabase = { db in\n    try db.usePassphrase(passphrase)\n}\n\n// RECOMMENDED: only load the passphrase when it is needed\nvar config = Configuration()\nconfig.prepareDatabase = { db in\n    let passphrase = try getPassphrase()\n    try db.usePassphrase(passphrase)\n}\n```\n\nThis technique manages the lifetime of the passphrase string. Some demanding users will want to go further, and manage the lifetime of the raw passphrase bytes. See below.\n\n\n#### Managing the lifetime of the passphrase bytes\n\nGRDB offers convenience methods for providing the database passphrases as Swift strings: `usePassphrase(_:)` and `changePassphrase(_:)`. Those methods don\'t keep the passphrase String in memory longer than necessary. But they are as secure as the standard String type: the lifetime of actual passphrase bytes in memory is not under control.\n\nWhen you want to precisely manage the passphrase bytes, talk directly to SQLCipher, using its raw C functions.\n\nFor example:\n\n```swift\nimport GRDB\nimport SQLCipher\n\nvar config = Configuration()\nconfig.prepareDatabase = { db in\n    ... // Carefully load passphrase bytes\n    let code = sqlite3_key(db.sqliteConnection, /* passphrase bytes */)\n    ... // Carefully dispose passphrase bytes\n    guard code == SQLITE_OK else {\n        throw DatabaseError(\n            resultCode: ResultCode(rawValue: code), \n            message: db.lastErrorMessage)\n    }\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\n#### Passphrase availability vs. Database availability\n\nWhen the passphrase is securely stored in the system keychain, your application can protect it using the [`kSecAttrAccessible`](https://developer.apple.com/documentation/security/ksecattraccessible) attribute.\n\nSuch protection prevents GRDB from creating SQLite connections when the passphrase is not available:\n\n```swift\nvar config = Configuration()\nconfig.prepareDatabase = { db in\n    let passphrase = try loadPassphraseFromSystemKeychain()\n    try db.usePassphrase(passphrase)\n}\n\n// Success if and only if the passphrase is available\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\nFor the same reason, [database pools](#database-pools), which open SQLite connections on demand, may fail at any time as soon as the passphrase becomes unavailable:\n\n```swift\n// Success if and only if the passphrase is available\nlet dbPool = try DatabasePool(path: dbPath, configuration: config)\n\n// May fail if passphrase has turned unavailable\ntry dbPool.read { ... }\n\n// May trigger value observation failure if passphrase has turned unavailable\ntry dbPool.write { ... }\n```\n\nBecause DatabasePool maintains a pool of long-lived SQLite connections, some database accesses will use an existing connection, and succeed. And some other database accesses will fail, as soon as the pool wants to open a new connection. It is impossible to predict which accesses will succeed or fail.\n\nFor the same reason, a database queue, which also maintains a long-lived SQLite connection, will remain available even after the passphrase has turned unavailable.\n\nApplications are thus responsible for protecting database accesses when the passphrase is unavailable. To this end, they can use [Data Protection](#data-protection). They can also destroy their instances of database queue or pool when the passphrase becomes unavailable.\n\n\n## Backup\n\n**You can backup (copy) a database into another.**\n\nBackups can for example help you copying an in-memory database to and from a database file when you implement NSDocument subclasses.\n\n```swift\nlet source: DatabaseQueue = ...      // or DatabasePool\nlet destination: DatabaseQueue = ... // or DatabasePool\ntry source.backup(to: destination)\n```\n\nThe `backup` method blocks the current thread until the destination database contains the same contents as the source database.\n\nWhen the source is a [database pool](#database-pools), concurrent writes can happen during the backup. Those writes may, or may not, be reflected in the backup, but they won\'t trigger any error.\n\n\n## Avoiding SQL Injection\n\nSQL injection is a technique that lets an attacker nuke your database.\n\n> ![XKCD: Exploits of a Mom](https://imgs.xkcd.com/comics/exploits_of_a_mom.png)\n>\n> https://xkcd.com/327/\n\nHere is an example of code that is vulnerable to SQL injection:\n\n```swift\n// BAD BAD BAD\nlet id = 1\nlet name = textField.text\ntry dbQueue.write { db in\n    try db.execute(sql: "UPDATE students SET name = \'\\(name)\' WHERE id = \\(id)")\n}\n```\n\nIf the user enters a funny string like `Robert\'; DROP TABLE students; --`, SQLite will see the following SQL, and drop your database table instead of updating a name as intended:\n\n```sql\nUPDATE students SET name = \'Robert\';\nDROP TABLE students;\n--\' WHERE id = 1\n```\n\nTo avoid those problems, **never embed raw values in your SQL queries**. The only correct technique is to provide [arguments](#executing-updates) to your raw SQL queries:\n\n```swift\nlet name = textField.text\ntry dbQueue.write { db in\n    // Good\n    try db.execute(\n        sql: "UPDATE students SET name = ? WHERE id = ?",\n        arguments: [name, id])\n    \n    // Just as good\n    try db.execute(\n        sql: "UPDATE students SET name = :name WHERE id = :id",\n        arguments: ["name": name, "id": id])\n}\n```\n\nWhen you use [records](#records) and the [query interface](#the-query-interface), GRDB always prevents SQL injection for you:\n\n```swift\nlet id = 1\nlet name = textField.text\ntry dbQueue.write { db in\n    if var student = try Student.fetchOne(db, key: id) {\n        student.name = name\n        try student.update(db)\n    }\n}\n```\n\n\n## Error Handling\n\nGRDB can throw [DatabaseError](#databaseerror), [PersistenceError](#persistenceerror), or crash your program with a [fatal error](#fatal-errors).\n\nConsidering that a local database is not some JSON loaded from a remote server, GRDB focuses on **trusted databases**. Dealing with [untrusted databases](#how-to-deal-with-untrusted-inputs) requires extra care.\n\n- [DatabaseError](#databaseerror)\n- [PersistenceError](#persistenceerror)\n- [Fatal Errors](#fatal-errors)\n- [How to Deal with Untrusted Inputs](#how-to-deal-with-untrusted-inputs)\n- [Error Log](#error-log)\n\n\n### DatabaseError\n\n**DatabaseError** are thrown on SQLite errors:\n\n```swift\ndo {\n    try db.execute(\n        sql: "INSERT INTO pet (masterId, name) VALUES (?, ?)",\n        arguments: [1, "Bobby"])\n} catch let error as DatabaseError {\n    // The SQLite error code: 19 (SQLITE_CONSTRAINT)\n    error.resultCode\n    \n    // The extended error code: 787 (SQLITE_CONSTRAINT_FOREIGNKEY)\n    error.extendedResultCode\n    \n    // The eventual SQLite message: FOREIGN KEY constraint failed\n    error.message\n    \n    // The eventual erroneous SQL query\n    // "INSERT INTO pet (masterId, name) VALUES (?, ?)"\n    error.sql\n    \n    // Full error description:\n    // "SQLite error 19 with statement `INSERT INTO pet (masterId, name)\n    //  VALUES (?, ?)` arguments [1, "Bobby"]: FOREIGN KEY constraint failed""\n    error.description\n}\n```\n\n**SQLite uses codes to distinguish between various errors:**\n\n```swift\ndo {\n    try ...\n} catch let error as DatabaseError where error.extendedResultCode == .SQLITE_CONSTRAINT_FOREIGNKEY {\n    // foreign key constraint error\n} catch let error as DatabaseError where error.resultCode == .SQLITE_CONSTRAINT {\n    // any other constraint error\n} catch let error as DatabaseError {\n    // any other database error\n}\n```\n\nIn the example above, `error.extendedResultCode` is a precise [extended result code](https://www.sqlite.org/rescode.html#extended_result_code_list), and `error.resultCode` is a less precise [primary result code](https://www.sqlite.org/rescode.html#primary_result_code_list). Extended result codes are refinements of primary result codes, as `SQLITE_CONSTRAINT_FOREIGNKEY` is to `SQLITE_CONSTRAINT`, for example. See [SQLite result codes](https://www.sqlite.org/rescode.html) for more information.\n\nAs a convenience, extended result codes match their primary result code in a switch statement:\n\n```swift\ndo {\n    try ...\n} catch let error as DatabaseError {\n    switch error.extendedResultCode {\n    case ResultCode.SQLITE_CONSTRAINT_FOREIGNKEY:\n        // foreign key constraint error\n    case ResultCode.SQLITE_CONSTRAINT:\n        // any other constraint error\n    default:\n        // any other database error\n    }\n}\n```\n\n> :warning: **Warning**: SQLite has progressively introduced extended result codes accross its versions. The [SQLite release notes](http://www.sqlite.org/changes.html) are unfortunately not quite clear about that: write your handling of extended result codes with care.\n\n\n### PersistenceError\n\n**PersistenceError** is thrown by the [PersistableRecord] protocol, in a single case: when the `update` method could not find any row to update:\n\n```swift\ndo {\n    try player.update(db)\n} catch let PersistenceError.recordNotFound(databaseTableName: table, key: key) {\n    print("Key \\(key) was not found in table \\(table).")\n}\n```\n\n\n### Fatal Errors\n\n**Fatal errors notify that the program, or the database, has to be changed.**\n\nThey uncover programmer errors, false assumptions, and prevent misuses. Here are a few examples:\n\n- **The code asks for a non-optional value, when the database contains NULL:**\n    \n    ```swift\n    // fatal error: could not convert NULL to String.\n    let name: String = row["name"]\n    ```\n    \n    Solution: fix the contents of the database, use [NOT NULL constraints](#create-tables), or load an optional:\n    \n    ```swift\n    let name: String? = row["name"]\n    ```\n\n- **Conversion from database value to Swift type fails:**\n    \n    ```swift\n    // fatal error: could not convert "Mom\xe2\x80\x99s birthday" to Date.\n    let date: Date = row["date"]\n    \n    // fatal error: could not convert "" to URL.\n    let url: URL = row["url"]\n    ```\n    \n    Solution: fix the contents of the database, or use [DatabaseValue](#databasevalue) to handle all possible cases:\n    \n    ```swift\n    let dbValue: DatabaseValue = row["date"]\n    if dbValue.isNull {\n        // Handle NULL\n    } else if let date = Date.fromDatabaseValue(dbValue) {\n        // Handle valid date\n    } else {\n        // Handle invalid date\n    }\n    ```\n\n- **The database can\'t guarantee that the code does what it says:**\n\n    ```swift\n    // fatal error: table player has no unique index on column email\n    try Player.deleteOne(db, key: ["email": "arthur@example.com"])\n    ```\n    \n    Solution: add a unique index to the player.email column, or use the `deleteAll` method to make it clear that you may delete more than one row:\n    \n    ```swift\n    try Player.filter(Column("email") == "arthur@example.com").deleteAll(db)\n    ```\n\n- **Database connections are not reentrant:**\n    \n    ```swift\n    // fatal error: Database methods are not reentrant.\n    dbQueue.write { db in\n        dbQueue.write { db in\n            ...\n        }\n    }\n    ```\n    \n    Solution: avoid reentrancy, and instead pass a database connection along.\n\n\n### How to Deal with Untrusted Inputs\n\nLet\'s consider the code below:\n\n```swift\nlet sql = "SELECT ..."\n\n// Some untrusted arguments for the query\nlet arguments: [String: Any] = ...\nlet rows = try Row.fetchCursor(db, sql: sql, arguments: StatementArguments(arguments))\n\nwhile let row = try rows.next() {\n    // Some untrusted database value:\n    let date: Date? = row[0]\n}\n```\n\nIt has two opportunities to throw fatal errors:\n\n- **Untrusted arguments**: The dictionary may contain values that do not conform to the [DatabaseValueConvertible protocol](#values), or may miss keys required by the statement.\n- **Untrusted database content**: The row may contain a non-null value that can\'t be turned into a date.\n\nIn such a situation, you can still avoid fatal errors by exposing and handling each failure point, one level down in the GRDB API:\n\n```swift\n// Untrusted arguments\nif let arguments = StatementArguments(arguments) {\n    let statement = try db.makeSelectStatement(sql: sql)\n    try statement.validate(arguments: arguments)\n    statement.unsafeSetArguments(arguments)\n    \n    var cursor = try Row.fetchCursor(statement)\n    while let row = try iterator.next() {\n        // Untrusted database content\n        let dbValue: DatabaseValue = row[0]\n        if dbValue.isNull {\n            // Handle NULL\n        if let date = Date.fromDatabaseValue(dbValue) {\n            // Handle valid date\n        } else {\n            // Handle invalid date\n        }\n    }\n}\n```\n\nSee [prepared statements](#prepared-statements) and [DatabaseValue](#databasevalue) for more information.\n\n\n### Error Log\n\n**SQLite can be configured to invoke a callback function containing an error code and a terse error message whenever anomalies occur.**\n\nThis global error callback must be configured early in the lifetime of your application:\n\n```swift\nDatabase.logError = { (resultCode, message) in\n    NSLog("%@", "SQLite error \\(resultCode): \\(message)")\n}\n```\n\n> :warning: **Warning**: Database.logError must be set before any database connection is opened. This includes the connections that your application opens with GRDB, but also connections opened by other tools, such as third-party libraries. Setting it after a connection has been opened is an SQLite misuse, and has no effect.\n\nSee [The Error And Warning Log](https://sqlite.org/errlog.html) for more information.\n\n\n## Unicode\n\nSQLite lets you store unicode strings in the database.\n\nHowever, SQLite does not provide any unicode-aware string transformations or comparisons.\n\n\n### Unicode functions\n\nThe `UPPER` and `LOWER` built-in SQLite functions are not unicode-aware:\n\n```swift\n// "J\xc3\xa9R\xc3\xb4ME"\ntry String.fetchOne(db, sql: "SELECT UPPER(\'J\xc3\xa9r\xc3\xb4me\')")\n```\n\nGRDB extends SQLite with [SQL functions](#custom-sql-functions-and-aggregates) that call the Swift built-in string functions `capitalized`, `lowercased`, `uppercased`, `localizedCapitalized`, `localizedLowercased` and `localizedUppercased`:\n\n```swift\n// "J\xc3\x89R\xc3\x94ME"\nlet uppercased = DatabaseFunction.uppercase\ntry String.fetchOne(db, sql: "SELECT \\(uppercased.name)(\'J\xc3\xa9r\xc3\xb4me\')")\n```\n\nThose unicode-aware string functions are also readily available in the [query interface](#sql-functions):\n\n```swift\nPlayer.select(nameColumn.uppercased)\n```\n\n\n### String Comparison\n\nSQLite compares strings in many occasions: when you sort rows according to a string column, or when you use a comparison operator such as `=` and `<=`.\n\nThe comparison result comes from a *collating function*, or *collation*. SQLite comes with three built-in collations that do not support Unicode: [binary, nocase, and rtrim](https://www.sqlite.org/datatype3.html#collation).\n\nGRDB comes with five extra collations that leverage unicode-aware comparisons based on the standard Swift String comparison functions and operators:\n\n- `unicodeCompare` (uses the built-in `<=` and `==` Swift operators)\n- `caseInsensitiveCompare`\n- `localizedCaseInsensitiveCompare`\n- `localizedCompare`\n- `localizedStandardCompare`\n\nA collation can be applied to a table column. All comparisons involving this column will then automatically trigger the comparison function:\n    \n```swift\ntry db.create(table: "player") { t in\n    // Guarantees case-insensitive email unicity\n    t.column("email", .text).unique().collate(.nocase)\n    \n    // Sort names in a localized case insensitive way\n    t.column("name", .text).collate(.localizedCaseInsensitiveCompare)\n}\n\n// Players are sorted in a localized case insensitive way:\nlet players = try Player.order(nameColumn).fetchAll(db)\n```\n\n> :warning: **Warning**: SQLite *requires* host applications to provide the definition of any collation other than binary, nocase and rtrim. When a database file has to be shared or migrated to another SQLite library of platform (such as the Android version of your application), make sure you provide a compatible collation.\n\nIf you can\'t or don\'t want to define the comparison behavior of a column (see warning above), you can still use an explicit collation in SQL requests and in the [query interface](#the-query-interface):\n\n```swift\nlet collation = DatabaseCollation.localizedCaseInsensitiveCompare\nlet players = try Player.fetchAll(db,\n    sql: "SELECT * FROM player ORDER BY name COLLATE \\(collation.name))")\nlet players = try Player.order(nameColumn.collating(collation)).fetchAll(db)\n```\n\n\n**You can also define your own collations**:\n\n```swift\nlet collation = DatabaseCollation("customCollation") { (lhs, rhs) -> NSComparisonResult in\n    // return the comparison of lhs and rhs strings.\n}\ndbQueue.add(collation: collation) // Or dbPool.add(collation: ...)\n```\n\n\n## Memory Management\n\nBoth SQLite and GRDB use non-essential memory that help them perform better.\n\nYou can reclaim this memory with the `releaseMemory` method:\n\n```swift\n// Release as much memory as possible.\ndbQueue.releaseMemory()\ndbPool.releaseMemory()\n```\n\nThis method blocks the current thread until all current database accesses are completed, and the memory collected.\n\n\n### Memory Management on iOS\n\n**The iOS operating system likes applications that do not consume much memory.**\n\n[Database queues](#database-queues) and [pools](#database-pools) can call the `releaseMemory` method for you, when application receives memory warnings, and when application enters background: call the `setupMemoryManagement` method after creating the queue or pool instance:\n\n```\nlet dbQueue = try DatabaseQueue(...)\ndbQueue.setupMemoryManagement(in: UIApplication.shared)\n```\n\n\n## Data Protection\n\n[Data Protection](https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/StrategiesforImplementingYourApp/StrategiesforImplementingYourApp.html#//apple_ref/doc/uid/TP40007072-CH5-SW21) lets you protect files so that they are encrypted and unavailable until the device is unlocked.\n\nData protection can be enabled [globally](https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW30) for all files created by an application.\n\nYou can also explicitly protect a database, by configuring its enclosing *directory*. This will not only protect the database file, but also all [temporary files](https://www.sqlite.org/tempfiles.html) created by SQLite (including the persistent `.shm` and `.wal` files created by [database pools](#database-pools)).\n\nFor example, to explicitly use [complete](https://developer.apple.com/reference/foundation/fileprotectiontype/1616200-complete) protection:\n\n```swift\n// Paths\nlet fileManager = FileManager.default\nlet directoryURL = try fileManager\n    .url(for: .applicationSupportDirectory, in: .userDomainMask, appropriateFor: nil, create: true)\n    .appendingPathComponent("database", isDirectory: true)\nlet databaseURL = directoryURL.appendingPathComponent("db.sqlite")\n\n// Create directory if needed\nvar isDirectory: ObjCBool = false\nif !fileManager.fileExists(atPath: directoryURL.path, isDirectory: &isDirectory) {\n    try fileManager.createDirectory(atPath: directoryURL.path, withIntermediateDirectories: false)\n} else if !isDirectory.boolValue {\n    throw NSError(domain: NSCocoaErrorDomain, code: NSFileWriteFileExistsError, userInfo: nil)\n}\n\n// Enable data protection\ntry fileManager.setAttributes([.protectionKey : FileProtectionType.complete], ofItemAtPath: directoryURL.path)\n\n// Open database\nlet dbQueue = try DatabaseQueue(path: databaseURL.path)\n```\n\nWhen a database is protected, an application that runs in the background on a locked device won\'t be able to read or write from it. Instead, it will get [DatabaseError](#error-handling) with code [`SQLITE_IOERR`](https://www.sqlite.org/rescode.html#ioerr) (10) "disk I/O error", or [`SQLITE_AUTH`](https://www.sqlite.org/rescode.html#auth) (23) "not authorized".\n\nYou can catch those errors and wait for [UIApplicationDelegate.applicationProtectedDataDidBecomeAvailable(_:)](https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623044-applicationprotecteddatadidbecom) or [UIApplicationProtectedDataDidBecomeAvailable](https://developer.apple.com/reference/uikit/uiapplicationprotecteddatadidbecomeavailable) notification in order to retry the failed database operation.\n\n\n## Concurrency\n\n- [Guarantees and Rules](#guarantees-and-rules)\n- [Differences between Database Queues and Pools](#differences-between-database-queues-and-pools)\n- [Advanced DatabasePool](#advanced-databasepool)\n- [Database Snapshots](#database-snapshots)\n- [DatabaseWriter and DatabaseReader Protocols](#databasewriter-and-databasereader-protocols)\n- [Asynchronous APIs](#asynchronous-apis)\n- [Unsafe Concurrency APIs](#unsafe-concurrency-apis)\n- [Dealing with External Connections](#dealing-with-external-connections)\n\n\n### Guarantees and Rules\n\nGRDB ships with three concurrency modes:\n\n- [DatabaseQueue](#database-queues) opens a single database connection, and serializes all database accesses.\n- [DatabasePool](#database-pools) manages a pool of several database connections, and allows concurrent reads and writes.\n- [DatabaseSnapshot](#database-snapshots) opens a single read-only database connection on an unchanging database content, and (currently) serializes all database accesses\n\n**All foster application safety**: regardless of the concurrency mode you choose, GRDB provides you with the same guarantees, as long as you follow three rules.\n\n- :bowtie: **Guarantee 1: writes are always serialized**. At every moment, there is no more than a single thread that is writing into the database.\n    \n    > Database writes always happen in a unique serial dispatch queue, named the *writer protected dispatch queue*.\n\n- :bowtie: **Guarantee 2: reads are always isolated**. This means that they are guaranteed an immutable view of the database, and that you can perform subsequent fetches without fearing eventual concurrent writes to mess with your application logic:\n    \n    ```swift\n    try dbPool.read { db in // or dbQueue.read\n        // Guaranteed to be equal\n        let count1 = try Player.fetchCount(db)\n        let count2 = try Player.fetchCount(db)\n    }\n    ```\n    \n    > In [database queues](#database-queues), reads happen in the same protected dispatch queue as writes: isolation is just a consequence of the serialization of database accesses\n    >\n    > [Database pools](#database-pools) and [snapshots](#database-snapshots) both use the "snapshot isolation" made possible by SQLite\'s WAL mode (see [Isolation In SQLite](https://sqlite.org/isolation.html)).\n\n- :bowtie: **Guarantee 3: requests don\'t fail**, unless a database constraint violation, a [programmer mistake](#error-handling), or a very low-level issue such as a disk error or an unreadable database file. GRDB grants *correct* use of SQLite, and particularly avoids locking errors and other SQLite misuses.\n\nThose guarantees hold as long as you follow three rules:\n\n- :point_up: **Rule 1**: Have a unique instance of DatabaseQueue or DatabasePool connected to any database file.\n    \n    This means that opening a new connection each time you access the database is a bad idea. Do share a single connection instead.\n    \n    See the [Demo Application] for a sample app that sets up a single database queue that is available throughout the application.\n    \n    If there are several instances of database queues or pools that write in the same database, a multi-threaded application will eventually face "database is locked" errors. See [Dealing with External Connections](#dealing-with-external-connections).\n    \n    ```swift\n    // SAFE CONCURRENCY\n    func fetchCurrentUser(_ db: Database) throws -> User? {\n        return try User.fetchOne(db)\n    }\n    // dbQueue is a singleton defined somewhere in your app\n    let user = try dbQueue.read { db in // or dbPool.read\n        try fetchCurrentUser(db)\n    }\n    \n    // UNSAFE CONCURRENCY\n    // This method fails when some other thread is currently writing into\n    // the database.\n    func currentUser() throws -> User? {\n        let dbQueue = try DatabaseQueue(...)\n        return try dbQueue.read { db in\n            try User.fetchOne(db)\n        }\n    }\n    let user = try currentUser()\n    ```\n    \n- :point_up: **Rule 2**: Group related statements within a single call to a DatabaseQueue or DatabasePool database access method (or use [snapshots](#database-snapshots)).\n    \n    Database access methods isolate your groups of related statements against eventual database updates performed by other threads, and guarantee a consistent view of the database. This isolation is only guaranteed *inside* the closure argument of those methods. Two consecutive calls *do not* guarantee isolation:\n    \n    ```swift\n    // SAFE CONCURRENCY\n    try dbPool.read { db in  // or dbQueue.read\n        // Guaranteed to be equal:\n        let count1 = try Place.fetchCount(db)\n        let count2 = try Place.fetchCount(db)\n    }\n    \n    // UNSAFE CONCURRENCY\n    // Those two values may be different because some other thread may have\n    // modified the database between the two blocks:\n    let count1 = try dbPool.read { db in try Place.fetchCount(db) }\n    let count2 = try dbPool.read { db in try Place.fetchCount(db) }\n    ```\n    \n    In the same vein, when you fetch values that depends on some database updates, group them:\n    \n    ```swift\n    // SAFE CONCURRENCY\n    try dbPool.write { db in\n        // The count is guaranteed to be non-zero\n        try Place(...).insert(db)\n        let count = try Place.fetchCount(db)\n    }\n    \n    // UNSAFE CONCURRENCY\n    // The count may be zero because some other thread may have performed\n    // a deletion between the two blocks:\n    try dbPool.write { db in try Place(...).insert(db) }\n    let count = try dbPool.read { db in try Place.fetchCount(db) }\n    ```\n    \n    On that last example, see [Advanced DatabasePool](#advanced-databasepool) if you look after extra performance.\n    \n- :point_up: **Rule 3**: When you perform several modifications of the database that temporarily put the database in an inconsistent state, make sure those modifications are grouped within a [transaction](#transactions-and-savepoints).\n    \n    ```swift\n    // SAFE CONCURRENCY\n    try dbPool.write { db in               // or dbQueue.write\n        try Credit(destinationAccount, amount).insert(db)\n        try Debit(sourceAccount, amount).insert(db)\n    }\n    \n    // SAFE CONCURRENCY\n    try dbPool.writeInTransaction { db in  // or dbQueue.inTransaction\n        try Credit(destinationAccount, amount).insert(db)\n        try Debit(sourceAccount, amount).insert(db)\n        return .commit\n    }\n    \n    // UNSAFE CONCURRENCY\n    try dbPool.writeWithoutTransaction { db in\n        try Credit(destinationAccount, amount).insert(db)\n        // <- Concurrent dbPool.read sees a partial db update here\n        try Debit(sourceAccount, amount).insert(db)\n    }\n    ```\n    \n    Without transaction, `DatabasePool.read { ... }` may see the first statement, but not the second, and access a database where the balance of accounts is not zero. A highly bug-prone situation.\n    \n    So do use [transactions](#transactions-and-savepoints) in order to guarantee database consistency accross your application threads: that\'s what they are made for.\n\n\n### Differences between Database Queues and Pools\n\nDespite the common [guarantees and rules](#guarantees-and-rules) shared by [database queues](#database-queues) and [pools](#database-pools), those two database accessors don\'t have the same behavior.\n\n**Database queues** serialize all database accesses, reads, and writes. There is never more than one thread that uses the database. In the image below, we see how three threads can see the database as time passes:\n\n![DatabaseQueueScheduling](https://cdn.rawgit.com/groue/GRDB.swift/master/Documentation/Images/DatabaseQueueScheduling.svg)\n\n**Database pools** also serialize all writes. But they allow concurrent reads and writes, and isolate reads so that they don\'t see changes performed by other threads. This gives a very different picture:\n\n![DatabasePoolScheduling](https://cdn.rawgit.com/groue/GRDB.swift/master/Documentation/Images/DatabasePoolScheduling.svg)\n\nSee how, with database pools, two reads can see different database states at the same time.\n\nFor more information about database pools, grab information about SQLite [WAL mode](https://www.sqlite.org/wal.html) and [snapshot isolation](https://sqlite.org/isolation.html). See [Database Observation](#database-changes-observation) when you look after automatic notifications of database changes.\n\n\n### Advanced DatabasePool\n\n- [The `concurrentRead` Method](#the-concurrentread-method)\n- [The `barrierWriteWithoutTransaction` Method](#the-barrierwritewithouttransaction-method)\n\n\n#### The `concurrentRead` Method\n\n[Database pools](#database-pools) are very concurrent, since all reads can run in parallel, and can even run during write operations. But writes are still serialized: at any given point in time, there is no more than a single thread that is writing into the database.\n\nWhen your application modifies the database, and then reads some value that depends on those modifications, you may want to avoid locking the writer queue longer than necessary:\n\n```swift\ntry dbPool.write { db in\n    // Increment the number of players\n    try Player(...).insert(db)\n    \n    // Read the number of players. The writer queue is still locked :-(\n    let count = try Player.fetchCount(db)\n}\n```\n\nA wrong solution is to chain a write then a read, as below. Don\'t do that, because another thread may modify the database in between, and make the read unreliable:\n\n```swift\n// WRONG\ntry dbPool.write { db in\n    // Increment the number of players\n    try Player(...).insert(db)\n}\n// <- other threads can write in the database here\ntry dbPool.read { db in\n    // Read some random value :-(\n    let count = try Player.fetchCount(db)\n}\n```\n\nThe correct solution is the `concurrentRead` method, which must be called from within a write block, outside of any transaction.\n\n`concurrentRead` returns a **future value** which you consume on any dispatch queue, with the `wait()` method:\n\n```swift\n// CORRECT\nlet futureCount: DatabaseFuture<Int> = try dbPool.writeWithoutTransaction { db in\n    // increment the number of players\n    try Player(...).insert(db)\n    \n    // <- not in a transaction here\n    let futureCount = dbPool.concurrentRead { db\n        return try Player.fetchCount(db)\n    }\n    return futureCount\n}\n// <- The writer queue has been unlocked :-)\n\n// Wait for the player count\nlet count: Int = try futureCount.wait()\n```\n\n`concurrentRead` blocks until it can guarantee its closure argument an isolated access to the last committed state of the database. It then asynchronously executes the closure.\n\nThe closure can run concurrently with eventual updates performed after `concurrentRead`: those updates won\'t be visible from within the closure. In the example below, the number of players is guaranteed to be non-zero, even though it is fetched concurrently with the player deletion:\n\n```swift\ntry dbPool.writeWithoutTransaction { db in\n    // Increment the number of players\n    try Player(...).insert(db)\n    \n    let futureCount = dbPool.concurrentRead { db\n        // Guaranteed to be non-zero\n        return try Player.fetchCount(db)\n    }\n    \n    try Player.deleteAll(db)\n}\n```\n\n[Transaction Observers](#transactionobserver-protocol) can also use `concurrentRead` in their `databaseDidCommit` method in order to process database changes without blocking other threads that want to write into the database.\n\n\n#### The `barrierWriteWithoutTransaction` Method\n\n```swift\ntry dbPool.barrierWriteWithoutTransaction { db in\n    // Exclusive database access\n}\n```\n\nThe barrier write guarantees exclusive access to the database: the method blocks until all concurrent database accesses are completed, reads and writes, and postpones all other accesses until it completes.\n\nThere is a known limitation: reads performed by [database snapshots](#database-snapshots) are out of scope, and may run concurrently with the barrier.\n\n\n\n### Database Snapshots\n\n**[Database pool](#database-pools) can take snapshots.** A database snapshot sees an unchanging database content, as it existed at the moment it was created.\n\n"Unchanging" means that a snapshot never sees any database modifications during all its lifetime. And yet it doesn\'t prevent database updates. This "magic" is made possible by SQLite\'s WAL mode (see [Isolation In SQLite](https://sqlite.org/isolation.html)).\n\nYou create snapshots from a [database pool](#database-pools):\n\n```swift\nlet snapshot = try dbPool.makeSnapshot()\n```\n\nYou can create as many snapshots as you need, regardless of the [maximum number of readers](#databasepool-configuration) in the pool. A snapshot database connection is closed when the snapshot gets deallocated.\n\n**A snapshot can be used from any thread.** Its `read` methods is synchronous, and blocks the current thread until your database statements are executed:\n\n```swift\n// Read values:\ntry snapshot.read { db in\n    let players = try Player.fetchAll(db)\n    let playerCount = try Player.fetchCount(db)\n}\n\n// Extract a value from the database:\nlet playerCount = try snapshot.read { db in\n    try Player.fetchCount(db)\n}\n```\n\nWhen you want to control the latest committed changes seen by a snapshot, create the snapshot from the pool\'s writer protected dispatch queue, outside of any transaction:\n\n```swift\nlet snapshot1 = try dbPool.writeWithoutTransaction { db -> DatabaseSnapshot in\n    try db.inTransaction {\n        // delete all players\n        try Player.deleteAll()\n        return .commit\n    }\n    \n    // <- not in a transaction here\n    return dbPool.makeSnapshot()\n}\n// <- Other threads may modify the database here\nlet snapshot2 = try dbPool.makeSnapshot()\n\ntry snapshot1.read { db in\n    // Guaranteed to be zero\n    try Player.fetchCount(db)\n}\n\ntry snapshot2.read { db in\n    // Could be anything\n    try Player.fetchCount(db)\n}\n```\n\n> :point_up: **Note**: snapshots currently serialize all database accesses. In the future, snapshots may allow concurrent reads.\n\n\n### DatabaseWriter and DatabaseReader Protocols\n\nBoth DatabaseQueue and DatabasePool adopt the [DatabaseReader](http://groue.github.io/GRDB.swift/docs/4.6/Protocols/DatabaseReader.html) and [DatabaseWriter](http://groue.github.io/GRDB.swift/docs/4.6/Protocols/DatabaseWriter.html) protocols. DatabaseSnapshot adopts DatabaseReader only.\n\nThese protocols provide a unified API that let you write generic code that targets all concurrency modes. They fuel, for example:\n\n- [Migrations](#migrations)\n- [DatabaseRegionObservation]\n- [ValueObservation]\n- [GRDBCombine]\n- [RxGRDB]\n\nOnly five types adopt those protocols: DatabaseQueue, DatabasePool, DatabaseSnapshot, AnyDatabaseReader, and AnyDatabaseWriter. Expanding this set is not supported: any future GRDB release may break your custom writers and readers, without notice.\n\nDatabaseReader and DatabaseWriter provide the *smallest* common guarantees: they don\'t erase the differences between queues, pools, and snapshots. See for example [Differences between Database Queues and Pools](#differences-between-database-queues-and-pools).\n\nHowever, you can prevent some parts of your application from writing in the database by giving them a DatabaseReader:\n\n```swift\n// This class can read in the database, but can\'t write into it.\nclass MyReadOnlyComponent {\n    let reader: DatabaseReader\n    \n    init(reader: DatabaseReader) {\n        self.reader = reader\n    }\n}\n\nlet dbQueue: DatabaseQueue = ...\nlet component = MyReadOnlyComponent(reader: dbQueue)\n```\n\n> :point_up: **Note**: DatabaseReader is not a **secure** way to prevent an application component from writing in the database, because write access is just a cast away:\n>\n> ```swift\n> if let dbQueue = reader as? DatabaseQueue {\n>     try dbQueue.write { ... }\n> }\n> ```\n\n\n### Asynchronous APIs\n\n**Database queues, pools, snapshots, as well as their common protocols `DatabaseReader` and `DatabaseWriter` provide asynchronous database access methods.**\n\n- [`asyncRead`](#asyncread)\n- [`asyncWrite`](#asyncwrite)\n- [`asyncWriteWithoutTransaction`](#asyncwritewithouttransaction)\n- [`asyncConcurrentRead`](#asyncconcurrentread)\n\n\n#### `asyncRead`\n\nThe `asyncRead` method can be used from any thread. It submits your database statements for asynchronous execution on a protected dispatch queue:\n\n```swift\nreader.asyncRead { (result: Result<Database>) in\n    try {\n        let db = try result.get()\n        let players = try Player.fetchAll(db)\n    } catch {\n        // handle error\n    }\n}\n```\n\nThe argument function accepts a standard `Result<Database, Error>` which may contain a failure if it was impossible to start a reading access to the database.\n\nAny attempt at modifying the database throws an error.\n\nWhen you use a [database queue](#database-queues) or a [database snapshot](#database-snapshots), the read has to wait for any eventual concurrent database access performed by this queue or snapshot to complete.\n\nWhen you use a [database pool](#database-pools), reads are generally non-blocking, unless the maximum number of concurrent reads has been reached. In this case, a read has to wait for another read to complete. That maximum number can be [configured](#databasepool-configuration).\n\n> :point_up: **Note**: because it uses the standard `Result` type, `asyncRead` is only available with a Swift 5+ compiler, starting Xcode 10.2.\n\n\n#### `asyncWrite`\n    \nThe `asyncWrite` method can be used from any thread. It submits your database statements for asynchronous execution on a protected dispatch queue, wrapped inside a [database transaction](#transactions-and-savepoints):\n\n```swift\nwriter.asyncWrite({ (db: Database) in\n    try Player(...).insert(db)\n}, completion: { (db: Database, result: Result<Void, Error>) in\n    switch result {\n    case let .success:\n        // handle transaction success\n    case let .failure(error):\n        // handle transaction error\n    }\n})\n```\n\n`asyncWrite` accepts two function arguments. The first one executes your database updates. The second one is a completion function which accepts a database connection and the result of the asynchronous transaction.\n\nOn the first unhandled error during database updates, all changes are reverted, the whole transaction is rollbacked, and the error is passed to the completion function.\n\nWhen the transaction completes successfully, the result of the first function is contained in the standard `Result` passed to the completion function:\n\n```swift\nwriter.asyncWrite({ (db: Database) -> Int in\n    try Player(...).insert(db)\n    return try Player.fetchCount(db)\n}, completion: { (db: Database, result: Result<Int, Error>) in\n    switch result {\n    case let .success(newPlayerCount):\n        print("new player count: \\(newPlayerCount)")\n    case let .failure(error):\n        // handle transaction error\n    }\n})\n```\n\nThe scheduled asynchronous transaction has to wait for any eventual concurrent database write to complete before it can start.\n\n> :point_up: **Note**: because it uses the standard `Result` type, `asyncWrite` is only available with a Swift 5+ compiler, starting Xcode 10.2.\n\n\n#### `asyncWriteWithoutTransaction`\n\nThe `asyncWriteWithoutTransaction` method can be used from any thread. It submits your database statements for asynchronous execution on a protected dispatch queue, outside of any transaction:\n\n```swift\nwriter.asyncWriteWithoutTransaction { (db: Database) in\n    try {\n        try Player(...).insert(db)\n    } catch {\n        // handle error\n    }\n}\n```\n\n**Writing outside of any transaction is dangerous.** You should almost always prefer the `asyncWrite` method described above. Please see [Transactions and Savepoints](#transactions-and-savepoints) for more information.\n\nThe scheduled asynchronous updates have to wait for any eventual concurrent database write to complete before they can start.\n\n\n#### `asyncConcurrentRead`\n\nThe `asyncConcurrentRead` method is available on database pools only. It is the asynchronous equivalent of the `concurrentRead` described in the [Advanced DatabasePool](#advanced-databasepool) chapter.\n\nIt must be called from a writing dispatch queue, outside of any transaction. You\'ll get a fatal error otherwise.\n\nThe closure argument is guaranteed to see the database in the last committed state at the moment this method is called. Eventual concurrent database updates are *not visible* inside the block.\n\n`asyncConcurrentRead` blocks until it can guarantee its closure argument an isolated access to the last committed state of the database. It then asynchronously executes the closure.\n\nIn the example below, the number of players is fetched concurrently with the player insertion. Yet the future is guaranteed to return zero:\n\n```swift\ntry writer.asyncWriteWithoutTransaction { db in\n    do {\n        // Delete all players\n        try Player.deleteAll()\n        \n        // <- not in a transaction here\n        // Count players concurrently\n        writer.asyncConcurrentRead { (result: Result<Database>) in\n            try {\n                let db = try result.get()\n                // Guaranteed to be zero\n                let count = try Player.fetchCount()\n            } catch {\n                // handle error\n            }\n        }\n        \n        // Insert a player\n        try Player(...).insert(db)\n    } catch {\n        // handle error\n    }\n}\n```\n\n> :point_up: **Note**: because it uses the standard `Result` type, `asyncWriteWithoutTransaction` is only available with a Swift 5+ compiler, starting Xcode 10.2.\n\n\n### Unsafe Concurrency APIs\n\n**Database queues, pools, snapshots, as well as their common protocols `DatabaseReader` and `DatabaseWriter` provide *unsafe* database access methods.** Unsafe APIs lift [concurrency guarantees](#guarantees-and-rules), and allow advanced yet unsafe patterns.\n\n- **`unsafeRead`**\n    \n    The `unsafeRead` method is synchronous, and blocks the current thread until your database statements are executed in a protected dispatch queue. GRDB does just the bare minimum to provide a database connection that can read.\n    \n    When used on a database pool, reads are no longer isolated:\n    \n    ```swift\n    dbPool.unsafeRead { db in\n        // Those two values may be different because some other thread\n        // may have inserted or deleted a player between the two requests:\n        let count1 = try Player.fetchCount(db)\n        let count2 = try Player.fetchCount(db)\n    }\n    ```\n    \n    When used on a database queue, the closure argument is allowed to write in the database.\n    \n- **`unsafeReentrantRead`**\n    \n    The `unsafeReentrantRead` behaves just as `unsafeRead` (see above), and allows reentrant calls:\n    \n    ```swift\n    dbPool.read { db1 in\n        // No "Database methods are not reentrant" fatal error:\n        dbPool.unsafeReentrantRead { db2 in\n            dbPool.unsafeReentrantRead { db3 in\n                ...\n            }\n        }\n    }\n    ```\n    \n    Reentrant database accesses make it very easy to break the second [safety rule](#guarantees-and-rules), which says: "group related statements within a single call to a DatabaseQueue or DatabasePool database access method.". Using a reentrant method is pretty much likely the sign of a wrong application architecture that needs refactoring.\n    \n    There is a single valid use case for reentrant methods, which is when you are unable to control database access scheduling.\n    \n- **`unsafeReentrantWrite`**\n    \n    The `unsafeReentrantWrite` method is synchronous, and blocks the current thread until your database statements are executed in a protected dispatch queue. Writes are serialized: eventual concurrent database updates are postponed until the block has executed.\n    \n    Reentrant calls are allowed:\n    \n    ```swift\n    dbQueue.write { db1 in\n        // No "Database methods are not reentrant" fatal error:\n        dbQueue.unsafeReentrantWrite { db2 in\n            dbQueue.unsafeReentrantWrite { db3 in\n                ...\n            }\n        }\n    }\n    ```\n    \n    Reentrant database accesses make it very easy to break the second [safety rule](#guarantees-and-rules), which says: "group related statements within a single call to a DatabaseQueue or DatabasePool database access method.". Using a reentrant method is pretty much likely the sign of a wrong application architecture that needs refactoring.\n    \n    There is a single valid use case for reentrant methods, which is when you are unable to control database access scheduling.\n\n\n### Dealing with External Connections\n\nThe first rule of GRDB is:\n\n- **[Rule 1](#guarantees-and-rules)**: Have a unique instance of DatabaseQueue or DatabasePool connected to any database file.\n\nThis means that dealing with external connections is not a focus of GRDB. [Guarantees](#guarantees-and-rules) of GRDB may or may not hold as soon as some external connection modifies a database.\n\nIf you absolutely need multiple connections, then:\n\n- Reconsider your position\n- Read about [isolation in SQLite](https://www.sqlite.org/isolation.html)\n- Learn about [locks and transactions](https://www.sqlite.org/lang_transaction.html)\n- Become a master of the [WAL mode](https://www.sqlite.org/wal.html)\n- Prepare to setup a [busy handler](https://www.sqlite.org/c3ref/busy_handler.html) with [Configuration.busyMode](http://groue.github.io/GRDB.swift/docs/4.6/Structs/Configuration.html)\n- [Ask questions](https://github.com/groue/GRDB.swift/issues)\n\n\n## Performance\n\nGRDB is a reasonably fast library, and can deliver quite efficient SQLite access. See [Comparing the Performances of Swift SQLite libraries](https://github.com/groue/GRDB.swift/wiki/Performance) for an overview.\n\nYou\'ll find below general advice when you do look after performance:\n\n- Focus\n- Know your platform\n- Use transactions\n- Don\'t do useless work\n- Learn about SQL strengths and weaknesses\n- Avoid strings & dictionaries\n\n\n### Performance tip: focus\n\nYou don\'t know which part of your program needs improvement until you have run a benchmarking tool.\n\nDon\'t make any assumption, avoid optimizing code too early, and use [Instruments](https://developer.apple.com/library/ios/documentation/ToolsLanguages/Conceptual/Xcode_Overview/MeasuringPerformance.html).\n\n\n### Performance tip: know your platform\n\nIf your application processes a huge JSON file and inserts thousands of rows in the database right from the main thread, it will quite likely become unresponsive, and provide a sub-quality user experience.\n\nIf not done yet, read the [Concurrency Programming Guide](https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091) and learn how to perform heavy computations without blocking your application.\n\nMost GRBD APIs are [synchronous](#database-connections). Spawning them into parallel queues is as easy as:\n\n```swift\nDispatchQueue.global().async { \n    dbQueue.write { db in\n        // Perform database work\n    }\n    DispatchQueue.main.async { \n        // update your user interface\n    }\n}\n```\n\n\n### Performance tip: use transactions\n\nPerforming multiple updates to the database is much faster when executed inside a [transaction](#transactions-and-savepoints). This is because a transaction allows SQLite to postpone writing changes to disk until the final commit:\n\n```swift\n// Inefficient\ntry dbQueue.inDatabase { db in // or dbPool.writeWithoutTransaction\n    for player in players {\n        try player.insert(db)\n    }\n}\n\n// Efficient\ntry dbQueue.write { db in      // or dbPool.write\n    for player in players {\n        try player.insert(db)\n    }\n}\n\n// Efficient\ntry dbQueue.inTransaction { db in // or dbPool.writeInTransaction\n    for player in players {\n        try player.insert(db)\n    }\n    return .commit\n}\n```\n\n\n### Performance tip: don\'t do useless work\n\nObviously, no code is faster than any code.\n\n\n**Don\'t fetch columns you don\'t use**\n\n```swift\n// SELECT * FROM player\ntry Player.fetchAll(db)\n\n// SELECT id, name FROM player\ntry Player.select(idColumn, nameColumn).fetchAll(db)\n```\n\nIf your Player type can\'t be built without other columns (it has non-optional properties for other columns), *do define and use a different type*.\n\nSee [Columns Selected by a Request] for more information.\n\n\n**Don\'t fetch rows you don\'t use**\n\nUse [fetchOne](#fetching-methods) when you need a single value, and otherwise limit your queries at the database level:\n\n```swift\n// Wrong way: this code may discard hundreds of useless database rows\nlet players = try Player.order(scoreColumn.desc).fetchAll(db)\nlet hallOfFame = players.prefix(5)\n\n// Better way\nlet hallOfFame = try Player.order(scoreColumn.desc).limit(5).fetchAll(db)\n```\n\n\n**Don\'t copy values unless necessary**\n\nParticularly: the Array returned by the `fetchAll` method, and the cursor returned by `fetchCursor` aren\'t the same:\n\n`fetchAll` copies all values from the database into memory, when `fetchCursor` iterates database results as they are generated by SQLite, taking profit from SQLite efficiency.\n\nYou should only load arrays if you need to keep them for later use (such as iterating their contents in the main thread). Otherwise, use `fetchCursor`.\n\nSee [fetching methods](#fetching-methods) for more information about `fetchAll` and `fetchCursor`. See also the [Row.dataNoCopy](#data-and-memory-savings) method.\n\n\n**Don\'t update rows unless necessary**\n\nAn UPDATE statement is costly: SQLite has to look for the updated row, update values, and write changes to disk.\n\nWhen the overwritten values are the same as the existing ones, it\'s thus better to avoid performing the UPDATE statement:.\n\n```swift\nif player.hasDatabaseChanges {\n    try player.update(db)\n}\n```\n\nSee [Record Comparison] for more information.\n\n\n### Performance tip: learn about SQL strengths and weaknesses\n\nConsider a simple use case: your store application has to display a list of authors with the number of available books:\n\n- J. M. Coetzee (6)\n- Herman Melville (1)\n- Alice Munro (3)\n- Kim Stanley Robinson (7)\n- Oliver Sacks (4)\n\nThe following code is inefficient. It is an example of the [N+1 problem](http://stackoverflow.com/questions/97197/what-is-the-n1-selects-issue), because it performs one query to load the authors, and then N queries, as many as there are authors. This turns very inefficient as the number of authors grows:\n\n```swift\n// SELECT * FROM author\nlet authors = try Author.fetchAll(db)\nfor author in authors {\n    // SELECT COUNT(*) FROM book WHERE authorId = ...\n    author.bookCount = try Book.filter(authorIdColumn == author.id).fetchCount(db)\n}\n```\n\nInstead, perform *a single query*:\n\n```swift\nlet sql = """\n    SELECT author.*, COUNT(book.id) AS bookCount\n    FROM author\n    LEFT JOIN book ON book.authorId = author.id\n    GROUP BY author.id\n    """\nlet authors = try Author.fetchAll(db, sql: sql)\n```\n\nIn the example above, consider extending your Author with an extra bookCount property, or define and use a different type.\n\nGenerally, define indexes on your database tables, and use SQLite\'s efficient query planning:\n\n- [Query Planning](https://www.sqlite.org/queryplanner.html)\n- [CREATE INDEX](https://www.sqlite.org/lang_createindex.html)\n- [The SQLite Query Planner](https://www.sqlite.org/optoverview.html)\n- [EXPLAIN QUERY PLAN](https://www.sqlite.org/eqp.html)\n\n\n### Performance tip: avoid strings & dictionaries\n\nThe String and Dictionary Swift types are better avoided when you look for the best performance.\n\nNow GRDB [records](#records), for your convenience, do use strings and dictionaries:\n\n```swift\nclass Player : Record {\n    var id: Int64?\n    var name: String\n    var email: String\n    \n    required init(_ row: Row) {\n        id = row["id"]       // String\n        name = row["name"]   // String\n        email = row["email"] // String\n        super.init()\n    }\n    \n    override func encode(to container: inout PersistenceContainer) {\n        container["id"] = id              // String\n        container["name"] = name          // String\n        container["email"] = email        // String\n    }\n}\n```\n\nWhen convenience hurts performance, you can still use records, but you have better avoiding their string and dictionary-based methods.\n\nFor example, when fetching values, prefer loading columns by index:\n\n```swift\n// Strings & dictionaries\nlet players = try Player.fetchAll(db)\n\n// Column indexes\n// SELECT id, name, email FROM player\nlet request = Player.select(idColumn, nameColumn, emailColumn)\nlet rows = try Row.fetchCursor(db, request)\nwhile let row = try rows.next() {\n    let id: Int64 = row[0]\n    let name: String = row[1]\n    let email: String = row[2]\n    let player = Player(id: id, name: name, email: email)\n    ...\n}\n```\n\nWhen inserting values, use reusable [prepared statements](#prepared-statements), and set statements values with an *array*:\n\n```swift\n// Strings & dictionaries\nfor player in players {\n    try player.insert(db)\n}\n\n// Prepared statement\nlet insertStatement = db.prepareStatement("INSERT INTO player (name, email) VALUES (?, ?)")\nfor player in players {\n    // Only use the unsafe arguments setter if you are sure that you provide\n    // all statement arguments. A mistake can store unexpected values in\n    // the database.\n    insertStatement.unsafeSetArguments([player.name, player.email])\n    try insertStatement.execute()\n}\n```\n\n\nFAQ\n===\n\n- [How do I create a database in my application?](#how-do-i-create-a-database-in-my-application)\n- [How do I open a database stored as a resource of my application?](#how-do-i-open-a-database-stored-as-a-resource-of-my-application)\n- [How do I close a database connection?](#how-do-i-close-a-database-connection)\n- [How do I print a request as SQL?](#how-do-i-print-a-request-as-sql)\n- [Generic parameter \'T\' could not be inferred](#generic-parameter-t-could-not-be-inferred)\n- [SQLite error 10 "disk I/O error", SQLite error 23 "not authorized"](#sqlite-error-10-disk-io-error-sqlite-error-23-not-authorized)\n- [SQLite error 21 "wrong number of statement arguments" with LIKE queries](#sqlite-error-21-wrong-number-of-statement-arguments-with-like-queries)\n- [What Are Experimental Features?](#what-are-experimental-features)\n\n\n### How do I create a database in my application?\n\nThis question assumes that your application has to create a new database from scratch. If your app has to open an existing database that is embedded inside your application as a resource, see [How do I open a database stored as a resource of my application?](#how-do-i-open-a-database-stored-as-a-resource-of-my-application) instead.\n\nThe database has to be stored in a valid place where it can be created and modified. For example, in the [Application Support directory](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html):\n\n```swift\nlet databaseURL = try FileManager.default\n    .url(for: .applicationSupportDirectory, in: .userDomainMask, appropriateFor: nil, create: true)\n    .appendingPathComponent("db.sqlite")\nlet dbQueue = try DatabaseQueue(path: databaseURL.path)\n```\n\n\n### How do I open a database stored as a resource of my application?\n\nIf your application does not need to modify the database, open a read-only [connection](#database-connections) to your resource:\n\n```swift\nvar config = Configuration()\nconfig.readonly = true\nlet dbPath = Bundle.main.path(forResource: "db", ofType: "sqlite")!\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\nIf the application should modify the database, you need to copy it to a place where it can be modified. For example, in the [Application Support directory](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html). Only then, open a [connection](#database-connections):\n\n```swift\nlet fileManager = FileManager.default\nlet dbPath = try fileManager\n    .url(for: .applicationSupportDirectory, in: .userDomainMask, appropriateFor: nil, create: true)\n    .appendingPathComponent("db.sqlite")\n    .path\nif !fileManager.fileExists(atPath: dbPath) {\n    let dbResourcePath = Bundle.main.path(forResource: "db", ofType: "sqlite")!\n    try fileManager.copyItem(atPath: dbResourcePath, toPath: dbPath)\n}\nlet dbQueue = try DatabaseQueue(path: dbPath)\n```\n\n\n### How do I close a database connection?\n    \nDatabase connections are managed by [database queues](#database-queues) and [pools](#database-pools). A connection is closed when its database queue or pool is deallocated, and all usages of this connection are completed.\n\nDatabase accesses that run in background threads postpone the closing of connections.\n\n\n### How do I print a request as SQL?\n\nWhen you want to debug a request that does not deliver the expected results, you may want to print the SQL that is actually executed.\n\nYou can turn your request into a `SQLRequest` instance:\n\n```swift\ntry dbQueue.read { db in\n    let request = Wine\n        .filter(originColumn == "Burgundy")\n        .order(priceColumn)\n    \n    let sqlRequest = try SQLRequest(db, request: request)\n    print(sqlRequest.sql)\n    // Prints SELECT * FROM wine WHERE origin = ? ORDER BY price\n    print(sqlRequest.arguments)\n    // Prints ["Burgundy"]\n}\n```\n\nAnother option is to setup a tracing function that will print out all SQL requests executed by your application. You provide the trace function when you connect to the database:\n\n```swift\nvar config = Configuration()\nconfig.trace = { print($0) } // Prints all SQL statements\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n\ntry dbQueue.read { db in\n    let wines = Wine\n        .filter(originColumn == "Burgundy")\n        .order(priceColumn)\n        .fetchAll(db)\n    // Prints SELECT * FROM wine WHERE origin = \'Burgundy\' ORDER BY price\n}\n```\n\n> :point_up: **Note**: the generated SQL may change between GRDB releases, without notice: don\'t have your application rely on any specific SQL output.\n\n\n### Generic parameter \'T\' could not be inferred\n    \nYou may get this error when using the `read` and `write` methods of database queues and pools:\n\n```swift\n// Generic parameter \'T\' could not be inferred\nlet string = try dbQueue.read { db in\n    let result = try String.fetchOne(db, ...)\n    return result\n}\n```\n\nThis is a limitation of the Swift compiler.\n\nThe general workaround is to explicitly declare the type of the closure result:\n\n```swift\n// General Workaround\nlet string = try dbQueue.read { db -> String? in\n    let result = try String.fetchOne(db, ...)\n    return result\n}\n```\n\nYou can also, when possible, write a single-line closure:\n\n```swift\n// Single-line closure workaround:\nlet string = try dbQueue.read { db in\n    try String.fetchOne(db, ...)\n}\n```\n\n\n### SQLite error 10 "disk I/O error", SQLite error 23 "not authorized"\n\nThose errors may be the sign that SQLite can\'t access the database due to [data protection](#data-protection).\n\nWhen your application should be able to run in the background on a locked device, it has to catch this error, and, for example, wait for [UIApplicationDelegate.applicationProtectedDataDidBecomeAvailable(_:)](https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623044-applicationprotecteddatadidbecom) or [UIApplicationProtectedDataDidBecomeAvailable](https://developer.apple.com/reference/uikit/uiapplicationprotecteddatadidbecomeavailable) notification and retry the failed database operation.\n\n```swift\ndo {\n    try ...\n} catch let error as DatabaseError where\n    error.resultCode == .SQLITE_IOERR ||\n    error.resultCode == .SQLITE_AUTH\n{\n    // Handle possible data protection error\n}\n```\n\nThis error can also be prevented altogether by using a more relaxed [file protection](https://developer.apple.com/reference/foundation/filemanager/1653059-file_protection_values).\n\n\n### SQLite error 21 "wrong number of statement arguments" with LIKE queries\n\nYou may get the error "wrong number of statement arguments" when executing a LIKE query similar to:\n\n```swift\nlet name = textField.text\nlet players = try dbQueue.read { db in\n    try Player.fetchAll(db, sql: "SELECT * FROM player WHERE name LIKE \'%?%\'", arguments: [name])\n}\n```\n\nThe problem lies in the `\'%?%\'` pattern.\n\nSQLite only interprets `?` as a parameter when it is a placeholder for a whole value (int, double, string, blob, null). In this incorrect query, `?` is just a character in the `\'%?%\'` string: it is not a query parameter, and is not processed in any way. See [https://www.sqlite.org/lang_expr.html#varparam](https://www.sqlite.org/lang_expr.html#varparam) for more information about SQLite parameters.\n\nTo fix the error, you can feed the request with the pattern itself, instead of the name:\n\n```swift\nlet name = textField.text\nlet players: [Player] = try dbQueue.read { db in\n    let pattern = "%\\(name)%"\n    return try Player.fetchAll(db, sql: "SELECT * FROM player WHERE name LIKE ?", arguments: [pattern])\n}\n```\n\n\n### What Are Experimental Features?\n\nSince GRDB 1.0, all backwards compatibility guarantees of [semantic versioning](http://semver.org) apply: no breaking change will happen until the next major version of the library.\n\nThere is an exception, though: *experimental features*, marked with the "**:fire: EXPERIMENTAL**" badge. Those are advanced features that are too young, or lack user feedback. They are not stabilized yet.\n\nThose experimental features are not protected by semantic versioning, and may break between two minor releases of the library. To help them becoming stable, [your feedback](https://github.com/groue/GRDB.swift/issues) is greatly appreciated.\n\n\nSample Code\n===========\n\n- The [Documentation](#documentation) is full of GRDB snippets.\n- [Demo Application]: A sample iOS application.\n- [WWDC Companion](https://github.com/groue/WWDCCompanion): A sample iOS application.\n- Check `GRDB.xcworkspace`: it contains GRDB-enabled playgrounds to play with.\n- How to synchronize a database table with a JSON payload: [JSONSynchronization.playground](Documentation/Playgrounds/JSONSynchronization.playground/Contents.swift)\n\n\n---\n\n**Thanks**\n\n- [Pierlis](http://pierlis.com), where we write great software.\n- [@alextrob](https://github.com/alextrob), [@bellebethcooper](https://github.com/bellebethcooper), [@bfad](https://github.com/bfad), [@cfilipov](https://github.com/cfilipov), [@charlesmchen-signal](https://github.com/charlesmchen-signal), [@Chiliec](https://github.com/Chiliec), [@chrisballinger](https://github.com/chrisballinger), [@darrenclark](https://github.com/darrenclark), [@davidkraus](https://github.com/davidkraus), [@fpillet](http://github.com/fpillet), [@gusrota](https://github.com/gusrota), [@hartbit](https://github.com/hartbit), [@kdubb](https://github.com/kdubb), [@kluufger](https://github.com/kluufger), [@KyleLeneau](https://github.com/KyleLeneau), [@Marus](https://github.com/Marus), [@michaelkirk-signal](https://github.com/michaelkirk-signal), [@pakko972](https://github.com/pakko972), [@peter-ss](https://github.com/peter-ss), [@pierlo](https://github.com/pierlo), [@pocketpixels](https://github.com/pocketpixels), [@robcas3](https://github.com/robcas3), [@runhum](https://github.com/runhum), [@schveiguy](https://github.com/schveiguy), [@SD10](https://github.com/SD10), [@sobri909](https://github.com/sobri909), [@sroddy](https://github.com/sroddy), [@swiftlyfalling](https://github.com/swiftlyfalling), [@Timac](https://github.com/Timac), [@valexa](https://github.com/valexa), and [@zmeyc](https://github.com/zmeyc) for their contributions, help, and feedback on GRDB.\n- [@aymerick](https://github.com/aymerick) and [@kali](https://github.com/kali) because SQL.\n- [ccgus/fmdb](https://github.com/ccgus/fmdb) for its excellency.\n\n---\n\n[URIs don\'t change: people change them.](https://www.w3.org/Provider/Style/URI)\n\n#### Changes Tracking\n\nThis chapter has been renamed [Record Comparison].\n\n#### FetchedRecordsController\n\nThis chapter has [moved](Documentation/FetchedRecordsController.md).\n\n#### Persistable Protocol\n\nThis protocol has been renamed [PersistableRecord] in GRDB 3.0.\n\n#### RowConvertible Protocol\n\nThis protocol has been renamed [FetchableRecord] in GRDB 3.0.\n\n#### TableMapping Protocol\n\nThis protocol has been renamed [TableRecord] in GRDB 3.0.\n\n#### Customized Decoding of Database Rows\n\nThis chapter has been renamed [Beyond FetchableRecord].\n\n#### Full-Text Search\n\nThis chapter has [moved](Documentation/FullTextSearch.md).\n\n#### Enabling FTS5 Support\n\nThis chapter has [moved](Documentation/FullTextSearch.md#enabling-fts5-support).\n\n[Associations]: Documentation/AssociationsBasics.md\n[Beyond FetchableRecord]: #beyond-fetchablerecord\n[Codable Records]: #codable-records\n[Columns Selected by a Request]: #columns-selected-by-a-request\n[Conflict Resolution]: #conflict-resolution\n[Customizing the Persistence Methods]: #customizing-the-persistence-methods\n[Date and UUID Coding Strategies]: #date-and-uuid-coding-strategies\n[Fetching from Requests]: #fetching-from-requests\n[Full-Text Search]: Documentation/FullTextSearch.md\n[The Implicit RowID Primary Key]: #the-implicit-rowid-primary-key\n[The userInfo Dictionary]: #the-userinfo-dictionary\n[JSON Columns]: #json-columns\n[FetchableRecord]: #fetchablerecord-protocol\n[EncodableRecord]: #persistablerecord-protocol\n[PersistableRecord]: #persistablerecord-protocol\n[Record Comparison]: #record-comparison\n[Record Customization Options]: #record-customization-options\n[TableRecord]: #tablerecord-protocol\n[ValueObservation]: #valueobservation\n[DatabaseRegionObservation]: #databaseregionobservation\n[RxGRDB]: http://github.com/RxSwiftCommunity/RxGRDB\n[GRDBCombine]: http://github.com/groue/GRDBCombine\n[DatabaseRegionConvertible]: #the-databaseregionconvertible-protocol\n[ValueObservation and DatabaseRegionObservation]: #valueobservation-and-databaseregionobservation\n[DatabaseRegion]: #databaseregion\n[SQL Interpolation]: Documentation/SQLInterpolation.md\n[custom SQLite build]: Documentation/CustomSQLiteBuilds.md\n[Combine]: https://developer.apple.com/documentation/combine\n[Demo Application]: Documentation/DemoApps/GRDBDemoiOS/README.md\n'