b'# About xo\n\n`xo` is a command-line tool to generate [Go](https://golang.org/project/)\ncode based on a database schema or a custom query.\n\n`xo` works by using database metadata and SQL introspection queries to discover\nthe types and relationships contained within a schema, and applying a standard\nset of base (or customized) Go templates against the discovered relationships.\n\nCurrently, `xo` can generate types for tables, enums, stored procedures, and\ncustom SQL queries for PostgreSQL, MySQL, Oracle, Microsoft SQL Server, and\nSQLite3 databases.\n\n**NOTE:** While the code generated by xo is production quality, it is not the\ngoal, nor the intention for xo to be a "silver bullet," nor to completely\neliminate the manual authoring of SQL / Go code.\n\n## Database Feature Support\n\nThe following is a matrix of the feature support for each database:\n\n|              | PostgreSQL       | MySQL            | Oracle           | Microsoft SQL Server| SQLite           |\n| ------------ |:----------------:|:----------------:|:----------------:|:-------------------:|:----------------:|\n| Models       |:white_check_mark:|:white_check_mark:|:white_check_mark:|:white_check_mark:   |:white_check_mark:|\n| Primary Keys |:white_check_mark:|:white_check_mark:|:white_check_mark:|:white_check_mark:   |:white_check_mark:|\n| Foreign Keys |:white_check_mark:|:white_check_mark:|:white_check_mark:|:white_check_mark:   |:white_check_mark:|\n| Indexes      |:white_check_mark:|:white_check_mark:|:white_check_mark:|:white_check_mark:   |:white_check_mark:|\n| Stored Procs |:white_check_mark:|:white_check_mark:|                  |                     |                  |\n| ENUM types   |:white_check_mark:|:white_check_mark:|                  |                     |                  |\n| Custom types |:white_check_mark:|                  |                  |                     |                  |\n\n## Installation\n\nInstall `goimports` dependency (if not already installed):\n\n```sh\n$ go get -u golang.org/x/tools/cmd/goimports\n```\n\nThen, install in the usual Go way:\n\n```sh\n$ go get -u github.com/xo/xo\n\n# install with oracle support (see notes below)\n$ go get -tags oracle -u github.com/xo/xo\n```\n\n**_NOTE:_** Go 1.6+ is needed for installing `xo` from source, as it makes use\nof the trim template syntax in Go templates, which is not compatible with\nprevious versions of Go. However, code generated by `xo` should compile with Go\n1.3+.\n\n## Quickstart\n\nThe following is a quick overview of using `xo` on the command-line:\n\n```sh\n# change to project directory\n$ cd $GOPATH/src/path/to/project\n\n# make an output directory\n$ mkdir -p models\n\n# generate code for a postgres schema\n$ xo pgsql://user:pass@host/dbname -o models\n\n# generate code for a Microsoft SQL schema using a custom template directory (see notes below)\n$ mkdir -p mssqlmodels\n$ xo mysql://user:pass@host/dbname -o mssqlmodels --template-path /path/to/custom/templates\n\n# generate code for a custom SQL query for postgres\n$ xo pgsql://user:pass@host/dbname -N -M -B -T AuthorResult -o models/ << ENDSQL\nSELECT\n  a.name::varchar AS name,\n  b.type::integer AS my_type\nFROM authors a\n  INNER JOIN authortypes b ON a.id = b.author_id\nWHERE\n  a.id = %%authorID int%%\nLIMIT %%limit int%%\nENDSQL\n\n# build generated code\n$ go build ./models/\n$ go build ./mssqlmodels/\n\n# do standard go install\n$ go install ./models/\n$ go install ./mssqlmodels/\n```\n\n## Command Line Options\n\nThe following are `xo`\'s command-line arguments and options:\n\n```sh\n$ xo --help\nusage: xo [--verbose] [--schema SCHEMA] [--out OUT] [--append] [--suffix SUFFIX] [--single-file] [--package PACKAGE] [--custom-type-package CUSTOM-TYPE-PACKAGE] [--int32-type INT32-TYPE] [--uint32-type UINT32-TYPE] [--ignore-fields IGNORE-FIELDS] [--fk-mode FK-MODE] [--use-index-names] [--use-reversed-enum-const-names] [--query-mode] [--query QUERY] [--query-type QUERY-TYPE] [--query-func QUERY-FUNC] [--query-only-one] [--query-trim] [--query-strip] [--query-interpolate] [--query-type-comment QUERY-TYPE-COMMENT] [--query-func-comment QUERY-FUNC-COMMENT] [--query-delimiter QUERY-DELIMITER] [--query-fields QUERY-FIELDS] [--escape-all] [--escape-schema] [--escape-table] [--escape-column] [--enable-postgres-oids] [--name-conflict-suffix NAME-CONFLICT-SUFFIX] [--template-path TEMPLATE-PATH] DSN\n\npositional arguments:\n  dsn                    data source name\n\noptions:\n  --verbose, -v          toggle verbose\n  --schema SCHEMA, -s SCHEMA\n                         schema name to generate Go types for\n  --out OUT, -o OUT      output path or file name\n  --append, -a           append to existing files\n  --suffix SUFFIX, -f SUFFIX\n                         output file suffix [default: .xo.go]\n  --single-file          toggle single file output\n  --package PACKAGE, -p PACKAGE\n                         package name used in generated Go code\n  --custom-type-package CUSTOM-TYPE-PACKAGE, -C CUSTOM-TYPE-PACKAGE\n                         Go package name to use for custom or unknown types\n  --int32-type INT32-TYPE, -i INT32-TYPE\n                         Go type to assign to integers [default: int]\n  --uint32-type UINT32-TYPE, -u UINT32-TYPE\n                         Go type to assign to unsigned integers [default: uint]\n  --ignore-fields IGNORE-FIELDS\n                         fields to exclude from the generated Go code types\n  --fk-mode FK-MODE, -k FK-MODE\n                         sets mode for naming foreign key funcs in generated Go code [values: <smart|parent|field|key>] [default: smart]\n  --use-index-names, -j\n                         use index names as defined in schema for generated Go code\n  --use-reversed-enum-const-names, -R\n                         use reversed enum names for generated consts in Go code\n  --query-mode, -N       enable query mode\n  --query QUERY, -Q QUERY\n                         query to generate Go type and func from\n  --query-type QUERY-TYPE, -T QUERY-TYPE\n                         query\'s generated Go type\n  --query-func QUERY-FUNC, -F QUERY-FUNC\n                         query\'s generated Go func name\n  --query-only-one, -1   toggle query\'s generated Go func to return only one result\n  --query-trim, -M       toggle trimming of query whitespace in generated Go code\n  --query-strip, -B      toggle stripping type casts from query in generated Go code\n  --query-interpolate, -I\n                         toggle query interpolation in generated Go code\n  --query-type-comment QUERY-TYPE-COMMENT\n                         comment for query\'s generated Go type\n  --query-func-comment QUERY-FUNC-COMMENT\n                         comment for query\'s generated Go func\n  --query-delimiter QUERY-DELIMITER, -D QUERY-DELIMITER\n                         delimiter for query\'s embedded Go parameters [default: %%]\n  --query-fields QUERY-FIELDS, -Z QUERY-FIELDS\n                         comma separated list of field names to scan query\'s results to the query\'s associated Go type\n  --escape-all, -X       escape all names in SQL queries\n  --escape-schema, -z    escape schema name in SQL queries\n  --escape-table, -y     escape table names in SQL queries\n  --escape-column, -x    escape column names in SQL queries\n  --enable-postgres-oids\n                         enable postgres oids\n  --name-conflict-suffix NAME-CONFLICT-SUFFIX, -w NAME-CONFLICT-SUFFIX\n                         suffix to append when a name conflicts with a Go variable [default: Val]\n  --template-path TEMPLATE-PATH\n                         user supplied template path\n  --help, -h             display this help and exit\n```\n\n## About Base Templates\n\n`xo` provides a set of generic "base" [templates](templates/) for each of the\nsupported databases, but it is understood these templates are not suitable for\nevery organization or every schema out there. As such, you can author your own\ncustom templates, or modify the base templates available in the `xo` source\ntree, and use those with `xo` by a passing a directory path via the `--template-path`\nflag.\n\nFor non-trivial schemas, custom templates are the most practical, common, and\nbest way to use `xo` (see below quickstart and related example).\n\n### Custom Template Quickstart\n\nThe following is a quick overview of copying the base templates contained in\nthe `xo` project\'s [`templates/`](templates) directory, editing to suit, and\nusing with `xo`:\n\n```sh\n# change to working project directory\n$ cd $GOPATH/src/path/to/my/project\n\n# create a template directory\n$ mkdir -p templates\n\n# copy xo templates for postgres\n$ cp "$GOPATH/src/github.com/xo/xo/templates/*" templates/\n\n# remove xo binary data\n$ rm templates/*.go\n\n# edit base postgres templates\n$ vi templates/postgres.*.tpl.go\n\n# use with xo\n$ xo pgsql://user:pass@host/db -o models --template-path templates\n```\n\nSee the Custom Template example below for more information on adapting the base\ntemplates in the `xo` source tree for use within your own project.\n\n### Storing Project Templates\n\nIdeally, the custom templates for your project/schema should be stored\nwithin your project, and used in conjunction with a build pipeline such as\n`go generate`:\n\n```sh\n# add to custom xo command to go generate:\n$ tee -a gen.go << ENDGO\npackage mypackage\n\n//go:generate xo pgsql://user:pass@host/db -o models --template-path templates\nENDGO\n\n# run go generate\n$ go generate\n\n# add custom templates and gen.go to project\n$ git add templates gen.go && git commit -m \'Adding custom xo templates for models\'\n```\n\nNote that `xo` only needs the templates for your specific database. You can\nsafely delete the templates for the other databases -- make sure, however, that\nyour templates are not symlinks to another database\'s templates before\ndeleting.\n\n### Template Language/Syntax\n\n`xo` templates are standard Go text templates. Please see the [documentation\nfor Go\'s standard `text/template` package](https://golang.org/pkg/text/template/)\nfor information concerning the syntax, logic, and variable use within Go\ntemplates.\n\n### Template Context and File Layout\n\nThe contexts (ie, the `.` identifier in templates) made available to custom\ntemplates are instances of `xo/internal/$TYPE` (see below table on `$TYPE`\navailable `$TYPE`s), and are defined in [`internal/types.go`](internal/types.go).\n\nEach database, `$DBNAME`, has its own set of templates for `$TYPE` and are\navailable in the [templates/](templates/) directory as `templates/$DBNAME.$TYPE.go.tpl`:\n\n| Template File                         | `$TYPE`      | Description                                           |\n|---------------------------------------|--------------|-------------------------------------------------------|\n| `templates/$DBNAME.type.go.tpl`       | `Type`       | Template for schema tables/views/queries              |\n| `templates/$DBNAME.enum.go.tpl`       | `Enum`       | Template for schema enum definitions                  |\n| `templates/$DBNAME.proc.go.tpl`       | `Proc`       | Template for stored procedures/functions ("routines") |\n| `templates/$DBNAME.foreignkey.go.tpl` | `ForeignKey` | Template for foreign keys relationships               |\n| `templates/$DBNAME.index.go.tpl`      | `Index`      | Template for schema indexes                           |\n| `templates/$DBNAME.querytype.go.tpl`  | `QueryType`  | Template for a custom query\'s generated type          |\n| `templates/$DBNAME.query.go.tpl`      | `Query`      | Template for custom query execution                   |\n| `templates/xo_db.go.tpl`              | `ArgType`    | Package level template generated once per package     |\n| `templates/xo_package.go.tpl`         | `ArgType`    | File header template generated once per file          |\n\nFor example, PostgreSQL has [`templates/postgres.foreignkey.go.tpl`](templates/postgres.foreignkey.go.tpl)\nwhich defines the template used by `xo` for PostgreSQL\'s foreign keys. This\ntemplate will be called once for every foreign key relationship that `xo` finds\nin a PostgreSQL schema, and each time the template will be passed a different\n`internal.ForeignKey` instance, populated fields for `Name`, `Schema`, etc.,\nwhich are then available in the `templates/postgres.foreignkey.go.tpl` as\ntemplate variables, and used similar to the following: `{{ .Name }}`, `{{ .Schema }}`,\netc.\n\nSince some of the templates are identical for the supported databases, the\ntemplates are not duplicated, but are instead symlinks in the `xo` source tree.\nFor example, [`templates/oracle.querytype.go.tpl`](templates/oracle.querytype.go.tpl)\nis a symlink to [`templates/postgres.querytype.go.tpl`](`templates/postgres.querytype.go.tpl`).\n\n#### Template Helpers\n\nThere is a set of well defined template helpers in [`internal/funcs.go`](internal/funcs.go)\nthat can assist with writing templated Go code / SQL. Please review how the\nbase [`templates/`](templates/) make use of helpers, and/or see the inline\ndocumentation for the respective helper func definitions.\n\n#### Packing Templates\n\nThe base `xo` templates are bin packed so that they are always available to the\nbuilt `xo` binary using [`go-bindata`](https://github.com/jteeuwen/go-bindata) (via\nthe [`tpl.sh`](tpl.sh) script) and need to be regenerated/included in any\nchangeset when submitting any template changes to the `xo` project.\n\nIf you would like to distribute your own binary version of `xo` with the\nincluded templates, simply modify the templates in the `xo` source tree, run\n`tpl.sh`, and build as you normally would.\n\nAlternatively, you can simply do the following:\n\n```sh\n$ go generate && go build\n```\n\n## Examples\n\n### Example: End-to-End\n\nPlease see the [booktest example](examples/booktest) for a full end-to-end\nexample for each supported database, showcasing how to use a database schema\nwith `xo`, and the resulting code generated by `xo`.\n\nAdditionally, please see the [pokedex example](examples/pokedex) for a\ndemonstration of running `xo` against a large schema. Please note that this\nexample is a work in progress, and does not yet work properly with Microsoft\nSQL Server and Oracle databases, and has no documentation (for now) -- however\nit works very similarly to the booktest end-to-end example.\n\n### Example: Ignoring Fields\n\nSometimes you may wish to have the database manage the values of columns\ninstead of having them managed by code generated by `xo`. As such, when you\nneed `xo` to ignore fields for a database schema, you can use the `--ignore-fields`\nflag. For example, a common use case is to define a table with `created_at`\nand/or `modified_at` timestamps, where the database is responsible for setting\ncolumn values on `INSERT` and `UPDATE`, respectively.\n\nConsider the following PostgreSQL schema where a `users` table has a\n`created_at` and `modified_at` field, where `created_at` has a default value of\n`now()` and where `modified_at` is updated by a trigger on `UPDATE`:\n\n```PLpgSQL\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  name text NOT NULL DEFAULT \'\' UNIQUE,\n  created_at timestamptz default now(),\n  modified_at timestamptz default now(),\n);\n\nCREATE OR REPLACE FUNCTION update_modified_column() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.modfified_at = now();\n    RETURN NEW;\nEND;\n$$ language \'plpgsql\';\n\nCREATE TRIGGER update_users_modtime BEFORE UPDATE ON users FROM EACH ROW EXECUTE PROCEDURE update_modified_column();\n```\n\nWe can ensure that these columns are managed by PostgreSQL and not by the Go\ncode generated with `xo` by passing the `--ignore-fields` option:\n\n```sh\n# ignore special fields\n$ xo pgsql://user:pass@host/db -o models --ignore-fields created_at modified_at\n```\n\n### Example: Custom Template -- adding a `GetMostRecent` lookup for all tables\n\nOften, a schema has a common layout/pattern, such as every table having a\n`created_at` and `modified_at` field (as in the PostgreSQL schema in the\nprevious example). It is then a common use-case to have a `GetMostRecent`\nlookup for each table type, retrieving the most recently modified rows for each\ntable (up to some limit, N).\n\nTo accomplish this with `xo`, we will need to create our own set of custom\ntemplates, and then add a `GetMostRecent` lookup to the `$DBTYPE.type.go.tpl`\ntemplate.\n\nFirst, we create a copy of the base `xo` templates:\n\n```sh\n$ cd $GOPATH/src/path/to/project\n\n$ mkdir -p templates\n\n$ cp $GOPATH/src/github.com/xo/xo/templates/* templates/\n```\n\nWe can now modify the templates to suit our specific schema, adding lookups,\nhelpers, or anything else necessary for our schema.\n\nTo add a `GetMostRecent` lookup, we edit our copy of the `postgres.type.go.tpl`\ntemplate:\n\n```sh\n$ vi templates/postgres.type.go.tpl\n```\n\nAnd add the following templated `GetMostRecent` func at the end of the file:\n\n```go\n// GetMostRecent{{ .Name }} returns n most recent rows from \'{{ .Schema }}.{{ .Table.TableName }}\',\n// ordered by "created_at" in descending order.\nfunc GetMostRecent{{ .Name }}(db XODB, n int) ([]*{{ .Name }}, error) {\n    const sqlstr = `SELECT ` +\n        `{{ colnames .Fields "created_at" "modified_at" }}` +\n        `FROM {{ $table }} ` +\n        `ORDER BY created_at DESC LIMIT $1`\n\n    q, err := db.Query(sqlstr, n)\n    if err != nil {\n        return nil, err\n    }\n    defer q.Close()\n\n    // load results\n    var res []*{{ .Name }}\n    for q.Next() {\n        {{ $short }} := {{ .Name }}{}\n\n        // scan\n        err = q.Scan({{ fieldnames .Fields (print "&" $short) }})\n        if err != nil {\n            return nil, err\n        }\n\n        res = append(res, &{{ $short }})\n    }\n\n    return res, nil\n}\n```\n\nWe can then use the templates in conjunction with `xo` to generate our "model"\ncode:\n\n```sh\n$ xo pgsql://user:pass@localhost/dbname -o models --template-path templates/\n```\n\nThere will now be a `GetMostRecentUsers` func defined in `models/user.xo.go`,\nwhich can be used as follows:\n\n```go\ndb, err := dburl.Open("pgsql//user:pass@localhost/dbname")\nif err != nil { /* ... */ }\n\n// retrieve 15 most recent items\nmostRecentUsers, err := models.GetMostRecentUsers(db, 15)\nif err != nil { /* ... */ }\nfor _, user := range users {\n    log.Printf("got user: %+v", user)\n}\n```\n\n## Using SQL Drivers\n\nPlease note that the base `xo` templates do not import any SQL drivers. It is\nleft for the user of `xo`\'s generated code to import the actual drivers. For\nreference, these are the expected drivers to use with the code generated by\n`xo`:\n\n| Database (driver)            | Package                                                                      |\n|------------------------------|------------------------------------------------------------------------------|\n| Microsoft SQL Server (mssql) | [github.com/denisenkom/go-mssqldb](https://github.com/denisenkom/go-mssqldb) |\n| MySQL (mysql)                | [github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)     |\n| Oracle (ora)                 | [gopkg.in/rana/ora.v4](https://gopkg.in/rana/ora.v4)                         |\n| PostgreSQL (postgres)        | [github.com/lib/pq](https://github.com/lib/pq)                               |\n| SQLite3 (sqlite3)            | [github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)           |\n\nAdditionally, please see below for usage notes on specific SQL database\ndrivers.\n\n### MySQL (mysql)\n\nIf your schema or custom query contains table or column names that need to be\nescaped using any of the `--escape-*` options, you must pass the `sql_mode=ansi`\noption to the MySQL driver:\n\n```sh\n$ xo --escape-all \'mysql://user:pass@host/?parseTime=true&sql_mode=ansi\' -o models\n```\n\nAnd when opening a database connection:\n\n```go\ndb, err := dburl.Open("mysql://user:pass@host/?parseTime=true&sql_mode=ansi")\n```\n\nAdditionally, when working with date/time column types in MySQL, one should\npass the `parseTime=true` option to the MySQL driver:\n\n```sh\n$ xo \'mysql://user:pass@host/dbname?parseTime=true\' -o models\n```\n\nAnd when opening a database connection:\n\n```go\ndb, err := dburl.Open("mysql://user:pass@host/dbname?parseTime=true")\n```\n\n### Oracle (ora)\n\nOracle support is disabled by default as the [Go Oracle driver](https://github.com/rana/ora)\nused by `xo` needs the Oracle `instantclient` libs to be installed/known by\n`pkg-config`. If you have already [installed rana\'s Oracle driver](https://github.com/rana/ora#installation)\naccording to the installation instructions, you can simply pass `-tags oracle`\nto `go get`, `go install` or `go build` to enable Oracle support:\n\n```sh\n$ go get -tags oracle -u github.com/xo/xo\n```\n\n#### Installing Oracle instantclient on Debian/Ubuntu\n\nOn Ubuntu/Debian, you may download the instantclient RPMs\n[here](http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html).\n\nYou should then be able to do the following:\n\n```sh\n# install alien, if not already installed\n$ sudo aptitude install alien\n\n# install the instantclient RPMs\n$ sudo alien -i oracle-instantclient-12.1-basic-*.rpm\n$ sudo alien -i oracle-instantclient-12.1-devel-*.rpm\n$ sudo alien -i oracle-instantclient-12.1-sqlplus-*.rpm\n\n# get xo\n$ go get -u github.com/xo/xo\n\n# copy oci8.pc from xo/contrib to system pkg-config directory\n$ sudo cp $GOPATH/src/github.com/xo/xo/contrib/oci8.pc /usr/lib/pkgconfig/\n\n# install rana\'s ora driver\n$ go get -u gopkg.in/rana/ora.v4\n\n# assuming the above succeeded, install xo with oracle support enabled\n$ go install -tags oracle github.com/xo/xo\n```\n\n#### Contrib Scripts and Oracle Docker Image\n\nIt\'s of note that there are additional scripts available in the\n[contrib](contrib/) directory that can help when working with Oracle databases\nand `xo`.\n\nFor reference, the `xo` developers use the [sath89/oracle-12c](https://hub.docker.com/r/sath89/oracle-12c/) Docker image\nfor testing `xo`\'s Oracle database support.\n\n### SQLite3 (sqlite3)\n\nWhile not required, one should specify the `loc=auto` option when using `xo`\nwith a SQLite3 database:\n\n```sh\n$ xo \'file:mydatabase.sqlite3?loc=auto\' -o models\n```\n\nAnd when opening a database connection:\n\n```go\ndb, err := dburl.Open("file:mydatabase.sqlite3?loc=auto")\n```\n\n## About Primary Keys\nFor row inserts `xo` determines whether the primary key is\nautomatically generated by the DB or must be provided by the application for the table row being inserted.\nFor example a table that has a primary key that is also a foreign key to another table, or a\ntable that has multiple primary keys in a many-to-many link table, it is desired that\nthe application provide the primary key(s) for the insert rather than the DB.\n\n`xo` will query the schema to determine if the database provides an automatic primary key\nand if the table does not provide one then it will require that the application provide the\nprimary key for the object passed to the the Insert method. Below is information on how\nthe logic works for each database type to determine if the DB automatically provides the PK.\n\n### MySQL Auto PK Logic\n* Checks for an autoincrement row in the information_schema for the table in question.\n\n### PostgreSQL Auto PK Logic\n* Checks for a sequence that is owned by the table in question.\n\n### SQLite Auto PK Logic\n* Checks the SQL that is used to generate the table contains\nthe *AUTOINCREMENT* keyword.\n* Checks that the table was created with the primary key type of *INTEGER*.\n\nIf either of the above conditions are satisfied then the PK is determined to be automatically provided\nby the DB. For the case of integer PK\'s when you want to override that the PK be manually provided\nthen you can define the key type as *INT* instead of *INTEGER*, for example as in the following many-to-many\nlink table:\n\n```sql\n  CREATE TABLE "SiteContacts" (\n  "ContactId"\tINT NOT NULL,\n  "SiteId"\tINT NOT NULL,\n  PRIMARY KEY(ContactId,SiteId),\n  FOREIGN KEY("ContactId") REFERENCES "Contacts" ( "ContactId" ),\n  FOREIGN KEY("SiteId") REFERENCES "Sites" ( "SiteId" )\n)\n```\n\n### SQL Server Auto PK Logic\n* Checks for an identity associated with one of the columns for the table in question.\n\n### Oracle Auto PK Logic\nThere is currently no method provided for Oracle as there is no programmatic way to query\nfor which sequences are associated with tables. All PK\'s will be assumed to be provided\nby the database.\n\n## About xo: Design, Origin, Philosophy, and History\n\n`xo` can likely get you 99% "of the way there" on medium or large database\nschemas and 100% of the way there for small or trivial database schemas. In\nshort, xo is a great launching point for developing standardized packages for\nstandard database abstractions/relationships, and xo\'s most common use-case is\nindeed in a code generation pipeline, ala `stringer`.\n\n### Design\n\n`xo` is **NOT** designed to be an ORM or to generate an ORM. Instead, `xo` is\ndesigned to vastly reduce the overhead/redundancy of (re-)writing types and\nfuncs for common database queries/relationships in Go -- it is not meant to be\na "silver bullet".\n\n### History\n\n`xo` was originally developed while migrating a large application written in\nPHP to Go. The schema in use in the original app, while well designed, had\nbecome inconsistent over multiple iterations/generations, mainly due to\ndifferent naming styles adopted by various developers/database admins over the\npreceding years. Additionally, some components had been written in different\nlanguages (Ruby, Java) and had also accumulated significant drift from the\noriginal application and accompanying schema. Simultaneously, a large amount of\ngrowth meant that the PHP/Ruby code could no longer efficiently serve the\ntraffic volumes.\n\nIn late 2014/early 2015, a decision was made to unify and strip out certain\nbackend services and to fully isolate the API from the original application,\nallowing the various components to instead speak to a common API layer instead\nof directly to the database, and to build that service layer in Go.\n\nHowever, unraveling the old PHP/Ruby/Java code became a large headache, as the\ncode, the database, and the API, all had significant drift -- thus, underlying\nfunction names, fields, and API methods no longer coincided with the actual\ndatabase schema, and were named differently in each language. As such, after a\nround of standardizing names, dropping cruft, and adding a small number of\nrelationship changes to the schema, the various codebases were fixed to match\nthe schema changes. After that was determined to be a success, the next target\nwas to rewrite the backend services in Go.\n\nIn order to keep a similar and consistent workflow for the developers, the\nprevious code generator (written in PHP and Twig templates) was modified to\ngenerate Go code. Additionally, at this time, but tangential to the story, the\nAPI definitions were ported from JSON to Protobuf to make use of its code\ngeneration abilities as well.\n\n`xo` is the open source version of that code generation tool, and is the fruits\nof those development efforts. It is hoped that others will be able to use and\nexpand `xo` to support other databases -- SQL or otherwise -- and that `xo` can\nbecome a common tool in any Go developer\'s toolbox.\n\n### Goals\n\nPart of `xo`\'s goals is to avoid writing an ORM, or an ORM-like in Go, and to\ninstead generate static, type-safe, fast, and idiomatic Go code across\nlanguages and databases. Additionally, the `xo` developers are of the opinion\nthat relational databases should have proper, well-designed relationships and\nall the related definitions should reside within the database schema itself:\nie, a "self-documenting" schema. `xo` is an end to that pursuit.\n\n## Related Projects\n\n* [dburl](https://github.com/xo/dburl) - a Go package providing a standard, URL style mechanism for parsing and opening database connection URLs\n* [usql](https://github.com/xo/usql) - a universal command-line interface for SQL databases\n\n### Other Projects\n\nThe following projects work with similar concepts as xo:\n\n#### Go Generators\n* [ModelQ](https://github.com/mijia/modelq)\n* [sqlgen](https://github.com/drone/sqlgen)\n* [squirrel](https://github.com/Masterminds/squirrel)\n* [scaneo](https://github.com/variadico/scaneo)\n* [acorn](https://github.com/willowtreeapps/acorn) and\n  [rootx](https://github.com/willowtreeapps/rootx) \\[[read overview\n  here](http://willowtreeapps.com/blog/go-generate-your-database-code/)\\]\n\n#### Go ORM-likes\n* [sqlc](https://github.com/relops/sqlc)\n\n## TODO\n* Completely refactor / fix code, templates, and other issues (PRIORITY #1)\n* Add (finish) stored proc support for Oracle + Microsoft SQL Server\n* Unit tests / code coverage / continuous builds for binary package releases\n* Move database introspection to separate package for reuse by other Go packages\n* Overhaul/standardize type parsing\n* Finish support for --{incl, excl}[ude] types\n* Write/publish template set for protobuf\n* Add support for generating models for other languages\n* Finish many-to-many and link table support\n* Finish example and code for generated *Slice types (also, only generate for the databases its needed for)\n* Add example for many-to-many relationships and link tables\n* Add support for supplying a file (ie, *.sql) for query generation\n* Add support for full text types (tsvector, tsquery on PostgreSQL)\n* Finish COMMENT support for PostgreSQL/MySQL and update templates accordingly.\n* Add support for JSON types (json, jsonb on PostgreSQL, json on MySQL)\n* Add support for GIN index queries (PostgreSQL)\n'