b'# Firebase Android Open Source Development\n\nThis repository contains a subset of the Firebase Android SDK source. It\ncurrently includes the following Firebase libraries, and some of their\ndependencies:\n\n  * `firebase-abt`\n  * `firebase-common`\n  * `firebase-common-ktx`\n  * `firebase-database`\n  * `firebase-database-ktx`\n  * `firebase-database-collection`\n  * `firebase-datatransport`\n  * `firebase-firestore`\n  * `firebase-firestore-ktx`\n  * `firebase-functions`\n  * `firebase-functions-ktx`\n  * `firebase-inappmessaging`\n  * `firebase-inappmessaging-ktx`\n  * `firebase-inappmessaging-display`\n  * `firebase-inappmessaging-display-ktx`\n  * `firebase-remote-config`\n  * `firebase-remote-config-ktx`\n  * `firebase-storage`\n  * `firebase-storage-ktx`\n\n\nFirebase is an app development platform with tools to help you build, grow and\nmonetize your app. More information about Firebase can be found at\nhttps://firebase.google.com.\n\n## Table of contents\n\n1. [Getting Started](#getting-started)\n1. [Testing](#testing)\n   1. [Unit Testing](#unit-testing)\n   1. [Integration Testing](#integration-testing)\n1. [Proguarding](#proguarding)\n   1. [APIs used via reflection](#APIs-used-via-reflection)\n   1. [APIs intended for developer\n   consumption](#APIs-intended-for-developer-consumption)\n   1. [APIs intended for other Firebase\n   SDKs](#APIs-intended-for-other-firebase-sdks)\n1. [Publishing](#publishing)\n   1. [Dependencies](#dependencies)\n   1. [Commands](#commands)\n1. [Code Formatting](#code-formatting)\n1. [Contributing](#contributing)\n\n## Getting Started\n\n* Install the latest Android Studio (should be 3.0.1 or later)\n* Clone the repo (`git clone git@github.com:firebase/firebase-android-sdk.git`)\n* Import the firebase-android-sdk gradle project into Android Studio using the\n  **Import project(Gradle, Eclipse ADT, etc.** option.\n\n## Testing\n\nFirebase Android libraries exercise all three types of tests recommended by the\n[Android Testing Pyramid](https://developer.android.com/training/testing/fundamentals#testing-pyramid).\nDepending on the requirements of the specific project, some or all of these\ntests may be used to support changes.\n\n### Unit Testing\n\nThese are tests that run on your machine\'s local Java Virtual Machine (JVM). At\nruntime, these tests are executed against a modified version of android.jar\nwhere all final modifiers have been stripped off. This lets us sandbox behaviors\nat desired places and use popular mocking libraries.\n\nUnit tests can be executed on the command line by running\n```bash\n./gradlew :<firebase-project>:check\n```\n\n### Integration Testing\n\nThese are tests that run on a hardware device or emulator. These tests have\naccess to Instrumentation APIs, give you access to information such as the\n[Android Context](https://developer.android.com/reference/android/content/Context).\nIn Firebase, instrumentation tests are used at different capacities by different\nprojects. Some tests may exercise device capabilities, while stubbing any calls\nto the backend, while some others may call out to nightly backend builds to\nensure distributed API compatibility.\n\nAlong with Espresso, they are also used to test projects that have UI\ncomponents.\n\n#### Project Setup\n\nBefore you can run integration tests, you need to add a `google-services.json`\nfile to the root of your checkout. You can use the `google-services.json` from\nany project that includes an Android App, though you\'ll likely want one that\'s\nseparate from any production data you have because our tests write random data.\n\nIf you don\'t have a suitable testing project already:\n\n  * Open the [Firebase console](https://console.firebase.google.com/)\n  * If you don\'t yet have a project you want to use for testing, create one.\n  * Add an Android app to the project\n  * Give the app any package name you like.\n  * Download the resulting `google-services.json` file and put it in the root of\n    your checkout.\n\n#### Running Integration Tests on Local Emulator\n\nIntegration tests can be executed on the command line by running\n```bash\n./gradlew :<firebase-project>:connectedCheck\n```\n\n#### Running Integration Tests on Firebase Test Lab\n\n> You need additional setup for this to work:\n>\n> * `gcloud` needs to be [installed](https://cloud.google.com/sdk/install) on local machine\n> * `gcloud` needs to be configured with a project that has billing enabled\n> * `gcloud` needs to be authenticated with credentials that have \'Firebase Test Lab Admin\' role\n\nIntegration tests can be executed on the command line by running\n```bash\n./gradlew :<firebase-project>:deviceCheck\n```\n\nThis will execute tests on devices that are configured per project, if nothing is configured for the\nproject, the tests will run on `model=Pixel2,version=27,locale=en,orientation=portrait`.\n\nProjects can be configured in the following way:\n\n```\nfirebaseTestLab {\n  // to get a list of available devices execute `gcloud firebase test android models list`\n  devices = [\n    \'<device1>\',\n    \'<device2>\',\n  ]\n}\n```\n\n## Annotations\n\nFirebase SDKs use some special annotations for tooling purposes.\n\n### @Keep\n\nAPIs that need to be preserved up until the app\'s runtime can be annotated with\n[@Keep](https://developer.android.com/reference/android/support/annotation/Keep).\nThe\n[@Keep](https://developer.android.com/reference/android/support/annotation/Keep)\nannotation is *blessed* to be honored by android\'s [default proguard\nconfiguration](https://developer.android.com/studio/write/annotations#keep).  A common use for\nthis annotation is because of reflection. These APIs should be generally **discouraged**, because\nthey can\'t be proguarded.\n\n### @KeepForSdk\n\nAPIs that are intended to be used by Firebase SDKs should be annotated with\n`@KeepForSdk`. The key benefit here is that the annotation is *blessed* to throw\nlinter errors on Android Studio if used by the developer from a non firebase\npackage, thereby providing a valuable guard rail.\n\n\n### @PublicApi\n\nWe annotate APIs that meant to be used by developers with\n[@PublicAPI](firebase-common/src/main/java/com/google/firebase/annotations/PublicApi.java).   This\nannotation will be used by tooling to help inform the version bump (major, minor, patch) that is\nrequired for the next release.\n\n## Proguarding\n\nFirebase SDKs do not proguard themselves, but support proguarding.   Firebase SDKs themselves are\nproguard friendly, but the dependencies of Firebase SDKs may not be.\n\n### Proguard config\n\nIn addition to preguard.txt, projects declare an additional set of proguard\nrules in a proguard.txt that are honored by the developer\'s app while building\nthe app\'s proguarded apk. This file typically contains the keep rules that need\nto be honored during the app\' s proguarding phase.\n\nAs a best practice, these explicit rules should be scoped to only libraries\nwhose source code is outside the firebase-android-sdk codebase making annotation\nbased approaches insufficient.The combination of keep rules resulting from the\nannotations, the preguard.txt and the proguard.txt collectively determine the\nAPIs that are preserved at **runtime**.\n\n## Publishing\n\nFirebase is published as a collection of libraries each of which either\nrepresents a top level product, or contains shared functionality used by one or\nmore projects. The projects are published as managed maven artifacts available\nat [Google\'s Maven Repository](https://maven.google.com). This section helps\nreason about how developers may make changes to firebase projects and have their\napps depend on the modified versions of Firebase.\n\n### Dependencies\n\nAny dependencies, within the projects, or outside of Firebase are encoded as\n[maven dependencies](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html)\ninto the `pom` file that accompanies the published artifact. This allows the\ndeveloper\'s build system (typically Gradle) to build a dependency graph and\nselect the dependencies using its own [resolution\nstrategy](https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html)\n\n### Commands\n\nThe simplest way to publish a project and all its associated dependencies is to\njust publish all projects. The following command builds SNAPSHOT dependencies of\nall projects. All pom level dependencies within the published artifacts will\nalso point to SNAPSHOT versions that are co-published.\n\n```bash\n./gradlew publishAllToLocal\n```\n\nDevelopers may take a dependency on these locally published versions by adding\nthe `mavenLocal()` repository to your [repositories\nblock](https://docs.gradle.org/current/userguide/declaring_repositories.html) in\nyour app module\'s build.gradle.\n\nFor more advanced use cases where developers wish to make changes to a project,\nbut have transitive dependencies point to publicly released versions, individual\nprojects may be published as follows.\n\n```bash\n# e.g. to publish Firestore and Functions\n./gradlew -PprojectsToPublish=":firebase-firestore,:firebase-functions" \\\n    publishProjectsToMavenLocal\n```\n\n### Code Formatting\n\nCode in this repo is formatted with the google-java-format tool. You can enable\nthis formatting in Android Studio by downloading and installing the\n[google-java-format plugin](https://github.com/google/google-java-format).\nThe plugin is disabled by default, but the repo contains configuration information\nand links to additional plugins.\n\nTo run formatting on your entire project you can run\n```bash\n./gradlew :<firebase-project>:googleJavaFormat\n```\n\n### Contributing\n\nWe love contributions! Please read our\n[contribution guidelines](/CONTRIBUTING.md) to get started.\n'