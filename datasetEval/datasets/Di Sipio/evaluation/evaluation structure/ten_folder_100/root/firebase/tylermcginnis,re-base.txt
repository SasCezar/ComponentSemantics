b'# re-base\n\n[![Build Status](https://travis-ci.org/tylermcginnis/re-base.svg?branch=master)](https://travis-ci.org/tylermcginnis/re-base)\n[![Coverage Status](https://coveralls.io/repos/github/tylermcginnis/re-base/badge.svg?branch=master)](https://coveralls.io/github/tylermcginnis/re-base?branch=master)\n\n![welcome](https://media.giphy.com/media/6459ZFRF1Wxna/giphy.gif)\n\nQuestions? Find me on twitter at [@tylermcginnis](http://twitter.com/tylermcginnis)\n\n# What is re-base?\n\nReact.js makes managing state easy to reason about. Firebase makes persisting your data easy to implement. re-base, inspired by Relay, combines the benefits of React and Firebase by allowing each component to specify its own data dependency. Forget about your data persistence and focus on what really matters, your application\'s state.\n\n# Why re-base?\n\nI spent a few weeks trying to figure out the cleanest way to implement Firebase into my React/Flux application. After struggling for a bit, I [tweeted](https://twitter.com/tylermcginnis33/status/605838057825132549) my frustrations. I was enlightened to the fact that Firebase and Flux really don\'t work well together. It makes sense why they don\'t work together, because they\'re both trying to accomplish roughly the same thing. So I did away with my reliance upon Flux and tried to think of a clean way to implement React with Firebase. I came across ReactFire built by Jacob Wenger at Firebase and loved his idea. Sync a Firebase endpoint with a property on your component\'s state. So whenever your data changes, your state will be updated. Simple as that. The problem with ReactFire is because it uses Mixins, it\'s not compatible with ES6 classes. After chatting with Jacob Turner, we wanted to create a way to allow the one way binding of ReactFire with ES6 classes along some more features like two way data binding and listening to Firebase endpoints without actually binding a state property to them. Thus, re-base was built.\n\n# Installing\n\n```bash\n$ npm install --save re-base firebase\n```\n\n# Examples\n\nFor more in depth examples, see the [`examples`](examples) folder.\n\n# API\n\n## Firebase Real Time Database\n\n### Overview\n\n- [_syncState_](#syncstateendpoint-options): Two way data binding between any property on your component\'s state and any endpoint in Firebase. Use the same API you\'re used to to update your component\'s state (setState), and Firebase will also update.\n- [_bindToState_](#bindtostateendpoint-options): One way data binding. When your Firebase endpoint changes, the property on your state will update as well.\n- [_listenTo_](#listentoendpoint-options): When your Firebase endpoint changes, it will invoke a callback passing it the new data from Firebase.\n- [_fetch_](#fetchendpoint-options): Retrieve data from Firebase without setting up any binding or listeners.\n- [_post_](#postendpoint-options): Add new data to Firebase.\n- [_push_](#pushendpoint-options): Push new child data to Firebase.\n- [_update_](#updateendpoint-options): Update child data using only the referenced properties\n- [_remove_](#removeendpoint-callback): Remove data from Firebase\n- [_removeBinding_](#removebindingref): Remove a Firebase listener before the component unmounts if you need to. (Listeners are automatically cleaned up when component unmounts)\n- [_reset_](#reset): Removes all of the Firebase listeners.\n\n### createClass(firebaseDatabase)\n\n##### Purpose\n\nAccepts an initialized firebase database object\n\n##### Arguments\n\n1.  initialized firebase database (Object)\n\n##### Return Value\n\nAn instance of re-base.\n\n##### Example using all of firebase\n\n```javascript\nvar Rebase = require(\'re-base\');\nvar firebase = require(\'firebase\');\nvar app = firebase.initializeApp({\n  apiKey: \'apiKey\',\n  authDomain: \'projectId.firebaseapp.com\',\n  databaseURL: \'https://databaseName.firebaseio.com\',\n  storageBucket: \'bucket.appspot.com\',\n  messagingSenderId: \'xxxxxxxxxxxxxx\'\n});\nvar base = Rebase.createClass(app.database());\n```\n\n##### Example using only the firebase database component\n\n```javascript\nvar Rebase = require(\'re-base\');\nvar firebase = require(\'firebase/app\');\nvar database = require(\'firebase/database\');\nvar app = firebase.initializeApp({\n  apiKey: \'apiKey\',\n  authDomain: \'projectId.firebaseapp.com\',\n  databaseURL: \'https://databaseName.firebaseio.com\',\n  storageBucket: \'bucket.appspot.com\',\n  messagingSenderId: \'xxxxxxxxxxxxxx\'\n});\nvar db = firebase.database(app);\nvar base = Rebase.createClass(db);\n```\n\n<br />\n\n### initializedApp\n\n##### Purpose\n\nThis property contains the initialized firebase app that was passed into re-base. You can access any of the firebase services that you are using off this object. For instance, if you want to use some firebase `database` methods that re-base doesn\'t have helpers for or if you are using the `auth` service and want to quickly access it off of re-base.\n\n<br />\n\n### timestamp\n\n##### Purpose\n\nThis property contains an object that you can use when adding data that will be converted to a timestamp by Firebase. See [the docs](https://firebase.google.com/docs/reference/js/firebase.database.ServerValue) for more info.\n\n<br />\n\n### syncState(endpoint, options)\n\n##### Purpose\n\nAllows you to set up two way data binding between your component\'s state and your Firebase. Whenever your Firebase changes, your component\'s state will change. Whenever your component\'s state changes, Firebase will change.\n\n##### Arguments\n\n1.  endpoint (String)\n    - The relative Firebase endpoint to which you\'d like to bind your component\'s state\n2.  options (Object)\n    - context: (Object - required) The context of your component\n    - state: (String - required) The state property you want to sync with Firebase; can be an arbitrarily nested property a l\xc3\xa0 `foo.bar`\n    - defaultValue: (String|Boolean|Number|Object - optional) A default value to set when the Firebase endpoint has no value (i.e., on init) (use this if you want a value other than an empty object or empty array)\n    - asArray: (Boolean - optional) Returns the Firebase data at the specified endpoint as an Array instead of an Object\n    - keepKeys: (Boolean - optional) will keep any firebase generated keys intact when manipulating data using the asArray option.\n    - queries: (Object - optional) Queries to be used with your read operations. See [Query Options](#queries) for more details.\n    - then: (Function - optional) The callback function that will be invoked when the initial listener is established with Firebase. Typically used (with syncState) to change `this.state.loading` to false.\n    - onFailure: (Function - optional) A callback function that will be invoked if the current user does not have read or write permissions at the location.\n\n##### Return Value\n\nAn object which you can pass to `removeBinding` if you want to remove the listener while the component is still mounted.\n\n##### Example\n\n```javascript\ncomponentDidMount(){\n  base.syncState(`shoppingList`, {\n    context: this,\n    state: \'items\',\n    asArray: true\n  });\n}\naddItem(newItem){\n  this.setState({\n    items: this.state.items.concat([newItem]) //updates Firebase and the local state\n  });\n}\n```\n\n<br />\n\n### bindToState(endpoint, options)\n\n##### Purpose\n\nOne way data binding from Firebase to your component\'s state. Allows you to bind a component\'s state property to a Firebase endpoint so whenever that Firebase endpoint changes, your component\'s state will be updated with that change.\n\n##### Arguments\n\n1.  endpoint (String)\n    - The relative Firebase endpoint that you\'d like to bind to your component\'s state\n2.  options (Object)\n    - context: (Object - required) The context of your component\n    - state: (String - required) The state property you want to sync with Firebase; can be an arbitrarily nested property a l\xc3\xa0 `foo.bar` (no arrays)\n    - asArray: (Boolean - optional) Returns the Firebase data at the specified endpoint as an Array instead of an Object\n    - queries: (Object - optional) Queries to be used with your read operations. See [Query Options](#queries) for more details.\n    - then: (Function - optional) The callback function that will be invoked when the initial listener is established with Firebase. Typically used (with bindToState) to change `this.state.loading` to false.\n    - onFailure: (Function - optional) A callback function that will be invoked if the current user does not have read permissions at the location.\n\n##### Return Value\n\nAn object which you can pass to `removeBinding` if you want to remove the listener while the component is still mounted.\n\n##### Example\n\n```javascript\ncomponentDidMount(){\n  base.bindToState(\'tasks\', {\n    context: this,\n    state: \'tasks\',\n    asArray: true\n  });\n}\n```\n\n<br />\n\n### listenTo(endpoint, options)\n\n##### Purpose\n\nAllows you to listen to Firebase endpoints without binding those changes to a state property. Instead, a callback will be invoked with the newly updated data.\n\n##### Arguments\n\n1.  endpoint (String)\n    - The relative Firebase endpoint which contains the data with which you\'d like to invoke your callback function\n2.  options (Object)\n    - context: (Object - required) The context of your component\n    - asArray: (Boolean - optional) Returns the Firebase data at the specified endpoint as an Array instead of an Object\n    - then: (Function - required) The callback function that will be invoked with the data from the specified endpoint when the endpoint changes\n    - onFailure: (Function - optional) The callback function that will be invoked if the current user does not have read permissions at the location.\n    - queries: (Object - optional) Queries to be used with your read operations. See [Query Options](#queries) for more details.\n\n##### Return Value\n\nAn object which you can pass to `removeBinding` when your component unmounts to remove the Firebase listeners.\n\n##### Example\n\n```javascript\ncomponentDidMount(){\n  base.listenTo(\'votes\', {\n    context: this,\n    asArray: true,\n    then(votesData){\n      var total = 0;\n      votesData.forEach((vote, index) => {\n        total += vote\n      });\n      this.setState({total});\n    }\n  })\n}\n```\n\n<br />\n\n### fetch(endpoint, options)\n\n##### Purpose\n\nAllows you to retrieve the data from a Firebase endpoint just once without subscribing or listening for data changes.\n\n##### Arguments\n\n1.  endpoint (String)\n    - The relative Firebase endpoint which contains the data you\'re wanting to fetch\n2.  options (Object)\n    - context: (Object - optional) The context of your component\n    - asArray: (Boolean - optional) Returns the Firebase data at the specified endpoint as an Array instead of an Object\n    - then: (Function - optional) The callback function that will be invoked with the data from the specified endpoint when the endpoint changes\n    - onFailure: (Function - optional) The callback function that will be invoked with an error that occurs reading data from the specified endpoint\n    - queries: (Object - optional) Queries to be used with your read operations. See [Query Options](#queries) for more details.\n\n##### Return Value\n\nA Firebase [Promise](https://firebase.google.com/docs/reference/js/firebase.Promise) which resolves when the write is complete and rejects if there is an error\n\n##### Example\n\n_Using callback_\n\n```javascript\ngetSales(){\n  base.fetch(\'sales\', {\n    context: this,\n    asArray: true,\n    then(data){\n      console.log(data);\n    }\n  });\n}\n```\n\n_Using Promise_\n\n```javascript\ngetSales(){\n  base.fetch(\'sales\', {\n    context: this,\n    asArray: true\n  }).then(data => {\n    console.log(data);\n  }).catch(error => {\n    //handle error\n  })\n}\n```\n\n<br />\n\n### post(endpoint, options)\n\n##### Purpose\n\nAllows you to update a Firebase endpoint with new data. _Replace all the data at this endpoint with the new data_\n\n##### Arguments\n\n1.  endpoint (String)\n    - The relative Firebase endpoint that you\'d like to update with the new data\n2.  options (Object)\n    - data: (Any - required) The data you\'re wanting to persist to Firebase\n    - then: (Function - optional) A callback that will get invoked once the new data has been saved to Firebase. If there is an error, it will be the only argument to this function.\n\n##### Return Value\n\nA Firebase [Promise](https://firebase.google.com/docs/reference/js/firebase.Promise) which resolves when the write is complete and rejects if there is an error\n\n##### Example\n\n_Using callback_\n\n```javascript\naddUser(){\n  base.post(`users/${userId}`, {\n    data: {name: \'Tyler McGinnis\', age: 25},\n    then(err){\n      if(!err){\n        Router.transitionTo(\'dashboard\');\n      }\n    }\n  });\n}\n```\n\n_Using promise_\n\n```javascript\naddUser(){\n  base.post(`users/${userId}`, {\n    data: {name: \'Tyler McGinnis\', age: 25}\n  }).then(() => {\n    Router.transitionTo(\'dashboard\');\n  }).catch(err => {\n    // handle error\n  });\n}\n```\n\n<br />\n\n### push(endpoint, options)\n\n##### Purpose\n\nAllows you to add data to a Firebase endpoint. _Adds data to a child of the endpoint with a new Firebase push key_\n\n##### Arguments\n\n1.  endpoint (String)\n    - The relative Firebase endpoint that you\'d like to push the new data to\n2.  options (Object)\n    - data: (Any - required) The data you\'re wanting to persist to Firebase\n    - then: (Function - optional) A callback that will get invoked once the new data has been saved to Firebase. If there is an error, it will be the only argument to this function.\n\n##### Return Value\n\nA Firebase [ThenableReference](https://firebase.google.com/docs/reference/js/firebase.database.ThenableReference)\nwhich is defined by Firebase as a "Combined Promise and reference; resolves when write is complete, but can be used immediately as the reference to the child location."\n\n##### Example\n\n_Using callback_\n\n```javascript\n//\naddBear(){\n  var immediatelyAvailableReference = base.push(\'bears\', {\n    data: {name: \'George\', type: \'Grizzly\'},\n    then(err){\n      if(!err){\n        Router.transitionTo(\'dashboard\');\n      }\n    }\n  });\n  //available immediately, you don\'t have to wait for the callback to be called\n  var generatedKey = immediatelyAvailableReference.key;\n}\n```\n\n_Using Promise interface_\n\n```javascript\n//\naddBear(){\n  var immediatelyAvailableReference = base.push(\'bears\', {\n    data: {name: \'George\', type: \'Grizzly\'}\n  }).then(newLocation => {\n    var generatedKey = newLocation.key;\n  }).catch(err => {\n    //handle error\n  });\n  //available immediately, you don\'t have to wait for the Promise to resolve\n  var generatedKey = immediatelyAvailableReference.key;\n}\n```\n\n<br />\n\n### update(endpoint, options)\n\n##### Purpose\n\nAllows you to update data at a Firebase endpoint changing only the properties you pass to it.\n**Warning: calling update with `options.data` being null will remove all the data at that endpoint**\n\n##### Arguments\n\n1.  endpoint (String)\n    - The relative Firebase endpoint that you\'d like to update\n2.  options (Object)\n    - data: (Any - required) The data you\'re wanting to persist to Firebase\n    - then: (Function - optional) A callback that will get invoked once the new data has been saved to Firebase. If there is an error, it will be the only argument to this function.\n\n##### Return Value\n\nA Firebase [Promise](https://firebase.google.com/docs/reference/js/firebase.Promise) which resolves when the write is complete and rejects if there is an error\n\n##### Example\n\n_Using callback_\n\n```javascript\n// bears endpoint currently holds the object { name: \'Bill\', type: \'Grizzly\' }\nbase.update(\'bears\', {\n  data: { name: \'George\' },\n  then(err) {\n    if (!err) {\n      Router.transitionTo(\'dashboard\');\n      //bears endpint is now {name: \'George\', type: \'Grizzly\'}\n    }\n  }\n});\n```\n\n_Using Promise_\n\n```javascript\n// bears endpoint currently holds the object { name: \'Bill\', type: \'Grizzly\' }\nbase\n  .update(\'bears\', {\n    data: { name: \'George\' }\n  })\n  .then(() => {\n    Router.transitionTo(\'dashboard\');\n  })\n  .catch(err => {\n    //handle error\n  });\n```\n\n<br />\n\n### remove(endpoint, callback)\n\n##### Purpose\n\nAllows you to delete all data at the endpoint location\n\n##### Arguments\n\n1.  endpoint (String)\n    - The relative Firebase endpoint that you\'d like to delete data from\n2.  callback (Function - optional)\n    - A callback that will get invoked once the data is successfully removed Firebase. If there is an error, it will be the only argument to this function.\n\n##### Return Value\n\nA Firebase [Promise](https://firebase.google.com/docs/reference/js/firebase.Promise) which resolves when the deletion is complete and rejects if there is an error\n\n##### Example\n\n_Using callback_\n\n```javascript\nbase.remove(\'bears\', function(err) {\n  if (!err) {\n    Router.transitionTo(\'dashboard\');\n  }\n});\n```\n\n_Using Promise_\n\n```javascript\nbase\n  .remove(\'bears\')\n  .then(() => {\n    Router.transitionTo(\'dashboard\');\n  })\n  .catch(error => {\n    //handle error\n  });\n```\n\n<br />\n\n### removeBinding(ref)\n\n##### Purpose\n\nClean up a listener. Listeners are automatically cleaned up when components unmount, however if you wish to remove a listener while the component is still mounted this will allow you to do that. An example would be if you want to start listening to a new endpoint in response to a prop change.\n\n##### Arguments\n\n1.  ref (Object)\n    - The return value of `syncState`, `bindToState`, or `listenTo`\n\n##### Return Value\n\nNo return value\n\n##### Example\n\n```javascript\ncomponentDidMount(){\n  this.ref = base.syncState(\'users\', {\n    context: this,\n    state: \'users\'\n  });\n}\ncomponentWillUnmount(){\n  base.removeBinding(this.ref);\n}\n```\n\n<br />\n\n### reset()\n\n##### Purpose\n\nRemoves every Firebase listener and resets all private variables.\n\n##### Arguments\n\nNo Arguments\n\n##### Return Value\n\nNo return value\n\n<br />\n\n### <a name=\'queries\'>Using Firebase Queries</a>\n\nUse the query option to utilize the [Firebase Query](https://firebase.google.com/docs/reference/js/firebase.database.Query) API. For a list of available queries and how they work, see the Firebase docs.\n\nQueries are accepted in the `options` object of each read method (`syncState`, `bindToState`, `listenTo`, and `fetch`). The object should have one or more keys of the type of query you wish to run, with the value being the value for the query. For example:\n\n```javascript\nbase.syncState(\'users\', {\n  context: this,\n  state: \'users\',\n  asArray: true,\n  queries: {\n    orderByChild: \'iq\',\n    limitToLast: 3\n  }\n});\n```\n\nThe binding above will sort the `users` endpoint by iq, retrieve the last three (or, three with highest iq), and bind it to the component\'s `users` state. NOTE: This query is happening within Firebase. The _only_ data that will be retrieved are the three users with the highest iq.\n\n## Firestore\n\n### Overview\n\n- [_createClass_](#createclassfirestoredatebase) : Initialize the re-base instance\n- [_bindDoc_](#binddocreforpath-options) : One way data binding. When your Document changes, your component will update with the new data.\n- [_listenToDoc_](#listentodocreforpath-options) : One way data binding. When your Document changes, it will invoke a callback passing it the new data.\n- [_bindCollection_](#bindcollectionreforpath-options) : One way binding. When the collection changes, your component will update with the new data.\n- [_listenToCollection_](#listentocollectionreforpath-options): One way binding. When the collection changes, it will invoke a callback passing it the new data.\n- [_get_](#getreforpath-options) : Fetch either a Collection or Document.\n- [_addToCollection_](#addtocollectionreforpath-data-id) : Add a new document to a collection.\n- [_updateDoc_](#updatedocreforpath-data) : Add a new document to a collection.\n- [_removeDoc_](#removedocreforpath) : Deletes a document.\n- [_removeFromCollection_](#removefromcollectionreforpath-options) : Deletes documents from a collection.\n- [_syncDoc_](#syncdocreforpath-options) : Syncs a components local state with a document (Read and Write)\n- [_removeBinding_](#fs-remove-binding): Remove a Firebase listener before the component unmounts if you need to. (Listeners are automatically cleaned up when component unmounts)\n- [_reset_](#fs-reset): Removes all Firestore listeners.\n\n### createClass(firestoreDatabase)\n\n##### Purpose\n\nAccepts an initialized firebase database object\n\n##### Arguments\n\n1.  initialized firestore database (Object)\n\n##### Return Value\n\nAn instance of re-base (with the Firestore methods available)\n\n##### Example using all of firebase\n\n```javascript\nvar Rebase = require(\'re-base\');\nvar firebase = require(\'firebase\');\nrequire(\'firebase/firestore\');\nvar app = firebase.initializeApp({\n  apiKey: \'apiKey\',\n  authDomain: \'projectId.firebaseapp.com\',\n  databaseURL: \'https://databaseName.firebaseio.com\',\n  storageBucket: \'bucket.appspot.com\',\n  messagingSenderId: \'xxxxxxxxxxxxxx\'\n});\n\nvar firestore = app.firestore();\nvar settings = { timestampsInSnapshots: true };\nfirestore.settings(settings);\n\nvar base = Rebase.createClass(firestore);\n```\n\n##### Example using only the firestore component\n\n```javascript\nvar Rebase = require(\'re-base\');\nvar firebase = require(\'firebase/app\');\nrequire(\'firebase/firestore\');\nvar app = firebase.initializeApp({\n  apiKey: \'apiKey\',\n  authDomain: \'projectId.firebaseapp.com\',\n  databaseURL: \'https://databaseName.firebaseio.com\',\n  storageBucket: \'bucket.appspot.com\',\n  messagingSenderId: \'xxxxxxxxxxxxxx\'\n});\n\nvar db = firebase.firestore(app);\nvar settings = { timestampsInSnapshots: true };\ndb.settings(settings);\n\nvar base = Rebase.createClass(db);\n```\n\n### initializedApp\n\n##### Purpose\n\nThis property contains the initialized firebase app that was passed into re-base. You can access any of the firebase services that you are using off this object. For instance, if you are using the `auth` service and want to quickly access it off of re-base\n\n<br />\n\n### timestamp\n\n##### Purpose\n\nThis property contains the an object that you can use when adding data that will be converted to a timestamp by Firestore. See [the docs](https://firebase.google.com/docs/reference/js/firebase.firestore.FieldValue#.serverTimestamp) for more info.\n\n<br />\n\n## Reading Data\n\n### bindDoc(refOrPath, options)\n\n##### Purpose\n\nBind a document to your component. When then document changes in firestore, your component will re-render with the latest data.\n\n##### Arguments\n\n- DocumentReference or path (DocumentReference or String)\n- options (Object)\n  - context: (Object - required) your react component\n  - state: (String - optional) a property name on your state to bind your document to, if omitted the document will be merged into your existing state\n  - then: (Function - optional) a callback that will be called when the listener is set, use for loading indicators\n  - onFailure: (Function - optional) a callback that will be called with any errors such as permissions errors\n\n##### Return Value\n\nAn object which you can pass to `removeBinding` if you want to remove the listener while the component is still mounted.\n\n##### Example\n\n```javascript\ncomponentWillMount() {\n  base.bindDoc(\'myCollection/myDocument\', {\n    context: this,\n    then() {\n      this.setState({\n        loading: false\n      })\n    },\n    onFailure(err) {\n      //handle error\n    }\n  });\n}\n```\n\n### listenToDoc(refOrPath, options)\n\n##### Purpose\n\nListen to a document, when the data changes it will invoke a callback passing it the new data from Firestore.\n\n##### Arguments\n\n1.  DocumentReference or path (DocumentReference or String)\n2.  options (Object)\n    - context: (Object - required) your react component\n    - then: (Function - required) a callback that will be called with the data from Firestore\n    - onFailure: (Function - optional) a callback that will be called with any errors such as permissions errors\n\n##### Return Value\n\nAn object which you can pass to `removeBinding` if you want to remove the listener while the component is still mounted.\n\n##### Example\n\n```javascript\ncomponentWillMount() {\n  base.listenToDoc(\'myCollection/myDocument\', {\n    context: this,\n    then(data) {\n      //do something with the data\n    },\n    onFailure(err) {\n      //handle error\n    }\n  });\n}\n```\n\n### bindCollection(refOrPath, options)\n\n##### Purpose\n\nBind a collection to a state property in your component. When then collection changes in firestore, your component will re-render with the latest data.\n\n##### Arguments\n\n1.  CollectionReference or path (DocumentReference or String)\n2.  options (Object)\n    - context : (Object - required) your react component\n    - state : (String - required) the state property to bind the collection to.\n    - query : (Function - optional) a function that receives the created ref as its only argument. You can chain any Firestore queries you want to perform. See [Using Firestore Queries](#firestorequeries)\n    - withIds : (Boolean - optional) will embed firestore generated document ids inside each document in your collections on the `id` property.\n    - withRefs : (Boolean - optional) will embed the DocumentReference inside each document in your collection on the `ref` property.\n    - then : (Function - optional) a callback that will be called when the listener is set, use for loading indicators\n    - onFailure : (Function - optional) a callback that will be called with any errors such as permissions errors\n\n##### Return Value\n\nAn object which you can pass to `removeBinding` if you want to remove the listener while the component is still mounted.\n\n##### Example\n\n```javascript\ncomponentWillMount() {\n  base.bindCollection(\'myCollection\', {\n    context: this,\n    state: \'users\',\n    withRefs: true,\n    withIds: true,\n    query: (ref) => ref.where(\'type\', \'==\', \'subscriber\'),\n    then(data) {\n     this.setState(state => ({\n       ...state,\n       loading: false\n     }))\n    },\n    onFailure(err) {\n      //handle error\n    }\n  });\n}\n```\n\n### listenToCollection(refOrPath, options)\n\n##### Purpose\n\nListen to a collection, when the data changes it will invoke a callback passing it the new data from Firestore.\n\n##### Arguments\n\n1.  CollectionReference or path (CollectionReference or String)\n2.  options (Object)\n    - context : (Object - required) your react component\n    - then : (Function - required) a callback that will be called with the data\n    - query : (Function - optional) a function that receives the created ref as its only argument. You can chain any Firestore queries you want to perform. See [Using Firestore Queries](#firestorequeries)\n    - withIds : (Boolean - optional) will embed firestore generated document ids inside each document in your collections on the `id` property.\n    - withRefs : (Boolean - optional) will embed the DocumentReference inside each document in your collection on the `ref` property.\n    - onFailure : (Function - optional) a callback that will be called with any errors such as permissions errors\n\n##### Return Value\n\nAn object which you can pass to `removeBinding` if you want to remove the listener while the component is still mounted.\n\n##### Example\n\n```javascript\ncomponentWillMount() {\n  base.listenToCollection(\'myCollection\', {\n    context: this,\n    query: (ref) => ref.where(\'type\', \'==\', \'subscriber\'),\n    then(data) {\n     // do something with the data\n    },\n    onFailure(err) {\n      //handle error\n    }\n  });\n}\n```\n\n### get(refOrPath, options)\n\n##### Purpose\n\nFetch either a Collection or Document.\n\n##### Arguments\n\n1.  CollectionReference, DocumentReference or path (CollectionReference, DocumentReference or String)\n2.  options (Object) only available on collections.\n    - query : (Function - optional) a function that receives the created ref\n    - withIds : (Boolean - optional) will embed firestore generated document ids inside each document in your collections on the `id` property.\n    - withRefs : (Boolean - optional) will embed the DocumentReference inside each document in your collection on the `ref` property.\n\n##### Return Value\n\nA Promise thats resolve with the resulting data or rejects if the document/collection does not exist or there are any read errors.\n\n##### Example\n\n```javascript\ncomponentWillMount() {\n  base.get(collectionRef, {\n    context: this,\n    query: (ref) => ref.where(\'type\', \'==\', \'subscriber\'),\n  }).then(data => {\n    //do something with data\n  }).catch(err => {\n    //handle error\n  })\n}\n```\n\n## Writing Data\n\n### addToCollection(refOrPath, data, id)\n\n##### Purpose\n\nAdd a new Document to a Collection.\n\n##### Arguments\n\n1.  CollectionReference or path (CollectionReference or String)\n2.  Data (Object) the document data\n3.  ID (String - optional) the id for the document. If omitted, the Firestore will generate an id for you.\n\n##### Return Value\n\nA Promise that resolves when the write is complete or rejects with any error such as a permissions error.\n\n##### Example\n\n```javascript\ncomponentWillMount() {\n  base.addToCollection(\'myCollection\', data, \'myCustomId\')\n    .then(() => {\n      //document is added to the collection\n    }).catch(err => {\n    //handle error\n  });\n}\n```\n\n### updateDoc(refOrPath, data)\n\n##### Purpose\n\nUpdate an existing document\n\n##### Arguments\n\n1.  DocumentReference or path (DocumentReference or String)\n2.  Data (Object) the document data\n\n##### Return Value\n\nA Promise thats resolve when the write is complete or rejects with any error such as a permissions error.\n\n##### Example\n\n```javascript\ncomponentWillMount() {\n  base.updateDoc(\'myCollection/myDoc\', data)\n    .then(() => {\n      //document is updated\n    }).catch(err => {\n    //handle error\n  });\n}\n```\n\n### removeDoc(refOrPath)\n\n##### Purpose\n\nDeletes a document\n\n##### Arguments\n\n1.  DocumentReference or path (DocumentReference or String)\n\n##### Return Value\n\nA Promise thats resolve when the document is delete or rejects with any error such as a permissions error\n\n##### Example\n\n```javascript\ncomponentWillMount() {\n  base.removeDoc(\'myCollection/myDoc\')\n    .then(() => {\n      //document is deleted\n    }).catch(err => {\n    //handle error\n  });\n}\n```\n\n### removeFromCollection(refOrPath, options)\n\n##### Purpose\n\nRemoves documents from a collection. If no query is supplied, it will remove all the documents. If a query is supplied, it will only remove documents that match the query.\n\n##### Arguments\n\n1.  CollectionReference or path (CollectionReference or String)\n2.  options (Object)\n    - query : (Function - optional) a function that receives the created ref as its only argument. You can chain any Firestore queries you want to perform. See [Using Firestore Queries](#firestorequeries)\n\n##### Return Value\n\nA Promise thats resolve when the write is complete or rejects with any error such as a permissions error.\n\n##### Example\n\n```javascript\ncomponentWillMount() {\n  base.bindCollection(\'myCollection\', {\n    context: this,\n    state: \'users\',\n    withRefs: true,\n    withIds: true,\n    query: (ref) => ref.where(\'type\', \'==\', \'subscriber\'),\n    then(data) {\n     this.setState(state => ({\n       ...state,\n       loading: false\n     }))\n    },\n    onFailure(err) {\n      //handle error\n    }\n  });\n}\n```\n\n## Sync Data\n\n### syncDoc(refOrPath, options)\n\n##### Purpose\n\nSyncs a component\'s local state with a document in Firestore.\n\n##### Arguments\n\n1.  DocumentReference or path (DocumentReference or String)\n2.  options (Object)\n    - context : (Object - required) your react component\n    - state : (String - required) the state property to sync\n    - then : (Function - optional) a callback that will be called when the listener is set, use for loading indicators\n    - onFailure : (Function - optional) a callback that will be called with any errors such as permissions errors\n\n##### Return Value\n\nAn object which you can pass to `removeBinding` if you want to remove the listener while the component is still mounted.\n\n##### Example\n\n```javascript\ncomponentWillMount() {\n  base.syncDoc(\'myCollection/myDoc\', data)\n    .then(() => {\n      //document is updated\n    }).catch(err => {\n    //handle error\n  });\n}\n```\n\n## Remove Listeners\n\n### <a name="fs-remove-binding">removeBinding(ref)</a>\n\n##### Purpose\n\nClean up a listener. Listeners are automatically cleaned up when components unmount, however if you wish to remove a listener while the component is still mounted this will allow you to do that. An example would be if you want to start listening to a new document or change a query on all collection in response to a prop change.\n\n##### Arguments\n\n1.  ref (Object)\n\n- The return value of `listenToCollection`, `bindCollection`, `listenToDoc`,`bindDoc` or `syncDoc`\n\n##### Return Value\n\nNo return value\n\n##### Example\n\n```javascript\ncomponentDidMount(){\n  this.ref = base.syncDoc(\'users/user-1-doc\',\n    context: this,\n    state: \'users\'\n  });\n}\ncomponentWillUnmount(){\n  base.removeBinding(this.ref);\n}\n```\n\n<br />\n\n### <a name="fs-reset">reset()</a>\n\n##### Purpose\n\nRemoves every Firestore listener.\n\n##### Arguments\n\nNo Arguments\n\n##### Return Value\n\nNo return value\n\n<br />\n\n### <a name=\'firestorequeries\'>Using Firestore Queries</a>\n\nUse the query option to utilize the [Firestore Query](https://firebase.google.com/docs/reference/js/firebase.firestore.Query) API. For a list of available queries and how they work, see the Firestore docs.\n\nQueries are accepted in the `options` object of each collection read method (`listenToCollection`, `bindCollection`, `get(Collection)`). You can also use them with `removeFromCollection` to remove documents that match the query\n\nThe query options takes a function that will receive the collection reference as its only argument. You can then apply any of the available methods you with to run and must return the reference.\n\n```javascript\nbase.bindCollection(\'users\', {\n  state: \'users\',\n  context: this,\n  query: ref => {\n    return ref\n      .where(\'type\', \'==\', \'subscriber\')\n      .where(\'joined\', \'>\', yesterday)\n      .orderBy(\'joined\');\n  }\n});\n```\n\n## <a name=\'upgrading-4.x\'>Upgrading to re-base 4.x from 3.x</a>\n\n### Major Changes:\n\n4.x no longer defines firebase as a direct dependency but rather a peerDependency. You need to install firebase and handle updates in your own project.\n\n## <a name=\'upgrading-3.x\'>Upgrading to re-base 3.x from 2.x</a>\n\n### Major Changes:\n\n3.x no longer requires you to include the full Firebase SDK in your app. This means that you need to include the parts of Firebase SDK you wish to use and handle initialization of the firebase services in your app instead of re-base doing this for you. re-base only requires you pass it the initialized database service. This also means that the authentication helpers are deprecated and re-base no longer exposes the firebase services.\n\n3.x also removes listeners automatically for you on `componentWillUnmount`\nso you don\'t have to explicitly call `removeBinding`. `removeBinding` is still available if you need to remove a listener while the component is still mounted.\nFor instance, if you are adding and removing listeners in response to a prop change.\n\nTo help with migrating to 3.x please see the [Migration Guide](docs/MIGRATION.md)\nfor the equivalent Firebase SDK methods to use for the deprecated auth helpers.\n\nChanges your re-base initialization:\n\n**Change** this....\n\n```javascript\nvar Rebase = require(\'re-base\');\nvar base = Rebase.createClass({\n  apiKey: \'apiKey\',\n  authDomain: \'projectId.firebaseapp.com\',\n  databaseURL: \'https://databaseName.firebaseio.com\',\n  storageBucket: \'bucket.appspot.com\'\n});\n```\n\n**_To_** this...\n\n```javascript\nvar Rebase = require(\'re-base\');\nvar firebase = require(\'firebase\');\nvar app = firebase.initializeApp({\n  apiKey: \'apiKey\',\n  authDomain: \'projectId.firebaseapp.com\',\n  databaseURL: \'https://databaseName.firebaseio.com\',\n  storageBucket: \'bucket.appspot.com\'\n});\nvar base = Rebase.createClass(app.database());\n```\n\n### Changes to Database methods\n\n<hr />\n\nNo changes. Your existing code should work.\n\n<br />\n\n### Changes to Authentication methods\n\n<hr />\n\n**_Deprecated Methods_**\n\n`base.resetPassword`\n`base.createUser`\n`base.authWithPassword`\n`base.authWithCustomToken`\n`base.authWithOAuthPopup`\n`base.getOAuthRedirectResult`\n`base.authWithOAuthToken`\n`base.authWithOAuthRedirect`\n`base.onAuth`\n`base.unauth`\n`base.getAuth`\n\n## Contributing\n\n1.  `npm install`\n2.  Add/edit tests in `tests/specs`\n3.  Add/edit source in `src`\n4.  `npm test`\n\n## Credits\n\nre-base is inspired by ReactFire from Firebase. Jacob Turner is also a core contributor and this wouldn\'t have been possible without his assistance.\n\n## License\n\nMIT\n'