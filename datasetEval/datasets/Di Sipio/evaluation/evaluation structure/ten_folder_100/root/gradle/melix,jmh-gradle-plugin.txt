b'= JMH Gradle Plugin\n:jmh-version: 1.21\n:plugin-version: 0.5.0\n\nimage:http://img.shields.io/travis/melix/jmh-gradle-plugin/master.svg["Build Status (travis)", link="https://travis-ci.org/melix/jmh-gradle-plugin"]\nimage:http://img.shields.io/coveralls/melix/jmh-gradle-plugin/master.svg["Coverage Status (coveralls)", link="https://coveralls.io/r/melix/jmh-gradle-plugin"]\nimage:https://api.bintray.com/packages/melix/gradle-plugins/jmh-gradle-plugin/images/download.svg[Download, link="https://bintray.com/melix/gradle-plugins/jmh-gradle-plugin"]\nimage:http://img.shields.io/badge/license-ASF2-blue.svg["Apache License 2", link="http://www.apache.org/licenses/LICENSE-2.0.txt"]\n\nThis plugin integrates the http://openjdk.java.net/projects/code-tools/jmh/[JMH micro-benchmarking framework] with Gradle.\n\n== Usage\n\nBuild script snippet for use in all Gradle versions:\n[source,groovy]\n[subs="attributes"]\n.build.gradle\n----\nbuildscript {\n  repositories {\n    jcenter()\n    maven {\n      url "https://plugins.gradle.org/m2/"\n    }\n  }\n  dependencies {\n    classpath "me.champeau.gradle:jmh-gradle-plugin:{plugin-version}"\n  }\n}\n\napply plugin: "me.champeau.gradle.jmh"\n----\n\nBuild script snippet for new, incubating, plugin mechanism introduced in Gradle 2.1:\n[source,groovy]\n[subs="attributes"]\n.build.gradle\n----\nplugins {\n  id "me.champeau.gradle.jmh" version "{plugin-version}"\n}\n----\n\n== What plugin version to use?\n\n[options="header"]\n|===\n|Gradle|Minimal plugin version\n|5.5|0.5.0\n|5.1|0.4.8\n|4.9|0.4.7 (to benefit from lazy tasks API)\n|4.8|0.4.5\n|4.7|0.4.5\n|4.6|0.4.5\n|4.5|0.4.5\n|4.4|0.4.5\n|4.3|0.4.5\n|4.2|0.4.4\n|4.1|0.4.4\n|===\n\n== Configuration\n\nThe plugin makes it easy to integrate into an existing project thanks to a specific configuration. In particular,\nbenchmark source files are expected to be found in the `src/jmh` directory:\n\n----\nsrc/jmh\n     |- java       : java sources for benchmarks\n     |- resources  : resources for benchmarks\n----\n\nThe plugin creates a `jmh` configuration that you should use if your benchmark files depend on a 3rd party library.\nFor example, if you want to use `commons-io`, you can add the dependency like this:\n\n[source,groovy]\n.build.gradle\n----\ndependencies {\n    jmh \'commons-io:commons-io:2.4\'\n}\n----\n\nThe plugin uses JMH {jmh-version}. You can upgrade the version just by changing the version in the `dependencies` block:\n\n[source,groovy]\n.build.gradle\n----\ndependencies {\n    jmh \'org.openjdk.jmh:jmh-core:0.9\'\n    jmh \'org.openjdk.jmh:jmh-generator-annprocess:0.9\'\n}\n----\n\n== Tasks\n\nThe project will add several tasks:\n\n* `jmhClasses`                 : compiles raw benchmark code\n* `jmhRunBytecodeGenerator`    : runs bytecode generator over raw benchmark code and generates actual benchmarks\n* `jmhCompileGeneratedClasses` : compiles generated benchmarks\n* `jmhJar`                     : builds the JMH jar containing the JMH runtime and your compiled benchmark classes\n* `jmh`                        : executes the benchmarks\n    \nThe `jmh` task is the main task and depends on the others so it is in general sufficient to execute this task:\n\n----\ngradle jmh\n----\n\n== Configuration options\n\nBy default, all benchmarks will be executed, and the results will be generated into `$buildDir/reports/jmh`. But you\ncan change various options thanks to the `jmh` configuration block. All configurations variables apart from `include`\nare unset, implying that they fall back to the default JMH values:\n\n[source,groovy]\n[subs="attributes"]\n.build.gradle\n----\njmh {\n   include = [\'some regular expression\'] // include pattern (regular expression) for benchmarks to be executed\n   exclude = [\'some regular expression\'] // exclude pattern (regular expression) for benchmarks to be executed\n   iterations = 10 // Number of measurement iterations to do.\n   benchmarkMode = [\'thrpt\',\'ss\'] // Benchmark mode. Available modes are: [Throughput/thrpt, AverageTime/avgt, SampleTime/sample, SingleShotTime/ss, All/all]\n   batchSize = 1 // Batch size: number of benchmark method calls per operation. (some benchmark modes can ignore this setting)\n   fork = 2 // How many times to forks a single benchmark. Use 0 to disable forking altogether\n   failOnError = false // Should JMH fail immediately if any benchmark had experienced the unrecoverable error?\n   forceGC = false // Should JMH force GC between iterations?\n   jvm = \'myjvm\' // Custom JVM to use when forking.\n   jvmArgs = [\'Custom JVM args to use when forking.\']\n   jvmArgsAppend = [\'Custom JVM args to use when forking (append these)\']\n   jvmArgsPrepend =[ \'Custom JVM args to use when forking (prepend these)\']\n   humanOutputFile = project.file("${project.buildDir}/reports/jmh/human.txt") // human-readable output file\n   resultsFile = project.file("${project.buildDir}/reports/jmh/results.txt") // results file\n   operationsPerInvocation = 10 // Operations per invocation.\n   benchmarkParameters =  [:] // Benchmark parameters.\n   profilers = [] // Use profilers to collect additional data. Supported profilers: [cl, comp, gc, stack, perf, perfnorm, perfasm, xperf, xperfasm, hs_cl, hs_comp, hs_gc, hs_rt, hs_thr]\n   timeOnIteration = \'1s\' // Time to spend at each measurement iteration.\n   resultFormat = \'CSV\' // Result format type (one of CSV, JSON, NONE, SCSV, TEXT)\n   synchronizeIterations = false // Synchronize iterations?\n   threads = 4 // Number of worker threads to run with.\n   threadGroups = [2,3,4] //Override thread group distribution for asymmetric benchmarks.\n   timeout = \'1s\' // Timeout for benchmark iteration.\n   timeUnit = \'ms\' // Output time unit. Available time units are: [m, s, ms, us, ns].\n   verbosity = \'NORMAL\' // Verbosity mode. Available modes are: [SILENT, NORMAL, EXTRA]\n   warmup = \'1s\' // Time to spend at each warmup iteration.\n   warmupBatchSize = 10 // Warmup batch size: number of benchmark method calls per operation.\n   warmupForks = 0 // How many warmup forks to make for a single benchmark. 0 to disable warmup forks.\n   warmupIterations = 1 // Number of warmup iterations to do.\n   warmupMode = \'INDI\' // Warmup mode for warming up selected benchmarks. Warmup modes are: [INDI, BULK, BULK_INDI].\n   warmupBenchmarks = [\'.*Warmup\'] // Warmup benchmarks to include in the run in addition to already selected. JMH will not measure these benchmarks, but only use them for the warmup.\n\n   zip64 = true // Use ZIP64 format for bigger archives\n   jmhVersion = \'{jmh-version}\' // Specifies JMH version\n   includeTests = true // Allows to include test sources into generate JMH jar, i.e. use it when benchmarks depend on the test classes.\n   duplicateClassesStrategy = \'fail\' // Strategy to apply when encountring duplicate classes during creation of the fat jar (i.e. while executing jmhJar task)\n}\n----\n\n== JMH Options Mapping\n\nThe following table describes the mappings between JMH\'s command line options and the plugin\'s extension properties.\n\n[options="header"]\n|===\n| JMH Option               | Extension Property\n| -bm <mode>               | benchmarkMode\n| -bs <int>                | batchSize\n| -e <regexp+>             | exclude\n| -f <int>                 | fork\n| -foe <bool>              | failOnError\n| -gc <bool>               | forceGC\n| -i <int>                 | iterations\n| -jvm <string>            | jvm\n| -jvmArgs <string>        | jvmArgs\n| -jvmArgsAppend <string>  | jvmArgsAppend\n| -jvmArgsPrepend <string> | jvmArgsPrepend\n| -o <filename>            | humanOutputFile\n| -opi <int>               | operationsPerInvocation\n| -p <param={v,}*>         | benchmarkParameters?\n| -prof <profiler>         | profilers\n| -r <time>                | timeOnIteration\n| -rf <type>               | resultFormat\n| -rff <filename>          | resultsFile\n| -si <bool>               | synchronizeIterations\n| -t <int>                 | threads\n| -tg <int+>               | threadGroups\n| -to <time>               | timeout\n| -tu <TU>                 | timeUnit\n| -v <mode>                | verbosity\n| -w <time>                | warmup\n| -wbs <int>               | warmupBatchSize\n| -wf <int>                | warmupForks\n| -wi <int>                | warmupIterations\n| -wm <mode>               | warmupMode\n| -wmb <regexp+>           | warmupBenchmarks\n|===\n\n== Dependency on project files\n\nThe `jmh` plugin makes it easy to test existing sources *without* having to create a separate project for this. This is\nthe reason why you must put your benchmark source files into `src/jmh/java` instead of `src/main/java`. This means that\nby default, the `jmh` (benchmarks) task depends on your `main` (production) source set.\n\nIt is possible a dependency on the `test` source set by setting property `includeTests` to true inside `jmh` block.\n\n== Using JMH Gradle Plugin with Shadow Plugin\n\nOptionally it is possible to use https://github.com/johnrengelman/shadow/[Shadow Plugin] to do actual JMH jar\ncreation. The configuration of Shadow Plugin for JMH jar is done via `jmhJar` block.\nFor example:\n[source,groovy]\n.build.gradle\n----\njmhJar {\n  append(\'META-INF/spring.handlers\')\n  append(\'META-INF/spring.schemas\')\n  exclude \'LICENSE\'\n}\n----\n\n== Duplicate dependencies and classes\n\nThis plugin will merge all dependencies that are defined as part of `jmh`, `runtime` and optionally `testRuntime`\nconfigurations into a single set from which fat jar will be created when executing `jmhJar` task. This is done to ensure\nthat no duplicate dependencies will be added the generated jar.\n\nIn addition plugin applies https://docs.gradle.org/current/javadoc/org/gradle/api/file/DuplicatesStrategy.html[DuplicatesStrategy]\ndefined via `duplicateClassesStrategy` extension property to every class while creating fat jar. By default this\nproperty is set to `DuplicatesStrategy.FAIL` which means that upon detection of\nduplicate classes the task will fail.\n\nIt is possible to change this behavior by configuring `duplicateClassesStrategy` property via `jmh` block, e.g.:\n[source,groovy]\n.build.gradle\n----\njmh {\n  duplicateClassesStrategy = \'warn\'\n}\n----\nHowever if you do encounter problem with defaut value it means that the classpath or sources in your project do contain\nduplicate classes which means that it is not possible to predict which one will be used when fat jar will generated.\n\nTo deal with duplicate files other than classes use\nhttps://github.com/johnrengelman/shadow/[Shadow Plugin] capabilities, see <<Using JMH Gradle Plugin with Shadow Plugin>>.\n\n== Known issues\n\nIf a benchmark is written in Groovy, you must use the same version of Groovy as the one bundled with Gradle. This is\na limitation of the Gradle Worker API that is going to be fixed in the future.\n'