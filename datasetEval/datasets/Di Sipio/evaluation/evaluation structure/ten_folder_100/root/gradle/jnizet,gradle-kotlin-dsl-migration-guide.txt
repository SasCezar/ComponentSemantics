b':note-caption: :information_source:\n\n# The missing migration guide to the Gradle Kotlin DSL\n\n[NOTE]\n====\nAll of this guide, and more, has now been integrated into an official migration guide at gradle.\nPlease refer to https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/[the official guide].\n====\n\nIn case you didn\'t know, Gradle build scripts can be written in Kotlin rather than Groovy.\nHowever, as far as I know, the Kotlin DSL has never been properly documented.\nThe closest I found to a documentation is the set of https://github.com/gradle/kotlin-dsl/tree/master/samples[examples in the kotlin-dsl project]\n\nThis README hopefully constitutes the temporary missing guide to migrate from the Groovy DSL to the Kotlin DSL.\n\nIt assumes you already know the Groovy DSL, and that you\'re familiar with the Kotlin language syntax.\n\n## Disclaimer\n\nI\'m by no means an expert of Gradle and even less of its Kotlin DSL. What follows is what I understood and tested. There might be better ways of doing, and this guide is not, at all, exhaustive. So issues and PRs are welcome.\n\n## File names\n\nTo use the Kotlin DSL, simply name your files `build.gradle.kts` instead of `build.gradle`.\n\nThe `settings.gradle` file can also be renamed `settings.gradle.kts`.\n\nIn a multi-project build, you can have some modules using the Groovy DSL (and thus use `build.gradle` files), and some other modules using the Kotlin DSL (and thus use `build.gradle.kts` files). So you\'re not forced to migrate everything at once.\n\n## Applying built-in plugins\n\nUsing the `plugins` block:\n\n.Groovy\n[source, groovy]\n----\nplugins {\n    id \'java\'\n    id \'jacoco\'\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\nplugins {\n    java\n    id("jacoco")\n}\n----\n\nAs you can see with the `jacoco` example, the same syntax can be used in Groovy and Kotlin (except for double quotes and parentheses that must be used in Kotlin, of course).\n\nBut the Kotlin DSL also defines extension properties for all (AFAIK) built-in plugins, so you can use them, as shown above with the `java` example.\n\nYou can also use the older `apply` syntax:\n\n.Groovy\n[source, groovy]\n----\napply plugin: \'checkstyle\'\n----\n\n.Kotlin\n[source, kotlin]\n----\napply(plugin = "checkstyle")\n----\n\n## Applying external plugins\n\nUsing the `plugins` block:\n\n.Groovy\n[source, groovy]\n----\nplugins {\n    id \'org.springframework.boot\' version \'2.0.1.RELEASE\'\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\nplugins {\n    id("org.springframework.boot") version "2.0.1.RELEASE"\n}\n----\n\nYou can also use the older `apply` syntax, but then the plugin must be added to the classpath of the build script:\n\n.Groovy\n[source, groovy]\n----\nbuildscript {\n    repositories {\n        gradlePluginPortal()\n    }\n    dependencies {\n        classpath("gradle.plugin.com.boxfuse.client:gradle-plugin-publishing:5.0.3")\n    }\n}\n\napply plugin: \'org.flywaydb.flyway\'\n----\n\n.Kotlin\n[source, kotlin]\n----\nbuildscript {\n    repositories {\n        gradlePluginPortal()\n    }\n    dependencies {\n        classpath("gradle.plugin.com.boxfuse.client:gradle-plugin-publishing:5.0.3")\n    }\n}\n\napply(plugin = "org.flywaydb.flyway")\n----\n\n## Applying the Kotlin plugin\n\nIf you\'re using Kotlin to write your build scripts, you probably also use Kotlin in your project. Applying the Kotlin plugin is no different from applying any external other plugin. But the DSL has an extension function to make it shorter:\n\n.Groovy\n[source, groovy]\n----\nplugins {\n    id \'org.jetbrains.kotlin.jvm\' version \'1.2.41\'\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\nplugins {\n    kotlin("jvm") version "1.2.41"\n}\n----\n\n## Customizing an existing task\n\nThis is where Groovy and Kotlin start to differ. Since Kotlin is a statically typed language, and since you want to benefit from this static typing by discovering available properties and methods using auto-completion, you need to know and provide the type of the task you want to configure.\n\nHere is how you can configure a single property of the existing `jar` task:\n\n.Groovy\n[source, groovy]\n----\njar.archiveName = \'foo.jar\'\n----\n\n.Kotlin\n[source, kotlin]\n----\nval jar: Jar by tasks\njar.archiveName = "foo.jar"\n----\n\nNote that specifying the type of the task explicitly is necessary. Otherwise, the script won\'t compile because the inferred type of `jar` will be `Task`, and the `archiveName` property is specific to the `Jar` task.\n\nYou can, however, omit the type if you only need to configure properties or call methods declared in `Task`:\n\n.Groovy\n[source, groovy]\n----\ntest.doLast {\n    println("test completed")\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\nval test by tasks\ntest.doLast { println("test completed") }\n----\n\nIf you need to configure several properties or call multiple methods on the same task you can group them in a block as follows:\n\n.Groovy\n[source, groovy]\n----\njar {\n    archiveName = \'foo.jar\'\n    into(\'META-INF\') {\n        from(\'bar\')\n    }\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\nval jar by tasks.getting(Jar::class) {\n    archiveName = "foo.jar"\n    into("META-INF") {\n        from("bar")\n    }\n}\n----\n\nIf you already have a `val` for the task you want to configure in scope, the Kotlin `apply` function is handy:\n\n.Kotlin\n[source, kotlin]\n----\nval jar: Jar by tasks\njar.apply {\n    archiveName = "foo.jar"\n    into("META-INF") {\n        from("bar")\n    }\n}\n----\n\nBut there is another idiomatic way to configure tasks: using a `tasks` block:\n\n.Groovy\n[source, groovy]\n----\njar {\n    archiveName = \'foo.jar\'\n    into(\'META-INF\') {\n        from(\'bar\')\n    }\n}\n\ntest.doLast {\n    println("test completed")\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\ntasks {\n    "jar"(Jar::class) {\n        archiveName = "foo.jar"\n        into("META-INF") {\n            from("bar")\n        }\n    }\n\n    "test" {\n        doLast { println("test completed") }\n    }\n}\n----\n\nOnce again, note that if you need to apply task-specific configurations, you need to provide the type of the task (`Jar` in this example).\n\nThis means that you\'ll sometimes need to dive in the documentation or source code of custom plugins to discover what the types of its custom tasks are, and to import them, or use their fully qualified name.\n\n.Groovy\n[source, groovy]\n----\nplugins {\n    id(\'java\')\n    id \'org.springframework.boot\' version \'2.0.1.RELEASE\'\n}\n\nrepositories {\n    mavenCentral()\n}\n\napply plugin: \'io.spring.dependency-management\'\n\nbootJar {\n    archiveName = \'app.jar\'\n    mainClassName = \'com.ninja_squad.demo.Demo\'\n}\n\nbootRun {\n    main = \'com.ninja_squad.demo.Demo\'\n    args \'--spring.profiles.active=demo\'\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\nimport org.springframework.boot.gradle.tasks.bundling.BootJar\nimport org.springframework.boot.gradle.tasks.run.BootRun\n\nplugins {\n    java\n    id("org.springframework.boot") version "2.0.1.RELEASE"\n}\n\nrepositories {\n    mavenCentral()\n}\n\napply(plugin = "io.spring.dependency-management")\n\ntasks {\n    "bootJar"(BootJar::class) {\n        archiveName = "app.jar"\n        mainClassName = "com.ninja_squad.demo.Demo"\n    }\n\n    "bootRun"(BootRun::class) {\n        main = "com.ninja_squad.demo.Demo"\n        args("--spring.profiles.active=demo")\n    }\n}\n----\n\n## Creating a task\n\nCreating a task can be done by declaring delegated property, delegating to `tasks.creating`:\n\n.Groovy\n[source, groovy]\n----\ntask greeting {\n    println(\'always printed: configuration phase\')\n    doLast {\n        println(\'only printed if executed: execution phase\')\n    }\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\nval greeting by tasks.creating {\n    println("always printed: configuration phase")\n    doLast {\n        println("only printed if executed: execution phase")\n    }\n}\n----\n\nSometimes you want to create a task of a given type (`Zip` in this example):\n\n.Groovy\n[source, groovy]\n----\ntask docZip(type: Zip) {\n    archiveName = \'doc.zip\'\n    from \'doc\'\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\nval docZip by tasks.creating(Zip::class) {\n    archiveName = "doc.zip"\n    from("doc")\n}\n----\n\nThe same things can also be done using the `tasks` block:\n\n.Groovy\n[source, groovy]\n----\ntask greeting2 {\n    println(\'always printed: configuration phase\')\n    doLast {\n        println(\'only printed if executed: execution phase\')\n    }\n}\n\ntask docZip2(type: Zip) {\n    archiveName = \'doc.zip\'\n    from \'doc\'\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\ntasks {\n    "greeting2" {\n        println("always printed: configuration phase")\n        doLast {\n            println("only printed if executed: execution phase")\n        }\n    }\n\n    "docZip2"(Zip::class) {\n        archiveName = "doc2.zip"\n        from("doc")\n    }\n}\n----\n\nNotice that creating a task uses the exact same syntax as customizing an existing task. This can be confusing, and even lead to bugs: your intention might be to customize an existing task, but if you use the wrong task name, you will end up creating a new task rather than customizing the existing task. The reader might also not know if your intention is to customize an existing task, or to create a new one. For these two reasons, you might prefer using these slightly more verbose variants, which clearly show your intent and avoid the previously described bug:\n\n.Kotlin\n[source, kotlin]\n----\ntasks {\n    // get and customize the existing task named test. Fails if there is no test task.\n    val test by getting {\n        doLast { println("test completed") }\n    }\n\n    // create a new docZip3 task. Fails if a task docZip3 already exists.\n    val docZip3 by creating(Zip::class) {\n        archiveName = "doc3.zip"\n        from("doc")\n    }\n}\n----\n\n## Dependencies\n\nDeclaring dependencies in the existing Java configurations is not much different from doing it in Groovy:\n\n.Groovy\n[source, groovy]\n----\ndependencies {\n    implementation \'org.springframework.boot:spring-boot-starter-web\'\n    implementation \'io.jsonwebtoken:jjwt:0.9.0\'\n    runtimeOnly \'org.postgresql:postgresql\'\n    testImplementation(\'org.springframework.boot:spring-boot-starter-test\') {\n        exclude(module: \'junit\')\n    }\n    testRuntimeOnly \'org.junit.jupiter:junit-jupiter-engine\'\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\ndependencies {\n    implementation("org.springframework.boot:spring-boot-starter-web")\n    implementation("io.jsonwebtoken:jjwt:0.9.0")\n    runtimeOnly("org.postgresql:postgresql")\n    testImplementation("org.springframework.boot:spring-boot-starter-test") {\n        exclude(module = "junit")\n    }\n    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")\n}\n----\n\n## Custom configurations\n\nSometimes you need to add your own configuration, and add dependencies to that configuration:\n\n.Groovy\n[source, groovy]\n----\nconfigurations {\n    db\n    integTestImplementation {\n        extendsFrom testImplementation\n    }\n}\n\ndependencies {\n    db \'org.postgresql:postgresql\'\n    integTestImplementation \'com.ninja-squad:DbSetup:2.1.0\'\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\nval db by configurations.creating\nval integTestImplementation by configurations.creating {\n    extendsFrom(configurations["testImplementation"])\n}\n\ndependencies {\n    db("org.postgresql:postgresql")\n    integTestImplementation("com.ninja-squad:DbSetup:2.1.0")\n}\n----\n\nNote that, in the above example, you can only use `db(...)` and `integTestImplementation(...)` because they\'re both declared as properties before. If they were defined elsewhere, you could get them by delegating to `configurations`, or you could use a string to add a dependency to the configuration:\n\n.Kotlin\n[source, kotlin]\n----\n// get the existing testRuntimeOnly configuration\nval testRuntimeOnly by configurations\n\ndependencies {\n    testRuntimeOnly("org.postgresql:postgresql")\n    "db"("org.postgresql:postgresql")\n    "integTestImplementation"("com.ninja-squad:DbSetup:2.1.0")\n}\n----\n\n## Extensions\n\nMany plugins come with extensions to configure them. If those plugins are applied using the `plugins` block (which is true for the jacoco and the Spring Boot plugins in the following example), then Kotlin extension functions are made available to configure their extension, the same way as in Groovy.\n\nOn the other hand, if you use the older `apply` function to apply a plugin (which is true for the checkstyle plugin in the following example), you\'ll have to use the `configure<T> {}` function to configure them:\n\n.Groovy\n[source, groovy]\n----\njacoco {\n    toolVersion = "0.8.1"\n}\n\nspringBoot {\n    buildInfo {\n        properties {\n            time = null\n        }\n    }\n}\n\ncheckstyle {\n    maxErrors = 10\n}\n----\n\n.Kotlin\n[source, kotlin]\n----\njacoco {\n    toolVersion = "0.8.1"\n}\n\nspringBoot {\n    buildInfo {\n        properties {\n            time = null\n        }\n    }\n}\n\nconfigure<CheckstyleExtension> {\n    maxErrors = 10\n}\n----\n'