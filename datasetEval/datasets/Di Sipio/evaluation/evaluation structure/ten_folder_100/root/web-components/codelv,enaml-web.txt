b'# Enaml Web #\n\n[![Build Status](https://travis-ci.org/codelv/enaml-web.svg?branch=master)](https://travis-ci.org/codelv/enaml-web)\n[![codecov](https://codecov.io/gh/codelv/enaml-web/branch/master/graph/badge.svg)](https://codecov.io/gh/codelv/enaml-web)\n[![Downloads](https://pepy.tech/badge/enaml-web/month)](https://pepy.tech/project/enaml-web/month)\n\n\nA web component toolkit for [enaml](https://github.com/nucleic/enaml) that\nlet\'s you build websites in python declaratively.\n\nYou can use enaml-web to build "interactive" websites using python, enaml, and a few lines of _simple_ javascript (see the simple pandas [dataframe viewer](https://github.com/codelv/enaml-web/tree/master/examples/dataframe_viewer) example). The view state (dom) is stored on the server as an enaml view and interaction works by syncing changes between\nbetween the client(s) and server using websockets (or polling).\n\nTo demonstrate, the following interaction is all handled with enaml-web\n\n![interactive-websites-in-python-with-enaml](https://user-images.githubusercontent.com/380158/44675893-b4ceb380-a9ff-11e8-89e9-9ca2bce7d217.gif)\n\n### Examples\n\nSee the examples folder\n\n- [www.codelv.com](https://www.codelv.com/) - Built entirely using enaml-web\n- [SMD Component search](https://github.com/frmdstryr/smd-search) - View and search a pandas dataframe\n\n\n### Short intro\n\nTo use enaml web, you simply replace html tags with the enaml component\n(the capitalized tag name). For example:\n\n```python\nfrom web.components.api import *\n\nenamldef Index(Html):\n    Head:\n        Title:\n            text = "Hello world"\n    Body:\n        H1:\n            text = "Hello world"\n\n```\n\nCalling `render()` on an instance of this enaml view then generates the html\nfrom the view. This is shown in the simple case of a static site generator:\n\n```python\n\nimport enaml\nfrom web.core.app import WebApplication\n\n# Create an enaml Application that supports web components\napp = WebApplication()\n\n# Import Index from index.enaml\nwith enaml.imports():\n    from index import Index\n\n# Render the Index.enaml to index.html\nview = Index()\nwith open(\'index.html\', \'w\') as f:\n    f.write(view.render())\n\n```\n\nYou can also use it in a request handler with your favorite web framework. For example with tornado\nweb you can do something like this:\n\n\n```python\nimport enaml\nimport tornado.web\nimport tornado.ioloop\nfrom web.core.app import WebApplication\n\n# Import Index from index.enaml\nwith enaml.imports():\n    from index import Index\n\nclass IndexHandler(tornado.web.RequestHandler):\n    view = Index()\n    def get(self, request):\n        return self.view.render(request=request)\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        super(Application, self).__init__([\n                (r\'/\',IndexHandler)\n           ],\n        )\n\nif __name__ == "__main__":\n    web_app = WebApplication()\n    app = Application()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\n\n```\n\n### So what\'s the advantage over plain html?\n\nIt\'s as simple as html but it\'s python so you can, loop over lists, render conditionally,\nformat variables, etc...\n\nAlso, it\'s not just formatting a template,  the server maintains the page state so\nyou can interact with the page after it\'s rendered.  This is something that no other\npython template frameworks can do (to my knowledge).\n\n### How it works\n\nIt generates a dom of [lxml](http://lxml.de/) elements.\n\n##### Inherently secure\n\nSince an lxml dom is generated it means that your code is inherently secure from\ninjection as it automatically escapes all attributes. Also a closing tag cannot\nbe accidentally missed.\n\nThe atom framework provides additional security by enforcing runtime type\nchecking and optional validation.\n\n\n##### Extendable via templates and blocks\n\nLike other template engines, enaml-web provides a "Block" node that allows\nyou to define a part of a template that can be overridden or extended.\n\nEnaml also provides pattern nodes for handling conditional statements, loops,\ndynamic nodes based on lists or models, and nodes generated from more complex\ntemplates (ex automatic form generation).\n\n\n##### No template tags needed\n\nMany template engines require the use of "template tags" wrapped in `{% %}`\nor similar to allow the use of python code to transform variables.\n\nSince enaml _is_ python, you can use any python code directly in\nyour enaml components and templates. You don\'t need any template tags.\n\n\n##### Testing is easier\n\nSince the internal representation is lxml nodes, you can use lxml\'s xpath\nqueries on the dom for e2e view testing. No need to use headless browsers and\nthat complicated stuff (unless you\'re using a lot of js).\n\n\n##### Component based\n\nSince enaml views are like python classes, you can "subclass" and extend any\ncomponent and extend it\'s functionality. This enables you to quickly build\nreusable components.\n\nI\'m working on components for several common css frameworks so they can simply\nbe installed and used.\n\n1. [materialize-ui](https://github.com/frmdstryr/materialize)\n2. semantic-ui (coming soon)\n3. bootstrap (coming soon)\n\n\n### Data binding\n\nBecause enaml-web is generating a dom, you can use websockets and some js\nto manipulate the dom to do data binding between the client to server.\n\nThe dom can be shared per user or per session making it easy to create\ncollaborative pages or they can be unique to each page.\n\n![Data binding](https://github.com/frmdstryr/enaml-web/blob/master/docs/data-binding.gif?raw=true)\n\nEach node as a unique identifier and can be modified using change events. An\nexample of this is in the examples folder.\n\nYou can also have the client trigger events on the server and have the server\ntrigger JS events on the client.\n\nTo use:\n1. Include enaml.js in your page\n2. Observe the `modified` event of an Html node and pass these changes to the\nclient via websockets.\n3. Enamljs will send events back to the server, update the dom accordingly.\n\n\n#### Data models\n\nForms can automatically be generated and populated using enaml\'s DynamicTemplate\nnodes. An implementation of the `AutoForm` using the [materalize css](https://github.com/frmdstryr/materialize)\nframework is available on my personal repo. With this, we can take a model like:\n\n```python\n\nfrom atom.api import Atom, Unicode, Bool, Enum\n\nclass Message(Atom):\n    name = Unicode()\n    email = Unicode()\n    message = Unicode()\n    options = Enum("Email","Phone","Text")\n    sign_up = Bool(True)\n\n\n```\n\nThen use the `AutoForm` node and pass in either a new or populated instance of\nthe model to render the form.\n\n```python\n\nfrom templates import Base\nfrom web.components.api import *\nfrom web.core.api import Block\n\n\nenamldef AddMessageView(Base): page:\n    attr message\n    Block:\n        block = page.content\n        AutoForm:\n            model << message\n\n```\n\n![Rendered Form](https://ibin.co/3Je5OwatJAGz.png)\n\n\n### Database ORM with Atom\n\nFor working with a database using atom see [atom-db](https://github.com/codelv/atom-db)\n\n\n#### Raw, Markdown, and Code nodes\n\nThe`Raw` node parses text into dom nodes (using lxml\'s html parser). Similarly\n`Markdown` and `Code` nodes parse markdown and highlight code respectively.\n\nFor example, you can use wagtal\'s richtext tag to render to a dom via:\n\n```python\n\nfrom web.components.api import *\nfrom web.core.api import *\nfrom wagtail.core.templatetags.wagtailcore_tags import richtext\nfrom myapp.views.base import Page\n\nenamldef BlogPage(Page):\n    body.cls = \'template-blogpage\'\n    Block:\n        block = parent.content\n        Raw:\n            source << richtext(page.body)\n\n```\n\nThis let\'s you use web wysiwyg editors to insert content into the dom.\n\n\n#### Block node\n\nYou can define a base template, then overwrite parts using the `Block` node.\n\nIn one file put:\n\n```python\n\nfrom web.components.api import *\nfrom web.core.api import Block\n\nenamldef Base(Html):\n    attr user\n    attr site\n    attr request\n    alias content\n    Head:\n        Title:\n            text << site.title\n    Body:\n        Header:\n            text = "Header"\n        Block: content:\n            pass\n        Footer:\n            text = "Footer"\n\n```\n\nThen you can import that view and _extend_ the template and override the\nblock\'s content.\n\n```python\nfrom templates import Base\nfrom web.components.api import *\nfrom web.core.api import Block\n\nenamldef Page(Base): page:\n    Block:\n        block = page.content\n        P:\n            text = "Content inserted between Header and Footer"\n\n```\n\nBlocks let you either replace, append, or prepend to the content.\n\n#### Custom Components\n\nWith enaml you can easily create reusable components and share them through\nthe views as you would any python class using regular python imports.\n\nFor instance, to create a\n[materalize breadcrumbs component](http://materializecss.com/breadcrumbs.html)\nthat automatically follows the current request path, simply include the required\ncss/scripts in your base template, define the component as shown below:\n\n```python\n\nfrom web.components.api import *\nfrom web.core.api import Looper\n\nenamldef Breadcrumbs(Nav): nav:\n    attr path # ex. pass in a tornado request.path\n    attr color = ""\n    attr breadcrumbs << path[1:-1].split("/")\n    tag = \'nav\'\n    Div:\n        cls = \'nav-wrapper {}\'.format(nav.color)\n        Div:\n            cls = \'container\'\n            Div:\n                cls = \'col s12\'\n                Looper:\n                    iterable << breadcrumbs\n                    A:\n                        href = "/{}/".format("/".join(breadcrumbs[:loop_index+1]))\n                        cls = "breadcrumb"\n                        text = loop_item.title()\n```\n\nthen use it it as follows\n\n```python\n\n# in your template add\nBreadcrumbs:\n    path << request.path\n\n```\n\n\n### Gotachas\n\n##### Text and tail nodes\n\nLxml uses text and tail properties to set text before and after child nodes, which can be confusing.\n\nFor instance in html you can do\n\n```html\n\n<p>This is a sentence <a href="#">click here</a> then keep going</p>\n\n```\n\nTo make this with enaml you need to do this:\n\n```python\n\nP:\n    text = "This is a sentence"\n    A:\n        href = "#"\n        text = "click here"\n        tail = "then keep going"\n\n```\n\nNotice how `tail` is set on the `A` NOT the `P`.\nSee [lxml etree documentation](http://lxml.de/tutorial.html#elements-contain-text) for more details.\n\n\n##### Tag attribute\n\nWhen creating a custom `Tag`, the `tag` attribute must be set to change what\nhtml tag is used for a node. For example:\n\n```python\n\nenamldef Svg(Tag):\n    tag = \'svg\' # Force tag to be \'svg\'\n\n```\n\nThis will then render a `<svg>...</svg>` tag.\n\n> Note: In previous versions (0.8.8 and below) the tag name defaulted to the\nlowercase class name. This is no longer done to eliminate a function call per\nnode and to avoid having to explicitly redefine the tag when subclassing.\n\n'