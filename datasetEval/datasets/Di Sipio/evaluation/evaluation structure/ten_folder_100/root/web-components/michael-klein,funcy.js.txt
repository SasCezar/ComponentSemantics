b'\n<p align="center">\n  <img src="https://i.imgur.com/HlOLFhy.png" width="300" alt="funcyjs logo">\n</p>\n<h3 align="center">\n  A functional web-components wrapper <img src="https://img.shields.io/npm/v/funcy-components.svg">\n</h3>\n<p align="center">\n  <img src="https://i.imgur.com/ioHwn7m.png" width="572" alt="example of code">\n</p>\n\n### Why \'funcy.js\'?\n\nNaming things is hard and \'funcyjs\' (pronounced like funky) seemed like a [fun](http://www.badum-tish.com/), recognizable name.\n\n### What is it?\n\nfuncy.js seeks to provide a functional way of defining web components, very much akin to [react](https://reactjs.org/)  [functional components](https://reactjs.org/docs/components-and-props.html#function-and-class-components) with [hooks](https://reactjs.org/docs/hooks-intro.html).\n\nthe hooks functionality in funcyjs is powered by: [hookuspocus](https://github.com/michael-klein/hookuspocus/edit/master/README.md)\n\nHere\'s a simple TODO app implemented with funcyjs: https://codepen.io/michael-klein/pen/xmQZBx\n\n### Browser Compatibility\n\nThe library is published is not transpiled for browser compatibility and does not contain any polyfills. As such you can use it as an es6 module in the latest version of chrome and other browsers that implement the latest JavaScript features including web components v1, but it will fail horribly anywhere else, so you will have to provide polyfills/transpilation if you want to use this in more browsers.\n\n### Installation\n\nUsing npm:\n\n```js\nnpm install funcy-components\n```\n\n```js\nimport {defineComponent} from "funcy-components"\n```\n\nAs ES6 module via hotlinking from unpkg:\n\n```js\nimport {defineComponent} from "https://unpkg.com/funcy-components/dist/core.min.mjs"\n```\n\nor the full version with all hooks:\n\n```js\nimport {defineComponent} from "https://unpkg.com/funcy-components/dist/full.min.mjs"\n```\n\n### Usage\n\n#### The bare minimum:\n\n```js\nimport {defineComponent} from "https://unpkg.com/funcy-components/dist/full.min.mjs";\n\ndefineComponent("a-component", () => {\n const div = document.createElement("div");\n div.innerHTML = "Hello World!";\n return div;\n});\n```\n:pencil2:[pen](https://codepen.io/michael-klein/pen/roQvjr)\n\nWhat\'s happening here?\ndefineComponent is a method with the signature:\n```ts\nfunction defineComponent(name:string, component:(props:any) => View, options:DefineComponentOptions = {}):void;\n```\nIt will define a web component via _customElements.define_ by internally creating a class that extends HTMLElement using the supplied name. \n\ncomponent is a function that accepts props and returns a View (just like functional components in react). It will be called whenever the component needs to (re-)render. A View is anything that can be consumed by a renderer (more on that in a bit). In the above example, the View is simply a div element. The default renderer will simply replace the current content of the shadowRoot with the view (unless you return the same nodes).\n\ndefineComponent also accepts an options object, that allows you to define observed attributes and pass options to [attachShadow](developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow)\n```ts\ninterface DefineComponentOptions {\n  observedAttributes:string[],\n  shadowOptions:ShadowRootInit\n}\n```\n\n#### Props\n\nNormally, you can only pass data to custom elements via attributes, which only support string values. funcyjs enables you to pass prps between funcyjs components using thr prps method like this:\n```js\ndefineComponent(\n  "prop-sender",\n  () => {\n    const html = usePreactHtm();\n    return html`\n      <prop-receiver ...${prps({greeting: "hello World"})}></prop-receiver>\n    `;\n  }\n);\ndefineComponent(\n  "prop-receiver",\n  (props) => {\n    const html = usePreactHtm();\n    return html`\n      <div>\n        ${props.greeting}\n      </div>\n    `;\n  }\n);\n```\n:pencil2:[pen](https://codepen.io/michael-klein/pen/VqVdpp)\n\nprps will actually return an object like this:\n```js\n{\n  "data-props": propsId\n}\n```\nYou can spread it on the component with htm or just set a "data-props" attribute manually if you just use DOM. Internally, funcyjs listens to changes to the data-props argument and qeueus re-renders if the passed props change.\n\n#### Hooks: The basics\n\nHooks are a way to use state or other internal features in your functional components. They were first popularized by react. Read more about the motivation and use of the basic hooks (useReducer, useState, useEffect) in the react docs: https://reactjs.org/docs/hooks-intro.html. The basic hooks that funcyjs has in common with react should work exactly the same. If they don\'t, pease submit an issue :)\n\nIn the following I will explain how to use some of the hooks which are specific to funcyjs.\n\n#### Custom renderers\n\nA custom renderer is a function that takes a View and a shadowRoot and knows how to render the View to the shadowRoot. It is called after a component renders with the generated View and the shadowRoot of the elment. For example, this is the default renderer:\n```js\nexport const defaultRenderer = (view, shadowRoot) => {\n  if (\n    !(view instanceof NodeList\n      ? shadowRoot.contains(view[0])\n      : shadowRoot.contains(view))\n  ) {\n    shadowRoot.innerHTML = "";\n    if (view instanceof NodeList) {\n      view.forEach(node => shadowRoot.appendChild(node));\n    } else {\n      shadowRoot.appendChild(view);\n    }\n  }\n};\n```\n\nYou can define your own custom renderer with the useRenderer hook. funcyjs exports a custom usePreactHtm hook that uses [htm](https://github.com/developit/htm) and [preact](https://preactjs.com) in the full bundle:\n```js\nimport { createHook, useRenderer } from "../export_core.mjs";\nimport { html, render } from "../../node_modules/htm/preact/standalone.mjs";\nexport const usePreactHtm = createHook(() => {\n  useRenderer((view, shadowRoot) => {\n    render(view, shadowRoot);\n  });\n  return html;\n});\n```\nIt also returns a html template tag that can be used to construct the view which is consumed with the render call.\n\n#### Attributes\n\nCustomElements can have attributes, just like any other element. The useAttribute hook will enable you to access and modify these:\n```js\ndefineComponent(\n  "attribute-example",\n  () => {\n    const html = usePreactHtm();\n    const [name, setName] = useAttribute("name");\n    return html`\n        <input type="text" onInput=${e => setName(e.target.value)} value=${name}></input>\n    `;\n  },\n  {\n    observedAttributes: ["name"]\n  }\n);\n```\n:pencil2:[pen](https://codepen.io/michael-klein/pen/NeEMZy)\n\nThe above example will reflect changes you make to the input back to the attribute on the component in the DOM. Note that we also supplied "name" as an observedAttribute, so that when an outside source changes the attribute, the component will re-render (the setter from useAttribute won\'t trigger a re-render).\n\n#### CSS\n\nYou can render CSS directly to the view, if you which. You can also use the useCSS hook for that purpose. The hook can act as a normal function or a template tag and will render the CSS you pass it to the shadowRoot:\n```js\ndefineComponent(\n  "css-example",\n  () => {\n    const html = usePreactHtm();\n    useCSS(\'h1 {color:green;}\');\n    const css = useCSS;\n    css`\n      h2 {\n        color:red;\n      }\n      `\n    return html`\n      <div>\n        <h1>green</h1>\n        <h2>red</h2>\n      </div>\n    `;\n  }\n);\n```\n:pencil2:[pen](https://codepen.io/michael-klein/pen/wRQXMm)\n\n#### Exposing an API\n\nCustomElements can expose API methods for others to consume. In funcyjs, this is done through the useExposeMethod hook:\n```js\ndefineComponent(\n  "expose-method",\n  () => {\n    const html = usePreactHtm();\n    useExposeMethod("methodName", () => alert("you used this method!"));\n    return html`<div>something</div>`;\n  }\n);\n```\n\nNote that wether you use an arrow function or a normal function, this will never be bound to the CustomElement instance.\n\n#### others:\n\nYou can access the host element, the shadow root or get information on the connected state of the component with the useHostElement, useShadowRoot useConnectedState hooks. Use them sparingly if at all.\n\n#### currently implemented hooks:\n\ncore hooks:\n* __useReducer__\n* __useState__\n* __useEffect__\n* useRenderer \n* useAttribute\n* useCSS\n* useExposeMethod\n* useConnectedState\n* useHostElement\n* useShadowRoot\n\nother (only present in full bundles):\n* usePreactHtm\n\n\n\n#### License\n\nMIT License\n\nCopyright (c) 2019 Michael Klein\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n'