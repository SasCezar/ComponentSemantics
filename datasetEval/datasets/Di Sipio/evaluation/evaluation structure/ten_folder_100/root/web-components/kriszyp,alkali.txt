b'![Alkali](./assets/alkali-logo.svg)\n\n[![Join the chat at https://gitter.im/alkali-js/Lobby](https://badges.gitter.im/alkali-js/Lobby.svg)](https://gitter.im/alkali-js/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Build Status](https://travis-ci.org/kriszyp/alkali.svg?branch=master)](https://travis-ci.org/kriszyp/alkali)\n[![devDependency status](https://david-dm.org/kriszyp/alkali/dev-status.svg)](https://david-dm.org/kriszyp/alkali#info=devDependencies)\n<a href="https://dev.doctorevidence.com/"><img src="./assets/powers-dre.png" width="203" /></a>\n\n[Alkali](https://kriszyp.github.io/alkali/) is a package for creating efficient, reactive data flow that drives native HTML elements. The namesake, alkali metals are a set of elements known for being extremely reactive, conductive, and lightweight, and likewise this library is designed to be a lightweight (20KB gzipped), dependency-free package for accessing simple pure native JavaScript objects with modeling and reactivity capabilities, and creating reactive UIs based on native DOM elements. Alkali is designed for speed and scalability, using a true functional reactive, cache and invalidation-based system that provides optimized on-demand rendering performance. This makes it possible to build highly efficient and fast applications, with UI components driven by standard JavaScript objects using modern functionally reactive techniques, and without any large framework impositions.\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON\'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  \n\n- [Alkali Basics](#alkali-basics)\n  - [Installation](#installation)\n- [Compatibility](#compatibility)\n- [Variables](#variables)\n  - [Debugging/Interaction](#debugginginteraction)\n  - [Todo Example](#todo-example)\n  - [Typings](#typings)\n  - [TypeScript Plugin for Reactive Expressions](#typescript-plugin-for-reactive-expressions)\n  - [Babel Plugin for Reactive Expressions](#babel-plugin-for-reactive-expressions)\n  - [`Variable`/`reactive` API](#variablereactive-api)\n    - [`reactive(initialValue: any)`: Variable](#reactiveinitialvalue-any-variable)\n  - [Variable API](#variable-api)\n    - [`new Variable(initialValue: any)`](#new-variableinitialvalue-any)\n    - [`valueOf()`](#valueof)\n    - [`then(onFulfilled, onRejected)`](#thenonfulfilled-onrejected)\n    - [`put(value)`](#putvalue)\n    - [`property(propertyName, PropertyClass?)`](#propertypropertyname-propertyclass)\n    - [`to(function, reversal?)`](#tofunction-reversal)\n    - [`get(propertyName)`](#getpropertyname)\n    - [`set(propertyName, value)`](#setpropertyname-value)\n    - [`schema`](#schema)\n    - [`validation`](#validation)\n    - [`subscribe(listener)`](#subscribelistener)\n    - [`Variable.for(subject)`](#variableforsubject)\n    - [`all(array, transform?)`](#allarray-transform)\n  - [Variables as Arrays (`VArray`)](#variables-as-arrays-varray)\n  - [Structured Variables](#structured-variables)\n  - [Variable `collection`s](#variable-collections)\n    - [Primitive Typed Variables](#primitive-typed-variables)\n    - [Subclassing Structured Variables](#subclassing-structured-variables)\n  - [EcmaScript Generator Support (`react()`)](#ecmascript-generator-support-react)\n    - [Generator Computed Properties](#generator-computed-properties)\n- [Element Construction](#element-construction)\n  - [Properties Argument](#properties-argument)\n    - [Children Array Argument](#children-array-argument)\n    - [Variable Argument](#variable-argument)\n    - [String (and numbers, booleans) Argument](#string-and-numbers-booleans-argument)\n    - [`null` and `undefined`](#null-and-undefined)\n    - [Event Handlers](#event-handlers)\n  - [Extending Elements](#extending-elements)\n  - [Creating/Extending Element Classes (Components)](#creatingextending-element-classes-components)\n      - [Children](#children)\n    - [Property Declaration](#property-declaration)\n    - [Generator getter methods](#generator-getter-methods)\n      - [Generator `*render` Method](#generator-render-method)\n    - [Construction Lifecycle Methods](#construction-lifecycle-methods)\n  - [Variable Classes](#variable-classes)\n  - [Element Lists/Loops](#element-listsloops)\n  - [Metadata and Validation](#metadata-and-validation)\n  - [Alkali Element API](#alkali-element-api)\n    - [Alkali Element Exports](#alkali-element-exports)\n      - [Options](#options)\n  - [Renderers](#renderers)\n  - [Reverse Mappings](#reverse-mappings)\n  - [Contextualization](#contextualization)\n  - [Variable Copy-on-Write](#variable-copy-on-write)\n  - [Variable Proxying](#variable-proxying)\n  - [Variable Copies](#variable-copies)\n  - [Creating Web Components/Custom Tag Named Elements](#creating-web-componentscustom-tag-named-elements)\n  - [Additional Variable Methods](#additional-variable-methods)\n    - [`updated(updateEvent)`](#updatedupdateevent)\n    - [`notifies(listener: { updated: (updateEvent: Event) => any })`](#notifieslistener--updated-updateevent-event--any-)\n    - [`apply(instance, functionVariable)`](#applyinstance-functionvariable)\n    - [`is(sourceVariable)`](#issourcevariable)\n    - [`whileResolving(valueUntilResolved?, useLastValue: boolean?)`](#whileresolvingvalueuntilresolved-uselastvalue-boolean)\n    - [`Variable.proxy(source)`](#variableproxysource)\n  - [`Transform(source)`](#transformsource)\n  - [Variables with Maps](#variables-with-maps)\n    - [`spawn()`](#spawn)\n  - [Operator Functions](#operator-functions)\n  - [Other Alkali Functions and Properties](#other-alkali-functions-and-properties)\n    - [`delayUpdate(variable, until)`](#delayupdatevariable-until)\n  - [Which Listener To Use?](#which-listener-to-use)\n- [Debugging](#debugging)\n- [Design Philosophy](#design-philosophy)\n- [Element Constructors](#element-constructors)\n  - [Standard Elements](#standard-elements)\n  - [Inputs](#inputs)\n- [Contributing](#contributing)\n  - [Testing](#testing)\n- [Browser Support](#browser-support)\n- [License](#license)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n\n\n# Alkali Basics\n\nThe basic approach of using Alkali within your application, is to first create "Variables" that holds your source data. A variable is the central entity in Alkali and represents a value that may change and can be reacted to. Next, we can traverse or transform variables into other derived variables. These variables can be used in the browser or server-side (in Node). In the browser, we can use these transformations, or the orginal variables directly, in element constructors to create bindings to DOM elements. A simple example would look like:\n```javascript\nimport { reactive, Div, Span } from \'alkali\'\n\n// construct a variable\nlet greeting = reactive(\'Hi\')\n// create a new variable based on the first\nlet fullGreeting = greeting.to(greeting => greeting + \', World\')\n// construct a div, with the fullGreeting variable bound as the content\ndocument.body.appendChild(new Div(fullGreeting))\n```\nThis would create a new `<div>` bound to our `greeting` variable with an initial value of `"Hi"`. From here we can make changes to variables, and changes will flow through:\n```javascript\ngreeting.put(\'Hello\')\n```\nThis will notify derived variables and bound elements. This will result in the element binding queuing up a rendering, which will later execute and execute any necessary transforms, showing "Hello, World" in our `<div>`.\n\n## Installation\n\nAlkali can be installed with `npm install alkali` or cloned from the github. Alkali works with ES6, CommonJS, or AMD modules bundlers/loaders. Or, you can load `dist/index.js` (from the package or from [github CDN](http://rawgit.com/kriszyp/alkali/master/dist/index.js)) as a script and use the `alkali` global. Also, here is a [codepen with a basic example to start trying out Alkali](http://codepen.io/kriszyp/pen/xEEBKY?editors=1111).\n\n# Compatibility\n\nAlkali is tested and runs on IE11+ or any other modern browser, and can also on NodeJS (without DOM generation). There is some very limited support for IE9-10.\n\n# Variables\n\nAgain, the central entity in the data model system is a "Variable" (similar notion has variously been known by various names such as "reactive", "signal", "property", "stream", "observable", and others). This object represents and holds a value that may change in the future. A variable can also be likened to a promise, except it can continue to change, rather than resolving one time. Depending on the interface, we can read the value, be notified when it has changed, change the value, and get meta and error information about the type of the value.\n\nThe simplest way to create a variable is by calling the `reactive(initialValue)` function, which will provided value as the initial value of the variable.\n\nNotifications of data changes are delivered by update notifications. When a downstream subscriber is interested in the results of a variable change, it can request the latest value. This is subtly distinct from "streams", in that unnecessary computations can be avoided and optimized when only the current state (rather than the history of every intermediate change) is of interest. Variables can also employ internal caching of calculated values. And Variables support bi-directional flow. They can be modified as well as monitored.\n\nVariables also support promises as values, and the variable pipeline will handle waiting for a promises to resolve to do computations.\n\nAlkali uses extendable element constructors and updaters that are designed to consume variables, binding to variables values, and reactively responding to variable changes. They can also bound to inputs that will update variables in respond to user changes.\n\nThe Variable class can be extended and variable classes can be used like variables, where the instance to be acted on, can be resolved as needed. This allows for structured variables and categorical relationships between variable and element classes to be defined, and resolved based on context.\n\nThe main/index module in alkali exports all of functionality in alkali. If you are using ES6 module format, you can import different constructors and utilities like:\n```javascript\nimport { reactive, Div } from \'alkali\'\n```\nAlkali uses UMD format, so it can be consumed by CommonJS or AMD module systems as well.\n\n## Debugging/Interaction\n\nSee the [Debugging](#debugging) section below for information on debugging tips with standard developer tools.\n\n## Todo Example\n[Alkali-Todo](https://github.com/kriszyp/alkali-todo) is a the TodoMVC application written with Alkali. This repository includes a walk-through for a good example-based approach to learning to use Alkali.\n\n## Typings\nAlkali includes an `index.d.ts` file to provide a TypeScript type interface.\n\n## TypeScript Plugin for Reactive Expressions\nThe [ts-transform-alkali](https://github.com/kriszyp/ts-transform-reactive) can optionally be used to write and transform reactive properties and expressions that create alkali variables and properties with decorators.\n\n## Babel Plugin for Reactive Expressions\nAlso, the [babel-plugin-transform-alkali](https://github.com/kriszyp/babel-plugin-transform-alkali) can optionally be used to write and transform reactive expressions for babel.\n\n## `Variable`/`reactive` API\n\nThe `Variable` class and `reactive` function are the main API for creating variables with most data.\n\n### `reactive(initialValue: any)`: Variable\nThis creates a new variable, using the intial value. The provided value will also be used to dictate the "type" or structure of the returned variable. Providing a primitive will return a variable with reactive methods mirroring the primitive methods. If you provide an object, it will return variable with reactive properties corresponding to the properties on the object. For example:\n```javascript\nimport { reactive } from \'alkali\'\nlet greeting = reactive(\'hello\')\nlet upperCaseHello = greeting.toUpperCase()\nupperCaseHello.valueOf() -> "HELLO"\ngreeting.put(\'hi\')\nupperCaseHello.valueOf() -> "HI" // reactively updates\n```\n\nLikewise returned variables will have reactive properties:\n```javascript\nlet person = reactive({\n\tname: \'John\',\n})\nlet name = person.name\nname.valueOf() -> \'John\'\nperson.name = \'Jane\'\nname.valueOf() -> \'Jane\'\n```\n\n## Variable API\n\nThe Variable class defines the variable structure, their properties and methods, and provides a base class for creating new variable classes.\n\n### `new Variable(initialValue: any)`\n\nThis is the constructor for a variable. You may create a variable with an initial value, provided as the optional argument.\n\n### `valueOf()`\n\nThis returns the current value of the variable. This method also allows variables to be used directly in expressions in place of primitive values, where JavaScript coercion will automatically convert a value. For example a variable with the number 4 can be used:\n```javascript\nimport { reactive } from \'alkali\' // assuming modern-ES or TS module transpilation\nlet four = reactive(4)\nfour * four -> 16\n\'#\' + four -> \'#4\'\nfour < 5 -> true\nfour == 4 -> true\n```\n\nIf the variable requires asynchronous resolution (async transform or source), this will return a promise.\n\n### `then(onFulfilled, onRejected)`\n\nThis also retrieves the current of the variable, using the standard promise API/callback. This method also means that all variables can be treated as promises/thenables, and used in places that accept promises, including the `await` operator.\n\n### `put(value)`\n\n`put` allows us to update the value of a variable with a new value. This can be given a standard value, or you can pass in another variable, in which case this variable will be "linked" to the other, receiving all values and updates from the provided variable.\n\nIf the `value` passed in is not different than the current value, no changes will be made and this will return `Variable.noChange`. If the value can not be assigned, it will return `Variable.deny`.\n\n### `property(propertyName, PropertyClass?)`\n\nThis returns a variable representing the value of the property of the variable. If this variable\'s value is an object, the property variable\'s value will be the value of the given property name. This variable will respond to changes in the object, and putting a value in a property variable will update the corresponding property on the parent object. For example:\n```javascript\nlet object = {foo: 1};\nlet objectVar = reactive(object);\nlet foo = objectVar.property(\'foo\');\nfoo.valueOf() -> 1\nfoo.put(2);\nobject.foo -> 2\n```\nAn optional class can be provided to define the class to use/instantiate for the property. Once the property variable has been created/accessed, it will be available as a property directly on the variable (as long as it doesn\'t conflict with any methods). In the case the property variable can be accessed from `objectVar.foo`.\n\n\n### `to(function, reversal?)`\n\nThis maps or transforms the value of the current variable to a new variable (that is returned), reflecting the current value of the variable (and any future changes) through the execution of the callback function. The callback function is called when the variable is changed and there is downstream interest in, or demand for it, and is called with the value and should return a value to be provided to the returned variable. For example:\n```javascript\nlet number = reactive(3);\nnumber.valueOf() -> 3\nlet doubled = number.to((value) => value * 2);\ndoubled.valueOf() -> 6\nnumber.put(5);\nnumber.valueOf() -> 5\ndoubled.valueOf() -> 10\n```\n\nA `to` function can return variables as well, in which case you can effectively chain variables together, merging their changes. For example:\n```javascript\nlet a = reactive(1)\nlet b = reactive(2)\nlet sum = a.to((aValue) => {\n\treturn b.to((bValue) => {\n\t\treturn aValue + bValue;\n\t})\n})\n// sum will reactively update to changes in either a or b\n```\nThe `to` function will also wait for any promise values to resolve before executing as well.\n\nThe optional `reversal` argument can define a function that will be called when the returned variable is changed (with `put` or child `set`), and can handle sending data back to the source.\n\n### `get(propertyName)`\n\nThis returns the value of the named property. The following are functionally equivalent:\n\n```javascript\nvariable.property(name).valueOf() === variable.get(name)\n```\n\n### `set(propertyName, value)`\n\nThis sets the value of the named property. The following are functionally equivalent:\n\n```javascript\nvariable.property(name).put(value)\n```\nand\n```javascript\nvariable.set(name, value)\n```\n\n### `schema`\n\nThis is a property that provides a variable representing the schema for the variable. The schema can include metadata and validation information (used for the `validation` property below). A schema can define sub-property schemas that will be applied to variable properties, as well. You can get and set this property. By default, this will return the constructor for plain variables, will get the `schema.properties[propertyName]` for property variables, and will use returned variables for derived variables.\n\n### `validation`\n\nThis is a property that provides a variable representing the validation of this variable. Alkali provides very basic validation, but generally you will want to implement your own `validate` method, which can use the `schema` to validate variable values. See the validation section below for more information.\n\n### `subscribe(listener)`\n\nThis adds a listener for any changes to the variable. If you provide a function, this will be called with an event object that has a `value()` method that can be called to get the current value. You can also use a subscriber object with a `next(value)` method, based on the proposed ES7 Observable API. However, use of `subscribe` to immediately access the value is generally discouraged, because it require immediate recomputation, rather than using alkali\'s optimized resource management. It is preferred to propagate changes through Variables to Elements and Renderers, as they provide more efficient resource management and avoid unnecessary computations. One of other distinction in these APIs is that when an object with `next(value)` is provided, and the variable resolves asynchrounsly (it or an upstream variable is assigned a promise), `next` will not be called until the promise is resolved the event listener will be called immediately (when the assignment takes place).\n\nThis method will return an object with an `unsubscribe` method, which you can call to stop a subscription.\n\n### `Variable.for(subject)`\n\nThis static method will return a variable instance mapped to the target object. This will return a stable reference to a variable instance, the first call for a given target object will create a new instance, and subsequently calls with return the same variable. This can be very useful if independent code will access the same object(s) and make changes to the object and ensure that the changes are communicated through the same variable.\n\n### `all(array, transform?)`\n\nThis function allows you to compose a new variable from an array of input variables, where the resulting variable will update in response to changes from any of the input variables. The return variable will hold an array of values that represent the value of each of the input variable\'s values (in the same order as the variables were provided). This is intended to mirror the `Promise.all()` API. For example:\n\n```javascript\nimport { all, reactive } from \'alkali\'\nlet a = reactive(1);\nlet b = reactive(2);\nlet sum = all(a, b).to(([a, b]) => a + b);\n```\n\n`all` will also work with a set of arguments, instead of an array. It was will also work with an object, in which case each property value will be resolved, and the result will resolved to an object with the resolved values.\n\nYou can also provide an optional `transform` argument that will do a transform of the input values, which is essentially shorthand for `all(...).to(...)`:\n```javascript\nlet sum = all([a, b], (a, b) => a + b);\n```\n\n## Variables as Arrays (`VArray`)\n\nVariables provide most of the array methods for when the value of a variable is an array, by using the `VArray` constructor. Methods including `push`, `splice`, `pop`, and `forEach` are all available on these variables, and will act on the underlying array, and send out the proper update notifications for modifications. When arrays are modified through variables, the update notifications are incremental, and can be much more efficient for downstream listeners that support them (including alkali element lists).\n\nFunctional array methods can also be applied, which will return a new variable, which will stay updated with results synced to the source array. These include `filter`, `map`, `every`, `same`, `reduce`, and `reduceRight` which take the same arguments and behave according to the standard methods.\n\nAlso, variables with arrays can be used as iterables in for-of loops. For example:\n```javascript\nvar letters = new VArray([\'a\', \'b\', \'c\']);\narrayVariable.push(\'d\');\nlet lettersAfterB = letters.filter(letter => letter > \'b\');\nfor (let letter of lettersAfterB) {\n\t...\n}\n```\n\nIn addition, VArray\'s implements most `Set` methods, and supports key-based interaction, for retrieving and removing values based on their id/primary-key. If entries in the array can be uniquely identified, support for this can be added by implementing a `getId(entry)` method.\n\n`keyBy` and `groupBy` methods are also available:\n`keyBy(getKey(element, emit(key, value))?, getValue(element)?)` - This will index the values in array using the provided key retrieval, `getKey`, which can be a string to indicate a property, or a function to retrieve the key from the element. The `getKey` receives the `element` and can return the appropriate key. It also has an `emit` function that can optionally be used to add additional entries to the index. If omitted, value itself will be the key. In addition `getValue` can also provided to retrieve the value, if something other than the original array element is desired. This will return a Map variable, which can be used to retrieve values by id.\n\n`groupBy(getKey(element, emit), ?, getValue(element)?)` - This behaves the same as `keyBy` but can be used when multiple elements may share the same key. This will put all the elements for a given in an array under the key. The returned Map variable will have array values.\n\n## Structured Variables\n\nWith variables we can define structured data that will be represented by a corresponding variable structure. We can create new extended `Variable`s with their own object structure. This can be done by provided a structure in a call to `Variable.with` or a direct call (without `new`) which will return an subclassed `Variable` class/constructor. Once we have defined the structure, these property variables will be available as properties directly on the variable class and instances. For example:\n```javascript\nlet MyVariable = Variable.with({\n\tname: VString,\n\t// we can subclass and define structures and use these in properties\n\tsubObject: Variable({\n\t\tsubValue: VNumber,\n\t\tfoo: OtherCustomVariable\n\t})\n})\n```\n([JSFiddle example](https://jsfiddle.net/kriszyp/8oLtfz10/4/))\n\nThis is a useful pattern because it defines a structure for your data, and these sub-variables can easily be accessed as first class properties (rather than going through the `property` API). We can also values to these properties and they will be assigned to the value of the variable. For example:\n```javascript\nlet myVar = new MyVariable({ name: \'Alkali\' });\nmyVar.name; // the "name" property variable\nmyVar.name.valueOf(); -> \'Alkali\'\nmyVar.name.subscribe(event => console.log(\'new name\', event.value()));\n// assign a new value to the property, will trigger the listener\nmyVar.name = \'New name\';\n// assignment the same as this:\nmyVar.name.put(\'New name\');\n// we can traverse into the sub class/objects:\nmyVar.subObject.subValue.put(3);\n```\nWe could go further and define list structures as well (here we demonstrate inline class definitions):\n```javascript\nlet MyVariable = Variable({\n\tmyList: VArray.of(Variable({\n\t\tfoo: Variable()\n\t}))\n});\n```\n\n## Variable `collection`s\nIn addition, any time you create a new variable class (with `Variable.with`, `Variable`, or extending with `class` syntax), this class has its own implicit, default collection (and instance of `VArray.of(Class)`) that can be accessed from the static `collection` property, and instances can be added to and removed from it. The idiomatic way to create a model class with alkali is to create a variable class and then using it\'s collection to manage and interact with the set of instances. For example:\n```javascript\nlet MyVariable = Variable.with({\n\tname: VString,\n\tage: VNumber\n});\nlet john = MyVariable.collection.push({ name: "John", age: 17})\n```\n\nFurthermore, for convenience in using this idiomatic pattern, the array methods are directly available as static methods on the model class:\n```javascript\nMyVariable.push({ name: "John", age: 17})\nlet filtered = MyVariable.filter(person => person.age > 15)\n```\n\n### Primitive Typed Variables\nWe can also define properties with a specific primitive type. Alkali exports classes for primitive typed variables:\n* VString\n* VNumber\n* VBoolean\n* VDate\n* VSet\n* VPromise\n* VMap\n\nEach of these have methods corresponding to the methods on the original primitive. For non-mutating accessor methods, the method will return a new variable representing the result of applying the method to the value. For example:\n```javascript\nlet greeting = new VString(\'hello, world\')\nlet greet = vs.slice(0, 5)\ngreet.valueOf() -> \'hello\'\ngreeting.put(\'hi there\')\ngreet.valueOf() -> \'hi th\'\n```\nAnd the mutating methods (that change the value of the primitive) will change the primitive and notifying any listeners:\n```javascript\nlet set = new VSet([\'a\', \'b\'])\nlet hasC = set.has(\'c\')\nhasC.valueOf() -> false\nset.add(\'c\')\nhasC.valueOf() -> true\n```\n\n### Subclassing Structured Variables\nVariables can also be subclassed with native class syntax. Subclassed variables can not be directly called without `new` (no classes can), but you can derive new structured variables from variable subclasses using the `.with(structure)` method, just as you would above:\n```javascript\nclass MyVariable extends Variable {\n  ...\n}\nlet AnotherVariable = MyVariable.with({\n  name: VString\n})\n```\n\n## EcmaScript Generator Support (`react()`)\n\nEcmaScript\'s new generator functions provide an elegant way to define reactive variable-based functions. Alkali provides a `react()` function that will take a generator function that yields variables and execute the function reactively, inputting variable values, and re-executing in response to changes. For example, we could create a function that computes the maximum of two other variables by simply writing:\n```javascript\nimport { react } from \'alkali\'\n\nlet sumOfAAndB = react(function*() {\n\treturn Math.max(yield a, yield b)\n})\n```\nThe resulting variable will reactively update in response to changes in the variable `a` or `b`.\n\nThis reactive function will also properly wait for promises; it can be used with variables that resolve to promises or even directly with promises themselves.\n\n### Generator Computed Properties\n\nReactive generators can also be directly defined in the variable structures. A computed variable property be assigned by providing a generator method used to calculate the variable value. This will generate a getter for the property that will return a variable based on the generator method. This method can be written in same way as the `react` generator functions described above, where you use the `yield` operator on each variable. The generator method also has access to `this`. Generator getters can be defined on variable classes or element classes. For example:\n\n```javascript\nlet MyVariable = Variable({\n\t*name() { // this will create a computed property for "name"\n\t\treturn `${yield this.firstName} ${yield this.lastName}`\n\t},\n\tfirstName: Variable,\n\tlastName: Variable\n})\nlet v = new MyVariable({\n\tfirstName: \'John\',\n\tlastName: \'Doe\'\n})\nlet name = v.name // the name property will return a variable\nname.valueOf() -> \'John Doe\'\nv.lastName = \'Smith\' // this will update "name" to have a value of "John Smith"\n```\n[See JSFiddle Example](https://jsfiddle.net/kriszyp/54b9gq7b/4/)\n\n# Element Construction\n\nAlkali includes functionality for constructing and extending from native DOM elements, and binding these elements to variables for reactive UIs. The `alkali` module exports the full set of native element constructors (see the list at the end of the documentation), as properties, to use for streamlined creation of DOM elements. For example, using EcmaScript\'s module format to import:\n\n```javascript\nimport { Div, Span, Anchor, TextInput } from \'alkali\';\n\nlet divElement = new Div();\nlet spanElement = new Span();\ndocument.body.appendChild(divElement).appendChild(spanElement);\n```\n\nIn addition, an element has a `create` method that may be alternately called to create a new element. `new Element()` and `Element.create()` are equivalent.\n\nThese classes create native DOM elements that can be placed directly into the DOM (it is not a wrapper). All the standardized element types should be available from the module (they are all properties of the module, and if you are not using ES6, you can access them like `Element.Div`). These classes can take several arguments for constructing elements. The first argument is an optional string in CSS selector format that can be used to define the class, id, or tag. For example, to create a div with a class of `\'my-class\'` and id of `\'my-id\'`:\n\n```javascript\nlet divElement = new Div(\'.my-class#my-id\');\n```\nAll remaining arguments can be in any order and be any of these types:\n\n## Properties Argument\n\nAn argument can be an object with properties that will be copied to the target element. For example, we could create `<a>` element with a link:\n```javascript\nnew Anchor({\n\thref: \'a url\',\n\ttextContent: \'click here\'\n});\n```\nEach of the property values will be assigned to the newly created element.\n\nIf any of the values are alkali variables, they will be automatically bound to the element, reactively updating the element in response to any changes to the variable. For example:\n```javascript\nlet a = reactive(1);\ndocument.body.appendChild(new Div({title: a}));\na.put(2); // will update the title of the div\n```\n\nYou can also use a variable for input value properties (`value`, `valueAsNumber`, and `checked`), and the variable will be auto-updated with user changes to the input.\n\nYou can alse use variable classes for property values as well. These are described below.\n\nAlkali uses an optimized strategy for updating elements, by waiting for the next animation frame to update, and only updating elements that are connected to the DOM.\n\nBy default, properties are copied directly to the element that is being, or will be, created. However, Alkali also provides special handling for certain properties:\n* `href`, `id`, `innerHTML`, `src`, `tabIndex`, `title`, `textContent`, etc. - All the standard DOM element properties are copied to the target element, and any of these can contain a static value or a variable. A variable will auto-update the value of the property with the value of the variable.\n* `content` - This represents the main content of an element, and can depend on the type of element. For most elements, this represents the inner content of element. If it is a primitive, it will be the text content (inserted as a text node). If it is an array, it will generate a set of child elements. For inputs, the content corresponds to the `value` or `checked` property of the input, typed to the type of value that the input expects (numbers for number inputs), with bi-directional binding.\n* `classes` - This can be an object where each property corresponds to a class name that can be conditionally turned on or off for the element. For each property, the value can be a boolean or variable that returns a boolean (or anything that can be evaluated as truthy or falsy). This is typically the best way to enable and disable conditional styling for an element.\n* `class`, `for`, `role` - These are copied to their corresponding attributes.\n* `attributes` This can be an object, and the properties are copied to attributes on the element.\n* `dataset` - This can be an object, and the properties are copied to the elements `dataset` object to construct custom-user attributes.\n* `style` - This can be an object, and the properties are copied to the elements `style` object to construct inline styles.\n* CSS style properties - Inline style properties can be defined directly in the properties argument as well, and will create inline styles. When used as direct properties, booleans will be converted to named values for certain properties (for `display`, `visibility`), and numbers will be appended with `px` for dimensional properties.\n* `render` - This described below.\n* If a property is not recognized as one of these handled properties described above, the value will be copied to the target element (if the value is variable, the variable itself will be copied directly). To avoid any unexpected property collisions, Alkali keeps a whitelist of known/standard element and style properties, such that if an unknown property on an element exists, it will be overriden (and its behavior ignored).\n\nIn addition, custom handling of properties can be defined creating render methods or getters and setters as described below.\n[See JSFiddle Example](https://jsfiddle.net/kriszyp/7ndqjoyd/4/)\n\n### Children Array Argument\n\nAn argument can be an array that defines a set of elements to use as the content or children of the created element. An array should consist of items where each item corresponds to the node that will be created as a child. This array can contain any of the following:\n* Element classes - These will generate new elements\n* Element instances - This is will be directly inserted\n* Variables or primitives - These will be converted to text nodes\n* Or nested arrays -\tThis will result in nested elements (within the last element before the array). Sub-array elements will be added as children of the preceding element.\n\nFor example, we could create a table:\n```javascript\nimport { Table, TR, TD } from \'alkali\';\nlet table = new Table([\n\tTR, [\n\t\tTD, [\'Column 1, Row 1\'],\n\t\tTD, [\'Column 2, Row 1\'],\n\t],\n\tTR, [\n\t\tTD, [\'Column 1, Row 2\'],\n\t\tTD, [\'Column 2, Row 2\'],\n\t]\n]);\n```\n[See JSFiddle Example](https://jsfiddle.net/kriszyp/nyz05qLm/1/)\n\n### Variable Argument\n\nA variable may be provided directly as an argument as well. This variable will be connected to the default `content` of the element. Again, for most elements, this variable will be mapped to the text content of the element. For example:\n```javascript\nlet greeting = reactive(\'Hello\');\nnew Span(greeting);\n```\nAnd for input elements, the `content` of the element is the value of the input. This makes it easy to setup bi-direction bindings from inputs to variables. For example:\n```javascript\nlet a = reactive();\nnew TextInput(a);\n```\nThe variable `a` will be mapped to this new input. This means that any changes made to `a` will cause the input to be updated, and any changes that the user makes to the input will update the variable (two-way binding).\n\nWhen an element is detached from the DOM, it will no longer listen for variable changes (allowing the variables and all dependencies to be automatically cleaned up).\n\n### String (and numbers, booleans) Argument\nYou can also simply provide a string (or any primitive, including numbers or booleans), and this will also be directly inserted as a text node. For example:\n```javascript\nnew Div(\'Some text to put in the div\');\n```\n\nNote that if you are using a string as the first argument, if it starts with a \'.\' or \'#\', it will be interpreted as a selector. Only the first argument can be selector, so a string-as-text can be safely used with any starting character for subsequent arguments. You can safely output variable or user-provided strings with explicit content (`Div({content: someString})`), or as an explicit child (`Div([someString])`).\n\n### `null` and `undefined`\nAny null or undefined argument will be ignored. This can be useful for conditionally creating elements:\n\n```javascript\nDiv([\n\tmaybeIncludeChild ? Span : null\n])\n```\n\n### Event Handlers\nThe properties argument may also define event handlers. These event handlers are simply functions defined with the same event handler names as used by event attributes (however, these are not implemented using "DOM0" event registration, Alkali uses modern event registration to setup these handlers). For example, we could create a span that listens for clicks:\n```javascript\nnew Span({\n\tonclick(event) {\n\t\t// click event occurred\n\t},\n\tonmouseover: mouseOverHandler\n});\n```\n[See Example](https://jsfiddle.net/kriszyp/7ndqjoyd/3/)\n\n## Extending Elements\n\nThe Alkali element classes are designed to be extended or derived so that you can easily create your own custom components and constructors. Extended element classes can define default properties, bindings, and children elements as well. When you call a class with the `new` operator or call the `create` method, you are creating a new element instance. But, you can also derive new constructors or classes. The first way to do this is by creating an extended constructor. By calling a class without the `new` operator or if you use the `with` method, you will create a new constructor of the original element class (or constructor). Creating new constructors works much like creating new instances, taking the same types of arguments, and defines a set of properties or event handlers to be assigned to an element instance on instantiation. An extended constructor constructs true extended native DOM element. For example, we could create a custom div constructor with a pre-defined HTML class attribute:\n```javascript\nlet MyDiv = Div(\'.my-class\')\n// and we can create new elements from this, just like with standard element classes\nlet myDivElement = new MyDiv()\n```\nWe can also define default property values and define a children layout, to create our own complex components. For example, we could go further in extending a Div:\n```javascript\nlet MyComponent = Div({\n\ttitle: \'a default title\'\n}, [\n\tSpan,\n\tP\n]);\n```\nThese resulting extended constructors can be used like any other element classes, including in child layouts, making it easy to create a hierarchy of layout:\n```javascript\nlet AnotherComponent = Div([\n\tH2(someVariable),\n\tMyComponent(\'.add-a-class\', {\n\t\tonclick() { // ...\n\t\t}\n\t})\n]);\n```\nAnd we can create element instances by using a new operator with nested constructors for a clean hierarchical syntax:\n```javascript\n\tnew UList([\n\t\tLI([Span(\'.a-class\', \'first\')]),\n\t\tLI([Span(\'.a-class\', \'second\')]),\n\t]);\n```\n\n## Creating/Extending Element Classes (Components)\nTrue custom element classes or components can also be created by using the native JavaScript class extension mechanism, or any transpilation or class emulation (like Babel). We can extend from an existing element class (or constructor), and create a real new class with its own prototype (that inherits the native methods and properties). This is appropriate to use when creating new components with their own behavior defined in methods and event handlers. For example, we could write:\n```javascript\nclass MyDiv extends Div {\n\tonclick() {\n\t\tthis.doSomething();\n\t}\n\tdoSomething() {\n\t\tsuper.click();\n\t}\n}\n```\nOne of the advantages of using classes is that it allows you to use the `super` operator to call super class methods, permitting more sophisticated element class composition. Note that there are some limitations to using native class syntax. EcmaScript does not currently support properties, nor does it support direct constructor calls, so if you want to create a new derived constructor from a natively constructed class, this must be done through the `with` method (instances can still be created with the `new` operator). Assigning default properties or children can be done by calling with properties before or after class extending:\n```javascript\nclass MyDiv extends Div({title: \'default title\'}) {\n\t// class methods\n}\n```\nAnd we can create a constructor from MyDiv with properties to be assigned to the instances:\n```javascript\nMyDivWithClass = MyDiv.with(\'.a-class\', {title: \'a different title\'});\n```\n\nNote that if you are using TypeScript, event handlers must be defined as class property (with a function value):\n```javascript\n\tonclick = function() {\n\t\tthis.doSomething();\n\t}\n```\n[See JSFiddle Example](https://jsfiddle.net/kriszyp/yun2y5dy/4/)\n\n#### Children\nYou can also define a set of children for by setting the static children property of a class:\n```javascript\nMyDiv.children = [\n\tDiv,\n\tSpan\n];\n```\nor\n```javascript\nclass MyDiv extends Div {\n\tstatic get children() {\n\t\treturn [Div, Span];\n\t}\n}\n```\nThis is distinct from providing an array of elements or other values as the `content` (or as an argument) of an element. The `children` represents  the intrinsic structure of an element, and the `content` is inserted after the children are created. Consequently we could define a structure like:\n```javascript\nimport { Div, Span, content } from \'alkali\'\n...\nMyDiv.children = [\n\tSpan(\'Hello\'),\n\tcontent(Div)\n]\n\nnew MyDiv([Span(\'.inner-span\', \'World\')])\n```\nWhich would create a structure like:\n```html\n<div>\n\t<span>Hello</span>\n\t<div>\n\t\t<span class="inner-span">World</span>\n\t</div>\n</div>\n```\nChildren can alternately be defined as a shadow DOM structure by using `shadow` instead of `children`.\n\n\n[See JSFiddle Example](https://jsfiddle.net/kriszyp/yun2y5dy/4/)\n\n### Property Declaration\n\nWe can also declare properties on our elements through a constructor call, just as we would with a variable. When we define a property with a variable, this will make the property consistently available as a variable statically on the element and on the element instance. For example, we can declare that an element expects a `title` and `body` properties that we expect to be passed in on creation:\n```javascript\nlet MyDiv = Div({\n  title: Variable,\n  body: Variable,\n  created(properties) {\n    properties.title // this will always be a variable, if a title is provided it will be initialized that value\n    // properties.body will be a variable as well\n    properties.content = properties.body.to(body => \'Body: \' + body)\n  }\n})\nlet myDiv = new MyDiv({title: 3})\nmyDiv.title // this will be a variable that has been initialized to 3\nmyDiv.title.put(4) // we can update the variable\nmyDiv.body.put(\'new body\') // this will be a variable as well, and we can update it\n```\nThis variables will also be statically available, which can be useful for statically defining the element children/structure:\n```javascript\nlet MyDiv = Div({\n  title: Variable,\n  body: Variable\n})\n```\nWe can then easily reference those properties:\n```javascript\nMyDiv.children = [\n  H1(MyDiv.title),\n  Div(\'.body\', MyDiv.body),\n]\n```\n[See JSFiddle Example](https://jsfiddle.net/kriszyp/yun2y5dy/4/)\n\n\n### Generator getter methods\n\nAgain, if you are developing in an ES6 compatible environment (Babel or restricted set of modern browsers), you can define generator getters in constructor arguments, making it very simple to construct element properties that react to other properties and variables. A generator getter will result a property variable for custom properties. For standard/native element properties, the generator getter will reactively assign its output to the standard element property. For example:\n\n```javascript\nlet MyLink = Anchor({\n\t*path() { // custom property\n\t\treturn `${yield this.owner}/${this.repo}`\n\t},\n\t*href() { // defines the href for the <a> element\n\t\treturn `https://${yield this.domain}/${yield this.path}`\n\t},\n\t*content() { // defines the contents of the <a> element\n\t\treturn \'Link to \' + (yield this.path)\n\t}\n})\nlet alkali = reactive(\'alkali\')\nnew MyLink({\n\tdomain: \'github.com\', // these can be variables or static values\n\towner: \'kriszyp\',\n\trepo: alkali\n})\n```\n\n#### Generator `*render` Method\n\nIn addition to getter generators, you can define a singular `*render` method to modify an element in response to variables. The `*render` method can be used on classes, constructors, or element instantiation. For example, without even creating a class we can write:\n```javascript\nnew Div({\n\t*render() {\n\t\tthis.title = yield titleVariable;\n\t\t...\n\t}\n})\n```\n[See JSFiddle Example](https://jsfiddle.net/kriszyp/yun2y5dy/4/)\n\n### Construction Lifecycle Methods\n\nThere are several methods that are called as part of the construction of an element that can be used to define additional behavior of an element. These include:\n* `created(properties)` - This is called for each new element instance prior to applying any properties or doing any rendering of the element or children, or attaching to the DOM. It is called with the properties that were provided to construct the element (merged arguments from construction, including original variables in the case of properties that contain variables). This method can modify the properties object, to apply different properties to the element during construction. This is the most common method for adding custom handling of elements. When an element contains children, the parent will be executed before the children `created` methods.\n* `ready(properties)` - This is called for each new element instance after the properties have been applied and rendering and construction of children have completed, and is called with the properties that were provided to construct the element (including original variables in the case of properties that contain variables). It is called after the properties and children have been assigned, but before the element is attached to a parent. Generally, DOM operations are faster prior to an element being attached. When an element contains children, the children will be executed before the parent `ready` method.\n* `attached()` (and `attachedCallback()`) - This is called when an element is attached to the document tree. This is useful for performing operations that may involve dimensional layout (measuring dimensions), requiring the element to be attached. When an element contains children, the parent will be executed before the children `attached` methods.\n* `detached()` - This is called when an element is detached from the document tree. This can be a useful place to perform cleanup operations. However, elements may be reattached as well (and `attached` would be called again).\n\nFor example:\n```javascript\nclass MyComponent extends Div {\n\tcreated(properties) {\n\t\t// we can interact with the properties that were passed in, and add to them\n\t\tproperties.content = [\n\t\t\tH2(\'Hello, \' + properties.greeting)\n\t\t];\n\t}\n\tready(properties) {\n\t\t// the properties have been set, do any additional manipulation\n\t\tthis.appendChild(new Span(\'World\'));\n\t}\n\tattached() {\n\t\t// we can measure now\n\t\tlet myWidth = this.offsetWidth;\n\t}\n}\n```\n\n## Variable Classes\n\nWe can create our own variable classes that can be used to define properties and be referenced as well. When we use our own variable classes in property declarations, this will define a relationship between an element class and a variable class. Variable classes have the same api as normal variables, and you can then use the variable class within properties of the defined element, or any child elements. For example:\n\n```javascript\nlet Title = Variable()\nlet MyComponent = Div({\n\ttitle: Title // Define title to be our own variable type\n}, [\n\tSpan(\'.some-child-element\', [\n\t\tTitle // can even reference the variable class in child elements\n\t])\n])\n```\nNow each instance of `MyComponent` that we create, will have a corresponding value/object for `MyVariable`, and those can even be accessed from child elements. We can also programmatically access the variable instance for a given element:\n```javascript\nlet myComponent = new MyComponent()\nvar title = Title.for(myComponent)\n// will update the element instance\ntitle.put(\'Hello\')\n```\n\nElement classes themselves also act as variable classes. Element classes include a static `property` method, like variables, which maps to the properties of the elements themselves. This makes it convenient to declaratively use element properties in child elements.\n\n## Element Lists/Loops\n\nOften you may want to create a set of child elements, based on an array or list of values or objects. You can provide an array, or a variable with an array, as the `content` of an element, and then define a child element structure to be generated for item in the array with an `each` property. The child element structure can then access the current item in the array loop through the `Item` variable class. For example, we could create a `ul` element with `li` children by doing:\n\n```javascript\nimport { UL, LI, Item } from \'alkali\';\n\nnew UL({\n\tcontent: [\'One\', \'Two\'],\n\teach: LI(Item)\n});\n```\nLike any other variable class, we can access properties from the `Item` class as well, and create more sophisticated child structures. Here is how to create a select dropdown:\n```javascript\nimport { Select, Option, Item } from \'alkali\';\nnew Select({\n\tcontent: [{id: 1, name: \'One\'}, {id: 2, name: \'Two\'}],\n\teach: Option({\n\t\tvalue: Item.property(\'id\'),\n\t\tcontent: Item.property(\'name\')\n\t})\n});\n\n```\nAgain, we can also use a variable that contains an array as the content to drive the list. When using a variable, the child elements will reactively be added, removed, or updated as the variable is modified in the future. If we use the array methods on the variable, the updates will be progressive or iterative, and will not require rerendering the whole list.\n\nThe generic `Item` class can be limiting in that it offers no connection back to a collection for updates. However, classes can extend a `VArray` and define a relationship with the class of the items within the array/collection. This can done setting a static `collection` property on the item class to reference the collection class. For example:\n```javascript\nclass Widgets extends VArray {...}\nclass Widget extends Variable {...}\nWidget.collection = Widgets\n```\nOne this has been the child class can be referenced in loops as well, and the changes can propagate to the collection:\n```javascript\nnew Div({\n\tcontent: Widgets,\n\teach: Input(Widget.property(\'selected\'))\n});\n```\nAlternately, you can define this relationship with `Widgets.collectionOf = Widget`\n\nAnother means of generating elements from list or array data is to use a `map` method:\n```javascript\nnew Select({\n\tcontent: options.map(item =>\n\t\tOption({\n\t\t\tvalue: item.id,\n\t\t\tcontent: item.name\n\t\t}))\n})\n```\nThis will also respond to changes (additions, removals) in the source array, if it is a variable.\n\n## Metadata and Validation\n\nAlkali provides metadata/schema information, as well as validation functionality that can be associated with variables and their properties and derived variables. This can further facilitate the encapsulation of a property, allowing you variable-aware UI controls to interact with a variable or property\'s future value changes, as well as metadata and validation that further defines the property.\n\nYou can define the schema for a variable by setting the `schema` property on a variable or defining a getter for the property. If you don\'t define a schema, the default schema is the variable\'s constructor. In any case, you can define metadata on your schema that is available for downstream use. A schema can also define metadata for properties, which is generally more useful. This is done by putting property definitions, in a `properties` object, with each property defining a schema for the corresponding property. For example, we could define a variable class that specifies that the `email` property should have a metadata property of `required: true`:\n```javascript\nlet ValidatedVariable = Variable({\n\temail: Variable({\n\t\trequired: true,\n\t\tdescription: \'Email address\'\n\t})\n}\n```\nNow we could define a UI control that makes use of this:\n```javascript\nclass FormField extends Label {\n\n}\nlet content = FormField.property(\'content\')\nFormField.children = [\n\tcontent.schema.description, \': \',\n\tInput(content, {\n\t\trequired: content.schema.required\n\t})\n]\n```\nThis form field class only relies on the variable/property to construct the label, input, and required attribute. We could then use it:\n```javascript\nvar entry = new ValidatedVariable({})\nform.append(FormField(entry.property(\'email\')))\n```\nWe could also add a `validate` method that will be called to determine the `validation` of the variable:\n```javascript\nlet ValidatedVariable = Variable({\n\tvalidate(value, schema) {\n\t\tif (schema.pattern && !schema.pattern.test(value)) {\n\t\t\treturn [\'Value is not the right format\']\n\t\t}\n\t}\n\temail: Variable({\n\t\tpattern: /\\w+@\\w+/,\n\t\t...\n})\n...\nFormField.children = [\n\t...\n\tInput(content),\n\tSpan(\'.errors\', content.validation, {\n\t\teach: errors\n}\n```\n\n## Alkali Element API\n\nAll the element classes/constructors that are exported or generated by Alkali have the following static methods/properties:\n* `create(...elementArguments)` - Creates a new element instance\n* `with(...elementArguments)` - Creates a new element constructor\n* `property(name)` - Returns a generalized variable for the property of elements of this class\n* `for(subject)` - Gets an instance of the element for the given subject\n* `children` - This an array of the children (constructors, variables, or elements) that will be constructed on instantiation\n* `inputEvents` - This is an array of events types to listen for when a variable is connected to an input\'s value. By default this is `[\'change\']`.\n\n### Alkali Element Exports\n\nSeveral additional exports are available from alkali for working with elements. The first is `assign` which allows the same type of element properties (like `classes`) that constructors can take, along with variable values, to be applied to an existing element or class/constructor. It takes the form:\n`assign(target, properties)`\n\nThe `target` can be an element, constructor, or class, and the `properties` should be an object with properties to be assigned.\n\nThese include two methods that can be added to `HTMLElement.prototype` to easily add elements to existing elements, using Alkali constructors and variables.\n\nWhen added to elements their API is:\n* `parentElement.append(...elementArguments)` - This appends new child elements to the parent element using standard alkali arguments for children (constructors, variables, elements, etc.).\n* `parentElement.prepend(...elementArguments)` - This inserts new child elements in the parent element using standard alkali arguments for children (constructors, variables, elements, etc.), before other existing elements.\n\nBoth of these methods are compatible with proposed DOM4 methods. While augmenting native objects isn\'t recommended for consumption by other libraries, it is recommended for application developers, and can be done:\n```javascript\nimport { append, prepend } from \'alkali\'\n\nHTMLElement.prototype.append = append\nHTMLElement.prototype.prepend = prepend\n```\n\n#### Options\n\nAlkali also exports an options object. It has the following properties:\n`options.moveLiveElementsEnabled` - This indicates whether or not alkali supports elements with variables, restarting the variables when an element is reattached. This is enabled (`true`) by default, but it requires expensive mutation observation, and it is recommended that you disable it, and avoid reattaching alkali constructed elements (that should be created, attached, removed and left to be collected).\n\n## Renderers\n\nRenderers are an additional mechanism for making UI components react to data changes. Renderers allow us to add reactive capabilities to existing components with minimal change. Renderers are given a variable to respond to, an element (or set of elements) to attach to, and rendering functionality to perform. When an renderer\'s variable changes, it will queue the rendering functionality, and render the change in the next rendering frame, if the element is still visible. A `Renderer` can be constructed with an options object that defines the source `variable`, the associated DOM `element`, and an `renderUpdate` method that will perform the rerender with the latest value from the variable.\n\nFor example, we could create a simple variable:\n```javascript\nimport { reactive } from \'alkali\';\n\nvar greeting = reactive(\'Hi\');\n```\nAnd then define an renderer:\n```javascript\nimport { Renderer } from \'alkali\'\n\nvar greeting = reactive(\'Hi\');\nnew Renderer({\n\tvariable: greeting,\n\telement: someElement,\n\trenderUpdate: function (newValue) {\n\t\telement.innerHTML = newValue + \'.\';\n\t}\n})\n```\nAn Renderer will only update an element if it is visible, and will mark it as needing rerendering. If a hidden element is made visible again, you can trigger the rerendering by calling `Renderer.onShowElement(element)` on a parent element. You can also provide a custom definition for what constitutes a visible element that should be immediately rendered by defining a `shouldRender(element)` method, which should return true or false indicating if the element needs to be rendered.\n\nAlternately, you may set `alwaysUpdate` to true on the Renderer options to force the Renderer to always render in response to changes.\n\nIf your variables use promises, alkali will wait for the promise to resolve before calling `renderUpdate` (and it will be called with the resolution of the promise). You may define a `renderLoading` to render something while a promise is waiting to be resolved.\n\n## Reverse Mappings\n\nAlkali supports assymetric, bi-directional bindings, which means that we can variables can no only pass data downstream, but data can flow back upstream. For examples, a variable can be bound to an input, but that input may be changed by the user, causing a new value flow back up into the variable. If this flow goes through variable function mappings, that transform data downstream, you may want to define a reverse transform for data flowing back upstream. This can be done by defining a `reverse` function attached to the primary mapping function. This takes two arguments, the incoming `output` variable with the change upstream, and the downstream `inputs` variables that may need to be updated in response to the change. For example:\n```javascript\nfunction double(value) {\n\treturn value * 2\n}\ndouble.reverse = function(output, inputs) {\n\t// in reverse, we divide the value by 2\n\tinputs[0].put(output.valueOf() / 2)\n}\nlet aNumber = reactive(4)\nlet doubled = aNumber.to(double)\ndoubled.valueOf() // -> returns 8\ndoubled.put(20) // change the output, this will feed back up, and change the original variable\naNumber.valueOf() // -> returns 10\n```\n\n## Contextualization\n\nThe computations (and invalidations) can be all be executed with an optional context, which effectively allows variables to be parameterized. This means that a given variable does not have to be used to only represent a single value, but the variable may be used to represent set of different variables depending on their context. This also facilitates the construction of very powerful caching mechanisms that can intelligently cache based on determining which parameters may lead to different results.\n\n\n## Variable Copy-on-Write\n\nAlkali variables that contain objects default to using copy-on-write semantics that protects object immutability. Whenever you `set` a property on a variable containing an object, a new copy of the object will be created and assigned the provide property value, leaving the original object untouched. For example:\n```javascript\nlet obj = {foo: 1}\nlet v = reactive(obj)\nv.set(\'foo\', 2)\nv.valueOf() -> {foo: 2}\nobj.foo -> 1\n```\nThis behavior can be altered by setting the `isWritable` flag to false on a variable:\n```javascript\nlet obj = {foo: 1}\nlet v = reactive(obj)\nv.isWritable = false\nv.set(\'foo\', 2)\nobj.foo -> 2\n```\n\nAlkali variables can be assigned (with `put`) a value that is another variable. When this happens the first variable will receive the value of the assigned variable, and reflect any changes of the assigned or linked variable. The linked variable acts as an "upstream" source, and changes will propagate down. In a default assignment, changes will *not* propagate upstream, changes to the downstream variable will not affect the source. Again, a new copied object will be created to contain the changes of a downstream variable. For example:\n```javascript\nlet sourceVariable = reactive({foo: 1})\nlet containingVariable = reactive()\ncontainingVariable.put(sourceVariable)\nsourceVariable.set(\'foo\', 2) // this will propagate down to containingVariable\ncontainingVariable.set(\'foo\', 3) // this will not affect the sourceVariable\ncontainingVariable.get(\'foo\') -> 3\nsourceVariable.get(\'foo\') -> 2\n```\n\n## Variable Proxying\n\nHowever, there may be situations where you want to explicitly define a variable as a proxy, such that changes propagate to the source, as well as to the proxying variable. This can be done by using the `is` method to assign the variable, or simply passing into the `reactive` function:\n```javascript\nlet sourceVariable = reactive({foo: 1})\nlet containingVariable = reactive(sourceVariable)\ncontainingVariable.set(\'foo\', 3) // this *will* affect the sourceVariable\nsourceVariable.get(\'foo\') -> 3\ncontainingVariable.put({foo: 4}) // this will also affect the sourceVariable\nsourceVariable.get(\'foo\') -> 4\n```\nNote that when returning a variable from `to` variable transform, the resulting transform variable will use proxying behavior, by default, if there is no reverse transform that was defined.\n\n## Variable Copies\n\nAlkali includes a variable Copy constructor, that allows you to maintain a copy of an object from another variable. Variable copies are very useful in situations where you want to reactively create a working copy of any object to edit and change, and potentially later save those changes back to the original object. For example, you may want to select an object to open in a form, and allow changes to be made in form. By using a working copy, the form edits can automatically be mapped to the object, but not committed back to the original object until later:\n```javascript\nvar selectedObject = reactive(); // this will be set to the currently selected object\nvar workingCopy = new Copy(selectedObject); // holds a copy of each object contained in selectedObject\nvar myForm = new MyForm({\n\tvariable: workingCopy // we can pass this to a form, with changing the original object\n});\nmyForm.on(\'submit\', function() {\n\tworkingCopy.save(); // now save the changes back to the original object\n})\n```\n\n## Creating Web Components/Custom Tag Named Elements\n\nCustom elements (web components) can be registered with their own custom tag name as well. This can be done by extending an Element class, and calling `defineElement` with that class. This will set the tag name of the created elements, attempt to call `customElements.define` to register the element with the browser, if it is available in the browser, and return a class/constructor for the element. For example:\n```javascript\nimport { Element, defineElement } from \'alkali\'\n\nexport default defineElement(\'custom-element\',\nclass MyCustomElement extends Element { // on newer browsers we could extend other elements\n\t...\n}\n```\nNote that this functionality currently will only work predictably on all browsers by extending the generic `Element` class, as other base elements with specific functionality, like inputs and tables, will not properly inherit their functionality in olders browsers (that do not support `customElements.define`). Using `defineElement` is recommended for classes that will be frequently used and can extend generic element functionality, or in newer browser environments.\n\nAgain, the returned element constructor can be called directly to construct new constructors, instantiated.\n\nThe provided name can include selectors as well as to define a class name or ids to assign on construction:\n```javascript\ndefineElement(\'custom-element.add-this-class-too\')\n```\n\n## Additional Variable Methods\n\nThe following methods are also available on variables (but mostly used internally):\n\n### `updated(updateEvent)`\n\nThis is called to indicate that the variable has been updated. This is typically called between dependent variables, but you can also call this to indicate that an object in a variable has been modified.\n\n### `notifies(listener: { updated: (updateEvent: Event) => any })`\n\nThis can be used to listen for alkali update events. There are several differen types of events. The event type is indicated by the `type` property:\n* `"replaced"` - This indicates that the value of the variable was completely replaced with a new value. Tt should be considered an entirely new value. No incremental description is provided\n* `"property"` - This indicates that a property of the variabl\'s object was changed, and the property change is described in the `propertyEvent` event. A `key` property will indicate which property was changed.\n* `"added"` - This indicates a value was added to the variable\'s set, map, or collection. The value will be in the `value` property. Unless it was a set, a `key` property will also be included.\n* `"removed"` - This indicates a value was removed from the variable\'s set, map, or collection. The value will be in the `value` property. Unless it was a set, a `key` property will also be included.\n* `"entry"` - This indicates that an entry in the map, set, or collection was updated. The update event for that value/object will be in the `entryEvent` property.\n* `"spliced"` - This indicates that an array was modified. The event can include a `start`, `deleteCount`, and `items` properties to indicate the array items that were deleted and/or added.\n\n### `apply(instance, functionVariable)`\n\nThis allows you to execute a function that is the value of a variable, with arguments that come from other variables, (and an instance variable) returning a new variable representing the return value of that function call. The returned variable\'s valueOf will return the return value of the function\'s execution. If the this variable, or the instance variable, or any of the argument variables are updated, than the returned variable will update. The function can be re-executed with the changed values on the next call to valueOf.\n\n### `is(sourceVariable)`\n\nThis will cause the variable to act as a direct proxy for the source variable, and changes to this variable will be directed to the source variable, and vice versa.\n\n### `whileResolving(valueUntilResolved?, useLastValue: boolean?)`\nReturns a new variable that is sourced from `this` variable and when the source\nreturns asynchronously (an upstream promise), this will immediately return\nthe `valueUntilResolved` until the `this` variable is resolved (and which point\nit will update and return that source value). If `useLastValue` is true, once the\nvariable has been resolved, the last resolved value will be used until the\nnext resolution. If no arguments are provided, will default to using the\nlast resolved value (with `undefined` returned until the first resolution).\n\n### `Variable.proxy(source)`\n\nThis will utilize ES2015 Proxy\'s to create a proxy object that will intercept all property access and modification, make them act like `property` and `set` methods.\n\n## `Transform(source)`\nThe `Transform` class is available for defining transforms with a class structure. For simple transforms, the `to` method will usually suffice, but if you would like to use a class structure with methods that can be used by/for the transform, this extension of a `Variable` class can be useful. The `Transform` constructor takes a `source` argument (available as a property0, and can define a `transform(source)` method. Instances are standard variables, and can be used as such. Additional sources can be defined with properties `source1`, `source2`, etc. and will be passed in as additional arguments to the `transform` method.\n\n## Variables with Maps\nJavaScript `Map` objects can be used as the value for a variable, with the `Map` properties mapped to the variable properties. This can be done using the `VMap` constructor. The `Map` can be provided as a standard value as the argument or through `put`:\n```javascript\nnew VMap(new Map())\n```\n\n### `spawn()`\n\nAlkali also exports a `spawn` function, which waits for promises like `react`, but rather than returning a variable that will execute the provided transform generator/function on-demand, will immediately execute the generator, returning a promise (if there are promises yielded in the generator). This is effectively the same as task.js\'s `spawn` function. The \'spawn\' can accept an iterator returned from a generator as well.\n\n## Operator Functions\n\nAlkali includes several operator functions for combining variables with operators, corresponding to JavaScript operators. These functions take variables or static values as arguments, and return a variable that is result of this operation. These operator functions are also reversible, the returned variable can be modified, triggering a change in input variable. These operators include:\n\n* `add(a, b)` - The `add` function returns a variable that is the sum of two input variables or values, corresponding to a + b.\n* `subtract(a, b)` - Returns a variable corresponding to a - b\n* `multiply(a, b)` - Returns a variable corresponding to a * b\n* `divide(a, b)` - Returns a variable corresponding to a / b\n* `not(a)` - Returns a variable corresponding to !a\n* `remainder(a, b)` - Returns a variable corresponding to a % b\n* `greater(a, b)` - Returns a variable with a boolean corresponding to a > b\n* `greaterOrEqual(a, b)` - Returns a variable with a boolean corresponding to a > b\n* `less(a, b)` - Returns a variable with a boolean corresponding to a > b\n* `lessOrEqual(a, b)` - Returns a variable with a boolean corresponding to a > b\n* `strictEqual(a, b)` - Returns a variable corresponding to a === b\n* `equal(a, b)` - Returns a variable corresponding to a == b\n* `and(a, b)` - Returns a variable corresponding to a && b\n* `or(a, b)` - Returns a variable corresponding to a || b\n* `round(a, decimals)` - Returns a variable corresponding to rounded a, optionally to provided decimal points\n\n## Other Alkali Functions and Properties\n\n### `delayUpdate(variable, until)`\nThis can be used to delay the update or rendering from a variable that has been updated. For example:\n```javascript\nlet v = reactive(3)\nlet v2 = v.to(reallyExpensive)\nnew Div(v2)\ndelayUpdate(v, new Promise((resolve) => setTimeout(resolve, 1000)))\nv.put(5)\n```\n\n## Which Listener To Use?\n\nThere are several ways to listen for variable updates with Alkali, and which are designed and optimized for different situations. Here are a list of the main ways to listen for changes, and which is preferred (starting with the most preferred):\n* `to`, (and `map` and `filter`) - These are passive listeners or transforms, that are only called lazily when needed. These are used to transform the value or values of one variable into an other variable. When a variable changes, these transform functions are only called when a downstream subscriber actually needs the value to be computed. As a passive, or lazy callback function, the function will not be executed by merely calling `to(callback)`, but as needed. Ideally with Alkali, an application should consist of variables, which then are transformed to other downstream variables, which are eventually used directly by elements without any other imperative listeners (the elements handle listening themselves). This is the preferred mechanism for defining functions that response to variables, but, of course there are always other needs, so we have other mechanisms.\n* `Renderer` - The Renderers are designed as a reactive listening endpoint to a variable, and is optimized for rendering variable changes into DOM elements. An Renderer will respond to changes in variables, but will debounce updates, waiting for the next rendering frame, to ensure that unnecessary variable access (through the lazy transform functions) is avoided. Renderers will also avoid accessing variables to update elements, when an element is detached from the DOM.\n* `subscribe(callback)` - This is an active listener to updates from variables. This will be called for each update made to a variable (or any upstream variable). This is not lazy, and does not need to wait for a downstream listener to request a value, it will be called immediately after any update. However, while the callback function will be called immediately, this does not necessarily immediately trigger upstream transform functions, until you call `event.value()`. Once you call `event.value()`, you will trigger the upstream transform functions. If you call this to retrieve the value, for every update event, without any debouncing, you can potentially incur a lot of thrashing if you have multiple updates taking place in immediate sequence. However, if you have a function that you really want to be directly notified of variable changes, this is the most direct and reliable way to be notified.\n\nOne other difference is that if a variable is given a value that is a promise, both `to` and `Renderer` will resolve any promise first, and then call the callback functions with the resolved value. `subscribe`, on the otherhand, calls the listener immediately in response to update events, so the value returned from `event.value()` may be a yet-to-be-resolved promise.\n\n# Debugging\n\nDebugging reactive code may seem unfamilar at first, but there are actually substantial benefits, since data flows can be visually inspected rather than requiring the complex reasoning involved in stepping through imperative state changes. Alkali element constructors and variables are designed to easily be traced with standard web development tools. If you are using Alkali element constructors, the easiest way to start inspecting code flow is by select an element that was constructed with variables. With Chrome\'s developer tools, we select an element (which can be done by right clicking on the page and choosing "inspect"), and then choose the "Properties" tab on the element information pane. Then expand the first item in the list. If the element is driven by variables, you should now see an `alkaliRenderers` property, that you can expand. This will show you a renderer for each variable that controls the element (different renderers are used for text, properties, styles, etc.). Each renderer has a `variable` property that can be expanded to show you the variable itself. This represents the bottom of the dependency chain, and we can continue to walk up the chain to see how the data is derived.\n\nYou can check the current value of variable by clicking on the `currentValue` getter (it will show `(...)` until you click on it, at which point it will be evaluated). You can also reassign this value, and elements should reactively respond. This can be a great way to test if elements are responding to different variable values as expected. If the variable is a transform, we can then expand the input arguments in the `input`, `input1` properties, for inspection into the input variables. We can also inspect the `transform` to see what function is handling transforms (and you can right click on the function, and choose "Show function definition" to go to your source code, and potentially set breakpoints in the transform function). If a transform returns another variable (or a variable contains another variable), this will be available in the `returnedVariable` property.\n\nYou can also walk back down the dependency chain to see what other renderers or variables may be driven by this variable by expanding the `listeners` property.\n\nThere can be situations where you may wish to understand what is causing variables to change their state. Often there may be some code that is reassigning variable values, and determine what caused the change can be helpful. Alkali provides a `_debug` getter to easily turn on debugging of a variable. Clicking on the getter will turn on the debugging. At this point, any changes to the variable will be logged to console, along with a stack trace of the call that triggered the variable change, so you can actually see exactly what code made variable changes.\n\nUsing the babel-plugin-transform-alkali can also provide additional information in the form of a `name` property on variables, based on the code context.\n\n# Design Philosophy\n\nAlkali has several key architectural advantages:\n* Getting values from a variable always (new or original) always goes through the same code path.\n* Caching avoids unnecessary computations\n* Getting values and performing computations based on changes is not performed until needed (lazy, on-demand).\n* Deduplication of messages is handled by the top level of dependency layer, the UI layer. When elements are invalidated, multiple invalidation don\'t need to trigger recomputations. The alkali UI handler can schedule rendering invalidated portions once a rendering phase each reached (the same way repainting works in the browser).\nHidden components can use invalidation information to determine if they need to re-render anything next time they are shown, without having to immediately recompute or re-render anything.\nCaching can be performed safely because dependencies and the cache can be invalidated once any dependencies invalidate.\nThese advantages are explained in more depth here:\nhttp://kriszyp.name/2015/01/13/reactivity-and-caching/\n\nThe two phase rendering approach of alkali is described here:\nhttp://kriszyp.name/2015/11/25/rendering-efficiently-with-two-phase-ui-updates/\n\n# Element Constructors\n\nThe `alkali` module exports the following element constructors:\n\n## Standard Elements\n\nVideo\nSource\nMedia\nAudio\nUL\nTrack\nTitle\nTextArea\nTemplate\nTBody\nTHead\nTFoot\nTR\nTable\nCol\nColGroup\nTH\nTD\nCaption\nStyle\nSpan\nShadow\nSelect\nScript\nQuote\nProgress\nPre\nPicture\nParam\nP\nOutput\nOption\nOptgroup\nObject\nOL\nIns\nDel\nMeter\nMeta\nMenu\nMap\nLink\nLegend\nLabel\nLI\nKeyGen\nImg\nIFrame\nH1\nH2\nH3\nH4\nH5\nH6\nHr\nFrameSet\nFrame\nForm\nFont\nEmbed\nArticle\nAside\nFigure\nFigCaption\nHeader\nMain\nMark\nMenuItem\nNav\nSection\nSummary\nWBr\nDiv\nDialog\nDetails\nDataList\nDL\nCanvas\nButton\nBase\nBr\nArea\nA\n\nAnchor (same as A)\nImage (same as Img)\nParagraph (same as P)\nTextarea (same as TextArea)\nDList (same as DL)\nUList (same as UL)\nOList (same as OL)\nListItem (same as LI)\nInput (same as TextInput)\nTableRow (same as TR)\nTableCell (same as TD)\nTableHeaderCell (same as TH)\nTableHeader (same as THead)\nTableBody (same as TBody)\n\n\n## Inputs\nCheckbox (also CheckboxInput)\nPassword (also PasswordInput)\nText (also TextInput)\nSubmit (also SubmitInput)\nRadio (also RadioInput)\nColor (also ColorInput)\nDate (also DateInput)\nDateTime (also DateTimeInput)\nEmail (also EmailInput)\nMonth (also MonthInput)\nNumber (also NumberInput)\nRange (also RangeInput)\nSearch (also SearchInput)\nTel (also TelInput)\nTime (also TimeInput)\nUrl (also UrlInput)\nWeek (also WeekInput)\n\n# Contributing\n\n## Testing\n\nTests are written with Mocha.\n\nTo run unit tests: `npm run test`\nTo run functional tests: serve the project directory (e.g. python -m SimpleHTTPServer) and open `http://localhost:8000/tests/test.html`\n\n## Build\n\nFor developing and building Alkali, run `webpack` to build the Alkali bundle. We currently check this in for ease in using the bundled files for github pages.\n\n# Browser Support\n\nBasic variables will work on virtually any browser, but the Alkali elements require at least IE11+ or any other modern browser.\n\n# License\nAlkali is freely available under *either* the terms of the modified BSD license *or* the\nAcademic Free License version 2.1. More details can be found in the [LICENSE](LICENSE).\nThe alkali project follows the IP guidelines of Dojo foundation packages and all contributions require a Dojo CLA.\n'