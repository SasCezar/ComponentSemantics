b'# Haunted \xf0\x9f\xa6\x87 \xf0\x9f\x8e\x83\n\n[![npm](https://img.shields.io/npm/dt/haunted)](https://npm.im/haunted)\n[![npm](https://img.shields.io/npm/v/haunted)](https://npm.im/haunted)\n\nReact\'s Hooks API but for standard web components and [lit-html](https://lit-html.polymer-project.org/) or [hyperHTML](https://codepen.io/WebReflection/pen/pxXrdy?editors=0010).\n\n```html\n<!doctype html>\n<html lang="en">\n\n<my-counter></my-counter>\n\n<script type="module">\n  import { html } from \'https://unpkg.com/lit-html/lit-html.js\';\n  import { component, useState } from \'https://unpkg.com/haunted/haunted.js\';\n\n  function Counter() {\n    const [count, setCount] = useState(0);\n\n    return html`\n      <div id="count">${count}</div>\n      <button type="button" @click=${() => setCount(count + 1)}>Increment</button>\n    `;\n  }\n\n  customElements.define(\'my-counter\', component(Counter));\n</script>\n```\n\n## Getting started\n\nA starter app is available on [codesandbox](https://codesandbox.io/s/github/matthewp/haunted-starter-app/tree/master/) and also can be cloned from [this repo](https://github.com/matthewp/haunted-starter-app). This app gives you the basics of how to use Haunted and build components.\n\n## Use\n\n```shell\nnpm install haunted\n```\n\nFor Internet Explorer 11, you\'ll need to use a proxy polyfill, in addition to the usual webcomponentsjs polyfills. \n\neg.\n```html\n<script src="https://cdn.jsdelivr.net/npm/proxy-polyfill@0.3.0/proxy.min.js"></script> \n```\n\nFor a full example with Internet Explorer 11, see - https://github.com/crisward/haunted-ie11\n\nYou can also use Custom Elements without Shadow DOM if you wish.\neg.\n\n```js\ncomponent(() => html`...`, { useShadowDOM: false }));\n```\n\n### Importing\n\n__Haunted__ can be imported just like any other library when using a bundler of your choice:\n\n```js\nimport { component, html, useState } from \'haunted\';\n```\n\nThe main entry point is intended for [lit-html](https://github.com/Polymer/lit-html) users.\n\n#### lighterhtml, etc\n\nIf you are using [lighterhtml](https://github.com/WebReflection/lighterhtml) or [hyperHTML](https://github.com/WebReflection/hyperHTML) then instead import `haunted/core`. This export gives you a function that creates Hooks that work with any template library.\n\n```js\nimport haunted, { useState } from \'haunted/core\';\nimport { html, render } from \'lighterhtml\';\n\nconst { component } = haunted({\n  render(what, where) {\n    render(where, () => what);\n  }\n});\n\nconst App = component(() => {\n  const [count, setCount] = useState(0);\n  return html`Using lighterhtml! Count: ${count}`;\n});\n```\n\n#### Web modules\n\n__Haunted__ can work directly in the browser without using any build tools. Simply import the `haunted.js` bundle. You can use the [unpkg] or [pika](https://www.pika.dev/cdn) CDNs. This works great for demo pages and small apps. Here\'s an example with unpkg:\n\n```js\nimport { html } from \'https://unpkg.com/lit-html/lit-html.js\';\nimport { component, useState, useEffect } from \'https://unpkg.com/haunted/haunted.js\';\n```\n\nIf using pika then use the `html` export from Haunted, as pika bundles everything together:\n\n```js\nimport { useState, component, html } from \'https://cdn.pika.dev/haunted\';\n```\n\nIf you install Haunted __locally__ this build is located at `node_modules/haunted/haunted.js`.\n\n## API\n\nHaunted is all about writing plain functions that can contain their own state. The follow docs is divided between creating *components* (the functions) and using *hooks* the state.\n\n### Components\n\nComponents are functions that contain state and return HTML via lit-html or hyperHTML. Through the `component()` and `virtual()` they become connected to a lifecycle that keeps the HTML up-to-date when state changes.\n\nUsing Haunted you can create custom elements or *virtual* components (components that contain state but have no element tag).\n\n#### Custom elements\n\nThe easiest way to create components is by importing `component` and creating a custom element like so:\n\n```js\nimport { component } from \'haunted\';\nimport { html } from \'lit-html\';\n\nconst App = ({ name }) => {\n  return html`Hello ${name}!`;\n};\n\ncustomElements.define(\'my-app\', component(App));\n```\n\nYou can now use this anywhere you use HTML (directly in a `.html` file, in JSX, in lit-html templates, whereever).\n\nHere\'s an example of rendering with lit-html the above app:\n\n```js\nimport { render, html } from \'lit-html\';\n\nrender(html`\n  <my-app name="world"></my-app>\n`, document.body);\n```\n\n##### Attributes\n\nIn custom elements, attributes must be pre-defined. Properties, on the other hand, do not. To define what attributes your component supports, set the `observedAttributes` property on the functional component. For example:\n\n```js\nconst App = ({name}) => {\n  return `Hello ${name}!`;\n};\n\nApp.observedAttributes = [\'name\'];\n\ncustomElements.define(\'hello-app\', component(App));\n```\n\nAlternatively, you can pass `observedAttributes` as an option to `component()`:\n\n```js\ncustomElements.define(\'hello-app\', component(App, {observedAttributes: [\'name\']}));\n```\n\nWhich allows you to author (in HTML):\n\n```html\n<hello-app name="world"></hello-app>\n```\n\n#### Virtual components\n\nHaunted also has the concept of *virtual components*. These are components that are not defined as a tag. Rather they are functions that can be called from within another template. They have their own state and will rerender when that state changes, *without* causing any parent components to rerender.\n\nThe following is an example of using virtual components:\n\n```js\nimport { useState, virtual, component } from \'haunted\';\nimport { html, render } from \'lit-html\';\n\nconst Counter = virtual(() => {\n  const [count, setCount] = useState(0);\n\n  return html`\n    <button type="button"\n      @click=${() => setCount(count + 1)}>${count}</button>\n  `;\n});\n\nconst App = component(() => {\n  return html`\n    <main>\n      <h1>My app</h1>\n\n      ${Counter()}\n    </main>\n  `;\n});\n\ncustomElements.define(\'my-app\', App);\n```\n\nNotice that we have `Counter`, a virtual component, and `App`, a custom element. You can use virtual components within custom elements and custom elements within virtual components.\n\nThe only difference is that custom elements are used by using their `<my-app>` tag name and virtual components are called as functions.\n\nIf you wanted you could create an entire app of virtual components.\n\n### Hooks\n\nHaunted supports the same API as React Hooks. The hope is that by doing so you can reuse hooks available on npm simply by aliasing package names in your bundler\'s config.\n\nCurrently Haunted supports the following hooks:\n\n#### useState\n\nCreate a tuple of state and a function to change that state.\n\n```js\nconst [count, setCount] = useState(0);\n```\n\nAdditionally you can provide a function as the argument to useState, in which case the function is called to initialize the first state, but never called again.\n\n```js\nconst [count, setCount] = useState(() => {\n  return expensiveFunction();\n});\n```\n\n#### useEffect\n\nUseful for side-effects that run after the render has been commited.\n\n```html\n<!doctype html>\n\n<my-counter></my-counter>\n\n<script type="module">\n  import { html } from \'https://unpkg.com/lit-html/lit-html.js\';\n  import { component, useState, useEffect } from \'https://unpkg.com/haunted/haunted.js\';\n\n  function Counter() {\n    const [count, setCount] = useState(0);\n\n    useEffect(() => {\n      document.title = `Clicked ${count} times`;\n    });\n\n    return html`\n      <div id="count">${count}</div>\n      <button type="button" @click=${() => setCount(count + 1)}>Increment</button>\n    `;\n  }\n\n  customElements.define(\'my-counter\', component(Counter));\n</script>\n```\n\n##### Memoization\n\nLike `useMemo`, `useEffect` can take a second argument that are values that are memoized. The effect will only run when these values change.\n\n```js\nfunction App() {\n  let [name, setName] = useState(\'Dracula\');\n\n  useEffect(() => {\n    // This only occurs when name changes.\n    document.title = `Hello ${name}`;\n  }, [name]);\n\n  return html`...`;\n}\n```\n\n##### Cleaning up side-effects\n\nSince effects are used for side-effectual things and might run many times in the lifecycle of a component, `useEffect` supports returning a teardown function.\n\nAn example of when you might use this is if you are setting up an event listener.\n\n```js\nfunction App() {\n  let [name, setName] = useState(\'Wolf Man\');\n\n  useEffect(() => {\n    function updateNameFromWorker(ev) {\n      setName(ev.data);\n    }\n\n    worker.addEventListener(\'message\', updateNameFromWorker);\n\n    return () => {\n      worker.removeEventListener(\'message\', updateNameFromWorker);\n    }\n  });\n\n  return html`...`;\n}\n```\n\n#### useLayoutEffect\n\nThe function signature is the same as `useEffect`, but the callback is being called synchronously after rendering. Updates scheduled inside `useLayoutEffect` will therefore be flushed synchronously, before the browser has a chance to paint.\n\nMost of time, it is preferable to use `useEffect` to avoid blocking visual updates.\n\n#### useReducer\n\nCreate state that updates after being ran through a reducer function.\n\n```html\n<!doctype html>\n\n<my-counter></my-counter>\n\n\n<script type="module">\n  import { html } from \'https://unpkg.com/lit-html/lit-html.js\';\n  import { component, useReducer } from \'https://unpkg.com/haunted/haunted.js\';\n\n  const initialState = {count: 0};\n\n  function reducer(state, action) {\n    switch (action.type) {\n      case \'reset\': return initialState;\n      case \'increment\': return {count: state.count + 1};\n      case \'decrement\': return {count: state.count - 1};\n    }\n  }\n\n  function Counter() {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    return html`\n      Count: ${state.count}\n      <button @click=${() => dispatch({type: \'reset\'})}>\n        Reset\n      </button>\n      <button @click=${() => dispatch({type: \'increment\'})}>+</button>\n      <button @click=${() => dispatch({type: \'decrement\'})}>-</button>\n    `;\n  }\n\n  customElements.define(\'my-counter\', component(Counter));\n</script>\n```\n\n#### useMemo\n\nCreate a memoized state value. Only reruns the function when dependent values have changed.\n\n```html\n<!doctype html>\n\n<my-app></my-app>\n\n<script type="module">\n  import { html } from \'https://unpkg.com/lit-html/lit-html.js\';\n  import { component, useMemo, useState } from \'https://unpkg.com/haunted/haunted.js\';\n\n  function fibonacci(num) {\n    if (num <= 1) return 1;\n\n    return fibonacci(num - 1) + fibonacci(num - 2);\n  }\n\n  function App() {\n    const [value, setVal] = useState(12);\n    const fib = useMemo(() => fibonacci(value), [value]);\n\n    return html`\n      <h1>Fibonacci</h1>\n      <input type="text" @change=${ev => setVal(Number(ev.target.value))} value="${value}">\n      <div>Fibonacci <strong>${fib}</strong></div>\n    `;\n  }\n\n  customElements.define(\'my-app\', component(App));\n</script>\n```\n\n#### useRef\n\nCreate and returns an object with one property "current" which can be assigned any value and is unaffected by multiple renders.\n\n```html\n<!doctype html>\n\n<my-app></my-app>\n\n<script type="module">\n  import { html } from \'https://unpkg.com/lit-html/lit-html.js\';\n  import { component, useRef } from \'https://unpkg.com/haunted/haunted.js\';\n\n  function App() {\n    const myRef = useRef(0);\n\n    return html`\n      ${myRef.current}\n    `;\n  }\n\n  customElements.define(\'my-app\', component(App));\n</script>\n```\n\n#### useContext\n\nGrabs context value from the closest provider up in the tree and updates component when value of a provider changes.\nLimited only to "real" components for now.\n\n```html\n<!doctype html>\n\n<my-app></my-app>\n\n<script type="module">\n  import { html } from \'https://unpkg.com/lit-html/lit-html.js\';\n  import { component, createContext, useContext } from \'https://unpkg.com/haunted/haunted.js\';\n\n  const ThemeContext = createContext(\'dark\');\n\n  customElements.define(\'theme-provider\', ThemeContext.Provider);\n  customElements.define(\'theme-consumer\', ThemeContext.Consumer);\n\n  function Consumer() {\n    const context = useContext(ThemeContext);\n\n    return context;\n  }\n\n  customElements.define(\'my-consumer\', component(Consumer));\n\n  function App() {\n    const [theme, setTheme] = useState(\'light\');\n    \n    return html`\n      <select value=${theme} @change=${(e) => setTheme(e.target.value)}>\n        <option value="dark">Dark</option>\n        <option value="light">Light</option>\n      </select>\n      \n      <theme-provider .value=${theme}>\n        \n        <my-consumer></my-consumer>\n\n        <!-- creates context with inverted theme -->\n        <theme-provider .value=${theme === \'dark\' ? \'light\' : \'dark\'}> \n          \n          <theme-consumer\n            .render=${value => html`<h1>${value}</h1>`}\n          ></theme-consumer>\n        \n        </theme-provider>\n      \n      </theme-provider>\n    `;\n  }\n\n  customElements.define(\'my-app\', component(App));\n</script>\n```\n\n#### Write Your Own Hook\n\nMost functionality can be achieved with the provided hooks above, but you can also create your own hooks for custom functionality like so:\n\n```js\nimport { hook, Hook } from \'haunted\';\n\nconst useMyHook = hook(class extends Hook {\n  constructor(id, state) {\n    super(id, state);\n    ...\n  }\n\n  update() { ... }\n\n  teardown() { ... }\n\n});\n```\n\n### State\n\nAt its heart, Haunted is a container for state derived from hooks. The `component` and `virtual` signatures build on top of this state container.\n\nIn order to use Haunted outside of its component types, such as to extend another custom element base class, you can use the `State` constructor.\n\nIt has a signature of: `new State(update, [ hostElement ])`.\n\n> Note that the second argument `hostElement` is optional. If you want to use the `useContext` hook you will need to provide a host element, however.\n\nHere\'s an example how it can be used to run hooks code:\n\n```js\nimport { State, useState } from \'haunted\';\n\nlet state = new State(() => {\n  update();\n});\n\nfunction update() {\n  state.run(() => {\n    const [count, setCount] = useState(0);\n\n    console.log(\'count is\', count);\n\n    setTimeout(() => setCount(count + 1), 3000);\n  });\n}\n\nupdate();\n```\n\nThe above will result in the count being incremented every 3 seconds and the current count being logged.\n\nA more practical example is integration with a custom element base class. Here\'s a simple integration with [LitElement](https://lit-element.polymer-project.org/):\n\n```js\nimport { LitElement } from \'lit-element\';\nimport { State } from \'haunted\';\n\nexport default class LitHauntedElement extends LitElement {\n  constructor() {\n    super();\n\n    this.hauntedState = new State(() => this.requestUpdate(), this);\n  }\n\n  update(changedProperties) {\n    this.hauntedState.run(() => super.update(changedProperties));\n    this.hauntedState.runEffects();\n  }\n}\n```\n\nMore example integrations can be found in [this gist](https://gist.github.com/matthewp/92c4daa6588eaef484c6f389d20d5700).\n\n### Function Signatures\n\n`component(renderer, options): Element`\n`component(renderer, BaseElement, options): Element`\n- renderer = ``` (element) => html`...` ```  \n- BaseElement = `HTMLElement`\n- options = `{baseElement: HTMLElement, observedAttributes: [], useShadowDOM: true}`\n\n`virtual(renderer): directive`\n- renderer = ``` (element) => html`...` ```  \n\n## License\n\nBSD-2-Clause\n'