b'# segyio #\n\n[![Travis](https://img.shields.io/travis/equinor/segyio/master.svg?label=travis)](https://travis-ci.org/equinor/segyio)\n[![Appveyor](https://ci.appveyor.com/api/projects/status/2i5cr8ui2t9qbxk9?svg=true)](https://ci.appveyor.com/project/statoil-travis/segyio)\n[![PyPI Updates](https://pyup.io/repos/github/equinor/segyio/shield.svg)](https://pyup.io/repos/github/equinor/segyio/)\n[![Python 3](https://pyup.io/repos/github/equinor/segyio/python-3-shield.svg)](https://pyup.io/repos/github/equinor/segyio/)\n\n## Documentation ##\n\nThe official documentation is hosted on [readthedocs](https://segyio.readthedocs.io/).\n\n## Index ##\n\n* [Introduction](#introduction)\n* [Feature summary](#feature-summary)\n* [Getting started](#getting-started)\n    * [Quick start](#quick-start)\n    * [Get segyio](#get-segyio)\n    * [Build segyio](#build-segyio)\n* [Tutorial](#tutorial)\n    * [Basics](#basics)\n    * [Modes](#modes)\n    * [Mode examples](#mode-examples)\n* [Goals](#project-goals)\n* [Contributing](#contributing)\n* [Examples](#examples)\n* [Common issues](#common-issues)\n* [History](#history)\n\n## Introduction ##\n\nSegyio is a small LGPL licensed C library for easy interaction with SEG-Y and\nSeismic Unix formatted seismic data, with language bindings for Python and\nMatlab. Segyio is an attempt to create an easy-to-use, embeddable,\ncommunity-oriented library for seismic applications. Features are added as they\nare needed; suggestions and contributions of all kinds are very welcome.\n\nTo catch up on the latest development and features, see the\n[changelog](changelog.md). To write future proof code, consult the planned\n[breaking changes](breaking-changes.md).\n\n## Feature summary ##\n\n  * A low-level C interface with few assumptions; easy to bind to other\n    languages\n  * Read and write binary and textual headers\n  * Read and write traces and trace headers\n  * Simple, powerful, and native-feeling Python interface with numpy\n    integration\n  * Read and write seismic unix files\n  * xarray integration with netcdf_segy\n  * Some simple applications with unix philosophy\n\n## Getting started ##\n\nWhen segyio is built and installed, you\'re ready to start programming! Check\nout the [tutorial](#tutorial), [examples](#examples), [example\nprograms](python/examples), and [example\nnotebooks](https://github.com/equinor/segyio-notebooks). For a technical\nreference with examples and small recipes, [read the\ndocs](https://segyio.readthedocs.io/). API docs are also available with pydoc -\nstart your favourite Python interpreter and type `help(segyio)`, which should\nintegrate well with IDLE, pycharm and other Python tools.\n\n### Quick start ###\n```python\nimport segyio\nimport numpy as np\nwith segyio.open(\'file.sgy\') as f:\n    for trace in f.trace:\n        filtered = trace[np.where(trace < 1e-2)]\n```\n\nSee the [examples](#examples) for more.\n\n### Get segyio ###\n\nA copy of segyio is available both as pre-built binaries and source code:\n\n* In Debian [unstable](https://packages.debian.org/source/sid/segyio)\n    * `apt install python3-segyio`\n* Wheels for Python from [PyPI](https://pypi.python.org/pypi/segyio/)\n    * `pip install segyio`\n* Source code from [github](https://github.com/equinor/segyio)\n    * `git clone https://github.com/statoil/segyio`\n* Source code in [tarballs](https://github.com/equinor/segyio/releases)\n\n### Build segyio ###\n\nTo build segyio you need:\n * A C99 compatible C compiler (tested mostly on gcc and clang)\n * A C++ compiler for the Python extension, and C++11 for the tests\n * [CMake](https://cmake.org/) version 2.8.12 or greater\n * [Python](https://www.python.org/) 2.7 or 3.x.\n * [numpy](http://www.numpy.org/) version 1.10 or greater\n * [setuptools](https://pypi.python.org/pypi/setuptools) version 28 or greater\n * [setuptools-scm](https://pypi.python.org/pypi/setuptools_scm)\n * [pytest](https://pypi.org/project/pytest)\n\n To build the documentation, you also need\n [sphinx](https://pypi.org/project/Sphinx)\n\nTo build and install segyio, perform the following actions in your console:\n\n```bash\ngit clone https://github.com/equinor/segyio\nmkdir segyio/build\ncd segyio/build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON\nmake\nmake install\n```\n\n`make install` must be done as root for a system install; if you want to\ninstall in your home directory, add `-DCMAKE_INSTALL_PREFIX=~/` or some other\nappropriate directory, or `make DESTDIR=~/ install`. Please ensure your\nenvironment picks up on non-standard install locations (PYTHONPATH,\nLD_LIBRARY_PATH and PATH).\n\nIf you have multiple Python installations, or want to use some alternative\ninterpreter, you can help cmake find the right one by passing\n`-DPYTHON_EXECUTABLE=/opt/python/binary` along with install prefix and build\ntype.\n\nTo build the matlab bindings, invoke CMake with the option `-DBUILD_MEX=ON`. In\nsome environments the Matlab binaries are in a non-standard location, in which\ncase you need to help CMake find the matlab binaries by passing\n`-DMATLAB_ROOT=/path/to/matlab`.\n\n#### Developers ####\n\nIt\'s recommended to build in debug mode to get more warnings and to embed debug\nsymbols in the objects. Substituting `Debug` for `Release` in the\n`CMAKE_BUILD_TYPE` is plenty.\n\nTests are located in the language/tests directories, and it\'s highly\nrecommended that new features added are demonstrated for correctness and\ncontract by adding a test. All tests can be run by invoking `ctest`. Feel free\nto use the tests already written as a guide.\n\nAfter building segyio you can run the tests with `ctest`, executed from the\nbuild directory.\n\nPlease note that to run the Python examples you need to let your environment\nknow where to find the Python library. It can be installed as a user, or on\nadding the segyio/build/python library to your pythonpath.\n\n## Tutorial ##\n\nAll code in this tutorial assumes segyio is imported, and that numpy is\navailable as np.\n\n```python\nimport segyio\nimport numpy as np\n```\n\nThis tutorial assumes you\'re familiar with Python and numpy. For a refresh,\ncheck out the [python tutorial](https://docs.python.org/3/tutorial/) and [numpy\nquickstart](https://docs.scipy.org/doc/numpy-dev/user/quickstart.html)\n\n### Basics ###\n\nOpening a file for reading is done with the `segyio.open` function, and\nidiomatically used with context managers. Using the `with` statement, files are\nproperly closed even in the case of exceptions. By default, files are opened\nread-only.\n\n```python\nwith segyio.open(filename) as f:\n    ...\n```\n\nOpen accepts several options (for more a more comprehensive reference, check\nthe open function\'s docstring with `help(segyio.open)`. The most important\noption is the second (optional) positional argument. To open a file for\nwriting, do `segyio.open(filename, \'r+\')`, from the C `fopen` function.\n\nFiles can be opened in *unstructured* mode, either by passing `segyio.open` the\noptional arguments `strict=False`, in which case not establishing structure\n(inline numbers, crossline numbers etc.) is not an error, and\n`ignore_geometry=True`, in which case segyio won\'t even try to set these\ninternal attributes.\n\nThe segy file object has several public attributes describing this structure:\n* `f.ilines`\n    Inferred inline numbers\n* `f.xlines`\n    Inferred crossline numbers\n* `f.offsets`\n    Inferred offsets numbers\n* `f.samples`\n    Inferred sample offsets (frequency and recording time delay)\n* `f.unstructured`\n    True if unstructured, False if structured\n* `f.ext_headers`\n    The number of extended textual headers\n\nIf the file is opened *unstructured*, all the line properties will will be\n`None`.\n\n### Modes ###\n\nIn segyio, data is retrieved and written through so-called *modes*. Modes are\nabstract arrays, or addressing schemes, and change what names and indices mean.\nAll modes are properties on the file handle object, support the `len` function,\nand reads and writes are done through `f.mode[]`. Writes are done with\nassignment. Modes support array slicing inspired by numpy. The following modes\nare available:\n\n* `trace`\n\n    The trace mode offers raw addressing of traces as they are laid out in the\n    file. This, along with `header`, is the only mode available for\n    unstructured files. Traces are enumerated `0..len(f.trace)`.\n\n    Reading a trace yields a numpy `ndarray`, and reading multiple traces\n    yields a generator of `ndarray`s. Generator semantics are used and the same\n    object is reused, so if you want to cache or address trace data later, you\n    must explicitly copy.\n\n    ```python\n    >>> f.trace[10]\n    >>> f.trace[-2]\n    >>> f.trace[15:45]\n    >>> f.trace[:45:3]\n    ```\n\n* `header`\n\n    With addressing behaviour similar to `trace`, accessing items yield header\n    objects instead of numpy `ndarray`s. Headers are dict-like objects, where\n    keys are integers, seismic unix-style keys (in segyio.su module) and segyio\n    enums (segyio.TraceField).\n\n    Header values can be updated by assigning a dict-like to it, and keys not\n    present on the right-hand-side of the assignment are *unmodified*.\n\n    ```python\n    >>> f.header[5] = { segyio.su.tracl: 10 }\n    >>> f.header[5].items()\n    >>> f.header[5][25, 37] # read multiple values at once\n    ```\n\n* `iline`, `xline`\n\n    These modes will raise an error if the file is unstructured. They consider\n    arguments to `[]` as the *keys* of the respective lines. Line numbers are\n    always increasing, but can have arbitrary, uneven spacing. The valid names\n    can be found in the `ilines` and `xlines` properties.\n\n    As with traces, getting one line yields an `ndarray`, and a slice of lines\n    yields a generator of `ndarray`s. When using slices with a step, some\n    intermediate items might be skipped if it is not matched by the step, i.e.\n    doing `f.line[1:10:3]` on a file with lines `[1,2,3,4,5]` is equivalent of\n    looking up `1, 4, 7`, and finding `[1,4]`.\n\n    When working with a 4D pre-stack file, the first offset is implicitly read.\n    To access a different or a range of offsets, use comma separated indices or\n    ranges, as such: `f.iline[120, 4]`.\n\n* `fast`, `slow`\n\n    These are aliases for `iline` and `xline`, determined by how the traces are\n    laid out. For inline sorted files, `fast` would yield `iline`.\n\n* `depth_slice`\n\n    The depth slice is a horizontal, file-wide cut at a depth. The yielded\n    values are `ndarray`s and generators-of-arrays.\n\n* `gather`\n\n    The `gather` is the intersection of an inline and crossline, a vertical\n    column of the survey, and unless a single offset is specified returns an\n    offset x samples `ndarray`. In the presence of ranges, it returns a\n    generator of such `ndarray`s.\n\n* `text`\n\n    The `text` mode is an array of the textual headers, where `text[0]` is the\n    standard-mandated textual header, and `1..n` are the optional extended\n    headers.\n\n    The text headers are returned as 3200-byte string-like blobs (bytes in\n    Python 3, str in Python 2), as it is in the file. The `segyio.tools.wrap`\n    function can create a line-oriented version of this string.\n\n* `bin`\n\n    The values of the file-wide binary header with a dict-like interface.\n    Behaves like the `header` mode, but without the indexing.\n\n### Mode examples ###\n\n```python\n>>> for line in f.iline[:2430]:\n...     print(np.average(line))\n\n>>> for line in f.xline[2:10]:\n...     print(line)\n\n>>> for line in f.fast[::2]:\n...     print(np.min(line))\n\n>>> for factor, offset in enumerate(f.iline[10, :]):\n...     offset *= factor\n        print(offset)\n\n>>> f.gather[200, 241, :].shape\n\n>>> text = f.text[0]\n>>> type(text)\n<type \'bytes\'> # \'str\' in Python 2\n\n>>> f.trace[10] = np.zeros(len(f.samples))\n```\n\nMore examples and recipes can be found in the docstrings `help(segyio)` and the\n[examples](#examples) section.\n\n## Project goals ##\n\nSegyio does not necessarily attempt to be the end-all of SEG-Y interactions;\nrather, we aim to lower the barrier to interacting with SEG-Y files for\nembedding, new applications or free-standing programs.\n\nAdditionally, the aim is not to support the full standard or all exotic (but\nstandard compliant) formatted files out there. Some assumptions are made, such\nas:\n\n * All traces in a file are assumed to be of the same size\n\nCurrently, segyio supports:\n * Post-stack 3D volumes, sorted with respect to two header words (generally\n   INLINE and CROSSLINE)\n * Pre-stack 4D volumes, sorted with respect to three header words (generally\n   INLINE, CROSSLINE, and OFFSET)\n * Unstructured data, i.e. a collection of traces\n * Most numerical formats (including IEEE 4- and 8-byte float, IBM float, 2-\n   and 4-byte integers)\n\nThe writing functionality in segyio is largely meant to *modify* or adapt\nfiles. A file created from scratch is not necessarily a to-spec SEG-Y file, as\nwe only necessarily write the header fields segyio needs to make sense of the\ngeometry. It is still highly recommended that SEG-Y files are maintained and\nwritten according to specification, but segyio **does not** enforce this.\n\n\n### SEG-Y Revisions ###\n\nSegyio can handle a lot of files that are SEG-Y-like, i.e. segyio handles files\nthat don\'t strictly conform to the SEG-Y standard. Segyio also does not\ndiscriminate between the revisions, but instead tries to use information\navailable in the file. For an *actual* standard\'s reference, please see the\npublications by SEG:\n\n- [SEG-Y 0 (1975)](https://seg.org/Portals/0/SEG/News%20and%20Resources/Technical%20Standards/seg_y_rev0.pdf)\n- [SEG-Y 1 (2002)](https://seg.org/Portals/0/SEG/News%20and%20Resources/Technical%20Standards/seg_y_rev1.pdf)\n- [SEG-Y 2 (2017)](https://seg.org/Portals/0/SEG/News%20and%20Resources/Technical%20Standards/seg_y_rev2_0-mar2017.pdf)\n\n## Contributing ##\n\nWe welcome all kinds of contributions, including code, bug reports, issues,\nfeature requests, and documentation. The preferred way of submitting a\ncontribution is to either make an\n[issue](https://github.com/equinor/segyio/issues) on github or by forking the\nproject on github and making a pull request.\n\n## xarray integration ##\n\n[Alan Richardson](https://github.com/ar4) has written a great little tool for\nusing [xarray](http://xarray.pydata.org/en/stable/) with segy files, which he\ndemos in this\n[notebook](https://github.com/ar4/netcdf_segy/blob/master/notebooks/netcdf_segy.ipynb)\n\n## Reproducing the test data ##\n\nSmall SEG-Y formatted files are included in the repository for test purposes.\nThe data is non-sensical and made to be predictable, and it is reproducible by\nusing segyio. The tests file are located in the test-data directory. To\nreproduce the data file, build segyio and run the test program `make-file.py`,\n`make-ps-file.py`, and `make-rotated-copies.py` as such:\n\n```python\npython examples/make-file.py small.sgy 50 1 6 20 25\npython examples/make-ps-file.py small-ps.sgy 10 1 5 1 4 1 3\npython examples/make-rotated-copies.py small.sgy\n```\n\nThe small-lsb.sgy file was created by running the flip-endianness program. This\nprogram is included in the segyio source tree, but not a part of the package,\nand not intended for distribution and installation, only for reproducing test\nfiles.\n\nThe seismic unix file small.su and small-lsb.su were created by the following\ncommands:\n\n```bash\nsegyread tape=small.sgy ns=50 remap=tracr,cdp byte=189l,193l conv=1 format=1 \\\n         > small-lsb.su\nsuswapbytes < small.su > small-lsb.su\n```\n\nIf you have have small data files with a free license, feel free to submit it\nto the project!\n\n## Examples ##\n\n### Python ###\n\nImport useful libraries:\n\n```python\nimport segyio\nimport numpy as np\nfrom shutil import copyfile\n```\n\nOpen segy file and inspect it:\n\n```python\nfilename = \'name_of_your_file.sgy\'\nwith segyio.open(filename) as segyfile:\n\n    # Memory map file for faster reading (especially if file is big...)\n    segyfile.mmap()\n\n    # Print binary header info\n    print(segyfile.bin)\n    print(segyfile.bin[segyio.BinField.Traces])\n\n    # Read headerword inline for trace 10\n    print(segyfile.header[10][segyio.TraceField.INLINE_3D])\n\n    # Print inline and crossline axis\n    print(segyfile.xlines)\n    print(segyfile.ilines)\n```\n\nRead post-stack data cube contained in segy file:\n\n```python\n# Read data along first xline\ndata = segyfile.xline[segyfile.xlines[1]]\n\n# Read data along last iline\ndata = segyfile.iline[segyfile.ilines[-1]]\n\n# Read data along 100th time slice\ndata = segyfile.depth_slice[100]\n\n# Read data cube\ndata = segyio.tools.cube(filename)\n```\n\nRead pre-stack data cube contained in segy file:\n\n```python\nfilename = \'name_of_your_prestack_file.sgy\'\nwith segyio.open(filename) as segyfile:\n\n    # Print offsets\n    print(segyfile.offset)\n\n    # Read data along first iline and offset 100:  data [nxl x nt]\n    data = segyfile.iline[0, 100]\n\n    # Read data along first iline and all offsets gath:  data [noff x nxl x nt]\n    data = np.asarray([np.copy(x) for x in segyfile.iline[0:1, :]])\n\n    # Read data along first 5 ilines and all offsets gath:  data [noff nil x nxl x nt]\n    data = np.asarray([np.copy(x) for x in segyfile.iline[0:5, :]])\n\n    # Read data along first xline and all offsets gath:  data [noff x nil x nt]\n    data = np.asarray([np.copy(x) for x in segyfile.xline[0:1, :]])\n```\n\nRead and understand fairly \'unstructured\' data (e.g., data sorted in common shot gathers):\n\n```python\nfilename = \'name_of_your_prestack_file.sgy\'\nwith segyio.open(filename, ignore_geometry=True) as segyfile:\n    segyfile.mmap()\n\n    # Extract header word for all traces\n    sourceX = segyfile.attributes(segyio.TraceField.SourceX)[:]\n\n    # Scatter plot sources and receivers color-coded on their number\n    plt.figure()\n    sourceY = segyfile.attributes(segyio.TraceField.SourceY)[:]\n    nsum = segyfile.attributes(segyio.TraceField.NSummedTraces)[:]\n    plt.scatter(sourceX, sourceY, c=nsum, edgecolor=\'none\')\n\n    groupX = segyfile.attributes(segyio.TraceField.GroupX)[:]\n    groupY = segyfile.attributes(segyio.TraceField.GroupY)[:]\n    nstack = segyfile.attributes(segyio.TraceField.NStackedTraces)[:]\n    plt.scatter(groupX, groupY, c=nstack, edgecolor=\'none\')\n```\n\nWrite segy file using same header of another file but multiply data by *2\n\n```python\ninput_file = \'name_of_your_input_file.sgy\'\noutput_file = \'name_of_your_output_file.sgy\'\n\ncopyfile(input_file, output_file)\n\nwith segyio.open(output_file, "r+") as src:\n\n    # multiply data by 2\n    for i in src.ilines:\n        src.iline[i] = 2 * src.iline[i]\n```\n\n[Make segy file from sctrach](python/examples/make-file.py)\n\n### MATLAB ###\n\n```\nfilename=\'name_of_your_file.sgy\'\n\n% Inspect segy\nSegy_struct=SegySpec(filename,189,193,1);\n\n% Read headerword inline for each trace\nSegy.get_header(filename,\'Inline3D\')\n\n%Read data along first xline\ndata= Segy.readCrossLine(Segy_struct,Segy_struct.crossline_indexes(1));\n\n%Read cube\ndata=Segy.get_cube(Segy_struct);\n\n%Write segy, use same header but multiply data by *2\ninput_file=\'input_file.sgy\';\noutput_file=\'output_file.sgy\';\ncopyfile(input_file,output_file)\ndata = Segy.get_traces(input_file);\ndata1 = 2*data;\nSegy.put_traces(output_file, data1);\n```\n\n## Common issues ##\n\n### ImportError: libsegyio.so.1: cannot open shared object file\n\nThis error shows up when the loader cannot find the core segyio library. If\nyou\'ve explicitly set the install prefix (with `-DCMAKE_INSTALL_PREFIX`) you\nmust configure your loader to also look in this prefix, either with a\n`ld.conf.d` file or the `LD_LIBRARY_PATH` variable.\n\nIf you haven\'t set `CMAKE_INSTALL_PREFIX`, cmake will by default install to\n`/usr/local`, which your loader usually knows about. On Debian based systems,\nthe library often gets installed to `/usr/local/lib`, which the loader may not\nknow about. See [issue #239](https://github.com/equinor/segyio/issues/239).\n\n#### Possible solutions\n\n* Configure the loader (`sudo ldconfig` often does the trick)\n* Install with a different, known prefix, e.g. `-DCMAKE_INSTALL_LIBDIR=lib64`\n\n### RuntimeError: unable to find sorting\n\nThis exception is raised when segyio tries to open the in strict mode, under\nthe assumption that the file is a regular, sorted 3D volume. If the file is\njust a collection of traces in arbitrary order, this would fail.\n\n#### Possible solutions\n\nSegyio supports files that are just a collection of traces too, but has to be\ntold that it\'s ok to do so. Pass `strict = False` or `ignore_geometry = True`\nto `segyio.open` to allow or force unstructured mode respectively. Please note\nthat `f.iline` and similar features are now disabled and will raise errors.\n\n## History ##\nSegyio was initially written and is maintained by [Equinor\nASA](http://www.equinor.com/) as a free, simple, easy-to-use way of interacting\nwith seismic data that can be tailored to our needs, and as contribution to the\nfree software community.\n'