b'MEXPLUS\n=======\n[![Build Status](https://travis-ci.org/kyamagu/mexplus.svg?branch=master)](https://travis-ci.org/kyamagu/mexplus)\n[![License](https://img.shields.io/badge/License-BSD%203--Clause-blue.svg)](https://opensource.org/licenses/BSD-3-Clause)\n\nC++ Matlab MEX development kit.\n\nThe kit contains a couple of C++ classes and macros to make MEX development\neasy in Matlab. There are 3 major components in the development kit.\n\n * `mexplus/dispatch.h` Macros to dispatch function calls within a MEX binary.\n * `mexplus/arguments.h` MEX function argument wrappers.\n * `mexplus/mxarray.h` MxArray data conversion and access class.\n\nAll classes are located in `mexplus` namespace, and you can use all of them by\nincluding the `mexplus.h` header file.\n\nThe library depends on a few C++11 features, and might not be compatible with\nolder compilers. For older `g++`, make sure to add `-std=c++11` flag at compile\ntime, or in the `CXXFLAGS` variable in the MEX options located at\n`$HOME/.matlab/$VERSION/mexopts.sh`, or in Matlab R2014a or later, at\n`$HOME/.matlab/$VERSION/mex_C++_$ARCH.xml`.\n\nExample\n-------\n\nSuppose we have the following Database class in C++, and we would like to create a Matlab wrapper.\n\n```c++\n// Database.h\n\n// Hypothetical database class to be wrapped.\nclass Database {\npublic:\n  Database(const std::string& filename);\n  virtual ~Database();\n  std::string query(const std::string& key) const;\n};\n```\n\nWe will need to create two files.\n\n  * `Database_.cc`: C++ interface file.\n  * `Database.m`: Matlab interface file.\n\n`Database_.cc`\n\nC++ implementation of the MEX interface. It provides MEX entry points by\n`MEX_DEFINE` macros and `MEX_DISPATCH` macro at the end. Notice how inputs and\noutputs are wrapped by mexplus `InputArguments` and `OutputArguments` class.\nThey automatically convert majority of C++ types to/from `mxArray`, using C++\ntemplate. The `Session` class keeps `Database` instances between MEX calls,\nallowing the MEX binary to be stateful.\n\n```c++\n// Database_.cc: C++ interface file to the Database class.\n#include <mexplus.h>\n#include "Database.h"\n\nusing namespace mexplus;\nusing namespace std;\n\n// This initializes a session storage for Database instances.\ntemplate class mexplus::Session<Database>;\n\n// Create a new instance of Database and return its session id.\nMEX_DEFINE(new) (int nlhs, mxArray* plhs[],\n                 int nrhs, const mxArray* prhs[]) {\n  InputArguments input(nrhs, prhs, 1);\n  OutputArguments output(nlhs, plhs, 1);\n  output.set(0, Session<Database>::create(\n      new Database(input.get<string>(0))));\n}\n\n// Delete the Database instance specified by its id.\nMEX_DEFINE(delete) (int nlhs, mxArray* plhs[],\n                    int nrhs, const mxArray* prhs[]) {\n  InputArguments input(nrhs, prhs, 1);\n  OutputArguments output(nlhs, plhs, 0);\n  Session<Database>::destroy(input.get(0));\n}\n\n// Query to the Database instance specified by its id with a string argument.\nMEX_DEFINE(query) (int nlhs, mxArray* plhs[],\n                   int nrhs, const mxArray* prhs[]) {\n  InputArguments input(nrhs, prhs, 2);\n  OutputArguments output(nlhs, plhs, 1);\n  const Database& database = Session<Database>::getConst(input.get(0));\n  output.set(0, database.query(input.get<string>(1)));\n}\n\nMEX_DISPATCH\n```\n\n`Database.m`\n\nMatlab class interface file. The `id_` property keeps the session ID (handle)\nin the MEX binary. Each method is a wrapper around corresponding MEX entry\npoints defined in the C++ file. The first argument of `Database_()` MEX function\nis the name defined using `MEX_DEFINE()` macro in the above file.\n\n```matlab\nclassdef Database < handle\n%DATABASE Matlab interface to Database.\n\nproperties (Access = private)\n  id_ % ID of the session instance.\nend\n\nmethods\n  function this = Database(filename)\n  %DATABASE Create a new database.\n    assert(ischar(filename));\n    this.id_ = Database_(\'new\', filename);\n  end\n\n  function delete(this)\n  %DELETE Destructor.\n    Database_(\'delete\', this.id_);\n  end\n\n  function result = query(this, key)\n  %QUERY Query something to the database.\n    assert(isscalar(this));\n    result = Database_(\'query\', this.id_, key);\n  end\nend\n\nend\n```\n\n_Build_\n\nThe above C++ can be compiled by `mex` command. The output name `Database_` is\nthe MEX function name used in `Database.m`.\n\n```matlab\nmex -Iinclude Database_.cc -output Database_\n```\n\nIn Linux, you might need to add `CXXFLAGS="$CXXFLAGS -std=c++11"` to `mex`\ncommand. i.e.,\n\n```bash\nmex -Iinclude Database_.cc -output Database_ CXXFLAGS="\\$CXXFLAGS -std=c++11"\n```\n\nOnce compiled, the Database class is available in Matlab.\n\n```matlab\ndatabase = Database(\'mydatabase.db\');\nresult = database.query(\'something\');\nclear database;\n```\n\nThe development kit also contains `make.m` build function to make a build\nprocess easier. Customize this file to build your own MEX interface. The kit\ndepends on some of the C++11 features.\n\nSee `example` directory for a complete demonstration.\n\nDispatching calls\n-----------------\n\nMEXPLUS defines a few macros in `mexplus/dispatch.h` that help to create a\nsingle MEX binary with multiple function entries. Create a C++ file that looks\nlike this:\n\n```c++\n//mylibrary.cc\n#include <mexplus/dispatch.h>\n\nMEX_DEFINE(myfunc) (int nlhs, mxArray* plhs[],\n                    int nrhs, const mxArray* prhs[]) {\n  // Do something.\n}\n\nMEX_DEFINE(myfunc2) (int nlhs, mxArray* plhs[],\n                     int nrhs, const mxArray* prhs[]) {\n  // Do another thing.\n}\n\nMEX_DISPATCH\n```\n\nNotice how `MEX_DEFINE` and `MEX_DISPATCH` macros are used. Then build this\nfile in Matlab.\n\n```matlab\nmex -Iinclude mylibrary.cc\n```\n\nThe built MEX binary can now call two entries by the first argument.\n\nNote that `MEX_DISPATCH` is only required per MEX binary. If you split the\n`MEX_DEFINE` entries across multiple files, you only need to instantiate\n`MEX_DISPATCH` in one file.\n\n```matlab\nmylibrary(\'myfunc\', varargin{:})  % myfunc is called.\nmylibrary(\'myfunc2\', varargin{:}) % myfunc2 is called.\n```\n\nTo prevent from unexpected use, it is a good practice to wrap these MEX calls\nin a Matlab class or namescoped functions and place the MEX binary in a private\ndirectory:\n\n    @MyClass/MyClass.m\n    @MyClass/myfunc.m\n    @MyClass/myfunc2.m\n    @MyClass/private/mylibrary.mex*\n\nor,\n\n    +mylibrary/myfunc.m\n    +mylibrary/myfunc2.m\n    +mylibrary/private/mylibrary.mex*\n\nInside of `myfunc.m` and `myfunc2.m`, call the `mylibrary` MEX binary. This\ndesign pattern is useful to wrap a C++ class in Matlab. See the `example`\ndirectory in the package.\n\nParsing function arguments\n--------------------------\n\nMEXPLUS provides `InputArguments` and `OutputArguments` classes to ease\nparsing, validation, and data conversion of input and output arguments to MEX\nfunctions.\n\n### InputArguments\n\nThe class provides a wrapper around input arguments to validate and convert\nMatlab variables. You can define a single or multiple input formats to accept.\nThe `get()` method automatically converts Matlab\'s `mxArray` to most of the\nbasic C++ types using a template parameter. Also it can convert to a custom\ndata type when a template specialization to `MxArray::to()` method is provided.\n(See the next section.)\n\n__Example__: The MEX function takes a single numeric input argument.\n\n```c++\n// C++\nInputArguments input(nrhs, prhs, 1);\nmyFunction(input.get<double>(0));\n```\n\n```matlab\n% Matlab\nmyFunction(1.0);\n```\n\n__Example__: The MEX function takes two numeric arguments, and two optional\narguments specified by name-value pairs. When optional arguments are not given,\nthe function uses a default value.\n\n```c++\n// C++\nInputArguments input(nrhs, prhs, 2, 2, "option1", "option2");\nmyFunction(input.get<double>(0),\n           input.get<int>(1),\n           input.get<string>("option1", "foo"), // default: "foo".\n           input.get<int>("option2", 10)); // default: 10.\n```\n\n```matlab\n% Matlab\nmyFunction(1.0, 2);\nmyFunction(1.0, 2, \'option2\', 11);\nmyFunction(1.0, 2, \'option1\', \'bar\');\nmyFunction(1.0, 2, \'option1\', \'baz\', \'option2\', 12);\nmyFunction(1.0, 2, \'option2\', 12, \'option1\', \'baz\');\n```\n\n__Example__: The MEX function has two input formats: 1 + 2 arguments or 2 + 2\narguments.\n\n```c++\n// C++\nInputArguments input;\ninput.define("format1", 1, 2, "option1", "option2");\ninput.define("format2", 2, 2, "option1", "option2");\ninput.parse(nrhs, prhs);\nif (input.is("format1"))\n    myFunction(input.get<int>(0),\n               input.get<string>("option1", "foo"),\n               input.get<int>("option2", 10));\nelse if (input.is("format2"))\n    myFunction(input.get<int>(0),\n               input.get<vector<double> >(1),\n               input.get<string>("option1", "foo"),\n               input.get<int>("option2", 10));\n```\n\n```matlab\n% Matlab\nmyFunction(1.0);\nmyFunction(1.0, \'option1\', \'foo\', \'option2\', 10);\nmyFunction(1.0, [1,2,3,4]);\nmyFunction(1.0, [1,2,3,4], \'option1\', \'foo\', \'option2\', 10);\n```\n\n### OutputArguments\n\nThe class provides a wrapper around output arguments to validate and convert\nMatlab variables. The `set()` method automatically converts most of the\nbasic C++ types to Matlab\'s `mxArray` using a template parameter.\n\n__Example__: The MEX function returns at most 3 arguments. The wrapper doesn\'t\nassign to the output when the number of outputs are less than 3.\n\n```c++\nOutputArguments output(nlhs, plhs, 3);\noutput.set(0, 1);\noutput.set(1, "foo");\nMxArray cell_array(MxArray::Cell(1, 2));\ncell_array.set(0, 0);\ncell_array.set(1, "value");\noutput.set(2, cell_array.release());\n```\n\nData conversion\n---------------\n\nData conversion in MEXPLUS is provided by `MxArray` class.\n\n### MxArray\n\nThe MxArray class provides common data conversion methods between `mxArray`\nand C++ types, as well as serving itself as a unique_ptr to manage memory.\n\nTwo static methods: `MxArray::to()` and `MxArray::from()` are the core of the\nhigh-level conversions. Give a desired type in the template parameter. The\n`MxArray::to()` method has two function signatures. The one with a second\npointer argument is to avoid extra copy assignment in the return value.\n\n```c++\nint value = MxArray::to<int>(prhs[0]);\nstring value = MxArray::to<string>(prhs[0]);\nvector<double> value = MxArray::to<vector<double> >(prhs[0]);\nvector<double> value2;\nMxArray::to<vector<double> >(prhs[0], &value2); // No extra copy.\n\nplhs[0] = MxArray::from(20);\nplhs[0] = MxArray::from("text value.");\nplhs[0] = MxArray::from(vector<double>(20, 0));\n```\n\nAdditionally, the following object API\'s are to wrap around a complicated data\nconstruction with automatic memory management. Use `MxArray::release()` to\nget a mutable `mxArray` pointer after construction.\n\n```c++\n// Read access.\nMxArray cell_array(prhs[0]);   // {x, y, ...}\nint x = cell_array.at<int>(0);\nvector<double> y = cell_array.at<vector<double> >(1);\n\nMxArray struct_array(prhs[0]);   // struct(\'field1\', x, ...)\nint x = struct_array.at<int>("field1");\nvector<double> y = struct_array.at<vector<double> >("field2");\n\nMxArray numeric_array(prhs[0]);   // [x, y, ...]\ndouble x = numeric_array.at<double>(0);\nint y = numeric_array.at<int>(1);\n```\n\n```c++\n// Write access.\nMxArray cell_array(MxArray::Cell(1, 3));\ncell_array.set(0, 12);\ncell_array.set(1, "text value.");\ncell_array.set(2, vector<double>(4, 0));\nplhs[0] = cell_array.release(); // {12, \'text value.\', [0, 0, 0, 0]}\n\nMxArray struct_array(MxArray::Struct());\nstruct_array.set("field1", 12);\nstruct_array.set("field2", "text value.");\nstruct_array.set("field3", vector<double>(4, 0));\nplhs[0] = struct_array.release(); // struct(\'field1\', 12, ...)\n\nMxArray numeric_array(MxArray::Numeric<double>(2, 2));\nnumeric_array.set(0, 0, 1);\nnumeric_array.set(0, 1, 2);\nnumeric_array.set(1, 0, 3);\nnumeric_array.set(1, 1, 4);\nplhs[0] = numeric_array.release(); // [1, 2; 3, 4]\n```\n\nTo add your own data conversion, define in `namespace mexplus` a template\nspecialization of `MxArray::from()` and `MxArray::to()` with a pointer\nargument. This will also enable automatic conversion in `InputArguments` and\n`OutputArguments` class.\n\n```c++\nclass MyObject; // This is your custom data class.\n\nnamespace mexplus {\n// Define two template specializations.\ntemplate <>\nmxArray* MxArray::from(const MyObject& value) {\n  // Write your conversion code. For example,\n  MxArray struct_array(MxArray::Struct());\n  struct_array.set("x", value.x);\n  struct_array.set("y", value.y);\n  // And so on...\n  return struct_array.release();\n}\n\ntemplate <>\nvoid MxArray::to(const mxArray* array, MyObject* value) {\n  // Write your conversion code. For example,\n  MxArray struct_array(array);\n  value->x = struct_array.at<double>("x");\n  value->y = struct_array.at<double>("y");\n  // And so on...\n}\n} // namespace mexplus\n\n// Then you can use any of the following.\nMyObject object;\nstd::vector<MyObject> object_vector;\nMxArray::to<MyObject>(prhs[0], &object);\nMxArray::to<std::vector<MyObject> >(prhs[1], &object_vector);\nplhs[0] = MxArray::from(object);\nplhs[1] = MxArray::from(object_vector);\n```\n\nTest\n----\n\nRun the following to test MEXPLUS.\n\n```matlab\nmake test\n```\n\nKnown issues\n------------\n\n * Matlab keeps a string in `uint16` while the `std::string` in C++ is actually\n   `std::basic_string<char>`. Because of this, signed integers might break\n   if saved inside `std::string`. To do unicode-safe conversion, use `unicode2native` and `native2unicode` before and after calling a MEX function.\n\nTODO\n----\n\n_General_\n\n * Add a script to generate wrapper templates.\n  * Maybe, use a compiler front-end to automatically generate a wrapper?\n * Runtime dependency checker.\n\n_MxArray_\n\n * N-D array composition and decomposition. See\n   [this](https://github.com/kyamagu/matlab-bson/blob/master/src/bsonmex.c).\n * Sparse arrays.\n'