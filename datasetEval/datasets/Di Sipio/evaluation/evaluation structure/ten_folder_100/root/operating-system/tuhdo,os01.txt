b'\n[![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=tuhdo1710%40gmail%2ecom&lc=VN&item_number=tuhdo&currency_code=USD&bn=PP%2dDonationsBF%3aDonate%2dPayPal%2dgreen%2esvg%3aNonHosted)\n\n[Operating Systems: From 0 to 1](https://tuhdo.github.io/os01/)\n=============================\n\nThis book helps you gain the foundational knowledge required to write an\noperating system from scratch. Hence the title, 0 to 1.\n\nAfter completing this book, at the very least you will learn:\n\n- How to write an operating system from scratch by reading hardware datasheets.\n  In the real world, it works like that. You won\'t be able to consult Google for\n  a quick answer.\n\n- A big picture of how each layer of a computer is related to the other, from hardware to software.\n\n- Write code independently. It\'s pointless to copy and paste code. Real learning\n  happens when you solve problems on your own. Some examples are given to kick\n  start, but most problems are yours to conquer. However, the solutions are\n  available online for you to examine after giving it a good try.\n\n- Linux as a development environment and how to use common tools for low-level\n  programming.\n\n- x86 assembly in-depth.\n\n- How a program is structured so that an operating system can run.\n\n- How to debug a program running directly on hardware with gdb and QEMU.\n\n- Linking and loading on bare metal x86_64, with pure C. No standard library. No\n  runtime overhead.\n\n[Download the book](https://github.com/tuhdo/os01/blob/master/Operating_Systems_From_0_to_1.pdf)\n\n# The pedagogy of the book\n\n> You give a poor man a fish and you feed him for a day. You teach him to fish\n> and you give him an occupation that will feed him for a lifetime.\n\nThis has been the guiding principle of the book when I was writing it. The book does\nnot try to teach you everything, but enough to enable you to learn by yourself.\nThe book itself, at this point, is quite "complete": once you master part 1 and\npart 2 (which consist of 8 chapters), you can drop the book and learn by\nyourself. At this point, smart readers should be able to continue on their own.\nFor example, they can continue their journeys\non [OSDev wiki](http://wiki.osdev.org/Main_Page); in fact, after you study\neverything in part 1 and part 2, you only meet\nthe [minimum requirement](http://wiki.osdev.org/Required_Knowledge) by OSDev\nWiki (well, not quite, the book actually goes deeper for the suggested topics).\nOr, if you consider developing an OS for fun is impractical, you can continue\nwith a Linux-specific book, such as this free\nbook [Linux Insides](https://0xax.gitbooks.io/linux-insides/content/), or other\npopular Linux kernel books. The book tries hard to provide you a strong\nfoundation, and that\'s why part 1 and part 2 were released first.\n\nThe book teaches you core concepts, such as x86 Assembly, ELF, linking and\ndebugging on bare metal, etc., but more importantly, where such information\ncome from. For example, instead of just teaching x86 Assembly, it also teaches\nhow to use reference manuals from Intel. Learning to read the official\nmanuals is important because only the hardware manufacturers themselves\nunderstand how their hardware work. If you only learn from the secondary\nresources because it is easier, you will never gain a complete understanding of\nthe hardware you are programming for. Have you ever read a book on Assembly, and\nwondered where all the information came from? How does the author know\neverything he says is correct? And how one seems to magically know so much about\nhardware programming? This book gives pointers to such questions.\n\nAs an example, you should skim through chapter 4, "x86 Assembly and C", to see\nhow it makes use of the Intel manual, Volume 2. And in\nthe process, it guides you how to use the official manuals.\n\nPart 3 is planned as a series of specifications that a reader will implement to\ncomplete each operating system component. It does not contain code aside from a\nfew examples. Part 3 is just there to shorten the reader\'s time when reading the\nofficial manuals by giving hints where to read, explaining difficult concepts\nand how to use the manuals to debug. In short, the implementation is up to the\nreader to work on his or her own; the chapters are just like university assignments.\n\n# Prerequisites\n\nKnow some circuit concepts:\n+ Basic Concepts of Electricity: atoms, electrons, protons, neutrons, current flow.\n+ Ohm\'s law\n\nHowever, if you know absolutely nothing about electricity, you can quickly learn it here:\n<http://www.allaboutcircuits.com/textbook/>, by reading chapter 1 and chapter 2.\n\nC programming. In particular:\n\n+ Variable and function declarations/definitions\n\n+ While and for loops\n\n+ Pointers and function pointers\n\n+ Fundamental algorithms and data structures in C\n\nLinux basics:\n\n+ Know how to navigate directory with the command line\n\n+ Know how to invoke a command with options\n\n+ Know how to pipe output to another program\n\nTouch typing. Since we are going to use Linux, touch typing helps. I know typing\nspeed does not relate to problem-solving, but at least your typing speed should\nbe fast enough not to let it get it the way and degrade the learning experience.\n\nIn general, I assume that the reader has basic C programming knowledge, and can\nuse an IDE to build and run a program.\n\n# Status:\n* Part 1\n    - Chapter 1: Complete\n    - Chapter 2: Complete\n    - Chapter 3: Almost. Currently, the book relies on the Intel Manual for fully explaining x86 execution environment.\n    - Chapter 4: Complete\n    - Chapter 5: Complete\n    - Chapter 6: Complete\n* Part 2\n    - Chapter 7: Complete\n    - Chapter 8: Complete\n* Part 3\n    - Chapter 9: Incomplete\n    - Chapter 10: Incomplete\n    - Chapter 11: Incomplete\n    - Chapter 12: Incomplete\n    - Chapter 13: Incomplete\n\n    ... and future chapters not included yet ...\n\nIn the future, I hope to expand part 3 to cover more than the first 2 parts. But\nfor the time being, I will try to finish the above chapters first.\n\n# Sample OS\n[This repository](https://github.com/tuhdo/sample-os) is the sample OS of the\nbook that is intended as a reference material for part 3. It covers 10 chapters\nof the "System Programming Guide" (Intel Manual Volume 3), along with a simple\nkeyboard and video driver for input and output. However, at the moment, only the\nfollowing features are implemented:\n\n- Protected mode.\n- Creating and managing processes with TSS (Task State Structure).\n- Interrupts\n- LAPIC.\n\nPaging and I/O are not yet implemented. I will try to implement it as the book progresses.\n\n# Contributing\n\nIf you find any grammatical issues, please report it using Github Issues. Or, if\nsome sentence or paragraph is difficult to understand, feel free to open an\nissue with the following title format: `[page number][type] Descriptive Title`.\n\nFor example: `[pg.9][grammar] Incorrect verb usage`.\n\n`type` can be one of the following:\n\n- `Typo`: indicates typing mistake.\n- `Grammar`: indicates incorrect grammar usage.\n- `Style`: indicates a style improvement.\n- `Content`: indicates problems with the content.\n\nEven better, you can make a pull request with the provided book source. The main\ncontent of the book is in the file "Operating Systems: From 0 to 1.lyx". You can\nedit the .txt file, then I will integrate the changes manually. It is a\nworkaround for now since Lyx can cause a huge diff which makes it impossible to\nreview changes.\n\nThe book is in development, so please bear with me if the English irritates you.\nI really appreciate it.\n\nFinally, if you like the project and if it is possible, please donate to help\nthis project and keep it going.\n\n# Got questions?\nIf you have any question related to the material or the development of the book,\nfeel free to [open a Github issue](https://github.com/tuhdo/os01/issues/new).\n'