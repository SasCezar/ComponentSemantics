b'Escape\n======\n\nEscape is a UNIX-like microkernel operating system on which I\'m working since\noctober 2008. It\'s implemented in C, C++ and a bit assembler. I\'m trying to\nwrite all code myself to maximize the learning effect and the fun, but\nthere are some cases where it just gets too time consuming to do that. Thus,\nI\'m using the bootloader GRUB, libgcc, libsupc++ and x86emu.\n\nEscape runs on x86, x86_64, ECO32 and MMIX.\n[ECO32](http://homepages.thm.de/~hg53/eco32/) is a 32-bit big-endian RISC\narchitecture, created by Hellwig Geisse at the University of Applied Sciences\nin Gie\xc3\x9fen for research and teaching purposes.\nMMIX is a 64-bit big-endian RISC architecture, developed by Donald Knuth as\nthe successor of MIX, which is the abstract machine that is used in the famous\nbookseries The Art of Computer Programming. More precisely, Escape runs only\non [GIMMIX](http://homepages.thm.de/~hg53/gimmix/), a simulator for MMIX\ndeveloped by myself for my master thesis (the differences are minimal, but\ncurrently required for Escape).\n\nIf you just want to take a quick look, you\'ll find\n[screenshots](https://github.com/Nils-TUD/Escape/wiki/Screenshots) and\nready-to-use [images](https://github.com/Nils-TUD/Escape/wiki/Images) in\nthe wiki.\n\n\nGeneral structure\n-----------------\n\nEscape consists of a kernel, drivers, libraries and user applications. The\nkernel is responsible for processes, threads, memory management, a virtual\nfile system (VFS) and some other things. Drivers run in user space and work\nvia message passing. They do not necessarily access the hardware and should\ntherefore more seen as an instance that provides a service.\n\nThe VFS is one of the central points of Escape. Besides the opportunity to\ncreate files and folders in it, it is used to provide information about the\nstate of the system for the user space (memory usage, CPU, running\nprocesses, ...). Most important, the VFS is used to communicate with devices,\nwhich are registered and handled by drivers. That means, each device gets\na node in the VFS over which it can be accessed. So, for example an\n`open("/dev/zero",...)` would open the device "zero". Afterwards one can use\nthe received file descriptor to communicate with it.\n\nBasically, the communication works over messages. Escape provides the\nsystem calls `send` and `receive` for that purpose. Additionally, Escape defines\nstandard messages for `open`, `read`, `write` and `close`, which devices\nmay support. For example, when using the `read` system call with a\nfile descriptor for a device, Escape will send the read message to\nthe corresponding device and handle the communication for the user program.\nAs soon as the answer is available, the result is passed back to the\nuser program that called `read`.\nBecause of this mechanism the user space doesn\'t have to distinguish between\nvirtual files, "real" files and devices. So, for example the tool cat can\nsimply do an `open` and use `read` to read from that file and `write` to\nwrite to stdout.\n\nThe same mechanism is used for filesystems, which can be mounted somewhere\nin the VFS. If a file is opened which belongs to one of these mounted\nfilesystems, the kernel will handle the communication with the driver that\nhas been registers as being responsible for this filesystem. This does not\nonly serve for getting filesystems out of the kernel, but does also provide\nthe possibility to use the filesystem interface whenever it fits. For example,\nEscape has a ftpfs that allows you to access a FTP server by mounting it\nsomewhere and a tarfs to access and/or change a tar file.\n\nEscape has also an interesting sandboxing mechanism, which causes no\nperformance overhead, can be used by unprivileged users (non-root) and\nis nestable (sandboxed processes can create sandboxes). In general, Escape\ndoes not allow to upgrade privileges, but only to downgrade them. To downgrade\npermissions, the sandbox application can be used. It allows to leave groups\nto restrict the access to drivers and services. And it allows to remount\ndirectories in the filesystem to reduce the permissions of entire subtrees.\nLet\'s consider a (non-existing) music player as an example. We could use\nsandbox to:\n\n* leave all groups, except audio\n* remove all access to the filesystem, except read+exec permission to its own\n  directory containing the executable, libraries, etc. and read permission to\n  the directory that contains the music library.\n\nAlthough the music player runs with our user, which makes sandboxing simple,\nit can\'t cause any harm to the rest of the system.\n\n\nFeatures\n--------\n\nEscape has currently the following features:\n\n* **Kernel**\n    * Memory management supporting copy-on-write, text sharing,\n      shared libraries, shared memory, mapping of physical mem (e.g. VESA),\n      demand loading and swapping\n    * Process and thread management, scheduler, ELF loader, groups, signals,\n      semaphores (are also used to pass interrupts to drivers) and\n      timer management (for sleeping and preemption)\n    * SMP support, CPU detection and CPU-speed calculation, FPU support\n    * Virtual file system for driver access, accessing the filesystems,\n      creating virtual files and directories and providing information about\n      the system (memory usage, cpu, running processes, ...)\n    * Debugging console\n* **libc**  \n  Except of some IMO not very important things like locale, math and so on,\n  most of a C standard library exists by now.\n* **libcpp**  \n  The C++ standard library isn\'t that complete as the libc. But the most basic\n  things like string, iostreams, vector, list, tuple, map, algorithm and a few\n  other things are available (some of them are a bit simpler than the standard\n  specifies it). That means, one can develop applications with the library when\n  one doesn\'t need the more exotic stuff ;)\n* **libesc**  \n  Many abstractions specifically for Escape. Most important, it contains classes\n  to communicate with certain types of devices like the window managers, NICs,\n  TCP/IP stacks and so on. Additionally, the library provides classes to\n  implement devices.\n* **libgui**  \n  The GUI library isn\'t finished yet, but does already provide things like\n  basic controls, layout manager, image support (BMP and PNG), event system\n  (keypresses, ...) and so on. It is written in C++, which was one of the main\n  reason to provide C++ support in Escape.\n* **libz**  \n  Contains classes for deflate/inflate, gzip and CRC32.\n* **drivers**  \n  Escape has some architecture-specific drivers and some common drivers that\n  are architecture independent. Currently, there are:\n    * common\n        * ext2: a nearly complete ext2-rev0 fs\n        * ftpfs: allows to access an FTP like an fs\n        * http: presents a HTTP accessible resource as a file\n        * init: is responsible for loading the drivers and restarting them\n          on crashes. The file /etc/drivers defines the drivers to load.\n        * initloader: Is loaded as boot module and is used as the first user process.\n          Loads the other boot modules (disk driver, pci (on x86 only) and fs\n          because we need them to load other drivers and user apps from the disk)\n          and mounts the root filesystem. After that it replaces itself with init.\n        * iso9660: a iso9660 fs (cd fs)\n        * lo: the loopback driver\n        * network: starts the network drivers according to PCI and creates links\n          for them. On crashes, it restarts the driver.\n        * pipe: realizes pipes\n        * ramdisk: a fs backend that sits in RAM\n        * tarfs: allows to access a tar like an fs\n        * tcpip: a TCP/IP stack (v4 only atm)\n        * uimng: multiplexes input and output devices between its clients.\n          A client gets an UI which supplies him with keyboard and mouse\n          events and provides him a screen. Both text and graphical interfaces\n          are supported. uimng has keyboard shortcuts for creating UIs and\n          switching between them.\n        * vterm: a text-interface client of uimng that provides a layer of\n          abstraction for user processes that are textbased.\n        * winmng: a GUI client of uimng that manages all existing windows. Gets\n          keyboard and mouse events from uimng and forwards it to the\n          corresponding application.\n        * random/null/zero: like /dev/{random,null,zero} in e.g. Linux\n    * x86\n        * ata: reading and writing from/to ATA/ATAPI devices. It supports\n          PIO-mode and DMA, LBA28 and LBA48.\n        * e1000: network driver for Intel e1000 cards.\n        * ne2k: network driver for NE2000 compatible cards\n        * pci: collects the available PCI devices and gives others access to\n          them. This is e.g. used by ata to find the IDE controller.\n        * ps2: a PS/2 driver with keyboard and mouse support. Gets notified\n          about interrupts, converts scancodes to keycodes and broadcasts\n          keyboard/mouse events to all clients.\n        * serial: provides a vterm interface for a serial port\n        * speaker: produces beeps with the PC speaker with a specified\n          frequency and duration.\n        * video: an output device for uimng that supports VGA and VESA. It\n          uses the BIOS via x86emu (to support x86 and x86_64) to get and set\n          video modes. Clients establish a shared memory for the screen and\n          talk via messages with the driver to copy parts of it to the actual\n          framebuffer.\n    * ECO32/MMIX  \n      Both architectures have the same devices atm (the only difference is that\n      ECO32 devices are accessed with 32-bit words and MMIX devices with 64-bit\n      words).\n        * disk: the disk driver and therefore the equivalent to ata on x86.\n        * keyb: the keyboard driver\n        * term: provides a vterm interface for a terminal\n        * video: the VGA driver\n* **user**  \n  There are quite a few user programs so that you can actually do something with\n  Escape ;) The most important ones are:\n    * mount: creates a filesystem device and binds it to a path.\n    * bind: binds an existing filesystem device to a different path.\n    * dynlink: the dynamic linker of Escape that is started by the kernel, if\n      the requested application is dynamically linked. It receives the fd for\n      the executable, loads all dependencies, does the relocation and\n      initialization and finally jumps to the application.\n    * users, groups: tools to conveniently add, edit and delete users/groups.\n    * (g)login: accepts username+password, sets uid, gid and further group ids\n      using /etc/users and /etc/groups, creates stdin, stdout and stderr, sets\n      the env vars CWD and USER and exchanges itself with the shell. There is\n      one for the text interface and one for the GUI.\n    * shell: The shell implements an interpreter for a small shell-scripting\n      language with pipes, io redirection, path expansion, background jobs,\n      arithmetic, loops, if statements, functions, variables and arrays.\n      The interpreter is implemented with flex and bison.\n    * cat, chmod, chown, cp, cut, date, dd, du, dump, find, grep, gunzip, gzip,\n      head, id, killall, less, ln, ls, lscpu, lspci, mkdir, mke2fs, more, mv,\n      ping, ps, pstree, readelf, rm, rmdir, size, sleep, sort, stat, strace, sync,\n      tail, tar, tee, time, top, touch, truncate, umount, wc, xargs, yes: The\n      well-known UNIX tools. They don\'t do exactly the same and are, of course,\n      much simpler, but in principle they are intended for the same things.\n    * ts: analogously to ps, ts lists all threads\n    * power: for reboot / shutdown using init.\n    * uictrl: a tool to show and set video modes, set keymap and list UIs\n    * lsacpi: list ACPI tables\n    * net-link: a tool for managing the network links (similar to ifconfig)\n    * net-arp: a tool to manage the ARP tables\n    * net-routes: a tool to manage the routing tables\n    * dhcp: use DHCP to configure a network link\n    * imginfo: show information about an image\n    * plasma: shows a plasma animation in text mode, graphical mode or GUI window\n    * sandbox: starts an application with restricted permissions (groups, mountspace)\n    * cpugraph, desktop, fileman, gcalc, gclock, gsettings, guishell, slideshow:\n      some GUI programs\n    * ...\n\n\nGetting started\n---------------\n\n1. At first you need to build the cross compiler for the desired\n   architecture:  \n   `$ cd cross`  \n   `$ ./build.sh (i586|x86_64|eco32|mmix)`  \n   This will download gcc and binutils, build the cross compiler and put it\n   into /opt/escape-cross-$arch.\n2. Now you can build escape:  \n   `$ cd ../source`  \n   `$ export ESC_TARGET=$arch` # choose $arch, if necessary (default: i586)  \n   `$ ./b`\n3. To start it, you have to choose a boot script at boot/`$ESC_TARGET`/.\n   E.g.:  \n   `$ ./b run qemu-cd`\n4. For further information, take a look at `./b -h`\n\n'