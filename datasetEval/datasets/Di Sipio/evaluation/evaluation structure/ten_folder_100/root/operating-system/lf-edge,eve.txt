b'# EVE is Edge Virtualization Engine\n\n[![CircleCI](https://circleci.com/gh/lf-edge/eve.svg?style=svg)](https://circleci.com/gh/lf-edge/eve)\n[![Goreport](https://goreportcard.com/badge/github.com/lf-edge/eve)](https://goreportcard.com/report/github.com/lf-edge/eve)\n[![Godoc](https://godoc.org/github.com/lf-edge/eve/pkg/pillar?status.svg)](https://godoc.org/github.com/lf-edge/eve/pkg/pillar)\n\nEVE aims to develop an open, agnostic and standardized architecture unifying the approach to developing and orchestrating cloud-native applications across the enterprise on-premises edge. It offers users new levels of control through hardware-assisted virtualization of on-prem edge devices. Once installed, EVE has direct access to and control of underlying resources and provides standard APIs that allow more efficient use of resources and can effectively partition hardware to increase workload consolidation and application multi-tenancy.\n\nEVE supports both ARM and Intel architectures and requires hardware-assisted virtualization. While EVE can run on a board as small as a $20 Orange Pi, the sweet spot for its deployment are IoT Gateways and Industrial PCs.\n\nTo get its job done, EVE leverages a lot of great open source projects: [Xen Project](https://xenproject.org/), [Linuxkit](https://github.com/linuxkit/linuxkit) and [Alpine Linux](https://alpinelinux.org/) just to name a few. All of that functionality is being orchestrated by the Go microservices available under [pkg/pillar](pkg/pillar). Why pillar? Well, because pillar is the kind of a monolith we need to break out into true, individual microservices under [pkg/](pkg/).\n\n## How to use\n\nYou will need [QEMU 3.x+](https://www.qemu.org/), [Docker](https://www.docker.com)\nand [go 1.12+](https://golang.org) installed in your system.\n\nNote, that since Linuxkit and manifest-tool are evolving pretty rapidly, we\'re\nvendoring those under build-tools/src. This means you don\'t have to have them\nlocally installed, but it also means your first build time will be much longer.\n\nIf you\'re on MacOS the following steps should get you all the dependencies:\n\n### Install Dependencies\n\n#### Get Go\n\n```sh\nhttps://golang.org/dl/\n```\n\n#### Get Docker\n\n```sh\nhttps://store.docker.com/editions/community/docker-ce-desktop-mac\n```\n\nMake sure that Docker is up and running on your system. On MacOS just start a docker Application, on Linux make sure docker service is running. Regardless of how you start Docker you can make sure that it is ready for you by running the following command and making sure that it returns both a version of the client AND a version of the server:\n\n```sh\ndocker version\n```\n\n#### Get QEMU\n\n##### On OSX using [Brew](https://brew.sh/)\n\n```sh\n$ brew install qemu\n```\n\n##### On Ubuntu Linux\n\n```sh\n$ sudo apt install qemu-utils # for make live\n$ sudo apt install qemu-system-x86 # for make run\n```\n\n#### Get Project EVE\n\nEVE requires being built in a Git repository (the tools keep looking up git commit IDs). The easiest way is to clone EVE repository from GitHub:\n\n```sh\ngit clone https://github.com/lf-edge/eve.git\ncd eve\n```\n\nBuild both the build-tools as well as the live image in the source directory:\n\n```sh\nmake build-tools\nmake live\n```\n\nThis will download the relevant docker images from docker hub and create a bootable\nimage `dist/<ARCH>/live.img`.\n\nPlease note that not all containers will be fetched from Docker Hub.\n`mkimage-raw-efi` in particular will be built.\n\n> **_NOTE:_** Since the initial build fetches a LOT of bits\n> over the network it may occasionally time out and fail. Typically\n> re-running `make` fixes the issue. If it doesn\'t you can attempt a local\n> build of all the required EVE packages first by running `make pkgs`\n\n#### Proxies\n\nBuilding of the various images may require downloading packages from the Internet. If you have direct Internet access, everything will "just work".\nOn the other hand, if you need to run behind a proxy, you may run into issues downloading. These manifest in two key areas:\n\n* docker: docker needs to download images from the image registries. Configuring your local installation of docker is beyond the scope of this\ndocument, please see [here](https://docs.docker.com/network/proxy/).\n* packages: the package updates _inside_ the images running in docker may need to use http/s proxies.\n\nTo configure your build process to use proxies, you can set the following environment variables. They will be picked up automatically when running\nany `make` commands and used within the building containers. If they are _not_ set, no proxy is set:\n\n* `HTTP_PROXY`\n* `HTTPS_PROXY`\n* `ALL_PROXY`\n* `NO_PROXY`\n\n#### Running in QEMU\n\nFinally run the resulting image in QEMU with some default assumptions:\n\n```sh\nmake run\n```\n\n> **_NOTE:_**  The default QEMU configuration needs 4GB of memory available.\n> If you get an error message about being unable to allocate memory, try freeing up some RAM.\n> If you can\'t free up 4GB, you can reduce the memory allocation in the `Makefile` from 4096 (4GB) to 2048 (2GB).\n> Running QEMU with less than 2GB of memory is not recommended.\n\nOnce the image boots you can interact with it either by using the console\n(right there in the terminal window from which make run was executed).\nYour shell in the console is connected to the \'host\' os. Everything\ninteresting is actually happening in the pillar container. Use\n`eve enter` command to enter it (or if you\'re comfortable with ctr CLI\nfrom containerd - use that instead).\n\nOnce in a container you can run the usual xl commands to start VMs and\ninteract with Xen.\n\n#### Exitting\n\nTo exit out of the QEMU environment, press `Ctrl-A + C` to reach the QEMU console, then `q` to quit.\n\n##### Linux\n\n```sh\n$ exit # leave eve\n$ poweroff -f # leave qemu\n```\n\n### Customizing the Configuration\n\nAs described in [BUILD.md](./docs/BUILD.md) and [REGISTRATION.md](./docs/REGISTRATION.md), a booting EVE looks in its config partition to determine:\n\n* the URL to a Controller\n* hostnames to add to the `/etc/hosts` file\n* certificates to trust\n\nWhen run in an emulator using `make run`, you can override the built-in `/config` partition by passing it the path of a directory to mount as that partition:\n\n```sh\nmake run CONF_PART=/path/to/partition\n```\n\nNote that the directory must exist to be mounted; if not, it will be ignored. The most common use case is a config directory output on the run of [adam](https://github.com/zededa/adam).\n\n## How to use on an ARM board\n\nWhile running everything on your laptop with QEMU could be fun, nothing\nbeats real hardware. The most cost-effective option, not surprisingly,\nis ARM. We recommend using HiKey board [http://www.lenovator.com/product/90.html](http://www.lenovator.com/product/90.html).\nOnce you acquire the board you will need to build an installer image by running\n(note that if you\'re building it on an ARM server you can drop ZARCH=arm64 part):\n\n```sh\nmake ZARCH=arm64 installer\n```\n\nand then flashing it onto an SD card. For example, here\'s how you can do the\nflashing on Mac OS X (where XXX is the name of your SD card as shown by\ndiskutil list):\n\n```sh\ndiskutil list\ndiskutil umountDisk /dev/rdiskXXX\nsudo dd if=dist/arm64/installer.raw of=/dev/rdiskXXX bs=1m\ndiskutil eject /dev/rdiskXXX\n```\n\nSince by default HiKey is using WiFi for all its networking, you will also\nhave to provide SSID and password for your WiFi network. On Mac OS X you\ncan simply re-insert SD card and edit wpa_supplicant.conf that will appear\non volume called EVE.\n\nAt this point you have everything you need to permanently install onto\nHiKey\'s internal flash. This, of course, will mean that if you have anything\nelse installed there (like a Debian or Android OS) it will be replaced so\nmake sure to make a backup if you nee to.\n\nAdditionally, our installer will try to configure an entry point to the\ninitial boot sequence via GRUB. Since the only reliable way to do so is\nby replacing a file called fastboot.efi in the system boot partition you\nneed to make sure that you have fastboot.efi present there (since if isn\'t\nthere installer will refuse to proceed). The easiest way to check for\nall that is to invoke an EFI shell on HiKey. Here\'s how: put the SD card\ninto the KiKey, connect HiKey to your serial port, start screen, poweron\nHiKey and immediately start pressing `<ESC>` key to trigger EFI shell:\n\n```sh\nscreen /dev/tty.usbserial-* 115200\n\n[1] fastboot\n[2] boot from eMMC\n[3] boot from SD card\n[4] Shell\n[5] Boot Manager\nStart: 4\n.....\nPress ESC in 4 seconds to skip startup.nsh or any other key to continue.\n\nShell> ls fs2:\\EFI\\BOOT\\fastboot.efi\nShell> setsize 1 fs2:\\EFI\\BOOT\\fastboot.efi\n```\n\nNOTE: you only need to execute the last (setsize) command if, for whatever\nreason, the previous command doesn\'t show fastboot.efi present on your\nsystem. Once you\'ve either verified that there\'s an existing fastboot.efi\n(or created a dummy one via the setsize command) you can proceed with\nthe rest of the installation from the same EFI shell by executing:\n\n```sh\nShell> fs0:\\EFI\\BOOT\\BOOTX64.EFI\n```\n\nYou will see an installation sequence scroll on screen and the output\nthat indicates a successful install will look like this:\n\n```sh\n[   85.717414]  mmcblk0: p1 p2 p3 p4 p5 p6 p7 p8 p11\n[   87.420407]  mmcblk0: p1 p2 p3 p4 p5 p6 p7 p8 p11 p12\n[  118.754353]  mmcblk0: p1 p2 p3 p4 p5 p6 p7 p8 p11 p12 p13\n[  119.801805]  mmcblk0: p1 p2 p3 p4 p5 p6 p7 p8 p11 p12 p13 p14\n[  120.992048]  mmcblk0: p1 p2 p3 p4 p5 p6 p7 p8 p11 p12 p13 p14 p19\n[  127.191119] reboot: Power down\n(XEN) Hardware Dom0 halted: halting machine\n```\n\nAt this point you should remove your SD card from HiKey\'s slot and reboot\nthe board. If everything went as planned you will boot right into the running\nsystem. One thing that you will notice is that a successful installation sequence\nmade a backup copy of your existing fastboot.efi under the fastboot.efi.XXX name.\nThis allows you to restore your HiKey to a pristine state without going through\na full fledged re-flashing sequence.\n\nAlternatively, if you\'re not quite ready to commit to replace your current OS\non the HiKey, you can try running from the SD card. For that you will have to\nput a live system on the SD card, not the installer. Here\'s how you can do that\non Mac OS X:\n\n```sh\nvi conf/wpa_supplicant.conf\n  # put your WIFI passwords in and/or add your own networks\nmake ZARCH=arm64 MEDIA_SIZE=8192 live\nsudo dd if=dist/arm64/live.raw of=/dev/rdiskXXX bs=1m\n```\n\nThen you can boot into a live system from triggering UEFI shell like shown\nabove and executing exactly the same boot command:\n\n```sh\nShell> fs0:\\EFI\\BOOT\\BOOTX64.EFI\n```\n\n## How to use on an AMD board\n\nThe following steps have been tested on Intel UP Squared Board (AAEON UP-APL01) and the bootable USB Disk containing the installer image has been made on Ubuntu 16.04.\n\n```bash\ngit clone https://github.com/lf-edge/eve.git\ncd eve\nmake ZARCH=amd64 installer\n```\n\nFind the device using\n\n### On Ubuntu\n\n```bash\nfdisk -l\n```\n\n### On OSX\n\n```bash\ndiskutil list\n```\n\nNow format the USB Disk and run the following commands\n\n```bash\nsudo umount /dev/sdXXX\nsudo dd if=dist/amd64/installer.raw of=/dev/sdXXX\n```\n\nAlternatively the image can be written with tools like [balenaEtcher](https://www.balena.io/etcher/)\n\nNow plug the USB Disk on your UP Squared Board and the installer should now replace the existing OS on the UP Squared board with EVE.\n\nYou will see an installation sequence scroll on screen and the output that indicates a successful install will look like this:\n\n```bash\n[10.69716164] mmcblk0:\n[11.915943]   mmcblk0: p1\n[13.606346]   mmcblk0: p1 p2\n[29.656563]   mmcblk0: p1 p2 p3\n[30.876806]   mmcblk0: p1 p2 p3 p4\n[32.156930]   mmcblk0: p1 p2 p3 p4 p9\nNOTICE: Device will now power off. Remove the USB stick and power it back on to complete the installation.\n[43.185325]   ACPI: Preparing to enter system sleep state S5\n[43.187349]   reboot: Power down\n```\n\nAt this point you should remove your USB Disk from the UP Squared Board slot and reboot the board. If everything went as planned you will boot right into the running system.\n\nA quick note on linuxkit: you may be wondering why do we have a container-based\narchitecture for a Xen-centric environment. First of all, OCI containers\nare a key type of a workload for our platform. Which means having\nOCI environment to run them is a key requirement. We do plan to run them\nvia Stage 1 Xen [https://github.com/rkt/stage1-xen](https://github.com/rkt/stage1-xen)\ndown the road, but\nwhile that isn\'t integrated fully we will be simply relying on containerd.\nIn addition to that, while we plan to build a fully disagregated system\n(with even device drivers running in their separate domains) right now\nwe are just getting started and having containers as a first step towards\nfull disagreagation seems like a very convenient stepping stone.\n\nLet us know what you think by filing GitHub issues, and feel free to\nsend us pull requests if something doesn\'t quite work.\n'