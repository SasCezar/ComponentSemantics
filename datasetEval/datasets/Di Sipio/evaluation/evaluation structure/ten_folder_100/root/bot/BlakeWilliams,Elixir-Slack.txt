b'[![Build\nStatus](https://api.travis-ci.org/BlakeWilliams/Elixir-Slack.svg?branch=master)](https://travis-ci.org/BlakeWilliams/Elixir-Slack)\n\n# Elixir-Slack\n\nThis is a Slack [Real Time Messaging API] client for Elixir.  You\'ll need a\nSlack API token which can be retrieved by following the [Token Generation\nInstructions] or by creating a\nnew [bot integration].\n\n[Real time Messaging API]: https://api.slack.com/rtm\n[Token Generation Instructions]: https://hexdocs.pm/slack/token_generation_instructions.html\n[bot integration]: https://my.slack.com/services/new/bot\n\n## Installing\n\nAdd Slack to your `mix.exs` `dependencies` function.\n\n[websocket_client]: https://github.com/jeremyong/websocket_client\n\n```elixir\ndef application do\n  [extra_applications: [:logger]]\nend\n\ndef deps do\n  [{:slack, "~> 0.19.0"}]\nend\n```\n\n## RTM (Bot) Usage\n\nDefine a module that uses the Slack behaviour and defines the appropriate\ncallback methods.\n\n```elixir\ndefmodule SlackRtm do\n  use Slack\n\n  def handle_connect(slack, state) do\n    IO.puts "Connected as #{slack.me.name}"\n    {:ok, state}\n  end\n\n  def handle_event(message = %{type: "message"}, slack, state) do\n    send_message("I got a message!", message.channel, slack)\n    {:ok, state}\n  end\n  def handle_event(_, _, state), do: {:ok, state}\n\n  def handle_info({:message, text, channel}, slack, state) do\n    IO.puts "Sending your message, captain!"\n\n    send_message(text, channel, slack)\n\n    {:ok, state}\n  end\n  def handle_info(_, _, state), do: {:ok, state}\nend\n```\n\nTo run this example, you\'ll want to call `Slack.Bot.start_link(SlackRtm, [],\n"TOKEN_HERE")` and run the project with `mix run --no-halt`.\n\nYou can send messages to channels using `send_message/3` which takes the message\nas the first argument, channel/user as the second, and the passed in `slack`\nstate as the third.\n\nThe passed in `slack` state holds the current user properties as `me`, team\nproperties as `team`, the current websocket connection as `socket`, and a list\nof  `bots`, `channels`, `groups`, `users`, and `ims` (direct message channels).\n\n[rtm.start]: https://api.slack.com/methods/rtm.start\n\nIf you want to do things like trigger the sending of messages outside of your\nSlack handlers, you can leverage the `handle_info/3` callback to implement an\nexternal API.\n\nThis allows you to both respond to Slack RTM events and programmatically control\nyour bot from external events.\n\n```elixir\n{:ok, rtm} = Slack.Bot.start_link(SlackRtm, [], "token")\nsend rtm, {:message, "External message", "#general"}\n#=> {:message, "External message", "#general"}\n#==> Sending your message, captain!\n```\n\nSlack has *a lot* of message types so it\'s a good idea to define a callback like\nabove where unhandled message types don\'t crash your application. You can find a\nlist of message types and examples on the [RTM API page].\n\nYou can find more detailed documentation on the [Slack hexdocs\npage][documentation].\n\n[RTM API page]: https://api.slack.com/rtm\n\n## Web API Usage\n\nThe complete Slack Web API is implemented by generating modules/functions from\nthe JSON documentation. You can view this project\'s [documentation] for more\ndetails.\n\nThere are two ways to authenticate your API calls. You can configure `api_token`\non `slack` that will authenticate all calls to the API automatically.\n\n```elixir\nconfig :slack, api_token: "VALUE"\n```\n\nAlternatively you can pass in `%{token: "VALUE"}` to any API call in\n`optional_params`. This also allows you to override the configured `api_token`\nvalue if desired.\n\nQuick example, getting the names of everyone on your team:\n\n```elixir\nnames = Slack.Web.Users.list(%{token: "TOKEN_HERE"})\n|> Map.get("members")\n|> Enum.map(fn(member) ->\n  member["real_name"]\nend)\n```\n\n### Web Client Configuration\n\nA custom client callback module can be configured for cases in which you need extra control\nover how calls to the web API are performed. This can be used to control timeouts, or to add additional\ncustom error handling as needed.\n\n```elixir\nconfig :slack, :web_http_client, YourApp.CustomClient\n```\n\nAll Web API calls from documentation-generated modules/functions will call `post!/2` with the generated url\nand body passed as arguments.\n\nIn the case where you only need to control the options passed to HTTPoison/hackney, the default client accepts\na keyword list as an additional configuration parameter. Note that this is ignored if configuring a custom client.\n\nSee [HTTPoison docs](https://hexdocs.pm/httpoison/HTTPoison.html#request/5) for a list of available options.\n\n```elixir\nconfig :slack, :web_http_client_opts, [timeout: 10_000, recv_timeout: 10_000]\n```\n\n\n## Testing\n\nFor integration tests, you can change the default Slack URL to your fake Slack\nserver:\n\n```elixir\nconfig :slack, url: "http://localhost:8000"\n```\n\n[documentation]: http://hexdocs.pm/slack/\n'