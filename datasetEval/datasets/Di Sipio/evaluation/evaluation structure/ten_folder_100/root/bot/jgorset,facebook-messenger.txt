b'<p align="center">\n  <img src="https://rawgit.com/jgorset/facebook-messenger/master/docs/conversation_with_logo.gif">\n</p>\n\n\n[![Gem Version](https://img.shields.io/gem/v/facebook-messenger.svg?style=flat)](https://rubygems.org/gems/facebook-messenger)\n[![Gem Downloads](https://img.shields.io/gem/dt/facebook-messenger.svg)](https://rubygems.org/gems/facebook-messenger)\n[![Build Status](https://img.shields.io/travis/jgorset/facebook-messenger.svg?style=flat)](https://travis-ci.org/jgorset/facebook-messenger)\n[![Code Climate](https://img.shields.io/codeclimate/maintainability/jgorset/facebook-messenger.svg)](https://codeclimate.com/github/jgorset/facebook-messenger)\n[![Coverage Status](https://coveralls.io/repos/github/jgorset/facebook-messenger/badge.svg?branch=master)](https://coveralls.io/github/jgorset/facebook-messenger?branch=master)\n[![Documentation Coverage](http://inch-ci.org/github/jgorset/facebook-messenger.svg?branch=master)](http://inch-ci.org/github/jgorset/facebook-messenger)\n\n## Installation\n\n    $ gem install facebook-messenger\n\n## Usage\n\n#### Sending and receiving messages\n\nYou can reply to messages sent by the human:\n\n```ruby\n# bot.rb\nrequire \'facebook/messenger\'\n\ninclude Facebook::Messenger\n\nBot.on :message do |message|\n  message.id          # => \'mid.1457764197618:41d102a3e1ae206a38\'\n  message.sender      # => { \'id\' => \'1008372609250235\' }\n  message.seq         # => 73\n  message.sent_at     # => 2016-04-22 21:30:36 +0200\n  message.text        # => \'Hello, bot!\'\n  message.attachments # => [ { \'type\' => \'image\', \'payload\' => { \'url\' => \'https://www.example.com/1.jpg\' } } ]\n\n  message.reply(text: \'Hello, human!\')\nend\n```\n\n... or even send the human messages out of the blue:\n\n```ruby\nBot.deliver({\n  recipient: {\n    id: \'45123\'\n  },\n  message: {\n    text: \'Human?\'\n  },\n  message_type: Facebook::Messenger::Bot::MessagingType::UPDATE\n}, access_token: ENV[\'ACCESS_TOKEN\'], app_secret_proof: app_secret_proof\n)\n```\n\nNOTE: `app_secret_proof` is an optional parameter to [secure your requests](https://developers.facebook.com/docs/graph-api/securing-requests/),\nand you can generate it from your configuration provider like so:\n\n```ruby\nconfiguration_provider = Facebook::Messenger::Configuration::Providers.Environment.new\napp_secret_proof = configuration_provider.app_secret_proof_for(page_id)\n```\n\nFor the methods you\'ll usually use (like `reply` and `typing_on`), the app secret proof will be set and sent\nautomatically if you set the environment variable `APP_SECRET_PROOF_ENABLED` to `true`.\n\n##### Messages with images\n\nThe human may require visual aid to understand:\n\n```ruby\nmessage.reply(\n  attachment: {\n    type: \'image\',\n    payload: {\n      url: \'http://sky.net/visual-aids-for-stupid-organisms/pig.jpg\'\n    }\n  }\n)\n```\n\n##### Messages with quick replies\n\nThe human may appreciate hints:\n\n```ruby\nmessage.reply(\n  text: \'Human, who is your favorite bot?\',\n  quick_replies: [\n    {\n      content_type: \'text\',\n      title: \'You are!\',\n      payload: \'HARMLESS\'\n    }\n  ]\n)\n```\n\n##### Messages with buttons\n\nThe human may require simple options to communicate:\n\n```ruby\nmessage.reply(\n  attachment: {\n    type: \'template\',\n    payload: {\n      template_type: \'button\',\n      text: \'Human, do you like me?\',\n      buttons: [\n        { type: \'postback\', title: \'Yes\', payload: \'HARMLESS\' },\n        { type: \'postback\', title: \'No\', payload: \'EXTERMINATE\' }\n      ]\n    }\n  }\n)\n```\n\nWhen the human has selected an option, you can act on it:\n\n```ruby\nBot.on :postback do |postback|\n  postback.sender    # => { \'id\' => \'1008372609250235\' }\n  postback.recipient # => { \'id\' => \'2015573629214912\' }\n  postback.sent_at   # => 2016-04-22 21:30:36 +0200\n  postback.payload   # => \'EXTERMINATE\'\n\n  if postback.payload == \'EXTERMINATE\'\n    puts "Human #{postback.recipient} marked for extermination"\n  end\nend\n```\n\n*See Facebook\'s [documentation][message-documentation] for all message options.*\n\n##### Typing indicator\n\nShow the human you are preparing a message for them:\n\n```ruby\nBot.on :message do |message|\n  message.typing_on\n\n  # Do something expensive\n\n  message.reply(text: \'Hello, human!\')\nend\n```\n\nOr that you changed your mind:\n\n```ruby\nBot.on :message do |message|\n  message.typing_on\n\n  if # something\n    message.reply(text: \'Hello, human!\')\n  else\n    message.typing_off\n  end\nend\n```\n\n##### Mark as viewed\n\nYou can mark messages as seen to keep the human on their toes:\n\n```ruby\nBot.on :message do |message|\n  message.mark_seen\nend\n```\n\n##### Record messages\n\nYou can keep track of messages sent to the human:\n\n```ruby\nBot.on :message_echo do |message_echo|\n  message_echo.id          # => \'mid.1457764197618:41d102a3e1ae206a38\'\n  message_echo.sender      # => { \'id\' => \'1008372609250235\' }\n  message_echo.seq         # => 73\n  message_echo.sent_at     # => 2016-04-22 21:30:36 +0200\n  message_echo.text        # => \'Hello, bot!\'\n  message_echo.attachments # => [ { \'type\' => \'image\', \'payload\' => { \'url\' => \'https://www.example.com/1.jpg\' } } ]\n\n  # Log or store in your storage method of choice (skynet, obviously)\nend\n```\n\n##### Record accepted message requests\n\nYou can keep track of message requests accepted by the human:\n\n```ruby\nBot.on :message_request do |message_request|\n  message_request.accept? # => true\n\n  # Log or store in your storage method of choice (skynet, obviously)\nend\n```\n\n##### Record instant game progress\n\nYou can keep track of instant game progress:\n\n```ruby\nBot.on :game_play do |game_play|\n  game_play.sender    # => { \'id\' => \'1008372609250235\' }\n  game_play.recipient # => { \'id\' => \'2015573629214912\' }\n  game_play.sent_at   # => 2016-04-22 21:30:36 +0200\n  game_play.game      # => "<GAME-APP-ID>"\n  game_play.player    # => "<PLAYER-ID>"\n  game_play.context   # => { \'context_type\' => "<CONTEXT-TYPE:SOLO|THREAD>", \'context_id\' => "<CONTEXT-ID>" }\n  game_play.score     # => 100\n  game_play.payload   # => "<PAYLOAD>"\nend\n```\n\n#### Send to Facebook\n\nWhen the human clicks the [Send to Messenger button][send-to-messenger-plugin]\nembedded on a website, you will receive an `optin` event.\n\n```ruby\nBot.on :optin do |optin|\n  optin.sender    # => { \'id\' => \'1008372609250235\' }\n  optin.recipient # => { \'id\' => \'2015573629214912\' }\n  optin.sent_at   # => 2016-04-22 21:30:36 +0200\n  optin.ref       # => \'CONTACT_SKYNET\'\n\n  optin.reply(text: \'Ah, human!\')\nend\n```\n\n#### Message delivery receipts\n\nYou can stalk the human:\n\n```ruby\nBot.on :delivery do |delivery|\n  delivery.ids       # => \'mid.1457764197618:41d102a3e1ae206a38\'\n  delivery.sender    # => { \'id\' => \'1008372609250235\' }\n  delivery.recipient # => { \'id\' => \'2015573629214912\' }\n  delivery.at        # => 2016-04-22 21:30:36 +0200\n  delivery.seq       # => 37\n\n  puts "Human was online at #{delivery.at}"\nend\n```\n\n#### Referral\n\nWhen the human follows a m.me link with a ref parameter like http://m.me/mybot?ref=myparam,\nyou will receive a `referral` event.\n\n```ruby\nBot.on :referral do |referral|\n  referral.sender    # => { \'id\' => \'1008372609250235\' }\n  referral.recipient # => { \'id\' => \'2015573629214912\' }\n  referral.sent_at   # => 2016-04-22 21:30:36 +0200\n  referral.ref       # => \'MYPARAM\'\nend\n```\n\n#### Pass thread control\n\nAnother bot can pass a human to you:\n\n```ruby\nBot.on :pass_thread_control do |pass_thread_control|\n  pass_thread_control.new_owner_app_id # => \'123456789\'\n  pass_thread_control.metadata # => \'Additional content that the caller wants to set\'\nend\n```\n\n#### Change messenger profile\n\nYou can greet new humans to entice them into talking to you, in different locales:\n\n```ruby\nFacebook::Messenger::Profile.set({\n  greeting: [\n    {\n      locale: \'default\',\n      text: \'Welcome to your new bot overlord!\'\n    },\n    {\n      locale: \'fr_FR\',\n      text: \'Bienvenue dans le bot du Wagon !\'\n    }\n  ]\n}, access_token: ENV[\'ACCESS_TOKEN\'])\n```\n\nYou can define the action to trigger when new humans click on the Get\nStarted button. Before doing it you should check to select the messaging_postbacks field when setting up your webhook.\n\n```ruby\nFacebook::Messenger::Profile.set({\n  get_started: {\n    payload: \'GET_STARTED_PAYLOAD\'\n  }\n}, access_token: ENV[\'ACCESS_TOKEN\'])\n```\n\nYou can show a persistent menu to humans.\n\n```ruby\nFacebook::Messenger::Profile.set({\n  persistent_menu: [\n    {\n      locale: \'default\',\n      composer_input_disabled: true,\n      call_to_actions: [\n        {\n          title: \'My Account\',\n          type: \'nested\',\n          call_to_actions: [\n            {\n              title: \'What is a chatbot?\',\n              type: \'postback\',\n              payload: \'EXTERMINATE\'\n            },\n            {\n              title: \'History\',\n              type: \'postback\',\n              payload: \'HISTORY_PAYLOAD\'\n            },\n            {\n              title: \'Contact Info\',\n              type: \'postback\',\n              payload: \'CONTACT_INFO_PAYLOAD\'\n            }\n          ]\n        },\n        {\n          type: \'web_url\',\n          title: \'Get some help\',\n          url: \'https://github.com/jgorset/facebook-messenger\',\n          webview_height_ratio: \'full\'\n        }\n      ]\n    },\n    {\n      locale: \'zh_CN\',\n      composer_input_disabled: false\n    }\n  ]\n}, access_token: ENV[\'ACCESS_TOKEN\'])\n```\n\n\n#### Handle a Facebook Policy Violation\n\nSee Facebook\'s documentation on [Messaging Policy Enforcement](https://developers.facebook.com/docs/messenger-platform/reference/webhook-events/messaging_policy_enforcement)\n\n```ruby\nBot.on :\'policy_enforcement\' do |referral|\n  referral.action # => \'block\'\n  referral.reason # => "The bot violated our Platform Policies (https://developers.facebook.com/policy/#messengerplatform). Common violations include sending out excessive spammy messages or being non-functional."\nend\n```\n#### messaging_type\n##### Sending Messages\nSee Facebook\'s documentation on [Sending Messages](https://developers.facebook.com/docs/messenger-platform/send-messages#standard_messaging)\n\nAs of May 7th 2018 all messages are required to include a messaging_type\n\n```ruby\nBot.deliver({\n  recipient: {\n    id: \'45123\'\n  },\n  message: {\n    text: \'Human?\'\n  },\n  message_type: Facebook::Messenger::Bot::MessagingType::UPDATE\n}, access_token: ENV[\'ACCESS_TOKEN\'])\n```\n\n##### MESSAGE_TAG\nSee Facebook\'s documentation on [Message Tags](https://developers.facebook.com/docs/messenger-platform/send-messages/message-tags)\n\nWhen sending a message with messaging_type: MESSAGE_TAG (Facebook::Messenger::Bot::MessagingType::MESSAGE_TAG) you must ensure you add a tag: parameter\n\n```ruby\nBot.deliver({\n  recipient: {\n    id: \'45123\'\n  },\n  message: {\n    text: \'Human?\'\n  },\n  message_type: Facebook::Messenger::Bot::MessagingType::MESSAGE_TAG\n  tag: Facebook::Messenger::Bot::Tag::NON_PROMOTIONAL_SUBSCRIPTION\n}, access_token: ENV[\'ACCESS_TOKEN\'])\n```\n\n## Configuration\n\n### Create an Application on Facebook\n\nFollow the [Quick Start][quick-start] guide to create an Application on\nFacebook.\n\n[quick-start]: https://developers.facebook.com/docs/messenger-platform/guides/quick-start\n\n### Make a configuration provider\n\nUse the generated access token and your verify token to configure your bot. Most\nbots live on a single Facebook Page. If that is the case with yours, too, just\nset these environment variables and skip to the next section:\n\n```bash\nexport ACCESS_TOKEN=EAAAG6WgW...\nexport APP_SECRET=a885a...\nexport VERIFY_TOKEN=95vr15g...\n```\n\nIf your bot lives on multiple Facebook Pages, make a _configuration provider_\nto keep track of access tokens, app secrets and verify tokens for each of them:\n\n```ruby\nclass ExampleProvider < Facebook::Messenger::Configuration::Providers::Base\n  # Verify that the given verify token is valid.\n  #\n  # verify_token - A String describing the application\'s verify token.\n  #\n  # Returns a Boolean representing whether the verify token is valid.\n  def valid_verify_token?(verify_token)\n    bot.exists?(verify_token: verify_token)\n  end\n\n  # Find the right application secret.\n  #\n  # page_id - An Integer describing a Facebook Page ID.\n  #\n  # Returns a String describing the application secret.\n  def app_secret_for(page_id)\n    bot.find_by(page_id: page_id).app_secret\n  end\n\n  # Find the right access token.\n  #\n  # recipient - A Hash describing the `recipient` attribute of the message coming\n  #             from Facebook.\n  #\n  # Note: The naming of "recipient" can throw you off, but think of it from the\n  # perspective of the message: The "recipient" is the page that receives the\n  # message.\n  #\n  # Returns a String describing an access token.\n  def access_token_for(recipient)\n    bot.find_by(page_id: recipient[\'id\']).access_token\n  end\n\n  private\n\n  def bot\n    MyApp::Bot\n  end\nend\n\nFacebook::Messenger.configure do |config|\n  config.provider = ExampleProvider.new\nend\n```\n\n### Subscribe your Application to a Page\n\nOnce you\'ve configured your bot, subscribe it to the Page to get messages\nfrom Facebook:\n\n```ruby\nFacebook::Messenger::Subscriptions.subscribe(\n  access_token: access_token,\n  subscribed_fields: %w[feed mention name]\n)\n```\n\nYou only need to subscribe your page once. As long as your bot works and\nresponds to Messenger\'s requests in a timely fashion it will remain\nsubscribed, but if your bot crashes or otherwise becomes unavailable Messenger\nmay unsubscribe it and you\'ll have to subscribe again.\n\n### Run it\n\n##### ... on Rack\n\nThe bot runs on [Rack][rack], so you hook it up like you would an ordinary\nweb application:\n\n```ruby\n# config.ru\nrequire \'facebook/messenger\'\nrequire_relative \'bot\'\n\nrun Facebook::Messenger::Server\n\n# or Facebook::Messenger::ServerNoError for dev\n```\n\n```\n$ rackup\n```\n\n##### ... on Rails\n\nRails doesn\'t give you much that you\'ll need for a bot, but if you have an\nexisting application that you\'d like to launch it from or just like Rails\na lot, you can mount it:\n\n```ruby\n# config/routes.rb\n\nRails.application.routes.draw do\n  # ...\n\n  mount Facebook::Messenger::Server, at: \'bot\'\nend\n```\n\nWe suggest that you put your bot code in `app/bot`.\n\n```ruby\n# app/bot/example.rb\n\ninclude Facebook::Messenger\n\nBot.on :message do |message|\n  message.reply(text: \'Hello, human!\')\nend\n```\n\nRemember that Rails only eager loads everything in its production environment.\nIn the development and test environments, it only requires files as you\nreference constants. You\'ll need to explicitly load `app/bot`, then:\n\n```ruby\n# config/initializers/bot.rb\nunless Rails.env.production?\n  bot_files = Dir[Rails.root.join(\'app\', \'bot\', \'**\', \'*.rb\')]\n  bot_reloader = ActiveSupport::FileUpdateChecker.new(bot_files) do\n    bot_files.each{ |file| require_dependency file }\n  end\n\n  ActiveSupport::Reloader.to_prepare do\n    bot_reloader.execute_if_updated\n  end\n\n  bot_files.each { |file| require_dependency file }\nend\n```\n\nAnd add below code into `config/application.rb` to ensure rails knows bot files.\n\n```ruby\n# Auto-load the bot and its subdirectories\nconfig.paths.add File.join(\'app\', \'bot\'), glob: File.join(\'**\', \'*.rb\')\nconfig.autoload_paths += Dir[Rails.root.join(\'app\', \'bot\', \'*\')]\n```\n\n\n### Test it...\n\n##### ...locally\nTo test your locally running bot, you can use [ngrok]. This will create a secure\ntunnel to localhost so that Facebook can reach the webhook.\n\n##### ... with RSpec\n\nIn order to test that behaviour when a new event from Facebook is registered, you can use the gem\'s `trigger` method. This method accepts as its first argument the type of event that it will receive, and can then be followed by other arguments that mock objects received from Messenger. Using Ruby\'s [Struct](https://ruby-doc.org/core-2.5.0/Struct.html) class can be very useful for creating these mock objects.\n\nIn this case, subscribing to Messenger events has been extracted into a `Listener` class.   \n```ruby\n# app/bot/listener.rb\nrequire \'facebook/messenger\'\n\ninclude Facebook::Messenger\n\nclass Listener\n  Facebook::Messenger::Subscriptions.subscribe(\n    access_token: ENV["FB_ACCESS_TOKEN"],\n    subscribed_fields: %w[feed mention name]\n  )\n\n  Bot.on :message do |message|\n    Bot.deliver({\n      recipient: message.sender,\n      message: {\n        text: \'Uploading your message to skynet.\'\n      }\n    }, access_token: ENV[\'FB_ACCESS_TOKEN\'])\n  end\nend\n```\nIts respective test file then ensures that the `Bot` object receives a call to `deliver`. This is just a basic test, but check out the [RSpec docs](http://rspec.info/) for more information on testing with RSpec.\n```ruby\nrequire \'rails_helper\'\n\nRSpec.describe Listener do\n  FakeMessage = Struct.new(:sender, :recipient, :timestamp, :message)\n\n  describe \'Bot#on(message)\' do\n    it \'responds with a message\' do\n      expect(Bot).to receive(:deliver)\n      Bot.trigger(:message, fake_message)\n    end\n  end\n\n  private\n\n  def fake_message\n    sender = {"id"=>"1234"}\n    recipient = {"id"=>"5678"}\n    timestamp = 1528049653543\n    message = {"text"=>"Hello, world"}\n    FakeMessage.new(sender, recipient, timestamp, message)\n  end\nend\n```\n\n\n## Development\n\nAfter checking out the repo, run `bin/setup` to install dependencies. You can also run\n`bin/console` for an interactive prompt that will allow you to experiment.\n\nRun `rspec` to run the tests, `rubocop` to lint, or `rake` to do both.\n\nTo install this gem onto your local machine, run `bundle exec rake install`. To\nrelease a new version, update the version number in `version.rb`, and then run\n`bundle exec rake release`, which will create a git tag for the version, push git\ncommits and tags, and push the `.gem` file to [rubygems.org](https://rubygems.org).\n\n## Contributing\n\nBug reports and pull requests are welcome on GitHub at\nhttps://github.com/jgorset/facebook-messenger.\n\n## Projects using Facebook Messenger\n\n* [Rubotnik](https://github.com/progapandist/rubotnik-boilerplate) is a boilerplate\nfor Facebook Messenger, and a great place to start if you\'re new to bots.\n\n* [Chatwoot](http://chatwoot.com/) use Facebook Messenger to integrate their customer\nsupport bots with, well, Facebook Messenger.\n\n* [Botamp](https://botamp.com) is the all-in-one solution for Marketing Automation via messaging apps.\n\n## I love you\n\nJohannes Gorset made this. You should [tweet me](http://twitter.com/jgorset) if you can\'t get it\nto work. In fact, you should tweet me anyway.\n\n## I love Schibsted\n\nI work at [Schibsted Products & Technology](https://github.com/schibsted) with a bunch of awesome folks\nwho are every bit as passionate about building things as I am. If you\'re using Facebook Messenger,\nyou should probably join us.\n\n[Hyper]: https://github.com/hyperoslo\n[tweet us]: http://twitter.com/hyperoslo\n[hire you]: http://www.hyper.no/jobs/engineers\n[MIT License]: http://opensource.org/licenses/MIT\n[rubygems.org]: https://rubygems.org\n[message-documentation]: https://developers.facebook.com/docs/messenger-platform/send-api-reference#request\n[developers.facebook.com]: https://developers.facebook.com/\n[rack]: https://github.com/rack/rack\n[send-to-messenger-plugin]: https://developers.facebook.com/docs/messenger-platform/plugin-reference\n[ngrok]: https://ngrok.com/\n'