b'==================================================\ngit-imerge -- incremental merge and rebase for git\n==================================================\n\nPerform a merge between two branches incrementally.  If conflicts are\nencountered, figure out exactly which pairs of commits conflict, and\npresent the user with one pairwise conflict at a time for resolution.\n\n``git-imerge`` has two primary design goals:\n\n* Reduce the pain of resolving merge conflicts to its unavoidable\n  minimum, by finding and presenting the smallest possible conflicts:\n  those between the changes introduced by one commit from each branch.\n\n* Allow a merge to be saved, tested, interrupted, published, and\n  collaborated on while it is in progress.\n\nI think that it is easiest to understand the concept of incremental\nmerging visually, and therefore I recommend the video of my\n`git-imerge presentation from the GitMerge 2013 conference`_ (20 min)\nas a good place to start.  The full slides for that talk are available\nin this repository under ``doc/presentations/GitMerge-2013``.  At the\nsame conference, I was interviewed about ``git-imerge`` by Thomas\nFerris Nicolaisen for his `GitMinutes Podcast #12`_.\n\n.. _`git-imerge presentation from the GitMerge 2013 conference`:\n   http://www.youtube.com/watch?v=FMZ2_-Ny_zc\n\n.. _`GitMinutes Podcast #12`:\n   http://episodes.gitminutes.com/2013/06/gitminutes-12-git-merge-2013-part-4.html\n\nTo learn how to use the ``git-imerge`` tool itself, I suggest the blog\narticle `git-imerge: A Practical Introduction`_ and also typing\n``git-imerge --help`` and ``git-imerge SUBCOMMAND --help``.  If you\nwant more information, the theory and benefits of incremental merging\nare described in minute detail in a series of blog articles [1]_, as\nare the benefits of retaining history when doing a rebase [2]_.\n\n.. _`git-imerge: A Practical Introduction`:\n   http://softwareswirl.blogspot.com/2013/05/git-imerge-practical-introduction.html\n\nMultiple incremental merges can be in progress at the same time.  Each\nincremental merge has a name, and its progress is recorded in the Git\nrepository as references under ``refs/imerge/NAME``.  The current\nstate of an incremental merge can be visualized using the ``diagram``\ncommand.\n\nAn incremental merge can be interrupted and resumed arbitrarily, or\neven pushed to a server to allow somebody else to work on it.\n\n``git-imerge`` comes with a Bash completion script. It can be installed\nby copying ``git-imerge.bashcomplete`` to the place where usually completion\nscripts are installed on your system, e.g. /etc/bash_completion.d/.\n\n\nRequirements\n============\n\n``git-imerge`` requires:\n\n* A Python interpreter; either\n\n  * Python 2.x, version 2.6 or later.  If you are using Python\n    2.6.x, then you have to install the ``argparse`` module yourself,\n    as it was only added to the standard library in Python 2.7.\n\n  * Python 3.x, version 3.3 or later.\n\n  The script tries to use a Python interpreter called ``python`` in\n  your ``PATH``.  If your Python interpreter has a different name or\n  is not in your ``PATH``, please adjust the first line of the script\n  accordingly.\n\n* A recent version of Git.\n\nBash completion requires Git\'s completion being available.\n\n\nInstructions\n============\n\nTo start a merge or rebase operation using ``git-imerge``, you use\ncommands that are similar to the corresponding ``git`` commands:\n\n.. list-table:: Starting an incremental merge or rebase\n   :header-rows: 1\n\n   * - ``git-imerge`` command\n     - ``git`` analogue\n     - Effect\n   * - ``git-imerge merge BRANCH``\n     - ``git merge BRANCH``\n     - Merge ``BRANCH`` into the current branch.\n   * - ``git-imerge rebase BRANCH``\n     - ``git rebase BRANCH``\n     - Rebase the current branch on top of ``BRANCH``\n   * - ``git-imerge revert COMMIT``\n     - ``git revert COMMIT``\n     - Add a new commit that undoes the effect of ``COMMIT``\n   * - ``git-imerge revert COMMIT1..COMMIT2``\n     - ``git revert COMMIT1..COMMIT2``\n     - Add new commits that undo the effects of ``COMMIT1..COMMIT2``\n   * - ``git-imerge drop COMMIT``\n     - ``git rebase --onto COMMIT^ COMMIT``\n     - Entirely delete commit ``COMMIT`` from the history of the\n       current branch\n   * - ``git-imerge drop COMMIT1..COMMIT2``\n     - ``git rebase --onto COMMIT1 COMMIT2``\n     - Entirely delete commits ``COMMIT1..COMMIT2`` from the history\n       of the current branch\n\n(``git-imerge drop`` is also analogous to running ``git rebase\n--interactive``, then deleting the specified commit(s) from the\nhistory. Both the ``drop`` and the ``revert`` subcommands are included\nin git-imerge because the equivalent git operations can conflict,\nso they both can benefit from using the incremental merge approach.)\n\nA few more options are available if you start the incremental merge\nusing ``git imerge start``::\n\n    git-imerge start --name=NAME --goal=GOAL [--first-parent] BRANCH\n\nwhere\n\n``NAME``\n    is the name for this merge (and also the default name of the\n    branch to which the results will be saved).\n\n``GOAL``\n    describes how you want to simplify the results (see next\n    section).\n\nAfter the incremental merge is started, you will be presented with any\nconflicts that have to be resolved.  The basic procedure is similar\nto performing an incremental merge using ``git``::\n\n    while not done:\n        <fix the conflict that is presented to you>\n        <"git add" the files that you changed>\n        git-imerge continue\n\nWhen you have resolved all of the conflicts, you finish the\nincremental merge by typing::\n\n    git-imerge finish\n\nThat should be enough to get you going.  All of these subcommands have\nadditional options; to learn about them type::\n\n    git-imerge --help\n    git-imerge SUBCMD --help\n\n\nSimplifying results\n-------------------\n\nWhen the incremental merge is finished, you can simplify its results\nin various ways before recording it in your project\'s permanent\nhistory by using either the ``finish`` or ``simplify`` command.  The\n"goal" of the incremental merge can be one of the following:\n\n``merge``\n    keep only a simple merge of the second branch into the first\n    branch, discarding all intermediate merges.  The end result is\n    similar to what you would get from ::\n\n        git checkout BRANCH1\n        git merge BRANCH2\n\n``rebase``\n    keep the versions of the commits from the second branch rebased\n    onto the first branch.  The end result is similar to what you\n    would get from ::\n\n        git checkout BRANCH2\n        git rebase BRANCH1\n\n``rebase-with-history``\n    like ``rebase``, except that it retains the old versions of the\n    rebased commits in the history.  It is equivalent to merging the\n    commits from ``BRANCH2`` into ``BRANCH1``, one commit at a\n    time. In other words, it transforms this::\n\n        o---o---o---o          BRANCH1\n             \\\n              A---B---C---D    BRANCH2\n\n    into this::\n\n        o---o---o---o---A\'--B\'--C\'--D\'   NEW_BRANCH\n             \\         /   /   /   /\n              --------A---B---C---D\n\n    It is safe to rebase an already-published branch using this\n    approach.  See [2]_ for more information.\n\n``full``\n\n    don\'t simplify the incremental merge at all: do all of the\n    intermediate merges and retain them all in the permanent history.\n    In other words, it transforms this::\n\n        o---o---1---2---3      BRANCH1\n             \\\n              A---B---C---D    BRANCH2\n\n    into this::\n\n        o---o---1---2---3\n             \\   \\   \\   \\\n              A---A1--A2--A3\n               \\   \\   \\   \\\n                B---B1--B2--B3\n                 \\   \\   \\   \\\n                  C---C1--C2--C3\n                   \\   \\   \\   \\\n                    D---D1--D2--D3    NEW_BRANCH\n\n    This approach retains the complete history and ancestry\n    information, which gives the maximum flexibility for conducting\n    future merges. On the other hand, it clutters up the permanent Git\n    history considerably.\n\n``border``\n    this experimental goal retains the rebase of ``BRANCH2`` onto\n    ``BRANCH1`` and also the rebase of ``BRANCH1`` onto ``BRANCH2``,\n    plus a merge commit that includes both branches. In other words,\n    it transforms this::\n\n        o---o---1---2---3      BRANCH1\n             \\\n              A---B---C---D    BRANCH2\n\n    into this::\n\n        o---o---1---2---3\n             \\           \\\n              A           A2\n               \\           \\\n                B           B2\n                 \\           \\\n                  C           C2\n                   \\           \\\n                    D---D1--D2--D3    NEW_BRANCH\n\n    This approach leaves more history than a simple merge or rebase,\n    possibly making future merges easier.\n\n``border-with-history``\n    this experimental goal retains the rebase-with-history of\n    ``BRANCH2`` onto ``BRANCH1`` and also the rebase (without history)\n    of ``BRANCH1`` onto ``BRANCH2``, plus a merge commit that includes\n    both branches. In other words, it transforms this::\n\n        o---o---1---2---3      BRANCH1\n             \\\n              A---B---C---D    BRANCH2\n\n    into this::\n\n        o---o---1---2---3\n             \\           \\\n              A-----------A3\n               \\           \\\n                B-----------B3\n                 \\           \\\n                  C-----------C3\n                   \\           \\\n                    D---D1--D2--D3    NEW_BRANCH\n\n    This approach leaves more history and ancestry information than a\n    simple merge or rebase, possibly making future merges easier.\n\n``border-with-history2``\n    this experimental goal retains the rebase-with-history of\n    ``BRANCH1`` onto ``BRANCH2`` and also the rebase-with-history of\n    ``BRANCH2`` onto ``BRANCH1``, plus a merge commit that includes\n    both branches. In other words, it transforms this::\n\n        o---o---1---2---3      BRANCH1\n             \\\n              A---B---C---D    BRANCH2\n\n    into this::\n\n        o---o---1---2---3\n             \\   \\   \\   \\\n              A--- --- ---A3\n               \\   \\   \\   \\\n                B--- --- ---B3\n                 \\   \\   \\   \\\n                  C--- --- ---C3\n                   \\   \\   \\   \\\n                    D---D1--D2--D3    NEW_BRANCH\n\n    This approach leaves more history and ancestry information than a\n    simple merge or rebase, possibly making future merges easier.\n\n\nTechnical notes\n===============\n\nSuspending/resuming\n-------------------\n\nWhen ``git-imerge`` needs to ask the user to do a merge manually, it\ncreates a temporary branch ``refs/heads/imerge/NAME`` to hold the\nresult. If you want to suspend an incremental merge to do something\nelse before continuing, all you need to do is abort any pending merge\nusing ``git merge --abort`` and switch to your other branch. When you\nare ready to resume the incremental merge, just type ``git imerge\ncontinue``.\n\nIf you need to completely abort an in-progress incremental merge,\nfirst remove the temporary branches ``git-imerge`` creates using\n``git-imerge remove``, then checkout the branch you were in before you\nstarted the incremental merge with ``git checkout ORIGINAL_BRANCH``.\n\n\nStorage\n-------\n\n``git-imerge`` records all of the intermediate state about an\nincremental merge in the Git object database as a bunch of references\nunder ``refs/imerge/NAME``, where ``NAME`` is the name of the imerge:\n\n* ``refs/imerge/NAME/state`` points to a blob that describes the\n  current state of the imerge in JSON format; for example,\n\n  * The tips of the two branches that are being merged\n\n  * The current "blocker" merges (merges that the user will have to do\n    by hand), if any\n\n  * The simplification goal\n\n  * The name of the branch to which the result will be written.\n\n* ``refs/imerge/NAME/manual/I-J`` and ``refs/imerge/NAME/auto/I-J``\n  refer to the manual and automatic merge commits, respectively, that\n  have been done so far as part of the incremental merge. ``I`` and\n  ``J`` are integers indicating the location ``(I,J)`` of the merge in\n  the incremental merge diagram.\n\n\nTransferring an in-progress imerge between repositories\n-------------------------------------------------------\n\nIt might sometimes be convenient to transfer an in-progress\nincremental merge from one Git repository to another. For example, you\nmight want to make a backup of the current state, or continue an\nimerge at home that you started at work, or ask a colleague to do a\nparticular pairwise merge for you. Since all of the imerge state is\nstored in the Git object database, this can be done by\npushing/fetching the references named in the previous section. For\nexample, ::\n\n    git push --prune origin +refs/imerge/NAME/*:refs/imerge/NAME/*\n\nor ::\n\n    git fetch --prune origin +refs/imerge/NAME/*:refs/imerge/NAME/*\n\nPlease note that these commands *overwrite* any state that already\nexisted in the destination repository. There is currently no support\nfor combining the work done by two people in parallel on an\nincremental merge, so for now you\'ll just have to take turns.\n\n\nInteraction with ``git rerere``\n-------------------------------\n\n``git rerere`` is a nice tool that records how you resolve merge\nconflicts, and if it sees the same conflict again it tries to\nautomatically reuse the same resolution.\n\nSince ``git-imerge`` attempts so many similar test merges, it is easy\nto imagine ``rerere`` getting confused. Moreover, ``git-imerge``\nrelies on a merge resolving (or not resolving) consistently if it is\ncarried out more than once. Having ``rerere`` store extra information\nbehind the scenes could therefore confuse ``git-imerge``.\n\nIndeed, in testing it appeared that during incremental merges, the\ninteraction of ``git-imerge`` with ``rerere`` was sometimes causing\nmerge conflicts to be resolved incorrectly. Therefore, ``git-imerge``\nexplicitly turns rerere off temporarily whenever it invokes git.\n\n\nLog messages for pairwise merge commits\n---------------------------------------\n\nWhen ``git imerge continue`` or ``git imerge record`` finds a resolved\nmerge in the working tree, it commits that merge then incorporates it\ninto the incremental merge. Usually it just uses Git\'s autogenerated\ncommit message for such commits. If you want to be prompted to edit\nsuch commit messages, you can either specify ``--edit`` on the command\nline or change the default in your configuration::\n\n    git config --global imerge.editmergemessages true\n\n\nLicense\n=======\n\n``git-imerge`` is released as open-source software under the GNU\nGeneral Public License (GPL), version 2 or later. See file ``COPYING``\nfor more information.\n\n\nReferences\n==========\n\n.. [1]\n   * http://softwareswirl.blogspot.com/2012/12/the-conflict-frontier-of-nightmare-merge.html\n   * http://softwareswirl.blogspot.com/2012/12/mapping-merge-conflict-frontier.html\n   * http://softwareswirl.blogspot.com/2012/12/real-world-conflict-diagrams.html\n   * http://softwareswirl.blogspot.com/2013/05/git-incremental-merge.html\n   * http://softwareswirl.blogspot.com/2013/05/one-merge-to-rule-them-all.html\n   * http://softwareswirl.blogspot.com/2013/05/incremental-merge-vs-direct-merge-vs.html\n   * http://softwareswirl.blogspot.com/2013/05/git-imerge-practical-introduction.html\n\n.. [2]\n   * http://softwareswirl.blogspot.com/2009/04/truce-in-merge-vs-rebase-war.html\n   * http://softwareswirl.blogspot.com/2009/08/upstream-rebase-just-works-if-history.html\n   * http://softwareswirl.blogspot.com/2009/08/rebase-with-history-implementation.html\n\n\n'