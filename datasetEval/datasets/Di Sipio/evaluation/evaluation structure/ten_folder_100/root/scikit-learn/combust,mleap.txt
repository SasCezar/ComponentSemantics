b'<a href="http://mleap-docs.combust.ml"><img src="logo.png" alt="MLeap Logo" width="176" height="70" /></a>\n\n[![Gitter](https://badges.gitter.im/combust/mleap.svg)](https://gitter.im/combust/mleap?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\n[![Build Status](https://travis-ci.org/combust/mleap.svg?branch=master)](https://travis-ci.org/combust/mleap)\n[![Maven Central](https://maven-badges.herokuapp.com/maven-central/ml.combust.mleap/mleap-base_2.11/badge.svg)](https://maven-badges.herokuapp.com/maven-central/ml.combust.mleap/mleap-base_2.11)\n\nDeploying machine learning data pipelines and algorithms should not be a time-consuming or difficult task. MLeap allows data scientists and engineers to deploy machine learning pipelines from Spark and Scikit-learn to a portable format and execution engine.\n\n## Documentation\n\nDocumentation is available at [mleap-docs.combust.ml](http://mleap-docs.combust.ml).\n\nRead [Serializing a Spark ML Pipeline and Scoring with MLeap](https://github.com/combust-ml/mleap/wiki/Serializing-a-Spark-ML-Pipeline-and-Scoring-with-MLeap) to gain a full sense of what is possible.\n\n## Introduction\n\nUsing the MLeap execution engine and serialization format, we provide a performant, portable and easy-to-integrate production library for machine learning data pipelines and algorithms.\n\nFor portability, we build our software on the JVM and only use serialization formats that are widely-adopted.\n\nWe also provide a high level of integration with existing technologies.\n\nOur goals for this project are:\n\n1. Allow Researchers/Data Scientists and Engineers to continue to build data pipelines and train algorithms with Spark and Scikit-Learn\n2. Extend Spark/Scikit/TensorFlow by providing ML Pipelines serialization/deserialization to/from a common framework (Bundle.ML)\n3. Use MLeap Runtime to execute your pipeline and algorithm without dependenices on Spark or Scikit (numpy, pandas, etc)\n\n## Overview\n\n1. Core execution engine implemented in Scala\n2. [Spark](http://spark.apache.org/), PySpark and Scikit-Learn support\n3. Export a model with Scikit-learn or Spark and execute it using the MLeap Runtime (without dependencies on the Spark Context, or sklearn/numpy/pandas/etc)\n4. Choose from 2 portable serialization formats (JSON, Protobuf)\n5. Implement your own custom data types and transformers for use with MLeap data frames and transformer pipelines\n6. Extensive test coverage with full parity tests for Spark and MLeap pipelines\n7. Optional Spark transformer extension to extend Spark\'s default transformer offerings\n\n<img src="assets/images/single-runtime.jpg" alt="Unified Runtime"/>\n\n## Requirements\n\nMLeap is built against Scala 2.11 and Java 8.  Because we depend heavily on Typesafe config for MLeap, we only support Java 8 at the\nmoment.\n\n### MLeap/Spark Version\n\nChoose the right verison of the `mleap-spark` module to export your pipeline. The serialization format is backwards compatible between different versions of MLeap. So if you export a pipeline using MLeap 0.11.0 and Spark 2.1, you can still load that pipeline using MLeap runtime version 0.12.0.\n\n| MLeap Version | Spark Version |\n|---------------|---------------|\n| 0.15.0        | 2.4           |\n| 0.14.0        | 2.4           |\n| 0.13.0        | 2.3           |\n| 0.12.0        | 2.3           |\n| 0.11.0        | 2.2           |\n| 0.11.0        | 2.1           |\n| 0.11.0        | 2.0           |\n\n## Setup\n\n### Link with Maven or SBT\n\n#### SBT\n\n```sbt\nlibraryDependencies += "ml.combust.mleap" %% "mleap-runtime" % "0.15.0"\n```\n\n#### Maven\n\n```pom\n<dependency>\n    <groupId>ml.combust.mleap</groupId>\n    <artifactId>mleap-runtime_2.11</artifactId>\n    <version>0.15.0</version>\n</dependency>\n```\n\n### For Spark Integration\n\n#### SBT\n\n```sbt\nlibraryDependencies += "ml.combust.mleap" %% "mleap-spark" % "0.15.0"\n```\n\n#### Maven\n\n```pom\n<dependency>\n    <groupId>ml.combust.mleap</groupId>\n    <artifactId>mleap-spark_2.11</artifactId>\n    <version>0.15.0</version>\n</dependency>\n```\n\n### Spark Packages\n\n```bash\n$ bin/spark-shell --packages ml.combust.mleap:mleap-spark_2.11:0.15.0\n```\n\n### PySpark Integration\n\nInstall MLeap from [PyPI](https://pypi.org/project/mleap/)\n```bash\n$ pip install mleap\n```\n\n## Using the Library\n\nFor more complete examples, see our other Git repository: [MLeap Demos](https://github.com/combust/mleap-demo)\n\n### Create and Export a Spark Pipeline\n\nThe first step is to create our pipeline in Spark. For our example we will manually build a simple Spark ML pipeline.\n\n\n```scala\nimport ml.combust.bundle.BundleFile\nimport ml.combust.mleap.spark.SparkSupport._\nimport org.apache.spark.ml.Pipeline\nimport org.apache.spark.ml.bundle.SparkBundleContext\nimport org.apache.spark.ml.feature.{Binarizer, StringIndexer}\nimport org.apache.spark.sql._\nimport org.apache.spark.sql.functions._\nimport resource._\n\n  val datasetName = "./examples/spark-demo.csv"\n\n  val dataframe: DataFrame = spark.sqlContext.read.format("csv")\n    .option("header", true)\n    .load(datasetName)\n    .withColumn("test_double", col("test_double").cast("double"))\n\n  // User out-of-the-box Spark transformers like you normally would\n  val stringIndexer = new StringIndexer().\n    setInputCol("test_string").\n    setOutputCol("test_index")\n\n  val binarizer = new Binarizer().\n    setThreshold(0.5).\n    setInputCol("test_double").\n    setOutputCol("test_bin")\n\n  val pipelineEstimator = new Pipeline()\n    .setStages(Array(stringIndexer, binarizer))\n\n  val pipeline = pipelineEstimator.fit(dataframe)\n\n  // then serialize pipeline\n  val sbc = SparkBundleContext().withDataset(pipeline.transform(dataframe))\n  for(bf <- managed(BundleFile("jar:file:/tmp/simple-spark-pipeline.zip"))) {\n    pipeline.writeBundle.save(bf)(sbc).get\n  }\n```\n\nThe dataset used for training can be found [here](https://github.com/combust/mleap/tree/master/examples/spark-demo.csv)\n\nSpark pipelines are not meant to be run outside of Spark. They require a DataFrame and therefore a SparkContext to run. These are expensive data structures and libraries to include in a project. With MLeap, there is no dependency on Spark to execute a pipeline. MLeap dependencies are lightweight and we use fast data structures to execute your ML pipelines.\n\n### PySpark Integration\n\nImport the MLeap library in your PySpark job\n\n```python\nimport mleap.pyspark\nfrom mleap.pyspark.spark_support import SimpleSparkSerializer\n```\n\n### Create and Export a Scikit-Learn Pipeline\n\n```python\nimport pandas as pd\n\nfrom mleap.sklearn.pipeline import Pipeline\nfrom mleap.sklearn.preprocessing.data import FeatureExtractor, LabelEncoder, ReshapeArrayToN1\nfrom sklearn.preprocessing import OneHotEncoder\n\ndata = pd.DataFrame([\'a\', \'b\', \'c\'], columns=[\'col_a\'])\n\ncategorical_features = [\'col_a\']\n\nfeature_extractor_tf = FeatureExtractor(input_scalars=categorical_features, \n                                         output_vector=\'imputed_features\', \n                                         output_vector_items=categorical_features)\n\n# Label Encoder for x1 Label \nlabel_encoder_tf = LabelEncoder(input_features=feature_extractor_tf.output_vector_items,\n                               output_features=\'{}_label_le\'.format(categorical_features[0]))\n\n# Reshape the output of the LabelEncoder to N-by-1 array\nreshape_le_tf = ReshapeArrayToN1()\n\n# Vector Assembler for x1 One Hot Encoder\none_hot_encoder_tf = OneHotEncoder(sparse=False)\none_hot_encoder_tf.mlinit(prior_tf = label_encoder_tf, \n                          output_features = \'{}_label_one_hot_encoded\'.format(categorical_features[0]))\n\none_hot_encoder_pipeline_x0 = Pipeline([\n                                         (feature_extractor_tf.name, feature_extractor_tf),\n                                         (label_encoder_tf.name, label_encoder_tf),\n                                         (reshape_le_tf.name, reshape_le_tf),\n                                         (one_hot_encoder_tf.name, one_hot_encoder_tf)\n                                        ])\n\none_hot_encoder_pipeline_x0.mlinit()\none_hot_encoder_pipeline_x0.fit_transform(data)\none_hot_encoder_pipeline_x0.serialize_to_bundle(\'/tmp\', \'mleap-scikit-test-pipeline\', init=True)\n\n# array([[ 1.,  0.,  0.],\n#        [ 0.,  1.,  0.],\n#        [ 0.,  0.,  1.]])\n```\n\n### Load and Transform Using MLeap\n\nBecause we export Spark and Scikit-learn pipelines to a standard format, we can use either our Spark-trained pipeline or our Scikit-learn pipeline from the previous steps to demonstrate usage of MLeap in this section. The choice is yours!\n\n```scala\nimport ml.combust.bundle.BundleFile\nimport ml.combust.mleap.runtime.MleapSupport._\nimport resource._\n// load the Spark pipeline we saved in the previous section\nval bundle = (for(bundleFile <- managed(BundleFile("jar:file:/tmp/simple-spark-pipeline.zip"))) yield {\n  bundleFile.loadMleapBundle().get\n}).opt.get\n\n// create a simple LeapFrame to transform\nimport ml.combust.mleap.runtime.frame.{DefaultLeapFrame, Row}\nimport ml.combust.mleap.core.types._\n\n// MLeap makes extensive use of monadic types like Try\nval schema = StructType(StructField("test_string", ScalarType.String),\n  StructField("test_double", ScalarType.Double)).get\nval data = Seq(Row("hello", 0.6), Row("MLeap", 0.2))\nval frame = DefaultLeapFrame(schema, data)\n\n// transform the dataframe using our pipeline\nval mleapPipeline = bundle.root\nval frame2 = mleapPipeline.transform(frame).get\nval data2 = frame2.dataset\n\n// get data from the transformed rows and make some assertions\nassert(data2(0).getDouble(2) == 1.0) // string indexer output\nassert(data2(0).getDouble(3) == 1.0) // binarizer output\n\n// the second row\nassert(data2(1).getDouble(2) == 2.0)\nassert(data2(1).getDouble(3) == 0.0)\n```\n\n## Documentation\n\nFor more documentation, please see our [documentation](http://mleap-docs.combust.ml), where you can learn to:\n\n1. Implement custom transformers that will work with Spark, MLeap and Scikit-learn\n2. Implement custom data types to transform with Spark and MLeap pipelines\n3. Transform with blazing fast speeds using optimized row-based transformers\n4. Serialize MLeap data frames to various formats like avro, json, and a custom binary format\n5. Implement new serialization formats for MLeap data frames\n6. Work through several demonstration pipelines which use real-world data to create predictive pipelines\n7. Supported Spark transformers\n8. Supported Scikit-learn transformers\n9. Custom transformers provided by MLeap\n\n## Contributing\n\n* Write documentation.\n* Write a tutorial/walkthrough for an interesting ML problem\n* Contribute an Estimator/Transformer from Spark\n* Use MLeap at your company and tell us what you think\n* Make a feature request or report a bug in github\n* Make a pull request for an existing feature request or bug report\n* Join the discussion of how to get MLeap into Spark as a dependency. Talk with us on Gitter (see link at top of README.md)\n\n## Thank You\n\nThank you to [Swoop](https://www.swoop.com/) for supporting the XGboost\nintegration.\n\n## Contact Information\n\n* Hollin Wilkins (hollin@combust.ml)\n* Mikhail Semeniuk (mikhail@combust.ml)\n* Anca Sarb (sarb.anca@gmail.com)\n\n## License\n\nSee LICENSE and NOTICE file in this repository.\n\nCopyright 2016 Combust, Inc.\n\nLicensed under the Apache License, Version 2.0 (the "License");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'