b'# tiptap\nA renderless and extendable rich-text editor for [Vue.js](https://github.com/vuejs/vue)\n\n[![](https://img.shields.io/npm/v/tiptap.svg?label=version)](https://www.npmjs.com/package/tiptap)\n[![](https://img.shields.io/npm/dm/tiptap.svg)](https://npmcharts.com/compare/tiptap?minimal=true)\n[![](https://img.shields.io/npm/l/tiptap.svg)](https://www.npmjs.com/package/tiptap)\n[![](https://img.badgesize.io/https://unpkg.com/tiptap/dist/tiptap.min.js?compression=gzip&label=size&colorB=000000)](https://www.npmjs.com/package/tiptap)\n[![Build Status](https://travis-ci.org/scrumpy/tiptap.svg?branch=master)](https://travis-ci.org/scrumpy/tiptap)\n\n## Why I built tiptap\nI was looking for a text editor for [Vue.js](https://github.com/vuejs/vue) and found some solutions that didn\'t really satisfy me. The editor should be easy to extend and not based on old dependencies such as jQuery. For React there is already a great editor called [Slate.js](https://github.com/ianstormtaylor/slate), which impresses with its modularity. I came across [Prosemirror](https://github.com/prosemirror) and decided to build on it. Prosemirror is a toolkit for building rich-text editors that are already in use at many well-known companies such as *Atlassian* or *New York Times*.\n\n### What does `renderless` mean?\n\nWith renderless components you\'ll have (almost) full control over markup and styling. I don\'t want to tell you what a menu should look like or where it should be rendered in the DOM. That\'s all up to you. There is also a [good article](https://adamwathan.me/renderless-components-in-vuejs/) about renderless components by Adam Wathan.\n\n### How is the data stored under the hood?\n\nYou can save your data as a raw `HTML` string or can get a `JSON`-serializable representation of your document. And of course, you can pass these two types back to the editor.\n\n## Examples\nTo check out some live examples, visit [tiptap.scrumpy.io](https://tiptap.scrumpy.io/).\n\n## Installation\n```\nnpm install tiptap\n```\nor\n```\nyarn add tiptap\n```\n\n## Basic Setup\n```vue\n<template>\n  <editor-content :editor="editor" />\n</template>\n\n<script>\n// Import the editor\nimport { Editor, EditorContent } from \'tiptap\'\n\nexport default {\n  components: {\n    EditorContent,\n  },\n  data() {\n    return {\n      editor: null,\n    }\n  },\n  mounted() {\n    this.editor = new Editor({\n      content: \'<p>This is just a boring paragraph</p>\',\n    })\n  },\n  beforeDestroy() {\n    this.editor.destroy()\n  },\n}\n</script>\n```\n\n## Editor Properties\n\n| **Property** | **Type** | **Default** | **Description** |\n| --- | :---: | :---: | --- |\n| `content` | `Object\\|String` | `null` | The editor state object used by Prosemirror. You can also pass HTML to the `content` slot. When used both, the `content` slot will be ignored. |\n| `editorProps` | `Object` | `{}` | A list of [Prosemirror editorProps](https://prosemirror.net/docs/ref/#view.EditorProps). |\n| `editable` | `Boolean` | `true` | When set to `false` the editor is read-only. |\n| `autoFocus` | `Boolean` | `false` | Focus the editor on init. |\n| `extensions` | `Array` | `[]` | A list of extensions used, by the editor. This can be `Nodes`, `Marks` or `Plugins`. |\n| `useBuiltInExtensions` | `Boolean` | `true` | By default tiptap adds a `Doc`, `Paragraph` and `Text` node to the Prosemirror schema. |\n| `dropCursor` | `Object` | `{}` | Config for `prosemirror-dropcursor`. |\n| `parseOptions` | `Object` | `{}` | A list of [Prosemirror parseOptions](https://prosemirror.net/docs/ref/#model.ParseOptions). |\n| `onInit` | `Function` | `undefined` | This will return an Object with the current `state` and `view` of Prosemirror on init. |\n| `onFocus` | `Function` | `undefined` | This will return an Object with the `event` and current `state` and `view` of Prosemirror on focus. |\n| `onBlur` | `Function` | `undefined` | This will return an Object with the `event` and current `state` and `view` of Prosemirror on blur. |\n| `onUpdate` | `Function` | `undefined` | This will return an Object with the current `state` of Prosemirror, a `getJSON()` and `getHTML()` function and the `transaction` on every change. |\n\n## Editor Methods\n\n| **Method** | **Arguments**| **Description** |\n| --- | :---: | --- |\n| `setContent` | `content, emitUpdate, parseOptions` | Replace the current content. You can pass an HTML string or a JSON document. `emitUpdate` defaults to `false`. `parseOptions` defaults to those provided in constructor. |\n| `clearContent` | `emitUpdate` | Clears the current content. `emitUpdate` defaults to `false`. |\n| `setOptions` | `options` | Overwrites the current editor properties. |\n| `registerPlugin` | `plugin` | Register a Prosemirror plugin. |\n| `getJSON` | \xe2\x80\x93 | Get the current content as JSON. |\n| `getHTML` | \xe2\x80\x93 | Get the current content as HTML. |\n| `focus` | \xe2\x80\x93 | Focus the editor. |\n| `blur` | \xe2\x80\x93 | Blur the editor. |\n| `destroy` | \xe2\x80\x93 | Destroy the editor. |\n\n## Components\n\n| **Name** | **Description** |\n| --- | --- |\n| `<editor-content />` | Here the content will be rendered. |\n| `<editor-menu-bar />` | Here a menu bar will be rendered. |\n| `<editor-menu-bubble />` | Here a menu bubble will be rendered. |\n| `<editor-floating-menu />` | Here a floating menu will be rendered. |\n\n### EditorMenuBar\n\nThe `<editor-menu-bar />` component is renderless and will receive some properties through a scoped slot.\n\n| **Property** | **Type** | **Description** |\n| --- | :---: | --- |\n| `commands` | `Array` | A list of all commands. |\n| `isActive` | `Object` | An object of functions to check if your selected text is a node or mark. `isActive.{node|mark}(attrs)` |\n| `getMarkAttrs` | `Function` | A function to get all mark attributes of your selection. |\n| `focused` | `Boolean` | Whether the editor is focused. |\n| `focus` | `Function` | A function to focus the editor. |\n\n#### Example\n\n```vue\n<template>\n  <editor-menu-bar :editor="editor" v-slot="{ commands, isActive }">\n    <div>\n      <button :class="{ \'is-active\': isActive.bold() }" @click="commands.bold">\n        Bold\n      </button>\n      <button :class="{ \'is-active\': isActive.heading({ level: 2 }) }" @click="commands.heading({ level: 2 })">\n        H2\n      </button>\n    </div>\n  </editor-menu-bar>\n</template>\n```\n\n### EditorMenuBubble\n\nThe `<editor-menu-bubble />` component is renderless and will receive some properties through a scoped slot.\n\n| **Property** | **Type** | **Description** |\n| --- | :---: | --- |\n| `commands` | `Array` | A list of all commands. |\n| `isActive` | `Object` | An object of functions to check if your selected text is a node or mark. `isActive.{node|mark}(attrs)` |\n| `getMarkAttrs` | `Function` | A function to get all mark attributes of your selection. |\n| `focused` | `Boolean` | Whether the editor is focused. |\n| `focus` | `Function` | A function to focus the editor. |\n| `menu` | `Object` | An object for positioning your menu. |\n\n#### Example\n\n```vue\n<template>\n  <editor-menu-bubble :editor="editor" v-slot="{ commands, isActive, menu }">\n    <div\n      :class="{ \'is-active\': menu.isActive }"\n      :style="`left: ${menu.left}px; bottom: ${menu.bottom}px;`"\n    >\n      <button :class="{ \'is-active\': isActive.bold() }" @click="commands.bold">\n        Bold\n      </button>\n      <button :class="{ \'is-active\': isActive.heading({ level: 2 }) }" @click="commands.heading({ level: 2 })">\n        H2\n      </button>\n    </div>\n  </editor-menu-bubble>\n</template>\n```\n\n### EditorFloatingMenu\n\nThe `<editor-floating-menu />` component is renderless and will receive some properties through a scoped slot.\n\n| **Property** | **Type** | **Description** |\n| --- | :---: | --- |\n| `commands` | `Array` | A list of all commands. |\n| `isActive` | `Object` | An object of functions to check if your selected text is a node or mark. `isActive.{node|mark}(attrs)` |\n| `getMarkAttrs` | `Function` | A function to get all mark attributes of your selection. |\n| `focused` | `Boolean` | Whether the editor is focused. |\n| `focus` | `Function` | A function to focus the editor. |\n| `menu` | `Object` | An object for positioning your menu. |\n\n#### Example\n\n```vue\n<template>\n  <editor-floating-menu :editor="editor" v-slot="{ commands, isActive, menu }">\n    <div\n      :class="{ \'is-active\': menu.isActive }"\n      :style="`top: ${menu.top}px`"\n    >\n      <button :class="{ \'is-active\': isActive.bold() }" @click="commands.bold">\n        Bold\n      </button>\n      <button :class="{ \'is-active\': isActive.heading({ level: 2 }) }" @click="commands.heading({ level: 2 })">\n        H2\n      </button>\n    </div>\n  </editor-floating-menu>\n</template>\n```\n\n## Extensions\n\nBy default, the editor will only support paragraphs. Other nodes and marks are available as **extensions**. There is a package called `tiptap-extensions` with the most basic nodes, marks, and plugins.\n\n### Available Extensions\n\n```vue\n<template>\n  <div>\n    <editor-menu-bar :editor="editor" v-slot="{ commands, isActive }">\n        <button :class="{ \'is-active\': isActive.bold() }" @click="commands.bold">\n          Bold\n        </button>\n    </editor-menu-bar>\n    <editor-content :editor="editor" />\n  </div>\n</template>\n\n<script>\nimport { Editor, EditorContent, EditorMenuBar } from \'tiptap\'\nimport {\n  Blockquote,\n  CodeBlock,\n  HardBreak,\n  Heading,\n  OrderedList,\n  BulletList,\n  ListItem,\n  TodoItem,\n  TodoList,\n  Bold,\n  Code,\n  Italic,\n  Link,\n  Strike,\n  Underline,\n  History,\n} from \'tiptap-extensions\'\n\nexport default {\n  components: {\n    EditorMenuBar,\n    EditorContent,\n  },\n  data() {\n    return {\n      editor: new Editor({\n        extensions: [\n          new Blockquote(),\n          new CodeBlock(),\n          new HardBreak(),\n          new Heading({ levels: [1, 2, 3] }),\n          new BulletList(),\n          new OrderedList(),\n          new ListItem(),\n          new TodoItem(),\n          new TodoList(),\n          new Bold(),\n          new Code(),\n          new Italic(),\n          new Link(),\n          new Strike(),\n          new Underline(),\n          new History(),\n        ],\n        content: `\n          <h1>Yay Headlines!</h1>\n          <p>All these <strong>cool tags</strong> are working now.</p>\n        `,\n      }),\n    }\n  },\n  beforeDestroy() {\n    this.editor.destroy()\n  },\n}\n</script>\n```\n\n### Create Custom Extensions\n\nThe most powerful feature of tiptap is that you can create your own extensions. There are 3 types of extensions.\n\n| **Type** | **Description** |\n| --- | --- |\n| `Extension` | The most basic type. It\'s useful to register some [Prosemirror plugins](https://prosemirror.net/docs/guide/) or some input rules. |\n| `Node` | Add a custom node. Nodes are block elements like a headline or a paragraph. |\n| `Mark` | Add a custom mark. Marks are used to add extra styling or other information to inline content like a strong tag or links. |\n\n### Extension Class\n\n| **Method** | **Type** | **Default** | **Description** |\n| --- | :---: | :---: | --- |\n| `get name()` | `String` | `null` | Define a name for your extension. |\n| `get defaultOptions()` | `Object` | `{}` | Define some default options. The options are available as `this.$options`. |\n| `get plugins()` | `Array` | `[]` | Define a list of [Prosemirror plugins](https://prosemirror.net/docs/guide/). |\n| `keys({ schema })` | `Object` | `null` | Define some keybindings. |\n| `commands({ schema, attrs })` | `Object` | `null` | Define a command. |\n| `inputRules({ schema })` | `Array` | `[]` | Define a list of input rules. |\n| `pasteRules({ schema })` | `Array` | `[]` | Define a list of paste rules. |\n| `get update()` | `Function` | `undefined` | Called when options of extension are changed via `editor.extensions.options` |\n\n### Node|Mark Class\n\n| **Method** | **Type** | **Default** | **Description** |\n| --- | :---: | :---: | --- |\n| `get name()` | `String` | `null` | Define a name for your node or mark. |\n| `get defaultOptions()` | `Object` | `{}` | Define some default options. The options are available as `this.$options`. |\n| `get schema()` | `Object` | `null` | Define a [schema](https://prosemirror.net/docs/guide/#schema). |\n| `get view()` | `Object` | `null` | Define a node view as a vue component. |\n| `keys({ type, schema })` | `Object` | `null` | Define some keybindings. |\n| `commands({ type, schema, attrs })` | `Object` | `null` | Define a command. For example this is used for menus to convert to this node or mark. |\n| `inputRules({ type, schema })` | `Array` | `[]` | Define a list of input rules. |\n| `pasteRules({ type, schema })` | `Array` | `[]` | Define a list of paste rules. |\n| `get plugins()` | `Array` | `[]` | Define a list of [Prosemirror plugins](https://prosemirror.net/docs/guide/). |\n\n### Create a Node\n\nLet\'s take a look at a real example. This is basically how the default `blockquote` node from [`tiptap-extensions`](https://www.npmjs.com/package/tiptap-extensions) looks like.\n\n```js\nimport { Node } from \'tiptap\'\nimport { wrappingInputRule, setBlockType, toggleWrap } from \'tiptap-commands\'\n\nexport default class BlockquoteNode extends Node {\n\n  // choose a unique name\n  get name() {\n    return \'blockquote\'\n  }\n\n  // the prosemirror schema object\n  // take a look at https://prosemirror.net/docs/guide/#schema for a detailed explanation\n  get schema() {\n    return {\n      content: \'block+\',\n      group: \'block\',\n      defining: true,\n      draggable: false,\n      // define how the editor will detect your node from pasted HTML\n      // every blockquote tag will be converted to this blockquote node\n      parseDOM: [\n        { tag: \'blockquote\' },\n      ],\n      // this is how this node will be rendered\n      // in this case a blockquote tag with a class called `awesome-blockquote` will be rendered\n      // the \'0\' stands for its text content inside\n      toDOM: () => [\'blockquote\', { class: \'awesome-blockquote\' }, 0],\n    }\n  }\n\n  // this command will be called from menus to add a blockquote\n  // `type` is the prosemirror schema object for this blockquote\n  // `schema` is a collection of all registered nodes and marks\n  commands({ type, schema }) {\n    return () => toggleWrap(type)\n  }\n\n  // here you can register some shortcuts\n  // in this case you can create a blockquote with `ctrl` + `>`\n  keys({ type }) {\n    return {\n      \'Ctrl->\': toggleWrap(type),\n    }\n  }\n\n  // a blockquote will be created when you are on a new line and type `>` followed by a space\n  inputRules({ type }) {\n    return [\n      wrappingInputRule(/^\\s*>\\s$/, type),\n    ]\n  }\n\n}\n```\n\n### Create a Node as a Vue Component\n\nThe real power of the nodes comes in combination with Vue components. Let us build an iframe node, where you can change its URL (this can also be found in our [examples](https://github.com/scrumpy/tiptap/tree/master/examples/Components/Routes/Embeds)).\n\n```js\nimport { Node } from \'tiptap\'\n\nexport default class IframeNode extends Node {\n\n  get name() {\n    return \'iframe\'\n  }\n\n  get schema() {\n    return {\n      // here you have to specify all values that can be stored in this node\n      attrs: {\n        src: {\n          default: null,\n        },\n      },\n      group: \'block\',\n      selectable: false,\n      // parseDOM and toDOM is still required to make copy and paste work\n      parseDOM: [{\n        tag: \'iframe\',\n        getAttrs: dom => ({\n          src: dom.getAttribute(\'src\'),\n        }),\n      }],\n      toDOM: node => [\'iframe\', {\n        src: node.attrs.src,\n        frameborder: 0,\n        allowfullscreen: \'true\',\n      }],\n    }\n  }\n\n  // return a vue component\n  // this can be an object or an imported component\n  get view() {\n    return {\n      // there are some props available\n      // `node` is a Prosemirror Node Object\n      // `updateAttrs` is a function to update attributes defined in `schema`\n      // `view` is the ProseMirror view instance\n      // `options` is an array of your extension options\n      // `selected`\n      props: [\'node\', \'updateAttrs\', \'view\'],\n      computed: {\n        src: {\n          get() {\n            return this.node.attrs.src\n          },\n          set(src) {\n            // we cannot update `src` itself because `this.node.attrs` is immutable\n            this.updateAttrs({\n              src,\n            })\n          },\n        },\n      },\n      template: `\n        <div class="iframe">\n          <iframe class="iframe__embed" :src="src"></iframe>\n          <input class="iframe__input" type="text" v-model="src" v-if="view.editable" />\n        </div>\n      `,\n    }\n  }\n\n}\n```\n\n#### NodeView Prop Types\n\n| **Prop** | **Type** | **Description** |\n| --- | :---: | --- |\n| `node` | `Object` | The Prosemirror node object. Common use case is to get `node.attrs` using a getter on a computed property. |\n| `updateAttrs` | `Function` | A function to update `node.attrs` defined in `schema`. Common use case is as setter on a computed property. |\n| `view` | `Object` | The Prosemirror editor view instance. |\n| `options` | `Array` | An array of your extension options. |\n| `getPos` | `Function` | A function that returns the anchored position of the node. |\n| `selected` | `Boolean` | A boolean that is set when the node is or is not selected. Common use case is using `watch` to see when the view is selected/unselected to do something, such focus an `<input>` or refocus the editor. |\n\n## Editor Methods\n\n## Development Setup\n\nCurrently, only Yarn is supported for development because of a feature called workspaces we are using here.\n\n``` bash\n# install dependencies\nyarn install\n\n# serve examples at localhost:3000\nyarn start\n\n# build dist files for packages\nyarn build:packages\n\n# build dist files for examples\nyarn build:examples\n```\n\n## Contributing\n\nPlease see [CONTRIBUTING](CONTRIBUTING.md) for details.\n\n## Credits\n\n- [Philipp K\xc3\xbchn](https://github.com/philippkuehn)\n- [Christoph Flathmann](https://github.com/Chrissi2812)\n- [Erick Wilder](https://github.com/erickwilder)\n- [Marius Tolzmann](https://github.com/mariux)\n- [All Contributors](../../contributors)\n\n## Packages Using Tiptap\n\n- [Laravel Nova Tiptap Editor Field](https://github.com/manogi/nova-tiptap) by @manogi\n- [WYSIWYG editor for Vuetify](https://github.com/iliyaZelenko/tiptap-vuetify) by @iliyaZelenko\n- [Quasar Tiptap Demo](https://github.com/kfields/quasar-tiptap-demo) @kfields\n\n## Love our work?\n[Become a backer](https://www.paypal.me/philippkuehn) \xe2\x9d\xa4\xef\xb8\x8f\n\n## License\n\nThe MIT License (MIT). Please see [License File](LICENSE.md) for more information.\n'