b'# Vue Property Decorator\n\n[![npm](https://img.shields.io/npm/v/vue-property-decorator.svg)](https://www.npmjs.com/package/vue-property-decorator)\n[![Build Status](https://travis-ci.org/kaorun343/vue-property-decorator.svg?branch=master)](https://travis-ci.org/kaorun343/vue-property-decorator)\n\nThis library fully depends on [vue-class-component](https://github.com/vuejs/vue-class-component), so please read its README before using this library.\n\n## License\n\nMIT License\n\n## Install\n\n```bash\nnpm i -S vue-property-decorator\n```\n\n## Usage\n\nThere are several decorators and 1 function (Mixin):\n\n- [`@Prop`](#Prop)\n- [`@PropSync`](#PropSync)\n- [`@Model`](#Model)\n- [`@Watch`](#Watch)\n- [`@Provide`](#Provide)\n- [`@Inject`](#Provide)\n- [`@ProvideReactive`](#ProvideReactive)\n- [`@InjectReactive`](#ProvideReactive)\n- [`@Emit`](#Emit)\n- [`@Ref`](#Ref)\n- `@Component` (**provided by** [vue-class-component](https://github.com/vuejs/vue-class-component))\n- `Mixins` (the helper function named `mixins` **provided by** [vue-class-component](https://github.com/vuejs/vue-class-component))\n\n## See also\n\n[vuex-class](https://github.com/ktsn/vuex-class/)\n\n### <a id="Prop"></a> `@Prop(options: (PropOptions | Constructor[] | Constructor) = {})` decorator\n\n```ts\nimport { Vue, Component, Prop } from \'vue-property-decorator\'\n\n@Component\nexport default class YourComponent extends Vue {\n  @Prop(Number) readonly propA: number | undefined\n  @Prop({ default: \'default value\' }) readonly propB!: string\n  @Prop([String, Boolean]) readonly propC: string | boolean | undefined\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  props: {\n    propA: {\n      type: Number\n    },\n    propB: {\n      default: \'default value\'\n    },\n    propC: {\n      type: [String, Boolean]\n    }\n  }\n}\n```\n\n**Note that:**\n\n## If you\'d like to set `type` property of each prop value from its type definition, you can use [reflect-metadata](https://github.com/rbuckton/reflect-metadata).\n\n1. Set `emitDecoratorMetadata` to `true`.\n2. Import `reflect-metadata` **before** importing `vue-property-decorator` (importing `reflect-metadata` is needed just once.)\n\n```ts\nimport \'reflect-metadata\'\nimport { Vue, Component, Prop } from \'vue-property-decorator\'\n\n@Component\nexport default class MyComponent extends Vue {\n  @Prop() age!: number\n}\n```\n\n## Each prop\'s default value need to be defined as same as the example code shown in above.\n\nIt\'s **not** supported to define each `default` property like `@Prop() prop = \'default value\'` .\n\n### <a id="PropSync"></a> `@PropSync(propName: string, options: (PropOptions | Constructor[] | Constructor) = {})` decorator\n\n```ts\nimport { Vue, Component, PropSync } from \'vue-property-decorator\'\n\n@Component\nexport default class YourComponent extends Vue {\n  @PropSync(\'name\', { type: String }) syncedName!: string\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  props: {\n    name: {\n      type: String\n    }\n  },\n  computed: {\n    syncedName: {\n      get() {\n        return this.name\n      },\n      set(value) {\n        this.$emit(\'update:name\', value)\n      }\n    }\n  }\n}\n```\n\nOther than that it works just like [`@Prop`](#Prop) other than it takes the propName as an argument of the decorator, in addition to it creates a computed getter and setter behind the scenes. This way you can interface with the property as it was a regular data property whilst making it as easy as appending the `.sync` modifier in the parent component.\n\n### <a id="Model"></a> `@Model(event?: string, options: (PropOptions | Constructor[] | Constructor) = {})` decorator\n\n```ts\nimport { Vue, Component, Model } from \'vue-property-decorator\'\n\n@Component\nexport default class YourComponent extends Vue {\n  @Model(\'change\', { type: Boolean }) readonly checked!: boolean\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  model: {\n    prop: \'checked\',\n    event: \'change\'\n  },\n  props: {\n    checked: {\n      type: Boolean\n    }\n  }\n}\n```\n\n`@Model` property can also set `type` property from its type definition via `reflect-metadata` .\n\n### <a id="Watch"></a> `@Watch(path: string, options: WatchOptions = {})` decorator\n\n```ts\nimport { Vue, Component, Watch } from \'vue-property-decorator\'\n\n@Component\nexport default class YourComponent extends Vue {\n  @Watch(\'child\')\n  onChildChanged(val: string, oldVal: string) {}\n\n  @Watch(\'person\', { immediate: true, deep: true })\n  onPersonChanged1(val: Person, oldVal: Person) {}\n\n  @Watch(\'person\')\n  onPersonChanged2(val: Person, oldVal: Person) {}\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  watch: {\n    child: [\n      {\n        handler: \'onChildChanged\',\n        immediate: false,\n        deep: false\n      }\n    ],\n    person: [\n      {\n        handler: \'onPersonChanged1\',\n        immediate: true,\n        deep: true\n      },\n      {\n        handler: \'onPersonChanged2\',\n        immediate: false,\n        deep: false\n      }\n    ]\n  },\n  methods: {\n    onChildChanged(val, oldVal) {},\n    onPersonChanged1(val, oldVal) {},\n    onPersonChanged2(val, oldVal) {}\n  }\n}\n```\n\n### <a id="Provide"></a> `@Provide(key?: string | symbol)` / `@Inject(options?: { from?: InjectKey, default?: any } | InjectKey)` decorator\n\n```ts\nimport { Component, Inject, Provide, Vue } from \'vue-property-decorator\'\n\nconst symbol = Symbol(\'baz\')\n\n@Component\nexport class MyComponent extends Vue {\n  @Inject() readonly foo!: string\n  @Inject(\'bar\') readonly bar!: string\n  @Inject({ from: \'optional\', default: \'default\' }) readonly optional!: string\n  @Inject(symbol) readonly baz!: string\n\n  @Provide() foo = \'foo\'\n  @Provide(\'bar\') baz = \'bar\'\n}\n```\n\nis equivalent to\n\n```js\nconst symbol = Symbol(\'baz\')\n\nexport const MyComponent = Vue.extend({\n  inject: {\n    foo: \'foo\',\n    bar: \'bar\',\n    optional: { from: \'optional\', default: \'default\' },\n    [symbol]: symbol\n  },\n  data() {\n    return {\n      foo: \'foo\',\n      baz: \'bar\'\n    }\n  },\n  provide() {\n    return {\n      foo: this.foo,\n      bar: this.baz\n    }\n  }\n})\n```\n\n### <a id="ProvideReactive"></a> `@ProvideReactive(key?: string | symbol)` / `@InjectReactive(options?: { from?: InjectKey, default?: any } | InjectKey)` decorator\n\nThese decorators are reactive version of `@Provide` and `@Inject`. If a provided value is modified by parent component, then the child component can catch this modification.\n\n```ts\nconst key = Symbol()\n@Component\nclass ParentComponent extends Vue {\n  @ProvideReactive() one = \'value\'\n  @ProvideReactive(key) two = \'value\'\n}\n\n@Component\nclass ChildComponent extends Vue {\n  @InjectReactive() one!: string\n  @InjectReactive(key) two!: string\n}\n```\n\n### <a id="Emit"></a> `@Emit(event?: string)` decorator\n\nThe functions decorated by `@Emit` `$emit` their return value followed by their original arguments. If the return value is a promise, it is resolved before being emitted.\n\nIf the name of the event is not supplied via the `event` argument, the function name is used instead. In that case, the camelCase name will be converted to kebab-case.\n\n```ts\nimport { Vue, Component, Emit } from \'vue-property-decorator\'\n\n@Component\nexport default class YourComponent extends Vue {\n  count = 0\n\n  @Emit()\n  addToCount(n: number) {\n    this.count += n\n  }\n\n  @Emit(\'reset\')\n  resetCount() {\n    this.count = 0\n  }\n\n  @Emit()\n  returnValue() {\n    return 10\n  }\n\n  @Emit()\n  onInputChange(e) {\n    return e.target.value\n  }\n\n  @Emit()\n  promise() {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve(20)\n      }, 0)\n    })\n  }\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    addToCount(n) {\n      this.count += n\n      this.$emit(\'add-to-count\', n)\n    },\n    resetCount() {\n      this.count = 0\n      this.$emit(\'reset\')\n    },\n    returnValue() {\n      this.$emit(\'return-value\', 10)\n    },\n    onInputChange(e) {\n      this.$emit(\'on-input-change\', e.target.value, e)\n    },\n    promise() {\n      const promise = new Promise(resolve => {\n        setTimeout(() => {\n          resolve(20)\n        }, 0)\n      })\n\n      promise.then(value => {\n        this.$emit(\'promise\', value)\n      })\n    }\n  }\n}\n```\n\n### <a id="Ref"></a> `@Ref(refKey?: string)` decorator\n\n```ts\nimport { Vue, Component, Ref } from \'vue-property-decorator\'\n\nimport AnotherComponent from \'@/path/to/another-component.vue\'\n\n@Component\nexport default class YourComponent extends Vue {\n  @Ref() readonly anotherComponent!: AnotherComponent\n  @Ref(\'aButton\') readonly button!: HTMLButtonElement\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  computed() {\n    anotherComponent: {\n      cache: false,\n      get() {\n        return this.$refs.anotherComponent as AnotherComponent\n      }\n    },\n    button: {\n      cache: false,\n      get() {\n        return this.$refs.aButton as HTMLButtonElement\n      }\n    }\n  }\n}\n```\n'