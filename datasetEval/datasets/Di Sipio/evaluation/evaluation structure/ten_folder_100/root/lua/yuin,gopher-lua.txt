b'\n===============================================================================\nGopherLua: VM and compiler for Lua in Go.\n===============================================================================\n\n.. image:: https://godoc.org/github.com/yuin/gopher-lua?status.svg\n    :target: http://godoc.org/github.com/yuin/gopher-lua\n\n.. image:: https://travis-ci.org/yuin/gopher-lua.svg\n    :target: https://travis-ci.org/yuin/gopher-lua\n\n.. image:: https://coveralls.io/repos/yuin/gopher-lua/badge.svg\n    :target: https://coveralls.io/r/yuin/gopher-lua\n\n.. image:: https://badges.gitter.im/Join%20Chat.svg\n    :alt: Join the chat at https://gitter.im/yuin/gopher-lua\n    :target: https://gitter.im/yuin/gopher-lua?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\n\n|\n\n\nGopherLua is a Lua5.1 VM and compiler written in Go. GopherLua has a same goal\nwith Lua: **Be a scripting language with extensible semantics** . It provides\nGo APIs that allow you to easily embed a scripting language to your Go host\nprograms.\n\n.. contents::\n   :depth: 1\n\n----------------------------------------------------------------\nDesign principle\n----------------------------------------------------------------\n\n- Be a scripting language with extensible semantics.\n- User-friendly Go API\n    - The stack based API like the one used in the original Lua\n      implementation will cause a performance improvements in GopherLua\n      (It will reduce memory allocations and concrete type <-> interface conversions).\n      GopherLua API is **not** the stack based API.\n      GopherLua give preference to the user-friendliness over the performance.\n\n----------------------------------------------------------------\nHow about performance?\n----------------------------------------------------------------\nGopherLua is not fast but not too slow, I think.\n\nGopherLua has almost equivalent ( or little bit better ) performance as Python3 on micro benchmarks.\n\nThere are some benchmarks on the `wiki page <https://github.com/yuin/gopher-lua/wiki/Benchmarks>`_ .\n\n----------------------------------------------------------------\nInstallation\n----------------------------------------------------------------\n\n.. code-block:: bash\n\n   go get github.com/yuin/gopher-lua\n\nGopherLua supports >= Go1.9.\n\n----------------------------------------------------------------\nUsage\n----------------------------------------------------------------\nGopherLua APIs perform in much the same way as Lua, **but the stack is used only\nfor passing arguments and receiving returned values.**\n\nGopherLua supports channel operations. See **"Goroutines"** section.\n\nImport a package.\n\n.. code-block:: go\n\n   import (\n       "github.com/yuin/gopher-lua"\n   )\n\nRun scripts in the VM.\n\n.. code-block:: go\n\n   L := lua.NewState()\n   defer L.Close()\n   if err := L.DoString(`print("hello")`); err != nil {\n       panic(err)\n   }\n\n.. code-block:: go\n\n   L := lua.NewState()\n   defer L.Close()\n   if err := L.DoFile("hello.lua"); err != nil {\n       panic(err)\n   }\n\nRefer to `Lua Reference Manual <http://www.lua.org/manual/5.1/>`_ and `Go doc <http://godoc.org/github.com/yuin/gopher-lua>`_ for further information.\n\nNote that elements that are not commented in `Go doc <http://godoc.org/github.com/yuin/gopher-lua>`_ equivalent to `Lua Reference Manual <http://www.lua.org/manual/5.1/>`_ , except GopherLua uses objects instead of Lua stack indices.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nData model\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nAll data in a GopherLua program is an ``LValue`` . ``LValue`` is an interface\ntype that has following methods.\n\n- ``String() string``\n- ``Type() LValueType``\n\n\nObjects implement an LValue interface are\n\n================ ========================= ================== =======================\n Type name        Go type                   Type() value       Constants\n================ ========================= ================== =======================\n ``LNilType``      (constants)              ``LTNil``          ``LNil``\n ``LBool``         (constants)              ``LTBool``         ``LTrue``, ``LFalse``\n ``LNumber``        float64                 ``LTNumber``       ``-``\n ``LString``        string                  ``LTString``       ``-``\n ``LFunction``      struct pointer          ``LTFunction``     ``-``\n ``LUserData``      struct pointer          ``LTUserData``     ``-``\n ``LState``         struct pointer          ``LTThread``       ``-``\n ``LTable``         struct pointer          ``LTTable``        ``-``\n ``LChannel``       chan LValue             ``LTChannel``      ``-``\n================ ========================= ================== =======================\n\nYou can test an object type in Go way(type assertion) or using a ``Type()`` value.\n\n.. code-block:: go\n\n   lv := L.Get(-1) // get the value at the top of the stack\n   if str, ok := lv.(lua.LString); ok {\n       // lv is LString\n       fmt.Println(string(str))\n   }\n   if lv.Type() != lua.LTString {\n       panic("string required.")\n   }\n\n.. code-block:: go\n\n   lv := L.Get(-1) // get the value at the top of the stack\n   if tbl, ok := lv.(*lua.LTable); ok {\n       // lv is LTable\n       fmt.Println(L.ObjLen(tbl))\n   }\n\nNote that ``LBool`` , ``LNumber`` , ``LString`` is not a pointer.\n\nTo test ``LNilType`` and ``LBool``, You **must** use pre-defined constants.\n\n.. code-block:: go\n\n   lv := L.Get(-1) // get the value at the top of the stack\n\n   if lv == lua.LTrue { // correct\n   }\n\n   if bl, ok := lv.(lua.LBool); ok && bool(bl) { // wrong\n   }\n\nIn Lua, both ``nil`` and ``false`` make a condition false. ``LVIsFalse`` and ``LVAsBool`` implement this specification.\n\n.. code-block:: go\n\n   lv := L.Get(-1) // get the value at the top of the stack\n   if lua.LVIsFalse(lv) { // lv is nil or false\n   }\n\n   if lua.LVAsBool(lv) { // lv is neither nil nor false\n   }\n\nObjects that based on go structs(``LFunction``. ``LUserData``, ``LTable``)\nhave some public methods and fields. You can use these methods and fields for\nperformance and debugging, but there are some limitations.\n\n- Metatable does not work.\n- No error handlings.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nCallstack & Registry size\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThe size of an ``LState``\'s callstack controls the maximum call depth for Lua functions within a script (Go function calls do not count).\n\nThe registry of an ``LState`` implements stack storage for calling functions (both Lua and Go functions) and also for temporary variables in expressions. Its storage requirements will increase with callstack usage and also with code complexity.\n\nBoth the registry and the callstack can be set to either a fixed size or to auto size.\n\nWhen you have a large number of ``LStates`` instantiated in a process, it\'s worth taking the time to tune the registry and callstack options.\n\n+++++++++\nRegistry\n+++++++++\n\nThe registry can have an initial size, a maximum size and a step size configured on a per ``LState`` basis. This will allow the registry to grow as needed. It will not shrink again after growing.\n\n.. code-block:: go\n\n    L := lua.NewState(lua.Options{\n       RegistrySize: 1024 * 20,         // this is the initial size of the registry\n       RegistryMaxSize: 1024 * 80,      // this is the maximum size that the registry can grow to. If set to `0` (the default) then the registry will not auto grow\n       RegistryGrowStep: 32,            // this is how much to step up the registry by each time it runs out of space. The default is `32`.\n    })\n   defer L.Close()\n\nA registry which is too small for a given script will ultimately result in a panic. A registry which is too big will waste memory (which can be significant if many ``LStates`` are instantiated).\nAuto growing registries incur a small performance hit at the point they are resized but will not otherwise affect performance.\n\n+++++++++\nCallstack\n+++++++++\n\nThe callstack can operate in two different modes, fixed or auto size.\nA fixed size callstack has the highest performance and has a fixed memory overhead.\nAn auto sizing callstack will allocate and release callstack pages on demand which will ensure the minimum amount of memory is in use at any time. The downside is it will incur a small performance impact every time a new page of callframes is allocated.\nBy default an ``LState`` will allocate and free callstack frames in pages of 8, so the allocation overhead is not incurred on every function call. It is very likely that the performance impact of an auto resizing callstack will be negligible for most use cases.\n\n.. code-block:: go\n\n    L := lua.NewState(lua.Options{\n        CallStackSize: 120,                 // this is the maximum callstack size of this LState\n        MinimizeStackMemory: true,          // Defaults to `false` if not specified. If set, the callstack will auto grow and shrink as needed up to a max of `CallStackSize`. If not set, the callstack will be fixed at `CallStackSize`.\n    })\n   defer L.Close()\n\n++++++++++++++++\nOption defaults\n++++++++++++++++\n\nThe above examples show how to customize the callstack and registry size on a per ``LState`` basis. You can also adjust some defaults for when options are not specified by altering the values of ``lua.RegistrySize``, ``lua.RegistryGrowStep`` and ``lua.CallStackSize``.\n\nAn ``LState`` object that has been created by ``*LState#NewThread()`` inherits the callstack & registry size from the parent ``LState`` object.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nMiscellaneous lua.NewState options\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n- **Options.SkipOpenLibs bool(default false)**\n    - By default, GopherLua opens all built-in libraries when new LState is created.\n    - You can skip this behaviour by setting this to ``true`` .\n    - Using the various `OpenXXX(L *LState) int` functions you can open only those libraries that you require, for an example see below.\n- **Options.IncludeGoStackTrace bool(default false)**\n    - By default, GopherLua does not show Go stack traces when panics occur.\n    - You can get Go stack traces by setting this to ``true`` .\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nAPI\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRefer to `Lua Reference Manual <http://www.lua.org/manual/5.1/>`_ and `Go doc(LState methods) <http://godoc.org/github.com/yuin/gopher-lua>`_ for further information.\n\n+++++++++++++++++++++++++++++++++++++++++\nCalling Go from Lua\n+++++++++++++++++++++++++++++++++++++++++\n\n.. code-block:: go\n\n   func Double(L *lua.LState) int {\n       lv := L.ToInt(1)             /* get argument */\n       L.Push(lua.LNumber(lv * 2)) /* push result */\n       return 1                     /* number of results */\n   }\n\n   func main() {\n       L := lua.NewState()\n       defer L.Close()\n       L.SetGlobal("double", L.NewFunction(Double)) /* Original lua_setglobal uses stack... */\n   }\n\n.. code-block:: lua\n\n   print(double(20)) -- > "40"\n\nAny function registered with GopherLua is a ``lua.LGFunction``, defined in ``value.go``\n\n.. code-block:: go\n\n   type LGFunction func(*LState) int\n\nWorking with coroutines.\n\n.. code-block:: go\n\n   co, _ := L.NewThread() /* create a new thread */\n   fn := L.GetGlobal("coro").(*lua.LFunction) /* get function from lua */\n   for {\n       st, err, values := L.Resume(co, fn)\n       if st == lua.ResumeError {\n           fmt.Println("yield break(error)")\n           fmt.Println(err.Error())\n           break\n       }\n\n       for i, lv := range values {\n           fmt.Printf("%v : %v\\n", i, lv)\n       }\n\n       if st == lua.ResumeOK {\n           fmt.Println("yield break(ok)")\n           break\n       }\n   }\n\n+++++++++++++++++++++++++++++++++++++++++\nOpening a subset of builtin modules\n+++++++++++++++++++++++++++++++++++++++++\n\nThe following demonstrates how to open a subset of the built-in modules in Lua, say for example to avoid enabling modules with access to local files or system calls.\n\nmain.go\n\n.. code-block:: go\n\n    func main() {\n        L := lua.NewState(lua.Options{SkipOpenLibs: true})\n        defer L.Close()\n        for _, pair := range []struct {\n            n string\n            f lua.LGFunction\n        }{\n            {lua.LoadLibName, lua.OpenPackage}, // Must be first\n            {lua.BaseLibName, lua.OpenBase},\n            {lua.TabLibName, lua.OpenTable},\n        } {\n            if err := L.CallByParam(lua.P{\n                Fn:      L.NewFunction(pair.f),\n                NRet:    0,\n                Protect: true,\n            }, lua.LString(pair.n)); err != nil {\n                panic(err)\n            }\n        }\n        if err := L.DoFile("main.lua"); err != nil {\n            panic(err)\n        }\n    }\n\n+++++++++++++++++++++++++++++++++++++++++\nCreating a module by Go\n+++++++++++++++++++++++++++++++++++++++++\n\nmymodule.go\n\n.. code-block:: go\n\n    package mymodule\n\n    import (\n        "github.com/yuin/gopher-lua"\n    )\n\n    func Loader(L *lua.LState) int {\n        // register functions to the table\n        mod := L.SetFuncs(L.NewTable(), exports)\n        // register other stuff\n        L.SetField(mod, "name", lua.LString("value"))\n\n        // returns the module\n        L.Push(mod)\n        return 1\n    }\n\n    var exports = map[string]lua.LGFunction{\n        "myfunc": myfunc,\n    }\n\n    func myfunc(L *lua.LState) int {\n        return 0\n    }\n\nmymain.go\n\n.. code-block:: go\n\n    package main\n\n    import (\n        "./mymodule"\n        "github.com/yuin/gopher-lua"\n    )\n\n    func main() {\n        L := lua.NewState()\n        defer L.Close()\n        L.PreloadModule("mymodule", mymodule.Loader)\n        if err := L.DoFile("main.lua"); err != nil {\n            panic(err)\n        }\n    }\n\nmain.lua\n\n.. code-block:: lua\n\n    local m = require("mymodule")\n    m.myfunc()\n    print(m.name)\n\n\n+++++++++++++++++++++++++++++++++++++++++\nCalling Lua from Go\n+++++++++++++++++++++++++++++++++++++++++\n\n.. code-block:: go\n\n   L := lua.NewState()\n   defer L.Close()\n   if err := L.DoFile("double.lua"); err != nil {\n       panic(err)\n   }\n   if err := L.CallByParam(lua.P{\n       Fn: L.GetGlobal("double"),\n       NRet: 1,\n       Protect: true,\n       }, lua.LNumber(10)); err != nil {\n       panic(err)\n   }\n   ret := L.Get(-1) // returned value\n   L.Pop(1)  // remove received value\n\nIf ``Protect`` is false, GopherLua will panic instead of returning an ``error`` value.\n\n+++++++++++++++++++++++++++++++++++++++++\nUser-Defined types\n+++++++++++++++++++++++++++++++++++++++++\nYou can extend GopherLua with new types written in Go.\n``LUserData`` is provided for this purpose.\n\n.. code-block:: go\n\n    type Person struct {\n        Name string\n    }\n\n    const luaPersonTypeName = "person"\n\n    // Registers my person type to given L.\n    func registerPersonType(L *lua.LState) {\n        mt := L.NewTypeMetatable(luaPersonTypeName)\n        L.SetGlobal("person", mt)\n        // static attributes\n        L.SetField(mt, "new", L.NewFunction(newPerson))\n        // methods\n        L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), personMethods))\n    }\n\n    // Constructor\n    func newPerson(L *lua.LState) int {\n        person := &Person{L.CheckString(1)}\n        ud := L.NewUserData()\n        ud.Value = person\n        L.SetMetatable(ud, L.GetTypeMetatable(luaPersonTypeName))\n        L.Push(ud)\n        return 1\n    }\n\n    // Checks whether the first lua argument is a *LUserData with *Person and returns this *Person.\n    func checkPerson(L *lua.LState) *Person {\n        ud := L.CheckUserData(1)\n        if v, ok := ud.Value.(*Person); ok {\n            return v\n        }\n        L.ArgError(1, "person expected")\n        return nil\n    }\n\n    var personMethods = map[string]lua.LGFunction{\n        "name": personGetSetName,\n    }\n\n    // Getter and setter for the Person#Name\n    func personGetSetName(L *lua.LState) int {\n        p := checkPerson(L)\n        if L.GetTop() == 2 {\n            p.Name = L.CheckString(2)\n            return 0\n        }\n        L.Push(lua.LString(p.Name))\n        return 1\n    }\n\n    func main() {\n        L := lua.NewState()\n        defer L.Close()\n        registerPersonType(L)\n        if err := L.DoString(`\n            p = person.new("Steeve")\n            print(p:name()) -- "Steeve"\n            p:name("Alice")\n            print(p:name()) -- "Alice"\n        `); err != nil {\n            panic(err)\n        }\n    }\n\n+++++++++++++++++++++++++++++++++++++++++\nTerminating a running LState\n+++++++++++++++++++++++++++++++++++++++++\nGopherLua supports the `Go Concurrency Patterns: Context <https://blog.golang.org/context>`_ .\n\n\n.. code-block:: go\n\n    L := lua.NewState()\n    defer L.Close()\n    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n    defer cancel()\n    // set the context to our LState\n    L.SetContext(ctx)\n    err := L.DoString(`\n      local clock = os.clock\n      function sleep(n)  -- seconds\n        local t0 = clock()\n        while clock() - t0 <= n do end\n      end\n      sleep(3)\n    `)\n    // err.Error() contains "context deadline exceeded"\n\nWith coroutines\n\n.. code-block:: go\n\n\tL := lua.NewState()\n\tdefer L.Close()\n\tctx, cancel := context.WithCancel(context.Background())\n\tL.SetContext(ctx)\n\tdefer cancel()\n\tL.DoString(`\n\t    function coro()\n\t\t  local i = 0\n\t\t  while true do\n\t\t    coroutine.yield(i)\n\t\t\ti = i+1\n\t\t  end\n\t\t  return i\n\t    end\n\t`)\n\tco, cocancel := L.NewThread()\n\tdefer cocancel()\n\tfn := L.GetGlobal("coro").(*LFunction)\n\n\t_, err, values := L.Resume(co, fn) // err is nil\n\n\tcancel() // cancel the parent context\n\n\t_, err, values = L.Resume(co, fn) // err is NOT nil : child context was canceled\n\n**Note that using a context causes performance degradation.**\n\n.. code-block::\n\n    time ./glua-with-context.exe fib.lua\n    9227465\n    0.01s user 0.11s system 1% cpu 7.505 total\n\n    time ./glua-without-context.exe fib.lua\n    9227465\n    0.01s user 0.01s system 0% cpu 5.306 total\n\n+++++++++++++++++++++++++++++++++++++++++\nSharing Lua byte code between LStates\n+++++++++++++++++++++++++++++++++++++++++\nCalling ``DoFile`` will load a Lua script, compile it to byte code and run the byte code in a ``LState``.\n\nIf you have multiple ``LStates`` which are all required to run the same script, you can share the byte code between them,\nwhich will save on memory.\nSharing byte code is safe as it is read only and cannot be altered by lua scripts.\n\n.. code-block:: go\n\n    // CompileLua reads the passed lua file from disk and compiles it.\n    func CompileLua(filePath string) (*lua.FunctionProto, error) {\n        file, err := os.Open(filePath)\n        defer file.Close()\n        if err != nil {\n            return nil, err\n        }\n        reader := bufio.NewReader(file)\n        chunk, err := parse.Parse(reader, filePath)\n        if err != nil {\n            return nil, err\n        }\n        proto, err := lua.Compile(chunk, filePath)\n        if err != nil {\n            return nil, err\n        }\n        return proto, nil\n    }\n\n    // DoCompiledFile takes a FunctionProto, as returned by CompileLua, and runs it in the LState. It is equivalent\n    // to calling DoFile on the LState with the original source file.\n    func DoCompiledFile(L *lua.LState, proto *lua.FunctionProto) error {\n        lfunc := L.NewFunctionFromProto(proto)\n        L.Push(lfunc)\n        return L.PCall(0, lua.MultRet, nil)\n    }\n\n    // Example shows how to share the compiled byte code from a lua script between multiple VMs.\n    func Example() {\n        codeToShare := CompileLua("mylua.lua")\n        a := lua.NewState()\n        b := lua.NewState()\n        c := lua.NewState()\n        DoCompiledFile(a, codeToShare)\n        DoCompiledFile(b, codeToShare)\n        DoCompiledFile(c, codeToShare)\n    }\n\n+++++++++++++++++++++++++++++++++++++++++\nGoroutines\n+++++++++++++++++++++++++++++++++++++++++\nThe ``LState`` is not goroutine-safe. It is recommended to use one LState per goroutine and communicate between goroutines by using channels.\n\nChannels are represented by ``channel`` objects in GopherLua. And a ``channel`` table provides functions for performing channel operations.\n\nSome objects can not be sent over channels due to having non-goroutine-safe objects inside itself.\n\n- a thread(state)\n- a function\n- an userdata\n- a table with a metatable\n\nYou **must not** send these objects from Go APIs to channels.\n\n\n\n.. code-block:: go\n\n    func receiver(ch, quit chan lua.LValue) {\n        L := lua.NewState()\n        defer L.Close()\n        L.SetGlobal("ch", lua.LChannel(ch))\n        L.SetGlobal("quit", lua.LChannel(quit))\n        if err := L.DoString(`\n        local exit = false\n        while not exit do\n          channel.select(\n            {"|<-", ch, function(ok, v)\n              if not ok then\n                print("channel closed")\n                exit = true\n              else\n                print("received:", v)\n              end\n            end},\n            {"|<-", quit, function(ok, v)\n                print("quit")\n                exit = true\n            end}\n          )\n        end\n      `); err != nil {\n            panic(err)\n        }\n    }\n\n    func sender(ch, quit chan lua.LValue) {\n        L := lua.NewState()\n        defer L.Close()\n        L.SetGlobal("ch", lua.LChannel(ch))\n        L.SetGlobal("quit", lua.LChannel(quit))\n        if err := L.DoString(`\n        ch:send("1")\n        ch:send("2")\n      `); err != nil {\n            panic(err)\n        }\n        ch <- lua.LString("3")\n        quit <- lua.LTrue\n    }\n\n    func main() {\n        ch := make(chan lua.LValue)\n        quit := make(chan lua.LValue)\n        go receiver(ch, quit)\n        go sender(ch, quit)\n        time.Sleep(3 * time.Second)\n    }\n\n\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\nGo API\n\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\n\n``ToChannel``, ``CheckChannel``, ``OptChannel`` are available.\n\nRefer to `Go doc(LState methods) <http://godoc.org/github.com/yuin/gopher-lua>`_ for further information.\n\n\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\nLua API\n\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\n\n- **channel.make([buf:int]) -> ch:channel**\n    - Create new channel that has a buffer size of ``buf``. By default, ``buf`` is 0.\n\n- **channel.select(case:table [, case:table, case:table ...]) -> {index:int, recv:any, ok}**\n    - Same as the ``select`` statement in Go. It returns the index of the chosen case and, if that\n      case was a receive operation, the value received and a boolean indicating whether the channel has been closed.\n    - ``case`` is a table that outlined below.\n        - receiving: `{"|<-", ch:channel [, handler:func(ok, data:any)]}`\n        - sending: `{"<-|", ch:channel, data:any [, handler:func(data:any)]}`\n        - default: `{"default" [, handler:func()]}`\n\n``channel.select`` examples:\n\n.. code-block:: lua\n\n    local idx, recv, ok = channel.select(\n      {"|<-", ch1},\n      {"|<-", ch2}\n    )\n    if not ok then\n        print("closed")\n    elseif idx == 1 then -- received from ch1\n        print(recv)\n    elseif idx == 2 then -- received from ch2\n        print(recv)\n    end\n\n.. code-block:: lua\n\n    channel.select(\n      {"|<-", ch1, function(ok, data)\n        print(ok, data)\n      end},\n      {"<-|", ch2, "value", function(data)\n        print(data)\n      end},\n      {"default", function()\n        print("default action")\n      end}\n    )\n\n- **channel:send(data:any)**\n    - Send ``data`` over the channel.\n- **channel:receive() -> ok:bool, data:any**\n    - Receive some data over the channel.\n- **channel:close()**\n    - Close the channel.\n\n\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\nThe LState pool pattern\n\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\nTo create per-thread LState instances, You can use the ``sync.Pool`` like mechanism.\n\n.. code-block:: go\n\n    type lStatePool struct {\n        m     sync.Mutex\n        saved []*lua.LState\n    }\n\n    func (pl *lStatePool) Get() *lua.LState {\n        pl.m.Lock()\n        defer pl.m.Unlock()\n        n := len(pl.saved)\n        if n == 0 {\n            return pl.New()\n        }\n        x := pl.saved[n-1]\n        pl.saved = pl.saved[0 : n-1]\n        return x\n    }\n\n    func (pl *lStatePool) New() *lua.LState {\n        L := lua.NewState()\n        // setting the L up here.\n        // load scripts, set global variables, share channels, etc...\n        return L\n    }\n\n    func (pl *lStatePool) Put(L *lua.LState) {\n        pl.m.Lock()\n        defer pl.m.Unlock()\n        pl.saved = append(pl.saved, L)\n    }\n\n    func (pl *lStatePool) Shutdown() {\n        for _, L := range pl.saved {\n            L.Close()\n        }\n    }\n\n    // Global LState pool\n    var luaPool = &lStatePool{\n        saved: make([]*lua.LState, 0, 4),\n    }\n\nNow, you can get per-thread LState objects from the ``luaPool`` .\n\n.. code-block:: go\n\n    func MyWorker() {\n       L := luaPool.Get()\n       defer luaPool.Put(L)\n       /* your code here */\n    }\n\n    func main() {\n        defer luaPool.Shutdown()\n        go MyWorker()\n        go MyWorker()\n        /* etc... */\n    }\n\n\n----------------------------------------------------------------\nDifferences between Lua and GopherLua\n----------------------------------------------------------------\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nGoroutines\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- GopherLua supports channel operations.\n    - GopherLua has a type named ``channel``.\n    - The ``channel`` table provides functions for performing channel operations.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nUnsupported functions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- ``string.dump``\n- ``os.setlocale``\n- ``lua_Debug.namewhat``\n- ``package.loadlib``\n- debug hooks\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nMiscellaneous notes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- ``collectgarbage`` does not take any arguments and runs the garbage collector for the entire Go program.\n- ``file:setvbuf`` does not support a line buffering.\n- Daylight saving time is not supported.\n- GopherLua has a function to set an environment variable : ``os.setenv(name, value)``\n\n----------------------------------------------------------------\nStandalone interpreter\n----------------------------------------------------------------\nLua has an interpreter called ``lua`` . GopherLua has an interpreter called ``glua`` .\n\n.. code-block:: bash\n\n   go get github.com/yuin/gopher-lua/cmd/glua\n\n``glua`` has same options as ``lua`` .\n\n----------------------------------------------------------------\nHow to Contribute\n----------------------------------------------------------------\nSee `Guidlines for contributors <https://github.com/yuin/gopher-lua/tree/master/.github/CONTRIBUTING.md>`_ .\n\n----------------------------------------------------------------\nLibraries for GopherLua\n----------------------------------------------------------------\n\n- `gopher-luar <https://github.com/layeh/gopher-luar>`_ : Simplifies data passing to and from gopher-lua\n- `gluamapper <https://github.com/yuin/gluamapper>`_ : Mapping a Lua table to a Go struct\n- `gluare <https://github.com/yuin/gluare>`_ : Regular expressions for gopher-lua\n- `gluahttp <https://github.com/cjoudrey/gluahttp>`_ : HTTP request module for gopher-lua\n- `gopher-json <https://github.com/layeh/gopher-json>`_ : A simple JSON encoder/decoder for gopher-lua\n- `gluayaml <https://github.com/kohkimakimoto/gluayaml>`_ : Yaml parser for gopher-lua\n- `glua-lfs <https://github.com/layeh/gopher-lfs>`_ : Partially implements the luafilesystem module for gopher-lua\n- `gluaurl <https://github.com/cjoudrey/gluaurl>`_ : A url parser/builder module for gopher-lua\n- `gluahttpscrape <https://github.com/felipejfc/gluahttpscrape>`_ : A simple HTML scraper module for gopher-lua\n- `gluaxmlpath <https://github.com/ailncode/gluaxmlpath>`_ : An xmlpath module for gopher-lua\n- `gluasocket <https://github.com/BixData/gluasocket>`_ : A LuaSocket library for the GopherLua VM\n- `gluabit32 <https://github.com/BixData/gluabit32>`_ : A native Go implementation of bit32 for the GopherLua VM.\n- `gmoonscript <https://github.com/rucuriousyet/gmoonscript>`_ : Moonscript Compiler for the Gopher Lua VM\n- `loguago <https://github.com/rucuriousyet/loguago>`_ : Zerolog wrapper for Gopher-Lua\n- `gluacrypto <https://github.com/tengattack/gluacrypto>`_ : A native Go implementation of crypto library for the GopherLua VM.\n- `gluasql <https://github.com/tengattack/gluasql>`_ : A native Go implementation of SQL client for the GopherLua VM.\n- `purr <https://github.com/leyafo/purr>`_ : A http mock testing tool.\n- `vadv/gopher-lua-libs <https://github.com/vadv/gopher-lua-libs>`_ : Some usefull libraries for GopherLua VM.\n- `gluaperiphery <https://github.com/BixData/gluaperiphery>`_ : A periphery library for the GopherLua VM (GPIO, SPI, I2C, MMIO, and Serial peripheral I/O for Linux).\n- `glua-async <https://github.com/CuberL/glua-async>`_ : An async/await implement for gopher-lua. \n----------------------------------------------------------------\nDonation\n----------------------------------------------------------------\n\nBTC: 1NEDSyUmo4SMTDP83JJQSWi1MvQUGGNMZB\n\n----------------------------------------------------------------\nLicense\n----------------------------------------------------------------\nMIT\n\n----------------------------------------------------------------\nAuthor\n----------------------------------------------------------------\nYusuke Inuzuka\n'