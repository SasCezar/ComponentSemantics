b'<img align="left" src="images/logo_small.png" width="128px"/>\n\n# Wicked Engine\n\n[![Build status][s1]][av] [![License: MIT][s3]][li] [![Discord chat][s2]][di] \n<a href="https://twitter.com/intent/follow?screen_name=turanszkij">\n        <img src="https://img.shields.io/twitter/follow/turanszkij.svg?style=social"\n            alt="follow on Twitter"></a><br/>\nLatest builds: \n[![Editor][s4]][do64] [![Editor32][s5]][do32]\n[![Tests][s6]][dt64] [![Tests32][s7]][dt32] <br/>\n\n[s1]: https://ci.appveyor.com/api/projects/status/3dbcee5gd6i7qh7v?svg=true\n[s2]: https://img.shields.io/discord/602811659224088577?logo=discord\n[s3]: https://img.shields.io/badge/License-MIT-orange.svg\n[s4]: https://img.shields.io/badge/editor-64bit-blue.svg\n[s5]: https://img.shields.io/badge/editor-32bit-blue.svg\n[s6]: https://img.shields.io/badge/tests-64bit-blue.svg\n[s7]: https://img.shields.io/badge/tests-32bit-blue.svg\n\n[av]: https://ci.appveyor.com/project/turanszkij/wickedengine\n[di]: https://discord.gg/CFjRYmE\n[li]: https://opensource.org/licenses/MIT\n[do64]: https://ci.appveyor.com/api/projects/turanszkij/wickedengine/artifacts/WickedEngineEditor.zip?branch=master&job=Platform%3A%20x64\n[do32]: https://ci.appveyor.com/api/projects/turanszkij/wickedengine/artifacts/WickedEngineEditor.zip?branch=master&job=Platform%3A%20Win32\n[dt64]: https://ci.appveyor.com/api/projects/turanszkij/wickedengine/artifacts/WickedEngineTests.zip?branch=master&job=Platform%3A%20x64\n[dt32]: https://ci.appveyor.com/api/projects/turanszkij/wickedengine/artifacts/WickedEngineTests.zip?branch=master&job=Platform%3A%20Win32\n[ba]: https://github.com/turanszkij/WickedEngine/tree/old-system-backup\n\n<br/>\n<img align="right" src="https://turanszkij.files.wordpress.com/2018/11/gltfanim.gif"/>\nWicked Engine is an open-source game engine written in C++. It is easy to use, high performance and feature rich. There are no external dependencies, but some free libraries are included as part of the source code. The MIT license means that anyone is free to download, modify, share or do anything with it. <br/>\nThis project is hosted on GitHub. For any questions, please open an issue at: https://github.com/turanszkij/WickedEngine<br/>\nBecause everything is changing rapidly, the documentation is sparse at the moment. <br/>\n\n[Documentation](Documentation/WickedEngine-Documentation.md)<br/>\n[Scripting API Documentation](Documentation/ScriptingAPI-Documentation.md)<br/>\n[Features](features.txt)<br/>\n[Devblog](https://turanszkij.wordpress.com/)<br/>\n[Videos](https://www.youtube.com/playlist?list=PLLN-1FTGyLU_HJoC5zx6hJkB3D2XLiaxS)<br/>\n\nYou can download the engine by using Git and cloning the repository, or downloading it as zip, which will give you the full C++ source code that you must build for yourself. Building is simply pressing F5 in Visual Studio. You can also choose to download a pre-built version of the Editor or Tests applications, which will allow you to load content and write LUA scripts out of the box. <br/>\n\n![Emitter](https://turanszkij.files.wordpress.com/2019/02/emitterskinned2.gif) ![Drone](https://turanszkij.files.wordpress.com/2018/11/drone_anim.gif) <br/>\n\n<img align="right" src="https://turanszkij.files.wordpress.com/2018/11/physics.gif"/>\n\n### Platforms:\n- Windows PC Desktop (x86, x64)\n- Universal Windows (x86, x64, ARM, Phone, XBOX One)\n\n### Requirements:\n\n- Windows 10\n- Visual Studio 2019\n\n### Getting started: \n\n<img align="right" src="https://turanszkij.files.wordpress.com/2018/11/trace.gif"/>\n\nThere are a couple of projects that you can run up front: Editor, Tests and Template. You just have to set either as startup project and press F5 in Visual Studio to build and run.\n\nIf you wish to integrate Wicked Engine into your own project, you can use it as a static library and link it to your application. For this, you must first compile the engine library project for the desired platform. For Windows Desktop, this is the WickedEngine_Windows project. After that, set the following dependencies to this library in Visual Studio this way in the implementing project (paths are as if your project is inside the engine root folder):\n\n1. Open Project Properties -> Configuration Properties\n2. C/C++ -> General -> Additional Include Directories: \n\t- ./WickedEngine\n3. Linker -> General -> Additional Library Directories:\n\t- Directory of your built .lib file (For example ./x64/Release)\n4. Also be sure to compile with a non-DLL runtime library for Release builds:\n\t- Project settings -> C/C++ -> Code Generation -> Runtime Library -> Multi threaded\n5. If you want to create an UWP application, #define WINSTORE_SUPPORT preprocessor for the whole implementing project and link against the WickedEngine_UWP library.\n\t\nWhen your project settings are set up, put #include "WickedEngine.h" in your source. This will enable the use of all the engine features and link the necessary binaries. After this, you should already be able to build your project.\n\nIf you have trouble, you can always look at or copy the project settings for Editor, Tests and Template projects to get an idea how to link with Wicked Engine.\n\nInitialization example (C++):\n\n<img align="right" src="https://turanszkij.files.wordpress.com/2018/05/sphinit.gif"/>\n\n```cpp\n// Include engine headers:\n#include "WickedEngine.h"\n\n// Declare main component once per application:\nMainComponent main;\n\n// If you want to render, interface with Windows API like this:\nmain.SetWindow(hWnd, hInst);\n\n// Run the application:\nwhile(true) {\n   main.Run(); \n}\n```\n\nSome basic usage examples (C++):\n```cpp\nRenderPath3D_Deferred myGame; // Declare a game screen component, aka "RenderPath" (you could also override its Update(), Render() etc. functions). This is a 3D, Deferred path for example, but there are others\nmain.ActivatePath(&myGame); // Register your game to the application. It will call Start(), Update(), Render(), etc. from now on...\n\nwiSceneSystem::LoadModel("myModel.wiscene"); // Simply load a model into the current global scene\nwiSceneSystem::GetScene(); // Get the current global scene\nwiRenderer::ClearWorld(); // Delete every model, etc. from the current global scene\n\nwiSceneSystem::Scene scene2; // create a separate scene\nwiSceneSystem::LoadModel(scene2, "myModel2.wiscene"); // Load model into a separate scene\nwiSceneSystem::GetScene().Merge(scene2); // Combine separate scene with global scene\n\nmyGame.setSSAOEnabled(true); // You can enable post process effects this way...\n\nRenderPath2D myMenuScreen; // This is an other render path, but now a simple 2D one. It can only render 2D graphics by default (like a menu for example)\nmain.ActivatePath(&myMenuScreen); // activate the menu, the previous path (myGame) will be stopped\n\nwiSprite mySprite("image.png"); // There are many utilities, such as a "sprite" helper class\nmyMenuScreen.addSprite(&mySprite); // The 2D render path is ready to handle sprite and font rendering for you\n\nwiAudio::Sound mySound;\nwiAudio::CreateSound("explosion.wav", &mySound); // Loads a sound file\nwiAudio::SoundInstance mySoundInstance;\nwiAudio::CreateSoundInstance(&mySound, &mySoundInstance); // Instances the sound file, it can be played now\nwiAudio::Play(&mySoundInstance); // Play the sound instance\nwiAudio::SetVolume(0.6, &mySoundInstance); // Set the volume of this soundinstance\nwiAudio::SetVolume(0.2); // Set the master volume\n\nif (wiInput::press(wiInput::KEYBOARD_BUTTON_SPACE)) { wiAudio::Stop(&mySoundInstance); } // You can check if a button is pressed or not (this only triggers once)\nif (wiInput::down(wiInput::KEYBOARD_BUTTON_SPACE)) { wiAudio::Play(&mySoundInstance); } // You can check if a button is pushed down or not (this triggers repeatedly)\n```\n\nSome scripting examples (LUA):\n```lua\n-- Set a rendering path for the application main component\npath = RenderPath3D_Deferred;\nmain.SetActivePath(path);    -- "main" is created automatically\n\n-- Load a model entity into the global scene:\nentity = LoadModel("myModel.wiscene");\n\n-- Load a model entity into a separate scene:\nscene2 = Scene()\nentity2 = LoadModel(scene2, "myModel2.wiscene");\n\n-- Combine the separate scene with the global scene:\nscene.Merge(scene2);\n\n-- Get the current global scene:\nscene = GetScene();\n\n-- Move model to the right using the entity-component system:\ntransform = scene.Component_GetTransform(entity);\ntransform.Translate(Vector(2, 0, 0));\n\n-- Clear every model from the current global scene:\nClearWorld();\n\n-- Print any WickedEngine class information to the backlog:\ngetprops(main);    -- prints the main component methods\ngetprops(scene);    -- prints the Scene class methods\ngetprops(path);    -- prints the deferred render path methods\n\n-- Play a sound:\nsound = Sound()\naudio.CreateSound("explosion.wav", sound)\nsoundinstance = SoundInstance()\naudio.CreateSoundInstance(sound, soundinstance)  -- several instances can be created from one file\naudio.Play(soundinstance)\naudio.SetVolume(0.6, soundinstance)  -- sets the volume of this soundinstance\naudio.SetVolume(0.2)  -- sets the master volume\n\n-- Check for input:\nif(input.press(KEYBOARD_BUTTON_LEFT)) then\n   audio.Play(soundinstance); -- this will play the sound if you press the left arrow on the keyboard\nend\n```\n<i>(You can enter lua scripts into the backlog (HOME button), or the startup.lua script which is always executed on application startup if it is found near the app, or load a script via dofile("script.lua") command)</i>\n\nFor more code samples and advanced use cases, please see the example projects, like the Template_Windows, Tests, or Editor project. There are also sample models and scripts included with Wicked Engine in the models and scripts folders. Check them out to learn about more features.\n\n### Scripting API:\n\n<img align="right" src="https://turanszkij.files.wordpress.com/2018/11/hairparticle2.gif"/>\n\nYou can use a great number of engine features through the Lua scripting api, which can even be used real time while the program is running. The included applications, like the Editor,\ncontain a scripting input method toggled by the "Home" key. A blue screen will be presented where the user can type in LUA commands. It is very minimal in regards to input methods.\nFor further details, please check the scripting API documentation: [Wicked Engine Scripting API](Documentation/ScriptingAPI-Documentation.md)\n\n\n### Model import/export:\n\nThe native model format is the <b>WISCENE</b> format. Any application using Wicked Engine can open this format efficiently.\n\nIn addition, the Editor supports the importing of some common model formats (the list will potentially grow): \n- <b>OBJ</b>\n- <b>GLTF 2.0</b>\n\nThe preferred workflow is to import models into the Editor, and save them as <b>WISCENE</b>, then any Wicked Engine application can open them.<br/>\n<i>(The old Blender exporter script is now not supported! (from version 0.21.0), because the engine was redesigned with Entity-Component System at its core. The old object oriented version can be found [here][ba].)</i>\n\n### Graphics API:\n\nThe default renderer is DirectX 11. There is also a DirectX12 renderer (experimental) and Vulkan renderer (experimental).\nYou can specify command line arguments to switch between render devices or other settings. Currently the list of options:\n<table>\n  <tr>\n    <th>Argument</th>\n    <th>Description</th>\n  </tr>\n  <tr>\n    <td>dx12</td>\n    <td>Create DirectX 12 rendering device (Windows 10 required)</td>\n  </tr>\n  <tr>\n    <td>vulkan</td>\n    <td>Create Vulkan rendering device*. (Only if engine was built with Vulkan SDK installed)</td>\n  </tr>\n  <tr>\n    <td>debugdevice</td>\n    <td>Create rendering device with debug layer enabled for validation. Performance will be degraded.</td>\n  </tr>\n  <tr>\n    <td>hlsl6</td>\n    <td>Reroute shader loading path to use shader model 6 shaders** (DirectX 12 only)</td>\n  </tr>\n</table>\n\n<img align="right" src="https://turanszkij.files.wordpress.com/2018/11/soft.gif"/>\n\n* *Before enabling the Vulkan API, you must first also compile SPIR-V shaders. This step is not yet included in the standard build process. First, run the "generate_shader_buildtask_spirv.py"\nPython script which will generate the SPIR-V shader building program "build_SPIRV.bat". Run "build_SPIRV.bat" to build all HLSL shaders as SPIR-V bytecode format for Vulkan. Shader loading after this \nis automatic if you start the application with Vulkan support.\nThis feature is experimental, not tested thoroughly yet.\n\n* **To load HLSL 6 shaders, replicate the exact steps as with SPIR-V above(*), but the python script you should run is called "generate_shader_buildtask_hlsl6.py" which will generate "build_HLSL6.bat". \nThis feature is experimental, not tested thoroughly yet.\n\n<br/>\n\n### Contributions\n\nContributions can be submitted on Github by following the steps below:\n1) Open an issue and describe the feature or patch in detail\n2) The feature or patch will be discussed in the issue, and determined if it would benefit the project\n3) After the request is accepted, open a pull request and reference the issue with #issue_number\n4) Code review will be conducted and the pull request will be merged when it meets the requirements\n5) When the pull request passes, you will be added to the credits as a contributor and your name shall be remembered by future generations\n\n<br/>\n\n### Finally, take a look at some screenshots:\n\nSponza scene with voxel GI enabled:\n![Sponza](https://turanszkij.files.wordpress.com/2018/12/sponza.png)\n\nDamaged Helmet GLTF sample model:\n![Sponza](https://turanszkij.files.wordpress.com/2019/03/damagedhelmet.png)\n\nPath tracing in the living room:\n![LivingRoom](https://turanszkij.files.wordpress.com/2019/09/livingroom.jpg)\n\nCity scene with a light map, model from <a href="https://www.cgtrader.com/michaelmilesgallie">Michael Gallie</a>:\n![City](https://turanszkij.files.wordpress.com/2019/01/city1.png)\n\nPath tracing in the city:\n![Balcony](https://turanszkij.files.wordpress.com/2019/01/city2.png)\n\nPath traced caustics:\n![Caustics](https://turanszkij.files.wordpress.com/2019/01/trace.png)\n\nLots of instanced boxes with a light map:\n![Lightmap](https://turanszkij.files.wordpress.com/2019/01/lightmap.png)\n\nLots of boxes path traced in the editor:\n![EditorBoxes](https://turanszkij.files.wordpress.com/2019/01/boxes.png)\n\nBloom and post processing:\n![Bloom](https://turanszkij.files.wordpress.com/2019/01/bloom.png)\n\nBistro scene from Amazon Lumberyard (from <a href="http://casual-effects.com/data/index.html">Morgan McGuire\'s graphics archive</a>):\n![Bistro_out](https://turanszkij.files.wordpress.com/2019/01/bistro_out_0.png)\n\nBistro scene from the inside:\n![Bistro_in](https://turanszkij.files.wordpress.com/2019/01/bistro_in_2.png)\n\nParallax occlusion mapping:\n![ParallxOcclusionMapping](https://turanszkij.files.wordpress.com/2019/01/pom.png)\n\nLarge scale particle simulation on the GPU:\n![ParticleSimulation](https://turanszkij.files.wordpress.com/2019/01/gpuparticles3.png)\n\nTiled light culling in the Bistro:\n![TiledLightCulling](https://turanszkij.files.wordpress.com/2019/02/bistro_heatmap-1.png)\n\nPhysically based rendering test:\n![PBRTest](https://turanszkij.files.wordpress.com/2019/03/roughness.png)\n\nGPU-based BVH builder:\n![GPU_BVH](https://turanszkij.files.wordpress.com/2019/07/bvh_livingroom.png)\n'