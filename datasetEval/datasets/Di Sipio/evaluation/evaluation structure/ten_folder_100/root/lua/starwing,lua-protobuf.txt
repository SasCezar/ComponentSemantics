b'# Google protobuf support for Lua\n\n[![Build Status](https://travis-ci.org/starwing/lua-protobuf.svg?branch=master)](https://travis-ci.org/starwing/lua-protobuf)[![Coverage Status](https://coveralls.io/repos/github/starwing/lua-protobuf/badge.svg?branch=master)](https://coveralls.io/github/starwing/lua-protobuf?branch=master)\n\n\xe4\xb8\xad\xe6\x96\x87\xe4\xbd\xbf\xe7\x94\xa8\xe8\xaf\xb4\xe6\x98\x8e\xef\xbc\x9ahttps://zhuanlan.zhihu.com/p/26014103\n\nUrho3d\xe9\x9b\x86\xe6\x88\x90\xe8\xaf\xb4\xe6\x98\x8e\xef\xbc\x9ahttps://note.youdao.com/ynoteshare1/index.html?id=20d06649fab669371140256abd7a362b&type=note\n\nToLua\xe9\x9b\x86\xe6\x88\x90\xe8\xaf\xb4\xe6\x98\x8e\xef\xbc\x9ahttp://changxianjie.com/tolua\xe9\x9b\x86\xe6\x88\x90lua-protobuf/\n\nQQ\xe7\xbe\xa4\xef\xbc\x9a485016061 [![lua-protobuf1\xe4\xba\xa4\xe6\xb5\x81\xe7\xbe\xa4](https://pub.idqqimg.com/wpa/images/group.png)](https://shang.qq.com/wpa/qunwpa?idkey=d7e2973604a723c4f77d0a837df39be26e15be2c2ec29d5ebfdb64f94e74e6ae)\n\nThis project offers a C module for Lua manipulating Google\'s protobuf protocol, both for version 2 and 3 syntax and semantics. It splits to the lower-level and the high-level parts for different goals.\n\nFor converting between binary protobuf data with Lua tables, using `pb.load()` loads the compiled protobuf schema content (`*.pb` file) generated by Google protobuf\'s compiler named `protoc` and call `pb.encode()`/`pb.decode()`.\n\nOr use these modules to manipulate the raw wire format in lower-level way:\n\n  - `pb.slice`: a wire format decoding module.\n  - `pb.buffer`: a buffer implement that use to encode basic types into protobuf\'s wire format.  It can be used to support streaming decode protobuf data.\n  - `pb.conv`: a module converting integers in the protobuf wire format.\n  - `pb.io`: a module access `stdin/stdout` or other files in binary mode.\n\nIf you don\'t want to depend Google\'s protobuf compiler, `protoc.lua` is a pure Lua module translating text-based protobuf schema content into the `*.pb` binary format.\n\n## Install\n\nTo install, you could just use `luarocks`:\n\n```shell\nluarocks install lua-protobuf\n```\n\nIf you want to build it from source, just clone the repo and use luarocks:\n\n```shell\ngit clone https://github.com/starwing/lua-protobuf\nluarocks make rockspecs/lua-protobuf-scm-1.rockspec\n```\n\nIf you don\'t have luarocks, use `hererocks` to install Lua and luarocks:\n\n```shell\npip install hererocks\ngit clone https://github.com/starwing/lua-protobuf\nhererocks -j 2.0 -rlatest .\nbin/luarocks make lua-protobuf/rockspecs/lua-protobuf-scm-1.rockspec CFLAGS="-fPIC -Wall -Wextra" LIBFLAGS="-shared"\ncp protoc.lua pb.so ..\n```\n\nOr you can build it by hand, it only has a pure Lua module `protoc.lua` and a pair of C source: `pb.h` and `pb.c`.\n\nTo build it on macOS, use your favor compiler:\n\n```shell\ngcc -O2 -shared -undefined dynamic_lookup pb.c -o pb.so\n```\n\nOn Linux, use the nearly same command:\n\n```shell\ngcc -O2 -shared -fPIC pb.c -o pb.so\n```\n\nOn Windows, you could use MinGW or MSVC, create a `*.sln` project or build it on the command line (notice the `Lua_BUILD_AS_DLL` flag):\n\n```shell\ncl /O2 /LD /Fepb.dll /I Lua53\\include /DLUA_BUILD_AS_DLL pb.c Lua53\\lib\\lua53.lib\n```\n\n## Example\n\n```lua\nlocal pb = require "pb"\nlocal protoc = require "protoc"\n\n-- load schema from text\nassert(protoc:load [[\n   message Phone {\n      optional string name        = 1;\n      optional int64  phonenumber = 2;\n   }\n   message Person {\n      optional string name     = 1;\n      optional int32  age      = 2;\n      optional string address  = 3;\n      repeated Phone  contacts = 4;\n   } ]])\n\n-- lua table data\nlocal data = {\n   name = "ilse",\n   age  = 18,\n   contacts = {\n      { name = "alice", phonenumber = 12312341234 },\n      { name = "bob",   phonenumber = 45645674567 }\n   }\n}\n\n-- encode lua table data into binary format in lua string and return\nlocal bytes = assert(pb.encode("Person", data))\nprint(pb.tohex(bytes))\n\n-- and decode the binary data back into lua table\nlocal data2 = assert(pb.decode("Person", bytes))\nprint(require "serpent".block(data2))\n\n```\n\n## Use case\n\n[![\xe9\x9b\xb6\xe5\xa2\x83\xe4\xba\xa4\xe9\x94\x99](https://img.tapimg.com/market/images/e59627dc9039ff22ba7d000b5c9fe7f6.jpg?imageView2/2/h/560/q/40/format/jpg/interlace/1/ignore-error/1)](http://djwk.qq.com)\n\n\n\n## Usage\n\n### `protoc` Module\n\n| Function            | Returns       | Descriptions                                         |\n| ------------------- | ------------- | ---------------------------------------------------- |\n| `protoc.new()`      | Proroc object | create a new compiler instance                       |\n| `protoc.reload()`   | true          | reload all google standard messages into `pb` module |\n| `p:parse(string)`   | table         | transform schema to `DescriptorProto` table          |\n| `p:compile(string)` | string        | transform schema to binary *.pb format data          |\n| `p:load(string)`    | true          | load schema into `pb` module                         |\n| `p.loaded`          | table         | contains all parsed `DescriptorProto` table          |\n| `p.unknown_module`  | see below     | handle schema import error                           |\n| `p.unknown_type`    | see below     | handle unknown type in schema                        |\n| `p.include_imports` | bool          | auto load imported proto                             |\n\nTo parse a text schema content, create a compiler instance first:\n\n```lua\nlocal p = protoc.new()\n```\n\nThen, set some options to the compiler, e.g. the unknown handlers:\n\n```lua\n-- set some hooks\np.unknown_module = function(self, module_name) ... end\np.unknown_type   = function(self, type_name) ... end\n-- ... and options\np.include_imports = true\n```\n\nThe `unknwon_module` and `unknown_type` handle could be `true`, string or a function.  Seting it to `true` means all *non-exist* modules and types are given a default value without triggering an error;  A string means a Lua pattern that indicates whether an unknown module or type should raise an error, e.g.\n\n```lua\np.unknown_type = "Foo.*"\n```\n\nmeans all types prefixed by `Foo` will be treat as existing type and do not trigger errors.\n\nIf these are functions, the unknown type and module name will be passed to functions.  For module handler, it should return a `DescriptorProto` Table produced by `p:load()` functions, for type handler, it should return a type name and type, such as `message` or `enum`, e.g.\n\n```lua\nfunction p:unknown_module(name)\n  -- if can not find "foo.proto", load "my_foo.proto" instead\n  return p:load("my_"..name)\nend\n\nfunction p:unknown_type(name)\n  -- if cannot find "Type", treat it as ".MyType" and is a message type return ".My"..name, "message"\nend\n```\n\nAfter setting options, use `load()` or `compile()` or `parse()` function to get result.\n\n### `pb` Module\n\n`pb` module has high-level routines to manipulate protobuf messages.\n\nin below table of functions, we have several types that have special means:\n\n- `type`: a string that indicates the protobuf message type, `".Foo"` means the type in a proto definition that has not `package` statement declared.  `"foo.Foo"` means the type in a proto definition that declared `package foo;`\n\n- `data`: could be string, `pb.Slice` value or `pb.Buffer` value.\n\n- `iterator`: a function that can use in Lua `for in` statement, e.g.\n\n  ```lua\n  for name in pb.types() do\n    print(name)\n  end\n  ```\n\n\nall functions raise a Lua error when meets errors.\n\n| Function                       | Returns         | Description                                             |\n| ------------------------------ | --------------- | ------------------------------------------------------- |\n| `pb.clear()`                   | None            | clear all types                                         |\n| `pb.clear(type)`               | None            | delete specific type                                    |\n| `pb.load(data)`                | boolean,integer | load a binary schema data into `pb` module              |\n| `pb.encode(type, table)`       | string          | encode a message table into binary form                 |\n| `pb.encode(type, table, b)`    | buffer          | encode a message table into binary form to buffer       |\n| `pb.decode(type, data)`        | table           | decode a binary message into Lua table                  |\n| `pb.decode(type, data, table)` | table           | decode a binary message into a given Lua table          |\n| `pb.pack(fmt, ...)`            | string          | same as `buffer.pack()` but return string               |\n| `pb.unpack(data, fmt, ...)`    | values...       | same as `slice.unpack()` but accept data                |\n| `pb.types()`                   | iterator        | iterate all types in `pb` module                        |\n| `pb.type(type)`                | see below       | return informations for specific type                   |\n| `pb.fields(type)`              | iterator        | iterate all fields in a message                         |\n| `pb.field(type, string)`       | see below       | return informations for specific field of type          |\n| `pb.typefmt(type)`             | String          | transform type name of field into pack/unpack formatter |\n| `pb.enum(type, string)`        | number          | get the value of a enum by name                         |\n| `pb.enum(type, number)`        | string          | get the name of a enum by value                         |\n| `pb.defaults(type[, table])`   | table           | get the default table of type                           |\n| `pb.hook(type[, function])`    | function        | get or set hook functions                               |\n| `pb.option(string)`            | string          | set options to decoder/encoder                          |\n| `pb.state()`                   | `pb.State`      | retrieve current pb state                               |\n| `pb.state(newstate \\| nil)`    | `pb.State`      | set new pb state and retrieve the old one               |\n\n#### Schema loading\n\n`pb.load()` accepts the schema binary data and returns a boolean indicates the result of loading, success or failure, and a offset reading in schema so far that is useful to figure out the reason of failure.\n\n#### Type Information\n\nUsing `pb.(type|field)[s]()` functions retrieve type information for loaded messages.  \n\n`pb.type()` returns multiple informations for specified type:\n\n- name : the full qualifier name of type, e.g. ".package.TypeName"\n- basename: the type name without package prefix, e.g. "TypeName"\n- `"map"` | `"enum"` | `"message"`: whether the type is a map_entry type, enum type or message type.\n\n`pb.types()` returns a iterators, behavior like call `pb.type()` on every types of all messages.\n\n```lua\nprint(pb.type "MyType")\n\n-- list all types that loaded into pb\nfor name, basename, type in pb.types() do\n  print(name, basename, type)\nend\n```\n\n`pb.field()` returns information of the specified field for one type:\n\n- name: the name of the field\n- number: number of field in the schema\n- type: field type\n- default value: if no default value, nil\n- `"packed"`|`"repeated"`| `"optional"`: label of the field, optional or repeated, required is not supported\n- [oneof_name, oneof_index]: if this is a `oneof` field, this is the `oneof` name and index\n\nAnd `pb.fields()` iterates all fields in a message:\n\n```lua\nprint(pb.field("MyType", "the_first_field"))\n\n-- notice that you needn\'t receive all return values from iterator\nfor name, number, type in pb.fields "MyType" do\n  print(name, number, type)\nend\n```\n\n`pb.enum()` maps from enum name and value:\n\n```lua\nprotoc:load [[\nenum Color { Red = 1; Green = 2; Blue = 3 }\n]]\nprint(pb.enum("Color", "Red")) --> 1\nprint(pb.enum("Color", 2)) --> "Green"\n```\n\n#### Default Values\n\nUsing `pb.defaults()` to get a table with all default values from a message. this table will be used as the metatable of the corresponding decoded message table when setting `use_default_metatable` option.\n\n```lua\n   check_load [[\n      message TestDefault {\n         optional int32 defaulted_int = 10 [ default = 777 ];\n         optional bool defaulted_bool = 11 [ default = true ];\n         optional string defaulted_str = 12 [ default = "foo" ];\n         optional float defaulted_num = 13 [ default = 0.125 ];\n      } ]]\n   print(require "serpent".block(pb.defaults "TestDefault"))\n-- output:\n-- {\n--   defaulted_bool = true,\n--   defaulted_int = 777,\n--   defaulted_num = 0.125,\n--   defaulted_str = "foo"\n-- } --[[table: 0x7f8c1e52b050]]\n\n```\n\n#### Hooks\n\nIf set `pb.option "enable_hooks"`, the hook function will enabled. you could use `pb.hook()` to set or get a hook function. call it with type name directly get current setted hook. call it with two arguments to set a hook. and call it with `nil` as the second argument to remove the hook. in all case, the original one will be returned.\n\nAfter the hook function setted and hook enabled, the function will be called *after* a message get decoded. So you could get all values in the table passed to hook function. That\'s the only argument of hook.\n\nIf you need type name in hook functions, use this helper:\n\n```lua\nlocal function make_hook(name, func)\n  return pb.hook(name, function(t)\n    return func(name, t)\n  end)\nend\n```\n\n#### Options\n\nSetting options to change the behavior of other routines.\nThese options are supported currently:\n\n| Option                  | Description                                                  |\n| ----------------------- | ------------------------------------------------------------ |\n| `enum_as_name`          | set value to enum name when decode a enum **(default)**      |\n| `enum_as_value`         | set value to enum value when decode a enum                   |\n| `int64_as_number`       | set value to integer when it fit int32, otherwise return a number **(default)** |\n| `int64_as_string`       | same as above, but when it not fit int32, return a string instead |\n| `int64_as_hexstring`    | same as above, but return a hexadigit string instead         |\n| `no_default_values`     | do not default values for decoded message table **(default)** |\n| `use_default_values`    | set default values by copy values from default table before decode |\n| `use_default_metatable` | set default values by set table from `pb.default()` as the metatable |\n| `enable_hooks`          | `pb.decode` will call `pb.hooks()` hook functions            |\n| `disable_hooks`         | `pb.decode` do not call hooks **(default)**                  |\n\n *Note*: The string returned by `int64_as_string` or `int64_as_hexstring` will prefix a `\'#\'` character. Because Lua may convert between string with number, prefix a `\'#\'` makes Lua return the string as-is.\n\nall routines in all module accepts `\'#\'` prefix `string`/`hex string` as arguments regardless of the option setting.\n\n#### Multiple State\n\n`pb` module support multiple states. A state is a database that contains all type information of registered messages. You can retrieve current state by `pb.state()`, or set new state by `pb.state(newstate)`.\n\nUse `pb.state(nil)` to discard current state, but not to set a new one (the following routines call that use the state will create a new default state automatedly). Use `pb.state()` to retrieve current state without setting a new one. e.g.\n\n```lua\nlocal old = pb.state(nil)\n-- if you use protoc.lua, call protoc.reload() here.\nassert(pb.load(...))\n-- do someting ...\npb.state(old)\n```\n\nNotice that if you use `protoc.lua` module, it will register some message to the state, so you should call `proto.reload()` after setting a new state.\n\n\n\n### `pb.io` Module\n\n`pb.io` module reads binary data from a file or `stdin`/`stdout`, `pb.io.read()` reads binary data from a file, or `stdin` if no file name given as the first parameter.\n\n`pb.io.write()` and `pb.io.dump()` are same as Lua\'s `io.write()` except they write binary data.  the former writes data to `stdout`, and the latter writes data to a file specified by the first parameter as the file name.\n\nAll these functions return a true value when success, and return `nil, errmsg` when an error occurs.\n\n| Function               | Returns | Description                         |\n| ---------------------- | ------- | ----------------------------------- |\n| `io.read()`            | string  | read all binary data from `stdin`   |\n| `io.read(string)`      | string  | read all binary data from file name |\n| `io.write(...)`        | true    | write binary data to `stdout`       |\n| `io.dump(string, ...)` | string  | write binary data to file name      |\n\n\n\n### `pb.conv` Module\n\n`pb.conv` provide functions to convert between numbers.\n\n| Encode Function        | Decode Function        |\n| ---------------------- | ---------------------- |\n| `conv.encode_int32()`  | `conv.decode_int32()`  |\n| `conv.encode_uint32()` | `conv.decode_uint32()` |\n| `conv.encode_sint32()` | `conv.decode_sint32()` |\n| `conv.encode_sint64()` | `conv.decode_sint64()` |\n| `conv.encode_float()`  | `conv.decode_float()`  |\n| `conv.encode_double()` | `conv.decode_double()` |\n\n\n\n### `pb.slice` Module\n\nSlice object parse binary protobuf data in a low-level way.  Use `slice.new()` to create a slice object, with the optional offset `i` and `j` to access a subpart of the original data (named a *view*).\n\nA slice object has a stack itself.  calling `s:enter(i, j)` saves current position and enters next level with the optional offset `i` and `j` just as `slice.new()`.  calling `s:leave()` restore the prior view.  `s:level()` returns the current level, and `s:level(n)` returns the current position, the start and the end position information of the `n`th level.  calling `s:enter()` without parameter will read a length delimited type value from the slice and enter the view in reading value.  Using `#a` to get the count of bytes remains in current view.\n\nTo read values from slice, use `slice.unpack()`, it use a format string to control how to read into a slice as below table (same format character are also used in `buffer.pack()`). Notice that you can use `pb.typefmt()` to convert between format and protobuf type names (returned from `pb.field()`).\n\n| Format | Description                                                  |\n| ------ | ------------------------------------------------------------ |\n| v      | variable Int value                                           |\n| d      | 4 bytes fixed32 value                                        |\n| q      | 8 bytes fixed64 value                                        |\n| s      | length delimited value, usually a `string`, `bytes` or `message` in protobuf. |\n| c      | receive a extra number parameter `count` after the format, and reads `count` bytes in slice. |\n| b      | variable int value as a Lua `boolean` value.                 |\n| f      | 4 bytes `fixed32` value as floating point `number` value.    |\n| F      | 8 bytes `fixed64` value as floating point `number` value.    |\n| i      | variable int value as signed int value, i.e. `int32`         |\n| j      | variable int value as zig-zad encoded signed int value, i.e.`sint32` |\n| u      | variable int value as unsigned int value, i.e. `uint32`      |\n| x      | 4 bytes fixed32 value as unsigned fixed32 value, i.e.`fixed32` |\n| y      | 4 bytes fixed32 value as signed fixed32 value, i.e. `sfixed32` |\n| I      | variable int value as signed int value, i.e.`int64`          |\n| J      | variable int value as zig-zad encoded signed int value, i.e. `sint64` |\n| U      | variable int value and treat it as `uint64`                  |\n| X      | 8 bytes fixed64 value as unsigned fixed64 value, i.e. `fixed64` |\n| Y      | 8 bytes fixed64 value as signed fixed64 value, i.e. `sfixed64` |\n\nAnd extra format can be used to control the read cursor in one `slice.unpack()` process:\n\n| Format | Description                                                  |\n| ------ | ------------------------------------------------------------ |\n| @      | returns current cursor position in the slice, related with the beginning of the current view. |\n| *      | set the current cursor position to the extra parameter after format string. |\n| +      | set the relate cursor position, i.e. add the extra parameter to the current position. |\n\ne.g. If you want to read a `varint` value twice, you can write it as:\n\n```lua\nlocal v1, v2 = s:unpack("v*v", 1)\n-- v: reads a `varint` value\n-- *: receive the second parameter 1 and set it to the current cursor position, i.e. restore the cursor to the head of the view\n-- v: reads the first `varint` value again\n```\n\nAll routines in `pb.slice` module:\n\n| Function                  | Returns      | Description                                                  |\n| ------------------------- | ------------ | ------------------------------------------------------------ |\n| `slice.new(data[,i[,j]])` | Slice object | create a new slice object                                    |\n| `s:delete()`              | none         | same as `s:reset()`, free it\'s content                       |\n| `tostring(s)`             | string       | return the string repr of the object                         |\n| `#s`                      | number       | returns the count of bytes can read in current view          |\n| `s:reset([...])`          | self         | reset object to another data                                 |\n| `s:level()`               | number       | returns the count of stored state                            |\n| `s:level(number)`         | p, i, j      | returns the informations of the `n`th stored state           |\n| `s:enter()`               | self         | reads a bytes value, and enter it\'s view                     |\n| `s:enter(i[, j])`         | self         | enter a view start at `i` and ends at `j`, includes          |\n| `s:leave([number])`       | self, n      | leave the number count of level (default 1) and return current level |\n| `s:unpack(fmt, ...)`      | values...    | reads values of current view from slice                      |\n\n\n\n### `pb.buffer` Module\n\nBuffer module used to construct a protobuf data format stream in a low-level way. It\'s just a bytes data buffer. using `buffer.pack()` to append values to the buffer, and `buffer.result()` to get the encoded raw data, or `buffer.tohex()` to get the human-readable hex digit value of data.\n\n `buffer.pack()` use the same format syntax with `slice.unpack()`, and support `\'()\'` format means the inner value will be encoded as a length delimited value, i.e. a message value encoded format.\n\nparenthesis can be nested.\n\ne.g.\n\n```lua\nb:pack("(vvv)", 1, 2, 3) -- get a bytes value that contains three varint value.\n```\n\n\n\n`buffer.pack()` also support \'#\' format, it means prepends a length into the buffer.\n\ne.g.\n\n```lua\nb:pack("#", 5) -- prepends a varint length #b-5+1 at offset 5\n```\n\nAll routines in `pb.buffer` module:\n\n| Function            | Returns       | Description                                                  |\n| ------------------- | ------------- | ------------------------------------------------------------ |\n| `buffer.new([...])` | Buffer object | create a new buffer object, extra args will passed to `b:reset()` |\n| `b:delete()`        | none          | same as `b:reset()`, free it\'s content                       |\n| `tostring(b)`       | string        | returns the string repr of the object                        |\n| `#b`                | number        | returns the encoded count of bytes in buffer                 |\n| `b:reset()`         | self          | reset to a empty buffer                                      |\n| `b:reset([...])`    | self          | resets the buffer and set its content as the concat of it\'s args |\n| `b:tohex([i[, j]])` | string        | return the string of hexadigit represent of the data, `i` and `j` are ranges in encoded data, includes. Omit it means the whole range |\n| `b:result([i[,j]])` | string        | return the raw data, `i` and `j` are ranges in encoded data, includes,. Omit it means the whole range |\n| `b:pack(fmt, ...)`  | self          | encode the values passed to `b:pack()`, use `fmt` to indicate how to encode value |\n\n'