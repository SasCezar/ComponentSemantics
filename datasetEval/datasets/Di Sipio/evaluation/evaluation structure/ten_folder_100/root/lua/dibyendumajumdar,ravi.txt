b'=========================\nRavi Programming Language\n=========================\n\nRavi is a derivative/dialect of `Lua 5.3 <http://www.lua.org/>`_ with limited optional static typing and \nfeatures `LLVM <http://www.llvm.org/>`_ and `Eclipse OMR <https://github.com/dibyendumajumdar/nj>`_ \npowered JIT compilers. The name Ravi comes from the Sanskrit word for the Sun. \nInterestingly a precursor to Lua was `Sol <http://www.lua.org/history.html>`_ which had support for \nstatic types; Sol means the Sun in Portugese.\n\nLua is perfect as a small embeddable dynamic language so why a derivative? Ravi extends Lua with \nstatic typing for improved performance when JIT compilation is enabled. However, the static typing is \noptional and therefore Lua programs are also valid Ravi programs.\n\nThere are other attempts to add static typing to Lua - e.g. `Typed Lua <https://github.com/andremm/typedlua>`_ but \nthese efforts are mostly about adding static type checks in the language while leaving the VM unmodified. \nThe Typed Lua effort is very similar to the approach taken by Typescript in the JavaScript world. \nThe static typing is to aid programming in the large - the code is eventually translated to standard Lua \nand executed in the unmodified Lua VM.\n\nMy motivation is somewhat different - I want to enhance the VM to support more efficient operations when types are \nknown. Type information can be exploited by JIT compilation technology to improve performance. At the same time, \nI want to keep the language safe and therefore usable by non-expert programmers. \n\nOf course there is the fantastic `LuaJIT <http://luajit.org>`_ implementation. Ravi has a different goal compared to \nLuaJIT. Ravi prioritizes ease of maintenance and support, language safety, and compatibility with Lua 5.3, \nover maximum performance. For more detailed comparison please refer to the documentation links below.\n\nFeatures\n========\n* Optional static typing - for details `see the reference manual <https://the-ravi-programming-language.readthedocs.io/en/latest/ravi-reference.html>`_.\n* Type specific bytecodes to improve performance\n* Compatibility with Lua 5.3 (see Compatibility section below)\n* `LLVM <http://www.llvm.org/>`_ powered JIT compiler\n* `Eclipse OMR <https://github.com/dibyendumajumdar/nj>`_ powered JIT compiler\n* Built-in C pre-processor, parser and JIT compiler\n* A `distribution with batteries <https://github.com/dibyendumajumdar/Suravi>`_.\n\nDocumentation\n=============\n* For the Lua extensions in Ravi see the `Reference Manual <https://the-ravi-programming-language.readthedocs.io/en/latest/ravi-reference.html>`_.\n* `OMR JIT Build instructions <https://the-ravi-programming-language.readthedocs.io/en/latest/ravi-omr-instructions.html>`_.\n* `LLVM JIT Build instructions <https://the-ravi-programming-language.readthedocs.io/en/latest/ravi-llvm-instructions.html>`_.\n* Also see `Ravi Documentation <http://the-ravi-programming-language.readthedocs.org/en/latest/index.html>`_.\n* and the slides I presented at the `Lua 2015 Workshop <http://www.lua.org/wshop15.html>`_.\n\nLua Goodies\n===========\n* `An Introduction to Lua <http://the-ravi-programming-language.readthedocs.io/en/latest/lua-introduction.html>`_ attempts to provide a quick overview of Lua for folks coming from other languages.\n* `Lua 5.3 Bytecode Reference <http://the-ravi-programming-language.readthedocs.io/en/latest/lua_bytecode_reference.html>`_ is my attempt to bring up to date the `Lua 5.1 Bytecode Reference <http://luaforge.net/docman/83/98/ANoFrillsIntroToLua51VMInstructions.pdf>`_.\n\nCompatibility with Lua\n======================\nRavi should be able to run all Lua 5.3 programs in interpreted mode, but following should be noted:\n\n* Ravi supports optional typing and enhanced types such as arrays (described above). Programs using these features cannot be run by standard Lua. However all types in Ravi can be passed to Lua functions; operations on Ravi arrays within Lua code will be subject to restrictions as described in the section above on arrays.\n* Values crossing from Lua to Ravi will be subjected to typechecks should these values be assigned to typed variables.\n* Upvalues cannot subvert the static typing of local variables (issue #26) when types are annotated.\n* Certain Lua limits are reduced due to changed byte code structure. These are described below.\n* Ravi uses an extended bytecode which means it is not compatible with Lua 5.3 bytecode.\n\n+-----------------+-------------+-------------+\n| Limit name      | Lua value   | Ravi value  |\n+=================+=============+=============+\n| MAXUPVAL        | 255         | 125         |\n+-----------------+-------------+-------------+\n| LUAI_MAXCCALLS  | 200         | 125         |\n+-----------------+-------------+-------------+\n| MAXREGS         | 255         | 125         |\n+-----------------+-------------+-------------+\n| MAXVARS         | 200         | 125         |\n+-----------------+-------------+-------------+\n| MAXARGLINE      | 250         | 120         |\n+-----------------+-------------+-------------+\n\nWhen JIT compilation is enabled there are following additional constraints:\n\n* Ravi will only execute JITed code from the main Lua thread; any secondary threads (coroutines) execute in interpreter mode.\n* In JITed code tailcalls are implemented as regular calls so unlike the interpreter VM which supports infinite tail recursion JIT compiled code only supports tail recursion to a depth of about 110 (issue #17)\n\nHistory\n=======\n* 2015\n       - Implemented JIT compilation using LLVM\n       - Implemented libgccjit based alternative JIT (now discontinued)\n* 2016\n       - Implemented debugger for Ravi and Lua 5.3 for `Visual Studio Code <https://github.com/dibyendumajumdar/ravi/tree/master/vscode-debugger>`_\n* 2017\n       - Embedded C compiler using dmrC project (C JIT compiler)\n       - Additional type-annotations\n* 2018\n       - Implemented Eclipse OMR JIT backend\n       - Created `Ravi with batteries <https://github.com/dibyendumajumdar/Suravi>`_.\n* 2019 (Plan)\n       - New parser, type checker and code generator\n       - New JIT backend `MIR <https://github.com/vnmakarov/mir>`_. \n       - Release Ravi 1.0\n\nLicense\n=======\nMIT License for LLVM version.\n'