b'# lua-resty-auto-ssl\n\n[![CI](https://github.com/GUI/lua-resty-auto-ssl/workflows/CI/badge.svg)](https://github.com/GUI/lua-resty-auto-ssl/actions?workflow=CI)\n\nOn the fly (and free) SSL registration and renewal inside [OpenResty/nginx](http://openresty.org) with [Let\'s Encrypt](https://letsencrypt.org).\n\nThis OpenResty plugin automatically and transparently issues SSL certificates from Let\'s Encrypt (a free certificate authority) as requests are received. It works like:\n\n- A SSL request for a SNI hostname is received.\n- If the system already has a SSL certificate for that domain, it is immediately returned (with OCSP stapling).\n- If the system does not yet have an SSL certificate for this domain, it issues a new SSL certificate from Let\'s Encrypt. Domain validation is handled for you. After receiving the new certificate (usually within a few seconds), the new certificate is saved, cached, and returned to the client (without dropping the original request).\n\nThis uses the `ssl_certificate_by_lua` functionality in OpenResty 1.9.7.2+.\n\nBy using lua-resty-auto-ssl to register SSL certificates with Let\'s Encrypt, you agree to the [Let\'s Encrypt Subscriber Agreement](https://letsencrypt.org/repository/).\n\n## Status\n\nUsed in production (but the internal APIs might still be in flux).\n\n## Installation\n\nRequirements:\n\n- [OpenResty](http://openresty.org/#Download) 1.9.7.2 or higher\n  - Or nginx patched with [ssl_cert_cb_yield](https://github.com/openresty/openresty/blob/v1.11.2.2/patches/nginx-1.11.2-ssl_cert_cb_yield.patch) and built with [ngx_lua](https://github.com/openresty/lua-nginx-module#installation) 0.10.0 or higher\n- OpenSSL 1.0.2e or higher\n- [LuaRocks](http://openresty.org/#UsingLuaRocks)\n- gcc, make (for initial install via LuaRocks)\n- bash, curl, diff, find, grep, mktemp, sed (these are generally pre-installed on most systems, but may not be included in some minimal containers)\n\n\n```sh\n$ sudo luarocks install lua-resty-auto-ssl\n\n# Create /etc/resty-auto-ssl and make sure it\'s writable by whichever user your\n# nginx workers run as (in this example, "www-data").\n$ sudo mkdir /etc/resty-auto-ssl\n$ sudo chown www-data /etc/resty-auto-ssl\n```\n\nImplement the necessary configuration inside your nginx config. Here is a minimal example:\n\n```nginx\nevents {\n  worker_connections 1024;\n}\n\nhttp {\n  # The "auto_ssl" shared dict should be defined with enough storage space to\n  # hold your certificate data. 1MB of storage holds certificates for\n  # approximately 100 separate domains.\n  lua_shared_dict auto_ssl 1m;\n  # The "auto_ssl_settings" shared dict is used to temporarily store various settings\n  # like the secret used by the hook server on port 8999. Do not change or\n  # omit it.\n  lua_shared_dict auto_ssl_settings 64k;\n\n  # A DNS resolver must be defined for OCSP stapling to function.\n  #\n  # This example uses Google\'s DNS server. You may want to use your system\'s\n  # default DNS servers, which can be found in /etc/resolv.conf. If your network\n  # is not IPv6 compatible, you may wish to disable IPv6 results by using the\n  # "ipv6=off" flag (like "resolver 8.8.8.8 ipv6=off").\n  resolver 8.8.8.8;\n\n  # Initial setup tasks.\n  init_by_lua_block {\n    auto_ssl = (require "resty.auto-ssl").new()\n\n    -- Define a function to determine which SNI domains to automatically handle\n    -- and register new certificates for. Defaults to not allowing any domains,\n    -- so this must be configured.\n    auto_ssl:set("allow_domain", function(domain)\n      return true\n    end)\n\n    auto_ssl:init()\n  }\n\n  init_worker_by_lua_block {\n    auto_ssl:init_worker()\n  }\n\n  # HTTPS server\n  server {\n    listen 443 ssl;\n\n    # Dynamic handler for issuing or returning certs for SNI domains.\n    ssl_certificate_by_lua_block {\n      auto_ssl:ssl_certificate()\n    }\n\n    # You must still define a static ssl_certificate file for nginx to start.\n    #\n    # You may generate a self-signed fallback with:\n    #\n    # openssl req -new -newkey rsa:2048 -days 3650 -nodes -x509 \\\n    #   -subj \'/CN=sni-support-required-for-valid-ssl\' \\\n    #   -keyout /etc/ssl/resty-auto-ssl-fallback.key \\\n    #   -out /etc/ssl/resty-auto-ssl-fallback.crt\n    ssl_certificate /etc/ssl/resty-auto-ssl-fallback.crt;\n    ssl_certificate_key /etc/ssl/resty-auto-ssl-fallback.key;\n  }\n\n  # HTTP server\n  server {\n    listen 80;\n\n    # Endpoint used for performing domain verification with Let\'s Encrypt.\n    location /.well-known/acme-challenge/ {\n      content_by_lua_block {\n        auto_ssl:challenge_server()\n      }\n    }\n  }\n\n  # Internal server running on port 8999 for handling certificate tasks.\n  server {\n    listen 127.0.0.1:8999;\n\n    # Increase the body buffer size, to ensure the internal POSTs can always\n    # parse the full POST contents into memory.\n    client_body_buffer_size 128k;\n    client_max_body_size 128k;\n\n    location / {\n      content_by_lua_block {\n        auto_ssl:hook_server()\n      }\n    }\n  }\n}\n```\n\n## Configuration\n\nAdditional configuration options can be set on the `auto_ssl` instance that is created:\n\n### `allow_domain`\n*Default:* `function(domain, auto_ssl, ssl_options, renewal) return false end`\n\nA function that determines whether the incoming domain should automatically issue a new SSL certificate.\n\nBy default, resty-auto-ssl will not perform any SSL registrations until you define the `allow_domain` function. You may return `true` to handle all possible domains, but be aware that bogus SNI hostnames can then be used to trigger an indefinite number of SSL registration attempts (which will be rejected). A better approach may be to whitelist the allowed domains in some way.\n\nThe callback function\'s arguments are:\n\n- `domain`: The domain of the incoming request.\n- `auto_ssl`: The current auto-ssl instance.\n- `ssl_options`: A table of optional configuration options that were passed to the [`ssl_certificate` function](#ssl_certificate-configuration). This can be used to customize the behavior on a per nginx `server` basis (see example in [`request_domain`](#request_domain)). Note, this option is **not** passed in when this function is called for renewals, so your function should handle that accordingly.\n- `renewal`: Boolean value indicating whether this function is being called during certificate renewal or not. When `true`, the `ssl_options` argument will not be present.\n\nWhen using the Redis storage adapter, you can access the current Redis connection inside the `allow_domain` callback by accessing `auto_ssl.storage.adapter:get_connection()`.\n\n*Example:*\n\n```lua\nauto_ssl:set("allow_domain", function(domain, auto_ssl, ssl_options, renewal)\n  return ngx.re.match(domain, "^(example.com|example.net)$", "ijo")\nend)\n```\n\n### `dir`\n*Default:* `/etc/resty-auto-ssl`\n\nThe base directory used for storing configuration, temporary files, and certificate files (if using the `file` storage adapter). This directory must be writable by the user nginx workers run as.\n\n*Example:*\n\n```lua\nauto_ssl:set("dir", "/some/other/location")\n```\n\n### `renew_check_interval`\n*Default:* `86400`\n\nHow frequently (in seconds) all of the domains should be checked for certificate renewals. Defaults to checking every 1 day. Certificates will automatically be renewed if the expire in less than 30 days.\n\n*Example:*\n\n```lua\nauto_ssl:set("renew_check_interval", 172800)\n```\n\n### `storage_adapter`\n*Default:* `resty.auto-ssl.storage_adapters.file`<br>\n*Options:* `resty.auto-ssl.storage_adapters.file`, `resty.auto-ssl.storage_adapters.redis`\n\nThe storage mechanism used for persistent storage of the SSL certificates. File-based and redis-based storage adapters are supplied, but custom external adapters may also be specified (the value simply needs to be on the `lua_package_path`).\n\nThe default storage adapter persists the certificates to local files. However, you may want to consider another storage adapter (like redis) for a couple reason:\n  - File I/O causes blocking in OpenResty which should be avoided for optimal performance. However, files are only read and written the first time a certificate is seen, and then things are cached in memory, so the actual amount of file I/O should be quite minimal.\n  - Local files won\'t work if the certificates need to be shared across multiple servers (for a load-balanced environment).\n\n*Example:*\n\n```lua\nauto_ssl:set("storage_adapter", "resty.auto-ssl.storage_adapters.redis")\n```\n\n### `redis`\n*Default:* `{ host = "127.0.0.1", port = 6379 }`\n\nIf the `redis` storage adapter is being used, then additional connection options can be specified on this table. Accepts the following options:\n\n- `host`: Host to connect to (defaults to `127.0.0.1`).\n- `port`: Port to connect to (defaults to `6379`).\n- `socket`: Instead of specifying `host` and `port` to connect to, a unix socket path can be given instead (in the format of `"unix:/path/to/unix.sock").`\n- `connect_options`: Additional connection options to pass to the Redis [`connect`](https://github.com/openresty/lua-resty-redis#connect) function.\n- `auth`: Value to pass to the [`AUTH` command](https://github.com/openresty/lua-resty-redis#redis-authentication).\n- `db`: The [Redis database number](https://redis.io/commands/select) used by lua-resty-auto-ssl to save certificates\n- `prefix`: Prefix all keys stored in Redis with this string.\n\n*Example:*\n\n```lua\nauto_ssl:set("redis", {\n  host = "10.10.10.1"\n})\n```\n\n### `request_domain`\n*Default:* `function(ssl, ssl_options) return ssl.server_name() end`\n\nA function that determines the hostname of the request. By default, the SNI domain is used, but a custom function can be implemented to determine the domain name for non-SNI requests (by basing the domain on something that can be determined outside of SSL, like the port or IP address that received the request).\n\nThe callback function\'s arguments are:\n\n- `ssl`: An instance of the [`ngx.ssl`](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md) module.\n- `ssl_options`: A table of optional configuration options that were passed to the [`ssl_certificate` function](#ssl_certificate-configuration). This can be used to customize the behavior on a per nginx `server` basis.\n\n*Example:*\n\nThis example, along with the accompanying nginx `server` blocks, will default to SNI domain names, but for non-SNI clients will respond with predefined hosts based on the connecting port. Connections to port 9000 will register and return a certificate for `foo.example.com`, while connections to port 9001 will register and return a certificate for `bar.example.com`. Any other ports will return the default nginx fallback certificate.\n\n```lua\nauto_ssl:set("request_domain", function(ssl, ssl_options)\n  local domain, err = ssl.server_name()\n  if (not domain or err) and ssl_options and ssl_options["port"] then\n    if ssl_options["port"] == 9000 then\n      domain = "foo.example.com"\n    elseif ssl_options["port"] == 9001 then\n      domain = "bar.example.com"\n    end\n  end\n\n  return domain, err\nend)\n```\n\n```nginx\nserver {\n  listen 9000 ssl;\n  ssl_certificate_by_lua_block {\n    auto_ssl:ssl_certificate({ port = 9000 })\n  }\n}\n\nserver {\n  listen 9001 ssl;\n  ssl_certificate_by_lua_block {\n    auto_ssl:ssl_certificate({ port = 9001 })\n  }\n}\n```\n\n### `ca`\n*Default:* the default Let\'s Encrypt CA\n\nURL of the Let\'s Encrypt environment to use. Normally you should not set this, unless you want make us of Let\'s Encrypts [staging environment](https://letsencrypt.org/docs/staging-environment/).\n\n*Example:*\n\n```lua\nauto_ssl:set("ca", "https://some-other-letsencrypt.org/directory")\n```\n\n### `hook_server_port`\n*Default:* 8999\n\nInternally we use a special server running on port 8999 for handling certificate tasks. The port used for this service may be changed here. Please note that you will also need to change it in your nginx configuration.\n\n*Example:*\n\n```lua\nauto_ssl:set("hook_server_port", 90)\n```\n\n### `json_adapter`\n*Default:* `resty.auto-ssl.json_adapters.cjson`<br>\n*Options:* `resty.auto-ssl.json_adapters.cjson`, `resty.auto-ssl.json_adapters.dkjson`\n\nThe JSON adapter to use for encoding and decoding JSON. Defaults to using [cjson](https://github.com/openresty/lua-cjson), which is bundled with OpenResty installations and should probably be used in most cases. However, an adapter using the pure Lua [dkjson](https://luarocks.org/modules/dhkolf/dkjson) can be used for environments where cjson may not be available (you will need to manually install the dkjson dependency via luarocks to use this adapter).\n\ncjson and dkjson json adapters are supplied, but custom external adapters may also be specified (the value simply needs to be on the `lua_package_path`).\n\n*Example:*\n\n```lua\nauto_ssl:set("json_adapter", "resty.auto-ssl.json_adapters.dkjson")\n```\n\n### `http_proxy_options`\n*Default:* `nil`\n\nConfigure an HTTP proxy to use when making OCSP stapling requests. Accepts a table of options for [lua-resty-http\'s `set_proxy_options`](https://github.com/ledgetech/lua-resty-http#set_proxy_options).\n\n*Example:*\n\n```lua\nauto_ssl:set("http_proxy_options", {\n  http_proxy = "http://localhost:3128",\n})\n```\n\n## `ssl_certificate` Configuration\n\nThe `ssl_certificate` function accepts an optional table of configuration options. These options can be used to customize and control the SSL behavior on a per nginx `server` basis. Some built-in options may control the default behavior of lua-resty-auto-ssl, but any other custom data can be given as options, which will then be passed along to the [`allow_domain`](#allow_domain) and [`request_domain`](#request_domain) callback functions.\n\nBuilt-in configuration options:\n\n### `generate_certs`\n*Default:* true\n\nThis variable can be used to disable generating certs on a per server block location.\n\n*Example:*\n\n```nginx\nserver {\n  listen 8443 ssl;\n  ssl_certificate_by_lua_block {\n    auto_ssl:ssl_certificate({ generate_certs = false })\n  }\n}\n```\n\n### Advanced Let\'s Encrypt Configuration\n\nInternally, lua-resty-auto-ssl uses [dehydrated](https://github.com/lukas2511/dehydrated) as it\'s Let\'s Encrypt client. If you\'d like to adjust lower-level settings, like the private key size, public key algorithm, or your registration e-mail, these settings can be configured in a custom dehydrated configuration file.\n\n- For a full list of supported options, see [dehydrated\'s example config](https://github.com/lukas2511/dehydrated/blob/v0.4.0/docs/examples/config).\n- Custom dehydrated configuration files can be placed inside the `/etc/resty-auto-ssl/letsencrypt/conf.d` directory by default (or adjust the path if you\'ve changed the default lua-resty-auto-ssl `dir` setting).\n\nExample `/etc/resty-auto-ssl/letsencrypt/conf.d/custom.sh`:\n\n```sh\nKEYSIZE="4096"\nKEY_ALGO="rsa"\nCONTACT_EMAIL="foo@example.com"\n```\n\n## Precautions\n\n- **Allowed Hosts:** By default, resty-auto-ssl will not perform any SSL registrations until you define the `allow_domain` function. You may return `true` to handle all possible domains, but be aware that bogus SNI hostnames can then be used to trigger an indefinite number of SSL registration attempts (which will be rejected). A better approach may be to whitelist the allowed domains in some way.\n- **Untrusted Code:** Ensure your OpenResty server where this is installed cannot execute untrusted code. The certificates and private keys have to be readable by the web server user, so it\'s important that this data is not compromised.\n- **File Storage:** The default storage adapter persists the certificates to local files. However, you may want to consider another storage adapter (like redis) for a couple reason:\n  - File I/O causes blocking in OpenResty which should be avoided for optimal performance. However, files are only read and written the first time a certificate is seen, and then things are cached in memory, so the actual amount of file I/O should be quite minimal.\n  - Local files won\'t work if the certificates need to be shared across multiple servers (for a load-balanced environment).\n\n\n## Development\n\nAfter checking out the repo, Docker can be used to run the test suite:\n\n```sh\n$ docker-compose run --rm app make test\n```\n\nTests can be found in the [`spec`](https://github.com/GUI/lua-resty-auto-ssl/tree/master/spec) directory, and the test suite is implemented using [busted](http://olivinelabs.com/busted/).\n\n### Release Process\n\nTo release a new version to LuaRocks:\n\n- Ensure `CHANGELOG.md` is up to date.\n- Move the rockspec file to the new version number (`git mv lua-resty-auto-ssl-X.X.X-1.rockspec lua-resty-auto-ssl-X.X.X-1.rockspec`), and update the `version` and `tag` variables in the rockspec file.\n- Commit and tag the release (`git tag -a vX.X.X -m "Tagging vX.X.X" && git push origin vX.X.X`).\n- Run `make release VERSION=X.X.X`.\n- Copy the CHANGELOG notes into a [new GitHub Release](https://github.com/GUI/lua-resty-auto-ssl/releases/new).\n\n## Credits\n\n**[dehydrated](https://github.com/lukas2511/dehydrated)** is the client used internally that does all the heavy lifting with Let\'s Encrypt.\n\n## TODO\n\n- Document and formalize the API for other storage adapters.\n- Open source the MongoDB storage adapter we\'re using in API Umbrella.\n- Add the ability to encrypt data at rest for any storage adapter (based on what we built for API Umbrella\'s MongoDB storage adapter).\n- We currently rely on [dehydrated](https://github.com/lukas2511/dehydrated) as our Let\'s Encrypt client. It\'s called in a non-blocking fashion via [lua-resty-shell](https://github.com/juce/lua-resty-shell) and [sockproc](https://github.com/juce/sockproc), however it might be simpler to eventually replace this approach with a native OpenResty Let\'s Encrypt client someday.\n'