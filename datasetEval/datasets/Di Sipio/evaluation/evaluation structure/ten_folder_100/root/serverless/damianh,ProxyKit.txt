b'![Image](logo.png)\n\n# ProxyKit [![NuGet][nuget badge]][nuget package] [![Feedz][feedz badge]][feedz package]\n\nA toolkit to create code-first **HTTP Reverse Proxies** hosted in ASP.NET Core as middleware. This\nallows focused code-first proxies that can be embedded in existing ASP.NET Core\napplications or deployed as a standalone server. Deployable anywhere ASP.NET\nCore is deployable such as Windows, Linux, Containers and Serverless (with\ncaveats).\n\nHaving built proxies many times before, I felt it is time to make a package. Forked\nfrom [ASP.NET labs][aspnet labs], it has been heavily modified with a different\nAPI, to facilitate a wider variety of proxying scenarios (i.e. routing based on\na JWT claim) and interception of the proxy requests / responses for\ncustomization of headers and (optionally) request / response bodies. It also\nuses [`HttpClientFactory`] internally that will mitigate against DNS caching\nissues making it suitable for microservice / container environments.\n\n<!-- TOC depthFrom:2 -->\n\n- [1. Quick Start](#1-quick-start)\n    - [1.1. Install](#11-install)\n    - [1.2. Forward HTTP Requests](#12-forward-http-requests)\n    - [1.3. Forward WebSocket Requests](#13-forward-websocket-requests)\n- [2. Core Features](#2-core-features)\n    - [2.1. Customising the upstream HTTP request](#21-customising-the-upstream-http-request)\n    - [2.2. Customising the upstream response](#22-customising-the-upstream-response)\n    - [2.3. X-Forwarded Headers](#23-x-forwarded-headers)\n        - [2.3.1. Client Sent X-Forwarded-Headers](#231-client-sent-x-forwarded-headers)\n        - [2.3.2. Adding `X-Forwarded-*` Headers](#232-adding-x-forwarded--headers)\n        - [2.3.3. Copying `X-Forwarded` headers](#233-copying-x-forwarded-headers)\n    - [2.4. Configuring ProxyKit\'s HttpClient](#24-configuring-proxykits-httpclient)\n    - [2.5. Error handling](#25-error-handling)\n    - [2.6. Testing](#26-testing)\n    - [2.7. Load Balancing](#27-load-balancing)\n        - [2.7.1. Weighted Round Robin](#271-weighted-round-robin)\n    - [2.8. Typed Handlers](#28-typed-handlers)\n- [3. Recipes](#3-recipes)\n    - [3.1. Simple Forwarding](#31-simple-forwarding)\n    - [3.2. Proxy Paths](#32-proxy-paths)\n    - [3.3. Claims Based Tenant Routing](#33-claims-based-tenant-routing)\n    - [3.4. Authentication offloading with Identity Server](#34-authentication-offloading-with-identity-server)\n    - [3.5. Weighted Round Robin Load Balancing](#35-weighted-round-robin-load-balancing)\n    - [3.6. In-memory Testing](#36-in-memory-testing)\n    - [3.7. Customise Upstream Requests](#37-customise-upstream-requests)\n    - [3.8. Customise Upstream Responses](#38-customise-upstream-responses)\n    - [3.9. Consul Service Discovery](#39-consul-service-discovery)\n    - [3.10. Copy X-Forwarded Headers](#310-copy-x-forwarded-headers)\n    - [3.11. Caching Upstream Responses with CacheCow](#311-caching-upstream-responses-with-cachecow)\n    - [3.12. Conditional Proxying](#312-conditional-proxying)\n    - [3.13. Client Certificate](#313-client-certificate)\n    - [3.14. Source IP Blocking](#314-source-ip-blocking)\n    - [3.15. WebSockets](#315-websockets)\n    - [3.16. SignalR](#316-signalr)\n    - [3.17. SignalR with Path](#317-signalr-with-path)\n    - [3.18. Automatic Decompression](#318-automatic-decompression)\n- [4. Making upstream servers reverse proxy friendly](#4-making-upstream-servers-reverse-proxy-friendly)\n- [5. Performance considerations](#5-performance-considerations)\n- [6. Note about serverless](#6-note-about-serverless)\n- [7. Comparison with Ocelot](#7-comparison-with-ocelot)\n- [8. How to build](#8-how-to-build)\n- [9. Contributing / Feedback / Questions](#9-contributing--feedback--questions)\n- [10. Articles, blogs and other external links](#10-articles-blogs-and-other-external-links)\n\n<!-- /TOC -->\n\n## 1. Quick Start\n\n### 1.1. Install\n\nProxyKit is a `NetStandard2.0` package. Install into your ASP.NET Core project:\n\n```bash\ndotnet add package ProxyKit\n```\n\n### 1.2. Forward HTTP Requests\n\nIn your `Startup`, add the proxy service:\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    ...\n    services.AddProxy();\n    ...\n}\n```\n\nForward HTTP requests to `upstream-server:5001`:\n\n```csharp\npublic void Configure(IApplicationBuilder app)\n{\n    app.RunProxy(context => context\n        .ForwardTo("http://upstream-server:5001/")\n        .AddXForwardedHeaders()\n        .Send());\n}\n```\n\nWhat is happening here?\n\n 1. `context.ForwardTo(upstreamHost)` is an extension method on\n    `HttpContext` that creates and initializes an `HttpRequestMessage` with\n    the original request headers copied over, yielding a `ForwardContext`.\n 2. `AddXForwardedHeaders` adds `X-Forwarded-For`, `X-Forwarded-Host`,\n    `X-Forwarded-Proto` and `X-Forwarded-PathBase` headers to the upstream\n    request.\n 3. `Send` Sends the forward request to the upstream server and returns an\n    `HttpResponseMessage`.\n 4. The proxy middleware then takes the response and applies it to\n    `HttpContext.Response`.\n\nNote: `RunProxy` is [terminal] - anything added to the pipeline _after_\n`RunProxy` will never be executed.\n\n### 1.3. Forward WebSocket Requests\n\nForward WebSocket requests to `upstream-server:5002`:\n\n```csharp\npublic void Configure(IApplicationBuilder app)\n{\n    app.UseWebSockets();\n    app.UseWebSocketProxy(\n        context => new Uri("ws://upstream-host:80/"),\n        options => options.AddXForwardedHeaders());\n}\n```\n\nWhat is happening here?\n\n 1. `app.UseWebSockets()` must first be added otherwise websocket requests will\n    never be handled by ProxyKit.\n 2. The first parameter must return the URI of the upstream host with a scheme\n    of `ws://`.\n 3. The second parameter `options` allows you to do some customisation of the\n    initial upstream requests such as adding some headers.\n\n## 2. Core Features\n\n### 2.1. Customising the upstream HTTP request\n\nOne can modify the upstream request headers prior to sending them to suit\ncustomisation needs. ProxyKit doesn\'t add, remove, nor modify any headers by\ndefault; one must opt in any behaviours explicitly.\n\nIn this example we will add a `X-Correlation-ID` header if the incoming request does not bear one:\n\n```csharp\npublic const string XCorrelationId = "X-Correlation-ID";\n\npublic void Configure(IApplicationBuilder app)\n{\n    app.RunProxy(context =>\n    {\n        var forwardContext = context.ForwardTo("http://upstream-server:5001/");\n        if (!forwardContext.UpstreamRequest.Headers.Contains(XCorrelationId))\n        {\n            forwardContext.UpstreamRequest.Headers.Add(XCorrelationId, Guid.NewGuid().ToString());\n        }\n        return forwardContext.Send();\n    });\n}\n```\n\nThis can be encapsulated as an extension method:\n\n```csharp\npublic static class CorrelationIdExtensions\n{\n    public const string XCorrelationId = "X-Correlation-ID";\n    \n    public static ForwardContext ApplyCorrelationId(this ForwardContext forwardContext)\n    {\n        if (!forwardContext.UpstreamRequest.Headers.Contains(XCorrelationId))\n        {\n            forwardContext.UpstreamRequest.Headers.Add(XCorrelationId, Guid.NewGuid().ToString());\n        }\n        return forwardContext;\n    }\n}\n```\n\n... making the proxy code a little nicer to read:\n\n```csharp\npublic void Configure(IApplicationBuilder app)\n{\n    app.RunProxy(context => context\n        .ForwardTo("http://upstream-server:5001/")\n        .ApplyCorrelationId()\n        .Send());\n}\n```\n\n### 2.2. Customising the upstream response\n\nThe response from an upstream server can be modified before it is sent to the\nclient. In this example we are removing a header:\n\n```csharp\npublic void Configure(IApplicationBuilder app)\n{\n    app.RunProxy(async context =>\n    {\n        var response = await context\n            .ForwardTo("http://localhost:5001/")\n            .Send();\n\n        response.Headers.Remove("MachineID");\n\n        return response;\n    });\n}\n```\n\n### 2.3. X-Forwarded Headers\n\n#### 2.3.1. Client Sent X-Forwarded-Headers \n\n:warning: To mitigate against spoofing attacks and misconfiguration ProxyKit\ndoes not copy `X-Forward-*` headers from the incoming request to the upstream\nrequest by default. Copying them requires opting in; see _2.3.3 Copying\nX-Forwarded headers_ below.\n\n#### 2.3.2. Adding `X-Forwarded-*` Headers\n\nMany applications will need to know what their "outside" host / URL is in order\nto generate correct values. This is achieved using `X-Forwarded-*` and\n`Forwarded` headers. ProxyKit supports applying `X-Forward-*` headers out of the\nbox (applying `Forwarded` headers support is on backlog). At the time of writing,\n`Forwarded` is [not supported](https://github.com/aspnet/AspNetCore/issues/5978)\nin ASP.NET Core.\n\nTo add `X-Forwarded-*` headers to the request to the upstream server:\n\n```csharp\npublic void Configure(IApplicationBuilder app)\n{\n    app.RunProxy(context => context\n        .ForwardTo("http://upstream-server:5001/")\n        .AddXForwardedHeaders()\n        .Send());\n}\n```\n\nThis will add `X-Forwarded-For`, `X-Forwarded-Host` and `X-Forwarded-Proto`\nheaders to the upstream request using values from `HttpContext`. If the proxy\nmiddleware is hosted on a path and a `PathBase` exists on the request, then an\n`X-Forwarded-PathBase` is also added.\n\n#### 2.3.3. Copying `X-Forwarded` headers\n\nChaining proxies is a common pattern in more complex setups. In this case, if\nthe proxy is an "internal" proxy, you will want to copy the "X-Forwarded-*"\nheaders from previous proxy. To do so, use `CopyXForwardedHeaders()`:\n\n```csharp\npublic void Configure(IApplicationBuilder app)\n{\n    app.RunProxy(context => context\n        .ForwardTo("http://upstream-server:5001/")\n        .CopyXForwardedHeaders()\n        .Send());\n}\n```\n\nYou may optionally also add the "internal" proxy details to the `X-Forwarded-*`\nheader values by combining `CopyXForwardedHeaders()` and\n`AddXForwardedHeaders()` (*note the order is important*):\n\n```csharp\npublic void Configure(IApplicationBuilder app)\n{\n    app.RunProxy(context => context\n        .ForwardTo("http://upstream-server:5001/")\n        .CopyXForwardedHeaders()\n        .AddXForwardedHeaders()\n        .Send());\n}\n```\n\n### 2.4. Configuring ProxyKit\'s HttpClient\n\nWhen adding the Proxy to your application\'s service collection, there is an\nopportunity to configure the internal HttpClient. As\n[`HttpClientFactory`](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)\nis used, its builder is exposed for you to configure:\n\n```csharp\nservices.AddProxy(httpClientBuilder => /* configure http client builder */);\n```\n\nBelow are two examples of what you might want to do:\n\n1. Configure the HTTP Client\'s timeout to 5 seconds:\n\n    ```csharp\n    services.AddProxy(httpClientBuilder =>\n        httpClientBuilder.ConfigureHttpClient =\n            client => client.Timeout = TimeSpan.FromSeconds(5));\n    ```\n\n2. Configure the primary `HttpMessageHandler`. This is typically used in testing\n   to inject a test handler (see _Testing_ below). \n\n    ```csharp\n    services.AddProxy(httpClientBuilder =>\n        httpClientBuilder.ConfigurePrimaryHttpMessageHandler = \n            () => _testMessageHandler);\n    ```\n\n### 2.5. Error handling\n\nWhen `HttpClient` throws, the following logic applies:\n\n1. When upstream server is not reachable, then `503 ServiceUnavailable` is returned.\n2. When upstream server is slow and client timeouts, then `504 GatewayTimeout` is\n   returned.\n\nNot all exception scenarios and variations are caught, which may result in a\n`InternalServerError` being returned to your clients. Please create an issue if\na scenario is missing.\n\n### 2.6. Testing\n\nAs ProxyKit is a standard ASP.NET Core middleware, it can be tested using the\nstandard in-memory `TestServer` mechanism.\n\nOften you will want to test ProxyKit with your application and perhaps test the\nbehaviour of your application when load balanced with two or more instances as\nindicated below.\n\n```\n                               +----------+\n                               |"Outside" |\n                               |HttpClient|\n                               +-----+----+\n                                     |\n                                     |\n                                     |\n                         +-----------+---------+\n    +-------------------->RoutingMessageHandler|\n    |                    +-----------+---------+\n    |                                |\n    |                                |\n    |           +--------------------+-------------------------+\n    |           |                    |                         |\n+---+-----------v----+      +--------v---------+     +---------v--------+\n|Proxy TestServer    |      |Host1 TestServer  |     |Host2 TestServer  |\n|with Routing Handler|      |HttpMessageHandler|     |HttpMessageHandler|\n+--------------------+      +------------------+     +------------------+\n```\n\n`RoutingMessageHandler` is an `HttpMessageHandler` that will route requests\nto specific hosts based on the origin it is configured with. For ProxyKit\nto forward requests (in memory) to the upstream hosts, it needs to be configured\nto use the `RoutingMessageHandler` as its primary `HttpMessageHandler`.\n\nFull example can been viewed in [Recipe 6](src/Recipes/06_Testing.cs).\n\n### 2.7. Load Balancing\n\nLoad balancing is a mechanism to decide which upstream server to forward the\nrequest to. Out of the box, ProxyKit currently supports one type of\nload balancing - Weighted Round Robin. Other types are planned.\n\n#### 2.7.1. Weighted Round Robin\n\nRound Robin simply distributes requests as they arrive to the next host in a\ndistribution list. With optional weighting, more requests are sent to the host with\nthe greater weight.\n\n```csharp\npublic void Configure(IApplicationBuilder app)\n{\n    var roundRobin = new RoundRobin\n    {\n        new UpstreamHost("http://localhost:5001/", weight: 1),\n        new UpstreamHost("http://localhost:5002/", weight: 2)\n    };\n\n    app.RunProxy(\n        async context =>\n        {\n            var host = roundRobin.Next();\n\n            return await context\n                .ForwardTo(host)\n                .Send();\n        });\n}\n```\n\n### 2.8. Typed Handlers\n\n_New in version 2.1.0_\n\nInstead of specifying a delegate, it is possible to use a typed handler. The\nreason you may want to do this is when you want to better leverage dependency\ninjection.\n\nTyped handlers must implement `IProxyHandler` that has a single method with same\nsignature as `HandleProxyRequest`. In this example our typed handler has a\ndependency on an imaginary service to lookup hosts:\n\n```csharp\npublic class MyTypedHandler : IProxyHandler\n{\n    private IUpstreamHostLookup _upstreamHostLookup;\n\n    public MyTypeHandler(IUpstreamHostLookup upstreamHostLookup)\n    {\n        _upstreamHostLookup = upstreamHostLookup;\n    }\n\n    public Task<HttpResponseMessage> HandleProxyRequest(HttpContext context)\n    {\n        var upstreamHost = _upstreamHostLookup.Find(context);\n        return context\n            .ForwardTo(upstreamHost)\n            .AddXForwardedHeaders()\n            .Send();\n    }\n}\n```\n\nWe then need to register our typed handler service:\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    ...\n    services.AddSingleton<MyTypedHandler>();\n    ...\n}\n```\n\nWhen adding the proxy to the pipeline, use the generic form:\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    ...\n    appInner.RunProxy<MyTypedHandler>());\n    ...\n}\n```\n\n## 3. Recipes\n\nRecipes are code samples that help you create proxy solutions for your needs.\nIf you have any ideas for a recipe, or can spot any improvements to the ones\nbelow, please send a pull request! Recipes that stand test of time may be\npromoted to an out-of-the-box feature in a future version of ProxyKit.\n\n### 3.1. Simple Forwarding\n\nForward request to a single upstream host.\n\n[src/Recipes/01_Simple.cs](src/Recipes/01_Simple.cs)\n\n### 3.2. Proxy Paths\n\nHosting multiple proxies on separate paths.\n\n[src/Recipes/02_Paths.cs](src/Recipes/02_Paths.cs)\n\n### 3.3. Claims Based Tenant Routing\n\nRouting to a specific upstream host based on a `TenantId` claim for an\nauthenticated user.\n\n[src/Recipes/03_TenantRouting.cs](src/Recipes/03_TenantRouting.cs)\n\n### 3.4. Authentication offloading with Identity Server\n\nUsing [IdentityServer](https://identityserver.io/) to handle authentication\nbefore forwarding to upstream host.\n\n[src/Recipes/04_IdSrv.cs](src/Recipes/04_IdSrv.cs)\n\n### 3.5. Weighted Round Robin Load Balancing\n\nWeighted Round Robin load balancing to two upstream hosts.\n\n[src/Recipes/05_RoundRobin.cs](src/Recipes/05_RoundRobin.cs)\n\n### 3.6. In-memory Testing\n\nTesting behaviour or your ASP.NET Core application by running two instances\nbehind round robin proxy. Really useful if your application has eventually\nconsistent aspects.\n\n[src/Recipes/06_Testing.cs](src/Recipes/06_Testing.cs)\n\n### 3.7. Customise Upstream Requests\n\nCustomise the upstream request by adding a header.\n\n[src/Recipes/07_CustomiseUpstreamRequest.cs](src/Recipes/07_CustomiseUpstreamRequest.cs)\n\n### 3.8. Customise Upstream Responses\n\nCustomise the upstream response by removing a header.\n\n[src/Recipes/08_CustomiseUpstreamResponse.cs](src/Recipes/08_CustomiseUpstreamResponse.cs)\n\n### 3.9. Consul Service Discovery\n\nService discovery for an upstream host using [Consul](https://www.consul.io/).\n\n[src/Recipes/09_ConsulServiceDisco.cs](src/Recipes/09_ConsulServiceDisco.cs)\n\n### 3.10. Copy X-Forwarded Headers\n\nCopies `X-Forwarded-For`, `X-Forwarded-Host`, `X-Forwarded-Proto` and\n`X-Forwarded-PathBase` headers from the incoming request. Typically only done\nwhen the proxy is in a chain of known proxies. Is it NOT recommended that you\nblindly accept these headers from the public Internet.\n\n[src/Recipes/10_CopyXForwarded.cs](src/Recipes/10_CopyXForwarded.cs)\n\n### 3.11. Caching Upstream Responses with CacheCow\n\nUsing [CacheCow.Client](https://github.com/aliostad/CacheCow) to cache responses\nfrom upstream servers using standard HTTP caching headers.\n\n[src/Recipes/11_CachingWithCacheCow.cs](src/Recipes/11_CachingWithCacheCow.cs)\n\n### 3.12. Conditional Proxying\n\nUsing `app.UseWhen()` to conditionally forward the request based on asserting a\nvalue on `HttpContext`.\n\n[src/Recipes/12_ConditionalProxying.cs](src/Recipes/12_ConditionalProxying.cs)\n\n### 3.13. Client Certificate\n\nUsing a client certificate in requests to upstream hosts.\n\n[src/Recipes/13_ClientCertificate.cs](src/Recipes/13_ClientCertificate.cs)\n\n### 3.14. Source IP Blocking\n\nBlock requests from sources whose IP addresses is not allowed.\n\n[src/Recipes/14_SourceIPBlocking.cs](src/Recipes/14_SourceIPBlocking.cs)\n\n### 3.15. WebSockets\n\nHow to proxy WebSocket connections.\n\n[src/Recipes/14_WebSockets.cs](src/Recipes/15_WebSockets.cs)\n\n### 3.16. SignalR\n\nProxying for SignalR whose protocol requires both HTTP and WebSocket forwarding\nto upstream hosts.\n\n[src/Recipes/16_SignalR.cs](src/Recipes/16_SignalR.cs)\n\n### 3.17. SignalR with Path\n\nProxying for SignalR on a specific path.\n\n[src/Recipes/17_SignalROnPath.cs](src/Recipes/17_SignalROnPath.cs)\n\n### 3.18. Automatic Decompression\n\nAutomatic decompression of responses from upstream hosts allowing response body\nmanipulation.\n\n[src/Recipes/18_AutomaticDecompression.cs](src/Recipes/18_AutomaticDecompression.cs)\n\n## 4. Making upstream servers reverse proxy friendly\n\nApplications that are deployed behind a reverse proxy typically need to be\nsomewhat aware of that so they can generate correct URLs and paths when\nresponding to a browser. That is, they look at `X-Forward-*` / `Forwarded`\nheaders and use their values.\n\nIn ASP.NET Core, this means using the `ForwardedHeaders` middleware in your\napplication. Please refer to the [documentation][forwarded headers middleware]\nfor correct usage (and note the security advisory!).\n\n**Note:** the Forwarded Headers middleware does not support\n`X-Forwarded-PathBase`. This means if you proxy `http://example.com/foo/` to\n`http://upstream-host/` the `/foo/` part is lost and absolute URLs cannot be\ngenerated unless you configure your application\'s `PathBase` directly.\n\nRelated issues and discussions:\n\n- https://github.com/aspnet/AspNetCore/issues/5978\n- https://github.com/aspnet/AspNetCore/issues/5898\n\nTo support PathBase dynamically in your application with `X-Forwarded-PathBase`,\nexamine the header early in your pipeline and set the `PathBase` accordingly:\n\n```csharp\nvar options = new ForwardedHeadersOptions\n{\n   ...\n};\napp.UseForwardedHeaders(options);\napp.Use((context, next) => \n{\n    if (context.Request.Headers.TryGetValue("X-Forwarded-PathBase", out var pathBases))\n    {\n        context.Request.PathBase = pathBases.First();\n    }\n    return next();\n});\n```\n\nAlternatively you can use ProxyKit\'s `UseXForwardedHeaders` extension that\nperforms the same as the above (including calling `UseForwardedHeaders`):\n\n```csharp\nvar options = new ForwardedHeadersOptions\n{\n   ...\n};\napp.UseXForwardedHeaders(options);\n```\n\n## 5. Performance considerations\n\nAccording to TechEmpower\'s Web Framework Benchmarks, ASP.NET Core [is up there\nwith the fastest for plain\ntext](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext).\nAs ProxyKit simply captures headers and async copies request and response body\nstreams, it will be fast enough for most scenarios.\n\nIf absolute raw throughput is a concern for you, then\nconsider nginx or alternatives. For me being able to create flexible proxies\nusing C# is a reasonable tradeoff for the (small) performance cost. Note that\nwhat your specific proxy (and its specific configuration) does will impact performance\nso you should measure for yourself in your context.\n\nOn Windows, ProxyKit is ~3x faster than nginx. However, nginx has clearly\ndocumented that [it has known\nperformance issues on Windows](https://nginx.org/en/docs/windows.html). Since\none wouldn\'t be running production nginx on Windows, this comparison is\nacademic.\n\nMemory wise, ProxyKit maintained a steady ~20MB of RAM after processing millions\nof requests for simple forwarding. Again, it depends on what your proxy does so\nyou should analyse and measure yourself.\n\n## 6. Note about serverless\n\nWhilst it is possible to run full ASP.NET Core web application in [AWS\nLambda] and [Azure Functions] it should be noted that Serverless systems are\nmessage based and not stream based. Incoming and outgoing HTTP request messages\nwill be buffered and potentially encoded as Base64 if binary (so larger). This\nmeans ProxyKit should only be used for API (json) proxying in production on\nServerless. (Though proxying other payloads is fine for dev / exploration /\nquick\'n\'dirty purposes.)\n\n## 7. Comparison with Ocelot\n\n[Ocelot] is an API Gateway that also runs on ASP.NET Core. A key difference\nbetween API Gateways and general Reverse Proxies is that the former tend to be\n**message** based whereas a reverse proxy is **stream** based. That is, an API\nGateway will typically buffer every request and response message to be able\nto perform transformations. This is fine for an API Gateway but not suitable for\na general reverse proxy performance wise nor for responses that are\nchunked-encoded. See [Not Supported Ocelot docs][ocelot not supported].\n\nCombining ProxyKit with Ocelot would give some nice options for a variety of\nscenarios.\n\n## 8. How to build\n\nRequirements: .NET Core SDK 2.2.100 or later.\n\nOn Windows: \n\n```bash\n.\\build.cmd\n```\n\nOn Linux: \n```bash\n./build.sh\n```\n\n## 9. Contributing / Feedback / Questions\n\nAny ideas for features, bugs or questions, please create an issue. Pull requests \ngratefully accepted but please create an issue for discussion first.\n\nI can be reached on twitter at [@randompunter](https://twitter.com/randompunter)\n\n## 10. Articles, blogs and other external links\n\n- [An alternative way to secure SPAs (with ASP.NET Core, OpenID Connect, OAuth 2.0 and ProxyKit)](https://leastprivilege.com/2019/01/18/an-alternative-way-to-secure-spas-with-asp-net-core-openid-connect-oauth-2-0-and-proxykit/)\n\n---\n\n<sub>logo is [distribute](https://thenounproject.com/term/target/345443) by [ChangHoon Baek](https://thenounproject.com/changhoon.baek.50/) from [the Noun Project](https://thenounproject.com/).</sub>\n\n[nuget badge]: https://img.shields.io/nuget/v/ProxyKit.svg\n[nuget package]: https://www.nuget.org/packages/ProxyKit\n[feedz badge]: https://img.shields.io/badge/endpoint.svg?url=https%3A%2F%2Ff.feedz.io%2Fdh%2Foss-ci%2Fshield%2FProxyKit%2Flatest\n[feedz package]: https://f.feedz.io/dh/oss-ci/packages/ProxyKit/latest/download\n[aspnet labs]: https://github.com/aspnet/AspLabs\n[`httpclientfactory`]:  https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests\n[terminal]: https://docs.microsoft.com/en-ie/dotnet/api/microsoft.aspnetcore.builder.runextensions.run?view=aspnetcore-2.1\n[forwarded headers middleware]: https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-2.2\n[aws lambda]: https://aws.amazon.com/blogs/developer/running-serverless-asp-net-core-web-apis-with-amazon-lambda/\n[azure functions]: https://blog.wille-zone.de/post/serverless-webapi-hosting-aspnetcore-webapi-in-azure-functions/\n[ocelot]: https://github.com/ThreeMammals/Ocelot\n[ocelot not supported]: https://ocelot.readthedocs.io/en/latest/introduction/notsupported.html\n'