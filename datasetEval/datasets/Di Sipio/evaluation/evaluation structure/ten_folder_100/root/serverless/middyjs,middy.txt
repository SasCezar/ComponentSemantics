b'<div align="center">\n  <img alt="Middy logo" src="https://raw.githubusercontent.com/middyjs/middy/master/img/middy-logo.png"/>\n</div>\n\n<div align="center">\n  <p><strong>The stylish Node.js middleware engine for AWS Lambda</strong></p>\n</div>\n\n<div align="center">\n<p>\n  <a href="http://badge.fury.io/js/middy">\n    <img src="https://badge.fury.io/js/middy.svg" alt="npm version" style="max-width:100%;">\n  </a>\n  <a href="https://circleci.com/gh/middyjs/middy">\n    <img src="https://circleci.com/gh/middyjs/middy.svg?style=shield" alt="CircleCI" style="max-width:100%;">\n  </a>\n  <a href="https://codecov.io/gh/middyjs/middy">\n    <img src="https://codecov.io/gh/middyjs/middy/branch/master/graph/badge.svg" alt="codecov" style="max-width:100%;">\n  </a>\n  <a href="https://snyk.io/test/github/middyjs/middy">\n    <img src="https://snyk.io/test/github/middyjs/middy/badge.svg" alt="Known Vulnerabilities" data-canonical-src="https://snyk.io/test/github/middyjs/middy" style="max-width:100%;">\n  </a>\n  <a href="https://standardjs.com/">\n    <img src="https://img.shields.io/badge/code_style-standard-brightgreen.svg" alt="Standard Code Style"  style="max-width:100%;">\n  </a>\n  <a href="https://lgtm.com/projects/g/middyjs/middy/context:javascript">\n    <img src="https://img.shields.io/lgtm/grade/javascript/g/middyjs/middy.svg?logo=lgtm&logoWidth=18" alt="Language grade: JavaScript" style="max-width:100%;">\n  </a>\n  <a href="https://greenkeeper.io/">\n    <img src="https://badges.greenkeeper.io/middyjs/middy.svg" alt="Greenkeeper badge"  style="max-width:100%;">\n  </a>\n  <a href="https://gitter.im/middyjs/Lobby">\n    <img src="https://badges.gitter.im/gitterHQ/gitter.svg" alt="Chat on Gitter"  style="max-width:100%;">\n  </a>\n</p>\n</div>\n\n\n## TOC\n\n- [TOC](#toc)\n- [A little appetizer](#a-little-appetizer)\n- [Install](#install)\n- [Requirements](#requirements)\n- [Why?](#why-)\n- [Usage](#usage)\n- [How it works](#how-it-works)\n  * [Execution order](#execution-order)\n  * [Interrupt middleware execution early](#interrupt-middleware-execution-early)\n  * [Handling errors](#handling-errors)\n  * [Promise support](#promise-support)\n  * [Promises and error handling](#promises-and-error-handling)\n  * [Using async/await](#using-asyncawait)\n- [Writing a middleware](#writing-a-middleware)\n  * [Configurable middlewares](#configurable-middlewares)\n  * [Inline middlewares](#inline-middlewares)\n  * [More details on creating middlewares](#more-details-on-creating-middlewares)\n- [Available middlewares](#available-middlewares)\n- [Api](#api)\n- [Typescript](#typescript)\n- [FAQ](#faq)\n  * [Q: Lambda timing out](#q-lambda-timing-out)\n- [3rd party middlewares](#3rd-party-middlewares)\n- [Contributing](#contributing)\n- [License](#license)\n\n\n## A little appetizer\n\nMiddy is a very simple middleware engine. If you are used to web frameworks like\nexpress, than you will be familiar with the concepts adopted in Middy and you will\nbe able to get started very quickly.\n\nBut code is better than 10,000 words, so let\'s jump into an example.\nLet\'s assume you are building a JSON API to process a payment:\n\n```javascript\n# handler.js\n\nconst middy = require(\'middy\')\nconst { jsonBodyParser, validator, httpErrorHandler } = require(\'middy/middlewares\')\n\n// This is your common handler, in no way different than what you are used to doing every day\n// in AWS Lambda\nconst processPayment = (event, context, callback) => {\n  // we don\'t need to deserialize the body ourself as a middleware will be used to do that\n  const { creditCardNumber, expiryMonth, expiryYear, cvc, nameOnCard, amount } = event.body\n\n  // do stuff with this data\n  // ...\n\n  return callback(null, { result: \'success\', message: \'payment processed correctly\'})\n}\n\n// Notice that in the handler you only added base business logic (no deserilization,\n// validation or error handler), we will add the rest with middlewares\n\nconst inputSchema = {\n  type: \'object\',\n  properties: {\n    body: {\n      type: \'object\',\n      properties: {\n        creditCardNumber: { type: \'string\', minLength: 12, maxLength: 19, pattern: \'\\d+\' },\n        expiryMonth: { type: \'integer\', minimum: 1, maximum: 12 },\n        expiryYear: { type: \'integer\', minimum: 2017, maximum: 2027 },\n        cvc: { type: \'string\', minLength: 3, maxLength: 4, pattern: \'\\d+\' },\n        nameOnCard: { type: \'string\' },\n        amount: { type: \'number\' }\n      },\n      required: [\'creditCardNumber\'] // Insert here all required event properties\n    }\n  }\n}\n\n// Let\'s "middyfy" our handler, then we will be able to attach middlewares to it\nconst handler = middy(processPayment)\n  .use(jsonBodyParser()) // parses the request body when it\'s a JSON and converts it to an object\n  .use(validator({inputSchema})) // validates the input\n  .use(httpErrorHandler()) // handles common http errors and returns proper responses\n\nmodule.exports = { handler }\n```\n\n\n## Install\n\nAs simple as:\n\n```bash\nnpm install middy\n```\n\nor\n\n```bash\nyarn add middy\n```\n\n## Requirements\n\nMiddy has been built to work by default from **Node >= 6.10**.\n\nIf you need to run it in earlier versions of Node (eg. 4.3) then you will have to\n*transpile* middy\'s code yourself using [babel](https://babeljs.io/) or a similar tool.\n\n\n## Why?\n\nOne of the main strengths of serverless and AWS Lambda is that, from a developer\nperspective, your focus is mostly shifted toward implementing business logic.\n\nAnyway, when you are writing a handler, you still have to deal with some common technical concerns\noutside business logic, like input parsing and validation, output serialization,\nerror handling, etc.\n\nVery often, all this necessary code ends up polluting the pure business logic code in\nyour handlers, making the code harder to read and to maintain.\n\nIn other contexts, like generic web frameworks ([express](http://expressjs.com/),\n[fastify](http://fastify.io), [hapi](https://hapijs.com/), etc.), this\nproblem has been solved using the [middleware pattern](https://www.packtpub.com/mapt/book/web_development/9781783287314/4/ch04lvl1sec33/middleware).\n\nThis pattern allows developers to isolate these common technical concerns into\n*"steps"* that *decorate* the main business logic code.\nMiddleware functions are generally written as independent modules and then plugged in into\nthe application in a configuration step, thus not polluting the main business logic\ncode that remains clean, readable and easy to maintain.\n\n\nSince  we couldn\'t find a similar approach for AWS Lambda handlers, we decided\nto create middy, our own middleware framework for serverless in AWS land.\n\n\n## Usage\n\nAs you might have already got from our first example here, using middy is very\nsimple and requires just few steps:\n\n 1. Write your Lambda handlers as usual, focusing mostly on implementing the bare\n    business logic for them.\n 2. Import `middy` and all the middlewares you want to use\n 3. Wrap your handler in the `middy()` factory function. This will return a new\n    enhanced instance of your original handler, to which you will be able to attach\n    the middlewares you need.\n 4. Attach all the middlewares you need using the function `.use(somemiddleware())`\n\nExample:\n\n```javascript\nconst middy = require(\'middy\')\nconst { middleware1, middleware2, middleware3 } = require(\'middy/middlewares\')\n\nconst originalHandler = (event, context, callback) => { /* your business logic */ }\n\nconst handler = middy(originalHandler)\n\nhandler\n  .use(middleware1())\n  .use(middleware2())\n  .use(middleware3())\n\nmodule.exports = { handler }\n```\n\nYou can also attach [inline middlewares](#inline-middlewares) by using the functions `.before`, `.after` and\n`.onError`.\n\nFor a more detailed use case and examples check the [Writing a middleware section](#writing-a-middleware) and\nthe [API section](#api).\n\n\n## How it works\n\nMiddy implements the classic *onion-like* middleware pattern, with some peculiar details.\n\n![Middy middleware engine diagram](/img/middy-middleware-engine.png)\n\nWhen you attach a new middleware this will wrap the business logic contained in the handler\nin two separate steps.\n\nWhen another middleware is attached this will wrap the handler again and it will be wrapped by\nall the previously added middlewares in order, creating multiple layers for interacting with\nthe *request* (event) and the *response*.\n\nThis way the *request-response cycle* flows through all the middlewares, the\nhandler and all the middlewares again, giving the opportunity within every step to\nmodify or enrich the current request, context or the response.\n\n\n### Execution order\n\nMiddlewares have two phases: `before` and `after`.\n\nThe `before` phase, happens *before* the handler is executed. In this code the\nresponse is not created yet, so you will have access only to the request.\n\nThe `after` phase, happens *after* the handler is executed. In this code you will\nhave access to both the request and the response.\n\nIf you have three middlewares attached as in the image above this is the expected\norder of execution:\n\n - `middleware1` (before)\n - `middleware2` (before)\n - `middleware3` (before)\n - `handler`\n - `middleware3` (after)\n - `middleware2` (after)\n - `middleware1` (after)\n\nNotice that in the `after` phase, middlewares are executed in inverted order,\nthis way the first handler attached is the one with the highest priority as it will\nbe the first able to change the request and last able to modify the response before\nit gets sent to the user.\n\n\n### Interrupt middleware execution early\n\nSome middlewares might need to stop the whole execution flow and return a response immediately.\n\nIf you want to do this you can invoke `handler.callback` in your middleware and return early without invoking `next`.\n\n**Note**: this will totally stop the execution of successive middlewares in any phase (`before` and `after`) and returns\nan early response (or an error) directly at the Lambda level. If your middlewares do a specific task on every request\nlike output serialization or error handling, these won\'t be invoked in this case.\n\nIn this example we can use this capability for building a sample caching middleware:\n\n```javascript\n\n// some function that calculates the cache id based on the current event\nconst calculateCacheId = (event) => { /* ... */ }\nconst storage = {}\n\n// middleware\nconst cacheMiddleware = (options) => {\n  let cacheKey\n  return ({\n    before: (handler, next) => {\n      cacheKey = options.calculateCacheId(handler.event)\n      if (options.storage.hasOwnProperty(cacheKey)) {\n        // exits early and returns the value from the cache if it\'s already there\n        return handler.callback(null, options.storage[cacheKey])\n      }\n\n      return next()\n    },\n    after: (handler, next) => {\n      // stores the calculated response in the cache\n      options.storage[cacheKey] = handler.response\n      next()\n    }\n  })\n}\n\n// sample usage\nconst handler = middy((event, context, callback) => { /* ... */ })\n  .use(cacheMiddleware({\n    calculateCacheId, storage\n  }))\n```\n\n\n### Handling errors\n\nBut what happens when there is an error?\n\nWhen there is an error, the regular control flow is stopped and the execution is\nmoved back to all the middlewares that implements a special phase called `onError`, following\nthe order they have been attached.\n\nEvery `onError` middleware can decide to handle the error and create a proper response or\nto delegate the error to the next middleware.\n\nWhen a middleware handles the error and creates a response, the execution is still propagated to all the other\nerror middlewares and they have a chance to update or replace the response as\nneeded. At the end of the error middlewares sequence, the response is returned\nto the user.\n\nIf no middleware manages the error, the Lambda execution fails reporting the unmanaged error.\n\n### Promise support\n\nMiddy allows you to return promises (or throw errors) from your handlers (instead of calling `callback()`) and middlewares\n(instead of calling `next()`).\n\nHere is an example of a handler that returns a promise:\n\n```javascript\nmiddy((event, context, callback) => {\n  return someAsyncStuff()\n    .then(() => {\n      return someOtherAsyncStuff()\n    })\n    .then(() => {\n      return {foo: bar}\n    }\n})\n```\n\nAnd here is an example of a middleware that returns a similar promise:\n\n```javascript\nconst asyncValidator = () => {\n  before: (handler) => {\n    if (handler.event.body) {\n      return someAsyncStuff(handler.event.body)\n        .then(() => {\n          return {foo: bar}\n        })\n    }\n\n    return Promise.resolve()\n  }\n}\n\nhandler.use(asyncValidator())\n```\n\n### Promises and error handling\n\n`onError` middlewares can return promises as well.\nHere\'s how Middy handles return values from promise-enabled error handlers:\n* If `onError` promise resolves to a *truthy* value, this value is treated as an error and passed further down the pipeline.\n\n```javascript\nmiddleware1 = {\n  onError: (handler) => {\n    Logger.debug("middleware1");\n    return Promise.resolve(handler.error)\n  }\n}\nmiddleware2 = {\n  onError: (handler) => {\n    Logger.debug("middleware2");\n    return Promise.resolve(handler.error)\n  }\n}\nhandler.use(middleware1).use(middleware2);\n```\n\nHere, first `middleware1.onError` then `middleware2.onError` will be called.\n\n  - If the last `onError` in the chain returns a promise which resolves to a value, the lambda fails and reports an unmanaged error\n  In the example above, the lambda will fail and report the error returned by `middleware2.onError`.\n  - If `onError` promise resolves to a *falsy* value (`null`, `undefined`, `false` etc.), the error handling pipeline exits early and the response is returned without an error\n\n```javascript\nmiddleware1 = {\n  onError: (handler) => {\n    handler.response = { error: handler.error };\n    return Promise.resolve();\n    // Resolves to a falsy value\n  }\n}\nmiddleware2 = {\n  onError: (handler) => {\n    return Promise.resolve(handler.error)\n  }\n}\nhandler.use(middleware1).use(middleware2);\n```\n\nHere, only `middleware1.onError` will be called. The rest of the error handlers will be skipped, and the lambda will finish normally and return the response. `middleware2.onError` will not be called.\n\n  - If `onError` promise rejects, the error handling pipeline exits early and the lambda execution fails.\n\n```javascript\nmiddleware1 = {\n  onError: (handler) => {\n    return Promise.reject(handler.error);\n  }\n}\nmiddleware2 = {\n  onError: (handler) => {\n    return Promise.resolve(handler.error)\n  }\n}\nhandler.use(middleware1).use(middleware2);\n```\n\nHere, only `middleware1.onError` will be called, and the lambda will fail early, reporting an error. `middleware2.onError` will not be called.\n\n\n### Using async/await\n\nNode.js 8.10 supports [async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function),\nallowing you to work with promises in a way that makes handling asynchronous logic easier to reason about and\nasynchronous code easier to read.\n\nYou can still use async/await if you\'re running AWS Lambda on Node.js 6.10, but you will need to transpile your\n`async/await` code (e.g. using [babel](https://babeljs.io/)).\n\nTake the following code as an example of a handler written with async/await:\n\n```javascript\nmiddy(async (event, context) => {\n  await someAsyncStuff()\n  await someOtherAsyncStuff()\n\n  return ({foo: bar})\n})\n```\n\n\nAnd here is an example of a middleware written with async/await:\n\n```javascript\nconst asyncValidator = () => {\n  before: async (handler) => {\n    if (handler.event.body) {\n      await asyncValidate(handler.event.body)\n\n      return {foo: bar}\n    }\n\n    return\n  }\n}\n\nhandler.use(asyncValidator())\n```\n\n\n## Writing a middleware\n\nA middleware is an object that should contain at least 1 of 3 possible keys:\n\n 1. `before`: a function that is executed in the before phase\n 2. `after`: a function that is executed in the after phase\n 3. `onError`: a function that is executed in case of errors\n\n`before`, `after` and `onError` functions need to have the following signature:\n\n```javascript\nfunction (handler, next) {\n  // ...\n}\n```\n\nWhere:\n\n - `handler`: is a reference to the current context and it allows access to (and modification of)\n   the current `event` (request), the `response` (in the *after* phase) and `error`\n   (in case of an error).\n - `next`: is a callback function that needs to be invoked when the middleware has finished\n   its job so that the next middleware can be invoked\n\n### Configurable middlewares\n\nIn order to make middlewares configurable, they are generally exported as a function that accepts\na configuration object. This function should then return the middleware object with `before`,\n`after` and `onError` as keys.\n\nE.g.\n\n```javascript\n# myMiddleware.js\n\nconst myMiddleware = (config) => {\n  // might set default options in config\n  return ({\n    before: (handler, next) => {\n      // might read options from `config`\n    },\n    after: (handler, next) => {\n      // might read options from `config`\n    },\n    onError: (handler, next) => {\n      // might read options from `config`\n    }\n  })\n}\n\nmodule.exports = myMiddleware\n```\n\nWith this convention in mind, using a middleware will always look like the following example:\n\n```javascript\nconst middy = require(\'middy\')\nconst myMiddleware = require(\'myMiddleware\')\n\nconst handler = middy((event, context, callback) => {\n  // do stuff\n})\n\nhandler.use(myMiddleware({\n  option1: \'foo\',\n  option2: \'bar\'\n}))\n\nmodule.exports = { handler }\n```\n\n\n### Inline middlewares\n\nSometimes you want to create handlers that serve a very small need and that are not\nnecessarily re-usable. In such cases you probably will need to hook only into one of\nthe different phases (`before`, `after` or `onError`).\n\nIn these cases you can use **inline middlewares** which are shortcut functions to hook\nlogic into Middy\'s control flow.\n\nLet\'s see how inline middlewares work with a simple example:\n\n```javascript\nconst middy = require(\'middy\')\n\nconst handler = middy((event, context, callback) => {\n  // do stuff\n})\n\nhandler.before((handler, next) => {\n  // do something in the before phase\n  next()\n})\n\nhandler.after((handler, next) => {\n  // do something in the after phase\n  next()\n})\n\nhandler.onError((handler, next) => {\n  // do something in the on error phase\n  next()\n})\n\nmodule.exports = { handler }\n```\n\nAs you can see above, a middy instance also exposes the `before`, `after` and `onError`\nmethods to allow you to quickly hook-in simple inline middlewares.\n\n\n### More details on creating middlewares\n\nCheck the [code for existing middlewares](/docs/middlewares.md) to see more examples\non how to write a middleware.\n\n\n## Available middlewares\n\nCurrently available middlewares:\n\n - [`cache`](/docs/middlewares.md#cache): A simple but flexible caching layer\n - [`cors`](/docs/middlewares.md#cors): Sets CORS headers on response\n - ~~[`functionShield`](/docs/middlewares.md#functionshield): Hardens AWS Lambda execution environment~~ **Note**: functionShield has been removed from core since *0.22.0*. Use [`@middy/function-shield`](https://www.npmjs.com/package/@middy/function-shield) instead.\n - [`doNotWaitForEmptyEventLoop`](/docs/middlewares.md#donotwaitforemptyeventloop): Sets callbackWaitsForEmptyEventLoop property to false\n - [`httpContentNegotiation`](/docs/middlewares.md#httpcontentnegotiation): Parses `Accept-*` headers and provides utilities for content negotiation (charset, encoding, language and media type) for HTTP requests\n - [`httpErrorHandler`](/docs/middlewares.md#httperrorhandler): Creates a proper HTTP response for errors that are created with the [http-errors](https://www.npmjs.com/package/http-errors) module and represents proper HTTP errors.\n - [`httpEventNormalizer`](/docs/middlewares.md#httpEventNormalizer): Normalizes HTTP events by adding an empty object for `queryStringParameters` and `pathParameters` if they are missing.\n - [`httpHeaderNormalizer`](/docs/middlewares.md#httpheadernormalizer): Normalizes HTTP header names to their canonical format.\n - [`httpMultipartBodyParser`](/docs/middlewares.md#multipartbodyparser): Automatically parses HTTP requests with content type `multipart/form-data`.\n - [`httpPartialResponse`](/docs/middlewares.md#httppartialresponse): Filter response objects attributes based on query string parameters.\n - [`jsonBodyParser`](/docs/middlewares.md#jsonbodyparser): Automatically parses HTTP requests with JSON body and converts the body into an object. Also handles gracefully broken JSON if used in combination of\n `httpErrorHandler`.\n - [`s3KeyNormalizer`](/docs/middlewares.md#s3keynormalizer): Normalizes key names in s3 events.\n - [`secretsManager`](/docs/middlewares.md#secretsmanager): Fetches parameters from [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html).\n - [`ssm`](/docs/middlewares.md#ssm): Fetches parameters from [AWS Systems Manager Parameter Store](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-paramstore.html).\n - [`validator`](/docs/middlewares.md#validator): Automatically validates incoming events and outgoing responses against custom schemas\n - [`urlEncodeBodyParser`](/docs/middlewares.md#urlencodebodyparser): Automatically parses HTTP requests with URL encoded body (typically the result of a form submit).\n - [`warmup`](/docs/middlewares.md#warmup): Warmup middleware that helps to reduce the [cold-start issue](https://serverless.com/blog/keep-your-lambdas-warm/)\n\n\nFor dedicated documentation on available middlewares check out the [Middlewares\ndocumentation](/docs/middlewares.md)\n\n## Api\n\n## \n\n* [middy(handler)](#middy) \xe2\x87\x92 [<code>middy</code>](#middy)\n\n## \n\n* [middy](#middy) : <code>function</code>\n* [useFunction](#useFunction) \xe2\x87\x92 [<code>middy</code>](#middy)\n* [middlewareAttachFunction](#middlewareAttachFunction) \xe2\x87\x92 [<code>middy</code>](#middy)\n* [middlewareNextFunction](#middlewareNextFunction) : <code>function</code>\n* [middlewareFunction](#middlewareFunction) \xe2\x87\x92 <code>void</code> \\| <code>Promise</code>\n* [middlewareObject](#middlewareObject) : <code>Object</code>\n\n<a name="middy"></a>\n\n## middy(handler) \xe2\x87\x92 [<code>middy</code>](#middy)\nMiddy factory function. Use it to wrap your existing handler to enable middlewares on it.\n\n**Kind**: global function  \n**Returns**: [<code>middy</code>](#middy) - - a `middy` instance  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| handler | <code>function</code> | your original AWS Lambda function |\n\n<a name="middy"></a>\n\n## middy : <code>function</code>\n**Kind**: global typedef  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| event | <code>Object</code> | the AWS Lambda event from the original handler |\n| context | <code>Object</code> | the AWS Lambda context from the original handler |\n| callback | <code>function</code> | the AWS Lambda callback from the original handler |\n\n**Properties**\n\n| Name | Type | Description |\n| --- | --- | --- |\n| use | [<code>useFunction</code>](#useFunction) | attach a new middleware |\n| before | [<code>middlewareAttachFunction</code>](#middlewareAttachFunction) | attach a new *before-only* middleware |\n| after | [<code>middlewareAttachFunction</code>](#middlewareAttachFunction) | attach a new *after-only* middleware |\n| onError | [<code>middlewareAttachFunction</code>](#middlewareAttachFunction) | attach a new *error-handler-only* middleware |\n| __middlewares | <code>Object</code> | contains the list of all the attached   middlewares organised by type (`before`, `after`, `onError`). To be used only   for testing and debugging purposes |\n\n<a name="useFunction"></a>\n\n## useFunction \xe2\x87\x92 [<code>middy</code>](#middy)\n**Kind**: global typedef  \n\n| Type | Description |\n| --- | --- |\n| [<code>middlewareObject</code>](#middlewareObject) | the middleware object to attach |\n\n<a name="middlewareAttachFunction"></a>\n\n## middlewareAttachFunction \xe2\x87\x92 [<code>middy</code>](#middy)\n**Kind**: global typedef  \n\n| Type | Description |\n| --- | --- |\n| [<code>middlewareFunction</code>](#middlewareFunction) | the middleware function to attach |\n\n<a name="middlewareNextFunction"></a>\n\n## middlewareNextFunction : <code>function</code>\n**Kind**: global typedef  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| error | <code>error</code> | An optional error object to pass in case an error occurred |\n\n<a name="middlewareFunction"></a>\n\n## middlewareFunction \xe2\x87\x92 <code>void</code> \\| <code>Promise</code>\n**Kind**: global typedef  \n**Returns**: <code>void</code> \\| <code>Promise</code> - - A middleware can return a Promise instead of using the `next` function as a callback.\n                         In this case middy will wait for the promise to resolve (or reject) and it will automatically\n                         propagate the result to the next middleware.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| handler | <code>function</code> | the original handler function.   It will expose properties `event`, `context`, `response`, `error` and `callback` that can   be used to interact with the middleware lifecycle |\n| next | [<code>middlewareNextFunction</code>](#middlewareNextFunction) | the callback to invoke to pass the control to the next middleware |\n\n<a name="middlewareObject"></a>\n\n## middlewareObject : <code>Object</code>\n**Kind**: global typedef  \n**Properties**\n\n| Name | Type | Description |\n| --- | --- | --- |\n| before | [<code>middlewareFunction</code>](#middlewareFunction) | the middleware function to attach as *before* middleware |\n| after | [<code>middlewareFunction</code>](#middlewareFunction) | the middleware function to attach as *after* middleware |\n| onError | [<code>middlewareFunction</code>](#middlewareFunction) | the middleware function to attach as *error* middleware |\n\n\n\n## Typescript\n\nMiddy exports Typescript compatible type information. To enable the use of Middy in your Typescript project please make sure `tsconfig.json` is configured as follows:\n\n```\n{\n\t"compilerOptions": {\n\t\t...\n\t\t/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies \'allowSyntheticDefaultImports\'. */\n\t\t"esModuleInterop": true,\n\t\t...\n\t},\n}\n\n```\n\nAfter that you can `import middy from \'middy\';` in your http handler and use it as described above.\n\n## FAQ\n\n### Q: Lambda timing out\n**A**: If Lambda is timing out even though you are invoking a callback, there may still be some events in an event loop that are\npreventing a Lambda to exit. This is common when using ORM to connect to the Database, which may keep connections to the database\nalive. To solve this issue, you can use `doNotWaitForEmptyEventLoop` middleware, which will force Lambda to exit when you invoke\na callback.\n\n## 3rd party middlewares\n\nHere\'s a collection of some 3rd party middlewares and libraries that you can use with Middy:\n\n - [middy-redis](https://www.npmjs.com/package/middy-redis): Redis connection middleware\n - [middy-extractor](https://www.npmjs.com/package/middy-extractor): Extracts data from events using expressions\n - [@keboola/middy-error-logger](https://www.npmjs.com/package/@keboola/middy-error-logger): middleware that catches thrown exceptions and rejected promises and logs them comprehensibly to the console\n - [@keboola/middy-event-validator](https://www.npmjs.com/package/@keboola/middy-event-validator): Joi powered event validation middleware\n - [middy-reroute](https://www.npmjs.com/package/middy-reroute): provides complex redirect, rewrite and proxying capabilities by simply placing a rules file into your S3 bucket\n - [middytohof](https://www.npmjs.com/package/middytohof): Convert Middy middleware plugins to higher-order functions returning lambda handlers\n - [wrap-ware](https://www.npmjs.com/package/wrap-ware): A middleware wrapper which works with promises / async\n - [middy-jsonapi](https://www.npmjs.com/package/middy-jsonapi): JSONAPI middleware for middy\n - [middy-middleware-warmup](https://www.npmjs.com/package/middy-middleware-warmup): A middy plugin to help keep your Lambdas warm during Winter\n - [@sharecover-co/middy-aws-xray-tracing](https://www.npmjs.com/package/@sharecover-co/middy-aws-xray-tracing): AWS X-Ray Tracing Middleware\n - [@sharecover-co/middy-http-response-serializer](https://www.npmjs.com/package/@sharecover-co/middy-http-response-serializer):  This middleware serializes the response to JSON and wraps it in a 200 HTTP response\n - [@seedrs/middyjs-middleware](https://www.npmjs.com/package/@seedrs/middyjs-middleware): Collection of useful middlewares\n - [middy-autoproxyresponse](https://www.npmjs.com/package/middy-autoproxyresponse): A middleware that lets you return simple JavaScript objects from Lambda function handlers and converts them into LAMBDA_PROXY responses\n - [`jwt-auth`](https://www.npmjs.com/package/middy-middleware-jwt-auth): JSON web token authorization middleware based on `express-jwt`\n - [middy-env](https://www.npmjs.com/package/middy-env): Fetch, validate and type cast environment variables\n\n## Contributing\n\nEveryone is very welcome to contribute to this repository. Feel free to [raise issues](https://github.com/middyjs/middy/issues) or to [submit Pull Requests](https://github.com/middyjs/middy/pulls).\n\n\n## License\n\nLicensed under [MIT License](LICENSE). Copyright (c) 2017-2018 Luciano Mammino and the [Middy team](https://github.com/middyjs/middy/graphs/contributors).\n\n<a href="https://app.fossa.io/projects/git%2Bgithub.com%2Fmiddyjs%2Fmiddy?ref=badge_large">\n  <img src="https://app.fossa.io/api/projects/git%2Bgithub.com%2Fmiddyjs%2Fmiddy.svg?type=large" alt="FOSSA Status"  style="max-width:100%;">\n</a>\n'