b'# T.A.D.S. boilerplate <!-- omit in toc -->\n\n[![Build Status](https://travis-ci.com/Thomvaill/tads-boilerplate.svg?branch=master)](https://travis-ci.com/Thomvaill/tads-boilerplate)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=Get%20started%20with%20Infrastructure%20as%20Code%20with%20T.A.D.S.%20https%3A%2F%2Fgithub.com%2FThomvaill%2Ftads-boilerplate%20-%20A%20boilerplate%20created%20by%20%40thomvaill%20which%20combines%20%23Terraform%20%23Ansible%20%23Vagrant%20and%20%23DockerSwarm.%20%23Docker%20%23DevOps%20%23IaC)\n\n<div align="center"><strong>The power of Ansible and Terraform + the simplicity of Swarm = DevOps on :fire::fire::fire:</strong></div>\n<br />\n\n![T.A.D.S. logo](.github/tads-header.png)\n\n- [:tada: What is it?](#tada-what-is-it)\n- [:dart: Who is it for?](#dart-who-is-it-for)\n- [:muscle: Philosophy](#muscle-philosophy)\n- [:lock: Knowledge prerequisites](#lock-knowledge-prerequisites)\n- [:lock: Technical prerequisites](#lock-technical-prerequisites)\n- [:rocket: Quick start](#rocket-quick-start)\n  - [1. Make this repository yours](#1-make-this-repository-yours)\n  - [2. Install the required dependencies](#2-install-the-required-dependencies)\n  - [3. Provision your local machine and deploy the example stack](#3-provision-your-local-machine-and-deploy-the-example-stack)\n  - [4. Write your own Docker Swarm Compose files](#4-write-your-own-docker-swarm-compose-files)\n  - [5. Test on a Vagrant cluster](#5-test-on-a-vagrant-cluster)\n  - [6. Edit and encrypt your production environment variables](#6-edit-and-encrypt-your-production-environment-variables)\n  - [7.a. Create, provision and deploy your production environment with Terraform](#7a-create-provision-and-deploy-your-production-environment-with-terraform)\n  - [7.b. Provision and deploy your production environment to an existing infrastructure](#7b-provision-and-deploy-your-production-environment-to-an-existing-infrastructure)\n  - [8. Add other remote environments](#8-add-other-remote-environments)\n  - [9. Make your team members autonomous](#9-make-your-team-members-autonomous)\n- [:question: FAQ](#question-faq)\n- [Contributing](#contributing)\n- [Acknowledgments](#acknowledgments)\n- [License](#license)\n\n## :tada: What is it?\n\nA boilerplate to create a full Infrastructure as Code (IaC) repository, from provisioning to deployment with:\n\n- **Terraform** to create your cloud infrastructure\n- **Vagrant** to reproduce a production-like environment locally\n- **Ansible** to provision Virtual Machines and set up the **Docker Swarm** cluster\n- **Ansible** again to deploy your stacks\n\nIt handles different environments:\n\n- `localhost`: a single node Docker Swarm cluster on your machine, useful for development ([demo](https://asciinema.org/a/282625))\n- `vagrant`: a 3 nodes production-like cluster deployed with Vagrant on your machine, useful for testing ([demo](https://asciinema.org/a/282636))\n- `production`: your production environment! It can be created by Terraform or you can use an existing bare metal/VMs infrastructure ([demo](https://asciinema.org/a/282640))\n- other remote production-like environments of your choice: staging, QA...\n\nOn top of that, it features:\n\n- A companion CLI (`./tads`), which is a wrapper around Terraform, Ansible and Vagrant commands. For example: `ansible-playbook -i inventories/production -D --vault-id production@vault_keys/production deploy.yml` becomes `./tads ansible-playbook production deploy`. More convenient, don\'t you think? :smirk:\n- Docker Swarm Compose files templated with Jinja2, so you can define your services once, while being able to customize them in each environment, from the same file\n- An example which implements [dockerswarm.rocks\' recommended good practices](https://dockerswarm.rocks/): traefik reverse proxy with HTTPS (even locally), and more coming soon\n- A smart `/etc/hosts` management to access your local and Vagrant applications with `.localhost` and `.test` https URIs\n- AES-256 encryption of your production credentials with ansible-vault\n\nWith T.A.D.S., you will be able to onboard a new developer on your project in less than 3 minutes, with just 3 commands! Even if you have a complex microservices architecture. Forget about your outdated wikis or installation procedures, they are no longer needed! See the [example user README](README.example.md) to get a preview of what your new procedures could look like.\n\n[![Example of a fresh development environment setup with T.A.D.S. in 02:30!](https://asciinema.org/a/282625.svg)](https://asciinema.org/a/282625)\n<div align="center"><sub>Example of a fresh development environment setup with T.A.D.S. in 02:30!</sub></div>\n\n## :dart: Who is it for?\n\nIf you recognize yourself into some of these statements, this project is definitely for you:\n\n- I am the only one who understands how the production environment works\n- I still have to execute SSH commands in production and this makes me sad because I cannot rollback or be reviewed :(\n- Setting up a new development environment for a new team member takes an entire day, and a lot of resources\n- My team suffers from "Microservices Hell": we have to install many services before being able to dev\n- Developers use docker-compose on their machine, while we use something else in production\n- I want to do Infrastructure as Code (IaC)\n- I want to promote the DevOps mindset in my team\n- I don\'t need/want Kubernetes features and complexity\n- I don\'t want to be vendor locked by a service like AWS ECS\n- I start a new project and I want to bootstrap it quickly with good practices presets\n\nOn the contrary, this project might not be for you if:\n\n- You have a large cluster (more than 100 machines)\n- You need Kubernetes features like autoscaling\n\n... but don\'t be sad, I am thinking of creating a similar project for K8s ;) Tell me if you want to help!\n\n## :muscle: Philosophy\n\n- Every environment infrastructure, including dev, is versioned into one repository\n- Same development environment installation procedure for everyone\n- No SSH, no manual actions, everything must be code\n- Every change to infrastructure must be code reviewed to:\n  - Avoid mistakes\n  - Make other (including non-DevOps) team members able to learn\n- Everyone, not only DevOps team members, is able to:\n  - Create their development environment in a minute with just one command\n  - Reproduce a production-like environment locally\n  - Understand the whole infrastructure\n  - Propose modifications to the infrastructure, while being able to test them locally\n- This project is a boilerplate, not a framework: modify it to fulfill your needs!\n- The companion CLI is written in Bash so it is easy to understand what a command does, and it is easy to modify command behaviors or to add new ones\n\n## :lock: Knowledge prerequisites\n\nBefore going further, I assume that you already have the knowledge **and practice** with Docker Swarm mode, Ansible, Terraform, and Infrastructure as Code in general.\nIf it is not the case, I urge you to study and practice **before**. You can use this material as a starter:\n\n- [Getting started with swarm mode](https://docs.docker.com/engine/swarm/swarm-tutorial/) and [Docker Swarm Rocks](https://dockerswarm.rocks/)\n- [Ansible Quickstart guide](https://docs.ansible.com/ansible/latest/user_guide/quickstart.html)\n- [Terraform getting started](https://learn.hashicorp.com/terraform/getting-started/install.html)\n\n## :lock: Technical prerequisites\n\n- **Local machine**:\n  - Ubuntu >= 18.04 or similar (PRs are welcome to update this list)\n  - Ansible >= 2.8\n  - Vagrant >= 2.0 *(optional)*\n  - Virtualbox >= 5.2 *(optional)*\n  - Terraform >= 0.12 *(optional)*\n- **Remote environments**:\n  - A cloud provider account (tested on AWS and Digital Ocean so far)\n  - ***OR***\n  - An existing bare metal / VMs infrastructure, with Linux based OSes (tested on Ubuntu server 18.04 and Debian 9 so far)\n\nHave a look at [Install the required dependencies](#2-install-the-required-dependencies) for installation procedures.\n\n**OS X:** It should not be that hard to make the project run on OS X. PRs are welcome! I am also thinking of creating a dockerized version of the project to improve compatibility.\n\n## :rocket: Quick start\n\n### 1. Make this repository yours\n\nClone this repo, create your own and push the code to it.\n\n```bash\ngit clone --single-branch https://github.com/Thomvaill/tads-boilerplate.git <YOUR_PROJECT_NAME>\ncd <YOUR_PROJECT_NAME>\ngit remote set-url origin <YOUR_REPO_URL>\ngit push\n```\n\n### 2. Install the required dependencies\n\nThis will install Ansible, Vagrant, Virtualbox and Terraform on your local machine:\n\n```bash\n./tads install-dependencies\n```\n\nYou can also manually install the dependencies if your preferer.\n\n### 3. Provision your local machine and deploy the example stack\n\n```bash\n./tads ansible-playbook localhost provision\n./tads ansible-playbook localhost deploy\n```\n\nThe first command will:\n\n- Install Docker on your local machine\n- Set up a Swarm cluster with one manager node\n- Hardcode `yourcompany.localhost` to your `/etc/hosts` file\n\nAnd the second one will deploy `traefik` and `example_app` stacks.\nIf everything went well, you are now able to access it at this URL: https://yourcompany.localhost/\n\n### 4. Write your own Docker Swarm Compose files\n\nNow that the example stack is running on your machine, you can deploy your own services.\n\nFirst, you probably need to change the `domains` dict in `ansible/group_vars/all.yml`.\nThis file contains all Ansible variables default values. These values can be overridden later in other group_vars files.\nYou are free to add your variables in it.\n\nThen, you can write your own Docker Swarm Compose files, following this naming convention: `ansible/stacks/<STACK_NAME>/<STACK_NAME>.yml.j2`\nThese files are [Jinja2 templates](https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html).\nYou are highly encouraged to use Ansible variables in them, so your template file can be used across all your environments.\nHave a look at `ansible/stacks/example_app/example_app.yml.j2` to see a good example.\n\nFinally, do not forget to add your new stacks to `ansible/deploy.yml`.\n\nTo help you with the `ansible/group_vars` directory, here is a representation of Ansible groups:\n\n```raw\nall\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 dev\n|   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 localhost\n|   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vagrant\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 production\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 staging\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 any_other_remote_environment...\n```\n\nEach group has its `_overrides` counterpart, which enables you to override some variables locally in a `xxx_overrides.yml` file,\nwhich is not versionned.\nHave a look at `.sample.yml` files to see some examples.\n\nWhile developing, perform some `./tads ansible-playbook localhost deploy` to test your deployment.\nDo not forget to run `./tads ansible-playbook localhost provision` again if you have changed domain names.\n\n**Tips:**\n\n- You can use `./tads ansible-playbook localhost all` to provision and deploy in a single command\n- You can use tags to go quicker. Example: `./tads ansible-playbook localhost all --tags dev,stack-traefik`\n- Always reference your Docker images with tags! It is a bad practice to rely on the `:latest` tag because you don\'t control what will be pushed to production. With specific tags, you will have idempotent deployments and you will be able to perform rollbacks\n\n### 5. Test on a Vagrant cluster\n\nNow that you are happy with your localhost environment, you should test the provisioning and the deployment\non an environment which looks more like a production environment.\nFor instance, on localhost, you can have just one node! And maybe you forgot some dependencies that are already installed on your computer.\nWith Vagrant, you will be able to test your stacks on a fresh 3 nodes Swarm cluster.\n\n1. Copy `vagrant/vagrant.sample.yml` to `vagrant/vagrant.yml` and adjust its settings\n2. Run `./tads vagrant up`\n3. Run `./tads ansible-playbook vagrant all`\n\nNow, you will be able to test your stacks deployed on Vagrant. If you have kept the example app, you can test it on https://yourcompany.test/\n\n**Tips:**\n\n- To destroy your cluster: `./tads vagrant destroy`\n- To SSH into the first node: `./tads vagrant ssh vagrant-1`\n  \n### 6. Edit and encrypt your production environment variables\n\nBefore going further, you should edit your production group_vars files:\n\n- `ansible/group_vars/production.yml`\n- `ansible/group_vars/production_encrypted.yml`\n  \nWhen you are done, **do not commit `production_encrypted.yml`**! You have to encrypt it first:\n\n- `./tads ansible-vault production init-key`\n- `./tads ansible-vault production encrypt ansible/group_vars/production_encrypted.yml`\n\nThe first command has generated a random key in `ansible/vault_keys/production`.\nYou must not commit this file. You should keep it in a safe place, and share it with your authorized team members securely.\nIf you lose it, you won\'t be able to decrypt your files anymore. The second one has encrypted your file\nwith AES-256. You can now commit it.\n\nYou can still edit this file by running `./tads ansible-vault production edit ansible/group_vars/production_encrypted.yml`. Always check that you do not commit an unencrypted version of this file by mistake.\n\n### 7.a. Create, provision and deploy your production environment with Terraform\n\nNow that everything is fine locally, it is time to create and deploy your production environment!\n\nThe `terraform/environments/production` is an AWS example. PRs are welcome for other providers!\nTo make it work, you should:\n\n- Have a working SSH key pair\n- Have a registered domain name managed by Route53\n- [Install AWS CLI](https://docs.aws.amazon.com/fr_fr/cli/latest/userguide/cli-chap-install.html): `pip3 install awscli --upgrade --user`\n- Configure your credentials: `aws configure`\n\nTerraform will use this default profile credentials.\n\nThen, you can run `./tads terraform production init` and `./tads terraform production apply`.\nThis example will create:\n\n- A custom VPC\n- 3 subnets into separate Availability Zones, for high availability\n- 3 manager nodes and 1 worker node (with spread placement groups, for high availability)\n- 1 classic ELB to distribute TCP traffic on port 80 and 443 to the manager nodes (traefik is responsible for SSL termination)\n\nThe CLI will also create the corresponding Ansible inventory for you in `ansible/inventories/production` from Terraform outputs. You should commit it.\nYou should also commit the Terraform state file, or better: [use a remote state](https://www.terraform.io/docs/state/remote.html).\n\nThen, you have to [create an alias in Route53 to the ELB](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-elb-load-balancer.html).\n\nFinally, you can run `./tads ansible-playbook production all` and your website will be available!\n\n**Disclaimer:**\n\n- This is an example, you should not use it as is in production!\n- Although resources created by the example are eligible to free tier, charges may occur depending on your situation\n- Use `./tads terraform production destroy` with caution :-)\n\n### 7.b. Provision and deploy your production environment to an existing infrastructure\n\nIf you don\'t want to use a cloud provider, you can use classic Virtual Machines.\nFor a production environment, you should have at least 3 manager nodes, so 3 VMs.\nThey should be fresh installs. Ubuntu server 18.04 or Debian 9 is fine.\n\n1. Make sure you can SSH into the VMs with your key pair\n2. Copy `ansible/inventories/production.sample-baremetal` to `ansible/inventories/production`\n3. Edit it\n4. Run `./tads ansible-playbook production all` and your website will be available!\n\n### 8. Add other remote environments\n\nYou can add other remote environments, like production.\n\nFor Terraform, you just have to duplicate `terraform/environments/production` to the directory of your choice, eg `staging`.\nAfter editing it, you can run `./tads terraform staging apply`, it will create the `ansible/inventories/staging` inventory file.\n\nFor an existing bare metal infrastructure, you just have to create the `ansible/inventories/staging` inventory file.\n\nThen, in Ansible, you have to create these files:\n\n- `ansible/group_vars/staging_encrypted.yml`\n- `ansible/group_vars/staging.yml`\n\nThen, create the ansible-vault key and encrypt the file:\n\n- `./tads ansible-vault staging init-key`\n- `./tads ansible-vault staging encrypt ansible/group_vars/staging_encrypted.yml`\n\nFinally, provision and deploy! `./tads ansible-playbook staging all`\n\n### 9. Make your team members autonomous\n\nIt is one of this project\'s goals: DevOps is not a job, it is a mindset!\nNow that you have a beautiful IaC, it is time to onboard your team members.\n\n1. Replace this `README.md` by `README.example.md` and customize it, so your team can use the project easily\n2. Make your developers use this project to configure their machine and develop\n3. Let your developers update/create stacks on their own, show them how to test their changes locally\n4. Enjoy :-)\n\n## :question: FAQ\n\n### Where is the companion CLI documentation? <!-- omit in toc -->\n\nThere is no documentation of the CLI since you will probably modify it, or add new commands!\nTo get some help, just run `./tads`. Do not hesitate also to have a look at the source into the `scripts` directory. This CLI is just a wrapper of Terraform, Ansible and Vagrant commands.\n\n### What if I don\'t want to deploy all the stacks locally? <!-- omit in toc -->\n\nUse Ansible tags! Example if you just want to deploy the `traefik` and `myapp` stack: `./tads ansible-playbook localhost deploy --tags stack-traefik,stack-myapp`.\n\n### How to do Continuous Delivery / Deployment? <!-- omit in toc -->\n\nI have not taken the time to develop this feature properly yet. But basically what you can do is:\n\n- Always referer to your Docker images with tags\n- Manage those tags into a separate `tags.yml` file\n- Write a script that can update a tag, perform a `./tads ansible-playbook production deploy`, and in case of success commit and push the file\n- Make your CI/CD tool use this script in your deployment pipeline\n\n### How to manage persistant storage? <!-- omit in toc -->\n\nThis problematic is beyond the scope of this project and depends a lot on your infrastructure / cloud provider.\nI advise you to have a look at [REX-Ray](https://github.com/rexray/rexray).\n\nThis might be a future feature to implement this plugin in the boilerplate.\n\n## Contributing\n\nPull Requests are more than welcome! Please read [CONTRIBUTING.md](CONTRIBUTING.md) for more details.\n\nDevelopment:\n\n```bash\n./tads install-dependencies --dev\nmake lint\nmake test\n```\n\n## Acknowledgments\n\n- John Patterson for his [ansible-swarm-playbook](https://github.com/nextrevision/ansible-swarm-playbook) and his [article](https://thisendout.com/2016/09/13/deploying-docker-swarm-with-ansible/)\n- Jeff Geerling for his [pip](https://github.com/geerlingguy/ansible-role-pip) and [docker](https://github.com/geerlingguy/ansible-role-docker) Ansible roles\n- The [forMetris](https://github.com/forMetris) team for being first users/testers of the project, and especially Axel Marbois for his contribution\n\n## License\n\nThis project is licensed under the MIT license, Copyright (c) 2019 Thomas Vaillant. For more information see [LICENSE](LICENSE) file.\n'