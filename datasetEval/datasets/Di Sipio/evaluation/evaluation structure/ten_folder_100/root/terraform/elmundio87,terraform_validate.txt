b'# Terraform Validate\n\nLinux: [![Linux Build Status](https://travis-ci.org/elmundio87/terraform_validate.svg?branch=master)](https://travis-ci.org/elmundio87/terraform_validate)\n\nWindows: [![Windows Build status](https://ci.appveyor.com/api/projects/status/36dwtekc8tvrny24/branch/master?svg=true)](https://ci.appveyor.com/project/elmundio87/terraform-validate/branch/master)\n\nA python package that allows users to define Policy as Code for Terraform configurations. \n\nBy parsing a directory of .tf files using `pyhcl`, each defined resource can be tested using this module. \n\n## Example Usages\n\n### Check that all AWS EBS volumes are encrypted\n\n\n```\nimport terraform_validate\n\nclass TestEncryptionAtRest(unittest.TestCase):\n\n    def setUp(self):\n        # Tell the module where to find your terraform configuration folder\n        self.path = os.path.join(os.path.dirname(os.path.realpath(__file__)),"../terraform")\n        self.v = terraform_validate.Validator(self.path)\n\n    def test_aws_ebs_volume(self):\n        # Assert that all resources of type \'aws_ebs_volume\' are encrypted\n        self.v.error_if_property_missing() # Fail any tests if the property does not exist on a resource\n        self.v.resources(\'aws_ebs_volume\').property(\'encrypted\').should_equal(True)\n\n    def test_instance_ebs_block_device(self):\n        # Assert that all resources of type \'ebs_block_device\' that are inside a \'aws_instance\' are encrypted\n        self.v.error_if_property_missing()\n        self.v.resources(\'aws_instance\').property(\'ebs_block_device\').property(\'encrypted\').should_equal(True)\n\nif __name__ == \'__main__\':\n    suite = unittest.TestLoader().loadTestsFromTestCase(TestEncryptionAtRest)\n    unittest.TextTestRunner(verbosity=0).run(suite)\n\n```\n\n```\nresource "aws_instance" "foo" {\n  # This would fail the test\n  ebs_block_device{\n    encrypted = false\n  }\n}\n\nresource "aws_ebs_volume" "bar" {\n  # This would fail the test\n  encrypted = false\n}\n```\n\n### Check that AWS resources are tagged correctly\n\n```\nimport terraform_validate\n\nclass TestEncryptionAtRest(unittest.TestCase):\n\n    def setUp(self):\n        # Tell the module where to find your terraform configuration folder\n        self.path = os.path.join(os.path.dirname(os.path.realpath(__file__)),"../terraform")\n        self.v = terraform_validate.Validator(self.path)\n\n    def test_aws_ebs_volume(self):\n        # Assert that all resources of type \'aws_instance\' and \'aws_ebs_volume\' have the correct tags\n        tagged_resources = ["aws_instance","aws_ebs_volume"]\n        required_tags = ["name","version","owner"]\n        self.v.resources(tagged_resources).property(\'tags\').should_have_properties(required_tags)\n\nif __name__ == \'__main__\':\n    suite = unittest.TestLoader().loadTestsFromTestCase(TestEncryptionAtRest)\n    unittest.TextTestRunner(verbosity=0).run(suite)\n```\n\n## Behaviour functions\n\nThese affect the results of the Validation functions in a way that may be required for your tests.\n\n### Validator.error_if_property_missing()\n\nBy default, no errors will be raised if a property value is missing on a resource. This changes the behavior of .property() calls to raise an error if a property is not found on a resource.\n\n### Validator.enable_variable_expansion()\n\nBy default, variables in property values will not be calculated against their default values. This changes the behaviour of all Validation functions, to work out the value of a string when the variables have default values.\n\neg. `string = "${var.foo}"` will be read as `string = "1"` by the validator if the default value of `foo` is 1.\n\n## Search functions\n\nThese are used to gather property values together so that they can be validated.\n\n### Validator.resources([resource_types])\nSearches for all resources of the required types and outputs a `TerraformResourceList`.\n\nCan be chained with a `.property()` function.\n\nIf passed a string as an argument, search through all resource types and list the ones that match the string as a regex.\nIf passed a list as an argument, only use the types that are inside the list.\n\nOutputs: `TerraformResourceList`\n\n### TerraformResourceList.property(property_name)\n\nCollects all top-level properties in a `TerraformResourceList`  and exposes methods that can be used to validate the property values.\n\nCan be chained with another `.property()` call to fetch nested properties.\n\neg. ``.resource(\'aws_instance\').property(\'name\')``\n\n### TerraformResourceList.find_property(regex)\n\nSimilar to `TerraformResourceList.property()`, except that it will attempt to use a regex string to search for the property.\n\neg. ``.resource(\'aws_instance\').find_property(\'tag[a-z]\')``\n\n\n### TerraformPropertyList.property(property_name)\n\nCollects all nested properties in `TerraformPropertyList` and exposes methods that can be used to validate the property values.\n\neg. ``.resource(\'aws_instance\').property(\'tags\').property(\'name\')``\n\n\n### TerraformPropertyList.find_property(regex)\n\nSimilar to `TerraformPropertyList.property()`, except that it will attempt to use a regex string to search for the property.\n\neg. ``.resource(\'aws_instance\').find_property(\'tag[a-z]\')``\n\n## Validation functions\n\nIf there are any errors, these functions will print the error and raise an AssertionError. The purpose of these functions is to validate the property values of different resources.\n\n### TerraformResourceList.should_have_properties([required_properties])\n\nWill raise an AssertionError if any of the properties in `required_properties` are missing from a `TerraformResourceList`.\n\n### TerraformPropertyList.should_have_properties([required_properties])\n\nWill raise an AssertionError if any of the properties in `required_properties` are missing from a `TerraformPropertyList`.\n\n### TerraformResourceList.should_not_have_properties([excluded_properties])\n\nWill raise an AssertionError if any of the properties in `required_properties` are missing from a `TerraformResourceList`.\n\n### TerraformPropertyList.should_not_have_properties([excluded_properties])\n\nWill raise an AssertionError if any of the properties in `required_properties` are missing from a `TerraformPropertyList`.\n\n### TerraformResourceList.name_should_match_regex(regex)\n\nWill raise an AssertionError if the Terraform resource name does not match the value of `regex`\n\n### TerraformPropertyList.should_equal(expected_value)\n\nWill raise an AssertionError if the value of the property does not equal `expected_value`\n\n### TerraformPropertyList.should_not_equal(unexpected_value)\n\nWill raise an AssertionError if the value of the property equals `unexpected_value`\n\n### TerraformPropertyList.should_match_regex(regex)\n\nWill raise an AssertionError if the value of the property does not match the value of `regex`\n\n### TerraformPropertyList.list_should_contain([value])\n\nWill raise an AssertionError if the list value does not contain any of the `[value]`\n\n### TerraformPropertyList.list_should_not_contain([value])\n\nWill raise an AssertionError if the list value does contain any of the `[value]`\n\n\n\n## Run with Docker\n\nBuild the terraform_validate daemon using:\n\n```\ndocker build -t terraform_validate .\n```\n\nThen, on a different location, place your tests on your tests.py.\n\nTo run:\n```\ndocker run -v `pwd`:/terraform_validate terraform_validate\n```\n\nExample output (All tests passing):\n\n```\n$ docker run -v `pwd`:/terraform_validate terraform_validate\n----------------------------------------------------------------------\nRan 3 tests in 1.607s\n\nOK\n```\n'