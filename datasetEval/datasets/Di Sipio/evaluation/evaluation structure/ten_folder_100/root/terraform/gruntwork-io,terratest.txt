b'# Terratest\n\n[![Maintained by Gruntwork.io](https://img.shields.io/badge/maintained%20by-gruntwork.io-%235849a6.svg)](https://gruntwork.io/?ref=repo_terratest)\n[![CircleCI](https://circleci.com/gh/gruntwork-io/terratest.svg?style=svg&circle-token=e48019e09fc3b8bf6e0315a84048501c87c4157c)](https://circleci.com/gh/gruntwork-io/terratest)\n[![Go Report Card](https://goreportcard.com/badge/github.com/gruntwork-io/terratest)](https://goreportcard.com/report/github.com/gruntwork-io/terratest)\n[![GoDoc](https://godoc.org/github.com/gruntwork-io/terratest?status.svg)](https://godoc.org/github.com/gruntwork-io/terratest)\n\nTerratest is a Go library that makes it easier to write automated tests for your infrastructure code. It provides a\nvariety of helper functions and patterns for common infrastructure testing tasks, including:\n\n- Testing Terraform code\n- Testing Packer templates\n- Testing Docker images\n- Executing commands on servers over SSH\n- Working with AWS APIs\n- Working with Azure APIs\n- Working with GCP APIs\n- Working with Kubernetes APIs\n- Testing Helm Charts\n- Making HTTP requests\n- Running shell commands\n- And much more\n\nTerratest was developed at [Gruntwork](https://gruntwork.io/) to help maintain the [Infrastructure as Code\nLibrary](https://gruntwork.io/infrastructure-as-code-library/), which contains over 250,000 lines of code written\nin Terraform, Go, Python, and Bash, and is used in production by hundreds of companies. See [Open sourcing Terratest: a\nswiss army knife for testing infrastructure code](https://blog.gruntwork.io/open-sourcing-terratest-a-swiss-army-knife-for-testing-infrastructure-code-5d883336fcd5)\nfor more info.\n\n\n\n\n## Introduction\n\nThe basic usage pattern for writing automated tests with Terratest is to:\n\n1.  Write tests using Go\'s built-in [package testing](https://golang.org/pkg/testing/): you create a file ending in\n    `_test.go` and run tests with the `go test` command.\n1.  Use Terratest to execute your _real_ IaC tools (e.g., Terraform, Packer, etc.) to deploy _real_ infrastructure\n    (e.g., servers) in a _real_ environment (e.g., AWS).\n1.  Validate that the infrastructure works correctly in that environment by making HTTP requests, API calls, SSH\n    connections, etc.\n1.  Undeploy everything at the end of the test.\n\nHere\'s a simple example of how to test some Terraform code:\n\n```go\nterraformOptions := &terraform.Options {\n  // The path to where your Terraform code is located\n  TerraformDir: "../examples/terraform-basic-example",\n}\n\n// At the end of the test, run `terraform destroy` to clean up any resources that were created\ndefer terraform.Destroy(t, terraformOptions)\n\n// This will run `terraform init` and `terraform apply` and fail the test if there are any errors\nterraform.InitAndApply(t, terraformOptions)\n\n// Validate your code works as expected\nvalidateServerIsWorking(t, terraformOptions)\n```\n\n\n\n\n## Quickstart\n\n### Install requirements\n\nTerratest uses the Go testing framework. To use terratest, you need to install:\n\n- [Go](https://golang.org/) (requires version >=1.13)\n\n\n### Setting up your project\n\n1. In the project folder, create three subfolders:\n    1. `modules`: This folder should contain your terraform modules that will be tested.\n    1. `examples`: This folder should contain examples of how to use the modules. These should be self-contained\n       deployable examples. Meaning, it should provision all the resources that are necessary to run the modules in the\n       `modules` folder.\n    1. `test`: This folder should contain your terratest code.\n1. Copy the [basic terraform\n   example](https://github.com/gruntwork-io/terratest/tree/master/examples/terraform-basic-example) into the `examples`\n   folder.\n1. Copy the [basic terraform example\n   test](https://github.com/gruntwork-io/terratest/blob/master/test/terraform_basic_example_test.go) into the `test`\n   folder.\n1. In the `test` folder, run `go mod init MODULE_NAME` to get a new `go.mod` file. Then run `go mod tidy` to download\n   terratest.\n\nNow you should be able to run the example test. To run the test:\n\n1. Change your working directory to the `test` folder.\n1. Each time you want to run the tests, use `go test -v -timeout 90m .`\n    - Note that `go` has a default test timeout of 10 minutes. With infrastructure testing, your tests will surpass the\n      10 minutes very easily. To extend the timeout, you can pass in the `-timeout` option, which takes a `go` duration\n      string (e.g `10m` for 10 minutes or `1h` for 1 hour). In the above command, we use the `-timeout` option to\n      override to a 90 minute timeout.\n    - When you hit the timeout, Go automatically exits the test, **skipping all cleanup routines**. This is problematic\n      for infrastructure testing because it will skip your deferred infrastructure cleanup steps (i.e `terraform\n      destroy`), leaving behind the infrastructure that was spun up. So it is important to use a longer timeout\n      everytime you run the tests.\n    - See the [Cleanup section](#cleanup) for more information on how to setup robust clean up procedures in the face of\n      test timeouts and instabilities.\n\n\n### Installing the utility binaries\n\nTerratest also ships utility binaries that you can use to improve the debugging experience (see [Debugging interleaved\ntest output](#debugging-interleaved-test-output)). The compiled binaries are shipped separately from the library in the [Releases page](https://github.com/gruntwork-io/terratest/releases).\n\nTo install a binary, download the version that matches your platform and place it somewhere on your `PATH`. For example\nto install version 0.13.13 of `terratest_log_parser`:\n\n```bash\n# This example assumes a linux 64bit machine\n# Use curl to download the binary\ncurl --location --silent --fail --show-error -o terratest_log_parser https://github.com/gruntwork-io/terratest/releases/download/v0.13.13/terratest_log_parser_linux_amd64\n# Make the downloaded binary executable\nchmod +x terratest_log_parser\n# Finally, we place the downloaded binary to a place in the PATH\nsudo mv terratest_log_parser /usr/local/bin\n```\n\nAlternatively, you can use [the gruntwork-installer](https://github.com/gruntwork-io/gruntwork-installer), which will do\nthe above steps and automatically select the right binary for your platform:\n\n```bash\ngruntwork-install --binary-name \'terratest_log_parser\' --repo \'https://github.com/gruntwork-io/terratest\' --tag \'v0.13.13\'\n```\n\nThe following binaries are currently available with `terratest`:\n\n| Command                  | Description                                                                                                                                                                |\n| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **terratest_log_parser** | Parses test output from the `go test` command and breaks out the interleaved logs into logs for each test. Integrate with your CI environment to help debug failing tests. |\n\n\n## Examples\n\nThe best way to learn how to use Terratest is through examples.\n\nFirst, check out the [examples folder](/examples) for different types of infrastructure code you may want to test,\nsuch as:\n\n1.  [Basic Terraform Example](/examples/terraform-basic-example): A simple "Hello, World" Terraform configuration.\n1.  [HTTP Terraform Example](/examples/terraform-http-example): A more complicated Terraform configuration that deploys\n    a simple web server that responds to HTTP requests in AWS.\n1.  [Basic Packer Example](/examples/packer-basic-example): A simple Packer template for building an Amazon Machine\n    Image (AMI) or Google Cloud Platform Compute Image.\n1.  [Terraform Packer Example](/examples/terraform-packer-example): A more complicated example that shows how to use\n    Packer to build an AMI with a web server installed and deploy that AMI in AWS using Terraform.\n1.  [Terraform GCP Example](/examples/terraform-gcp-example): A simple Terraform configuration that creates a GCP Compute Instance and Storage Bucket.\n1.  [Terraform remote-exec Example](/examples/terraform-remote-exec-example): A terraform configuration that creates and\n    AWS instance and then uses `remote-exec` to provision it.\n1.  [Basic Kubernetes Example](/examples/kubernetes-basic-example): A minimal Kubernetes resource that deploys an\n    addressable nginx instance.\n1.  [Kubernetes RBAC Example](/examples/kubernetes-rbac-example): A Kubernetes resource config that creates a Namespace\n    with a ServiceAccount that has admin permissions within the Namespace, but not outside.\n1.  [Basic Helm Chart Example](/examples/helm-basic-example): A minimal helm chart that deploys a `Deployment` resource\n    for the provided container image.\n\nNext, head over to the [test folder](/test) to see how you can use Terratest to test each of these examples:\n\n1.  [terraform_basic_example_test.go](/test/terraform_basic_example_test.go): Use Terratest to run `terraform apply` on\n    the Basic Terraform Example and verify you get the expected outputs.\n1.  [terraform_http_example_test.go](/test/terraform_http_example_test.go): Use Terratest to run `terraform apply` on\n    the HTTP Terraform Example to deploy the web server, make HTTP requests to the web server to check that it is\n    working correctly, and run `terraform destroy` to undeploy the web server.\n1.  [packer_basic_example_test.go](/test/packer_basic_example_test.go): Use Terratest to run `packer build` to build an\n    AMI and then use the AWS APIs to delete that AMI.\n1.  [packer_gcp_basic_example_test.go](/test/packer_gcp_basic_example_test.go): Use Terratest to run `packer build`\n    to build a Google Cloud Platform Compute Image and then use the GCP APIs to delete that image.\n1.  [terraform_packer_example_test.go](/test/terraform_packer_example_test.go): Use Terratest to run `packer build` to\n    build an AMI with a web server installed, deploy that AMI in AWS by running `terraform apply`, make HTTP requests to\n    the web server to check that it is working correctly, and run `terraform destroy` to undeploy the web server.\n1.  [terraform_gcp_example_test.go](/test/terraform_gcp_example_test.go): Use Terratest to run `terraform apply` on\n    the Terraform GCP Example and verify you get the expected outputs.\n1.  [terraform_remote_exec_example_test.go](/test/terraform_remote_exec_example_test.go): Use Terratest to run\n    `terraform apply` and then remotely provision the instance while using a custom SSH agent managed by Terratest\n1.  [terraform_scp_example_test.go](/test/terraform_scp_example_test.go): Use Terratest to simplify copying resources\n    like config files and logs from deployed EC2 Instances. This is especially useful for getting a snapshot of the\n    state of a deployment when a test fails.\n1.  [kubernetes_basic_example_test.go](/test/kubernetes_basic_example_test.go): Use Terratest to run `kubectl apply`\n    to apply a Kubernetes resource file, verify resources are created using the Kubernetes API, and then run `kubectl\n    delete` to delete the resources at the end of the test.\n1.  [kubernetes_rbac_example_test.go](/test/kubernetes_rbac_example_test.go): Use Terratest to run `kubectl apply` to\n    apply a Kubernetes resource file, retrieve auth tokens to authenticate as the created ServiceAccount, update the\n    kubeconfig file with the authentication token and add a new context to auth as the ServiceAccount, verify auth as\n    the ServiceAccount by checking what resources you have access to, and finally run `kubectl delete` to delete the\n    resources at the end of the test.\n1.  [helm_basic_example_template_test.go](/test/helm_basic_example_template_test.go): Use Terratest to run `helm\n    template` to test template rendering logic.\n\n\nFinally, to see some real-world examples of Terratest in action, check out some of our open source infrastructure\nmodules:\n\n1.  [Consul](https://github.com/hashicorp/terraform-aws-consul)\n1.  [Vault](https://github.com/hashicorp/terraform-aws-vault)\n1.  [Nomad](https://github.com/hashicorp/terraform-aws-nomad)\n1.  [Couchbase](https://github.com/gruntwork-io/terraform-aws-couchbase/)\n\n\n\n\n## Package by package overview\n\nNow that you\'ve had a chance to browse the examples and their tests, here\'s an overview of the packages you\'ll find in\nTerratest\'s [modules folder](/modules) and how they can help you test different types infrastructure:\n\n| Package            | Description                                                                                                                                                                                                                                                                                          |\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **aws**            | Functions that make it easier to work with the AWS APIs. Examples: find an EC2 Instance by tag, get the IPs of EC2 Instances in an ASG, create an EC2 KeyPair, look up a VPC ID.                                                                                                                     |\n| **azure**          | Functions that make it easier to work with the Azure APIs. Examples: get the size of a virtual machine, get the tags of a virtual machine.                                                                                                                                                           |\n| **collections**    | Go doesn\'t have much of a collections library built-in, so this package has a few helper methods for working with lists and maps. Examples: subtract two lists from each other.                                                                                                                      |\n| **docker**         | Functions that make it easier to work with Docker and Docker Compose. Examples: run `docker-compose` commands.                                                                                                                                                                                       |\n| **environment**    | Functions for interacting with os environment. Examples: check for first non empty environment variable in a list.                                                                                                                                                                                   |\n| **files**          | Functions for manipulating files and folders. Examples: check if a file exists, copy a folder and all of its contents.                                                                                                                                                                               |\n| **gcp**            | Functions that make it easier to work with the GCP APIs. Examples: Add labels to a Compute Instance, get the Public IPs of an Instance, Get a list of Instances in a Managed Instance Group, Work with Storage Buckets and Objects.                                                                                                                                                                                                                     |\n| **git**            | Functions for working with Git. Examples: get the name of the current Git branch.                                                                                                                                                                                                                    |\n| **http-helper**    | Functions for making HTTP requests. Examples: make an HTTP request to a URL and check the status code and body contain the expected values, run a simple HTTP server locally.                                                                                                                        |\n| **k8s**            | Functions that make it easier to work with Kubernetes. Examples: Getting the list of nodes in a cluster, waiting until all nodes in a cluster is ready.                                                                                                                                              |\n| **logger**         | A replacement for Go\'s `t.Log` and `t.Logf` that writes the logs to `stdout` immediately, rather than buffering them until the very end of the test. This makes debugging and iterating easier.                                                                                                      |\n| **logger/parser**  | Includes functions for parsing out interleaved go test output and piecing out the individual test logs. Used by the [terratest_log_parser](/cmd/terratest_log_parser) command.                                                                                                                       |\n| **oci**            | Functions that make it easier to work with OCI. Examples: Getting the most recent image of a compartment + OS pair, deleting a custom image, retrieving a random subnet.                                                                                                                             |\n| **packer**         | Functions for working with Packer. Examples: run a Packer build and return the ID of the artifact that was created.                                                                                                                                                                                  |\n| **random**         | Functions for generating random data. Examples: generate a unique ID that can be used to namespace resources so multiple tests running in parallel don\'t clash.                                                                                                                                      |\n| **retry**          | Functions for retrying actions. Examples: retry a function up to a maximum number of retries, retry a function until a stop function is called, wait up to a certain timeout for a function to complete. These are especially useful when working with distributed systems and eventual consistency. |\n| **shell**          | Functions to run shell commands. Examples: run a shell command and return its `stdout` and `stderr`.                                                                                                                                                                                                 |\n| **ssh**            | Functions to SSH to servers. Examples: SSH to a server, execute a command, and return `stdout` and `stderr`.                                                                                                                                                                                         |\n| **terraform**      | Functions for working with Terraform. Examples: run `terraform init`, `terraform apply`, `terraform destroy`.                                                                                                                                                                                        |\n| **test_structure** | Functions for structuring your tests to speed up local iteration. Examples: break up your tests into stages so that any stage can be skipped by setting an environment variable.                                                                                                                     |\n\n\n\n## GoDoc\n\nYou can find the GoDoc for Terratest here: https://godoc.org/github.com/gruntwork-io/terratest. This will let you see the methods and types within each package.\n\n\n\n\n## Testing best practices\n\nTesting infrastructure as code (IaC) is hard. With general purpose programming languages (e.g., Java, Python, Ruby),\nyou have a "localhost" environment where you can run and test the code before you commit. You can also isolate parts\nof your code from external dependencies to create fast, reliable unit tests. With IaC, neither of these advantages is\ntypically available, as there isn\'t a "localhost" equivalent for most IaC code (e.g., I can\'t use Terraform to deploy\nan AWS VPC on my own laptop) and there\'s no way to isolate your code from the outside world (i.e., the whole point of\na tool like Terraform is to make calls to AWS, so if you remove AWS, there\'s nothing left).\n\nThat means that most of the tests are going to be integration tests that deploy into a real AWS account. This makes\nthe tests effective at catching real-world bugs, but it also makes them much slower and more brittle. In this section,\nwe\'ll outline some best practices to minimize the downsides of this sort of testing.\n\n1.  [Testing environment](#testing-environment)\n1.  [Namespacing](#namespacing)\n1.  [Cleanup](#cleanup)\n1.  [Timeouts and logging](#timeouts-and-logging)\n1.  [Debugging interleaved test output](#debugging-interleaved-test-output)\n1.  [Avoid test caching](#avoid-test-caching)\n1.  [Error handling](#error-handling)\n1.  [Iterating locally using Docker](#iterating-locally-using-docker)\n1.  [Iterating locally using test stages](#iterating-locally-using-test-stages)\n\n\n### Testing environment\n\nSince most automated tests written with Terratest can make potentially destructive changes in your environment, we\nstrongly recommend running tests in an environment that is totally separate from production. For example, if you are\ntesting infrastructure code for AWS, you should run your tests in a completely separate AWS account.\n\nThis means that you will have to write your infrastructure code in such a way that you can plug in ([dependency\ninjection](https://en.wikipedia.org/wiki/Dependency_injection)) environment-specific details, such as account IDs,\ndomain names, IP addresses, etc. Adding support for this will typically make your code cleaner and more flexible.\n\n\n### Namespacing\n\nJust about all resources your tests create (e.g., servers, load balancers, machine images) should be "namespaced" with\na unique name to ensure that:\n\n1.  You don\'t accidentally overwrite any "production" resources in that environment (though as mentioned in the previous\n    section, your test environment should be completely isolated from prod anyway).\n1.  You don\'t accidentally clash with other tests running in parallel.\n\nFor example, when deploying AWS infrastructure with Terraform, that typically means exposing variables that allow you\nto configure auto scaling group names, security group names, IAM role names, and any other names that must be unique.\n\nYou can use Terratest\'s `random.UniqueId()` function to generate identifiers that are short enough to use in resource\nnames (just 6 characters) but random enough to make it unlikely that you\'ll have a conflict.\n\n```go\nuniqueId := random.UniqueId()\ninstanceName := fmt.Sprintf("terratest-http-example-%s", uniqueId)\n\nterraformOptions := &terraform.Options {\n  TerraformDir: "../examples/terraform-http-example",\n  Vars: map[string]interface{} {\n    "instance_name": instanceName,\n  },\n}\n\nterraform.Apply(t, terraformOptions)\n```\n\n\n### Cleanup\n\nSince automated tests with Terratest deploy real resources into real environments, you\'ll want to make sure your tests\nalways cleanup after themselves so you don\'t leave a bunch of resources lying around. Typically, you should use Go\'s\n`defer` keyword to ensure that the cleanup code always runs, even if the test hits an error along the way.\n\nFor example, if your test runs `terraform apply`, you should run `terraform destroy` at the end to clean up:\n\n```go\n// Ensure cleanup always runs\ndefer terraform.Destroy(t, options)\n\n// Deploy\nterraform.Apply(t, options)\n\n// Validate\ncheckServerWorks(t, options)\n```\n\nOf course, despite your best efforts, occasionally cleanup will fail, perhaps due to the CI server going down, or a bug\nin your code, or a temporary network outage. To handle those cases, we run a tool called\n[cloud-nuke](https://github.com/gruntwork-io/cloud-nuke) in our test AWS account on a nightly basis to clean up any\nleftover resources.\n\n\n### Timeouts and logging\n\nGo\'s package testing has a default timeout of 10 minutes, after which it forcibly kills your tests (even your cleanup\ncode won\'t run!). It\'s not uncommon for infrastructure tests to take longer than 10 minutes, so you\'ll want to increase\nthis timeout:\n\n```bash\ngo test -timeout 30m\n```\n\nNote that many CI systems will also kill your tests if they don\'t see any log output for a certain period of time\n(e.g., 10 minutes in CircleCI). If you use Go\'s `t.Log` and `t.Logf` for logging in your tests, you\'ll find that these\nfunctions buffer all log output until the very end of the test (see https://github.com/golang/go/issues/24929 for more\ninfo). If you have a long-running test, this might mean you get no log output for more than 10 minutes, and the CI\nsystem will shut down your tests. Moreover, if your test has a bug that causes it to hang, you won\'t see any log output\nat all to help you debug it.\n\nTherefore, we recommend instead using Terratest\'s `logger.Log` and `logger.Logf` functions, which log to `stdout`\nimmediately:\n\n```go\nfunc TestFoo(t *testing.T) {\n  logger.Log(t, "This will show up in stdout immediately")\n}\n```\n\nFinally, if you\'re testing multiple Go packages, be aware that Go will buffer log output\xe2\x80\x94even that sent directly to\n`stdout` by `logger.Log` and `logger.Logf`\xe2\x80\x94until all the tests in the package are done. This leads to the same\ndifficulties with CI servers and debugging. The workaround is to tell Go to test each package sequentially using the\n`-p 1` flag:\n\n```bash\ngo test -timeout 30m -p 1 ./...\n```\n\n\n### Debugging interleaved test output\n\n**Note**: The `terratest_log_parser` requires an explicit installation. See [Installing the utility\nbinaries](#installing-the-utility-binaries) for installation instructions.\n\nIf you log using Terratest\'s `logger` package, you may notice that all the test outputs are interleaved from the\nparallel execution. This may make it difficult to debug failures, as it can be tedious to sift through the logs to find\nthe relevant entries for a failing test, let alone find the test that failed.\n\nTherefore, Terratest ships with a utility binary `terratest_log_parser` that can be used to break out the logs.\n\nTo use the utility, you simply give it the log output from a `go test` run and a desired output directory:\n\n```bash\ngo test -timeout 30m | tee test_output.log\nterratest_log_parser -testlog test_output.log -outputdir test_output\n```\n\nThis will:\n\n- Create a file `TEST_NAME.log` for each test it finds from the test output containing the logs corresponding to that\n  test.\n- Create a `summary.log` file containing the test result lines for each test.\n- Create a `report.xml` file containing a Junit XML file of the test summary (so it can be integrated in your CI).\n\nThe output can be integrated in your CI engine to further enhance the debugging experience. See Terratest\'s own\n[circleci configuration](/.circleci/config.yml) for an example of how to integrate the utility with CircleCI. This\nprovides for each build:\n\n- A test summary view showing you which tests failed:\n\n![CircleCI test summary](/_docs/images/circleci-test-summary.png)\n\n- A snapshot of all the logs broken out by test:\n\n![CircleCI logs](/_docs/images/circleci-logs.png)\n\n\n### Avoid test caching\n\nSince Go 1.10, test results are automatically [cached](https://golang.org/doc/go1.10#test). This can lead to Go not\nrunning your tests again if you haven\'t changed any of the Go code. Since you\'re probably mainly manipulating Terraform\nfiles, you should consider turning the caching of test results off. This ensures that the tests are run every time\nyou run `go test` and the result is not just read from the cache.\n\nTo turn caching off, you can set the `-count` flag to `1` force the tests to run:\n\n```shell\n$ go test -count=1 -timeout 30m -p 1 ./...\n```\n\n\n### Error handling\n\nJust about every method `foo` in Terratest comes in two versions: `foo` and `fooE` (e.g., `terraform.Apply` and\n`terraform.ApplyE`).\n\n- `foo`: The base method takes a `t *testing.T` as an argument. If the method hits any errors, it calls `t.Fatal` to\n  fail the test.\n\n- `fooE`: Methods that end with the capital letter `E` always return an `error` as the last argument and never call\n  `t.Fatal` themselves. This allows you to decide how to handle errors.\n\nYou will use the base method name most of the time, as it allows you to keep your code more concise by avoiding\n`if err != nil` checks all over the place:\n\n```go\nterraform.Init(t, terraformOptions)\nterraform.Apply(t, terraformOptions)\nurl := terraform.Output(t, terraformOptions, "url")\n```\n\nIn the code above, if `Init`, `Apply`, or `Output` hits an error, the method will call `t.Fatal` and fail the test\nimmediately, which is typically the behavior you want. However, if you are _expecting_ an error and don\'t want it to\ncause a test failure, use the method name that ends with a capital `E`:\n\n```go\nif _, err := terraform.InitE(t, terraformOptions); err != nil {\n  // Do something with err\n}\n\nif _, err := terraform.ApplyE(t, terraformOptions); err != nil {\n  // Do something with err\n}\n\nurl, err := terraform.OutputE(t, terraformOptions, "url")\nif err != nil {\n  // Do something with err\n}\n```\n\nAs you can see, the code above is more verbose, but gives you more flexibility with how to handle errors.\n\n\n### Iterating locally using Docker\n\nFor most infrastructure code, your only option is to deploy into a real environment such as AWS. However, if you\'re\nwriting scripts (i.e., Bash, Python, or Go), you should be able to test them locally using Docker. Docker containers\ntypically build 10x faster and start 100x faster than real servers, so using Docker for testing can help you iterate\nmuch faster.\n\nHere are some techniques we use with Docker:\n\n- If your script is used in a Packer template, add a [Docker\n  builder](https://www.packer.io/docs/builders/docker.html) to the template so you can create a Docker image from the\n  same code. See the [Packer Docker Example](https://github.com/gruntwork-io/terratest/tree/master/examples/packer-docker-example) for working sample code.\n\n- We have prebuilt Docker images for major Linux distros that have many important dependencies (e.g., curl, vim,\n  tar, sudo) already installed. See the [test-docker-images folder](/test-docker-images) for more details.\n\n- Create a `docker-compose.yml` to make it easier to run your Docker image with all the ports, environment variables,\n  and other settings it needs. See the [Packer Docker Example](https://github.com/gruntwork-io/terratest/tree/master/examples/packer-docker-example) for working sample code.\n\n- With scripts in Docker, you can replace _some_ real-world dependencies with mocks! One way to do this is to create\n  some "mock scripts" and to bind-mount them in `docker-compose.yml` in a way that replaces the real dependency. For\n  example, if your script calls the `aws` CLI, you could create a mock script called `aws` that shows up earlier in the\n  `PATH`. Using mocks allows you to test 100% locally, without external dependencies such as AWS.\n\n\n### Iterating locally using test stages\n\nMost automated tests written with Terratest consist of multiple "stages", such as:\n\n1.  Build an AMI using Packer\n1.  Deploy the AMI using Terraform\n1.  Validate that the AMI works as expected\n1.  Undeploy the AMI using Terraform\n\nOften, while testing locally, you\'ll want to re-run some subset of these stages over and over again: for example, you\nmight want to repeatedly run the validation step while you work out the kinks. Having to run _all_ of these stages\neach time you change a single line of code can be very slow.\n\nThis is where Terratest\'s `test_structure` package comes in handy: it allows you to explicitly break up your tests into\nstages and to be able to disable any one of those stages simply by setting an environment variable. Check out the\n[terraform_packer_example_test.go](/test/terraform_packer_example_test.go) for working sample code.\n\n\n\n\n## Alternative testing tools\n\n1.  [A list of infrastructure testing tools](#a-list-of-infrastructure-testing-tools)\n1.  [How Terratest compares to other testing tools](#how-terratest-compares-to-other-testing-tools)\n\n\n### A list of infrastructure testing tools\n\nBelow is a list of other infrastructure testing tools you may wish to use in addition to Terratest. Check out [How\nTerratest compares to other testing tools](#how-terratest-compares-to-other-testing-tools) to understand the trade-offs.\n\n1.  [kitchen-terraform](https://github.com/newcontext-oss/kitchen-terraform)\n1.  [rspec-terraform](https://github.com/bsnape/rspec-terraform)\n1.  [serverspec](https://serverspec.org/)\n1.  [inspec](https://www.inspec.io/)\n1.  [Goss](https://github.com/aelsabbahy/goss)\n1.  [awspec](https://github.com/k1LoW/awspec)\n1.  [Terraform\'s acceptance testing framework](https://github.com/hashicorp/terraform/blob/master/.github/CONTRIBUTING.md#writing-an-acceptance-test)\n1.  [ruby_terraform](https://github.com/infrablocks/ruby_terraform)\n\n\n### How Terratest compares to other testing tools\n\nMost of the other infrastructure testing tools we\'ve seen are focused on making it easy to check the properties of a\nsingle server or resource. For example, the various `xxx-spec` tools offer a nice, concise language for connecting to\na server and checking if, say, `httpd` is installed and running. These tools are effectively verifying that individual\n"properties" of your infrastructure meet a certain spec.\n\nTerratest approaches the testing problem from a different angle. The question we\'re trying to answer is, "does the\ninfrastructure actually work?" Instead of checking individual server properties (e.g., is `httpd` installed and\nrunning), we\'ll actually make HTTP requests to the server and check that we get the expected response; or we\'ll store\ndata in a database and make sure we can read it back out; or we\'ll try to deploy a new version of a Docker container\nand make sure the orchestration tool can roll out the new container with no downtime.\n\nMoreover, we use Terratest not only with individual servers, but to test entire systems. For example, the automated\ntests for the [Vault module](https://github.com/hashicorp/terraform-aws-vault/tree/master/modules) do the following:\n\n1.  Use Packer to build an AMI.\n1.  Use Terraform to create self-signed TLS certificates.\n1.  Use Terraform to deploy all the infrastructure: a Vault cluster (which runs the AMI from the previous step), Consul\n    cluster, load balancers, security groups, S3 buckets, and so on.\n1.  SSH to a Vault node to initialize the cluster.\n1.  SSH to all the Vault nodes to unseal them.\n1.  Use the Vault SDK to store data in Vault.\n1.  Use the Vault SDK to make sure you can read the same data back out of Vault.\n1.  Use Terraform to undeploy and clean up all the infrastructure.\n\nThe steps above are exactly what you would\'ve done to test the Vault module manually. Terratest helps automate this\nprocess. You can think of Terratest as a way to do end-to-end, acceptance or integration testing, whereas most other\ntools are focused on unit or functional testing.\n\n\n### Why Terratest?\n\nOur experience with building the [Infrastructure as Code Library](https://gruntwork.io/infrastructure-as-code-library/)\nis that the _only_ way to create reliable, maintainable infrastructure code is to have a thorough suite of real-world,\nend-to-end acceptance tests. Without these sorts of tests, you simply cannot be confident that the infrastructure code\nactually works.\n\nThis is especially important with modern DevOps, as all the tools are changing so quickly. Terratest has helped us\ncatch bugs not only in our own code, but also in AWS, Azure, Terraform, Packer, Kafka, Elasticsearch, CircleCI, and\nso on. Moreover, by running tests nightly, we\'re able to catch backwards incompatible changes and\nregressions in our dependencies (e.g., backwards incompatibilities in new versions of Terraform) as early as possible.\n\n\n\n\n## Developing Terratest\n\n1.  [Contributing](#contributing)\n1.  [Running tests](#running-tests)\n1.  [Versioning](#versioning)\n\n\n### Contributing\n\nContributions are very welcome! Check out the\n[Contribution Guidelines](CONTRIBUTING.md) for instructions.\n\n\n### Running tests\n\nTerratest itself includes a number of automated tests.\n\n**Note #1**: Some of these tests create real resources in an AWS account. That means they cost money to run, especially\nif you don\'t clean up after yourself. Please be considerate of the resources you create and take extra care to clean\neverything up when you\'re done!\n\n**Note #2**: In order to run tests that access your AWS account, you will need to configure your [AWS CLI\ncredentials](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html). For example, you could\nset the credentials as the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.\n\n**Note #3**: Never hit `CTRL + C` or cancel a build once tests are running or the cleanup tasks won\'t run!\n\n**Prerequisite**: Most the tests expect Terraform, Packer, and/or Docker to already be installed and in your `PATH`.\n\nTo run all the tests:\n\n```bash\ngo test -v -timeout 30m -p 1 ./...\n```\n\nTo run the tests in a specific folder:\n\n```bash\ncd "<FOLDER_PATH>"\ngo test -timeout 30m\n```\n\nTo run a specific test in a specific folder:\n\n```bash\ncd "<FOLDER_PATH>"\ngo test -timeout 30m -run "<TEST_NAME>"\n```\n\n\n### Versioning\n\nThis repo follows the principles of [Semantic Versioning](http://semver.org/). You can find each new release,\nalong with the changelog, in the [Releases Page](https://github.com/gruntwork-io/terratest/releases).\n\nDuring initial development, the major version will be 0 (e.g., `0.x.y`), which indicates the code does not yet have a\nstable API. Once we hit `1.0.0`, we will make every effort to maintain a backwards compatible API and use the MAJOR,\nMINOR, and PATCH versions on each release to indicate any incompatibilities.\n\n\n\n\n## License\n\nThis code is released under the Apache 2.0 License. Please see [LICENSE](LICENSE) and [NOTICE](NOTICE) for more details.\n\nCopyright &copy; 2018 Gruntwork, Inc.\n'