b'[![Maintained by Gruntwork.io](https://img.shields.io/badge/maintained%20by-gruntwork.io-%235849a6.svg)](https://gruntwork.io/?ref=repo_terragrunt)\n[![Go Report Card](https://goreportcard.com/badge/github.com/gruntwork-io/terragrunt)](https://goreportcard.com/report/github.com/gruntwork-io/terragrunt)\n[![GoDoc](https://godoc.org/github.com/gruntwork-io/terragrunt?status.svg)](https://godoc.org/github.com/gruntwork-io/terragrunt)\n![Terraform Version](https://img.shields.io/badge/tf-%3E%3D0.12.0-blue.svg)\n\n# Terragrunt\n\nTerragrunt is a thin wrapper for [Terraform](https://www.terraform.io/) that provides extra tools for keeping your\nTerraform configurations [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself),\nworking with multiple Terraform modules, and managing remote state. Check out\n[Terragrunt: how to keep your Terraform code DRY and\nmaintainable](https://blog.gruntwork.io/terragrunt-how-to-keep-your-terraform-code-dry-and-maintainable-f61ae06959d8)\nfor a quick introduction to Terragrunt.\n\n## Quick start\n\n1. [Install Terraform](https://www.terraform.io/intro/getting-started/install.html).\n\n1. Install Terragrunt by going to the [Releases Page](https://github.com/gruntwork-io/terragrunt/releases),\n   downloading the binary for your OS, renaming it to `terragrunt`, and adding it to your PATH.\n     * See the [Install Terragrunt](#install-terragrunt) docs for other installation options.\n\n1. Go into a folder with your Terraform configurations (`.tf` files) and create a `terragrunt.hcl` or `terragrunt.hcl.json` file that contains \n   the configuration for Terragrunt (Terragrunt configuration uses the exact language, HCL, as Terraform. [JSON configuration syntax](https://www.terraform.io/docs/configuration/syntax-json.html) is also supported.). Here\'s an \n   example of using Terragrunt to keep your Terraform backend configuration DRY (check out the [Use cases](#use-cases) \n   section for other types of configuration Terragrunt supports):\n\n    ```hcl\n    # terragrunt.hcl example\n    remote_state {\n      backend = "s3"\n      config = {\n        bucket         = "my-terraform-state"\n        key            = "${path_relative_to_include()}/terraform.tfstate"\n        region         = "us-east-1"\n        encrypt        = true\n        dynamodb_table = "my-lock-table"\n      }   \n    }\n    ```\n\n    ```json\n    # terragrunt.hcl.json example\n    {\n      "remote_state":{\n        "backend": "s3",\n        "config":{\n          "bucket"         : "my-terraform-state",\n          "key"            : "${path_relative_to_include()}/terraform.tfstate",\n          "region"         : "us-east-1",\n          "encrypt"        : true,\n          "dynamodb_table" : "my-lock-table"\n        }\n      }\n    }\n    ```\n\n1. Now, instead of running `terraform` directly, run all the standard Terraform commands using `terragrunt`:\n\n    ```bash\n    terragrunt get\n    terragrunt plan\n    terragrunt apply\n    terragrunt output\n    terragrunt destroy\n    ```\n\n   Terragrunt forwards almost all commands, arguments, and options directly to Terraform, using whatever version of\n   Terraform you already have installed. However, based on the settings in your `terragrunt.hcl` file, Terragrunt can\n   configure remote state, locking, extra arguments, and lots more.\n\n1. Terragrunt is a direct implementation of the ideas expressed in\n   [Terraform: Up & Running](http://www.terraformupandrunning.com). Additional background reading that will help\n   explain the motivation for Terragrunt include\n   [Terragrunt: how to keep your Terraform code DRY and\n   maintainable](https://blog.gruntwork.io/terragrunt-how-to-keep-your-terraform-code-dry-and-maintainable-f61ae06959d8),\n   [How to create reusable infrastructure with Terraform modules](https://blog.gruntwork.io/how-to-create-reusable-infrastructure-with-terraform-modules-25526d65f73d)\n   and [How to use Terraform as a team](https://blog.gruntwork.io/how-to-use-terraform-as-a-team-251bc1104973).\n\n1. Check out the [terragrunt-infrastructure-modules-example](https://github.com/gruntwork-io/terragrunt-infrastructure-modules-example)\n   and [terragrunt-infrastructure-live-example](https://github.com/gruntwork-io/terragrunt-infrastructure-live-example)\n   repos for fully-working sample code that demonstrates how to use Terragrunt.\n\n\n## Table of Contents\n\n1. [Install Terragrunt](#install-terragrunt)\n1. [Migrating to Terraform 0.12 and Terragrunt 0.19.x](#migrating-to-terraform-012-and-terragrunt-019x)\n1. [Use cases](#use-cases)\n   1. [Keep your Terraform code DRY](#keep-your-terraform-code-dry)\n   1. [Keep your remote state configuration DRY](#keep-your-remote-state-configuration-dry)\n   1. [Keep your CLI flags DRY](#keep-your-cli-flags-dry)\n   1. [Execute Terraform commands on multiple modules at once](#execute-terraform-commands-on-multiple-modules-at-once)\n   1. [Work with multiple AWS accounts](#work-with-multiple-aws-accounts)\n1. [Terragrunt details](#terragrunt-details)\n   1. [Inputs](#inputs)\n   1. [AWS credentials](#aws-credentials)\n   1. [AWS IAM policies](#aws-iam-policies)\n   1. [Built-in Functions](#built-in-functions)\n   1. [Before and After Hooks](#before-and-after-hooks)\n   1. [Auto-Init](#auto-init)\n   1. [Auto-Retry](#auto-retry)\n   1. [CLI options](#cli-options)\n   1. [Configuration](#configuration)\n   1. [Configuration parsing order](#configuration-parsing-order)\n   1. [Formatting terragrunt.hcl](#formatting-terragrunthcl)\n   1. [Clearing the Terragrunt cache](#clearing-the-terragrunt-cache)\n   1. [Contributing](#contributing)\n   1. [Developing Terragrunt](#developing-terragrunt)\n   1. [License](#license)\n\n\n## Install Terragrunt\n\nNote that third-party Terragrunt packages may not be updated with the latest version, but are often close.\nPlease check your version against the latest available on the\n[Releases Page](https://github.com/gruntwork-io/terragrunt/releases).\n\n### Windows\nYou can install Terragrunt on Windows using [Chocolatey](https://chocolatey.org/): `choco install terragrunt`.\n\n### macOS\nYou can install Terragrunt on macOS using [Homebrew](https://brew.sh/): `brew install terragrunt`.\n\n### Linux\nYou can install Terragrunt on Linux using [Homebrew](https://docs.brew.sh/Homebrew-on-Linux): `brew install terragrunt`.\n\n### Manual\nYou can install Terragrunt manually by going to the [Releases Page](https://github.com/gruntwork-io/terragrunt/releases),\ndownloading the binary for your OS, renaming it to `terragrunt`, and adding it to your PATH.\n\n\n\n\n\n## Migrating to Terraform 0.12 and Terragrunt 0.19.x\n\nIf you were using Terraform <= 0.11.x with Terragrunt <= 0.18.x, and you wish to upgrade to Terraform 0.12.x newer,\nyou\'ll need to upgrade to Terragrunt 0.19.x or newer. Due to some changes in Terraform 0.12.x, this is a backwards\nincompatible upgrade that requires some manual migration steps. Check out our [Upgrading to Terragrunt 0.19.x\nGuide](/_docs/migration_guides/upgrading_to_terragrunt_0.19.x.md) for instructions.\n\n## Required terraform version\n\nWe only support and test against the latest version of terraform, however older versions might still work.\n\n## Use cases\n\nTerragrunt supports the following use cases:\n\n1. [Keep your Terraform code DRY](#keep-your-terraform-code-dry)\n1. [Keep your remote state configuration DRY](#keep-your-remote-state-configuration-dry)\n1. [Keep your CLI flags DRY](#keep-your-cli-flags-dry)\n1. [Execute Terraform commands on multiple modules at once](#execute-terraform-commands-on-multiple-modules-at-once)\n1. [Work with multiple AWS accounts](#work-with-multiple-aws-accounts)\n\n\n### Keep your Terraform code DRY\n\n* [Motivation](#motivation)\n* [Remote Terraform configurations](#remote-terraform-configurations)\n* [How to use remote configurations](#how-to-use-remote-configurations)\n* [Achieve DRY Terraform code and immutable infrastructure](#achieve-dry-terraform-code-and-immutable-infrastructure)\n* [Working locally](#working-locally)\n* [Important gotcha: working with relative file paths](#important-gotcha-working-with-relative-file-paths)\n* [Using Terragrunt with private Git repos](#using-terragrunt-with-private-git-repos)\n\n\n#### Motivation\n\nConsider the following file structure, which defines three environments (prod, qa, stage) with the same infrastructure\nin each one (an app, a MySQL database, and a VPC):\n\n```\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 live\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 prod\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n    \xe2\x94\x82\xc2\xa0\xc2\xa0     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 qa\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n    \xe2\x94\x82\xc2\xa0\xc2\xa0     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 stage\n        \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n        \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n        \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n        \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n        \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n            \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n```\n\nThe contents of each environment will be more or less identical, except perhaps for a few settings (e.g. the prod\nenvironment may run bigger or more servers). As the size of the infrastructure grows, having to maintain all of this\nduplicated code between environments becomes more error prone. You can reduce the amount of copy paste using\n[Terraform modules](https://blog.gruntwork.io/how-to-create-reusable-infrastructure-with-terraform-modules-25526d65f73d),\nbut even the code to instantiate a module and set up input variables, output variables, providers, and remote state\ncan still create a lot of maintenance overhead.\n\nHow can you keep your Terraform code [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) so that you only\nhave to define it once, no matter how many environments you have?\n\n\n#### Remote Terraform configurations\n\nTerragrunt has the ability to download remote Terraform configurations. The idea is that you define the Terraform code\nfor your infrastructure just once, in a single repo, called, for example, `modules`:\n\n```\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 modules\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n    \xc2\xa0\xc2\xa0  \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n```\n\nThis repo contains typical Terraform code, with one difference: anything in your code that should be different between\nenvironments should be exposed as an input variable. For example, the `app` module might expose the following\nvariables:\n\n```hcl\nvariable "instance_count" {\n  description = "How many servers to run"\n}\n\nvariable "instance_type" {\n  description = "What kind of servers to run (e.g. t2.large)"\n}\n```\n\nThese variables allow you to run smaller/fewer servers in qa and stage to save money and larger/more servers in prod to\nensure availability and scalability.\n\nIn a separate repo, called, for example, `live`, you define the code for all of your environments, which now consists\nof just one `terragrunt.hcl` file per component (e.g. `app/terragrunt.hcl`, `mysql/terragrunt.hcl`, etc). This gives you\nthe following file layout:\n\n```\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 live\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 prod\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n    \xe2\x94\x82\xc2\xa0\xc2\xa0     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 qa\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n    \xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n    \xe2\x94\x82\xc2\xa0\xc2\xa0     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 stage\n     \xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app\n     \xc2\xa0\xc2\xa0 \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n     \xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n     \xc2\xa0\xc2\xa0 \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n     \xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n     \xc2\xa0\xc2\xa0     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nNotice how there are no Terraform configurations (`.tf` files) in any of the folders. Instead, each `terragrunt.hcl`\nfile specifies a `terraform { ... }` block that specifies from where to download the Terraform code, as well as the\nenvironment-specific values for the input variables in that Terraform code. For example,\n`stage/app/terragrunt.hcl` may look like this:\n\n```hcl\nterraform {\n  # Deploy version v0.0.3 in stage\n  source = "git::git@github.com:foo/modules.git//app?ref=v0.0.3"\n}\n\ninputs = {\n  instance_count = 3\n  instance_type  = "t2.micro"\n}\n```\n\n*(Note: the double slash (`//`) in the `source` parameter is intentional and required. It\'s part of Terraform\'s Git\nsyntax for [module sources](https://www.terraform.io/docs/modules/sources.html). Terraform may display a "Terraform\ninitialized in an empty directory" warning, but you can safely ignore it.)*\n\nAnd `prod/app/terragrunt.hcl` may look like this:\n\n```hcl\nterraform {\n  # Deploy version v0.0.1 in prod\n  source = "git::git@github.com:foo/modules.git//app?ref=v0.0.1"\n}\n\ninputs = {\n  instance_count = 10\n  instance_type  = "m2.large"\n}\n```\n\nYou can now deploy the modules in your `live` repo. For example, to deploy the `app` module in stage, you would do the\nfollowing:\n\n```\ncd live/stage/app\nterragrunt apply\n```\n\nWhen Terragrunt finds the `terraform` block with a `source` parameter in `live/stage/app/terragrunt.hcl` file, it will:\n\n1. Download the configurations specified via the `source` parameter into the `--terragrunt-download-dir` folder (by\n   default `.terragrunt-cache` in the working directory, which we recommend adding to `.gitignore`). This downloading\n   is done by using the same [go-getter library](https://github.com/hashicorp/go-getter) Terraform uses, so the `source`\n   parameter supports the exact same syntax as the [module source](https://www.terraform.io/docs/modules/sources.html)\n   parameter, including local file paths, Git URLs, and Git URLs with `ref` parameters (useful for checking out a\n   specific tag, commit, or branch of Git repo). Terragrunt will download all the code in the repo (i.e. the part\n   before the double-slash `//`) so that relative paths work correctly between modules in that repo.\n\n1. Copy all files from the current working directory into the temporary folder.\n\n1. Execute whatever Terraform command you specified in that temporary folder.\n\n1. Pass any variables defined in the `inputs = { ... }` block as environment variables (prefixed with `TF_VAR_` to your\n   Terraform code. Notice how the `inputs` block in `stage/app/terragrunt.hcl` deploys fewer and smaller instances than\n   prod.\n\n\nCheck out the [terragrunt-infrastructure-modules-example](https://github.com/gruntwork-io/terragrunt-infrastructure-modules-example)\nand [terragrunt-infrastructure-live-example](https://github.com/gruntwork-io/terragrunt-infrastructure-live-example)\nrepos for fully-working sample code that demonstrates this new folder structure.\n\n\n\n#### Achieve DRY Terraform code and immutable infrastructure\n\nWith this new approach, copy/paste between environments is minimized. The `terragrunt.hcl` files contain solely the\n`source` URL of the module to deploy and the `inputs` to set for that module in the current environment. To create a\nnew environment, you copy an old one and update just the environment-specific `inputs` in the `terragrunt.hcl` files,\nwhich is about as close to the "essential complexity" of the problem as you can get.\n\nJust as importantly, since the Terraform module code is now defined in a single repo, you can version it (e.g., using Git\ntags and referencing them using the `ref` parameter in the `source` URL, as in the `stage/app/terragrunt.hcl` and\n`prod/app/terragrunt.hcl` examples above), and promote a single, immutable version through each environment (e.g.,\nqa -> stage -> prod). This idea is inspired by Kief Morris\' blog post [Using Pipelines to Manage Environments with\nInfrastructure as Code](https://medium.com/@kief/https-medium-com-kief-using-pipelines-to-manage-environments-with-infrastructure-as-code-b37285a1cbf5).\n\n\n#### Working locally\n\nIf you\'re testing changes to a local copy of the `modules` repo, you can use the `--terragrunt-source` command-line\noption or the `TERRAGRUNT_SOURCE` environment variable to override the `source` parameter. This is useful to point\nTerragrunt at a local checkout of your code so you can do rapid, iterative, make-a-change-and-rerun development:\n\n```\ncd live/stage/app\nterragrunt apply --terragrunt-source ../../../modules//app\n```\n\n*(Note: the double slash (`//`) here too is intentional and required. Terragrunt downloads all the code in the folder\nbefore the double-slash into the temporary folder so that relative paths between modules work correctly. Terraform may\ndisplay a "Terraform initialized in an empty directory" warning, but you can safely ignore it.)*\n\n\n#### Important gotcha: Terragrunt caching\n\nThe first time you set the `source` parameter to a remote URL, Terragrunt will download the code from that URL into a tmp folder.\nIt will *NOT* download it again afterwords unless you change that URL. That\'s because downloading code\xe2\x80\x94and more importantly,\nreinitializing remote state, redownloading provider plugins, and redownloading modules\xe2\x80\x94can take a long time. To avoid adding 10-90\nseconds of overhead to every Terragrunt command, Terragrunt assumes all remote URLs are immutable, and only downloads them once.\n\nTherefore, when working locally, you should use the `--terragrunt-source` parameter and point it at a local file path as described\nin the previous section. Terragrunt will copy the local files every time you run it, which is nearly instantaneous, and doesn\'t\nrequire reinitializing everything, so you\'ll be able to iterate quickly.\n\nIf you need to force Terragrunt to redownload something from a remote URL, run Terragrunt with the `--terragrunt-source-update` flag\nand it\'ll delete the tmp folder, download the files from scratch, and reinitialize everything. This can take a while, so avoid it\nand use `--terragrunt-source` when you can!\n\n#### Important gotcha: working with relative file paths\n\nOne of the gotchas with downloading Terraform configurations is that when you run `terragrunt apply` in folder `foo`,\nTerraform will actually execute in some temporary folder such as `.terragrunt-cache/foo`. That means you have to be\nespecially careful with relative file paths, as they will be relative to that temporary folder and not the folder where\nyou ran Terragrunt!\n\nIn particular:\n\n* **Command line**: When using file paths on the command line, such as passing an extra `-var-file` argument, you\n  should use absolute paths:\n\n    ```bash\n    # Use absolute file paths on the CLI!\n    terragrunt apply -var-file /foo/bar/extra.tfvars\n    ```\n\n* **Terragrunt configuration**: When using file paths directly in your Terragrunt configuration (`terragrunt.hcl`),\n  such as in an `extra_arguments` block, you can\'t use hard-coded absolute file paths, or it won\'t work on your\n  teammates\' computers. Therefore, you should utilize the Terragrunt built-in function `get_terragrunt_dir()` to use\n  a relative file path:\n\n    ```hcl\n    terraform {\n      source = "git::git@github.com:foo/modules.git//frontend-app?ref=v0.0.3"\n\n      extra_arguments "custom_vars" {\n        commands = [\n          "apply",\n          "plan",\n          "import",\n          "push",\n          "refresh"\n        ]\n\n        # With the get_terragrunt_dir() function, you can use relative paths!\n        arguments = [\n          "-var-file=${get_terragrunt_dir()}/../common.tfvars",\n          "-var-file=example.tfvars"\n        ]\n      }\n    }\n    ```\n\n  See the [get_terragrunt_dir()](#get_terragrunt_dir) documentation for more details.\n\n\n#### Using Terragrunt with private Git repos\n\nThe easiest way to use Terragrunt with private Git repos is to use SSH authentication.\nConfigure your Git account so you can use it with SSH\n(see the [guide for GitHub here](https://help.github.com/articles/connecting-to-github-with-ssh/))\nand use the SSH URL for your repo, prepended with `git::ssh://`:\n\n```hcl\nterraform {\n  source = "git::ssh://git@github.com/foo/modules.git//path/to/module?ref=v0.0.1"\n}\n```\nLook up the Git repo for your repository to find the proper format.\n\nNote: In automated pipelines, you may need to run the following command for your\nGit repository prior to calling `terragrunt` to ensure that the ssh host is registered\nlocally, e.g.:\n\n```\n$ ssh -T -oStrictHostKeyChecking=accept-new git@github.com || true\n```\n\n\n### Keep your remote state configuration DRY\n\n* [Motivation](#motivation-1)\n* [Filling in remote state settings with Terragrunt](#filling-in-remote-state-settings-with-terragrunt)\n* [Create remote state and locking resources automatically](#create-remote-state-and-locking-resources-automatically)\n\n\n#### Motivation\n\nTerraform supports [remote state storage](https://www.terraform.io/docs/state/remote.html) via a variety of\n[backends](https://www.terraform.io/docs/backends) that you normally configure in your `.tf` files as follows:\n\n```hcl\nterraform {\n  backend "s3" {\n    bucket         = "my-terraform-state"\n    key            = "frontend-app/terraform.tfstate"\n    region         = "us-east-1"\n    encrypt        = true\n    dynamodb_table = "my-lock-table"\n  }\n}\n```\n\nUnfortunately, the `backend` configuration does not support expressions, variables, or functions. This makes it hard to\nkeep your code [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) if you have multiple Terraform modules. For\nexample, consider the following folder structure, which uses different Terraform modules to deploy a backend app,\nfrontend app, MySQL database, and a VPC:\n\n```\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 backend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 frontend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n```\n\nTo use remote state with each of these modules, you would have to copy/paste the exact same `backend` configuration\ninto each of the `main.tf` files. The only thing that would differ between the configurations would be the `key`\nparameter: e.g., the `key` for `mysql/main.tf` might be `mysql/terraform.tfstate` and the `key` for\n`frontend-app/main.tf` might be `frontend-app/terraform.tfstate`.\n\nTo keep your remote state configuration DRY, you can use Terragrunt. You still have to specify the `backend` you want\nto use in each module, but instead of copying and pasting the configuration settings over and over again into each\n`main.tf` file, you can leave them blank (this is known as [partial\nconfiguration](https://www.terraform.io/docs/backends/config.html#partial-configuration)):\n\n```hcl\nterraform {\n  # The configuration for this backend will be filled in by Terragrunt\n  backend "s3" {}\n}\n```\n\n\n#### Filling in remote state settings with Terragrunt\n\nTo fill in the settings via Terragrunt, create a `terragrunt.hcl` file in the root folder, plus one `terragrunt.hcl`\nfile in each of the Terraform modules:\n\n```\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 backend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 frontend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nIn your **root** `terragrunt.hcl` file, you can define your entire remote state configuration just once in a\n`remote_state` block (which supports all the same [backend types](https://www.terraform.io/docs/backends/types/index.html)\nas Terraform), as follows:\n\n```hcl\nremote_state {\n  backend = "s3"\n  config = {\n    bucket         = "my-terraform-state"\n    key            = "${path_relative_to_include()}/terraform.tfstate"\n    region         = "us-east-1"\n    encrypt        = true\n    dynamodb_table = "my-lock-table"\n  }\n}\n```\n\nIn each of the **child** `terragrunt.hcl` files, such as `mysql/terragrunt.hcl`, you can tell Terragrunt to\nautomatically include all the settings from the root `terragrunt.hcl` file as follows:\n\n```hcl\ninclude {\n  path = find_in_parent_folders()\n}\n```\n\nThe `include` block tells Terragrunt to use the exact same Terragrunt configuration from the `terragrunt.hcl` file\nspecified via the `path` parameter. It behaves exactly as if you had copy/pasted the Terraform configuration from\nthe included file `remote_state` configuration into `mysql/terragrunt.hcl`, but this approach is much easier to\nmaintain!\n\nThe next time you run `terragrunt`, it will automatically configure all the settings in the\n`remote_state.config` block, if they aren\'t configured already, by calling [terraform\ninit](https://www.terraform.io/docs/commands/init.html).\n\nThe `terragrunt.hcl` files above use two Terragrunt built-in functions:\n\n* `find_in_parent_folders()`: This function returns the path to the first `terragrunt.hcl` file it finds in the parent\n  folders above the current `terragrunt.hcl` file. In the example above, the call to `find_in_parent_folders()` in\n  `mysql/terragrunt.hcl` will return `../terragrunt.hcl`. This way, you don\'t have to hard code the `path`\n  parameter in every module.\n\n* `path_relative_to_include()`: This function returns the relative path between the current `terragrunt.hcl`\n  file and the path specified in its `include` block. We typically use this in a root `terragrunt.hcl` file so that\n  each Terraform child module stores its Terraform state at a different `key`. For example, the `mysql` module will\n  have its `key` parameter resolve to `mysql/terraform.tfstate` and the `frontend-app` module will have its `key`\n  parameter resolve to `frontend-app/terraform.tfstate`.\n\nSee [the Built-in Functions docs](#built-in-functions) for more info.\n\nCheck out the [terragrunt-infrastructure-modules-example](https://github.com/gruntwork-io/terragrunt-infrastructure-modules-example)\nand [terragrunt-infrastructure-live-example](https://github.com/gruntwork-io/terragrunt-infrastructure-live-example)\nrepos for fully-working sample code that demonstrates how to use Terragrunt to manage remote state.\n\n\n#### Rules for merging parent and child configurations\n\nThe child `.hcl` file\'s `terraform` settings will be merged into the parent file\'s `terraform` settings as follows:\n\n* If an `extra_arguments` block in the child has the same name as an `extra_arguments` block in the parent,\n  then the child\'s block will override the parent\'s.\n  * Specifying an empty `extra_arguments` block in a child with the same name will effectively remove the parent\'s block.\n* If an `extra_arguments` block in the child has a different name than `extra_arguments` blocks in the parent,\n  then both the parent and child\'s `extra_arguments` will be effective.\n  * The child\'s `extra_arguments` will be placed _after_ the parent\'s `extra_arguments` on the terraform command line.\n  * Therefore, if a child\'s and parent\'s `extra_arguments` include `.tfvars` files with the same variable defined,\n    the value from the `.tfvars` file from the child\'s `extra_arguments` will be used by terraform.\n* If a `before_hook` or `after_hook` block in the child has the same name as the hook block in the parent,\n  then the child\'s block will override the parent\'s.\n  * Specifying an empty hook block in a child with the same name will effectively remove the parent\'s block.\n* If a `before_hook` or `after_hook` block in the child has a different name than hook blocks in the parent,\n  then both the parent and child\'s hook blocks will be effective.\n* The `source` field in the child will override `source` field in the parent\n\nOther settings in the child `.hcl` file override the respective settings in the parent.\n\n\n#### Create remote state and locking resources automatically\n\nWhen you run `terragrunt` with `remote_state` configuration, it will automatically create the following resources if\nthey don\'t already exist:\n\n* **S3 bucket**: If you are using the [S3 backend](https://www.terraform.io/docs/backends/types/s3.html) for remote\n  state storage and the `bucket` you specify in `remote_state.config` doesn\'t already exist, Terragrunt will create it\n  automatically, with [versioning](https://docs.aws.amazon.com/AmazonS3/latest/dev/Versioning.html),\n  [server-side encryption](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html), and\n  [access logging](https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerLogs.html) enabled.\n\n  In addition, you can let terragrunt tag the bucket with custom tags that you specify in\n  `remote_state.config.s3_bucket_tags`.\n\n* **DynamoDB table**: If you are using the [S3 backend](https://www.terraform.io/docs/backends/types/s3.html) for\n  remote state storage and you specify a `dynamodb_table` (a [DynamoDB table used for\n  locking](https://www.terraform.io/docs/backends/types/s3.html#dynamodb_table)) in `remote_state.config`, if that table\n  doesn\'t already exist, Terragrunt will create it automatically, with\n  [server-side encryption](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/EncryptionAtRest.html)\n  enabled, including a primary key called `LockID`.\n\n  In addition, you can let terragrunt tag the DynamoDB table with custom tags that you specify in\n  `remote_state.config.dynamodb_table_tags`.\n\n- **GCS bucket**: If you are using the [GCS backend](https://www.terraform.io/docs/backends/types/gcs.html) for remote\n  state storage and the `bucket` you specify in `remote_state.config` doesn\'t already exist, Terragrunt will create it\n  automatically, with [versioning](https://cloud.google.com/storage/docs/object-versioning) enabled. For this to work\n  correctly you must also specify `project` and `location` keys in `remote_state.config`, so Terragrunt knows where to\n  create the bucket. You will also need to supply valid credentials using either `remote_state.config.credentials` or by\n  setting the `GOOGLE_APPLICATION_CREDENTIALS` environment variable. If you want to skip creating the bucket entirely,\n  simply set `skip_bucket_creation` to `true` and Terragrunt will assume the bucket has already been created. If you\n  don\'t specify `bucket` in `remote_state` then terragrunt will assume that you will pass `bucket` through\n  `-backend-config` in `extra_arguments`.\n\n  We also strongly recommend you enable [Cloud Audit Logs](https://cloud.google.com/storage/docs/access-logs) to audit\n  and track API operations performed against the state bucket.\n\n  In addition, you can let Terragrunt label the bucket with custom labels that you specify in\n  `remote_state.config.gcs_bucket_labels`.\n\n**Note**: If you specify a `profile` key in `remote_state.config`, Terragrunt will automatically use this AWS profile\nwhen creating the S3 bucket or DynamoDB table.\n\n**Note**: You can disable automatic remote state initialization by setting `remote_state.disable_init`, this will\nskip the automatic creation of remote state resources and will execute `terraform init` passing the `backend=false` option.\nThis can be handy when running commands such as `validate-all` as part of a CI process where you do not want to initialize remote state.\n\nThe following example demonstrates using an environment variable to configure this option:\n\n```hcl\nremote_state {\n  # ...\n\n  disable_init = tobool(get_env("TERRAGRUNT_DISABLE_INIT", "false"))\n}\n```\n\n#### S3-specific remote state settings\n\nFor the `s3` backend, the following config options can be used for S3-compatible object stores, as necessary:\n\n```hcl\nremote_state {\n  # ...\n\n  skip_bucket_versioning         = true # use only if the object store does not support versioning\n  skip_bucket_ssencryption       = true # use only if non-encrypted Terraform State is required and/or the object store does not support server-side encryption\n  skip_bucket_accesslogging      = true # use only if the cost for the extra object space is undesirable or the object store does not support access logging\n  enable_lock_table_ssencryption = true # use only if non-encrypted DynamoDB Lock Table for the Terraform State is required and/or the NoSQL database service does not support server-side encryption\n\n  shared_credentials_file     = "/path/to/credentials/file"\n  skip_credentials_validation = true\n  skip_metadata_api_check     = true\n  force_path_style            = true\n}\n```\n\nIf you experience an error for any of these configurations, confirm you are using Terraform v0.12.2 or greater.\n\nFurther, the config options `s3_bucket_tags`, `dynamodb_table_tags`, `skip_bucket_versioning`,\n`skip_bucket_ssencryption`, `skip_bucket_accesslogging`, and `enable_lock_table_ssencryption` are only valid for\nbackend `s3`. They are used by terragrunt and are **not** passed on to\nterraform. See section [Create remote state and locking resources automatically](#create-remote-state-and-locking-resources-automatically).\n\n\n#### GCS-specific remote state settings\n\nFor the `gcs` backend, the following config options can be used for GCS-compatible object stores, as necessary:\n\n```hcl\nremote_state {\n # ...\n\n skip_bucket_versioning = true # use only if the object store does not support versioning\n\n encryption_key = "GOOGLE_ENCRYPTION_KEY"\n}\n```\n\nIf you experience an error for any of these configurations, confirm you are using Terraform v0.12.0 or greater.\n\nFurther, the config options `gcs_bucket_labels` and `skip_bucket_versioning` are only valid for the backend `gcs`. They are used by\nterragrunt and are **not** passed on to terraform. See section [Create remote state and locking resources automatically](#create-remote-state-and-locking-resources-automatically).\n\n### Keep your CLI flags DRY\n\n* [Motivation](#motivation-2)\n* [Multiple extra_arguments blocks](#multiple-extra_arguments-blocks)\n* [extra_arguments for init](#extra_arguments-for-init)\n* [Required and optional var-files](#required-and-optional-var-files)\n* [Handling whitespace](#handling-whitespace)\n\n#### Motivation\n\nSometimes you may need to pass extra CLI arguments every time you run certain `terraform` commands. For example, you\nmay want to set the `lock-timeout` setting to 20 minutes for all commands that may modify remote state so that\nTerraform will keep trying to acquire a lock for up to 20 minutes if someone else already has the lock rather than\nimmediately exiting with an error.\n\nYou can configure Terragrunt to pass specific CLI arguments for specific commands using an `extra_arguments` block\nin your `terragrunt.hcl` file:\n\n```hcl\nterraform {\n  # Force Terraform to keep trying to acquire a lock for\n  # up to 20 minutes if someone else already has the lock\n  extra_arguments "retry_lock" {\n    commands = [\n      "init",\n      "apply",\n      "refresh",\n      "import",\n      "plan",\n      "taint",\n      "untaint"\n    ]\n\n    arguments = [\n      "-lock-timeout=20m"\n    ]\n\n    env_vars = {\n      TF_VAR_var_from_environment = "value"\n    }\n  }\n}\n```\n\nEach `extra_arguments` block includes an arbitrary name (in the example above, `retry_lock`), a list of `commands` to\nwhich the extra arguments should be added, and a list of `arguments` or `required_var_files` or `optional_var_files` to\nadd. You can also pass custom environment variables using `env_vars` block, which stores environment variables in key\nvalue pairs. With the configuration above, when you run `terragrunt apply`, Terragrunt will call Terraform as follows:\n\n```\n$ terragrunt apply\n\nterraform apply -lock-timeout=20m\n```\n\nYou can even use built-in functions such as\n[get_terraform_commands_that_need_locking](#get_terraform_commands_that_need_locking) to automatically populate the\nlsit of Terraform commands that need locking:\n\n```hcl\nterraform {\n  # Force Terraform to keep trying to acquire a lock for up to 20 minutes if someone else already has the lock\n  extra_arguments "retry_lock" {\n    commands  = get_terraform_commands_that_need_locking()\n    arguments = ["-lock-timeout=20m"]\n  }\n}\n```\n\n\n\n#### Multiple extra_arguments blocks\n\nYou can specify one or more `extra_arguments` blocks. The `arguments` in each block will be applied any time you call\n`terragrunt` with one of the commands in the `commands` list. If more than one `extra_arguments` block matches a\ncommand, the arguments will be added in the order of appearance in the configuration. For example, in addition to\nlock settings, you may also want to pass custom `-var-file` arguments to several commands:\n\n```hcl\nterraform {\n  # Force Terraform to keep trying to acquire a lock for\n  # up to 20 minutes if someone else already has the lock\n  extra_arguments "retry_lock" {\n    commands  = get_terraform_commands_that_need_locking()\n    arguments = ["-lock-timeout=20m"]\n  }\n\n  # Pass custom var files to Terraform\n  extra_arguments "custom_vars" {\n    commands = [\n      "apply",\n      "plan",\n      "import",\n      "push",\n      "refresh"\n    ]\n\n    arguments = [\n      "-var", "foo=bar",\n      "-var", "region=us-west-1"\n    ]\n  }\n}\n```\n\nWith the configuration above, when you run `terragrunt apply`, Terragrunt will call Terraform as follows:\n\n```\n$ terragrunt apply\n\nterraform apply -lock-timeout=20m -var foo=bar -var region=us-west-1\n```\n\n#### `extra_arguments` for `init`\n\nExtra arguments for the `init` command have some additional behavior and constraints.\n\nIn addition to being appended to the `terraform init` command that is run when you explicitly run `terragrunt init`,\n`extra_arguments` for `init` will also be appended to the `init` commands that are automatically\nrun during other commands (see [Auto-Init](#auto-init)).\n\nYou must _not_ specify the `-from-module` option (aka. the `SOURCE` argument for terraform < 0.10.0) or the `DIR`\nargument in the `extra_arguments` for `init`. This option and argument will be provided automatically by terragrunt.\n\nHere\'s an example of configuring `extra_arguments` for `init` in an environment in which terraform plugins are manually installed,\nrather than relying on terraform to automatically download them.\n\n```hcl\nterraform {\n  # ...\n\n  extra_arguments "init_args" {\n    commands = [\n      "init"\n    ]\n\n    arguments = [\n      "-get-plugins=false",\n      "-plugin-dir=/my/terraform/plugin/dir",\n    ]\n  }\n}\n```\n\n\n#### Required and optional var-files\n\nOne common usage of extra_arguments is to include tfvars files. Instead of using arguments, it is simpler to use\neither `required_var_files` or `optional_var_files`. Both options require only to provide the list of file to include.\nThe only difference is that `required_var_files` will add the extra argument `-var-file=<your file>` for each file\nspecified and if they don\'t exist, exit with an error. `optional_var_files`, on the other hand, will skip over files\nthat don\'t exists. This allows many conditional configurations based on environment variables as you can see in the\nfollowing example:\n\n```\n/my/tf\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 prod.tfvars\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 us-west-2.tfvars\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 backend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 dev.tfvars\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 frontend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 us-east-1.tfvars\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\n```hcl\nterraform {\n  extra_arguments "conditional_vars" {\n    commands = [\n      "apply",\n      "plan",\n      "import",\n      "push",\n      "refresh"\n    ]\n\n    required_var_files = [\n      "${get_parent_terragrunt_dir()}/terraform.tfvars"\n    ]\n\n    optional_var_files = [\n      "${get_parent_terragrunt_dir()}/${get_env("TF_VAR_env", "dev")}.tfvars",\n      "${get_parent_terragrunt_dir()}/${get_env("TF_VAR_region", "us-east-1")}.tfvars",\n      "${get_terragrunt_dir()}/${get_env("TF_VAR_env", "dev")}.tfvars",\n      "${get_terragrunt_dir()}/${get_env("TF_VAR_region", "us-east-1")}.tfvars"\n    ]\n  }\n```\n\nSee the [get_terragrunt_dir()](#get_terragrunt_dir) and [get_parent_terragrunt_dir()](#get_parent_terragrunt_dir) documentation\nfor more details.\n\nWith the configuration above, when you run `terragrunt apply-all`, Terragrunt will call Terraform as follows:\n\n```\n$ terragrunt apply-all\n[backend-app]  terraform apply -var-file=/my/tf/terraform.tfvars -var-file=/my/tf/backend-app/dev.tfvars\n[frontend-app] terraform apply -var-file=/my/tf/terraform.tfvars -var-file=/my/tf/frontend-app/us-east-1.tfvars\n\n$ TF_VAR_env=prod terragrunt apply-all\n[backend-app]  terraform apply -var-file=/my/tf/terraform.tfvars -var-file=/my/tf/prod.tfvars\n[frontend-app] terraform apply -var-file=/my/tf/terraform.tfvars -var-file=/my/tf/prod.tfvars -var-file=/my/tf/frontend-app/us-east-1.tfvars\n\n$ TF_VAR_env=prod TF_VAR_region=us-west-2 terragrunt apply-all\n[backend-app]  terraform apply -var-file=/my/tf/terraform.tfvars -var-file=/my/tf/prod.tfvars -var-file=/my/tf/us-west-2.tfvars\n[frontend-app] terraform apply -var-file=/my/tf/terraform.tfvars -var-file=/my/tf/prod.tfvars -var-file=/my/tf/us-west-2.tfvars\n```\n\n#### Handling whitespace\n\nThe list of arguments cannot include whitespaces, so if you need to pass command line arguments that include\nspaces (e.g. `-var bucket=example.bucket.name`), then each of the arguments will need to be a separate item in the\n`arguments` list:\n\n```hcl\nterraform {\n  extra_arguments "bucket" {\n    commands = [\n      "apply",\n      "plan",\n      "import",\n      "push",\n      "refresh"\n    ]\n\n    arguments = [\n      "-var", "bucket=example.bucket.name",\n    ]\n  }\n}\n```\n\nWith the configuration above, when you run `terragrunt apply`, Terragrunt will call Terraform as follows:\n\n```\n$ terragrunt apply\n\nterraform apply -var bucket=example.bucket.name\n```\n\n\n### Execute Terraform commands on multiple modules at once\n\n* [Motivation](#motivation-3)\n* [The apply-all, destroy-all, output-all and plan-all commands](#the-apply-all-destroy-all-output-all-and-plan-all-commands)\n* [Passing outputs between modules](#passing-outputs-between-modules)\n* [Dependencies between modules](#dependencies-between-modules)\n* [Testing multiple modules locally](#testing-multiple-modules-locally)\n\n\n#### Motivation\n\nLet\'s say your infrastructure is defined across multiple Terraform modules:\n\n```\nroot\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 backend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 frontend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 redis\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 main.tf\n```\n\nThere is one module to deploy a frontend-app, another to deploy a backend-app, another for the MySQL database, and so\non. To deploy such an environment, you\'d have to manually run `terraform apply` in each of the subfolder, wait for it\nto complete, and then run `terraform apply` in the next subfolder. How do you avoid this tedious and time-consuming\nprocess?\n\n\n#### The apply-all, destroy-all, output-all and plan-all commands\n\nTo be able to deploy multiple Terraform modules in a single command, add a `terragrunt.hcl` file to each module:\n\n```\nroot\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 backend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 frontend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 redis\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n \xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n \xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nNow you can go into the `root` folder and deploy all the modules within it by using the `apply-all` command:\n\n```\ncd root\nterragrunt apply-all\n```\n\nWhen you run this command, Terragrunt will recursively look through all the subfolders of the current working\ndirectory, find all folders with a `terragrunt.hcl` file, and run `terragrunt apply` in each of those folders\nconcurrently.\n\nSimilarly, to undeploy all the Terraform modules, you can use the `destroy-all` command:\n\n```\ncd root\nterragrunt destroy-all\n```\n\nTo see the currently applied outputs of all of the subfolders, you can use the `output-all` command:\n\n```\ncd root\nterragrunt output-all\n```\n\nFinally, if you make some changes to your project, you could evaluate the impact by using `plan-all` command:\n\nNote: It is important to realize that you could get errors running `plan-all` if you have dependencies between your\nprojects and some of those dependencies haven\'t been applied yet.\n\n_Ex: If module A depends on module B and module B hasn\'t been applied yet, then plan-all will show the plan for B,\nbut exit with an error when trying to show the plan for A._\n\n```\ncd root\nterragrunt plan-all\n```\n\nIf your modules have dependencies between them\xe2\x80\x94for example, you can\'t deploy the backend-app until MySQL and redis are\ndeployed\xe2\x80\x94you\'ll need to express those dependencies in your Terragrunt configuration as explained in the next section.\n\n\n#### Passing outputs between modules\n\nConsider the following file structure:\n\n```\nroot\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 backend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 redis\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n \xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n \xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nSuppose that you wanted to pass in the VPC ID of the VPC that is created from the `vpc` module in the folder structure\nabove to the `mysql` module as an input variable. Or if you wanted to pass in the subnet IDs of the private subnet that\nis allocated as part of the `vpc` module.\n\nYou can use the `dependency` block to extract the output variables to access another module\'s output variables in\nthe terragrunt `inputs` attribute.\n\nFor example, suppose the `vpc` module outputs the ID under the name `vpc_id`. To access that output, you would specify\nin `mysql/terragrunt.hcl`:\n\n```\ndependency "vpc" {\n  config_path = "../vpc"\n}\n\ninputs = {\n  vpc_id = dependency.vpc.outputs.vpc_id\n}\n```\n\nWhen you apply this module, the output will be read from the `vpc` module and passed in as an input to the `mysql`\nmodule right before calling `terraform apply`.\n\nYou can also specify multiple `dependency` blocks to access multiple different module output variables. For\nexample, in the above folder structure, you might want to reference the `domain` output of the `redis` and `mysql`\nmodules for use as `inputs` in the `backend-app` module. To access those outputs, you would specify in\n`backend-app/terragrunt.hcl`:\n\n```\ndependency "mysql" {\n  config_path = "../mysql"\n}\n\ndependency "redis" {\n  config_path = "../redis"\n}\n\ninputs = {\n  mysql_url = dependency.mysql.outputs.domain\n  redis_url = dependency.redis.outputs.domain\n}\n```\n\nNote that each `dependency` is automatically considered a dependency in Terragrunt. This means that when you run\n`apply-all` on a config that has `dependency` blocks, Terragrunt will not attempt to deploy the config until all\nthe modules referenced in `dependency` blocks have been applied. So for the above example, the order for the\n`apply-all` command would be:\n\n1. Deploy the VPC\n1. Deploy MySQL and Redis in parallel\n1. Deploy the backend-app\n\nIf any of the modules failed to deploy, then Terragrunt will not attempt to deploy the modules that depend on them.\n\n**Note**: Not all blocks are able to access outputs passed by `dependency` blocks. See the section on\n[Configuration parsing order](#configuration-parsing-order) in this README for more information.\n\n##### Unapplied dependency and mock outputs\n\nTerragrunt will return an error indicating the dependency hasn\'t been applied yet if the terraform module managed by the\nterragrunt config referenced in a `dependency` block has not been applied yet. This is because you cannot actually fetch\noutputs out of an unapplied Terraform module, even if there are no resources being created in the module.\n\nThis is most problematic when running commands that do not modify state (e.g `plan-all` and `validate-all`) on a\ncompletely new setup where no infrastructure has been deployed. You won\'t be able to `plan` or `validate` a module if\nyou can\'t determine the `inputs`. If the module depends on the outputs of another module that hasn\'t been applied\nyet, you won\'t be able to compute the `inputs` unless the dependencies are all applied. However, in real life usage, you\nwould want to run `validate-all` or `plan-all` on a completely new set of infrastructure.\n\nTo address this, you can provide mock outputs to use when a module hasn\'t been applied yet. This is configured using\nthe `mock_outputs` attribute on the `dependency` block and it corresponds to a map that will be injected in place of\nthe actual dependency outputs if the target config hasn\'t been applied yet.\n\nFor example, in the previous example with a `mysql` module and `vpc` module, suppose you wanted to place in a temporary,\ndummy value for the `vpc_id` during a `validate-all` for the `mysql` module. You can specify in `mysql/terragrunt.hcl`:\n\n```\ndependency "vpc" {\n  config_path = "../vpc"\n\n  mock_outputs = {\n    vpc_id = "temporary-dummy-id"\n  }\n}\n\ninputs = {\n  vpc_id = dependency.vpc.outputs.vpc_id\n}\n```\n\nYou can now run `validate` on this config before the `vpc` module is applied because Terragrunt will use the map\n`{vpc_id = "temporary-dummy-id"}` as the `outputs` attribute on the dependency instead of erroring out.\n\nWhat if you wanted to restrict this behavior to only the `validate` command? For example, you might not want to use\nthe defaults for a `plan` operation because the plan doesn\'t give you any indication of what is actually going to be\ncreated.\n\nYou can use the `mock_outputs_allowed_terraform_commands` attribute to indicate that the `mock_outputs` should\nonly be used when running those Terraform commands. So to restrict the `mock_outputs` to only when `validate` is\nbeing run, you can modify the above `terragrunt.hcl` file to:\n\n```\ndependency "vpc" {\n  config_path = "../vpc"\n\n  mock_outputs = {\n    vpc_id = "temporary-dummy-id"\n  }\n  mock_outputs_allowed_terraform_commands = ["validate"]\n}\n\ninputs = {\n  vpc_id = dependency.vpc.outputs.vpc_id\n}\n```\n\nNote that indicating `validate` means that the `mock_outputs` will be used either with `validate` or with\n`validate-all`.\n\nYou can also use `skip_outputs` on the `dependency` block to specify the dependency without pulling in the outputs:\n\n```\ndependency "vpc" {\n  config_path = "../vpc"\n  skip_outputs = true\n}\n```\n\nWhen `skip_outputs` is used with `mock_outputs`, mocked outputs will be returned without pulling in the outputs from remote states. This can be useful when you disable the backend initialization (`remote_state.disable_init`) in CI for example.\n\n```\ndependency "vpc" {\n  config_path = "../vpc"\n  mock_outputs = {\n    vpc_id = "temporary-dummy-id"\n  }\n\n  skip_outputs = true\n}\n```\n<!--\nThis currently makes no sense to do, but will make more sense when `dependency` blocks start to pull in other\ninformation from the target config.\n-->\n\n\n#### Dependencies between modules\n\nYou can also specify dependencies explicitly. Consider the following file structure:\n\n```\nroot\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 backend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 frontend-app\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 redis\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n \xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 main.tf\n \xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nLet\'s assume you have the following dependencies between Terraform modules:\n\n* `backend-app` depends on `mysql`, `redis`, and `vpc`\n* `frontend-app` depends on `backend-app` and `vpc`\n* `mysql` depends on `vpc`\n* `redis` depends on `vpc`\n* `vpc` has no dependencies\n\nYou can express these dependencies in your `terragrunt.hcl` config files using a `dependencies` block. For example,\nin `backend-app/terragrunt.hcl` you would specify:\n\n```hcl\ndependencies {\n  paths = ["../vpc", "../mysql", "../redis"]\n}\n```\n\nSimilarly, in `frontend-app/terragrunt.hcl`, you would specify:\n\n```hcl\ndependencies {\n  paths = ["../vpc", "../backend-app"]\n}\n```\n\nOnce you\'ve specified the dependencies in each `terragrunt.hcl` file, when you run the `terragrunt apply-all` or\n`terragrunt destroy-all`, Terragrunt will ensure that the dependencies are applied or destroyed, respectively, in the\ncorrect order. For the example at the start of this section, the order for the `apply-all` command would be:\n\n1. Deploy the VPC\n1. Deploy MySQL and Redis in parallel\n1. Deploy the backend-app\n1. Deploy the frontend-app\n\nIf any of the modules fail to deploy, then Terragrunt will not attempt to deploy the modules that depend on them. Once\nyou\'ve fixed the error, it\'s usually safe to re-run the `apply-all` or `destroy-all` command again, since it\'ll be a\nno-op for the modules that already deployed successfully, and should only affect the ones that had an error the last\ntime around.\n\nTo check all of your dependencies and validate the code in them, you can use the `validate-all` command.\n\n\n#### Testing multiple modules locally\n\nIf you are using Terragrunt to configure [remote Terraform configurations](#remote-terraform-configurations) and all\nof your modules have the `source` parameter set to a Git URL, but you want to test with a local checkout of the code,\nyou can use the `--terragrunt-source` parameter:\n\n\n```\ncd root\nterragrunt plan-all --terragrunt-source /source/modules\n```\n\nIf you set the `--terragrunt-source` parameter, the `xxx-all` commands will assume that parameter is pointing to a\nfolder on your local file system that has a local checkout of all of your Terraform modules. For each module that is\nbeing processed via a `xxx-all` command, Terragrunt will read in the `source` parameter in that module\'s `terragrunt.hcl`\nfile, parse out the path (the portion after the double-slash), and append the path to the `--terragrunt-source`\nparameter to create the final local path for that module.\n\nFor example, consider the following `terragrunt.hcl` file:\n\n```hcl\nterraform {\n  source = "git::git@github.com:acme/infrastructure-modules.git//networking/vpc?ref=v0.0.1"\n}\n```\n\nIf you run `terragrunt apply-all --terragrunt-source /source/infrastructure-modules`, then the local path Terragrunt\nwill compute for the module above will be `/source/infrastructure-modules//networking/vpc`.\n\n\n\n\n### Work with multiple AWS accounts\n\n#### Motivation\n\nThe most secure way to manage infrastructure in AWS is to use [multiple AWS\naccounts](https://aws.amazon.com/answers/account-management/aws-multi-account-security-strategy/). You define all your\nIAM users in one account (e.g., the "security" account) and deploy all of your infrastructure into a number of other\naccounts (e.g., the "dev", "stage", and "prod" accounts). To access those accounts, you login to the security account\nand [assume an IAM role](http://docs.aws.amazon.com/cli/latest/userguide/cli-roles.html) in the other accounts.\n\nThere are a few ways to assume IAM roles when using AWS CLI tools, such as Terraform:\n\n1. One option is to create a named [profile](http://docs.aws.amazon.com/cli/latest/userguide/cli-multiple-profiles.html),\n   each with a different [role_arn](http://docs.aws.amazon.com/cli/latest/userguide/cli-roles.html) parameter. You then\n   tell Terraform which profile to use via the `AWS_PROFILE` environment variable. The downside to using profiles is\n   that you have to store your AWS credentials in plaintext on your hard drive.\n\n1. Another option is to use environment variables and the [AWS CLI](https://aws.amazon.com/cli/). You first set the\n   credentials for the security account (the one where your IAM users are defined) as the environment variables\n   `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` and run `aws sts assume-role --role-arn <ROLE>`. This gives you\n   back a blob of JSON that contains new `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` values you can set as\n   environment variables to allow Terraform to use that role. The advantage of this approach is that you can store your\n   AWS credentials in a secret store and never write them to disk in plaintext. The disadvantage is that assuming an\n   IAM role requires several tedious steps. Worse yet, the credentials you get back from the `assume-role` command are\n   only good for up to 1 hour, so you have to repeat this process often.\n\n1. A final option is to modify your AWS provider with the [assume_role\n   configuration](https://www.terraform.io/docs/providers/aws/#assume-role) and your S3 backend with the [role_arn\n   parameter](https://www.terraform.io/docs/backends/types/s3.html#role_arn). You can then set the credentials for the\n   security account (the one where your IAM users are defined) as the environment variables `AWS_ACCESS_KEY_ID` and\n   `AWS_SECRET_ACCESS_KEY` and when you run `terraform apply` or `terragrunt apply`, Terraform/Terragrunt will assume\n   the IAM role you specify automatically. The advantage of this approach is that you can store your\n   AWS credentials in a secret store and never write them to disk in plaintext, and you get fresh credentials on every\n   run of `apply`, without the complexity of calling `assume-role`. The disadvantage is that you have to modify all\n   your Terraform / Terragrunt code to set the `role_arn` param and your Terraform backend configuration will change\n   (and prompt you to manually confirm the update!) every time you change the IAM role you\'re using.\n\nTo avoid these frustrating trade-offs, you can configure Terragrunt to assume an IAM role for you, as described next.\n\n\n#### Configuring Terragrunt to assume an IAM role\n\nTo tell Terragrunt to assume an IAM role, just set the `--terragrunt-iam-role` command line argument:\n\n```bash\nterragrunt apply --terragrunt-iam-role "arn:aws:iam::ACCOUNT_ID:role/ROLE_NAME"\n```\n\nAlternatively, you can set the `TERRAGRUNT_IAM_ROLE` environment variable:\n\n```bash\nexport TERRAGRUNT_IAM_ROLE="arn:aws:iam::ACCOUNT_ID:role/ROLE_NAME"\nterragrunt apply\n```\n\nAdditionally, you can specify an `iam_role` property in the terragrunt config:\n\n```hcl\niam_role = "arn:aws:iam::ACCOUNT_ID:role/ROLE_NAME"\n```\n\nTerragrunt will resolve the value of the option by first looking for the cli argument, then looking for the environment\nvariable, then defaulting to the value specified in the config file.\n\nTerragrunt will call the `sts assume-role` API on your behalf and expose the credentials it gets back as environment\nvariables when running Terraform. The advantage of this approach is that you can store your AWS credentials in a secret\nstore and never write them to disk in plaintext, you get fresh credentials on every run of Terragrunt, without the\ncomplexity of calling `assume-role` yourself, and you don\'t have to modify your Terraform code or backend configuration\nat all.\n\n\n\n\n## Terragrunt details\n\nThis section contains detailed documentation for the following aspects of Terragrunt:\n\n1. [Inputs](#inputs)\n1. [Locals](#locals)\n1. [AWS credentials](#aws-credentials)\n1. [AWS IAM policies](#aws-iam-policies)\n1. [Built-in Functions](#built-in-functions)\n1. [Before & After Hooks](#before-and-after-hooks)\n1. [Auto-Init](#auto-init)\n1. [CLI options](#cli-options)\n1. [Configuration](#configuration)\n1. [Configuration parsing order](#configuration-parsing-order)\n1. [Formatting terragrunt.hcl](#formatting-terragrunthcl)\n1. [Migrating from Terragrunt v0.11.x and Terraform 0.8.x and older](#migrating-from-terragrunt-v011x-and-terraform-08x-and-older)\n1. [Clearing the Terragrunt cache](#clearing-the-terragrunt-cache)\n1. [Contributing](#contributing)\n1. [Developing Terragrunt](#developing-terragrunt)\n1. [License](#license)\n\n\n### Inputs\n\nYou can set values for your module\'s input parameters by specifying an `inputs` block in `terragrunt.hcl`:\n\n```hcl\ninputs = {\n  instance_type  = "t2.micro"\n  instance_count = 10\n\n  tags = {\n    Name = "example-app"\n  }\n}\n```\n\nWhenever you run a Terragrunt command, Terragrunt will set any inputs you pass in as environment variables. For example,\nwith the `terragrunt.hcl` file above, running `terragrunt apply` is roughly equivalent to:\n\n```\n$ terragrunt apply\n\n# Roughly equivalent to:\n\nTF_VAR_instance_type="t2.micro" \\\nTF_VAR_instance_count=10 \\\nTF_VAR_tags=\'{"Name":"example-app"}\' \\\nterraform apply\n```\n\nNote that Terragrunt will respect any `TF_VAR_xxx` variables you\'ve manually set in your environment, ensuring that\nanything in `inputs` will NOT be override anything you\'ve already set in your environment.\n\n#### Variable precedence\n\nTerragrunt follows the same variable precedence as [terraform](https://www.terraform.io/docs/configuration/variables.html#variable-definition-precedence).\n\nIf the same variable is assigned multiple values, Terraform will use the **last** value it finds overriding any previous values.\n\nVariables are loaded in the following order:\n\n- Environment variables.\n- `terraform.tfvars` file, if present.\n- `terraform.tfvars.json` file, if present.\n- Any `*.auto.tfvars`/`*.auto.tfvars.json` files, processed in order of their filenames.\n- Any `-var`/`-var-file` options on the command line, in the order they are provided.\n\n\n### Locals\n\nYou can use locals to bind a name to an expression, so you can reuse that expression without having to repeat it multiple times (keeping your Terragrunt configuration DRY).\nconfig. For example, suppose that you need to use the AWS region in multiple inputs. You can bind the name `aws_region`\nusing locals:\n\n```\nlocals {\n  aws_region = "us-east-1"\n}\n\ninputs = {\n  aws_region  = local.aws_region\n  s3_endpoint = "com.amazonaws.${local.aws_region}.s3"\n}\n```\n\nYou can use any valid terragrunt expression in the `locals` configuration. The `locals` block also supports referencing other `locals`:\n\n```\nlocals {\n  x = 2\n  y = 40\n  answer = local.x + local.y\n}\n```\n\n##### Including globally defined locals\n\nCurrently you can only reference `locals` defined in the same config file. `terragrunt` does not automatically include\n`locals` defined in the parent config of an `include` block into the current context. If you wish to reuse variables\nglobally, consider using `yaml` or `json` files that are included and merged using the `terraform` built in functions\navailable to `terragrunt`.\n\nFor example, suppose you had the following directory tree:\n\n```\n.\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nInstead of adding the `locals` block to the parent `terragrunt.hcl` file, you can define a file `common_vars.yaml`\nthat contains the global variables you wish to pull in:\n\n```\n.\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 common_vars.yaml\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 vpc\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nYou can then include them into the `locals` block of the child terragrunt config using `yamldecode` and `file`:\n\n```\n# child terragrunt.hcl\nlocals {\n  common_vars = yamldecode(file("${get_terragrunt_dir()}/${find_in_parent_folders("common_vars.yaml")}")),\n  region = "us-east-1"\n}\n```\n\nThis configuration will load in the `common_vars.yaml` file and bind it to the attribute `common_vars` so that it is available\nin the current context. Note that because `locals` is a block, there currently is a way to merge the map into the top\nlevel.\n\n\n### AWS credentials\n\nTerragrunt uses the official [AWS SDK for Go](https://aws.amazon.com/sdk-for-go/), which\nmeans that it will automatically load credentials using the\n[AWS standard approach](https://aws.amazon.com/blogs/security/a-new-and-standardized-way-to-manage-credentials-in-the-aws-sdks/).\nIf you need help configuring your credentials, please refer to the [Terraform\ndocs](https://www.terraform.io/docs/providers/aws/#authentication).\n\n\n### AWS IAM policies\n\nYour AWS user must have an [IAM policy](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-identity-based.html)\nwhich grants permissions for interacting with DynamoDB and S3. Terragrunt will automatically create\nthe configured DynamoDB tables and S3 buckets for storing remote state if they do not already exist.\n\nThe following is an example IAM policy for use with Terragrunt. The policy grants the following permissions:\n\n* all DynamoDB permissions in all regions for tables used by Terragrunt\n* all S3 permissions for buckets used by Terragrunt\n\nBefore using this policy, make sure to replace `1234567890` with your AWS account id and `terragrunt*` with\nyour organization\'s naming convention for AWS resources for Terraform remote state.\n\n```json\n{\n    "Version": "2012-10-17",\n    "Statement": [\n        {\n            "Sid": "AllowAllDynamoDBActionsOnAllTerragruntTables",\n            "Effect": "Allow",\n            "Action": "dynamodb:*",\n            "Resource": [\n                "arn:aws:dynamodb:*:1234567890:table/terragrunt*"\n            ]\n        },\n        {\n            "Sid": "AllowAllS3ActionsOnTerragruntBuckets",\n            "Effect": "Allow",\n            "Action": "s3:*",\n            "Resource": [\n                "arn:aws:s3:::terragrunt*",\n                "arn:aws:s3:::terragrunt*/*"\n            ]\n        }\n    ]\n}\n```\n\nFor a more minimal policy, for example when using a single bucket and DynamoDB table for multiple Terragrunt\nusers, you can use the following. Be sure to replace `BUCKET_NAME` and `TABLE_NAME` with the S3 bucket name\nand DynamoDB table name respectively.\n\n```json\n{\n    "Version": "2012-10-17",\n    "Statement": [\n        {\n            "Sid": "AllowCreateAndListS3ActionsOnSpecifiedTerragruntBucket",\n            "Effect": "Allow",\n            "Action": [\n                "s3:ListBucket",\n                "s3:GetBucketVersioning",\n                "s3:CreateBucket"\n            ],\n            "Resource": "arn:aws:s3:::BUCKET_NAME"\n        },\n        {\n            "Sid": "AllowGetAndPutS3ActionsOnSpecifiedTerragruntBucketPath",\n            "Effect": "Allow",\n            "Action": [\n                "s3:PutObject",\n                "s3:GetObject"\n            ],\n            "Resource": "arn:aws:s3:::BUCKET_NAME/some/path/here"\n        },\n        {\n            "Sid": "AllowCreateAndUpdateDynamoDBActionsOnSpecifiedTerragruntTable",\n            "Effect": "Allow",\n            "Action": [\n                "dynamodb:PutItem",\n                "dynamodb:GetItem",\n                "dynamodb:DescribeTable",\n                "dynamodb:DeleteItem",\n                "dynamodb:CreateTable"\n            ],\n            "Resource": "arn:aws:dynamodb:*:*:table/TABLE_NAME"\n        }\n    ]\n}\n```\n\nWhen the above is applied to an IAM user it will restrict them to creating the DynamoDB table if it doesn\'t\nalready exist and allow updating records for state locking, and for the S3 bucket will allow creating the\nbucket if it doesn\'t already exist and only write files to the specified path.\n\nIf you are only given access to an externally created Bucket you will need at least this IAM policy to be granted to your account:\n```\n{\n    "Version": "2012-10-17",\n    "Statement": [\n        {\n            "Action": [\n                "s3:GetBucketLocation",\n                "s3:List*"\n            ],\n            "Resource": [\n                "arn:aws:s3:::<BucketName>"\n            ],\n            "Effect": "Allow"\n        },\n        {\n            "Action": [\n                "s3:DeleteObject",\n                "s3:GetObject",\n                "s3:PutObject",\n                "s3:ListBucket"\n            ],\n            "Resource": [\n                "arn:aws:s3:::<BucketName>/*"\n            ],\n            "Effect": "Allow"\n        }\n    ]\n}\n```\n\nand you will need to set the flag `skip_bucket_versioning` to true (only bucket owners can check versioning status on an S3 Bucket)\n\n\n### Built-in Functions\n\nTerragrunt allows you to use built-in functions anywhere in `terragrunt.hcl`, just like Terraform! The functions\ncurrently available are:\n\n* [All Terraform built-in functions](#terraform-built-in-functions)\n* [find_in_parent_folders()](#find_in_parent_folders)\n* [path_relative_to_include()](#path_relative_to_include)\n* [path_relative_from_include()](#path_relative_from_include)\n* [get_env(NAME, DEFAULT)](#get_env)\n* [get_terragrunt_dir()](#get_terragrunt_dir)\n* [get_parent_terragrunt_dir()](#get_parent_terragrunt_dir)\n* [get_terraform_commands_that_need_vars()](#get_terraform_commands_that_need_vars)\n* [get_terraform_commands_that_need_input()](#get_terraform_commands_that_need_input)\n* [get_terraform_commands_that_need_locking()](#get_terraform_commands_that_need_locking)\n* [get_terraform_commands_that_need_parallelism()](#get_terraform_commands_that_need_parallelism)\n* [get_aws_account_id()](#get_aws_account_id)\n* [get_aws_caller_identity_arn()](#get_aws_caller_identity_arn)\n* [get_aws_caller_identity_user_id()](#get_aws_caller_identity_user_id)\n* [run_cmd()](#run_cmd)\n\n\n#### Terraform built-in functions\n\nAll [Terraform built-in functions](https://www.terraform.io/docs/configuration/functions.html) are supported in\nTerragrunt config files:\n\n```hcl\nterraform {\n  source = "../modules/${basename(get_terragrunt_dir())}"\n}\n\nremote_state {\n  backend = "s3"\n  config = {\n    bucket = trimspace("   my-terraform-bucket     ")\n    region = join("-", ["us", "east", "1"])\n    key    = format("%s/terraform.tfstate", path_relative_to_include())\n  }\n}\n```\n\nNote: Any `file*` functions (`file`, `fileexists`, `filebase64`, etc) are relative to the directory containing the\n`terragrunt.hcl` file they\'re used in.\n\nGiven the following structure:\n```\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt\n  \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 common.tfvars\n  \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 assets\n  |\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 mysql\n  |\xc2\xa0    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 assets.txt\n  \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nThen `assets.txt` could be read with the following function call:\n```hcl\nfile("assets/mysql/assets.txt")\n```\n\n\n#### find_in_parent_folders\n\n`find_in_parent_folders()` searches up the directory tree from the current `terragrunt.hcl` file and returns the\nrelative path to the first `terragrunt.hcl` in a parent folder or exit with an error if no such file is found. This is\nprimarily useful in an `include` block to automatically find the path to a parent `terragrunt.hcl` file:\n\n```hcl\ninclude {\n  path = find_in_parent_folders()\n}\n```\n\nThe function takes an optional `name` parameter that allows you to specify a different filename to search for:\n\n```hcl\ninclude {\n  path = find_in_parent_folders("some-other-file-name.hcl")\n}\n```\n\nYou can also pass an optional second `fallback` parameter which causes the function to return the fallback value\n(instead of exiting with an error) if the file in the `name` parameter cannot be found:\n\n```hcl\ninclude {\n  path = find_in_parent_folders("some-other-file-name.tfvars", "fallback.tfvars")\n}\n```\n\n\n#### path_relative_to_include\n\n`path_relative_to_include()` returns the relative path between the current `terragrunt.hcl` file and the `path`\nspecified in its `include` block. For example, consider the following folder structure:\n\n```\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 prod\n \xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 mysql\n \xc2\xa0\xc2\xa0     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 stage\n \xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 mysql\n \xc2\xa0\xc2\xa0     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nImagine `prod/mysql/terragrunt.hcl` and `stage/mysql/terragrunt.hcl` include all settings from the root\n`terragrunt.hcl` file:\n\n```hcl\ninclude {\n  path = find_in_parent_folders()\n}\n```\n\nThe root `terragrunt.hcl` can use the `path_relative_to_include()` in its `remote_state` configuration to ensure\neach child stores its remote state at a different `key`:\n\n```hcl\nremote_state {\n  backend = "s3"\n  config = {\n    bucket = "my-terraform-bucket"\n    region = "us-east-1"\n    key    = "${path_relative_to_include()}/terraform.tfstate"\n  }\n}\n```\n\nThe resulting `key` will be `prod/mysql/terraform.tfstate` for the prod `mysql` module and\n`stage/mysql/terraform.tfstate` for the stage `mysql` module.\n\n\n#### path_relative_from_include\n\n`path_relative_from_include()` returns the relative path between the `path` specified in its `include` block and the\ncurrent `terragrunt.hcl` file (it is the counterpart of `path_relative_to_include()`). For example, consider the\nfollowing folder structure:\n\n```\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 sources\n|  \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n|  |\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 *.tf\n|  \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 secrets\n|     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 mysql\n|  \xc2\xa0\xc2\xa0     \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 *.tf\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt\n  \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 common.tfvars\n  \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 mysql\n  |\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n  \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 secrets\n  |\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 mysql\n  |\xc2\xa0    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n  \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nImagine `terragrunt/mysql/terragrunt.hcl` and `terragrunt/secrets/mysql/terragrunt.hcl` include all settings from the\nroot `terragrunt.hcl` file:\n\n```hcl\ninclude {\n  path = find_in_parent_folders()\n}\n```\n\nThe root `terragrunt.hcl` can use the `path_relative_from_include()` in combination with `path_relative_to_include()`\nin its `source` configuration to retrieve the relative terraform source code from the terragrunt configuration file:\n\n```hcl\nterraform {\n  source = "${path_relative_from_include()}/../sources//${path_relative_to_include()}"\n}\n```\n\nThe resulting `source` will be `../../sources//mysql` for `mysql` module and `../../../sources//secrets/mysql` for\n`secrets/mysql` module.\n\nAnother use case would be to add extra argument to include the `common.tfvars` file for all subdirectories:\n\n```hcl\n  terraform {\n    extra_arguments "common_var" {\n      commands = [\n        "apply",\n        "plan",\n        "import",\n        "push",\n        "refresh"\n      ]\n\n      arguments = [\n        "-var-file=${get_terragrunt_dir()}/${path_relative_from_include()}/common.tfvars",\n      ]\n    }\n  }\n```\n\nThis allows proper retrieval of the `common.tfvars` from whatever the level of subdirectories we have.\n\n\n#### get_env\n\n`get_env(NAME, DEFAULT)` returns the value of the environment variable named `NAME` or `DEFAULT` if that environment\nvariable is not set. Example:\n\n```hcl\nremote_state {\n  backend = "s3"\n  config = {\n    bucket = get_env("BUCKET", "my-terraform-bucket")\n  }\n}\n```\n\nNote that [Terraform will read environment\nvariables](https://www.terraform.io/docs/configuration/environment-variables.html#tf_var_name) that start with the\nprefix `TF_VAR_`, so one way to share a variable named `foo` between Terraform and Terragrunt is to set its value\nas the environment variable `TF_VAR_foo` and to read that value in using this `get_env()` built-in function.\n\n#### get_terragrunt_dir\n\n`get_terragrunt_dir()` returns the directory where the Terragrunt configuration file (by default `terragrunt.hcl`) lives.\nThis is useful when you need to use relative paths with [remote Terraform\nconfigurations](#remote-terraform-configurations) and you want those paths relative to your Terragrunt configuration\nfile and not relative to the temporary directory where Terragrunt downloads the code.\n\nFor example, imagine you have the following file structure:\n\n```\n/terraform-code\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 common.tfvars\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 frontend-app\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nInside of `/terraform-code/frontend-app/terragrunt.hcl` you might try to write code that looks like this:\n\n```hcl\nterraform {\n  source = "git::git@github.com:foo/modules.git//frontend-app?ref=v0.0.3"\n\n  extra_arguments "custom_vars" {\n    commands = [\n      "apply",\n      "plan",\n      "import",\n      "push",\n      "refresh"\n    ]\n\n    arguments = [\n      "-var-file=../common.tfvars" # Note: This relative path will NOT work correctly!\n    ]\n  }\n}\n```\n\nNote how the `source` parameter is set, so Terragrunt will download the `frontend-app` code from the `modules` repo\ninto a temporary folder and run `terraform` in that temporary folder. Note also that there is an `extra_arguments`\nblock that is trying to allow the `frontend-app` to read some shared variables from a `common.tfvars` file.\nUnfortunately, the relative path (`../common.tfvars`) won\'t work, as it will be relative to the temporary folder!\nMoreover, you can\'t use an absolute path, or the code won\'t work on any of your teammates\' computers.\n\nTo make the relative path work, you need to use `get_terragrunt_dir()` to combine the path with the folder where\nthe `terragrunt.hcl` file lives:\n\n```hcl\nterraform {\n  source = "git::git@github.com:foo/modules.git//frontend-app?ref=v0.0.3"\n\n  extra_arguments "custom_vars" {\n    commands = [\n      "apply",\n      "plan",\n      "import",\n      "push",\n      "refresh"\n    ]\n\n    # With the get_terragrunt_dir() function, you can use relative paths!\n    arguments = [\n      "-var-file=${get_terragrunt_dir()}/../common.tfvars"\n    ]\n  }\n}\n```\n\nFor the example above, this path will resolve to `/terraform-code/frontend-app/../common.tfvars`, which is exactly\nwhat you want.\n\n\n#### get_parent_terragrunt_dir\n\n`get_parent_terragrunt_dir()` returns the absolute directory where the Terragrunt parent configuration file (by default\n`terragrunt.hcl`) lives. This is useful when you need to use relative paths with [remote Terraform\nconfigurations](#remote-terraform-configurations) and you want those paths relative to your parent Terragrunt\nconfiguration file and not relative to the temporary directory where Terragrunt downloads the code.\n\nThis function is very similar to [get_terragrunt_dir()](#get_terragrunt_dir) except it returns the root instead of the\nleaf of your terragrunt configuration folder.\n\n```\n/terraform-code\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 common.tfvars\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app1\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 tests\n\xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 app2\n\xe2\x94\x82   |   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 app3\n\xe2\x94\x82       \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\n```hcl\nterraform {\n  extra_arguments "common_vars" {\n    commands = [\n      "apply",\n      "plan",\n      "import",\n      "push",\n      "refresh"\n    ]\n\n    arguments = [\n      "-var-file=${get_parent_terragrunt_dir()}/common.tfvars"\n    ]\n  }\n}\n```\n\nThe common.tfvars located in the terraform root folder will be included by all applications, whatever their relative location to the root.\n\n#### get_terraform_commands_that_need_vars\n\n`get_terraform_commands_that_need_vars()` returns the list of terraform commands that accept `-var` and `-var-file`\nparameters. This function is used when defining [extra_arguments](#keep-your-cli-flags-dry).\n\n```hcl\nterraform {\n  extra_arguments "common_var" {\n    commands  = get_terraform_commands_that_need_vars()\n    arguments = ["-var-file=${get_aws_account_id()}.tfvars"]\n  }\n}\n```\n\n#### get_terraform_commands_that_need_input\n\n`get_terraform_commands_that_need_input()` returns the list of terraform commands that accept the `-input=(true or false)`\nparameter. This function is used when defining [extra_arguments](#keep-your-cli-flags-dry).\n\n```hcl\nterraform {\n  # Force Terraform to not ask for input value if some variables are undefined.\n  extra_arguments "disable_input" {\n    commands  = get_terraform_commands_that_need_input()\n    arguments = ["-input=false"]\n  }\n}\n```\n\n#### get_terraform_commands_that_need_locking\n\n`get_terraform_commands_that_need_locking()` returns the list of terraform commands that accept the `-lock-timeout`\nparameter. This function is used when defining [extra_arguments](#keep-your-cli-flags-dry).\n\n```hcl\nterraform {\n  # Force Terraform to keep trying to acquire a lock for up to 20 minutes if someone else already has the lock\n  extra_arguments "retry_lock" {\n    commands  = get_terraform_commands_that_need_locking()\n    arguments = ["-lock-timeout=20m"]\n  }\n}\n```\n\n#### get_terraform_commands_that_need_parallelism\n\n`get_terraform_commands_that_need_parallelism()` returns the list of terraform commands that accept the `-parallelism`\nparameter. This function is used when defining [extra_arguments](#keep-your-cli-flags-dry).\n\n```hcl\nterraform {\n  # Force Terraform to run with reduced parallelism\n  extra_arguments "parallelism" {\n    commands  = get_terraform_commands_that_need_parallelism()\n    arguments = ["-parallelism=5"]\n  }\n}\n```\n\n#### get_aws_account_id\n\n`get_aws_account_id()` returns the AWS account id associated with the current set of credentials. Example:\n\n```hcl\nremote_state {\n  backend = "s3"\n  config = {\n    bucket = "mycompany-${get_aws_account_id()}"\n  }\n}\n```\n\n#### get_aws_caller_identity_arn\n\n`get_aws_caller_identity_arn()` returns the ARN of the AWS identity associated with the current set of credentials. Example:\n\n```hcl\ninputs = {\n  caller_arn = get_aws_caller_identity_arn()\n}\n```\n\n#### get_aws_caller_identity_user_id\n\n`get_aws_caller_identity_user_id()` returns the UserId of the AWS identity associated with the current set of credentials. Example:\n\n```hcl\ninputs = {\n  caller_user_id = get_aws_caller_identity_user_id()\n}\n```\n\nThis allows uniqueness of the storage bucket per AWS account (since bucket name must be globally unique).\n\nIt is also possible to configure variables specifically based on the account used:\n\n```hcl\nterraform {\n  extra_arguments "common_var" {\n    commands = get_terraform_commands_that_need_vars()\n    arguments = ["-var-file=${get_aws_account_id()}.tfvars"]\n  }\n}\n```\n\n#### run_cmd\n\n`run_cmd(command, arg1, arg2...)` runs a shell command and returns the stdout as the result of the interpolation. The\ncommand is executed at the same folder as the `terragrunt.hcl` file. This is useful whenever you want to dynamically\nfill in arbitrary information in your Terragrunt configuration.\n\nAs an example, you could write a script that determines the bucket and DynamoDB table name based on the AWS account,\ninstead of hardcoding the name of every account:\n\n```hcl\nremote_state {\n  backend = "s3"\n  config = {\n    bucket         = run_cmd("./get_names.sh", "bucket")\n    dynamodb_table = run_cmd("./get_names.sh", "dynamodb")\n  }\n}\n```\n\nIf the command you are running has the potential to output sensitive values, you may wish to redact the output from\nappearing in the terminal. To do so, use the special `--terragrunt-quiet` argument which must be passed as the first\nargument to `run_cmd()`:\n```hcl\nsuper_secret_value = run_cmd("--terragrunt-quiet", "./decrypt_secret.sh", "foo")\n```\n\n**Note:** This will prevent terragrunt from displaying the output from the command in its output.\nHowever, the value could still be displayed in the Terraform output if Terraform does not treat it as a\n[sensitive value](https://www.terraform.io/docs/configuration/outputs.html#sensitive-suppressing-values-in-cli-output).\n\n### Before and After Hooks\n\n_Before Hooks_ or _After Hooks_ are a feature of terragrunt that make it possible to define custom actions\nthat will be called either before or after execution of the `terraform` command.\n\nHere\'s an example:\n\n```hcl\nterraform {\n  before_hook "before_hook_1" {\n    commands     = ["apply", "plan"]\n    execute      = ["echo", "Foo"]\n    run_on_error = true\n  }\n\n  before_hook "before_hook_2" {\n    commands     = ["apply"]\n    execute      = ["echo", "Bar"]\n    run_on_error = false\n  }\n\n  before_hook "interpolation_hook_1" {\n    commands     = ["apply", "plan"]\n    execute      = ["echo", get_env("HOME", "HelloWorld")]\n    run_on_error = false\n  }\n\n  after_hook "after_hook_1" {\n    commands     = ["apply", "plan"]\n    execute      = ["echo", "Baz"]\n    run_on_error = true\n  }\n\n  after_hook "init_from_module" {\n    commands = ["init-from-module"]\n    execute  = ["cp", "${get_parent_terragrunt_dir()}/foo.tf", "."]\n  }\n}\n```\n\nHooks support the following arguments:\n\n* `commands` (required): the `terraform` commands that will trigger the execution of the hook.\n* `execute` (required): the shell command to execute.\n* `run_on_error` (optional): if set to true, this hook will run even if a previous hook hit an error, or in the case of\n  "after" hooks, if the Terraform command hit an error. Default is false.\n* `init_from_module` and `init`: This is not an argument, but a special name you can use for hooks that run during\n  initialization. There are two stages of initialization: one is to download\n  [remote configurations](#keep-your-terraform-code-dry) using `go-getter`; the other is [Auto-Init](#auto-init), which\n  configures the backend and downloads provider plugins and modules. If you wish to execute a hook when Terragrunt is\n  using `go-getter` to download remote configurations, name the hook `init_from_module`. If you wish to execute a hook\n  when Terragrunt is using `terraform init` for Auto-Init, name the hook `init`.\n\n\n\n\n### Auto-Init\n\n_Auto-Init_ is a feature of Terragrunt that makes it so that `terragrunt init` does not need to be called explicitly\nbefore other terragrunt commands.\n\nWhen Auto-Init is enabled (the default), terragrunt will automatically call\n[`terraform init`](https://www.terraform.io/docs/commands/init.html) during other commands (e.g. `terragrunt plan`)\n when terragrunt detects that:\n\n* `terraform init` has never been called, or\n* `source` needs to be downloaded, or\n* the modules or remote state used by the module have changed since the previous call to `terraform init`.\n\nAs mentioned [above](#extra_arguments-for-init), `extra_arguments` can be configured to allow customization of the\n`terraform init` command.\n\nNote that there might be cases where terragrunt does not properly detect that `terraform init` needs be called.\nIn this case, terraform would fail. Running `terragrunt init` again corrects this situation.\n\nFor some use cases, it might be desirable to disable Auto-Init. For example, if each user wants to specify a different\n`-plugin-dir` option to `terraform init` (and therefore it cannot be put in `extra_arguments`). To disable Auto-Init,\nuse the `--terragrunt-no-auto-init` command line option or set the `TERRAGRUNT_AUTO_INIT` environment variable to\n`false`.\n\nDisabling Auto-Init means that you _must_ explicitly call `terragrunt init` prior to any other terragrunt commands for\na particular configuration. If Auto-Init is disabled, and terragrunt detects that `terraform init` needs to be called,\nthen terragrunt will fail.\n\n### Auto-Retry\n\n_Auto-Retry_ is a feature of `terragrunt` that will automatically address situations where a `terraform` command needs\nto be re-run.\n\nTerraform can fail with transient errors which can be addressed by simply retrying the command again. In the event\n`terragrunt` finds one of these errors, the command will be re-run again automatically.\n\n**Example**\n\n```\n$ terragrunt apply\n...\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\nError installing provider "template": error fetching checksums: Get https://releases.hashicorp.com/terraform-provider-template/1.0.0/terraform-provider-template_1.0.0_SHA256SUMS: net/http: TLS handshake timeout.\n```\n\nTerragrunt sees this error, and knows it is a transient error that can addressed by re-running the `apply` command.\n\n`auto-retry` will try a maximum of three times to re-run the command, at which point it will deem the error as not\ntransient, and accept the terraform failure. Retries will occur when the error is encountered, pausing for 5 seconds\nbetween retries.\n\nKnown errors that `auto-retry` will rerun, are maintained in the `TerragruntOptions.RetryableErrors` array. Future\nupgrades to `terragrunt` may include the ability to configure `auto-retry` by specifying additional error strings and\nconfiguring max retries and retry intervals the `terragrunt` config (PRs welcome!).\n\nTo disable `auto-retry`, use the `--terragrunt-no-auto-retry` command line option or set the `TERRAGRUNT_AUTO_RETRY`\nenvironment variable to `false`.\n\n\n### CLI Options\n\nTerragrunt forwards all arguments and options to Terraform. The only exceptions are `--version`, `terragrunt-info` and\narguments that start with the prefix `--terragrunt-`. The currently available options are:\n\n* `--terragrunt-config`: A custom path to the `terragrunt.hcl` file. May also be specified via the `TERRAGRUNT_CONFIG`\n  environment variable. The default path is `terragrunt.hcl` in the current directory (see\n  [Configuration](#configuration) for a slightly more nuanced explanation). This argument is not\n  used with the `apply-all`, `destroy-all`, `output-all`, `validate-all`, and `plan-all` commands.\n\n* `--terragrunt-tfpath`: A custom path to the Terraform binary. May also be specified via the `TERRAGRUNT_TFPATH`\n  environment variable. The default is `terraform` in a directory on your PATH.\n\n* `--terragrunt-no-auto-init`: Don\'t automatically run `terraform init` when other commands are run (e.g. `terragrunt\n  apply`). Useful if you want to pass custom arguments to `terraform init` that are specific to a user or execution\n  environment, and therefore cannot be specified as `extra_arguments`. For example, `-plugin-dir`. You must run\n  `terragrunt init` yourself in this case if needed. `terragrunt` will fail if it detects that `init` is needed, but\n  auto init is disabled. See [Auto-Init](#auto-init)\n\n* `--terragrunt-no-auto-retry`: Don\'t automatically retry commands which fail with transient errors.\n  See [Auto-Retry](#auto-retry)\n\n* `--terragrunt-non-interactive`: Don\'t show interactive user prompts. This will default the answer for all prompts to\n  \'yes\'. Useful if you need to run Terragrunt in an automated setting (e.g. from a script). May also be specified with\n  the [TF_INPUT](https://www.terraform.io/docs/configuration/environment-variables.html#tf_input) environment variable.\n\n* `--terragrunt-working-dir`: Set the directory where Terragrunt should execute the `terraform` command. Default is the\n  current working directory. Note that for the `apply-all`, `destroy-all`, `output-all`, `validate-all`, and `plan-all`\n  commands, this parameter has a different meaning: Terragrunt will apply or destroy all the Terraform modules in the\n  subfolders of the `terragrunt-working-dir`, running `terraform` in the root of each module it finds.\n\n* `--terragrunt-download-dir`: The path where to download Terraform code when using [remote Terraform\n  configurations](#keep-your-terraform-code-dry). May also be specified via the `TERRAGRUNT_DOWNLOAD` environment\n  variable. Default is `.terragrunt-cache` in the working directory. We recommend adding this folder to your `.gitignore`.\n\n* `--terragrunt-source`: Download Terraform configurations from the specified source into a temporary folder, and run\n  Terraform in that temporary folder. May also be specified via the `TERRAGRUNT_SOURCE` environment variable. The\n  source should use the same syntax as the [Terraform module source](https://www.terraform.io/docs/modules/sources.html)\n  parameter. If you specify this argument for the `apply-all`, `destroy-all`, `output-all`, `validate-all`, or `plan-all`\n  commands, Terragrunt will assume this is the local file path for all of your Terraform modules, and for each module\n  processed by the `xxx-all` command, Terragrunt will automatically append the path of `source` parameter in each\n  module to the `--terragrunt-source` parameter you passed in.\n\n* `--terragrunt-source-update`: Delete the contents of the temporary folder before downloading Terraform source code\n  into it. Can also be enabled by setting the `TERRAGRUNT_SOURCE_UPDATE` environment variable to `true`.\n\n* `--terragrunt-ignore-dependency-errors`: `*-all` commands continue processing components even if a dependency fails\n\n* `--terragrunt-iam-role`: Assume the specified IAM role ARN before running Terraform or AWS commands. May also be\n  specified via the `TERRAGRUNT_IAM_ROLE` environment variable. This is a convenient way to use Terragrunt and\n  Terraform with multiple AWS accounts.\n\n* `--terragrunt-exclude-dir`: Unix-style glob of directories to exclude when running `*-all` commands. Modules under\n  these directories will be excluded during execution of the commands. If a relative path is specified, it should be\n  relative from `--terragrunt-working-dir`. Flag can be specified multiple times. This will only exclude the module,\n  not its dependencies.\n\n* `--terragrunt-include-dir`: Unix-style glob of directories to include when running `*-all` commands. Only modules\n  under these directories (and all dependent modules) will be included during execution of the commands. If a relative\n  path is specified, it should be relative from `--terragrunt-working-dir`. Flag can be specified multiple times.\n\n* `--terragrunt-ignore-dependency-order`: Ignore the depedencies between modules when running `*-all` commands.\n\n* `--terragrunt-ignore-external-dependencies`: Dont attempt to include any external dependencies when running `*-all`\n  commands\n\n* `--terragrunt-include-external-dependencies`: Include any external dependencies when running `*-all` without asking.\n\n### Configuration\n\nTerragrunt configuration is defined in a `terragrunt.hcl` file. This uses the same HCL syntax as Terraform itself.\n\nHere\'s an example:\n\n```hcl\ninclude {\n  path = find_in_parent_folders()\n}\n\ndependencies {\n  paths = ["../vpc", "../mysql", "../redis"]\n}\n```\n\nTerragrunt figures out the path to its config file according to the following rules:\n\n 1. The value of the `--terragrunt-config` command-line option, if specified.\n 1. The value of the `TERRAGRUNT_CONFIG` environment variable, if defined.\n 1. A `terragrunt.hcl` file in the current working directory, if it exists.\n 1. If none of these are found, exit with an error.\n\n\n#### prevent_destroy\n\nTerragrunt `prevent_destroy` boolean flag allows you to protect selected Terraform module. It will prevent `destroy`\nor `destroy-all` command to actually destroy resources of the protected module. This is useful for modules you want\nto carefully protect, such as a database, or a module that provides auth.\n\nExample:\n\n```hcl\nterraform {\n  source = "git::git@github.com:foo/modules.git//app?ref=v0.0.3"\n}\n\nprevent_destroy = true\n```\n\n#### skip\n\nThe terragrunt `skip` boolean flag can be used to protect modules you don\'t want any changes to or just to skip modules\nthat don\'t define any infrastructure by themselves. When set to true, all terragrunt commands will skip the selected\nmodule.\n\nConsider the following file structure:\n\n```\nroot\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 prod\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 dev\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 qa\n \xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nIn some cases, the root level `terragrunt.hcl` file is solely used to DRY up your Terraform configuration by being\nincluded in the other `terragrunt.hcl` files. In this case, you do not want the `xxx-all` commands to process the root\nlevel `terragrunt.hcl` since it does not define any infrastructure by itself. To make the `xxx-all` commands skip the\nroot level `terragrunt.hcl` file, you can set `skip = true`:\n\n```hcl\nskip = true\n```\n\nThe `skip` flag must be set explicitly in terragrunt modules that should be skipped. If you set `skip = true` in a\n`terragrunt.hcl` file that is included by another `terragrunt.hcl` file, only the `terragrunt.hcl` file that explicitly\nset `skip = true` will be skipped.\n\n\n### Configuration parsing order\n\nIt is important to be aware of the terragrunt configuration parsing order when using features like [locals](#locals) and\n[dependency outputs](#passing-outputs-between-modules), where you can reference attributes of other blocks in the config\nin your `inputs`. For example, because `locals` are evaluated before `dependency` blocks, you can not bind outputs\nfrom `dependency` into `locals`. On the other hand, for the same reason, you can use `locals` in the\n`dependency` blocks.\n\nCurrently terragrunt parses the config in the following order:\n\n1. `include` block\n1. `locals` block\n1. `dependencies` block\n1. `dependency` blocks, including calling `terragrunt output` on the dependent modules to retrieve the outputs\n1. Everything else\n1. The config referenced by `include`\n1. A merge operation between the config referenced by `include` and the current config.\n\nBlocks that are parsed earlier in the process will be made available for use in the parsing of later blocks. Similarly,\nyou cannot use blocks that are parsed later earlier in the process (e.g you can\'t reference `dependency` in\n`locals`, `include`, or `dependencies` blocks).\n\nNote that the parsing order is slightly different when using the `-all` flavors of the command. In the `-all` flavors of\nthe command, Terragrunt parses the configuration twice. In the first pass, it follows the following parsing order:\n\n1. `include` block of all configurations in the tree\n1. `locals` block of all configurations in the tree\n1. `dependency` blocks of all configurations in the tree, but does NOT retrieve the outputs\n1. `terraform` block of all configurations in the tree\n1. `dependencies` block of all configurations in the tree\n\nThe results of this pass are then used to build the dependency graph of the modules in the tree. Once the graph is\nconstructed, Terragrunt will loop through the modules and run the specified command. It will then revert to the single\nconfiguration parsing order specified above for each module as it runs the command.\n\nThis allows Terragrunt to avoid resolving `dependency` on modules that haven\'t been applied yet when doing a\nclean deployment from scratch with `apply-all`.\n\n\n### Formatting terragrunt.hcl\n\nYou can rewrite `terragrunt.hcl` files to a canonical format using the `hclfmt` command built into `terragrunt`. Similar\nto `terraform fmt`, this command applies a subset of [the Terraform language style\nconventions](https://www.terraform.io/docs/configuration/style.html), along with other minor adjustments for\nreadability.\n\nThis command will recursively search for `terragrunt.hcl` files and format all of them under a given directory tree.\nConsider the following file structure:\n\n```\nroot\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 prod\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 dev\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 qa\n \xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 terragrunt.hcl\n```\n\nIf you run `terragrunt hclfmt` at the `root`, this will update:\n\n- `root/terragrunt.hcl`\n- `root/prod/terragrunt.hcl`\n- `root/dev/terragrunt.hcl`\n- `root/qa/terragrunt.hcl`\n\nAdditionally, there\'s a flag `--terragrunt-check`. It allows to validating if files are properly formatted. It does not\nrewrite files and in case of invalid format, it will return an error with exit status 0.\n\n#### terraform_binary\n\nThe terragrunt `terraform_binary` string option can be used to override the default terraform binary path (which is `terraform`).\n\nThe precedence is as follows: `--terragrunt-tfpath` command line option -> `TERRAGRUNT_TFPATH` env variable -> `terragrunt.hcl` in the module directory -> included `terragrunt.hcl`\n\n#### download_dir\n\nThe terragrunt `download_dir` string option can be used to override the default download directory.\n\nThe precedence is as follows: `--terragrunt-download-dir` command line option -> `TERRAGRUNT_DOWNLOAD` env variable -> `terragrunt.hcl` in the module directory -> included `terragrunt.hcl`\n\nIt supports all terragrunt functions, i.e. `path_relative_from_include()`.\n\n#### terraform_version_constraint\n\nThe terragrunt `terraform_version_constraint` string overrides the default minimum supported version of terraform.\nTerragrunt only officially supports the latest version of terraform, however in some cases an old terraform is needed.\n\nFor example:\n\n```hcl\nterraform_version_constraint = ">= 0.11"\n```\n\n### Clearing the Terragrunt cache\n\nTerragrunt creates a `.terragrunt-cache` folder in the current working directory as its scratch directory. It downloads\nyour remote Terraform configurations into this folder, runs your Terraform commands in this folder, and any modules and\nproviders those commands download also get stored in this folder. You can safely delete this folder any time and\nTerragrunt will recreate it as necessary.\n\nIf you need to clean up a lot of these folders (e.g., after `terragrunt apply-all`), you can use the following commands\non Mac and Linux:\n\nRecursively find all the `.terragrunt-cache` folders that are children of the current folder:\n\n```bash\nfind . -type d -name ".terragrunt-cache"\n```\n\nIf you are ABSOLUTELY SURE you want to delete all the folders that come up in the previous command, you can recursively\ndelete all of them as follows:\n\n```bash\nfind . -type d -name ".terragrunt-cache" -prune -exec rm -rf {} \\;\n```\n\nAlso consider setting the `TERRAGRUNT_DOWNLOAD` environment variable if you wish to place the cache directories\nsomewhere else.\n\n\n\n\n### Contributing\n\nTerragrunt is an open source project, and contributions from the community are very welcome! Please check out the\n[Contribution Guidelines](CONTRIBUTING.md) and [Developing Terragrunt](#developing-terragrunt) for instructions.\n\n\n\n\n\n### Developing Terragrunt\n\n#### Running locally\n\nTo run Terragrunt locally, use the `go run` command:\n\n```bash\ngo run main.go plan\n```\n\n#### Dependencies\n\n* Terragrunt uses `dep`, a vendor package management tool for golang. See the dep repo for\n  [installation instructions](https://github.com/golang/dep).\n\n#### Running tests\n\n**Note**: The tests in the `dynamodb` folder for Terragrunt run against a real AWS account and will add and remove\nreal data from DynamoDB. DO NOT hit `CTRL+C` while the tests are running, as this will prevent them from cleaning up\ntemporary tables and data in DynamoDB. We are not responsible for any charges you may incur.\n\nBefore running the tests, you must configure your [AWS credentials](#aws-credentials) and [AWS IAM policies](#aws-iam-policies).\n\nTo run all the tests:\n\n```bash\ngo test -v ./...\n```\n\nTo run only the tests in a specific package, such as the package `remote`:\n\n```bash\ncd remote\ngo test -v\n```\n\nAnd to run a specific test, such as `TestToTerraformRemoteConfigArgsNoBackendConfigs` in package `remote`:\n\n```bash\ncd remote\ngo test -v -run TestToTerraformRemoteConfigArgsNoBackendConfigs\n```\n\n\n#### Debug logging\n\nIf you set the `TERRAGRUNT_DEBUG` environment variable to "true", the stack trace for any error will be printed to\nstdout when you run the app.\n\nAdditionally, newer features introduced in v0.19.0 (such as `locals` and `dependency` blocks) can output more verbose\nlogging if you set the `TG_LOG` environment variable to `debug`.\n\n\n#### Error handling\n\nIn this project, we try to ensure that:\n\n1. Every error has a stacktrace. This makes debugging easier.\n1. Every error generated by our own code (as opposed to errors from Go built-in functions or errors from 3rd party\n   libraries) has a custom type. This makes error handling more precise, as we can decide to handle different types of\n   errors differently.\n\nTo accomplish these two goals, we have created an `errors` package that has several helper methods, such as\n`errors.WithStackTrace(err error)`, which wraps the given `error` in an Error object that contains a stacktrace. Under\nthe hood, the `errors` package is using the [go-errors](https://github.com/go-errors/errors) library, but this may\nchange in the future, so the rest of the code should not depend on `go-errors` directly.\n\nHere is how the `errors` package should be used:\n\n1. Any time you want to create your own error, create a custom type for it, and when instantiating that type, wrap it\n   with a call to `errors.WithStackTrace`. That way, any time you call a method defined in the Terragrunt code, you\n   know the error it returns already has a stacktrace and you don\'t have to wrap it yourself.\n1. Any time you get back an error object from a function built into Go or a 3rd party library, immediately wrap it with\n   `errors.WithStackTrace`. This gives us a stacktrace as close to the source as possible.\n1. If you need to get back the underlying error, you can use the `errors.IsError` and `errors.Unwrap` functions.\n\n\n#### Formatting\n\nEvery source file in this project should be formatted with `go fmt`. There are few helper scripts and targets in the\nMakefile that can help with this (mostly taken from the [terraform repo](https://github.com/hashicorp/terraform/)):\n\n1. `make fmtcheck`\n\n   Checks to see if all source files are formatted. Exits 1 if there are unformatted files.\n1. `make fmt`\n\n    Formats all source files with `gofmt`.\n1. `make install-pre-commit-hook`\n\n    Installs a git pre-commit hook that will run all of the source files through `gofmt`.\n\nTo ensure that your changes get properly formatted, please install the git pre-commit hook with `make install-pre-commit-hook`.\n\n\n#### Releasing new versions\n\nTo release a new version, just go to the [Releases Page](https://github.com/gruntwork-io/terragrunt/releases) and\ncreate a new release. The CircleCI job for this repo has been configured to:\n\n1. Automatically detect new tags.\n1. Build binaries for every OS using that tag as a version number.\n1. Upload the binaries to the release in GitHub.\n\nSee `.circleci/config.yml` for details.\n\n\n### License\n\nThis code is released under the MIT License. See LICENSE.txt.\n'