b'# HashiCorp Vault on GKE with Terraform\n\nThis tutorial walks through provisioning a highly-available [HashiCorp\nVault][vault] cluster on [Google Kubernetes Engine][gke] using [HashiCorp\nTerraform][terraform] as the provisioning tool.\n\nThis tutorial is based on [Kelsey Hightower\'s Vault on Google Kubernetes\nEngine][kelseys-tutorial], but focuses on codifying the steps in Terraform\ninstead of teaching you them individually. If you would like to know how to\nprovision HashiCorp Vault on Kuberenetes step-by-step (aka "the hard way"),\nplease follow Kelsey\'s repository instead.\n\n**These configurations require Terraform 0.12+!** For support with Terraform\n0.11, please use the git tag v0.1.2 series.\n\n\n## Feature Highlights\n\n- **Vault HA** - The Vault cluster is deployed in HA mode backed by [Google\n  Cloud Storage][gcs]\n\n- **Production Hardened** - Vault is deployed according to the [production\n  hardening\n  guide](https://www.vaultproject.io/guides/operations/production.html). Please\n  see the [security section](#security) for more information.\n\n- **Auto-Init and Unseal** - Vault is automatically initialized and unsealed\n  at runtime. The unseal keys are encrypted with [Google Cloud KMS][kms] and\n  stored in [Google Cloud Storage][gcs]\n\n- **Full Isolation** - The Vault cluster is provisioned in it\'s own Kubernetes\n  cluster in a dedicated GCP project that is provisioned dynamically at\n  runtime. Clients connect to Vault using **only** the load balancer and Vault\n  is treated as a managed external service.\n\n- **Audit Logging** - Audit logging to Stackdriver can be optionally enabled\n  with minimal additional configuration.\n\n\n## Tutorial\n\n1. Download and install [Terraform][terraform].\n\n1. Download, install, and configure the [Google Cloud SDK][sdk]. You will need\n   to configure your default application credentials so Terraform can run. It\n   will run against your default project, but all resources are created in the\n   (new) project that it creates.\n\n1. Install the [kubernetes\n   CLI](https://kubernetes.io/docs/tasks/tools/install-kubectl/) (aka\n   `kubectl`)\n\n1. Run Terraform:\n\n    ```text\n    $ cd terraform/\n    $ terraform init\n    $ terraform apply\n    ```\n\n    This operation will take some time as it:\n\n    1. Creates a new project\n    1. Enables the required services on that project\n    1. Creates a bucket for storage\n    1. Creates a KMS key for encryption\n    1. Creates a service account with the most restrictive permissions to those resources\n    1. Creates a GKE cluster with the configured service account attached\n    1. Creates a public IP\n    1. Generates a self-signed certificate authority (CA)\n    1. Generates a certificate signed by that CA\n    1. Configures Terraform to talk to Kubernetes\n    1. Creates a Kubernetes secret with the TLS file contents\n    1. Configures your local system to talk to the GKE cluster by getting the cluster credentials and kubernetes context\n    1. Submits the StatefulSet and Service to the Kubernetes API\n\n\n## Interact with Vault\n\n1. Export environment variables:\n\n    Vault reads these environment variables for communication. Set Vault\'s\n    address, the CA to use for validation, and the initial root token.\n\n    ```text\n    # Make sure you\'re in the terraform/ directory\n    # $ cd terraform/\n\n    $ export VAULT_ADDR="https://$(terraform output address)"\n    $ export VAULT_TOKEN="$(terraform output root_token)"\n    $ export VAULT_CAPATH="$(cd ../ && pwd)/tls/ca.pem"\n    ```\n\n1. Run some commands:\n\n    ```text\n    $ vault secrets enable -path=secret -version=2 kv\n    $ vault kv put secret/foo a=b\n    ```\n\n## Audit Logging\n\nAudit logging is not enabled in a default Vault installation. To enable audit\nlogging to [Stackdriver][stackdriver] on Google Cloud, enable the `file` audit\ndevice on `stdout`:\n\n```text\n$ vault audit enable file file_path=stdout\n```\n\nThat\'s it! Vault will now log all audit requests to Stackdriver. Additionally,\nbecause the configuration uses an L4 load balancer, Vault does not need to\nparse `X-Forwarded-For` headers to extract the client IP, as requests are\npassed directly to the node.\n\n## Additional Permissions\n\nYou may wish to grant the Vault service account additional permissions. This\nservice account is attached to the GKE nodes and will be the "default\napplication credentials" for Vault.\n\nTo specify additional permissions, create a `terraform.tfvars` file with the\nfollowing:\n\n```terraform\nservice_account_custom_iam_roles = [\n  "roles/...",\n]\n```\n\n### GCP Auth Method\n\nTo use the [GCP auth method][vault-gcp-auth] with the default application\ncredentials, the Vault server needs the following role:\n\n```text\nroles/iam.serviceAccountKeyAdmin\n```\n\nAlternatively you can create and upload a dedicated service account for the\nGCP auth method during configuration and restrict the node-level default\napplication credentials.\n\n### GCP Secrets Engine\n\nTo use the [GCP secrets engine][vault-gcp-secrets] with the default\napplication credentials, the Vault server needs the following roles:\n\n```text\nroles/iam.serviceAccountKeyAdmin\nroles/iam.serviceAccountAdmin\n```\n\nAdditionally, Vault needs the superset of any permissions it will grant. For\nexample, if you want Vault to generate GCP access tokens with access to\ncompute, you must also grant Vault access to compute.\n\nAlternatively you can create and upload a dedicated service account for the\nGCP auth method during configuration and restrict the node-level default\napplication credentials.\n\n\n## Cleaning Up\n\n```text\n$ terraform destroy\n```\n\n\n## Security\n\n### Root Token\n\nThis set of Terraform configurations is designed to make your life easy. It\'s\na best-practices setup for Vault, but also aids in the retrieval of the initial\nroot token. **The decrypted initial root token will be stored in your state file!**\n\nAs such, you should **use a Terraform state backend with encryption enabled,\nsuch as Cloud Storage**. Alternatively you can remove the decryption calls in\n`k8s.tf` and manually decrypt the root token using `gcloud`. Terraform\nauto-generates the command, but you will need to setup the permissions for your\nlocal default application credentials.\n\n```text\n$ $(terraform output token_decrypt_command)\n```\n\n### TLS Keys, Service Accounts, etc\n\nJust like the Vault root token, additional information is stored in plaintext in\nthe Terraform state. This is not a bug and is the fundamental design of\nTerraform. You are ultimately responsible for securing access to your Terraform\nstate. As such, you should **use a Terraform state backend with encryption\nenabled, such as Cloud Storage**.\n\n- Vault TLS keys - the Vault TLS keys, including the private key, are stored in\n  Terraform state. Terraform created the resources and thus maintains their\n  data.\n\n- Service Account Key - Terraform generates a Google Cloud Service Account key\n  in order to download the initial root token from Cloud Storage. This service\n  account key is stored in the Terraform state.\n\n- OAuth Access Token - In order to communicate with the Kubernetes cluster,\n  Terraform gets an OAuth2 access token. This access token is stored in the\n  Terraform state.\n\nYou may be seeing a theme, which is that the Terraform state includes a wealth\nof information. This is fundamentally part of Terraform\'s architecture, and you\nshould **use a Terraform state backend with encryption enabled, such as Cloud\nStorage**.\n\n### Private Cluster\n\nThe Kubernetes cluster is a "private" cluster, meaning nodes do not have\npublicly exposed IP addresses, and pods are only publicly accessible if exposed\nthrough a load balancer service. Additionally, only authorized IP CIDR blocks\nare able to communicate with the Kubernetes master nodes.\n\nThe default allowed CIDR is `0.0.0.0/0 (anyone)`. **You should restrict this\nCIDR to the IP address(es) which will access the nodes!**.\n\n\n## FAQ\n\n**Q: How is this different than [kelseyhightower/vault-on-google-kubernetes-engine][kelseys-tutorial]?**\n<br>\nKelsey\'s tutorial walks through the manual steps of provisioning a cluster,\ncreating all the components, etc. This captures those steps as\n[Terraform](https://www.terraform.io) configurations, so it\'s a single command\nto provision the cluster, service account, ip address, etc. Instead of using\ncfssl, it uses the built-in Terraform functions.\n\n**Q: Why are you using StatefulSets instead of Deployments?**\n<br>\nA: StatefulSets ensure that each pod is deployed in order. This is important for\nthe initial bootstrapping process, otherwise there\'s a race for which Vault\nserver initializes first with auto-init.\n\n**Q: Why didn\'t you use the Terraform Kubernetes provider to create the pods? There\'s this hacky template_file data source instead...**\n<br>\nA: StatefulSets are not fully supported in Terraform yet. Should that change,\nwe can avoid the shellout to kubectl.\n\n**Q: I want to deploy without Terraform. Were is the YAML I can just apply?**\n<br>\n\nA: The YAML _template_ is in [k8s/vault.yaml][] in this repository. However,\nthe spec requires information that is only known at runtime. Specifically, you\nwill need to fill in any values with the dollar-brace `${...}` syntax before\nyou can apply the spec with `kubectl`;. For example:\n\n```diff\n spec:\n   type: LoadBalancer\n-  loadBalancerIP: ${load_balancer_ip}\n+  loadBalancerIP: 124.2.55.3\n   externalTrafficPolicy: Local\n   selector:\n    app: vault\n```\n\n\n[gcs]: https://cloud.google.com/storage\n[gke]: https://cloud.google.com/kubernetes-engine\n[kms]: https://cloud.google.com/kms\n[sdk]: https://cloud.google.com/sdk\n[kelseys-tutorial]: https://github.com/kelseyhightower/vault-on-google-kubernetes-engine\n[stackdriver]: https://cloud.google.com/stackdriver/\n[terraform]: https://www.terraform.io\n[vault]: https://www.vaultproject.io\n[vault-gcp-auth]: https://www.vaultproject.io/docs/auth/gcp.html\n[vault-gcp-secrets]: https://www.vaultproject.io/docs/secrets/gcp/index.html\n'