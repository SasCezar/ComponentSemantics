b'## Node + Docker Hello World, for Showing Good Defaults for Using Node.js in Docker\n\n> This tries to be a "good defaults" example of starting to use Node.js in Docker for local development and shipping to production with basic bells, whistles, and best practices. Issues/PR welcome.\n\n**Note** I have more advanced examples of Node.js Dockerfiles and Compose files in my [DockerCon 2019 talk and repo](https://github.com/BretFisher/dockercon19). I also have more about everything Docker and Node.js in my 8 hour video course [Docker for Node.js](https://www.bretfisher.com/node/). \n\n**Also Note**, I have other resources on [Docker and Kubernetes here](https://www.bretfisher.com/docker).\n\n### Local Development Features\n\n - **Dev as close to prod as you can**. docker-compose builds a local development image that is just like production image except for the below dev-only features needed in image. Goal is to have dev env be as close to test and prod as possible while still giving all the nice tools to make you a happy dev.\n - **Prevent needing node/npm on host**. Installs `node_modules` outside app root in container so local development won\'t run into a problem of bind-mounting over it with local source code. This means it will run `npm install` once on container build and you don\'t need to run npm on host or on each docker run. It will re-run on build if you change `package.json`.\n - **One line startup**. Uses `docker-compose up` for single-line build and run of local development server.\n - **Edit locally while code runs in container**. docker-compose uses proper bind-mounts of host source code into container so you can edit locally while running code in Linux container.\n - **Use nodemon in container**. docker-compose uses nodemon for development for auto-restarting node in container when you change files on host.\n - **Enable debug from host to container**. opens the inspect port 9229 for using host-based debugging like chrome tools or VS Code. Nodemon enables `--inspect` by default in docker-compose.\n - **Provides VSCode debug configs and tasks for tests**. for Visual Studio Code fans, `.vscode` directory has the goods, thanks to @JPLemelin.\n - **Small image and quick re-builds**. `COPY` in `package.json` and run `npm install` **before** `COPY` in your source code. This saves big on build time and keep container lean.\n - **Bind-mount package.json**. This allows adding packages in realtime without rebuilding images. e.g. `dce node npm install --save <package name>` (dosn\'t work on all systems)\n\n\n### Production-minded Features\n\n - **Use Docker build-in healthchecks**. uses Dockerfile `HEALTHCHECK` with `/healthz` route to help Docker know if your container is running properly (example always returns 200, but you get the idea).\n - **Proper NODE_ENV use**. Defaults to `NODE_ENV=production` in Dockerfile and overrides to `development` in docker-compose for local dev.\n - **Don\'t add dev dependencies into production image**. Proper `NODE_ENV` use means dev dependencies won\'t be installed in container by default. Using docker-compose will build with them by default.\n - **Enables proper SIGTERM/SIGINT for graceful exit**. Defaults to `node index.js` rather then npm for allowing graceful shutdown of node. npm doesn\'t pass SIGTERM/SIGINT properly (you can\'t ctrl-c when running `docker run` in foreground). To get `node index.js` to graceful exit, extra signal-catching code is needed. The `Dockerfile` and `index.js` document the options and links to known issues.\n - **Run node in the container as `node` user, not `root`**. \n - **Use docker-stack.yml example for Docker Swarm deployments**.\n\n\n### Assumptions\n\n - You have Docker and Docker-Compose installed (Docker for Mac, Docker for Windows, get.docker.com and manual Compose installed for Linux).\n - You want to use Docker for local development (i.e. never need to install node/npm on host) and have dev and prod Docker images be as close as possible.\n - You don\'t want to lose fidelity in your dev workflow. You want a easy environment setup, using local editors, node debug/inspect, local code repo, while node server runs in a container.\n - You use `docker-compose` for local development only (docker-compose was never intended to be a production deployment tool anyway).\n - The `docker-compose.yml` is not meant for `docker stack deploy` in Docker Swarm, it\'s meant for happy local development. Use `docker-stack.yml` for Swarm.\n\n \n### Getting Started\n\nIf this was your Node.js app, to start local development you would:\n\n - Running `docker-compose up` is all you need. It will:\n - Build custom local image enabled for development (nodemon, `NODE_ENV=development`).\n - Start container from that image with ports 80 and 9229 open (on localhost).\n - Starts with `nodemon` to restart node on file change in host pwd.\n - Mounts the pwd to the app dir in container.\n - If you need other services like databases, just add to compose file and they\'ll be added to the custom Docker network for this app on `up`.\n - Compose should detect if you need to rebuild due to changed package.json or Dockerfile, but `docker-compose build` works for manually building.\n - Be sure to use `docker-compose down` to cleanup after your done dev\'ing.\n\nIf you wanted to add a package while docker-compose was running your app:\n - `docker-compose exec -w /opt/node_app node npm install --save <package name>`\n - This installs it inside the running container.\n - Nodemon will detect the change and restart.\n - `--save` will add it to the package.json for next `docker-compose build`\n\nTo execute the unit-tests, you would:\n - Execute `docker-compose exec node npm test`, It will:\n - Run a process `npm test` in the container node.\n - You can use the *vscode* to debug unit-tests with config `Docker Test (Attach 9230 --inspect)`, It will:\n   - Start a debugging process in the container and wait-for-debugger, this is done by *vscode tasks*\n   - It will also kill previous debugging process if existing.\n\n### Ways to improve security\n\n#### Run Node.js as Non-Root User\n\nAs mentioned in the official docker node image docs, Docker runs the image as root. This can pose a potential security issue.\n  - https://github.com/nodejs/docker-node/blob/master/docs/BestPractices.md#non-root-user\n\nAs a security best practice, it is recommended for node apps to listen on non-privileged ports as mentioned here:\n  - https://github.com/i0natan/nodebestpractices/blob/master/sections/security/non-root-user.md\n\n### Other Resources\n\n - https://blog.hasura.io/an-exhaustive-guide-to-writing-dockerfiles-for-node-js-web-apps-bbee6bd2f3c4\n\nMIT License, \n\nCopyright (c) 2015-2019 Bret Fisher\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n'