b'SwiftyRSA\n=========\n\n**Maintainer(s):** [@starback](https://github.com/starback)\n\n[![](https://img.shields.io/cocoapods/v/SwiftyRSA.svg)](https://cocoapods.org/pods/SwiftyRSA)\n![](https://img.shields.io/badge/carthage-compatible-brightgreen.svg)\n![](https://img.shields.io/cocoapods/p/SwiftyRSA.svg)\n![](https://img.shields.io/badge/language-swift_3.2/4.2-brightgreen.svg)\n[![](https://circleci.com/gh/TakeScoop/SwiftyRSA.png?style=shield&circle-token=03e95e0cd05dab2e159cf65d6e62de1d1d84148e)](https://circleci.com/gh/TakeScoop/SwiftyRSA)\n\n**Public key RSA encryption in Swift.**\n\nSwiftyRSA is used in the [Scoop](https://www.takescoop.com/) [iOS app](https://itunes.apple.com/us/app/scoop-easy-custom-carpooling/id997978145?mt=8) to encrypt driver license numbers before submitting them to Checkr through our API.\n\nInstallation\n------------\n\n### Swift 3.2 / 4.0+\n\nWith Cocoapods:\n\n```\npod \'SwiftyRSA\'\n```\n\nWith Carthage:\n\n```\ngithub "TakeScoop/SwiftyRSA"\n```\n\n### Swift 2.3\n\nThe `swift-2.3` branch is built out of SwiftRSA 0.4.0 and is not actively maintained. If you\'d like to use the latest features of SwiftyRSA, please use swift 3.0.\n\n```\npod \'SwiftyRSA\', :git => \'git@github.com:TakeScoop/SwiftyRSA.git\', :branch => \'swift-2.3\'\n```\n\n### Objective-C\n\n```\npod \'SwiftyRSA/ObjC\'\n```\n\n\nQuick Start\n-----------\n\n### Encrypt with a public key\n\n```swift\nlet publicKey = try PublicKey(pemNamed: "public")\nlet clear = try ClearMessage(string: "Clear Text", using: .utf8)\nlet encrypted = try clear.encrypted(with: publicKey, padding: .PKCS1)\n\n// Then you can use:\nlet data = encrypted.data\nlet base64String = encrypted.base64String\n```\n\n### Decrypt with a private key\n\n```swift\nlet privateKey = try PrivateKey(pemNamed: "private")\nlet encrypted = try EncryptedMessage(base64Encoded: "AAA===")\nlet clear = try encrypted.decrypted(with: privateKey, padding: .PKCS1)\n\n// Then you can use:\nlet data = clear.data\nlet base64String = clear.base64String\nlet string = clear.string(using: .utf8)\n```\n\n\nAdvanced Usage\n--------------\n\n### Create a public/private key representation\n\n#### With a DER file\n\n```swift\nlet publicKey = try PublicKey(derNamed: "public")\nlet privateKey = try PrivateKey(derNamed: "private")\n```\n\n#### With a PEM file\n\n```swift\nlet publicKey = try PublicKey(pemNamed: "public")\nlet privateKey = try PrivateKey(pemNamed: "private")\n```\n\n#### With a PEM string\n\n```swift\nlet publicKey = try PublicKey(pemEncoded: str)\nlet privateKey = try PrivateKey(pemEncoded: str)\n```\n\n#### With a Base64 string\n\n```swift\nlet publicKey = try PublicKey(base64Encoded: base64String)\nlet privateKey = try PrivateKey(base64Encoded: base64String)\n```\n\n#### With data\n\n```swift\nlet publicKey = try PublicKey(data: data)\nlet privateKey = try PrivateKey(data: data)\n```\n\n#### With a SecKey\n\n```swift\nlet publicKey = try PublicKey(reference: secKey)\nlet privateKey = try PrivateKey(reference: secKey)\n```\n\n### Encrypt with a public key\n\n```swift\nlet str = "Clear Text"\nlet clear = try ClearMessage(string: str, using: .utf8)\nlet encrypted = try clear.encrypted(with: publicKey, padding: .PKCS1)\n\nlet data = encrypted.data\nlet base64String = encrypted.base64Encoded\n```\n\n### Decrypt with a private key\n\n```swift\nlet encrypted = try EncryptedMessage(base64Encoded: base64String)\nlet clear = try encrypted.decrypted(with: privateKey, padding: .PKCS1)\n\nlet data = clear.data\nlet base64String = clear.base64Encoded\nlet string = try clear.string(using: .utf8)\n```\n\n### Sign with a private key\n\nSwiftyRSA can sign data with a private key. SwiftyRSA will calculate a SHA digest of the supplied `String`/`Data` and use this to generate the digital signature.\n\n```swift\nlet clear = try ClearMessage(string: "Clear Text", using: .utf8)\nlet signature = clear.signed(with: privateKey, digestType: .sha1)\n\nlet data = signature.data\nlet base64String = signature.base64String\n```\n\n### Verify with a public key\n\nSwiftyRSA can verify digital signatures with a public key. SwiftyRSA will calculate a digest of the supplied `String`/`Data` and use this to verify the digital signature.\n\n```swift\nlet signature = try Signature(base64Encoded: "AAA===")\nlet isSuccessful = try clear.verify(with: publicKey, signature: signature, digestType: .sha1)\n```\n\n### Create a public/private RSA key pair\n\n```swift\nlet keyPair = SwiftyRSA.generateRSAKeyPair(sizeInBits: 2048)\nlet privateKey = keyPair.privateKey\nlet publicKey = keyPair.publicKey\n```\n\n### Export a key or access its content\n\n```swift\nlet pem = try key.pemString()\nlet base64 = try key.base64String()\nlet data = try key.data()\nlet reference = key.reference\nlet originalData = key.originalData\n```\n\nCreate public and private RSA keys\n----------------------------------\n\nUse `ssh-keygen` to generate a PEM public key and a PEM private key. SwiftyRSA also supports DER public keys.\n\n```\n$ ssh-keygen -t rsa -f ~/mykey -N \'\'\n$ cat ~/mykey > ~/private.pem\n$ ssh-keygen -f ~/mykey.pub -e -m pem > ~/public.pem\n```\n\nYour keys are now in `~/public.pem` and `~/private.pem`. Don\'t forget to move `~/mykey` and `~/mykey.pub` to a secure place.\n\nUnder the hood\n--------------\n\nTo enable using public/private RSA keys on iOS, SwiftyRSA uses a couple techniques like X.509 header stripping so that the keychain accepts them.\n\n<details>\n\t<summary>Click here for more details</summary>\n\nWhen encrypting using a public key:\n\n - If the key is in PEM format, get rid of its meta data and convert it to Data\n - Strip the public key X.509 header, otherwise the keychain won\'t accept it\n - Add the public key to the keychain, with a random tag\n - Get a reference on the key using the key tag\n - Use `SecKeyEncrypt` to encrypt a `ClearMessage` using the key reference and the message data.\n - Store the resulting encrypted data to an `EncryptedMessage`\n - When the key gets deallocated, delete the public key from the keychain using its tag\n\nWhen decrypting using a private key:\n\n - Get rid of PEM meta data and convert to Data\n - Add the private key to the app keychain, with a random tag\n - Get a reference on the key using the key tag\n - Use `SecKeyDecrypt` to decrypt an `EncryptedMessage` using the key reference and the encrypted message data\n - Store the resulting decrypted data to a `ClearMessage`\n - Delete private key from keychain using tag\n</details>\n\nInspired from\n-------------\n\n - <http://blog.flirble.org/2011/01/05/rsa-public-key-openssl-ios/>\n - <https://github.com/lancy/RSADemo>\n - <https://github.com/btnguyen2k/swift-rsautils>\n\nLicense\n-------\n\nThis project is copyrighted under the MIT license. Complete license can be found here: <https://github.com/TakeScoop/SwiftyRSA/blob/master/LICENSE>\n'