b'Follow [@ServiceStack](https://twitter.com/servicestack) or [view the docs](https://docs.servicestack.net), use [StackOverflow](http://stackoverflow.com/questions/ask) or the [Customer Forums](https://forums.servicestack.net/) for support.\n\n# Fast, Simple, Typed ORM for .NET\n\nOrmLite\'s goal is to provide a convenient, DRY, config-free, RDBMS-agnostic typed wrapper that retains \na high affinity with SQL, exposing intuitive APIs that generate predictable SQL and maps cleanly to \n(DTO-friendly) disconnected POCO\'s. This approach makes easier to reason-about your data access making \nit obvious what SQL is getting executed at what time, whilst mitigating unexpected behavior, \nimplicit N+1 queries and leaky data access prevalent in Heavy ORMs.\n\nOrmLite was designed with a focus on the core objectives:\n\n  * Provide a set of light-weight C# extension methods around .NET\'s impl-agnostic `System.Data.*` interfaces\n  * Map a POCO class 1:1 to an RDBMS table, cleanly by conventions, without any attributes required.\n  * Create/Drop DB Table schemas using nothing but POCO class definitions (IOTW a true code-first ORM)\n  * Simplicity - typed, wrist friendly API for common data access patterns.\n  * High performance - with support for indexes, text blobs, etc.\n    * Amongst the [fastest Micro ORMs](http://mono.servicestack.net/benchmarks/) for .NET.\n  * Expressive power and flexibility - with access to IDbCommand and raw SQL\n  * Cross platform - supports multiple dbs (currently: Sql Server, Sqlite, MySql, PostgreSQL, Firebird) running on both .NET and Mono platforms.\n\nIn OrmLite: **1 Class = 1 Table**. There should be no surprising or hidden behaviour, the Typed API\nthat produces the Query \n[doesn\'t impact how results get intuitively mapped](http://stackoverflow.com/a/37443162/85785)\nto the returned POCO\'s which could be different to the POCO used to create the query, e.g. containing only \na subset of the fields you want populated.\n\nAny non-scalar properties (i.e. complex types) are text blobbed by default in a schema-less text field \nusing any of the [available pluggable text serializers](#pluggable-complex-type-serializers). \nSupport for [POCO-friendly references](#reference-support-poco-style) is also available to provide \na convenient API to persist related models. Effectively this allows you to create a table from any \nPOCO type and it should persist as expected in a DB Table with columns for each of the classes 1st \nlevel public properties.\n\n# Download \n\n[![Download on NuGet](https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/install-ormlite.png)](https://www.nuget.org/packages?q=servicestack+ormlite)\n\n### 8 flavours of OrmLite is on NuGet: \n\n  - [ServiceStack.OrmLite.SqlServer](http://nuget.org/List/Packages/ServiceStack.OrmLite.SqlServer)\n  - [ServiceStack.OrmLite.Sqlite](http://nuget.org/packages/ServiceStack.OrmLite.Sqlite)\n  - [ServiceStack.OrmLite.PostgreSQL](http://nuget.org/List/Packages/ServiceStack.OrmLite.PostgreSQL)\n  - [ServiceStack.OrmLite.MySql](http://nuget.org/List/Packages/ServiceStack.OrmLite.MySql)\n  - [ServiceStack.OrmLite.MySqlConnector](http://nuget.org/List/Packages/ServiceStack.OrmLite.MySqlConnector)\n\nThese packages contain both **.NET Framework v4.5** and **.NET Standard 2.0** versions and supports both .NET Framework and .NET Core projects.\n\nThe `.Core` packages contains only **.NET Standard 2.0** versions which can be used in ASP.NET Core Apps running on the .NET Framework:\n\n  - [ServiceStack.OrmLite.SqlServer.Core](http://nuget.org/List/Packages/ServiceStack.OrmLite.SqlServer.Core)\n  - [ServiceStack.OrmLite.PostgreSQL.Core](http://nuget.org/List/Packages/ServiceStack.OrmLite.PostgreSQL.Core)\n  - [ServiceStack.OrmLite.MySql.Core](http://nuget.org/List/Packages/ServiceStack.OrmLite.MySql.Core)\n  - [ServiceStack.OrmLite.Sqlite.Core](http://nuget.org/packages/ServiceStack.OrmLite.Sqlite.Core) \n\nUnofficial Releases maintained by ServiceStack Community:\n\n  - [ServiceStack.OrmLite.Oracle](http://nuget.org/packages/ServiceStack.OrmLite.Oracle)\n  - [ServiceStack.OrmLite.Firebird](http://nuget.org/List/Packages/ServiceStack.OrmLite.Firebird)\n  - [ServiceStack.OrmLite.VistaDb](http://nuget.org/List/Packages/ServiceStack.OrmLite.VistaDb)\n\n_Latest v4+ on NuGet is a [commercial release](https://servicestack.net/ormlite) with [free quotas](https://servicestack.net/download#free-quotas)._\n\n### [Getting Started with OrmLite and AWS RDS](https://github.com/ServiceStackApps/AwsGettingStarted)\n\nOrmLite has great support AWS\'s managed RDS Databases, follow these getting started guides to help getting up and running quickly:\n\n- [PostgreSQL](https://github.com/ServiceStackApps/AwsGettingStarted#getting-started-with-aws-rds-postgresql-and-ormlite)\n- [Aurora](https://github.com/ServiceStackApps/AwsGettingStarted#getting-started-with-aws-rds-aurora-and-ormlite)\n- [MySQL](https://github.com/ServiceStackApps/AwsGettingStarted#getting-started-with-aws-rds-mysql-and-ormlite)\n- [MariaDB](https://github.com/ServiceStackApps/AwsGettingStarted#getting-started-with-aws-rds-mariadb-and-ormlite)\n- [SQL Server](https://github.com/ServiceStackApps/AwsGettingStarted#getting-started-with-aws-rds-sql-server-and-ormlite)\n\n#### [Docs and Downloads for older v3 BSD releases](https://github.com/ServiceStackV3/ServiceStackV3)\n\n### Copying\n\nSince September 2013, ServiceStack source code is available under GNU Affero General Public \nLicense/FOSS License Exception, see license.txt in the source. \nAlternative [commercial licensing](https://servicestack.net/ormlite) is also available.\n\n### Contributing\n\nContributors need to approve the [Contributor License Agreement](https://docs.google.com/forms/d/16Op0fmKaqYtxGL4sg7w_g-cXXyCoWjzppgkuqzOeKyk/viewform) \nbefore submitting pull-requests, see the [Contributing wiki](https://github.com/ServiceStack/ServiceStack/wiki/Contributing) for more details. \n\n***\n\n## Usage\n\nFirst Install the NuGet package of the RDBMS you want to use, e.g:\n\n    PM> Install-Package ServiceStack.OrmLite.SqlServer\n\nEach RDBMS includes a specialized dialect provider that encapsulated the differences in each RDBMS \nto support OrmLite features. The available Dialect Providers for each RDBMS is listed below:\n\n    SqlServerDialect.Provider      // SQL Server Version 2012+\n    SqliteDialect.Provider         // Sqlite\n    PostgreSqlDialect.Provider     // PostgreSQL \n    MySqlDialect.Provider          // MySql\n    OracleDialect.Provider         // Oracle\n    FirebirdDialect.Provider       // Firebird\n    VistaDbDialect.Provider        // Vista DB\n\n#### SQL Server Versions\n\nThere are a number of different SQL Server dialects to take advantage of features available in each version. For any version before SQL Server 2008 please use `SqlServer2008Dialect.Provider`, for any other version please use the best matching version:\n\n    SqlServer2008Dialect.Provider  // SQL Server <= 2008\n    SqlServer2012Dialect.Provider  // SQL Server 2012\n    SqlServer2014Dialect.Provider  // SQL Server 2014\n    SqlServer2016Dialect.Provider  // SQL Server 2016\n    SqlServer2017Dialect.Provider  // SQL Server 2017+\n\n### Configure OrmLiteConnectionFactory\n\nTo configure OrmLite you need the DB Connection string along the Dialect Provider of the RDBMS you\'re\nconnecting to, e.g: \n\n```csharp\nvar dbFactory = new OrmLiteConnectionFactory(\n    connectionString,  \n    SqlServerDialect.Provider);\n```\n\nIf you\'re using an IOC you can register `OrmLiteConnectionFactory` as a **singleton**, e.g:\n\n```csharp\ncontainer.Register<IDbConnectionFactory>(c => \n    new OrmLiteConnectionFactory(":memory:", SqliteDialect.Provider)); //InMemory Sqlite DB\n```\n\nYou can then use the `dbFactory` to open ADO.NET DB Connections to your database. \nIf connecting to an empty database you can use OrmLite\'s Create Table API\'s to create any tables\nyou need based solely on the Schema definition of your POCO and populate it with any initial \nseed data you need, e.g:\n\n```csharp\nusing (var db = dbFactory.Open())\n{\n    if (db.CreateTableIfNotExists<Poco>())\n    {\n        db.Insert(new Poco { Id = 1, Name = "Seed Data"});\n    }\n\n    var result = db.SingleById<Poco>(1);\n    result.PrintDump(); //= {Id: 1, Name:Seed Data}\n}\n```\n\n## [OrmLite Interactive Tour](http://gistlyn.com/ormlite)\n\nThe best way to learn about OrmLite is to take the [OrmLite Interactive Tour](http://gistlyn.com/ormlite)\nwhich lets you try out and explore different OrmLite features immediately from the comfort of your own \nbrowser without needing to install anything:\n\n[![](https://raw.githubusercontent.com/ServiceStack/Assets/master/img/ormlite/ormlite-tour.png)](http://gistlyn.com/ormlite)\n\n## [Type Converters](https://github.com/ServiceStack/ServiceStack.OrmLite/wiki/OrmLite-Type-Converters)\n\nYou can customize, enhance or replace how OrmLite handles specific .NET Types with the new \n[OrmLite Type Converters](https://github.com/ServiceStack/ServiceStack.OrmLite/wiki/OrmLite-Type-Converters).\n\nThere\'s also support for SQL Server-specific `SqlGeography`, `SqlGeometry` and `SqlHierarchyId` Types,\nSee [docs on SQL Server Types](https://github.com/ServiceStack/ServiceStack.OrmLite/wiki/SQL-Server-Types) \nfor instructions on how to enable them.\n\n# Async API Overview\n\nA quick overview of Async API\'s can be seen in the class diagram below:\n\n![OrmLite Async APIs](https://raw.githubusercontent.com/ServiceStack/Assets/master/img/ormlite/OrmLiteApiAsync.png) \n\nEssentially most of OrmLite public API\'s now have async equivalents of the same name and an additional conventional `*Async` suffix. \nThe Async API\'s also take an optional `CancellationToken` making converting sync code trivial, where you just need to\nadd the `Async` suffix and **await** keyword, as can be seen in the \n[Customer Orders UseCase upgrade to Async diff](https://github.com/ServiceStack/ServiceStack.OrmLite/commit/c1ce6f0eac99133fc232b263c26c42379d4c5f48)\n, e.g:\n\nSync:\n\n```csharp\ndb.Insert(new Employee { Id = 1, Name = "Employee 1" });\ndb.Save(product1, product2);\nvar customer = db.Single<Customer>(new { customer.Email }); \n```\n\nAsync:\n\n```csharp\nawait db.InsertAsync(new Employee { Id = 1, Name = "Employee 1" });\nawait db.SaveAsync(product1, product2);\nvar customer = await db.SingleAsync<Customer>(new { customer.Email });\n```\n\n> Effectively the only Data Access API\'s that doesn\'t have async equivalents are `*Lazy` APIs yielding a lazy \n> sequence (incompatible with async) as well as **Schema** DDL API\'s which are typically not used at runtime.\n\nFor a quick preview of many of the new Async API\'s in action, checkout \n[ApiSqlServerTestsAsync.cs](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/tests/ServiceStack.OrmLite.Tests/Async/ApiSqlServerTestsAsync.cs).\n\n### Async RDBMS Providers\n\nCurrently only a limited number of RDBMS providers offer async API\'s, which at this time are only:\n\n  - [SQL Server .NET 4.5+](https://www.nuget.org/packages/ServiceStack.OrmLite.SqlServer)\n  - [PostgreSQL .NET 4.5+](https://www.nuget.org/packages/ServiceStack.OrmLite.PostgreSQL)\n  - [MySQL .NET 4.5+](https://www.nuget.org/packages/ServiceStack.OrmLite.MySql)\n\nWe\'ve also added a \n[.NET 4.5 build for Sqlite](https://www.nuget.org/packages/ServiceStack.OrmLite.Sqlite) \nas it\'s a common use-case to swapout to use Sqlite\'s in-memory provider for faster tests. \nBut as Sqlite doesn\'t provide async API\'s under-the-hood we fallback to *pseudo async* support where we just wrap its synchronous responses in `Task` results. \n\n# API Examples\n\nOrmLite provides terse and intuitive typed API\'s for database querying from simple\nlambda expressions to more complex LINQ-Like Typed SQL Expressions which you can use to\nconstruct more complex queries. To give you a flavour here are some examples: \n\n### Querying with SELECT\n\n```csharp\nint agesAgo = DateTime.Today.AddYears(-20).Year;\ndb.Select<Author>(x => x.Birthday >= new DateTime(agesAgo, 1, 1) \n                    && x.Birthday <= new DateTime(agesAgo, 12, 31));\n```\n\n```csharp\ndb.Select<Author>(x => Sql.In(x.City, "London", "Madrid", "Berlin"));\n```\n\n```csharp\ndb.Select<Author>(x => x.Earnings <= 50);\n```\n\n```csharp\ndb.Select<Author>(x => x.Name.StartsWith("A"));\n```\n\n```csharp\ndb.Select<Author>(x => x.Name.EndsWith("garzon"));\n```\n\n```csharp\ndb.Select<Author>(x => x.Name.Contains("Benedict"));\n```\n\n```csharp\ndb.Select<Author>(x => x.Rate == 10 && x.City == "Mexico");\n```\n\n```csharp\ndb.Select<Author>(x => x.Rate.ToString() == "10"); //impicit string casting\n```\n\n```csharp\ndb.Select<Author>(x => "Rate " + x.Rate == "Rate 10"); //server string concatenation\n```\n\n### Convenient common usage data access patterns \n\nOrmLite also includes a number of convenient API\'s providing DRY, typed data access for common queries:\n\n```csharp\nPerson person = db.SingleById<Person>(1);\n```\n\n```csharp\nPerson person = db.Single<Person>(x => x.Age == 42);\n```\n\n```csharp\nvar q = db.From<Person>()\n          .Where(x => x.Age > 40)\n          .Select(Sql.Count("*"));\n\nint peopleOver40 = db.Scalar<int>(q);\n```\n\n```csharp\nint peopleUnder50 = db.Count<Person>(x => x.Age < 50);\n```\n\n```csharp\nbool has42YearOlds = db.Exists<Person>(new { Age = 42 });\n```\n\n```csharp\nint maxAgeUnder50 = db.Scalar<Person, int>(x => Sql.Max(x.Age), x => x.Age < 50);\n```\n\n```csharp\nvar q = db.From<Person>()\n    .Where(x => x.Age == 27)\n    .Select(x => x.LastName);\n    \nList<string> results = db.Column<string>(q);\n```\n\n```csharp\nvar q = db.From<Person>()\n          .Where(x => x.Age < 50)\n          .Select(x => x.Age);\n\nHashSet<int> results = db.ColumnDistinct<int>(q);\n```\n\n```csharp\nvar q = db.From<Person>()\n          .Where(x => x.Age < 50)\n          .Select(x => new { x.Id, x.LastName });\n\nDictionary<int,string> results = db.Dictionary<int, string>(q);\n```\n\n```csharp\nvar q = db.From<Person>()\n          .Where(x => x.Age < 50)\n          .Select(x => new { x.Age, x.LastName });\n\nDictionary<int, List<string>> results = db.Lookup<int, string>(q);\n```\n\nThe new `db.KeyValuePair<K,V>` API is similar to `db.Dictionary<K,V>` where it uses the **first 2 columns** for its Key/Value Pairs to \ncreate a Dictionary but is more appropriate when the results can contain duplicate Keys or when ordering needs to be preserved:\n\n```csharp\nvar q = db.From<StatsLog>()\n    .GroupBy(x => x.Name)\n    .Select(x => new { x.Name, Count = Sql.Count("*") })\n    .OrderByDescending("Count");\n\nvar results = db.KeyValuePairs<string, int>(q);\n```\n\n### INSERT, UPDATE and DELETEs\n\nTo see the behaviour of the different APIs, all examples uses this simple model\n\n```csharp\npublic class Person\n{\n    public int Id { get; set; }\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    public int? Age { get; set; }\n}\n```\n\n### UPDATE\n\nIn its most simple form, updating any model without any filters will update every field, except the **Id** which \nis used to filter the update to this specific record:\n\n```csharp\ndb.Update(new Person { Id = 1, FirstName = "Jimi", LastName = "Hendrix", Age = 27});\n```\n\nIf you supply your own where expression, it updates every field (inc. Id) but uses your filter instead:\n\n```csharp\ndb.Update(new Person { Id = 1, FirstName = "JJ" }, p => p.LastName == "Hendrix");\n```\n\nOne way to limit the fields which gets updated is to use an **Anonymous Type**:\n\n```csharp\ndb.Update<Person>(new { FirstName = "JJ" }, p => p.LastName == "Hendrix");\n```\n\nOr by using `UpdateNonDefaults` which only updates the non-default values in your model using the filter specified:\n\n```csharp\ndb.UpdateNonDefaults(new Person { FirstName = "JJ" }, p => p.LastName == "Hendrix");\n```\n\n#### UpdateOnly\n\nAs updating a partial row is a common use-case in Db\'s, we\'ve added a number of methods for just \nthis purpose, named **UpdateOnly**. \n\nThe lambda syntax lets you update only the fields listed in property initializers, e.g:\n\n```csharp\ndb.UpdateOnly(() => new Person { FirstName = "JJ" });\n```\n\nThe second argument lets you specify a filter for updates: \n\n```csharp\ndb.UpdateOnly(() => new Person { FirstName = "JJ" }, where: p => p.LastName == "Hendrix");\n```\n\nAlternatively you can pass in a POCO directly, in which case the first expression in an `UpdateOnly` \nstatement is used to specify which fields should be updated:\n\n```csharp\ndb.UpdateOnly(new Person { FirstName = "JJ" }, onlyFields: p => p.FirstName);\n\ndb.UpdateOnly(new Person { FirstName = "JJ", Age = 12 }, \n    onlyFields: p => new { p.FirstName, p.Age });\n\ndb.UpdateOnly(new Person { FirstName = "JJ", Age = 12 }, \n    onlyFields: p => new[] { "Name", "Age" });\n```\n\nWhen present, the second expression is used as the where filter:\n\n```csharp\ndb.UpdateOnly(new Person { FirstName = "JJ" }, \n    onlyFields: p => p.FirstName, \n    where: p => p.LastName == "Hendrix");\n```\nInstead of using the expression filters above you can choose to use an SqlExpression builder which provides more flexibility when you want to programatically construct the update statement:\n\n```csharp\nvar q = db.From<Person>()\n    .Update(p => p.FirstName);\n\ndb.UpdateOnly(new Person { FirstName = "JJ", LastName = "Hendo" }, onlyFields: q);\n```\n\nUsing an Object Dictionary:\n\n```csharp\nvar updateFields = new Dictionary<string,object> {\n    [nameof(Person.FirstName)] = "JJ",\n};\n\ndb.UpdateOnly<Person>(updateFields, p => p.LastName == "Hendrix");\n```\n\nUsing a typed SQL Expression:\n\n```csharp\nvar q = db.From<Person>()\n    .Where(x => x.FirstName == "Jimi")\n    .Update(p => p.FirstName);\n          \ndb.UpdateOnly(new Person { FirstName = "JJ" }, onlyFields: q);\n```\n\n### Updating existing values\n\nThe `UpdateAdd` API provides several Typed API\'s for updating existing values:\n\n```csharp\n//Increase everyone\'s Score by 3 points\ndb.UpdateAdd(() => new Person { Score = 3 }); \n\n//Remove 5 points from Jackson Score\ndb.UpdateAdd(() => new Person { Score = -5 }, where: x => x.LastName == "Jackson");\n\n//Graduate everyone and increase everyone\'s Score by 2 points \ndb.UpdateAdd(() => new Person { Points = 2, Graduated = true });\n\n//Add 10 points to Michael\'s score\nvar q = db.From<Person>()\n    .Where(x => x.FirstName == "Michael");\ndb.UpdateAdd(() => new Person { Points = 10 }, q);\n```\n\n> Note: Any non-numeric values in an `UpdateAdd` statement (e.g. strings) are replaced as normal.\n\n### INSERT\n\nInsert\'s are pretty straight forward since in most cases you want to insert every field:\n\n```csharp\ndb.Insert(new Person { Id = 1, FirstName = "Jimi", LastName = "Hendrix", Age = 27 });\n```\n\n#### Partial Inserts\n\nYou can use `InsertOnly` for the rare cases you don\'t want to insert every field\n\n```csharp\ndb.InsertOnly(() => new Person { FirstName = "Amy" });\n```\n\nAlternative API using an SqlExpression\n\n```csharp\nvar q = db.From<Person>()\n    .Insert(p => new { p.FirstName });\n\ndb.InsertOnly(new Person { FirstName = "Amy" }, onlyFields: q)\n```\n\n### DELETE\n\nLike updates for DELETE\'s we also provide APIs that take a where Expression:\n```csharp\ndb.Delete<Person>(p => p.Age == 27);\n```\n\nOr an SqlExpression:\n\n```csharp\nvar q = db.From<Person>()\n    .Where(p => p.Age == 27);\n\ndb.Delete<Person>(q);\n```\n\nAs well as un-typed, string-based expressions:\n```csharp\ndb.Delete<Person>(where: "Age = @age", new { age = 27 });\n```\n\n#### Delete from Table JOIN\n\nUsing a SqlExpression to delete rows by querying from a joined table:\n\n```csharp\nvar q = db.From<Person>()\n    .Join<PersonJoin>((x, y) => x.Id == y.PersonId)\n    .Where<PersonJoin>(x => x.Id == 2);\n\ndb.Delete(q);\n```\n\n> Not supported in MySql\n\n# API Overview\n\nThe API is minimal, providing basic shortcuts for the primitive SQL statements:\n\n[![OrmLite API](https://raw.githubusercontent.com/ServiceStack/Assets/master/img/ormlite/OrmLiteApi.png)](https://raw.githubusercontent.com/ServiceStack/Assets/master/img/ormlite/OrmLiteApi.png)\n\nOrmLite makes available most of its functionality via extension methods to add enhancments over ADO.NET\'s `IDbConnection`, providing \na Typed RDBMS-agnostic API that transparently handles differences in each supported RDBMS provider.\n\n## Create Tables Schemas\n\nOrmLite is able to **CREATE**, **DROP** and **ALTER** RDBMS Tables from your code-first Data Models with rich annotations for \ncontrolling how the underlying RDBMS Tables are constructed. \n\nThe Example below utilizes several annotations to customize the definition and behavior of RDBMS tables based on a POCOs \n**public properties**:\n\n```csharp\npublic class Player\n{\n    public int Id { get; set; }                     // \'Id\' is PrimaryKey by convention\n\n    [Required]\n    public string FirstName { get; set; }           // Creates NOT NULL Column\n\n    [Alias("Surname")]                              // Maps to [Surname] RDBMS column\n    public string LastName { get; set; }\n\n    [Index(Unique = true)]                          // Creates Unique Index\n    public string Email { get; set; }\n\n    public List<Phone> PhoneNumbers { get; set; }   // Complex Types blobbed by default\n\n    [Reference]\n    public List<GameItem> GameItems { get; set; }   // 1:M Reference Type saved separately\n\n    [Reference]\n    public Profile Profile { get; set; }            // 1:1 Reference Type saved separately\n    public int ProfileId { get; set; }              // 1:1 Self Ref Id on Parent Table\n\n    [ForeignKey(typeof(Level), OnDelete="CASCADE")] // Creates ON DELETE CASCADE Constraint\n    public Guid SavedLevelId { get; set; }          // Creates Foreign Key Reference\n\n    public ulong RowVersion { get; set; }           // Optimistic Concurrency Updates\n}\n\npublic class Phone                                  // Blobbed Type only\n{\n    public PhoneKind Kind { get; set; }\n    public string Number { get; set; }\n    public string Ext { get; set; }\n}\n\npublic enum PhoneKind\n{\n    Home,\n    Mobile,\n    Work,\n}\n\n[Alias("PlayerProfile")]                            // Maps to [PlayerProfile] RDBMS Table\n[CompositeIndex(nameof(Username), nameof(Region))]  // Creates Composite Index\npublic class Profile\n{\n    [AutoIncrement]                                 // Auto Insert Id assigned by RDBMS\n    public int Id { get; set; }\n\n    public PlayerRole Role { get; set; }            // Native support for Enums\n    public Region Region { get; set; }\n    public string Username { get; set; }\n    public long HighScore { get; set; }\n\n    [Default(1)]                                    // Created in RDBMS with DEFAULT (1)\n    public long GamesPlayed { get; set; }\n\n    [CheckConstraint("Energy BETWEEN 0 AND 100")]   // Creates RDBMS Check Constraint\n    public short Energy { get; set; }\n\n    public string ProfileUrl { get; set; }\n    public Dictionary<string, string> Meta { get; set; }\n}\n\npublic enum PlayerRole                              // Enums saved as strings by default\n{\n    Leader,\n    Player,\n    NonPlayer,\n}\n\n[EnumAsInt]                                         // Enum Saved as int\npublic enum Region\n{\n    Africa = 1,\n    Americas = 2,\n    Asia = 3,\n    Australasia = 4,\n    Europe = 5,\n}\n\npublic class GameItem\n{\n    [PrimaryKey]                                    // Specify field to use as Primary Key\n    [StringLength(50)]                              // Creates VARCHAR COLUMN\n    public string Name { get; set; }\n\n    public int PlayerId { get; set; }               // Foreign Table Reference Id\n\n    [StringLength(StringLengthAttribute.MaxText)]   // Creates "TEXT" RDBMS Column \n    public string Description { get; set; }\n\n    [Default(OrmLiteVariables.SystemUtc)]           // Populated with UTC Date by RDBMS\n    public DateTime DateAdded { get; set; }\n}\n\npublic class Level\n{\n    public Guid Id { get; set; }                    // Unique Identifer/GUID Primary Key\n    public byte[] Data { get; set; }                // Saved as BLOB/Binary where possible\n}\n```\n\nWe can drop the existing tables and re-create the above table definitions with:\n\n```csharp\nusing (var db = dbFactory.Open())\n{\n    if (db.TableExists<Level>())\n        db.DeleteAll<Level>();                      // Delete ForeignKey data if exists\n\n    //DROP and CREATE ForeignKey Tables in dependent order\n    db.DropTable<Player>();\n    db.DropTable<Level>();\n    db.CreateTable<Level>();\n    db.CreateTable<Player>();\n\n    //DROP and CREATE tables without Foreign Keys in any order\n    db.DropAndCreateTable<Profile>();\n    db.DropAndCreateTable<GameItem>();\n\n    var savedLevel = new Level\n    {\n        Id = Guid.NewGuid(),\n        Data = new byte[]{ 1, 2, 3, 4, 5 },\n    };\n    db.Insert(savedLevel);\n\n    var player = new Player\n    {\n        Id = 1,\n        FirstName = "North",\n        LastName = "West",\n        Email = "north@west.com",\n        PhoneNumbers = new List<Phone>\n        {\n            new Phone { Kind = PhoneKind.Mobile, Number = "123-555-5555"},\n            new Phone { Kind = PhoneKind.Home,   Number = "555-555-5555", Ext = "123"},\n        },\n        GameItems = new List<GameItem>\n        {\n            new GameItem { Name = "WAND", Description = "Golden Wand of Odyssey"},\n            new GameItem { Name = "STAFF", Description = "Staff of the Magi"},\n        },\n        Profile = new Profile\n        {\n            Username = "north",\n            Role = PlayerRole.Leader,\n            Region = Region.Australasia,\n            HighScore = 100,\n            GamesPlayed = 10,\n            ProfileUrl = "https://www.gravatar.com/avatar/205e460b479e2e5b48aec07710c08d50.jpg",\n            Meta = new Dictionary<string, string>\n            {\n                {"Quote", "I am gamer"}\n            },\n        },\n        SavedLevelId = savedLevel.Id,\n    };\n    db.Save(player, references: true);\n}\n```\n\nThis will add a record in all the above tables with all the Reference data properties automatically populated which we can quickly see\nby selecting the inserted `Player` record and all its referenced data by using [OrmLite\'s Load APIs](#querying-pocos-with-references), e.g:\n\n```csharp\nvar dbPlayer = db.LoadSingleById<Player>(player.Id);\n\ndbPlayer.PrintDump();\n```\n\nWhich uses the [Dump Utils](http://docs.servicestack.net/dump-utils) to quickly display the populated data to the console:\n\n    {\n        Id: 1,\n        FirstName: North,\n        LastName: West,\n        Email: north@west.com,\n        PhoneNumbers: \n        [\n            {\n                Kind: Mobile,\n                Number: 123-555-5555\n            },\n            {\n                Kind: Home,\n                Number: 555-555-5555,\n                Ext: 123\n            }\n        ],\n        GameItems: \n        [\n            {\n                Name: WAND,\n                PlayerId: 1,\n                Description: Golden Wand of Odyssey,\n                DateAdded: 2018-01-17T07:53:45-05:00\n            },\n            {\n                Name: STAFF,\n                PlayerId: 1,\n                Description: Staff of the Magi,\n                DateAdded: 2018-01-17T07:53:45-05:00\n            }\n        ],\n        Profile: \n        {\n            Id: 1,\n            Role: Leader,\n            Region: Australasia,\n            Username: north,\n            HighScore: 100,\n            GamesPlayed: 10,\n            Energy: 0,\n            ProfileUrl: "https://www.gravatar.com/avatar/205e460b479e2e5b48aec07710c08d50.jpg",\n            Meta: \n            {\n                Quote: I am gamer\n            }\n        },\n        ProfileId: 1,\n        SavedLevelId: 7690dfa4d31949ab9bce628c34d1c549,\n        RowVersion: 2\n    }\n\nFeel free to continue expirementing with [this Example Live on Gistlyn](https://gistlyn.com/?gist=840bc7f09292ad5753d07cef6063893e&collection=991db51e44674ad01d3d318b24cf0934).\n\n## Select APIs\n\nIf your SQL doesn\'t start with a **SELECT** statement, it is assumed a WHERE clause is being provided, e.g:\n\n```csharp\nvar tracks = db.Select<Track>("Artist = @artist AND Album = @album",\n    new { artist = "Nirvana", album = "Heart Shaped Box" });\n```\n\nWhich is equivalent to:\n\n```csharp\nvar tracks = db.Select<Track>("SELECT * FROM track WHERE Artist = @artist AND Album = @album", \n    new { artist = "Nirvana", album = "Heart Shaped Box" });\n```\n\nUse `Sql*` APIs for when you want to query custom SQL that is not a SELECT statement, e.g:\n\n```csharp\nvar tracks = db.SqlList<Track>("EXEC GetArtistTracks @artist, @album",\n    new { artist = "Nirvana", album = "Heart Shaped Box" });\n```\n\n**Select** returns multiple records: \n\n```csharp\nList<Track> tracks = db.Select<Track>()\n```\n\n**Single** returns a single record:\n\n```csharp\nTrack track = db.Single<Track>(x => x.RefId == refId)\n```\n\n**Dictionary** returns a Dictionary made from the first two columns:\n\n```csharp\nDictionary<int, string> trackIdNamesMap = db.Dictionary<int, string>(\n    db.From<Track>().Select(x => new { x.Id, x.Name }))\n\nDictionary<int, string> trackIdNamesMap = db.Dictionary<int, string>(\n    "select Id, Name from Track")\n```\n\n**Lookup** returns an `Dictionary<K, List<V>>` made from the first two columns:\n\n```csharp\nDictionary<int, List<string>> albumTrackNames = db.Lookup<int, string>(\n    db.From<Track>().Select(x => new { x.AlbumId, x.Name }))\n\nDictionary<int, List<string>> albumTrackNames = db.Lookup<int, string>(\n    "select AlbumId, Name from Track")\n```\n\n**Column** returns a List of first column values:\n\n```csharp\nList<string> trackNames = db.Column<string>(db.From<Track>().Select(x => x.Name))\n\nList<string> trackNames = db.Column<string>("select Name from Track")\n```\n\n**HashSet** returns a HashSet of distinct first column values:\n\n```csharp    \nHashSet<string> uniqueTrackNames = db.ColumnDistinct<string>(\n    db.From<Track>().Select(x => x.Name))\n\nHashSet<string> uniqueTrackNames = db.ColumnDistinct<string>("select Name from Track")\n```\n\n**Scalar** returns a single scalar value:\n\n```csharp\nvar trackCount = db.Scalar<int>(db.From<Track>().Select(Sql.Count("*")))\n\nvar trackCount = db.Scalar<int>("select count(*) from Track")\n```\n\nAnonymous types passed into **Where** are treated like an **AND** filter:\n\n```csharp\nvar track3 = db.Where<Track>(new { AlbumName = "Throwing Copper", TrackNo = 3 })\n```\n\nSingleById(s), SelectById(s), etc provide strong-typed convenience methods to fetch by a Table\'s **Id** primary key field.\n\n```csharp\nvar track = db.SingleById<Track>(1);\nvar tracks = db.SelectByIds<Track>(new[]{ 1,2,3 });\n```\n\n## Nested Typed Sub SqlExpressions\n\nThe `Sql.In()` API supports nesting and combining of multiple Typed SQL Expressions together \nin a single SQL Query, e.g:\n  \n```csharp\nvar usaCustomerIds = db.From<Customer>(c => c.Country == "USA").Select(c => c.Id);\nvar usaCustomerOrders = db.Select(db.From<Order>()\n    .Where(x => Sql.In(x.CustomerId, usaCustomerIds)));\n``` \n\n### SQL In Expressions\n\n```csharp\ndb.Select<Author>(x => Sql.In(x.City, "London", "Madrid", "Berlin"));\n\nvar cities = new[] { "London", "Madrid", "Berlin" };\ndb.Select<Author>(x => Sql.In(x.City, cities));\n```\n\n### Parametrized IN Values\n\nOrmLite also supports providing collection of values which is automatically split into multiple DB parameters to simplify executing parameterized SQL with multiple IN Values, e.g:\n\n```csharp\nvar ids = new[]{ 1, 2, 3};\nvar results = db.Select<Table>("Id in (@ids)", new { ids });\n\nvar names = new List<string>{ "foo", "bar", "qux" };\nvar results = db.SqlList<Table>("SELECT * FROM Table WHERE Name IN (@names)", new { names });\n```\n\n### Custom SQL using PostgreSQL Arrays\n\nIf using PostgreSQL you can take advantage of its complex Array Types and utilize its [Array Functions and Operators](https://www.postgresql.org/docs/9.6/functions-array.html), e.g:\n\n```csharp\nvar ids = new[]{ 1, 2, 3};\nvar q = Db.From<Table>()\n    .Where("ARRAY[{0}] && ref_ids", ids.Join(","))\nvar results = db.Select(q);\n```\n\nWhen comparing a string collection you can use `SqlInValues` to create a quoted SQL IN list, e.g:\n\n```csharp\nvar q = Db.From<Table>()\n    .Where($"ARRAY[{new SqlInValues(cities).ToSqlInString()}] && cities");\nvar results = db.Select(q);\n```\n\n### Lazy Queries\n\nAPI\'s ending with `Lazy` yield an IEnumerable sequence letting you stream the results without having to map the entire resultset into a disconnected List of POCO\'s first, e.g:\n\n```csharp\nvar lazyQuery = db.SelectLazy<Person>("Age > @age", new { age = 40 });\n// Iterate over a lazy sequence \nforeach (var person in lazyQuery) {\n   //...  \n}\n```\n \n### Save Methods\n \n`Save` and `SaveAll` will Insert if no record with **Id** exists, otherwise it Updates. \n\n`Save` will populate any `[AutoIncrement]` or `[AutoId]` Primary Keys, e.g:\n\n```csharp\ndb.Save(item);\nitem.Id // RDBMS populated Auto Id \n```\n\nAlternatively you can also manually Select and Retrieve the Inserted RDBMS Auto Id in a single query with `Insert` APIs by specifying `selectIdentity:true`:\n\n```csharp\nitem.Id = db.Insert(item, selectIdentity:true);\n```\n\n#### Other examples\n\n```csharp\nvar topVIPs = db.WhereLazy<Person>(new { Age = 27 }).Where(p => IsVip(p)).Take(5)\n```\n\n### Other Notes\n\n - All **Insert**, **Update**, and **Delete** methods take multiple params, while `InsertAll`, `UpdateAll` and `DeleteAll` take IEnumerables.\n - Methods containing the word **Each** return an IEnumerable<T> and are lazily loaded (i.e. non-buffered).\n\n# Features\n\nWhilst OrmLite aims to provide a light-weight typed wrapper around SQL, it offers a number of convenient features that makes working with RDBMS\'s a clean and enjoyable experience:\n\n## Typed SqlExpression support for JOIN\'s\n\nStarting with the most basic example you can simply specify the table you want to join with:\n\n```csharp\nvar q = db.From<Customer>()\n          .Join<CustomerAddress>();\n\nvar dbCustomers = db.Select<Customer>(q);\n```\n\nThis query rougly maps to the following SQL:\n\n```sql\nSELECT Customer.* \n  FROM Customer \n       INNER JOIN \n       CustomerAddress ON (Customer.Id == CustomerAddress.CustomerId)\n```\n\nJust like before `q` is an instance of `SqlExpression<Customer>` which is bounded to the base `Customer` type (and what any subsequent implicit API\'s apply to). \n\nTo better illustrate the above query, lets expand it to the equivalent explicit query:\n\n```csharp\nSqlExpression<Customer> q = db.From<Customer>();\nq.Join<Customer,CustomerAddress>((cust,address) => cust.Id == address.CustomerId);\n\nList<Customer> dbCustomers = db.Select(q);\n```\n\n### Reference Conventions\n\nThe above query implicitly joins together the `Customer` and `CustomerAddress` POCO\'s using the same `{ParentType}Id` property convention used in [OrmLite\'s support for References](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/tests/ServiceStack.OrmLite.Tests/LoadReferencesTests.cs), e.g:\n\n```csharp\nclass Customer {\n    public int Id { get; set; }\n    ...\n}\nclass CustomerAddress {\n    public int Id { get; set; }\n    public int CustomerId { get; set; }  // Reference based on Property name convention\n}\n```\n\nReferences based on matching alias names is also supported, e.g:\n\n```csharp\n[Alias("LegacyCustomer")]\nclass Customer {\n    public int Id { get; set; }\n    ...\n}\nclass CustomerAddress {\n    public int Id { get; set; }\n\n    [Alias("LegacyCustomerId")]             // Matches `LegacyCustomer` Alias\n    public int RenamedCustomerId { get; set; }  // Reference based on Alias Convention\n}\n```\n\n### Self References\n\nSelf References are also supported for **1:1** relations where the Foreign Key can instead be on the parent table:\n\n```csharp\npublic class Customer\n{\n    ...\n    public int CustomerAddressId { get; set; }\n\n    [Reference]\n    public CustomerAddress PrimaryAddress { get; set; }\n}\n```\n\n### Foreign Key and References Attributes\n\nReferences that don\'t follow the above naming conventions can be declared explicitly using\nthe `[References]` and `[ForeignKey]` attributes:\n\n```csharp\npublic class Customer\n{\n    [References(typeof(CustomerAddress))]\n    public int PrimaryAddressId { get; set; }\n\n    [Reference]\n    public CustomerAddress PrimaryAddress { get; set; }\n}\n```\n\n> Reference Attributes take precedence over naming conventions\n\n### Multiple Self References\n\nThe example below shows a customer with multiple `CustomerAddress` references which are able to be matched with \nthe `{PropertyReference}Id` naming convention, e.g:\n\n```csharp\npublic class Customer\n{\n    [AutoIncrement]\n    public int Id { get; set; }\n    public string Name { get; set; }\n\n    [References(typeof(CustomerAddress))]\n    public int? HomeAddressId { get; set; }\n\n    [References(typeof(CustomerAddress))]\n    public int? WorkAddressId { get; set; }\n\n    [Reference]\n    public CustomerAddress HomeAddress { get; set; }\n\n    [Reference]\n    public CustomerAddress WorkAddress { get; set; }\n}\n```\n\nOnce defined, it can be saved and loaded via OrmLite\'s normal Reference and Select API\'s, e.g:\n\n```csharp\nvar customer = new Customer\n{\n    Name = "The Customer",\n    HomeAddress = new CustomerAddress {\n        Address = "1 Home Street",\n        Country = "US"\n    },\n    WorkAddress = new CustomerAddress {\n        Address = "2 Work Road",\n        Country = "UK"\n    },\n};\n\ndb.Save(customer, references:true);\n\nvar c = db.LoadSelect<Customer>(x => x.Name == "The Customer");\nc.WorkAddress.Address.Print(); // 2 Work Road\n\nvar ukAddress = db.Single<CustomerAddress>(x => x.Country == "UK");\nukAddress.Address.Print();     // 2 Work Road\n```\n\n### Implicit Reference Conventions are applied by default\n\nThe implicit relationship above allows you to use any of these equilvalent APIs to JOIN tables:\n\n```csharp\nq.Join<CustomerAddress>();\nq.Join<Customer,CustomerAddress>();\nq.Join<Customer,CustomerAddress>((cust,address) => cust.Id == address.CustomerId);\n```\n\n### Selecting multiple columns across joined tables\n\nThe `SelectMulti` API lets you select from multiple joined tables into a typed tuple\n\n```csharp\nvar q = db.From<Customer>()\n    .Join<Customer, CustomerAddress>()\n    .Join<Customer, Order>()\n    .Where(x => x.CreatedDate >= new DateTime(2016,01,01))\n    .And<CustomerAddress>(x => x.Country == "Australia");\n\nvar results = db.SelectMulti<Customer, CustomerAddress, Order>(q);\n\nforeach (var tuple in results)\n{\n    Customer customer = tuple.Item1;\n    CustomerAddress custAddress = tuple.Item2;\n    Order custOrder = tuple.Item3;\n}\n```\n\nThanks to Micro ORM\'s lightweight abstractions over ADO.NET that maps to clean POCOs, we can also use \nOrmLite\'s embedded version of [Dapper\'s QueryMultiple](http://stackoverflow.com/a/37420341/85785):\n\n```csharp\nvar q = db.From<Customer>()\n    .Join<Customer, CustomerAddress>()\n    .Join<Customer, Order>()\n    .Select("*");\n\nusing (var multi = db.QueryMultiple(q.ToSelectStatement()))\n{\n    var results = multi.Read<Customer, CustomerAddress, Order, \n        Tuple<Customer,CustomerAddress,Order>>(Tuple.Create).ToList();\n\n    foreach (var tuple in results)\n    {\n        Customer customer = tuple.Item1;\n        CustomerAddress custAddress = tuple.Item2;\n        Order custOrder = tuple.Item3;\n    }\n}\n```\n\n### SELECT DISTINCT in SelectMulti\n\n[SelectMulti](https://github.com/ServiceStack/ServiceStack.OrmLite#selecting-multiple-columns-across-joined-tables) APIs for populating\nmultiple tables now supports **SELECT DISTINCT** with:\n\n```csharp\nvar tuples = db.SelectMulti<Customer, CustomerAddress>(q.SelectDistinct());\n```\n\n### Select data from multiple tables into a Custom POCO\n\nAnother implicit behaviour when selecting from a typed SqlExpression is that results are mapped to the \n`Customer` POCO. To change this default we just need to explicitly specify what POCO it should map to instead:\n\n```csharp\nList<FullCustomerInfo> customers = db.Select<FullCustomerInfo>(\n    db.From<Customer>().Join<CustomerAddress>());\n```\n\nWhere `FullCustomerInfo` is any POCO that contains a combination of properties matching any of the joined \ntables in the query. \n\nThe above example is also equivalent to the shorthand `db.Select<Into,From>()` API:\n\n```csharp\nvar q = db.From<Customer>()\n          .Join<CustomerAddress>();\n\nvar customers = db.Select<FullCustomerInfo,Customer>(q);\n```\n\nRules for how results are mapped is simply each property on `FullCustomerInfo` is mapped to the first matching property in any of the tables in the order they were added to the SqlExpression.\n\nThe mapping also includes a fallback for referencing fully-qualified names in the format: `{TableName}{FieldName}` allowing you to reference ambiguous fields, e.g:\n\n  - `CustomerId` => "Customer"."Id"\n  - `OrderId` => "Order"."Id"\n  - `CustomerName` => "Customer"."Name"\n  - `OrderCost` => "Order"."Cost"\n\n## Dynamic Result Sets\n\nIn addition to populating Typed POCOs, OrmLite has a number of flexible options for accessing dynamic resultsets with adhoc schemas:\n\n### C# 7 Value Tuples\n \nThe C# 7 Value Tuple support enables a terse, clean and typed API for accessing the Dynamic Result Sets returned when using a custom Select expression:\n\n```csharp\nvar query = db.From<Employee>()\n    .Join<Department>()\n    .OrderBy(e => e.Id)\n    .Select<Employee, Department>(\n        (e, d) => new { e.Id, e.LastName, d.Name });\n \nvar results = db.Select<(int id, string lastName, string deptName)>(query);\n \nvar row = results[i];\n$"row: ${row.id}, ${row.lastName}, ${row.deptName}".Print();\n```\n \nFull Custom SQL Example:\n \n```csharp\nvar results = db.SqlList<(int count, string min, string max, int sum)>(\n    "SELECT COUNT(*), MIN(Word), MAX(Word), Sum(Total) FROM Table");\n```\n \nPartial Custom SQL Select Example:\n \n```csharp\nvar query = db.From<Table>()\n    .Select("COUNT(*), MIN(Word), MAX(Word), Sum(Total)");\n \nvar result = db.Single<(int count, string min, string max, int sum)>(query);\n```\n \nSame as above, but using Typed APIs:\n \n```csharp\nvar result = db.Single<(int count, string min, string max, int sum)>(\n    db.From<Table>()\n        .Select(x => new {\n            Count = Sql.Count("*"),\n            Min = Sql.Min(x.Word),\n            Max = Sql.Max(x.Word),\n            Sum = Sql.Sum(x.Total)\n        }));\n```\n\nThere\'s also support for returning unstructured resultsets in `List<object>`, e.g:\n\n```csharp\nvar results = db.Select<List<object>>(db.From<Poco>()\n  .Select("COUNT(*), MIN(Id), MAX(Id)"));\n\nresults[0].PrintDump();\n```\n\nOutput of objects in the returned `List<object>`:\n\n    [\n        10,\n        1,\n        10\n    ]\n\nYou can also Select `Dictionary<string,object>` to return a dictionary of column names mapped with their values, e.g:\n\n```csharp\nvar results = db.Select<Dictionary<string,object>>(db.From<Poco>()\n  .Select("COUNT(*) Total, MIN(Id) MinId, MAX(Id) MaxId"));\n\nresults[0].PrintDump();\n```\n\nOutput of objects in the returned `Dictionary<string,object>`:\n\n    {\n        Total: 10,\n        MinId: 1,\n        MaxId: 10\n    }\n\nand can be used for API\'s returning a **Single** row result:\n\n```csharp\nvar result = db.Single<List<object>>(db.From<Poco>()\n  .Select("COUNT(*) Total, MIN(Id) MinId, MAX(Id) MaxId"));\n```\n\nor use `object` to fetch an unknown **Scalar** value:\n\n```csharp\nobject result = db.Scalar<object>(db.From<Poco>().Select(x => x.Id));\n```\n\n### Select data from multiple tables into Dynamic ResultSets\n\nYou can also select data from multiple tables into \n[dynamic result sets](https://github.com/ServiceStack/ServiceStack.OrmLite#dynamic-result-sets)\nwhich provide [several Convenience APIs](http://stackoverflow.com/a/37443162/85785)\nfor accessing data from an unstructured queries.\n\nUsing dynamic:\n\n```csharp\nvar q = db.From<Employee>()\n    .Join<Department>()\n    .Select<Employee, Department>((e, d) => new { e.FirstName, d.Name });\n    \nList<dynamic> results = db.Select<dynamic>(q);\nforeach (dynamic result in results)\n{\n    string firstName = result.FirstName;\n    string deptName = result.Name;\n}\n```\n\nDictionary of Objects:\n\n```csharp\nList<Dictionary<string,object>> rows = db.Select<Dictionary<string,object>>(q);\n```\n\nList of Objects:\n\n```csharp\nList<List<object>> rows = db.Select<Dictionary<string,object>>(q);\n```\n\nCustom Key/Value Dictionary:\n\n```csharp\nDictionary<string,string> rows = db.Dictionary<string,string>(q);\n```\n\n### BelongsTo Attribute\n\nThe `[BelongTo]` attribute can be used for specifying how Custom POCO results are mapped when the resultset is ambiguous, e.g:\n\n```csharp\nclass A { \n    public int Id { get; set; }\n}\nclass B {\n    public int Id { get; set; }\n    public int AId { get; set; }\n}\nclass C {\n    public int Id { get; set; }\n    public int BId { get; set; }\n}\nclass Combined {\n    public int Id { get; set; }\n    [BelongTo(typeof(B))]\n    public int BId { get; set; }\n}\n\nvar q = db.From<A>()\n    .Join<B>()\n    .LeftJoin<B,C>();\n\nvar results = db.Select<Combined>(q); //Combined.BId = B.Id\n```\n\n### Advanced Example\n\nSeeing how the SqlExpression is constructed, joined and mapped, we can take a look at a more advanced example to showcase more of the new API\'s available:\n\n```csharp\nList<FullCustomerInfo> rows = db.Select<FullCustomerInfo>(  // Map results to FullCustomerInfo POCO\n  db.From<Customer>()                                       // Create typed Customer SqlExpression\n    .LeftJoin<CustomerAddress>()                            // Implicit left join with base table\n    .Join<Customer, Order>((c,o) => c.Id == o.CustomerId)   // Explicit join and condition\n    .Where(c => c.Name == "Customer 1")                     // Implicit condition on base table\n    .And<Order>(o => o.Cost < 2)                            // Explicit condition on joined Table\n    .Or<Customer,Order>((c,o) => c.Name == o.LineItem));    // Explicit condition with joined Tables\n```\n\nThe comments next to each line document each Type of API used. Some of the new API\'s introduced in this example include:\n\n  - Usage of `LeftJoin` for specifying a LEFT JOIN, `RightJoin` and `FullJoin` also available\n  - Usage of `And<Table>()`, to specify an **AND** condition on a Joined table \n  - Usage of `Or<Table1,Table2>`, to specify an **OR** condition against 2 joined tables\n\nMore code examples of References and Joined tables are available in:\n\n  - [LoadReferencesTests.cs](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/tests/ServiceStack.OrmLite.Tests/LoadReferencesTests.cs)\n  - [LoadReferencesJoinTests.cs](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/tests/ServiceStack.OrmLite.Tests/LoadReferencesJoinTests.cs)\n\n### Reference Support, POCO style\n\nOrmLite lets you Store and Load related entities in separate tables using `[Reference]` attributes in primary tables in conjunction with `{Parent}Id` property convention in child tables, e.g: \n\n```csharp\npublic class Customer\n{\n    [AutoIncrement]\n    public int Id { get; set; }\n    public string Name { get; set; }\n\n    [Reference] // Save in CustomerAddress table\n    public CustomerAddress PrimaryAddress { get; set; }\n\n    [Reference] // Save in Order table\n    public List<Order> Orders { get; set; }\n}\n\npublic class CustomerAddress\n{\n    [AutoIncrement]\n    public int Id { get; set; }\n    public int CustomerId { get; set; } //`{Parent}Id` convention to refer to Customer\n    public string AddressLine1 { get; set; }\n    public string AddressLine2 { get; set; }\n    public string City { get; set; }\n    public string State { get; set; }\n    public string Country { get; set; }\n}\n\npublic class Order\n{\n    [AutoIncrement]\n    public int Id { get; set; }\n    public int CustomerId { get; set; } //`{Parent}Id` convention to refer to Customer\n    public string LineItem { get; set; }\n    public int Qty { get; set; }\n    public decimal Cost { get; set; }\n}\n```\n\nWith the above structure you can save a POCO and all its entity references with `db.Save(T,references:true)`, e.g:\n\n```csharp\nvar customer =  new Customer {\n    Name = "Customer 1",\n    PrimaryAddress = new CustomerAddress {\n        AddressLine1 = "1 Australia Street",\n        Country = "Australia"\n    },\n    Orders = new[] {\n        new Order { LineItem = "Line 1", Qty = 1, Cost = 1.99m },\n        new Order { LineItem = "Line 2", Qty = 2, Cost = 2.99m },\n    }.ToList(),\n};\n\ndb.Save(customer, references:true);\n```\n\nThis saves the root customer POCO in the `Customer` table, its related PrimaryAddress in the `CustomerAddress` table and its 2 Orders in the `Order` table.\n\n### Querying POCO\'s with References\n\nThe `Load*` API\'s are used to automatically load a POCO and all it\'s child references, e.g:\n\n```csharp\nvar customer = db.LoadSingleById<Customer>(customerId);\n```\n\nUsing Typed SqlExpressions:\n\n```csharp\nvar customers = db.LoadSelect<Customer>(x => x.Name == "Customer 1");\n```\n\nMore examples available in [LoadReferencesTests.cs](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/tests/ServiceStack.OrmLite.Tests/LoadReferencesTests.cs)\n\nUnlike normal complex properties, references:\n\n  - Doesn\'t persist as complex type blobs\n  - Doesn\'t impact normal querying\n  - Saves and loads references independently from itself\n  - Are serializable with Text serializers (only populated are visible).\n  - Loads related data only 1-reference-level deep\n \nBasically they provides a better story when dealing with referential data that doesn\'t impact the POCO\'s ability to be used as DTO\'s. \n\n### Merge Disconnected POCO Result Sets\n\nThe `Merge` extension method can stitch disconnected POCO collections together as per their relationships defined in OrmLite\'s POCO References.\n\nFor example you can select a collection of Customers who\'ve made an order with quantities of 10 or more and in a separate query select their filtered Orders and then merge the results of these 2 distinct queries together with:\n\n```csharp\n//Select Customers who\'ve had orders with Quantities of 10 or more\nvar q = db.From<Customer>()\n          .Join<Order>()\n          .Where<Order>(o => o.Qty >= 10)\n          .SelectDistinct();\n\nList<Customer> customers = db.Select<Customer>(q);\n\n//Select Orders with Quantities of 10 or more\nList<Order> orders = db.Select<Order>(o => o.Qty >= 10);\n\ncustomers.Merge(orders); // Merge disconnected Orders with their related Customers\n\ncustomers.PrintDump();   // Print merged customers and orders datasets\n```\n\n### Custom Load References\n\nYou can selectively specifying which references you want to load using the `include` parameter, e.g:\n\n```csharp\nvar customerWithAddress = db.LoadSingleById<Customer>(customer.Id, include: new[] { "PrimaryAddress" });\n\n//Alternative\nvar customerWithAddress = db.LoadSingleById<Customer>(customer.Id, include: x => new { x.PrimaryAddress });\n```\n\n### Custom Select with JOIN\n\nYou can specify SQL Aliases for ambiguous columns using anonymous properties, e.g:\n\n```csharp\nvar q = db.From<Table>()\n    .Join<JoinedTable>()\n    .Select<Table, JoinedTable>((a, b) => new { a, JoinId = b.Id, JoinName = b.Name });\n```\n\nWhich is roughly equivalent to:\n\n    SELECT a.*, b.Id AS JoinId, b.Name AS JoinName\n\nWhere it selects all columns from the primary `Table` as well as `Id` and `Name` columns from `JoinedTable,` \nreturning them in the `JoinId` and `JoinName` custom aliases.\n\n### Nested JOIN Table Expressions\n\nYou can also query POCO References on JOIN tables, e.g:\n\n```csharp\nvar q = db.From<Table>()\n    .Join<Join1>()\n    .Join<Join1, Join2>()\n    .Where(x => !x.IsValid.HasValue && \n        x.Join1.IsValid &&\n        x.Join1.Join2.Name == theName &&\n        x.Join1.Join2.IntValue == intValue)\n    .GroupBy(x => x.Join1.Join2.IntValue)\n    .Having(x => Sql.Max(x.Join1.Join2.IntValue) != 10)\n    .Select(x => x.Join1.Join2.IntValue);\n```\n\n### Table aliases\n\nThe `TableAlias` APIs lets you specify table aliases when joining same table multiple times together to differentiate from any \nambiguous columns in Queries with multiple self-reference joins, e.g:\n\n```csharp\nvar q = db.From<Page>(db.TableAlias("p1"))\n    .Join<Page>((p1, p2) => \n        p1.PageId == p2.PageId && \n        p2.ActivityId == activityId, db.TableAlias("p2"))\n    .Join<Page,Category>((p2,c) => Sql.TableAlias(p2.Category) == c.Id)\n    .Join<Page,Page>((p1,p2) => Sql.TableAlias(p1.Rank,"p1") < Sql.TableAlias(p2.Rank,"p2"))\n    .Select<Page>(p => new {\n        ActivityId = Sql.TableAlias(p.ActivityId, "p2")\n    });\n\nvar rows = db.Select(q);\n```\n\n### Unique Constraints\n\nIn addition to creating an Index with unique constraints using `[Index(Unique=true)]` you can now use `[Unique]` to enforce a single column should only contain unique values or annotate the class with `[UniqueConstraint]` to specify a composite unique constraint, e.g:\n\n```csharp\n[UniqueConstraint(nameof(PartialUnique1), nameof(PartialUnique2), nameof(PartialUnique3))]\npublic class UniqueTest\n{\n    [AutoIncrement]\n    public int Id { get; set; }\n\n    [Unique]\n    public string UniqueField { get; set; }\n\n    public string PartialUnique1 { get; set; }\n    public string PartialUnique2 { get; set; }\n    public string PartialUnique3 { get; set; }\n}\n```\n\n### Auto populated Guid Ids\n\nSupport for Auto populating `Guid` Primary Keys is available using the `[AutoId]` attribute, e.g:\n\n```csharp\npublic class Table\n{\n    [AutoId]\n    public Guid Id { get; set; }\n}\n```\n\nIn SQL Server it will populate `Id` primary key with `newid()`, in `PostgreSQL` it uses `uuid_generate_v4()` which requires installing the the **uuid-ossp** extension by running the SQL below on each PostgreSQL RDBMS it\'s used on:\n\n    CREATE EXTENSION IF NOT EXISTS "uuid-ossp"\n\nFor all other RDBMS\'s OrmLite will populate the `Id` with `Guid.NewGuid()`. In all RDBMS\'s it will populate the `Id` property on `db.Insert()` or `db.Save()` with the new value, e.g:\n\n```csharp\nvar row = new Table { ... };\ndb.Insert(row);\nrow.Id //= Auto populated with new Guid\n```\n\n### SQL Server 2012 Sequences\n\nThe `[Sequence]` attribute can be used as an alternative to `[AutoIncrement]` for inserting rows with an auto incrementing integer value populated by SQL Server, but instead of needing an `IDENTITY` column it can populate a normal `INT` column from a user-defined Sequence, e.g:\n\n```csharp\npublic class SequenceTest\n{\n    [Sequence("Seq_SequenceTest_Id"), ReturnOnInsert]\n    public int Id { get; set; }\n\n    public string Name { get; set; }\n    public string UserName { get; set; }\n    public string Email { get; set; }\n\n    [Sequence("Seq_Counter")]\n    public int Counter { get; set; }\n}\n\nvar user = new SequenceTest { Name = "me", Email = "me@mydomain.com" };\ndb.Insert(user);\n\nuser.Id //= Populated by next value in "Seq_SequenceTest_Id" SQL Server Sequence\n```\n\nThe new `[ReturnOnInsert]` attribute tells OrmLite which columns to return the values of, in this case it returns the new Sequence value the row was inserted with. Sequences offer more flexibility than `IDENTITY` columns where you can use multiple sequences in a table or have the same sequence shared across multiple tables.\n\nWhen creating tables, OrmLite will also create any missing Sequences automatically so you can continue to have reproducible tests and consistent Startups states that\'s unreliant on external state. But it doesn\'t drop sequences when OrmLite drops the table as they could have other external dependents.\n\nTo be able to use the new sequence support you\'ll need to use an SQL Server dialect greater than SQL Server 2012+, e.g:\n\n```csharp\nvar dbFactory = new OrmLiteConnectionFactory(connString, SqlServer2012Dialect.Provider);\n```\n\n### SQL Server Table Hints\n\nUsing the same JOIN Filter feature OrmLite also lets you add SQL Server Hints on JOIN Table expressions, e.g:\n\n```csharp\nvar q = db.From<Car>()\n    .Join<Car, CarType>((c, t) => c.CarId == t.CarId, SqlServerTableHint.ReadUncommitted);\n```\n\nWhich emits the appropriate SQL Server hints:\n\n```sql\nSELECT "Car"."CarId", "CarType"."CarTypeName" \nFROM "Car" INNER JOIN "CarType" WITH (READUNCOMMITTED) ON ("Car"."CarId" = "CarType"."CarId")\n```\n\n### Custom SqlExpression Filter\n\nThe generated SQL from a Typed `SqlExpression` can also be customized using `.WithSqlFilter()`, e.g:\n\n```csharp\nvar q = db.From<Table>()\n    .Where(x => x.Age == 27)\n    .WithSqlFilter(sql => sql + " option (recompile)");\n\nvar q = db.From<Table>()\n    .Where(x => x.Age == 27)\n    .WithSqlFilter(sql => sql + " WITH UPDLOCK");\n\nvar results = db.Select(q);\n```\n\n## Optimistic Concurrency\n\nOptimistic concurrency can be added to any table by adding the `ulong RowVersion { get; set; }` property, e.g:\n\n```csharp\npublic class Poco\n{\n    ...\n    public ulong RowVersion { get; set; }\n}\n```\n\nRowVersion is implemented efficiently in all major RDBMS\'s, i.e:\n\n - Uses `rowversion` datatype in SqlServer \n - Uses PostgreSql\'s `xmin` system column (no column on table required)\n - Uses UPDATE triggers on MySql, Sqlite and Oracle whose lifetime is attached to Create/Drop tables APIs\n\nDespite their differing implementations each provider works the same way where the `RowVersion` property is populated when the record is selected and only updates the record if the RowVersion matches with what\'s in the database, e.g:\n\n```csharp\nvar rowId = db.Insert(new Poco { Text = "Text" }, selectIdentity:true);\n\nvar row = db.SingleById<Poco>(rowId);\nrow.Text += " Updated";\ndb.Update(row); //success!\n\nrow.Text += "Attempting to update stale record";\n\n//Can\'t update stale record\nAssert.Throws<OptimisticConcurrencyException>(() =>\n    db.Update(row));\n\n//Can update latest version\nvar updatedRow = db.SingleById<Poco>(rowId);  // fresh version\nupdatedRow.Text += "Update Success!";\ndb.Update(updatedRow);\n\nupdatedRow = db.SingleById<Poco>(rowId);\ndb.Delete(updatedRow);                        // can delete fresh version\n```\n\nOptimistic concurrency is only verified on API\'s that update or delete an entire entity, i.e. it\'s not enforced in partial updates. There\'s also an Alternative API available for DELETE\'s:\n\n```csharp\ndb.DeleteById<Poco>(id:updatedRow.Id, rowversion:updatedRow.RowVersion)\n```\n\n### RowVersion Byte Array\n\nTo improve reuse of OrmLite\'s Data Models in Dapper, OrmLite also supports `byte[] RowVersion` which lets you use OrmLite Data Models with `byte[] RowVersion` properties in Dapper queries.\n\n## Conflict Resolution using commandFilter\n\nAn optional `Func<IDbCommand> commandFilter` is available in all `INSERT` and `UPDATE` APIs to allow customization and inspection of the populated `IDbCommand` before it\'s run. \nThis feature is utilized in the [Conflict Resolution Extension methods](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/src/ServiceStack.OrmLite/OrmLiteConflictResolutions.cs) \nwhere you can specify the conflict resolution strategy when a Primary Key or Unique constraint violation occurs:\n\n```csharp\ndb.InsertAll(rows, dbCmd => dbCmd.OnConflictIgnore());\n\n//Equivalent to: \ndb.InsertAll(rows, dbCmd => dbCmd.OnConflict(ConflictResolution.Ignore));\n```\n\nIn this case it will ignore any conflicts that occurs and continue inserting the remaining rows in SQLite, MySql and PostgreSQL, whilst in SQL Server it\'s a NOOP.\n\nSQLite offers [additional fine-grained behavior](https://sqlite.org/lang_conflict.html) that can be specified for when a conflict occurs:\n\n - ROLLBACK\n - ABORT\n - FAIL\n - IGNORE\n - REPLACE\n\n### GetTableNames and GetTableNamesWithRowCounts APIs\n\nAs the queries for retrieving table names can vary amongst different RDBMS\'s, we\'ve abstracted their implementations behind uniform APIs\nwhere you can now get a list of table names and their row counts for all supported RDBMS\'s with:\n\n```csharp\nList<string> tableNames = db.GetTableNames();\n\nList<KeyValuePair<string,long>> tableNamesWithRowCounts = db.GetTableNamesWithRowCounts();\n```\n\n> `*Async` variants also available\n\nBoth APIs can be called with an optional `schema` if you only want the tables for a specific schema.\nIt defaults to using the more efficient RDBMS APIs, which if offered typically returns an approximate estimate of rowcounts in each table. \n\nIf you need exact table row counts, you can specify `live:true`:\n\n```csharp\nvar tablesWithRowCounts = db.GetTableNamesWithRowCounts(live:true);\n```\n\n### Modify Custom Schema\n\nOrmLite provides Typed APIs for modifying Table Schemas that makes it easy to inspect the state of an \nRDBMS Table which can be used to determine what modifications you want on it, e.g:\n\n```csharp\nclass Poco \n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public string Ssn { get; set; }\n}\n\ndb.DropTable<Poco>();\ndb.TableExists<Poco>(); //= false\n\ndb.CreateTable<Poco>(); \ndb.TableExists<Poco>(); //= true\n\ndb.ColumnExists<Poco>(x => x.Ssn); //= true\ndb.DropColumn<Poco>(x => x.Ssn);\ndb.ColumnExists<Poco>(x => x.Ssn); //= false\n```\n\nIn a future version of your Table POCO you can use `ColumnExists` to detect which columns haven\'t been \nadded yet, then use `AddColumn` to add it, e.g:\n\n```csharp\nclass Poco \n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n\n    [Default(0)]\n    public int Age { get; set; }\n}\n\nif (!db.ColumnExists<Poco>(x => x.Age)) //= false\n    db.AddColumn<Poco>(x => x.Age);\n\ndb.ColumnExists<Poco>(x => x.Age); //= true\n```\n\n#### Modify Schema APIs\n\nAdditional Modify Schema APIs available in OrmLite include:\n\n - `AlterTable`\n - `AddColumn`\n - `AlterColumn`\n - `ChangeColumnName`\n - `DropColumn`\n - `AddForeignKey`\n - `DropForeignKey`\n - `CreateIndex`\n - `DropIndex`\n\n### Typed `Sql.Cast()` SQL Modifier\n\nThe `Sql.Cast()` provides a cross-database abstraction for casting columns or expressions in SQL queries, e.g:\n\n```csharp\ndb.Insert(new SqlTest { Value = 123.456 });\n\nvar results = db.Select<(int id, string text)>(db.From<SqlTest>()\n    .Select(x => new {\n        x.Id,\n        text = Sql.Cast(x.Id, Sql.VARCHAR) + " : " + Sql.Cast(x.Value, Sql.VARCHAR) + " : " \n             + Sql.Cast("1 + 2", Sql.VARCHAR) + " string"\n    }));\n\nresults[0].text //= 1 : 123.456 : 3 string\n```\n\n### Typed `Column<T>` and `Table<T>` APIs\n\nYou can use the `Column<T>` and `Table<T>()` methods to resolve the quoted names of a Column or Table within SQL Fragments (taking into account any configured aliases or naming strategies). \n\nUsage Example of the new APIs inside a `CustomJoin()` expression used to join on a custom SELECT expression:\n\n```csharp\nq.CustomJoin($"LEFT JOIN (SELECT {q.Column<Job>(x => x.Id)} ...")\nq.CustomJoin($"LEFT JOIN (SELECT {q.Column<Job>(nameof(Job.Id))} ...")\n\nq.CustomJoin($"LEFT JOIN (SELECT {q.Column<Job>(x => x.Id, tablePrefix:true)} ...")\n//Equivalent to:\nq.CustomJoin($"LEFT JOIN (SELECT {q.Table<Job>()}.{q.Column<Job>(x => x.Id)} ...")\n\nq.Select($"{q.Column<Job>(x => x.Id)} as JobId, {q.Column<Task>(x => x.Id)} as TaskId")\n//Equivalent to:\nq.Select<Job,Task>((j,t) => new { JobId = j.Id, TaskId = t.Id })\n```\n\n### DB Parameter API\'s\n\nTo enable even finer-grained control of parameterized queries we\'ve added new overloads that take a collection of IDbDataParameter\'s:\n\n```csharp\nList<T> Select<T>(string sql, IEnumerable<IDbDataParameter> sqlParams)\nT Single<T>(string sql, IEnumerable<IDbDataParameter> sqlParams)\nT Scalar<T>(string sql, IEnumerable<IDbDataParameter> sqlParams)\nList<T> Column<T>(string sql, IEnumerable<IDbDataParameter> sqlParams)\nIEnumerable<T> ColumnLazy<T>(string sql, IEnumerable<IDbDataParameter> sqlParams)\nHashSet<T> ColumnDistinct<T>(string sql, IEnumerable<IDbDataParameter> sqlParams)\nDictionary<K, List<V>> Lookup<K, V>(string sql, IEnumerable<IDbDataParameter> sqlParams)\nList<T> SqlList<T>(string sql, IEnumerable<IDbDataParameter> sqlParams)\nList<T> SqlColumn<T>(string sql, IEnumerable<IDbDataParameter> sqlParams)\nT SqlScalar<T>(string sql, IEnumerable<IDbDataParameter> sqlParams)\n```\n\n> Including Async equivalents for each of the above Sync API\'s.\n\nThe new API\'s let you execute parameterized SQL with finer-grained control over the `IDbDataParameter` used, e.g:\n\n```csharp\nIDbDataParameter pAge = db.CreateParam("age", 40, dbType:DbType.Int16);\ndb.Select<Person>("SELECT * FROM Person WHERE Age > @pAge", new[] { pAge });\n```\n\nThe new `CreateParam()` extension method above is a useful helper for creating custom IDbDataParameter\'s.\n\n### Customize null values\n\nThe new `OrmLiteConfig.OnDbNullFilter` lets you to replace DBNull values with a custom value, so you could convert all `null` strings to be populated with `"NULL"` using:\n\n```csharp\nOrmLiteConfig.OnDbNullFilter = fieldDef => \n    fieldDef.FieldType == typeof(string)\n        ? "NULL"\n        : null;\n```\n\n### Logging an Introspection\n\nOne way to see what queries OrmLite generates is to enable a **debug** enabled logger, e.g:\n\n```csharp\nLogManager.LogFactory = new ConsoleLogFactory(debugEnabled:true);\n```\n\nWhere it will log the generated SQL and Params OrmLite executes to the Console.\n\n### BeforeExecFilter and AfterExecFilter filters\n\nAn alternative to debug logging which can easily get lost in the noisy stream of other debug messages is to use the `BeforeExecFilter` and `AfterExecFilter` filters where you can inspect executed commands with a custom lambda expression before and after each query is executed. So if one of your a queries are failing you can put a breakpoint in `BeforeExecFilter` to inspect the populated `IDbCommand` object before it\'s executed or use the `.GetDebugString()` extension method for an easy way to print the Generated SQL and DB Params to the Console:\n\n```csharp\nOrmLiteConfig.BeforeExecFilter = dbCmd => Console.WriteLine(dbCmd.GetDebugString());\n\n//OrmLiteConfig.AfterExecFilter = dbCmd => Console.WriteLine(dbCmd.GetDebugString());\n```\n\n### Exec, Result and String Filters\n\nOrmLite\'s core Exec filters makes it possible to inject your own behavior, tracing, profiling, etc.\n\nIt\'s useful in situations like wanting to use SqlServer in production but use an `in-memory` Sqlite database in tests and being able to emulate any missing SQL Server Stored Procedures in code:\n\n```csharp\npublic class MockStoredProcExecFilter : OrmLiteExecFilter\n{\n    public override T Exec<T>(IDbConnection dbConn, Func<IDbCommand, T> filter)\n    {\n        try\n        {\n            return base.Exec(dbConn, filter);\n        }\n        catch (Exception ex)\n        {\n            if (dbConn.GetLastSql() == "exec sp_name @firstName, @age")\n                return (T)(object)new Person { FirstName = "Mocked" };\n            throw;\n        }\n    }\n}\n\nOrmLiteConfig.ExecFilter = new MockStoredProcExecFilter();\n\nusing (var db = OpenDbConnection())\n{\n    var person = db.SqlScalar<Person>("exec sp_name @firstName, @age",\n        new { firstName = "aName", age = 1 });\n\n    person.FirstName.Print(); //Mocked\n}\n```\n\n### CaptureSqlFilter\n\nResults filters makes it trivial to implement the `CaptureSqlFilter` which allows you to capture SQL Statements without running them.\n[CaptureSqlFilter](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/4c56bde197d07cfc78a80be06dd557732ecf68fa/src/ServiceStack.OrmLite/OrmLiteResultsFilter.cs#L321) \nis just a simple Results Filter which can be used to quickly found out what SQL your DB calls generate by surrounding DB access in a using scope, e.g:\n\n```csharp\nusing (var captured = new CaptureSqlFilter())\nusing (var db = OpenDbConnection())\n{\n    db.Where<Person>(new { Age = 27 });\n\n    captured.SqlStatements[0].PrintDump();\n}\n```\n\nEmits the Executed SQL along with any DB Parameters: \n\n    {\n        Sql: "SELECT ""Id"", ""FirstName"", ""LastName"", ""Age"" FROM ""Person"" WHERE ""Age"" = @Age",\n        Parameters: \n        {\n            Age: 27\n        }\n    }\n\n### Replay Exec Filter\n\nOr if you want to do things like executing each operation multiple times, e.g:\n\n```csharp\npublic class ReplayOrmLiteExecFilter : OrmLiteExecFilter\n{\n    public int ReplayTimes { get; set; }\n\n    public override T Exec<T>(IDbConnection dbConn, Func<IDbCommand, T> filter)\n    {\n        var holdProvider = OrmLiteConfig.DialectProvider;\n        var dbCmd = CreateCommand(dbConn);\n        try\n        {\n            var ret = default(T);\n            for (var i = 0; i < ReplayTimes; i++)\n            {\n                ret = filter(dbCmd);\n            }\n            return ret;\n        }\n        finally\n        {\n            DisposeCommand(dbCmd);\n            OrmLiteConfig.DialectProvider = holdProvider;\n        }\n    }\n}\n\nOrmLiteConfig.ExecFilter = new ReplayOrmLiteExecFilter { ReplayTimes = 3 };\n\nusing (var db = OpenDbConnection())\n{\n    db.DropAndCreateTable<PocoTable>();\n    db.Insert(new PocoTable { Name = "Multiplicity" });\n\n    var rowsInserted = db.Count<PocoTable>(x => x.Name == "Multiplicity"); //3\n}\n```\n\n\n## Mockable extension methods\n\nThe Result Filters also lets you easily mock results and avoid hitting the database, typically useful in Unit Testing Services to mock OrmLite API\'s directly instead of using a repository, e.g:\n\n```csharp\nusing (new OrmLiteResultsFilter {\n    PrintSql = true,\n    SingleResult = new Person { \n      Id = 1, FirstName = "Mocked", LastName = "Person", Age = 100 \n    },\n})\n{\n    db.Single<Person>(x => x.Age == 42).FirstName // Mocked\n    db.Single(db.From<Person>().Where(x => x.Age == 42)).FirstName // Mocked\n    db.Single<Person>(new { Age = 42 }).FirstName // Mocked\n    db.Single<Person>("Age = @age", new { age = 42 }).FirstName // Mocked\n}\n```\n\nMore examples showing how to mock different API\'s including support for nesting available in [MockAllApiTests.cs](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/tests/ServiceStack.OrmLite.Tests/MockAllApiTests.cs)\n\n### String Filter\n\nThere\'s also a specific filter for strings available which allows you to apply custom sanitization on String fields, e.g. you can ensure all strings are right trimmed with:\n\n```csharp\nOrmLiteConfig.StringFilter = s => s.TrimEnd();\n\ndb.Insert(new Poco { Name = "Value with trailing   " });\ndb.Select<Poco>().First().Name // "Value with trailing"\n```\n\n## Pluggable Complex Type Serializers\n\nPluggable serialization lets you specify different serialization strategies of Complex Types for each available RDBMS provider, e.g:\n\n```csharp\n//ServiceStack\'s JSON and JSV Format\nSqliteDialect.Provider.StringSerializer = new JsvStringSerializer();       \nPostgreSqlDialect.Provider.StringSerializer = new JsonStringSerializer();\n//.NET\'s XML and JSON DataContract serializers\nSqlServerDialect.Provider.StringSerializer = new DataContractSerializer();\nMySqlDialect.Provider.StringSerializer = new JsonDataContractSerializer();\n//.NET XmlSerializer\nOracleDialect.Provider.StringSerializer = new XmlSerializableSerializer();\n```\nYou can also provide a custom serialization strategy by implementing \n[IStringSerializer](https://github.com/ServiceStack/ServiceStack.Text/blob/master/src/ServiceStack.Text/IStringSerializer.cs).\n\nBy default all dialects use the existing `JsvStringSerializer`, except for PostgreSQL which due to its built-in support for JSON, uses the JSON format by default.  \n\n## Global Insert / Update Filters\n\nSimilar to interceptors in some heavy ORM\'s, Insert and Update filters get fired just before any **INSERT** or **UPDATE** operation using OrmLite\'s typed API\'s (i.e. not dynamic SQL or partial updates using anon types). This functionality can be used for easily auto-maintaining Audit information for your POCO data models, e.g:\n\n```csharp\npublic interface IAudit \n{\n    DateTime CreatedDate { get; set; }\n    DateTime ModifiedDate { get; set; }\n    string ModifiedBy { get; set; }\n}\n\nOrmLiteConfig.InsertFilter = (dbCmd, row) => {\n    if (row is IAudit auditRow)\n        auditRow.CreatedDate = auditRow.ModifiedDate = DateTime.UtcNow;\n};\n\nOrmLiteConfig.UpdateFilter = (dbCmd, row) => {\n    if (row is IAudit auditRow)\n        auditRow.ModifiedDate = DateTime.UtcNow;\n};\n```\n\nWhich will ensure that the `CreatedDate` and `ModifiedDate` fields are populated on every insert and update.\n\n### Validation Example\n\nThe filters can also be used for validation where throwing an exception will prevent the operation and bubble the exception, e.g:\n\n```csharp\nOrmLiteConfig.InsertFilter = OrmLiteConfig.UpdateFilter = (dbCmd, row) => {\n    if (row is IAudit auditRow && auditRow.ModifiedBy == null)\n        throw new ArgumentNullException("ModifiedBy");\n};\n\ntry\n{\n    db.Insert(new AuditTable());\n}\ncatch (ArgumentNullException) {\n   //throws ArgumentNullException\n}\n\ndb.Insert(new AuditTable { ModifiedBy = "Me!" }); //succeeds\n```\n\n## Custom SQL Customizations\n\nA number of new hooks are available to provide more flexibility when creating and dropping your RDBMS tables.\n\n### CustomSelect Attribute\n\nThe new `[CustomSelect]` can be used to define properties you want populated from a Custom SQL Function or \nExpression instead of a normal persisted column, e.g:\n\n```csharp\npublic class Block\n{\n    public int Id { get; set; }\n    public int Width { get; set; }\n    public int Height { get; set; }\n\n    [CustomSelect("Width * Height")]\n    public int Area { get; set; }\n\n    [Default(OrmLiteVariables.SystemUtc)]\n    public DateTime CreatedDate { get; set; }\n\n    [CustomSelect("FORMAT(CreatedDate, \'yyyy-MM-dd\')")]\n    public string DateFormat { get; set; }\n}\n\ndb.Insert(new Block { Id = 1, Width = 10, Height = 5 });\n\nvar block = db.SingleById<Block>(1);\n\nblock.Area.Print(); //= 50\n\nblock.DateFormat.Print(); //= 2016-06-08 (SQL Server)\n```\n\n### Order by dynamic expressions\n\nThe `[CustomSelect]` attribute can be used to populate a property with a dynamic SQL Expression instead of an existing column, e.g:\n\n```csharp\npublic class FeatureRequest\n{\n    public int Id { get; set; }\n    public int Up { get; set; }\n    public int Down { get; set; }\n\n    [CustomSelect("1 + Up - Down")]\n    public int Points { get; set; }\n}\n```\n\nYou can also order by the SQL Expression by referencing the property as you would a normal column. By extension this feature now also works in AutoQuery where you can [select it in a partial result set](http://docs.servicestack.net/autoquery-rdbms#custom-fields) and order the results by using its property name, e.g:\n\n    /features?fields=id,points&orderBy=points\n\n### Custom SQL Fragments\n\nThe `Sql.Custom()` API lets you use raw SQL Fragments in Custom `.Select()` expressions, e.g:\n\n```csharp\nvar q = db.From<Table>()\n    .Select(x => new {\n        FirstName = x.FirstName,\n        LastName = x.LastName,\n        Initials = Sql.Custom("CONCAT(LEFT(FirstName,1), LEFT(LastName,1))")\n    });\n```\n\n### Custom Field Declarations\n\nThe `[CustomField]` attribute can be used for specifying custom field declarations in the generated Create table DDL statements, e.g:\n\n```csharp\npublic class PocoTable\n{\n    public int Id { get; set; }\n\n    [CustomField("CHAR(20)")]\n    public string CharColumn { get; set; }\n\n    [CustomField("DECIMAL(18,4)")]\n    public decimal? DecimalColumn { get; set; }\n\n    [CustomField(OrmLiteVariables.MaxText)]        //= {MAX_TEXT}\n    public string MaxText { get; set; }\n\n    [CustomField(OrmLiteVariables.MaxTextUnicode)] //= {NMAX_TEXT}\n    public string MaxUnicodeText { get; set; }\n}\n\ndb.CreateTable<PocoTable>(); \n```\n\nGenerates and executes the following SQL in SQL Server:\n\n```sql\nCREATE TABLE "PocoTable" \n(\n  "Id" INTEGER PRIMARY KEY, \n  "CharColumn" CHAR(20) NULL, \n  "DecimalColumn" DECIMAL(18,4) NULL, \n  "MaxText" VARCHAR(MAX) NULL, \n  "MaxUnicodeText" NVARCHAR(MAX) NULL \n); \n```\n\n> OrmLite replaces any variable placeholders with the value in each RDBMS DialectProvider\'s `Variables` Dictionary.\n\n#### Pre / Post Custom SQL Hooks when Creating and Dropping tables \n\nPre / Post Custom SQL Hooks allow you to inject custom SQL before and after tables are created or dropped, e.g:\n\n```csharp\n[PostCreateTable("INSERT INTO TableWithSeedData (Name) VALUES (\'Foo\');" +\n                 "INSERT INTO TableWithSeedData (Name) VALUES (\'Bar\');")]\npublic class TableWithSeedData\n{\n    [AutoIncrement]\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n```\n\nWhich like other ServiceStack attributes, can also be added dynamically, e.g:\n\n```csharp\ntypeof(TableWithSeedData)\n    .AddAttributes(new PostCreateTableAttribute(\n        "INSERT INTO TableWithSeedData (Name) VALUES (\'Foo\');" +\n        "INSERT INTO TableWithSeedData (Name) VALUES (\'Bar\');"));\n```\n\nCustom SQL Hooks also allow executing custom SQL before and after a table has been created or dropped, i.e:\n\n```csharp\n[PreCreateTable(runSqlBeforeTableCreated)]\n[PostCreateTable(runSqlAfterTableCreated)]\n[PreDropTable(runSqlBeforeTableDropped)]\n[PostDropTable(runSqlAfterTableDropped)]\npublic class Table {}\n```\n\n### Untyped API support\n\nThe [IUntypedApi](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/src/ServiceStack.OrmLite/IUntypedApi.cs) interface is useful for when you only have access to a late-bound object runtime type which is accessible via `db.CreateTypedApi`, e.g:\n\n```csharp\npublic class BaseClass\n{\n    public int Id { get; set; }\n}\n\npublic class Target : BaseClass\n{\n    public string Name { get; set; }\n}\n\nvar row = (BaseClass)new Target { Id = 1, Name = "Foo" };\n\nvar useType = row.GetType();\nvar typedApi = db.CreateTypedApi(useType);\n\ndb.DropAndCreateTables(useType);\n\ntypedApi.Save(row);\n\nvar typedRow = db.SingleById<Target>(1);\ntypedRow.Name //= Foo\n\nvar updateRow = (BaseClass)new Target { Id = 1, Name = "Bar" };\n\ntypedApi.Update(updateRow);\n\ntypedRow = db.SingleById<Target>(1);\ntypedRow.Name //= Bar\n\ntypedApi.Delete(typedRow, new { Id = 1 });\n\ntypedRow = db.SingleById<Target>(1); //= null\n```\n\n## T4 Template Support\n\n[OrmLite\'s T4 Template](https://github.com/ServiceStack/ServiceStack.OrmLite/tree/master/src/T4) \nare useful in database-first development or when wanting to use OrmLite with an existing\nRDBMS by automatically generating POCO\'s and strong-typed wrappers \nfor executing stored procedures. \n\nOrmLite\'s T4 support can be added via NuGet with:\n\n    PM> Install-Package ServiceStack.OrmLite.T4\n\n## Typed SqlExpressions with Custom SQL APIs\n\nOrmLite\'s Expression support satisfies the most common RDBMS queries with a strong-typed API. \nFor more complex queries you can easily fall back to raw SQL where the Custom SQL API\'s \nlet you to map custom SqlExpressions into different responses:\n\n```csharp\nvar q = db.From<Person>()\n          .Where(x => x.Age < 50)\n          .Select("*");\nList<Person> results = db.SqlList<Person>(q);\n\nList<Person> results = db.SqlList<Person>(\n    "SELECT * FROM Person WHERE Age < @age", new { age=50});\n\nList<string> results = db.SqlColumn<string>(db.From<Person>().Select(x => x.LastName));\nList<string> results = db.SqlColumn<string>("SELECT LastName FROM Person");\n\nHashSet<int> results = db.ColumnDistinct<int>(db.From<Person>().Select(x => x.Age));\nHashSet<int> results = db.ColumnDistinct<int>("SELECT Age FROM Person");\n\nvar q = db.From<Person>()\n          .Where(x => x.Age < 50)\n          .Select(Sql.Count("*"));\nint result = db.SqlScalar<int>(q);\nint result = db.SqlScalar<int>("SELCT COUNT(*) FROM Person WHERE Age < 50");\n```\n\n### Custom Insert and Updates\n\n```csharp\nDb.ExecuteSql("INSERT INTO page_stats (ref_id, fav_count) VALUES (@refId, @favCount)",\n              new { refId, favCount })\n\n//Async:\nDb.ExecuteSqlAsync("UPDATE page_stats SET view_count = view_count + 1 WHERE id = @id", new { id })\n```\n\n### INSERT INTO SELECT\n\nYou can use OrmLite\'s Typed `SqlExpression` to create a subselect expression that you can use to create and execute a \ntyped **INSERT INTO SELECT** `SqlExpression` with:\n\n```csharp\nvar q = db.From<User>()\n    .Where(x => x.UserName == "UserName")\n    .Select(x => new {\n        x.UserName, \n        x.Email, \n        GivenName = x.FirstName, \n        Surname = x.LastName, \n        FullName = x.FirstName + " " + x.LastName\n    });\n\nvar id = db.InsertIntoSelect<CustomUser>(q)\n```\n\n## Stored Procedures using Custom Raw SQL API\'s\n\nThe Raw SQL API\'s provide a convenient way for mapping results of any Custom SQL like\nexecuting Stored Procedures:\n\n```csharp\nList<Poco> results = db.SqlList<Poco>("EXEC GetAnalyticsForWeek 1");\nList<Poco> results = db.SqlList<Poco>(\n    "EXEC GetAnalyticsForWeek @weekNo", new { weekNo = 1 });\n\nList<int> results = db.SqlList<int>("EXEC GetTotalsForWeek 1");\nList<int> results = db.SqlList<int>(\n    "EXEC GetTotalsForWeek @weekNo", new { weekNo = 1 });\n\nint result = db.SqlScalar<int>("SELECT 10");\n```\n\n### Stored Procedures with output params\n\nThe `SqlProc` API provides even greater customization by letting you modify the underlying\nADO.NET Stored Procedure call by returning a prepared `IDbCommand` allowing for \nadvanced customization like setting and retriving OUT parameters, e.g:\n\n```csharp\nstring spSql = @"DROP PROCEDURE IF EXISTS spSearchLetters;\n    CREATE PROCEDURE spSearchLetters (IN pLetter varchar(10), OUT pTotal int)\n    BEGIN\n        SELECT COUNT(*) FROM LetterFrequency WHERE Letter = pLetter INTO pTotal;\n        SELECT * FROM LetterFrequency WHERE Letter = pLetter;\n    END";\n\ndb.ExecuteSql(spSql);\n\nusing (var cmd = db.SqlProc("spSearchLetters", new { pLetter = "C" }))\n{\n    var pTotal = cmd.AddParam("pTotal", direction: ParameterDirection.Output);\n\n    var results = cmd.ConvertToList<LetterFrequency>();\n    var total = pTotal.Value;\n}\n```\n\nAn alternative approach is to use `SqlList` which lets you use a filter to customize a \nStored Procedure or any other command type, e.g:\n\n```csharp\nIDbDataParameter pTotal = null;\nvar results = db.SqlList<LetterFrequency>("spSearchLetters", cmd => {\n        cmd.CommandType = CommandType.StoredProcedure;\n        cmd.AddParam("pLetter", "C");\n        pTotal = cmd.AddParam("pTotal", direction: ParameterDirection.Output);\n    });\nvar total = pTotal.Value;\n```\n\nMore examples can be found in [SqlServerProviderTests](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/tests/ServiceStack.OrmLite.Tests/SqlServerProviderTests.cs).\n\n## Foreign Key attribute for referential actions on Update/Deletes\n\nCreating a foreign key in OrmLite can be done by adding `[References(typeof(ForeignKeyTable))]` on the relation property,\nwhich will result in OrmLite creating the Foreign Key relationship when it creates the DB table with `db.CreateTable<Poco>`.\n\nAdditional fine-grain options and behaviour are available in the `[ForeignKey]` attribute which will let you specify the desired behaviour when deleting or updating related rows in Foreign Key tables. \n\nAn example of a table with the different available options:\n\n```csharp\npublic class TableWithAllCascadeOptions\n{\n\t[AutoIncrement] public int Id { get; set; }\n\t\n\t[References(typeof(ForeignKeyTable1))]\n\tpublic int SimpleForeignKey { get; set; }\n\t\n\t[ForeignKey(typeof(ForeignKeyTable2), OnDelete = "CASCADE", OnUpdate = "CASCADE")]\n\tpublic int? CascadeOnUpdateOrDelete { get; set; }\n\t\n\t[ForeignKey(typeof(ForeignKeyTable3), OnDelete = "NO ACTION")]\n\tpublic int? NoActionOnCascade { get; set; }\n\t\n\t[Default(typeof(int), "17")]\n\t[ForeignKey(typeof(ForeignKeyTable4), OnDelete = "SET DEFAULT")]\n\tpublic int SetToDefaultValueOnDelete { get; set; }\n\t\n\t[ForeignKey(typeof(ForeignKeyTable5), OnDelete = "SET NULL")]\n\tpublic int? SetToNullOnDelete { get; set; }\n}\n```\n\n### System Variables and Default Values\n\nTo provide richer support for non-standard default values, each RDBMS Dialect Provider contains a \n`OrmLiteDialectProvider.Variables` placeholder dictionary for storing common, but non-standard RDBMS functionality. \nWe can use this to declaratively define non-standard default values that works across all supported RDBMS\'s \nlike automatically populating a column with the RDBMS UTC Date when Inserted with a `default(T)` Value: \n\n```csharp\npublic class Poco\n{\n    [Default(OrmLiteVariables.SystemUtc)]  //= {SYSTEM_UTC}\n    public DateTime CreatedTimeUtc { get; set; }\n}\n```\n\nOrmLite variables need to be surrounded with `{}` braces to identify that it\'s a placeholder variable, e.g `{SYSTEM_UTC}`.\n\nThe [ForeignKeyTests](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/tests/ServiceStack.OrmLite.Tests/ForeignKeyAttributeTests.cs)\nshow the resulting behaviour with each of these configurations in more detail.\n\n> Note: Only supported on RDBMS\'s with foreign key/referential action support, e.g. \n[Sql Server](http://msdn.microsoft.com/en-us/library/ms174979.aspx), \n[PostgreSQL](http://www.postgresql.org/docs/9.1/static/ddl-constraints.html),\n[MySQL](http://dev.mysql.com/doc/refman/5.5/en/innodb-foreign-key-constraints.html). Otherwise they\'re ignored.\n\n## Multi nested database connections\n\nWe now support multiple nested database connections so you can now trivially use OrmLite to access multiple databases\non different connections. The `OrmLiteConnectionFactory` class has been extended to support named connections which \nallows you to conveniently define all your db connections when you register it in your IOC and access them with the \nnamed property when you use them.\n\nA popular way of scaling RDBMS\'s is to create a Master / Shard setup where datasets for queries that span entire system\nare kept in the master database, whilst context-specific related data can be kept together in an isolated shard.\nThis feature makes it trivial to maintain multiple separate db shards with a master database in a different RDBMS. \n\nHere\'s an (entire source code) sample of the code needed to define, and populate a Master/Shard setup.\nSqlite can create DB shards on the fly so only the blank SqlServer master database needed to be created out-of-band:\n\n### Sharding 1000 Robots into 10 Sqlite DB shards - referencing each in a Master SqlServer RDBMS\n\n```csharp\npublic class MasterRecord {\n    public Guid Id { get; set; }\n    public int RobotId { get; set; }\n    public string RobotName { get; set; }\n    public DateTime? LastActivated { get; set; }\n}\n\npublic class Robot {\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public bool IsActivated { get; set; }\n    public long CellCount { get; set; }\n    public DateTime CreatedDate { get; set; }\n}\n\nconst int NoOfShards = 10;\nconst int NoOfRobots = 1000;\n\nvar dbFactory = new OrmLiteConnectionFactory(\n    "Data Source=host;Initial Catalog=RobotsMaster;Integrated Security=SSPI",  //Connection String\n    SqlServerDialect.Provider); \n\ndbFactory.Run(db => db.CreateTable<MasterRecord>(overwrite:false));\n\nNoOfShards.Times(i => {\n    var namedShard = "robots-shard" + i;\n    dbFactory.RegisterConnection(namedShard, \n        $"~/App_Data/{shardId}.sqlite".MapAbsolutePath(),                //Connection String\n        SqliteDialect.Provider);\n\t\n\tdbFactory.OpenDbConnection(namedShard).Run(db => db.CreateTable<Robot>(overwrite:false));\n});\n\nvar newRobots = NoOfRobots.Times(i => //Create 1000 Robots\n    new Robot { Id=i, Name="R2D"+i, CreatedDate=DateTime.UtcNow, CellCount=DateTime.Now.ToUnixTimeMs() % 100000 });\n\nforeach (var newRobot in newRobots) \n{\n    using (IDbConnection db = dbFactory.OpenDbConnection()) //Open Connection to Master DB \n    {\n        db.Insert(new MasterRecord { Id = Guid.NewGuid(), RobotId = newRobot.Id, RobotName = newRobot.Name });\n        using (IDbConnection robotShard = dbFactory.OpenDbConnection("robots-shard"+newRobot.Id % NoOfShards)) //Shard\n        {\n            robotShard.Insert(newRobot);\n        }\n    }\n}\n```\n\nUsing the [SQLite Manager](https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/?src=search) Firefox extension\nwe can peek at one of the created shards to see 100 Robots in each shard. This is the dump of `robots-shard0.sqlite`:\n\n![Data dump of Robot Shard #1](http://mono.servicestack.net/files/robots-shard0.png)\n\nAs expected each shard has every 10th robot inside.\n\n## Code-first Customer & Order example with complex types on POCO as text blobs\n\nBelow is a complete stand-alone example. No other config or classes is required for it to run. It\'s also available as a \n[stand-alone unit test](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/tests/ServiceStack.OrmLite.Tests/UseCase/CustomerOrdersUseCase.cs).\n\n```csharp\npublic enum PhoneType {\n    Home,\n    Work,\n    Mobile,\n}\n\npublic enum AddressType {\n    Home,\n    Work,\n    Other,\n}\n\npublic class Address {\n    public string Line1 { get; set; }\n    public string Line2 { get; set; }\n    public string ZipCode { get; set; }\n    public string State { get; set; }\n    public string City { get; set; }\n    public string Country { get; set; }\n}\n\npublic class Customer {\n    public Customer() {\n        this.PhoneNumbers = new Dictionary<PhoneType, string>();\n        this.Addresses = new Dictionary<AddressType, Address>();\n    }\n\n    [AutoIncrement] // Creates Auto primary key\n    public int Id { get; set; }\n    \n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    \n    [Index(Unique = true)] // Creates Unique Index\n    public string Email { get; set; }\n    \n    public Dictionary<PhoneType, string> PhoneNumbers { get; set; }  //Blobbed\n    public Dictionary<AddressType, Address> Addresses { get; set; }  //Blobbed\n    public DateTime CreatedAt { get; set; }\n}\n\npublic class Order {\n    \n    [AutoIncrement]\n    public int Id { get; set; }\n    \n    [References(typeof(Customer))]      //Creates Foreign Key\n    public int CustomerId { get; set; }\n    \n    [References(typeof(Employee))]      //Creates Foreign Key\n    public int EmployeeId { get; set; }\n    \n    public Address ShippingAddress { get; set; } //Blobbed (no Address table)\n    \n    public DateTime? OrderDate { get; set; }\n    public DateTime? RequiredDate { get; set; }\n    public DateTime? ShippedDate { get; set; }\n    public int? ShipVia { get; set; }\n    public decimal Freight { get; set; }\n    public decimal Total { get; set; }\n}\n\npublic class OrderDetail {\n    \n    [AutoIncrement]\n    public int Id { get; set; }\n    \n    [References(typeof(Order))] //Creates Foreign Key\n    public int OrderId { get; set; }\n    \n    public int ProductId { get; set; }\n    public decimal UnitPrice { get; set; }\n    public short Quantity { get; set; }\n    public decimal Discount { get; set; }\n}\n\npublic class Employee {\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\npublic class Product {\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public decimal UnitPrice { get; set; }\n}\n\n//Setup SQL Server Connection Factory\nvar dbFactory = new OrmLiteConnectionFactory(\n\t@"Data Source=.\\SQLEXPRESS;AttachDbFilename=|DataDirectory|\\App_Data\\Database1.mdf;Integrated Security=True;User Instance=True",\n\tSqlServerDialect.Provider);\n\n//Use in-memory Sqlite DB instead\n//var dbFactory = new OrmLiteConnectionFactory(\n//    ":memory:", false, SqliteDialect.Provider);\n\n//Non-intrusive: All extension methods hang off System.Data.* interfaces\nusing (IDbConnection db = Config.OpenDbConnection())\n{\n  //Re-Create all table schemas:\n  db.DropTable<OrderDetail>();\n  db.DropTable<Order>();\n  db.DropTable<Customer>();\n  db.DropTable<Product>();\n  db.DropTable<Employee>();\n\n  db.CreateTable<Employee>();\n  db.CreateTable<Product>();\n  db.CreateTable<Customer>();\n  db.CreateTable<Order>();\n  db.CreateTable<OrderDetail>();\n\n  db.Insert(new Employee { Id = 1, Name = "Employee 1" });\n  db.Insert(new Employee { Id = 2, Name = "Employee 2" });\n  var product1 = new Product { Id = 1, Name = "Product 1", UnitPrice = 10 };\n  var product2 = new Product { Id = 2, Name = "Product 2", UnitPrice = 20 };\n  db.Save(product1, product2);\n\n  var customer = new Customer {\n      FirstName = "Orm",\n      LastName = "Lite",\n      Email = "ormlite@servicestack.net",\n      PhoneNumbers =\n      {\n          { PhoneType.Home, "555-1234" },\n          { PhoneType.Work, "1-800-1234" },\n          { PhoneType.Mobile, "818-123-4567" },\n      },\n      Addresses =\n      {\n          { AddressType.Work, new Address { \n            Line1 = "1 Street", Country = "US", State = "NY", City = "New York", ZipCode = "10101" } \n          },\n      },\n      CreatedAt = DateTime.UtcNow,\n  };\n\n  var customerId = db.Insert(customer, selectIdentity: true); //Get Auto Inserted Id\n  customer = db.Single<Customer>(new { customer.Email }); //Query\n  Assert.That(customer.Id, Is.EqualTo(customerId));\n\n  //Direct access to System.Data.Transactions:\n  using (IDbTransaction trans = db.OpenTransaction(IsolationLevel.ReadCommitted))\n  {\n      var order = new Order {\n          CustomerId = customer.Id,\n          EmployeeId = 1,\n          OrderDate = DateTime.UtcNow,\n          Freight = 10.50m,\n          ShippingAddress = new Address { \n            Line1 = "3 Street", Country = "US", State = "NY", City = "New York", ZipCode = "12121" },\n      };\n      db.Save(order); //Inserts 1st time\n\n      //order.Id populated on Save().\n\n      var orderDetails = new[] {\n          new OrderDetail {\n              OrderId = order.Id,\n              ProductId = product1.Id,\n              Quantity = 2,\n              UnitPrice = product1.UnitPrice,\n          },\n          new OrderDetail {\n              OrderId = order.Id,\n              ProductId = product2.Id,\n              Quantity = 2,\n              UnitPrice = product2.UnitPrice,\n              Discount = .15m,\n          }\n      };\n\n      db.Save(orderDetails);\n\n      order.Total = orderDetails.Sum(x => x.UnitPrice * x.Quantity * x.Discount) + order.Freight;\n\n      db.Save(order); //Updates 2nd Time\n\n      trans.Commit();\n  }\n}\n```\n\nRunning this against a SQL Server database will yield the results below:\n\n[![SQL Server Management Studio results](http://mono.servicestack.net/files/ormlite-example.png)](http://www.servicestack.net/files/ormlite-example.png)\n\nNotice the POCO types are stored in the [very fast](http://mono.servicestack.net/mythz_blog/?p=176) \nand [Versatile](http://mono.servicestack.net/mythz_blog/?p=314) \n[JSV Format](https://github.com/ServiceStack/ServiceStack.Text/wiki/JSV-Format) which although hard to do - \nis actually more compact, human and parser-friendly than JSON :)\n\n### Ignoring DTO Properties\n\nYou may use the `[Ignore]` attribute to denote DTO properties that are not fields in the table. This will force the SQL generation to ignore that property.\n\n# More Examples \n\nIn its simplest useage, OrmLite can persist any POCO type without any attributes required:\n\n```csharp\npublic class SimpleExample\n{\n\tpublic int Id { get; set; }\n\tpublic string Name { get; set; }\n}\n\n//Set once before use (i.e. in a static constructor).\nOrmLiteConfig.DialectProvider = SqliteDialect.Provider;\n\nusing (IDbConnection db = "/path/to/db.sqlite".OpenDbConnection())\n{\n\tdb.CreateTable<SimpleExample>(true);\n\tdb.Insert(new SimpleExample { Id=1, Name="Hello, World!"});\n\tvar rows = db.Select<SimpleExample>();\n\n\tAssert.That(rows, Has.Count(1));\n\tAssert.That(rows[0].Id, Is.EqualTo(1));\n}\n```\n\nTo get a better idea of the features of OrmLite lets walk through a complete example using sample tables from the Northwind database. \n_ (Full source code for this example is [available here](https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/tests/ServiceStack.OrmLite.Tests/ShippersExample.cs).) _\n\nSo with no other configuration using only the classes below:\n\n```csharp\n[Alias("Shippers")]\npublic class Shipper\n\t: IHasId<int>\n{\n\t[AutoIncrement]\n\t[Alias("ShipperID")]\n\tpublic int Id { get; set; }\n\n\t[Required]\n\t[Index(Unique = true)]\n\t[StringLength(40)]\n\tpublic string CompanyName { get; set; }\n\n\t[StringLength(24)]\n\tpublic string Phone { get; set; }\n\n\t[References(typeof(ShipperType))]\n\tpublic int ShipperTypeId { get; set; }\n}\n\n[Alias("ShipperTypes")]\npublic class ShipperType\n\t: IHasId<int>\n{\n\t[AutoIncrement]\n\t[Alias("ShipperTypeID")]\n\tpublic int Id { get; set; }\n\n\t[Required]\n\t[Index(Unique = true)]\n\t[StringLength(40)]\n\tpublic string Name { get; set; }\n}\n\npublic class SubsetOfShipper\n{\n\tpublic int ShipperId { get; set; }\n\tpublic string CompanyName { get; set; }\n}\n\npublic class ShipperTypeCount\n{\n\tpublic int ShipperTypeId { get; set; }\n\tpublic int Total { get; set; }\n}\n```\n\n### Creating tables \nCreating tables is a simple 1-liner:\n\n```csharp\nusing (IDbConnection db = ":memory:".OpenDbConnection())\n{\n    db.CreateTable<ShipperType>();\n    db.CreateTable<Shipper>();\n}\n\n/* In debug mode the line above prints:\nDEBUG: CREATE TABLE "ShipperTypes" \n(\n  "ShipperTypeID" INTEGER PRIMARY KEY AUTOINCREMENT, \n  "Name" VARCHAR(40) NOT NULL \n);\nDEBUG: CREATE UNIQUE INDEX uidx_shippertypes_name ON "ShipperTypes" ("Name" ASC);\nDEBUG: CREATE TABLE "Shippers" \n(\n  "ShipperID" INTEGER PRIMARY KEY AUTOINCREMENT, \n  "CompanyName" VARCHAR(40) NOT NULL, \n  "Phone" VARCHAR(24) NULL, \n  "ShipperTypeId" INTEGER NOT NULL, \n\n  CONSTRAINT "FK_Shippers_ShipperTypes" FOREIGN KEY ("ShipperTypeId") REFERENCES "ShipperTypes" ("ShipperID") \n);\nDEBUG: CREATE UNIQUE INDEX uidx_shippers_companyname ON "Shippers" ("CompanyName" ASC);\n*/\n```\n\n### Transaction Support\n\nAs we have direct access to IDbCommand and friends - playing with transactions is easy:\n\n```csharp\nvar trainsType = new ShipperType { Name = "Trains" };\nvar planesType = new ShipperType { Name = "Planes" };\n\n//Playing with transactions\nusing (IDbTransaction dbTrans = db.OpenTransaction())\n{\n    db.Save(trainsType);\n    db.Save(planesType);\n\n    dbTrans.Commit();\n}\n\nusing (IDbTransaction dbTrans = db.OpenTransaction(IsolationLevel.ReadCommitted))\n{\n    db.Insert(new ShipperType { Name = "Automobiles" });\n    Assert.That(db.Select<ShipperType>(), Has.Count.EqualTo(3));\n}\nAssert.That(db.Select<ShipperType>(), Has.Count(2));\n```\n\n### CRUD Operations \nNo ORM is complete without the standard crud operations:\n\n```csharp\n\t//Performing standard Insert\'s and Selects\n  db.Insert(new Shipper { CompanyName = "Trains R Us", Phone = "555-TRAINS", ShipperTypeId = trainsType.Id });\n  db.Insert(new Shipper { CompanyName = "Planes R Us", Phone = "555-PLANES", ShipperTypeId = planesType.Id });\n  db.Insert(new Shipper { CompanyName = "We do everything!", Phone = "555-UNICORNS", ShipperTypeId = planesType.Id });\n\n  var trainsAreUs = db.Single<Shipper>("ShipperTypeId = @Id", new { trainsType.Id });\n  Assert.That(trainsAreUs.CompanyName, Is.EqualTo("Trains R Us"));\n  Assert.That(db.Select<Shipper>("CompanyName = @company OR Phone = @phone", \n        new { company = "Trains R Us", phone = "555-UNICORNS" }), Has.Count.EqualTo(2));\n  Assert.That(db.Select<Shipper>("ShipperTypeId = @Id", new { planesType.Id }), Has.Count.EqualTo(2));\n\n  //Lets update a record\n  trainsAreUs.Phone = "666-TRAINS";\n  db.Update(trainsAreUs);\n          Assert.That(db.SingleById<Shipper>(trainsAreUs.Id).Phone, Is.EqualTo("666-TRAINS"));\n  \n  //Then make it dissappear\n  db.Delete(trainsAreUs);\n          Assert.That(db.SingleById<Shipper>(trainsAreUs.Id), Is.Null);\n\n  //And bring it back again\n  db.Insert(trainsAreUs);\n```\n\n### Performing custom queries \n\nAnd with access to raw sql when you need it - the database is your oyster :)\n\n```csharp\nvar partialColumns = db.Select<SubsetOfShipper>(typeof(Shipper), \n    "ShipperTypeId = @Id", new { planesType.Id });\nAssert.That(partialColumns, Has.Count.EqualTo(2));\n\n//Select into another POCO class that matches sql\nvar rows = db.Select<ShipperTypeCount>(\n    "SELECT ShipperTypeId, COUNT(*) AS Total FROM Shippers GROUP BY ShipperTypeId ORDER BY COUNT(*)");\n\nAssert.That(rows, Has.Count.EqualTo(2));\nAssert.That(rows[0].ShipperTypeId, Is.EqualTo(trainsType.Id));\nAssert.That(rows[0].Total, Is.EqualTo(1));\nAssert.That(rows[1].ShipperTypeId, Is.EqualTo(planesType.Id));\nAssert.That(rows[1].Total, Is.EqualTo(2));\n\n\n//And finally lets quickly clean up the mess we\'ve made:\ndb.DeleteAll<Shipper>();\ndb.DeleteAll<ShipperType>();\n\nAssert.That(db.Select<Shipper>(), Has.Count.EqualTo(0));\nAssert.That(db.Select<ShipperType>(), Has.Count.EqualTo(0));\n```\n\n### Soft Deletes\n\nSelect Filters let you specify a custom `SelectFilter` that lets you modify queries that use `SqlExpression<T>` before they\'re executed. This could be used to make working with "Soft Deletes" Tables easier where it can be made to apply a custom `x.IsDeleted != true` condition on every `SqlExpression`.\n\nBy either using a `SelectFilter` on concrete POCO Table Types, e.g:\n\n```csharp\nSqlExpression<Table1>.SelectFilter = q => q.Where(x => x.IsDeleted != true);\nSqlExpression<Table2>.SelectFilter = q => q.Where(x => x.IsDeleted != true);\n```\n\nOr alternatively using generic delegate that applies to all SqlExpressions, but you\'ll only have access to a \n`IUntypedSqlExpression` which offers a limited API surface area but will still let you execute a custom filter \nfor all `SqlExpression<T>` that could be used to add a condition for all tables implementing a custom \n`ISoftDelete` interface with:\n\n```csharp\nOrmLiteConfig.SqlExpressionSelectFilter = q =>\n{\n    if (q.ModelDef.ModelType.HasInterface(typeof(ISoftDelete)))\n    {\n        q.Where<ISoftDelete>(x => x.IsDeleted != true);\n    }\n};\n```\n\nBoth solutions above will transparently add the `x.IsDeleted != true` to all `SqlExpression<T>` based queries\nso it only returns results which aren\'t `IsDeleted` from any of queries below:\n\n```csharp\nvar results = db.Select(db.From<Table>());\nvar result = db.Single(db.From<Table>().Where(x => x.Name == "foo"));\nvar result = db.Single(x => x.Name == "foo");\n```\n\n### Check Constraints\n\nOrmLite includes support for [SQL Check Constraints](https://en.wikipedia.org/wiki/Check_constraint) which will create your Table schema with the `[CheckConstraint]` specified, e.g:\n\n```csharp\npublic class Table\n{\n    [AutoIncrement]\n    public int Id { get; set; }\n\n    [Required]\n    [CheckConstraint("Age > 1")]\n    public int Age { get; set; }\n\n    [CheckConstraint("Name IS NOT NULL")]\n    public string Name { get; set; }\n}\n```\n\n### Bitwise operators\n\nThe Typed SqlExpression bitwise operations support depends on the RDBMS used.\n\nE.g. all RDBMS\'s support Bitwise `And` and `Or` operators:\n\n```csharp\ndb.Select<Table>(x => (x.Flags | 2) == 3);\ndb.Select<Table>(x => (x.Flags & 2) == 2);\n```\n\nAll RDBMS Except for SQL Server support bit shift operators:\n\n```csharp\ndb.Select<Table>(x => (x.Flags << 1) == 4);\ndb.Select<Table>(x => (x.Flags >> 1) == 1);\n```\n\nWhilst only SQL Server and MySQL Support Exclusive Or:\n\n```csharp\ndb.Select<Table>(x => (x.Flags ^ 2) == 3);\n```\n\n## SQL Server Features\n\n### Memory Optimized Tables\n\nOrmLite allows access to many advanced SQL Server features including \n[Memory-Optimized Tables](https://msdn.microsoft.com/en-us/library/dn133165.aspx) where you can tell \nSQL Server to maintain specific tables in Memory using the `[SqlServerMemoryOptimized]` attribute, e.g:\n\n```csharp\n[SqlServerMemoryOptimized(SqlServerDurability.SchemaOnly)]\npublic class SqlServerMemoryOptimizedCacheEntry : ICacheEntry\n{\n    [PrimaryKey]\n    [StringLength(StringLengthAttribute.MaxText)]\n    [SqlServerBucketCount(10000000)]\n    public string Id { get; set; }\n    [StringLength(StringLengthAttribute.MaxText)]\n    public string Data { get; set; }\n    public DateTime CreatedDate { get; set; }\n    public DateTime? ExpiryDate { get; set; }\n    public DateTime ModifiedDate { get; set; }\n}\n```\n\nThe `[SqlServerBucketCount]` attribute can be used to \n[configure the bucket count for a hash index](https://msdn.microsoft.com/en-us/library/mt706517.aspx#configuring_bucket_count)\nwhilst the new `[SqlServerCollate]` attribute can be used to specify an SQL Server collation.\n\n## PostgreSQL Features\n\n### PostgreSQL Rich Data Types\n\nThe `[PgSql*]` specific attributes lets you use attributes to define PostgreSQL rich data types, e.g:\n\n```csharp\npublic class MyPostgreSqlTable\n{\n    [PgSqlJson]\n    public List<Poco> AsJson { get; set; }\n\n    [PgSqlJsonB]\n    public List<Poco> AsJsonB { get; set; }\n\n    [PgSqlTextArray]\n    public string[] AsTextArray { get; set; }\n\n    [PgSqlIntArray]\n    public int[] AsIntArray { get; set; }\n\n    [PgSqlBigIntArray]\n    public long[] AsLongArray { get; set; }\n}\n```\n\nBy default all arrays of .NET\'s built-in **numeric**, **string** and **DateTime** types will be stored in PostgreSQL array types:\n\n```csharp\npublic class Table\n{\n    public Guid Id { get; set; }\n\n    public int[] Ints { get; set; }\n    public long[] Longs { get; set; }\n    public float[] Floats { get; set; }\n    public double[] Doubles { get; set; }\n    public decimal[] Decimals { get; set; }\n    public string[] Strings { get; set; }\n    public DateTime[] DateTimes { get; set; }\n    public DateTimeOffset[] DateTimeOffsets { get; set; }\n}\n```\n\nYou can opt-in to annotate other collections like `List<T>` to also be stored in array types by annotating them with `[Pgsql*]` attributes, e.g:\n\n```csharp\npublic class Table\n{\n    public Guid Id { get; set; }\n\n    [PgSqlIntArray]\n    public List<int> ListInts { get; set; }\n    [PgSqlBigIntArray]\n    public List<long> ListLongs { get; set; }\n    [PgSqlFloatArray]\n    public List<float> ListFloats { get; set; }\n    [PgSqlDoubleArray]\n    public List<double> ListDoubles { get; set; }\n    [PgSqlDecimalArray]\n    public List<decimal> ListDecimals { get; set; }\n    [PgSqlTextArray]\n    public List<string> ListStrings { get; set; }\n    [PgSqlTimestamp]\n    public List<DateTime> ListDateTimes { get; set; }\n    [PgSqlTimestampTz]\n    public List<DateTimeOffset> ListDateTimeOffsets { get; set; }\n}\n```\n\nAlternatively if you **always** want `List<T>` stored in Array types, you can register them in the `PostgreSqlDialect.Provider`:\n\n```csharp\nPostgreSqlDialect.Provider.RegisterConverter<List<string>>(new PostgreSqlStringArrayConverter());\nPostgreSqlDialect.Provider.RegisterConverter<List<int>>(new PostgreSqlIntArrayConverter());\nPostgreSqlDialect.Provider.RegisterConverter<List<long>>(new PostgreSqlLongArrayConverter());\nPostgreSqlDialect.Provider.RegisterConverter<List<float>>(new PostgreSqlFloatArrayConverter());\nPostgreSqlDialect.Provider.RegisterConverter<List<double>>(new PostgreSqlDoubleArrayConverter());\nPostgreSqlDialect.Provider.RegisterConverter<List<decimal>>(new PostgreSqlDecimalArrayConverter());\nPostgreSqlDialect.Provider.RegisterConverter<List<DateTime>>(new PostgreSqlDateTimeTimeStampArrayConverter());\nPostgreSqlDialect.Provider.RegisterConverter<List<DateTimeOffset>>(new PostgreSqlDateTimeOffsetTimeStampTzArrayConverter());\n```\n\n### Hstore support\n\nTo use `hstore`, its extension needs to be enabled in your PostgreSQL RDBMS by running:\n\n    CREATE EXTENSION hstore;\n\nWhich can then be enabled in OrmLite with:\n\n```csharp\nPostgreSqlDialect.Instance.UseHstore = true;\n```\n\nWhere it will now store **string Dictionaries** in `Hstore` columns:\n\n```csharp\npublic class TableHstore\n{\n    public int Id { get; set; }\n\n    public Dictionary<string,string> Dictionary { get; set; }\n    public IDictionary<string,string> IDictionary { get; set; }\n}\n\ndb.DropAndCreateTable<TableHstore>();\n\ndb.Insert(new TableHstore\n{\n    Id = 1,\n    Dictionary = new Dictionary<string, string> { {"A", "1"} },\n    IDictionary = new Dictionary<string, string> { {"B", "2"} },\n});\n```\n\nWhere they can than be queried in postgres using [Hstore SQL Syntax](https://www.postgresql.org/docs/9.0/hstore.html):\n\n```csharp\ndb.Single(db.From<PostgreSqlTypes>().Where("dictionary -> \'A\' = \'1\'")).Id //= 1\n```\n\nThanks to [@cthames](https://forums.servicestack.net/users/cthames/activity) for this feature.\n\n### JSON data types\n\nIf you instead wanted to store arbitrary complex types in PostgreSQL\'s rich column types to enable deep querying in postgres, \nyou\'d instead annotate them with `[PgSqlJson]` or `[PgSqlJsonB]`, e.g:\n\n```csharp\npublic class TableJson\n{\n    public int Id { get; set; }\n\n    [PgSqlJson]\n    public ComplexType ComplexTypeJson { get; set; }\n\n    [PgSqlJsonB]\n    public ComplexType ComplexTypeJsonb { get; set; }\n}\n\ndb.Insert(new TableJson\n{\n    Id = 1,\n    ComplexTypeJson = new ComplexType {\n        Id = 2, SubType = new SubType { Name = "JSON" }\n    },\n    ComplexTypeJsonb = new ComplexType {\n        Id = 3, SubType = new SubType { Name = "JSONB" }\n    },\n});\n```\n\nWhere they can then be queried on the server with [JSON SQL Syntax and functions](https://www.postgresql.org/docs/9.3/functions-json.html):\n\n```csharp\nvar result = db.Single<TableJson>("table_json->\'SubType\'->>\'Name\' = \'JSON\'");\n```\n\n# Limitations \n\n### Single Primary Key\n\nFor simplicity, and to be able to have the same POCO class persisted in db4o, memcached, redis or on the filesystem (i.e. providers included in ServiceStack), each model must have a single primary key, by convention OrmLite expects it\nto be `Id` although you use `[Alias("DbFieldName")]` attribute it map it to a column with a different name or use \nthe `[PrimaryKey]` attribute to tell OrmLite to use a different property for the primary key.\n\nYou can still `SELECT` from these tables, you will just be unable to make use of APIs that rely on it, e.g. \n`Update` or `Delete` where the filter is implied (i.e. not specified), all the APIs that end with `ById`, etc.\n\n### Optimize LIKE Searches\n\nOne of the primary goals of OrmLite is to expose and RDBMS agnostic Typed API Surface which will allow you\nto easily switch databases, or access multiple databases at the same time with the same behavior.\n\nOne instance where this can have an impact is needing to use `UPPER()` in **LIKE** searches to enable \ncase-insensitive **LIKE** queries across all RDBMS. The drawback of this is that LIKE Queries are not able \nto use any existing RDBMS indexes. We can disable this feature and return to the default RDBMS behavior with:\n\n```csharp\nOrmLiteConfig.StripUpperInLike = true;\n```\n\nAllowing all **LIKE** Searches in OrmLite or AutoQuery to use any available RDBMS Index.\n\n## Oracle Provider Notes\n\nBy default the Oracle provider stores Guids in the database as character strings and when generating SQL it quotes only table and column names that are reserved words in Oracle. That requires that you use the same quoting if you code your own SQL. Both of these options can be overridden, but overriding them will cause problems: the provider can store Guids as raw(16) but it cannot read them.\n\nThe Oracle provider uses Oracle sequences to implement AutoIncrement columns and it queries the sequence to get a new value in a separate database call. You can override the automatically generated sequence name with a\n\n  [Sequence("name")]\n\nattribute on a field. The Sequence attribute implies [AutoIncrement], but you can use both on the same field.\n\nSince Oracle has a very restrictive 30 character limit on names, it is strongly suggested that you use short entity class and field names or aliases, remembering that indexes and foreign keys get compound names. If you use long names, the provider will squash them to make them compliant with the restriction. The algorithm used is to remove all vowels ("aeiouy") and if still too long then every fourth letter starting with the third one and finally if still too long to truncate the name. You must apply the same squashing algorithm if you are coding your own SQL.  \n\nThe previous version of ServiceStack.OrmLite.Oracle used System.Data.OracleClient to talk to the database. Microsoft has deprecated that client, but it does still mostly work if you construct the Oracle provider like this:\n\n    OracleOrmLiteDialectProvider.Instance = new OracleOrmLiteDialectProvider(\n    compactGuid: false,\n    quoteNames: false,\n    clientProvider: OracleOrmLiteDialectProvider.MicrosoftProvider); \n\nDateTimeOffset fields and, in locales that use a comma to separate the fractional part of a floating point number, some aspects of using floating point numbers, do not work with System.Data.OracleClient.\n\n# Community Resources\n\n  - [OrmLite and Redis: New alternatives for handling db communication](http://www.abtosoftware.com/blog/servicestack-ormlite-and-redis-new-alternatives-for-handling-db-communication) by [@abtosoftware](https://twitter.com/abtosoftware)\n  - [Object Serialization as Step Towards Normalization](http://www.unpluggeddevelopment.com/post/85225892120/object-serialization-as-step-towards-normalization) by [@ 82unpluggd](https://twitter.com/82unpluggd)\n  - [Creating a Data Access Layer using OrmLite](http://blogs.askcts.com/2014/05/07/getting-started-with-servicestack-part-2/) by [Lydon Bergin](http://blogs.askcts.com/)\n  - [Code Generation using ServiceStack.OrmLite and T4 Text templates](http://jokecamp.wordpress.com/2013/09/07/code-generation-using-servicestack-ormlite-and-t4-text-templates/) by [@jokecamp](https://twitter.com/jokecamp)\n  - [Simple ServiceStack OrmLite Example](http://www.curlette.com/?p=1068) by [@robrtc](https://twitter.com/robrtc)\n  - [OrmLite Blobbing done with NHibernate and Serialized JSON](http://www.philliphaydon.com/2012/03/ormlite-blobbing-done-with-nhibernate-and-serialized-json/) by [@philliphaydon](https://twitter.com/philliphaydon)\n  - [Creating An ASP.NET MVC Blog With ServiceStack.OrmLite](http://www.eggheadcafe.com/tutorials/asp-net/285cbe96-9922-406a-b193-3a0b40e31c40/creating-an-aspnet-mvc-blog-with-servicestackormlite.aspx) by [@peterbromberg](https://twitter.com/peterbromberg)\n\n## Other notable Micro ORMs for .NET\nMany performance problems can be mitigated and a lot of use-cases can be simplified without the use of a heavyweight ORM, and their config, mappings and infrastructure. \nAs [performance is the most important feature](https://github.com/mythz/ScalingDotNET) we can recommend the following list, each with their own unique special blend of features. \n\n  * **[Dapper](http://code.google.com/p/dapper-dot-net/)** - by [@samsaffron](http://twitter.com/samsaffron) and [@marcgravell](http://twitter.com/marcgravell) \n    - The current performance king, supports both POCO and dynamic access, fits in a single class. Put in production to solve [StackOverflow\'s DB Perf issues](http://samsaffron.com/archive/2011/03/30/How+I+learned+to+stop+worrying+and+write+my+own+ORM). Requires .NET 4.\n  * **[PetaPoco](http://www.toptensoftware.com/petapoco/)** - by [@toptensoftware](http://twitter.com/toptensoftware)\n    - Fast, supports dynamics, expandos and typed POCOs, fits in a single class, runs on .NET 3.5 and Mono. Includes optional T4 templates for POCO table generation.\n  * **[Massive](https://github.com/robconery/massive)** - by [@robconery](http://twitter.com/robconery)\n    - Fast, supports dynamics and expandos, smart use of optional params to provide a wrist-friendly api, fits in a single class. Multiple RDBMS support. Requires .NET 4.\n  * **[Simple.Data](https://github.com/markrendle/Simple.Data)** - by [@markrendle](http://twitter.com/markrendle)\n    - A little slower than above ORMS, most wrist-friendly courtesy of a dynamic API, multiple RDBMS support inc. Mongo DB. Requires .NET 4.\n'