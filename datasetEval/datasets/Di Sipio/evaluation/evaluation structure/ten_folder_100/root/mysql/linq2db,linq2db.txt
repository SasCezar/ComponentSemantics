b'# LINQ to DB\n\n[![NuGet Version and Downloads count](https://buildstats.info/nuget/linq2db)](https://www.nuget.org/profiles/LinqToDB)\n[![Stack Exchange questions](https://img.shields.io/stackexchange/stackoverflow/t/linq2db.svg?label=stackoverflow)](https://stackoverflow.com/questions/tagged/linq2db) \n\n[![Follow @linq2db](https://img.shields.io/twitter/follow/linq2db.svg?style=social)](https://twitter.com/linq2db)\n\nLINQ to DB is the fastest LINQ database access library offering a simple, light, fast, and type-safe layer between your POCO objects and your database. \n\nArchitecturally it is one step above micro-ORMs like Dapper, Massive, or PetaPoco, in that you work with LINQ expressions, not with magic strings, while maintaining a thin abstraction layer between your code and the database. Your queries are checked by the C# compiler and allow for easy refactoring.\n\nHowever, it\'s not as heavy as LINQ to SQL or Entity Framework. There is no change-tracking, so you have to manage that yourself, but on the positive side you get more control and faster access to your data.\n\nIn other words **LINQ to DB is type-safe SQL**.\n\n## Standout Features\n\n - Rich Querying API:\n   - [Explicit Join Syntax](https://linq2db.github.io/articles/sql/Join-Operators.html) (In addition to standard LINQ join syntax.)\n   - [CTE Support](https://linq2db.github.io/articles/sql/CTE.html)\n   - [Bulk Copy/Insert](https://linq2db.github.io/articles/sql/Bulk-Copy.html)\n   - [Windowing/Analytic Functions](https://linq2db.github.io/articles/sql/Window-Functions-%28Analytic-Functions%29.html)\n   - [Merge API](https://linq2db.github.io/articles/sql/merge/Merge-API-Description.html)\n - Extensibility:\n   - [Ability to Map Custom SQL to Static Functions](https://github.com/linq2db/linq2db/tree/master/Source/LinqToDB/Sql/)\n\nVisit our [blog](http://blog.linq2db.com/) and see [Github.io documentation](https://linq2db.github.io/index.html) for more details.\n\nCode examples and demos can be found [here](https://github.com/linq2db/examples) or in [tests](https://github.com/linq2db/linq2db/tree/master/Tests/Linq).\n\nT4 model generation help is [here](https://github.com/linq2db/linq2db/blob/master/Source/LinqToDB.Templates/README.md).\n\n[Releases and Roadmap](https://github.com/linq2db/linq2db/wiki/Releases-and-Roadmap).\n\n## How to help the project\n\nNo, this is not the donate link. We do need something really more valuable - your **time**. If you really want to help us please read this [post](https://linq2db.github.io/articles/project/How-can-i-help.html).\n\n## Project Build Status\n\n--------------------\n| |Appveyor|Travis\n-----|-------|--------\n|master|[![Build status](https://ci.appveyor.com/api/projects/status/4au5v7xm5gi19o8m/branch/master?svg=true)](https://ci.appveyor.com/project/igor-tkachev/linq2db/branch/master)|[![Build Status](https://travis-ci.org/linq2db/linq2db.svg?branch=master)](https://travis-ci.org/linq2db/linq2db)\n|latest|[![Build status](https://ci.appveyor.com/api/projects/status/4au5v7xm5gi19o8m?svg=true)](https://ci.appveyor.com/project/igor-tkachev/linq2db)| |\n\n## Feeds\n\n* NuGet [![NuGet](https://img.shields.io/nuget/vpre/linq2db.svg)](https://www.nuget.org/profiles/LinqToDB)\n* MyGet [![MyGet](https://img.shields.io/myget/linq2db/vpre/linq2db.svg)](https://www.myget.org/gallery/linq2db)\n  * V2 `https://www.myget.org/F/linq2db/api/v2`\n  * V3 `https://www.myget.org/F/linq2db/api/v3/index.json`\n\n## Let\'s get started\n\nFrom **NuGet**:\n* `Install-Package linq2db` - .NET & .NET Core\n\n## Configuring connection strings\n\n### .NET\n\nIn your `web.config` or `app.config` make sure you have a connection string (check [this file](https://github.com/linq2db/linq2db/blob/master/Source/LinqToDB/ProviderName.cs) for supported providers):\n\n```xml\n<connectionStrings>\n  <add name="Northwind" \n    connectionString = "Server=.\\;Database=Northwind;Trusted_Connection=True;Enlist=False;" \n    providerName     = "SqlServer" />\n</connectionStrings>\n```\n\n### .NET Core\n\n.Net Core does not support `System.Configuration` so to configure connection strings you should implement `ILinqToDBSettings`, for example:\n\n```cs\npublic class ConnectionStringSettings : IConnectionStringSettings\n{\n    public string ConnectionString { get; set; }\n    public string Name { get; set; }\n    public string ProviderName { get; set; }\n    public bool IsGlobal => false;\n}\n\npublic class MySettings : ILinqToDBSettings\n{\n    public IEnumerable<IDataProviderSettings> DataProviders => Enumerable.Empty<IDataProviderSettings>();\n\n    public string DefaultConfiguration => "SqlServer";\n    public string DefaultDataProvider => "SqlServer";\n\n    public IEnumerable<IConnectionStringSettings> ConnectionStrings\n    {\n        get\n        {\n            yield return\n                new ConnectionStringSettings\n                {\n                    Name = "Northwind",\n                    ProviderName = "SqlServer",\n                    ConnectionString = @"Server=.\\;Database=Northwind;Trusted_Connection=True;Enlist=False;"\n                };\n        }\n    }\n}\n\n```\n\nAnd later just set on program startup before the first query is done (Startup.cs for example):\n\n```cs\nDataConnection.DefaultSettings = new MySettings();\n```\n\nYou can also use same for regular .NET.\n\n## Now let\'s create a **POCO** class\n\nImportant: you also can generate those classes from your database using [T4 templates](https://github.com/linq2db/linq2db/tree/master/Source/LinqToDB.Templates#t4-models). Demonstration video could be found [here](https://linq2db.github.io/articles/general/Video.html).\n\n```c#\nusing System;\nusing LinqToDB.Mapping;\n\n[Table(Name = "Products")]\npublic class Product\n{\n  [PrimaryKey, Identity]\n  public int ProductID { get; set; }\n\n  [Column(Name = "ProductName"), NotNull]\n  public string Name { get; set; }\n\n  // ... other columns ...\n}\n```\n\nAt this point LINQ to DB doesn\'t know how to connect to our database or which POCOs go with what database. All this mapping is done through a `DataConnection` class:\n\n```c#\npublic class DbNorthwind : LinqToDB.Data.DataConnection\n{\n  public DbNorthwind() : base("Northwind") { }\n\n  public ITable<Product> Product => GetTable<Product>();\n  public ITable<Category> Category => GetTable<Category>();\n\n  // ... other tables ...\n}\n```\n\nWe call the base constructor with the "Northwind" parameter. This parameter (called `configuration name`) has to match the name="Northwind" we defined above in our connection string. We also have to register our `Product` class we defined above to allow us to write LINQ queries.\n\nAnd now let\'s get some data:\n\n```c#\nusing LinqToDB;\nusing LinqToDB.Common;\n\npublic static List<Product> All()\n{\n  using (var db = new DbNorthwind())\n  {\n    var query = from p in db.Product\n                where p.ProductID > 25\n                orderby p.Name descending\n                select p;\n    return query.ToList();\n  }\n}\n```\n\nMake sure you **always** wrap your `DataConnection` class (in our case `DbNorthwind`) in a `using` statement. This is required for proper resource management, like releasing the database connections back into the pool. [More details](https://linq2db.github.io/articles/general/Managing-data-connection.html)\n\n## Selecting Columns\n\nMost times we get the entire row from the database:\n\n```c#\nfrom p in db.Product\nwhere p.ProductID == 5\nselect p;\n```\n\nHowever, sometimes getting all the fields is too wasteful so we want only certain fields, but still use our POCOs; something that is challenging for libraries that rely on object tracking, like LINQ to SQL.\n\n```c#\nfrom p in db.Product\norderby p.Name descending\nselect new Product\n{\n  Name = p.Name\n};\n```\n\n## Composing queries\n\nRather than concatenating strings we can \'compose\' LINQ expressions.  In the example below the final SQL will be different if `onlyActive` is true or false, or if `searchFor` is not null.\n\n```c#\npublic static List<Product> All(bool onlyActive, string searchFor)\n{\n  using (var db = new DbNorthwind())\n  {\n    var products = from p in db.Product \n                   select p;\n\n    if (onlyActive)\n    {\n      products = from p in products \n                 where !p.Discontinued \n                 select p;\n    }\n\n    if (searchFor != null)\n    {\n      products = from p in products \n                 where p.Name.Contains(searchFor) \n                 select p;\n    }\n\n    return products.ToList();\n  }\n}\n```\n\n## Paging\n\nA lot of times we need to write code that returns only a subset of the entire dataset. We expand on the previous example to show what a product search function could look like. \n\nKeep in mind that the code below will query the database twice. Once to find out the total number of records, something that is required by many paging controls, and once to return the actual data.\n\n```c#\npublic static List<Product> Search(string searchFor, int currentPage, int pageSize, out int totalRecords)\n{\n  using (var db = new DbNorthwind())\n  {\n    var products = from p in db.Product \n                   select p;\n\n    if (searchFor != null)\n    {\n      products = from p in products \n                 where p.Name.Contains(searchFor) \n                 select p;\n    }\n\n    totalRecords = products.Count();\n\n    return products.Skip((currentPage - 1) * pageSize).Take(pageSize).ToList();\n  }\n}\n```\n\n## Joins\n\nThis assumes we added a `Category` class, just like we did with the `Product` class, defined all the fields, and registered it in our `DbNorthwind` data access class. We can now write an **INNER JOIN** query like this:\n\n```c#\nfrom p in db.Product\njoin c in db.Category on p.CategoryID equals c.CategoryID\nselect new Product\n{\n  Name = p.Name,\n  Category = c\n};\n```\n\nand a **LEFT JOIN** query like this:\n\n```c#\nfrom p in db.Product\nfrom c in db.Category.Where(q => q.CategoryID == p.CategoryID).DefaultIfEmpty()\nselect new Product\n{\n  Name = p.Name,\n  Category = c\n};\n```\n\n[More samples are here](https://linq2db.github.io/articles/sql/Join-Operators.html)\n\n## Creating your POCOs\n\nIn the previous example we assign an entire `Category` object to our product, but what if we want all the fields in our `Product` class, but we don\'t want to specify every field by hand? Unfortunately, we **cannot** write this:\n\n```c#\nfrom p in db.Product\nfrom c in db.Category.Where(q => q.CategoryID == p.CategoryID).DefaultIfEmpty()\nselect new Product(c);\n```\n\nThe query above assumes the Product class has a constructor that takes in a Category object. The query above won\'t work, but we **can** work around that with the following query:\n\n```c#\nfrom p in db.Product\nfrom c in db.Category.Where(q => q.CategoryID == p.CategoryID).DefaultIfEmpty()\nselect Product.Build(p, c);\n```\n\nFor this to work, we need a function in the `Product` class that looks like this:\n\n```c#\npublic static Product Build(Product product, Category category)\n{\n  if (product != null)\n  {\n    product.Category = category;\n  }\n  return product;\n}\n```\n\nOne caveat with this approach is that if you\'re using it with composed queries (see example above) the select Build part has to come only in the final select.\n\n## Insert\n\nAt some point we will need to add a new `Product` to the database. One way would be to call the `Insert` extension method found in the `LinqToDB` namespace; so make sure you import that.\n\n```c#\nusing LinqToDB;\n\nusing (var db = new DbNorthwind())\n{\n  db.Insert(product);\n}\n```\n\nThis inserts all the columns from our Product class, but without retrieving the generated identity value. To do that we can use `InsertWith*Identity` methods, like this:\n\n```c#\nusing LinqToDB;\n\nusing (var db = new DbNorthwind())\n{\n  product.ProductID = db.InsertWithInt32Identity(product);\n}\n```\n\nThere is also `InsertOrReplace` that updates a database record if it was found by primary key or adds it otherwise.\n\nIf you need to insert only certain fields, or use values generated by the database, you could write:\n\n```c#\nusing LinqToDB;\n\nusing (var db = new DbNorthwind())\n{\n  db.Product\n    .Value(p => p.Name, product.Name)\n    .Value(p => p.UnitPrice, 10.2m)\n    .Value(p => p.Added, () => Sql.CurrentTimestamp)\n    .Insert();\n}\n```\n\nUse of this method also allows us to build insert statements like this:\n\n```c#\nusing LinqToDB;\n\nusing (var db = new DbNorthwind())\n{\n  var statement = db.Product\n                    .Value(p => p.Name, product.Name)\n                    .Value(p => p.UnitPrice, 10.2m);\n\n  if (storeAdded) statement.Value(p => p.Added, () => Sql.CurrentTimestamp);\n\n  statement.Insert();\n}\n```\n\n## Update\n\nUpdating records follows similar pattern to Insert. We have an extension method that updates all the columns in the database:\n\n```c#\nusing LinqToDB;\n\nusing (var db = new DbNorthwind())\n{\n  db.Update(product);\n}\n```\n\nAnd we also have a lower level update mechanism:\n\n```c#\nusing LinqToDB;\n\nusing (var db = new DbNorthwind())\n{\n  db.Product\n    .Where(p => p.ProductID == product.ProductID)\n    .Set(p => p.Name, product.Name)\n    .Set(p => p.UnitPrice, product.UnitPrice)\n    .Update();\n}\n```\n\nSimilarly, we can break an update query into multiple pieces if needed:\n\n```c#\nusing LinqToDB;\n\nusing (var db = new DbNorthwind())\n{\n  var statement = db.Product\n                    .Where(p => p.ProductID == product.ProductID)\n                    .Set(p => p.Name, product.Name);\n\n  if (updatePrice) statement = statement.Set(p => p.UnitPrice, product.UnitPrice);\n\n  statement.Update();\n}\n```\n\nYou\'re not limited to updating a single record. For example, we could discontinue all the products that are no longer in stock:\n\n```c#\nusing LinqToDB;\n\nusing (var db = new DbNorthwind())\n{\n  db.Product\n    .Where(p => p.UnitsInStock == 0)\n    .Set(p => p.Discontinued, true)\n    .Update();\n}\n```\n\n## Delete\n\nSimilar to how you update records, you can also delete records:\n\n```c#\nusing LinqToDB;\n\nusing (var db = new DbNorthwind())\n{\n  db.Product\n    .Where(p => p.Discontinued)\n    .Delete();\n}\n```\n\n## Bulk Copy\n\nBulk copy feature supports the transfer of large amounts of data into a table from another data source. For faster data inserting DO NOT use a transaction. If you use a transaction an adhoc implementation of the bulk copy feature has been added in order to insert multiple lines at once. You get faster results then inserting lines one by one, but it\'s still slower than the database provider bulk copy. So, DO NOT use transactions whenever you can (Take care of unique constraints, primary keys, etc. since bulk copy ignores them at insertion).\n\n```c#\nusing LinqToDB.Data;\n\n[Table(Name = "ProductsTemp")]\npublic class ProductTemp\n{\n  public int ProductID { get; set; }\n\n  [Column(Name = "ProductName"), NotNull]\n  public string Name { get; set; }\n\n  // ... other columns ...\n}\n\nlist = List<ProductTemp>\n\nusing (var db = new DbNorthwind())\n{\n  db.BulkCopy(list);\n}\n```\n\n## Transactions\n\nUsing database transactions is easy. All you have to do is call BeginTransaction() on your DataConnection, run one or more queries, and then commit the changes by calling CommitTransaction(). If something happened and you need to roll back your changes you can either call RollbackTransaction() or throw an exception.\n\n```c#\nusing (var db = new DbNorthwind())\n{\n  db.BeginTransaction();\n  \n  // ... select / insert / update / delete ...\n\n  if (somethingIsNotRight)\n  {\n    db.RollbackTransaction();\n  }\n  else\n  {\n    db.CommitTransaction();\n  }\n}\n```\n\nAlso, you can use .NET built-in TransactionScope class:\n\n```c#\n// don\'t forget that isolation level is serializable by default\nusing (var transaction = new TransactionScope())\n// or for async code\n// using (var transaction = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))\n{\n  using (var db = new DbNorthwind())\n  {\n    ...\n  }\n  transaction.Complete();\n}\n```\n\n## Merge\n\n[Here](https://linq2db.github.io/articles/sql/merge/Merge-API.html) you can read about MERGE support.\n\n## Window (Analytic) Functions\n\n[Here](https://linq2db.github.io/articles/sql/Window-Functions-%28Analytic-Functions%29.html) you can read about Window (Analytic) Functions support.\n\n## MiniProfiler\n\nIf you would like to use MiniProfiler from StackExchange you\'d need to wrap ProfiledDbConnection around our regular DataConnection.\n\n```c#\npublic class DbDataContext : DataConnection\n{\n#if !DEBUG\n  public DbDataContext() : base("Northwind") { }\n#else\n  public DbDataContext() : base(GetDataProvider(), GetConnection()) { }\n\n  private static IDataProvider GetDataProvider()\n  {\n    // you can move this line to other place, but it should be\n    // always set before LINQ to DB provider instance creation\n    LinqToDB.Common.Configuration.AvoidSpecificDataProviderAPI = true;\n\n    return new SqlServerDataProvider("", SqlServerVersion.v2012);\n  }\n\n  private static IDbConnection GetConnection()\n  {\n    var dbConnection = new SqlConnection(@"Server=.\\SQL;Database=Northwind;Trusted_Connection=True;Enlist=False;");\n    return new StackExchange.Profiling.Data.ProfiledDbConnection(dbConnection, MiniProfiler.Current);\n  }\n#endif\n}\n```\n\nThis assumes that you only want to use MiniProfiler while in DEBUG mode and that you are using SQL Server for your database. If you\'re using a different database you would need to change GetDataProvider() to return the appropriate IDataProvider. For example for MySql you would use:\n\n```c#\nprivate static IDataProvider GetDataProvider()\n{\n  return new LinqToDB.DataProvider.MySql.MySqlDataProvider();\n}\n```\n\n# More\nStill have questions left? Check out our [documentation site](https://linq2db.github.io) and [FAQ](https://linq2db.github.io/articles/FAQ.html)\n'