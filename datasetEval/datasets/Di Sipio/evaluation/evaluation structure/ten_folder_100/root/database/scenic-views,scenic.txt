b'# Scenic\n\n![Scenic Landscape](https://user-images.githubusercontent.com/152152/49344534-a8817480-f646-11e8-8431-3d95d349c070.png)\n\n[![Build Status](https://travis-ci.org/scenic-views/scenic.svg?branch=master)](https://travis-ci.org/scenic-views/scenic)\n[![Documentation Quality](http://inch-ci.org/github/scenic-views/scenic.svg?branch=master)](http://inch-ci.org/github/scenic-views/scenic)\n[![Reviewed by Hound](https://img.shields.io/badge/Reviewed_by-Hound-8E64B0.svg)](https://houndci.com)\n\nScenic adds methods to `ActiveRecord::Migration` to create and manage database\nviews in Rails.\n\nUsing Scenic, you can bring the power of SQL views to your Rails application\nwithout having to switch your schema format to SQL. Scenic provides a convention\nfor versioning views that keeps your migration history consistent and reversible\nand avoids having to duplicate SQL strings across migrations. As an added bonus,\nyou define the structure of your view in a SQL file, meaning you get full SQL\nsyntax highlighting in the editor of your choice and can easily test your SQL in\nthe database console during development.\n\nScenic ships with support for PostgreSQL. The adapter is configurable (see\n`Scenic::Configuration`) and has a minimal interface (see\n`Scenic::Adapters::Postgres`) that other gems can provide.\n\n## So how do I install this?\n\nIf you\'re using Postgres, Add `gem "scenic"` to your Gemfile and run `bundle\ninstall`. If you\'re using something other than Postgres, check out the available\n[third party adapters](https://github.com/scenic-views/scenic#faqs).\n\n## Great, how do I create a view?\n\nYou\'ve got this great idea for a view you\'d like to call `search_results`. You\ncan create the migration and the corresponding view definition file with the\nfollowing command:\n\n```sh\n$ rails generate scenic:view search_results\n      create  db/views/search_results_v01.sql\n      create  db/migrate/[TIMESTAMP]_create_search_results.rb\n```\n\nEdit the `db/views/search_results_v01.sql` file with the SQL statement that\ndefines your view. In our example, this might look something like this:\n\n```sql\nSELECT\n  statuses.id AS searchable_id,\n  \'Status\' AS searchable_type,\n  comments.body AS term\nFROM statuses\nJOIN comments ON statuses.id = comments.status_id\n\nUNION\n\nSELECT\n  statuses.id AS searchable_id,\n  \'Status\' AS searchable_type,\n  statuses.body AS term\nFROM statuses\n```\n\nThe generated migration will contain a `create_view` statement. Run the\nmigration, and [baby, you got a view going][carl]. The migration is reversible\nand the schema will be dumped into your `schema.rb` file.\n\n[carl]: https://www.youtube.com/watch?v=Sr2PlqXw03Y\n\n```sh\n$ rake db:migrate\n```\n\n## Cool, but what if I need to change that view?\n\nHere\'s where Scenic really shines. Run that same view generator once more:\n\n```sh\n$ rails generate scenic:view search_results\n      create  db/views/search_results_v02.sql\n      create  db/migrate/[TIMESTAMP]_update_search_results_to_version_2.rb\n```\n\nScenic detected that we already had an existing `search_results` view at version\n1, created a copy of that definition as version 2, and created a migration to\nupdate to the version 2 schema. All that\'s left for you to do is tweak the\nschema in the new definition and run the `update_view` migration.\n\n## What if I want to change a view without dropping it?\n\nThe `update_view` statement used by default will drop your view then create\na new version of it.\n\nThis is not desirable when you have complicated hierarchies of views, especially\nwhen some of those views may be materialized and take a long time to recreate.\n\nYou can use `replace_view` to generate a CREATE OR REPLACE VIEW SQL statement.\n\nSee postgresql documentation on how this works:\nhttp://www.postgresql.org/docs/current/static/sql-createview.html\n\nTo start replacing a view run the generator like for a regular change:\n\n```sh\n$ rails generate scenic:view search_results\n      create  db/views/search_results_v02.sql\n      create  db/migrate/[TIMESTAMP]_update_search_results_to_version_2.rb\n```\n\nNow, edit the migration. It should look something like:\n\n```ruby\nclass UpdateSearchResultsToVersion2 < ActiveRecord::Migration\n  def change\n    update_view :search_results, version: 2, revert_to_version: 1\n  end\nend\n```\n\nUpdate it to use replace view:\n\n```ruby\nclass UpdateSearchResultsToVersion2 < ActiveRecord::Migration\n  def change\n    replace_view :search_results, version: 2, revert_to_version: 1\n  end\nend\n```\n\nNow you can run the migration like normal.\n\n## Can I use this view to back a model?\n\nYou bet! Using view-backed models can help promote concepts hidden in your\nrelational data to first-class domain objects and can clean up complex\nActiveRecord or ARel queries. As far as ActiveRecord is concerned, a view is\nno different than a table.\n\n```ruby\nclass SearchResult < ActiveRecord::Base\n  belongs_to :searchable, polymorphic: true\n\n  # this isn\'t strictly necessary, but it will prevent\n  # rails from calling save, which would fail anyway.\n  def readonly?\n    true\n  end\nend\n```\n\nScenic even provides a `scenic:model` generator that is a superset of\n`scenic:view`.  It will act identically to the Rails `model` generator except\nthat it will create a Scenic view migration rather than a table migration.\n\nThere is no special base class or mixin needed. If desired, any code the model\ngenerator adds can be removed without worry.\n\n```sh\n$ rails generate scenic:model recent_status\n      invoke  active_record\n      create    app/models/recent_status.rb\n      invoke    test_unit\n      create      test/models/recent_status_test.rb\n      create      test/fixtures/recent_statuses.yml\n      create  db/views/recent_statuses_v01.sql\n      create  db/migrate/20151112015036_create_recent_statuses.rb\n```\n\n## What about materialized views?\n\nMaterialized views are essentially SQL queries whose results can be cached to a\ntable, indexed, and periodically refreshed when desired. Does Scenic support\nthose? Of course!\n\nThe `scenic:view` and `scenic:model` generators accept a `--materialized`\noption for this purpose. When used with the model generator, your model will\nhave the following method defined as a convenience to aid in scheduling\nrefreshes:\n\n```ruby\ndef self.refresh\n  Scenic.database.refresh_materialized_view(table_name, concurrently: false, cascade: false)\nend\n```\n\nThis will perform a non-concurrent refresh, locking the view for selects until\nthe refresh is complete. You can avoid locking the view by passing\n`concurrently: true` but this requires both PostgreSQL 9.4 and your view to have\nat least one unique index that covers all rows. You can add or update indexes for\nmaterialized views using table migration methods (e.g. `add_index table_name`)\nand these will be automatically re-applied when views are updated.\n\nThe `cascade` option is to refresh materialized views that depend on other\nmaterialized views. For example, say you have materialized view A, which selects\ndata from materialized view B. To get the most up to date information in view A\nyou would need to refresh view B first, then right after refresh view A. If you\nwould like this cascading refresh of materialized views, set `cascade: true`\nwhen you refresh your materialized view.\n\n## I don\'t need this view anymore. Make it go away.\n\nScenic gives you `drop_view` too:\n\n```ruby\ndef change\n  drop_view :search_results, revert_to_version: 2\n  drop_view :materialized_admin_reports, revert_to_version: 3, materialized: true\nend\n```\n\n## FAQs\n\n**Why do I get an error when querying a view-backed model with `find`, `last`, or `first`?**\n\nActiveRecord\'s `find` method expects to query based on your model\'s primary key,\nbut views do not have primary keys. Additionally, the `first` and `last` methods\nwill produce queries that attempt to sort based on the primary key.\n\nYou can get around these issues by setting the primary key column on your Rails\nmodel like so:\n\n```ruby\nclass People < ActiveRecord::Base\n  self.primary_key = :my_unique_identifier_field\nend\n```\n\n**Why is my view missing columns from the underlying table?**\n\nDid you create the view with `SELECT [table_name].*`? Most (possibly all)\nrelational databases freeze the view definition at the time of creation. New\ncolumns will not be available in the view until the definition is updated once\nagain. This can be accomplished by "updating" the view to its current definition\nto bake in the new meaning of `*`.\n\n```ruby\nadd_column :posts, :title, :string\nupdate_view :posts_with_aggregate_data, version: 2, revert_to_version: 2\n```\n\n**When will you support MySQL, SQLite, or other databases?**\n\nWe have no plans to add first-party adapters for other relational databases at\nthis time because we (the maintainers) do not currently have a use for them.\nIt\'s our experience that maintaining a library effectively requires regular use\nof its features. We\'re not in a good position to support MySQL, SQLite or other\ndatabase users.\n\nScenic *does* support configuring different database adapters and should be\nextendable with adapter libraries. If you implement such an adapter, we\'re happy\nto review and link to it. We\'re also happy to make changes that would better\naccommodate adapter gems.\n\nWe are aware of the following existing adapter libraries for Scenic which may\nmeet your needs:\n\n* [scenic_sqlite_adapter](https://github.com/pdebelak/scenic_sqlite_adapter)\n* [scenic-mysql_adapter](https://github.com/EmpaticoOrg/scenic-mysql_adapter)\n* [scenic-sqlserver-adapter](https://github.com/ClickMechanic/scenic_sqlserver_adapter)\n* [scenic-oracle_enhanced_adapter](https://github.com/PMACS/scenic_oracle_enhanced_adapter)\n\n## About\n\nScenic is maintained by [Derek Prior], [Caleb Thompson], and you, our\ncontributors.\n\n[Derek Prior]: http://prioritized.net\n[Caleb Thompson]: http://calebthompson.io\n'