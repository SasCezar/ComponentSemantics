b'# Toast \xf0\x9f\xa5\x82\n\n[![Build Status](https://travis-ci.org/stepchowfun/toast.svg?branch=master)](https://travis-ci.org/stepchowfun/toast)\n\n*Toast* is a tool for doing work in containers. You define tasks in a YAML file called a *toastfile*, and Toast runs them in a containerized environment based on a Docker image of your choosing. What constitutes a "task" is up to you: tasks can install system packages, build an application, run a test suite, or even serve web pages.\n\n![Welcome to Toast.](https://raw.githubusercontent.com/stepchowfun/toast/master/media/welcome-0.svg?sanitize=true)\n\nHere\'s the toastfile for the example shown above:\n\n```yml\nimage: ubuntu\ntasks:\n  install_gcc:\n    command: |\n      apt-get update\n      apt-get install --yes gcc\n\n  build:\n    dependencies:\n      - install_gcc\n    input_paths:\n      - main.c\n    command: gcc main.c\n\n  run:\n    dependencies:\n      - build\n    command: ./a.out\n```\n\nToast caches each task by committing the container to an image. The image is tagged with a cryptographic hash of the shell command for the task, the contents of the files copied into the container, and all the other task inputs. This hash allows Toast to skip tasks that haven\'t changed since the last run.\n\nIn addition to local caching, Toast can use a Docker registry as a remote cache. You, your teammates, and your continuous integration (CI) system can all share the same remote cache. Used in this way, your CI system can do all the heavy lifting like building and installing dependencies so you and your team can focus on development.\n\nRelated tools:\n\n- [Docker Compose](https://docs.docker.com/compose/): Docker Compose is a convenient Docker-based development environment which shares many features with Toast. However, it doesn\'t support defining tasks (like `lint`, `test`, `run`, etc.) or remote caching.\n- [Nix](https://nixos.org/nix/): Nix achieves reproducible builds by leveraging ideas from functional programming rather than containerization. We\'re big fans of Nix. However, Nix involves a larger commitment compared to Toast because you have to use the Nix package manager or write your own Nix derivations. For better or worse, Toast allows you to use familiar idioms like `apt-get install ...`.\n\n## Table of contents\n\n* [Installation](#installation)\n   * [Easy installation](#easy-installation)\n   * [Manual installation](#manual-installation)\n   * [Installation with Cargo](#installation-with-cargo)\n* [Tutorial](#tutorial)\n   * [Defining a simple task](#defining-a-simple-task)\n   * [Adding a dependency](#adding-a-dependency)\n   * [Importing files from the host](#importing-files-from-the-host)\n   * [Exporting files from the container](#exporting-files-from-the-container)\n   * [Passing arguments to a task](#passing-arguments-to-a-task)\n   * [Running a server and mounting paths into the container](#running-a-server-and-mounting-paths-into-the-container)\n   * [Dropping into a shell](#dropping-into-a-shell)\n* [How Toast works](#how-toast-works)\n* [Toastfiles](#toastfiles)\n* [Cache configuration](#cache-configuration)\n* [Command-line options](#command-line-options)\n* [Requirements](#requirements)\n* [Acknowledgements](#acknowledgements)\n\n## Installation\n\n### Easy installation\n\nIf you are running macOS or a GNU-based Linux on an x86-64 CPU, you can install Toast with this command:\n\n```sh\ncurl https://raw.githubusercontent.com/stepchowfun/toast/master/install.sh -LSfs | sh\n```\n\nThe same command can be used again to update Toast to the latest version.\n\n**NOTE:** Piping `curl` to `sh` is dangerous since the server might be compromised. If you\'re concerned about this, you can download and inspect the installation script or choose one of the other installation methods.\n\nThe installation script can be customized with the following environment variables:\n\n- `VERSION=x.y.z` (defaults to the latest version)\n- `PREFIX=/path/to/install` (defaults to `/usr/local/bin`)\n\nFor example, the following will install Toast into the working directory:\n\n```sh\ncurl https://raw.githubusercontent.com/stepchowfun/toast/master/install.sh -LSfs | PREFIX=. sh\n```\n\n### Manual installation\n\nThe [releases page](https://github.com/stepchowfun/toast/releases) has precompiled binaries for macOS or Linux systems running on an x86-64 CPU. You can download one of them and place it in a directory listed in your [`PATH`](https://en.wikipedia.org/wiki/PATH_\\(variable\\)).\n\n### Installation with Cargo\n\nIf you have [Cargo](https://doc.rust-lang.org/cargo/), you can install Toast as follows:\n\n```sh\ncargo install toast\n```\n\nYou can run that command with `--force` to update an existing installation.\n\n## Tutorial\n\n### Defining a simple task\n\nLet\'s create a toastfile. Create a file named `toast.yml` with the following contents:\n\n```yaml\nimage: ubuntu\ntasks:\n  greet:\n    command: echo \'Hello, World!\' # Toast will run this in a container.\n```\n\nNow run `toast`. You should see the following:\n\n![Defining a simple task.](https://raw.githubusercontent.com/stepchowfun/toast/master/media/simple-task-0.svg?sanitize=true)\n\nIf you run it again, Toast will find that nothing has changed and skip the task:\n\n![Caching.](https://raw.githubusercontent.com/stepchowfun/toast/master/media/caching-0.svg?sanitize=true)\n\nToast caches tasks to save you time. For example, you don\'t want to reinstall your dependencies every time you run your tests. However, caching may not be appropriate for some tasks, like running your development server. You can disable caching for a specific task and all tasks that depend on it with the `cache` option:\n\n```yaml\nimage: ubuntu\ntasks:\n  greet:\n    cache: false # Don\'t cache this task.\n    command: echo \'Hello, World!\'\n```\n\n### Adding a dependency\n\nLet\'s make the greeting more fun with a program called `figlet`. We\'ll add a task to install `figlet`, and we\'ll change the `greet` task to depend on it:\n\n```yaml\nimage: ubuntu\ntasks:\n  install_figlet:\n    command: |\n      apt-get update\n      apt-get install --yes figlet\n\n  greet:\n    dependencies:\n      - install_figlet # Toast will run this task first.\n    command: figlet \'Hello, World!\'\n```\n\nRun `toast` to see a marvelous greeting:\n\n![Adding a dependency.](https://raw.githubusercontent.com/stepchowfun/toast/master/media/dependencies-0.svg?sanitize=true)\n\n### Importing files from the host\n\nHere\'s a more realistic example. Suppose you want to compile and run a simple C program. Create a file called `main.c`:\n\n```c\n#include <stdio.h>\n\nint main(void) {\n  printf("Hello, World!\\n");\n}\n```\n\nUpdate `toast.yml` to compile and run the program:\n\n```yaml\nimage: ubuntu\ntasks:\n  install_gcc:\n    command: |\n      apt-get update\n      apt-get install --yes gcc\n\n  build:\n    dependencies:\n      - install_gcc\n    input_paths:\n      - main.c # Toast will copy this file into the container before running the command.\n    command: gcc main.c\n\n  run:\n    dependencies:\n      - build\n    command: ./a.out\n```\n\nNotice the `input_paths` array in the `build` task. Here we are copying a single file into the container, but we could instead import the entire directory containing the toastfile with `.`. By default, the files will be copied into a directory called `/scratch` in the container. The commands will be run in that directory as well.\n\nNow if you run `toast`, you\'ll see this:\n\n![Importing files from the host.](https://raw.githubusercontent.com/stepchowfun/toast/master/media/input-paths-0.svg?sanitize=true)\n\nFor subsequent runs, Toast will skip the task if nothing has changed. But if you update the greeting in `main.c`, Toast will detect the change and rerun the `build` and `run` tasks on the next invocation.\n\n### Exporting files from the container\n\nA common use case for Toast is to build a project. Naturally, you might wonder how to access the build artifacts produced inside the container from the host machine. It\'s easy to do with `output_paths`:\n\n```yaml\nimage: ubuntu\ntasks:\n  install_gcc:\n    command: |\n      apt-get update\n      apt-get install --yes gcc\n\n  build:\n    dependencies:\n      - install_gcc\n    input_paths:\n      - main.c\n    output_paths:\n      - a.out # Toast will copy this file onto the host after running the command.\n    command: gcc main.c\n```\n\nWhen Toast runs the `build` task, it will copy the `a.out` file to the host.\n\n![Exporting files from the container.](https://raw.githubusercontent.com/stepchowfun/toast/master/media/output-paths-0.svg?sanitize=true)\n\n### Passing arguments to a task\n\nSometimes it\'s useful for tasks to take arguments. For example, a `deploy` task might want to know whether you want to deploy to the `staging` or `production` cluster. To do this, add an `environment` section to your task:\n\n```yaml\nimage: ubuntu\ntasks:\n  deploy:\n    cache: false\n    environment:\n      CLUSTER: staging # Deploy to staging by default.\n    command: echo "Deploying to $CLUSTER..."\n```\n\nWhen you run this task, Toast will read the value from the environment:\n\n![Passing arguments to a task.](https://raw.githubusercontent.com/stepchowfun/toast/master/media/arguments-explicit-0.svg?sanitize=true)\n\nIf the variable does not exist in the environment, Toast will use the default value:\n\n![Using argument defaults.](https://raw.githubusercontent.com/stepchowfun/toast/master/media/arguments-default-0.svg?sanitize=true)\n\nIf you don\'t want to have a default, set it to `null`:\n\n```yaml\nimage: ubuntu\ntasks:\n  deploy:\n    cache: false\n    environment:\n      CLUSTER: null # No default; this variable must be provided at runtime.\n    command: echo "Deploying to $CLUSTER..."\n```\n\nNow if you run `toast deploy` without specifying a `CLUSTER`, Toast will complain about the missing variable and refuse to run the task.\n\nEnvironment variables listed in a task are also set for any tasks that run after it.\n\n### Running a server and mounting paths into the container\n\nToast can be used for more than just building a project. Suppose you\'re developing a website. You can define a Toast task to run your web server! Create a file called `index.html` with the following contents:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Welcome to Toast!</title>\n  </head>\n  <body>\n    <p>Hello, World!</p>\n  </body>\n</html>\n```\n\nWe can use a web server like [nginx](https://www.nginx.com/). The official `nginx` Docker image will do, but you could also use a more general image and define a Toast task to install nginx.\n\nIn our `toast.yml` file, we\'ll use the `ports` field to make the website accessible outside the container. We\'ll also use `mount_paths` rather than `input_paths` to synchronize files between the host and the container while the server is running.\n\n```yml\nimage: nginx\ntasks:\n  serve:\n    cache: false # It doesn\'t make sense to cache this task.\n    mount_paths:\n      - index.html # Synchronize this file between the host and the container.\n    ports:\n      - 3000:80 # Expose port 80 in the container as port 3000 on the host.\n    location: /usr/share/nginx/html/ # Nginx will serve the files in here.\n    command: nginx -g \'daemon off;\' # Run in foreground mode.\n```\n\nNow you can use Toast to run the server:\n\n![Running a server.](https://raw.githubusercontent.com/stepchowfun/toast/master/media/server-1.svg?sanitize=true)\n\n### Dropping into a shell\n\nIf you run Toast with `--shell`, Toast will drop you into an interactive shell inside the container when the requested tasks are finished, or if any of them fails. This feature is useful for debugging tasks or exploring what\'s in the container. Suppose you have the following toastfile:\n\n```yaml\nimage: ubuntu\ntasks:\n  install_figlet:\n    command: |\n      apt-get update\n      apt-get install --yes figlet\n```\n\nYou can run `toast --shell` to play with the `figlet` program:\n\n![Dropping into a shell.](https://raw.githubusercontent.com/stepchowfun/toast/master/media/shell-0.svg?sanitize=true)\n\nWhen you\'re done, the container is deleted automatically.\n\n## How Toast works\n\nGiven a set of tasks to run, Toast computes a [topological sort](https://en.wikipedia.org/wiki/Topological_sorting) of the dependency DAG to determine in what order to run the tasks. Toast builds a Docker image for each task based on the image from the previous task, or the base image in the case of the first task. Because Docker doesn\'t support combining two arbitrary images into one (for good reasons), Toast doesn\'t run tasks in parallel. You\'re free to use parallelism within individual tasks, of course.\n\nThe topological sort of an arbitrary DAG is not necessarily unique. Toast uses an algorithm based on depth-first search, traversing children in lexicographical order. The algorithm is deterministic and invariant to the order in which tasks and dependencies are listed, so reordering tasks in a toastfile will not invalidate the cache. Furthermore, `toast foo bar` and `toast bar foo` are guaranteed to produce identical schedules to maximize cache utilization.\n\nFor each task in the schedule, Toast first computes a cache key based on a hash of the shell command, the contents of the `input_paths`, the cache key of the previous task in the schedule, etc. Toast will then look for a Docker image tagged with that cache key. If the image is found, Toast will skip the task. Otherwise, Toast will create a container, copy any `input_paths` into it, run the shell command, copy any `output_paths` from the container to the host, commit the container to an image, and delete the container. The image is tagged with the cache key so the task can be skipped for subsequent runs.\n\nToast aims to make as few assumptions about the container environment as possible. Toast only assumes there is a program at `/bin/su` which can be invoked as `su -c COMMAND USER`. This program is used to run commands for tasks in the container as the appropriate user with their preferred shell. Every popular Linux distribution has a `su` utility that supports this usage. Toast has integration tests to ensure it works with popular base images such as `debian`, `alpine`, `busybox`, etc.\n\n## Toastfiles\n\nA *toastfile* is a YAML file (typically named `toast.yml`) that defines tasks and their dependencies. The schema contains three top-level keys:\n\n```yaml\nimage:   <Docker image name with optional tag or digest>\ndefault: <name of default task to run or `null` to run all tasks by default>\ntasks:   <map from task name to task>\n```\n\nTasks have the following schema and defaults:\n\n```yaml\ndescription: null     # A description of the task for the `--list` option\ndependencies: []      # Names of dependencies\ncache: true           # Whether a task can be cached\nenvironment: {}       # Map from environment variable to optional default\ninput_paths: []       # Paths to copy into the container\noutput_paths: []      # Paths to copy out of the container\nmount_paths: []       # Paths to mount into the container\nmount_readonly: false # Whether to mount the `mount_paths` as readonly\nports: []             # Port mappings to publish\nlocation: /scratch    # Path in the container for running this task\nuser: root            # Name of the user in the container for running this task\ncommand: \'\'           # Shell command to run in the container\n```\n\nThe [toastfile](https://github.com/stepchowfun/toast/blob/master/toast.yml) for Toast itself is a comprehensive real-world example.\n\n## Cache configuration\n\nToast supports local and remote caching. By default, only local caching is enabled. Remote caching requires that the Docker Engine is logged into a Docker registry (e.g., via `docker login`).\n\nThe caching behavior can be customized with a configuration file. The default location of the configuration file depends on the operating system:\n\n- For macOS, the default location is `~/Library/Preferences/toast/toast.yml`.\n- For other Unix platforms, Toast follows the [XDG Base Directory Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html). The default location is `~/.config/toast/toast.yml` unless overridden by the `XDG_CONFIG_HOME` environment variable.\n\nThe configuration file has the following schema and defaults:\n\n```yaml\ndocker_repo: toast        # Docker repository\nread_local_cache: true    # Whether Toast should read from local cache\nwrite_local_cache: true   # Whether Toast should write to local cache\nread_remote_cache: false  # Whether Toast should read from remote cache\nwrite_remote_cache: false # Whether Toast should write to remote cache\n```\n\nEach of these options can be overridden via command-line options (see [below](#command-line-options)).\n\nA typical configuration for a CI environment will enable all forms of caching, whereas for local development you may want to set `write_remote_cache: false` to avoid waiting for remote cache writes. See [`.travis.yml`](https://github.com/stepchowfun/toast/blob/master/.travis.yml) for a complete example of how to use Toast in a CI environment.\n\n## Command-line options\n\nBy default, Toast looks for a toastfile called `toast.yml` in the working directory, then in the parent directory, and so on. Any paths in the toastfile are relative to where the toastfile lives, not the working directory. This means you can run Toast from anywhere in your project and get the same results.\n\nRun `toast` with no arguments to execute the default task, or all the tasks if the toastfile doesn\'t define a default. You can also execute specific tasks and their dependencies:\n\n```sh\ntoast task1 task2 task3\xe2\x80\xa6\n```\n\nHere are all the supported command-line options:\n\n```\nUSAGE:\n    toast [OPTIONS] [TASKS]...\n\nOPTIONS:\n    -c, --config-file <PATH>\n            Sets the path of the config file\n\n    -f, --file <PATH>\n            Sets the path to the toastfile\n\n    -h, --help\n            Prints help information\n\n    -l, --list\n            Lists the tasks in the toastfile\n\n        --read-local-cache <BOOL>\n            Sets whether local cache reading is enabled\n\n        --read-remote-cache <BOOL>\n            Sets whether remote cache reading is enabled\n\n    -r, --repo <REPO>\n            Sets the Docker repository\n\n    -s, --shell\n            Drops you into a shell after the tasks are finished\n\n    -v, --version\n            Prints version information\n\n        --write-local-cache <BOOL>\n            Sets whether local cache writing is enabled\n\n        --write-remote-cache <BOOL>\n            Sets whether remote cache writing is enabled\n```\n\n## Requirements\n\n- Toast requires [Docker Engine](https://www.docker.com/products/docker-engine) 17.06.0 or later.\n- Only Linux-based Docker images are supported. Toast can run on any Unix-based platform capable of running such images, e.g., macOS with [Docker Desktop](https://www.docker.com/products/docker-desktop).\n\n## Acknowledgements\n\nToast was inspired by an in-house tool used at Airbnb for CI jobs. The design was heavily influenced by the lessons I learned working on that tool and building out Airbnb\'s CI system with the fabulous CI Infrastructure Team.\n\nSpecial thanks to Julia Wang ([@juliahw](https://github.com/juliahw)) for valuable early feedback. Thanks to her and Mark Tai ([@marktai](https://github.com/marktai)) for coming up with the name *Toast*.\n\nThe terminal animations were produced with [asciinema](https://asciinema.org/) and [svg-term-cli](https://github.com/marionebl/svg-term-cli).\n'