b'**straight.el**: next-generation, purely functional package manager\nfor the [Emacs] hacker.\n\n**Please check out the [FAQ][#faq] and [news][#news] :)**\n\n[![Build status][travis-badge]][travis-build] [![Gitter\nchat][gitter-badge]][gitter]\n\n<!-- longlines-start -->\n\n<!-- toc -->\n\n- [Features](#features)\n- [Guiding principles](#guiding-principles)\n- [Getting started](#getting-started)\n    + [Debugging](#debugging)\n  * [Install packages](#install-packages)\n  * [But what about my fork of (obscure .el package)?](#but-what-about-my-fork-of-obscure-el-package)\n  * [Integration with `use-package`](#integration-with-use-package)\n  * [Edit packages locally](#edit-packages-locally)\n  * [Automatic repository management](#automatic-repository-management)\n  * [Configuration reproducibility](#configuration-reproducibility)\n- [Conceptual overview](#conceptual-overview)\n  * [TL;DR](#tldr)\n  * [What is a package?](#what-is-a-package)\n  * [Where do packages come from?](#where-do-packages-come-from)\n  * [What does this look like on disk?](#what-does-this-look-like-on-disk)\n  * [Where do repositories come from?](#where-do-repositories-come-from)\n  * [What does it mean to load a package?](#what-does-it-mean-to-load-a-package)\n  * [Where do recipes come from?](#where-do-recipes-come-from)\n  * [What happens when I call `straight-use-package`?](#what-happens-when-i-call-straight-use-package)\n  * [What does it mean to register a package?](#what-does-it-mean-to-register-a-package)\n  * [How does `straight.el` know when to rebuild packages?](#how-does-straightel-know-when-to-rebuild-packages)\n  * [How does `straight.el` know what packages are installed?](#how-does-straightel-know-what-packages-are-installed)\n- [Comparison to other package managers](#comparison-to-other-package-managers)\n  * [TL;DR](#tldr-1)\n  * [Comparison to `package.el`](#comparison-to-packageel)\n    + [Advantages of `straight.el`](#advantages-of-straightel)\n    + [Advantages of `package.el`](#advantages-of-packageel)\n    + [Additional notes](#additional-notes)\n  * [Comparison to Quelpa](#comparison-to-quelpa)\n    + [Advantages of `straight.el`](#advantages-of-straightel-1)\n    + [Advantages of Quelpa](#advantages-of-quelpa)\n    + [Additional notes](#additional-notes-1)\n  * [Comparison to Cask](#comparison-to-cask)\n    + [Advantages of `straight.el`](#advantages-of-straightel-2)\n    + [Advantages of Cask](#advantages-of-cask)\n  * [Comparison to el-get](#comparison-to-el-get)\n    + [Advantages of `straight.el`](#advantages-of-straightel-3)\n    + [Advantages of el-get](#advantages-of-el-get)\n  * [Comparison to Borg](#comparison-to-borg)\n    + [Advantages of `straight.el`](#advantages-of-straightel-4)\n    + [Advantages of Borg](#advantages-of-borg)\n  * [Comparison to the manual approach](#comparison-to-the-manual-approach)\n    + [Advantages of `straight.el`](#advantages-of-straightel-5)\n    + [Advantages of the manual approach](#advantages-of-the-manual-approach)\n- [User manual](#user-manual)\n  * [Bootstrapping `straight.el`](#bootstrapping-straightel)\n  * [Installing packages programmatically](#installing-packages-programmatically)\n    + [Installing with a custom recipe](#installing-with-a-custom-recipe)\n    + [Additional arguments to `straight-use-package`](#additional-arguments-to-straight-use-package)\n    + [Variants of `straight-use-package`](#variants-of-straight-use-package)\n    + [Customizing when packages are built](#customizing-when-packages-are-built)\n      - [Custom or manual modification detection](#custom-or-manual-modification-detection)\n      - [Summary of options for package modification detection](#summary-of-options-for-package-modification-detection)\n        * [`find-at-startup`](#find-at-startup)\n        * [`check-on-save`](#check-on-save)\n        * [`watch-files`](#watch-files)\n    + [Customizing how packages are built](#customizing-how-packages-are-built)\n    + [Customizing how packages are made available](#customizing-how-packages-are-made-available)\n    + [Hooks run by `straight-use-package`](#hooks-run-by-straight-use-package)\n  * [The recipe format](#the-recipe-format)\n    + [Version-control backends](#version-control-backends)\n    + [Git backend](#git-backend)\n      - [Deprecated `:upstream` keyword](#deprecated-upstream-keyword)\n  * [Recipe lookup](#recipe-lookup)\n    + [Updating recipe repositories](#updating-recipe-repositories)\n    + [Customizing recipe repositories](#customizing-recipe-repositories)\n      - [GNU ELPA](#gnu-elpa)\n      - [Emacsmirror](#emacsmirror)\n      - [Defining new recipe repositories](#defining-new-recipe-repositories)\n  * [Overriding recipes](#overriding-recipes)\n    + [Overriding the recipe for `straight.el`](#overriding-the-recipe-for-straightel)\n  * [Interactive usage](#interactive-usage)\n    + [Version control operations](#version-control-operations)\n  * [Lockfile management](#lockfile-management)\n    + [The profile system](#the-profile-system)\n  * [Packages and the init-file](#packages-and-the-init-file)\n  * [Using `straight.el` to reproduce bugs](#using-straightel-to-reproduce-bugs)\n  * [Integration with other packages](#integration-with-other-packages)\n    + [Integration with `use-package`](#integration-with-use-package-1)\n    + ["Integration" with `package.el`](#integration-with-packageel)\n    + [Integration with Org](#integration-with-org)\n    + [Integration with Hydra](#integration-with-hydra)\n  * [Miscellaneous](#miscellaneous)\n- [Developer manual](#developer-manual)\n- [Trivia](#trivia)\n  * [Comments and docstrings](#comments-and-docstrings)\n- [Contributing](#contributing)\n- [FAQ](#faq)\n  * [My init time got slower](#my-init-time-got-slower)\n  * [How do I update MELPA et al.?](#how-do-i-update-melpa-et-al)\n  * [The wrong version of my package was loaded](#the-wrong-version-of-my-package-was-loaded)\n  * [I get "could not read username/password" errors](#i-get-could-not-read-usernamepassword-errors)\n  * [The interactive version-control operations are confusing](#the-interactive-version-control-operations-are-confusing)\n  * [How do I pin package versions or use only tagged releases?](#how-do-i-pin-package-versions-or-use-only-tagged-releases)\n  * [How can I use the built-in version of a package?](#how-can-i-use-the-built-in-version-of-a-package)\n- [News](#news)\n  * [July 6, 2019](#july-6-2019)\n  * [May 24, 2019](#may-24-2019)\n  * [May 22, 2019](#may-22-2019)\n  * [May 1, 2019](#may-1-2019)\n  * [March 15, 2019](#march-15-2019)\n  * [December 22, 2018](#december-22-2018)\n  * [September 12, 2018](#september-12-2018)\n  * [July 19, 2018](#july-19-2018)\n  * [July 12, 2018](#july-12-2018)\n\n<!-- tocstop -->\n\n<!-- longlines-stop -->\n\n## Features\n\n* Install Emacs packages listed on [MELPA], [GNU ELPA][gnu-elpa], or\n  [Emacsmirror], or provide your own recipes.\n* Packages are cloned as Git (or other) repositories, not as opaque\n  tarballs.\n* Make changes to a package simply by editing its source code, no\n  additional steps required. Contribute upstream just by pushing your\n  changes.\n* Powerful interactive workflows (with popups \xc3\xa0 la Magit) for\n  performing bulk maintenance on the Git repositories for your\n  packages.\n* Save and load version lockfiles that ensure 100% reproducibility for\n  your Emacs configuration. Package state is defined entirely by your\n  init-file and (optional) lockfile, with no extra persistent data\n  floating around.\n* Specify package descriptions using a powerful recipe format that\n  supports everything from [MELPA recipes][melpa-recipe-format] and\n  more.\n* [`use-package`][use-package] integration.\n* Modular: you can install your packages manually and straight.el will\n  load them for you. Or you can also have straight.el install your\n  packages, while you provide the recipes explicitly. Or straight.el\n  can also fetch recipes, if you want. Bulk repository management and\n  package updates are also optional.\n* Extensible APIs to add new recipe sources and version-control\n  backends.\n* The cleanest source code you\'ve ever seen. [45%][#trivia/comments]\n  of `straight.el` is comments and docstrings.\n\n## Guiding principles\n\n* Init-file and version lockfiles as the sole source of truth. No\n  persistent state kept elsewhere.\n* 100% reproducible package management, accounting for changes in\n  packages, recipe repositories, configuration, and the package\n  manager itself.\n* No support whatsoever for `package.el`.\n* Edit packages by editing their code, no extra steps required. Allow\n  for manual version control operations.\n* Compatibility with MELPA, GNU ELPA, and Emacsmirror.\n* Trivial to quickly try out a package without permanently installing\n  it.\n* Good for reproducing an issue with `emacs -Q`.\n\n## Getting started\n\n> **Note: `straight.el` supports a minimum version of Emacs 24.5, and\n> works on macOS, Windows, and most flavors of Linux.**\n\nFirst, place the following bootstrap code in your init-file:\n\n<!-- longlines-start -->\n\n    (defvar bootstrap-version)\n    (let ((bootstrap-file\n           (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))\n          (bootstrap-version 5))\n      (unless (file-exists-p bootstrap-file)\n        (with-current-buffer\n            (url-retrieve-synchronously\n             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"\n             \'silent \'inhibit-cookies)\n          (goto-char (point-max))\n          (eval-print-last-sexp)))\n      (load bootstrap-file nil \'nomessage))\n\n<!-- longlines-stop -->\n\nHere are some variables you may be interested in (some of them must be\nset **before** the bootstrap code runs, if they might affect how\n`straight.el` itself is loaded):\n\n* [`straight-repository-branch`][#user/overriding/straight.el] -- to\n  get the latest version of `straight.el` from the `develop` branch,\n  rather than the default `master` which is updated less frequently\n  but which is ostensibly more stable.\n* [`straight-check-for-modifications`][#user/install/mod-detection] --\n  to configure an alternate way for `straight.el` to check for\n  modifications made to package source code, rather than the default\n  (which is 100% reliable, but has a minor cost to startup time).\n* [`straight-use-package-by-default`][#user/integration/use-package]\n  -- if you use [`use-package`][use-package], then this makes each\n  `use-package` form also invoke `straight.el` to install the package,\n  unless otherwise specified.\n* [`straight-vc-git-default-protocol`][#user/recipes/git] -- by\n  default, `straight.el` clones over HTTPS. If you need packages from\n  private Git repositories in your configuration, then you might want\n  to use SSH instead.\n\nYou should remove any code that relates to `package.el`; for example,\nreferences to `package-initialize`, `package-archives`, and (if you\'re\nusing [`use-package`][use-package]) `:ensure` or\n`use-package-always-ensure`. While it is technically possible to use\nboth `package.el` and `straight.el` at the same time, there is no real\nreason to, and it might result in oddities like packages getting\nloaded more than once.\n\n#### Debugging\n\nOn macOS, you may receive an error:\n\n    Could not create connection to raw.githubusercontent.com:443\n\nThere are two ways to solve this problem. One way is to install a\nversion of Emacs that is linked with GnuTLS. The [Homebrew] formula\nfor Emacs was recently updated to link with GnuTLS by default, so you\nneed only do this:\n\n    $ brew upgrade emacs\n\nThe other way is to let Emacs use certificates provided by LibreSSL,\nwhich you can do by running this command:\n\n    $ brew install gnutls libressl\n\nAnd adding this to your init-file, *before* the bootstrap snippet:\n\n    (with-eval-after-load \'gnutls\n      (add-to-list \'gnutls-trustfiles "/usr/local/etc/libressl/cert.pem"))\n\n### Install packages\n\nOut of the box, you can install any package listed on [MELPA], [GNU\nELPA][gnu-elpa], or [Emacsmirror], which is to say any package in\nexistence. (Although MELPA is used as a package listing, packages are\ninstalled by cloning their Git repositories rather than by downloading\ntarballs like `package.el` does.) To install a package temporarily\n(until you restart Emacs), run `M-x straight-use-package` and select\nthe package you want. To install a package permanently, place a call\nto `straight-use-package` in your init-file, like:\n\n    (straight-use-package \'el-patch)\n\nNote that installing a package will activate all of its autoloads, but\nit will not actually `require` the features provided by the package.\nThis means that you might need to use `require` or `autoload` for some\nantiquated packages that do not properly declare their autoloads.\n\nTo learn more, see the documentation on [the package\nlifecycle][#user/install].\n\n### But what about my fork of (obscure .el package)?\n\nInstead of passing just a package name to `straight-use-package`, you\ncan pass a list ("recipe"). You can see the default recipe for any\ngiven package by running `M-x straight-get-recipe`. For example, the\nrecipe for `el-patch` is:\n\n    (el-patch :type git :host github :repo "raxod502/el-patch")\n\nSo, if you have forked `el-patch` and you want to use your fork\ninstead of the upstream, do:\n\n    (straight-use-package\n     \'(el-patch :type git :host github :repo "your-name/el-patch"))\n\nIn fact, `straight.el` has explicit support for using a forked\npackage, since this is so common:\n\n    (straight-use-package\n     \'(el-patch :type git :host github :repo "raxod502/el-patch"\n                :fork (:host github\n                       :repo "your-name/el-patch")))\n\nYou may also omit the `:type git` if you leave `straight-default-vc`\nat its default value of `git`.\n\nTo learn more, see the documentation on [the recipe\nformat][#user/recipes].\n\n### Integration with `use-package`\n\n[`use-package`][use-package] is a macro that provides convenient\nsyntactic sugar for many common tasks related to installing and\nconfiguring Emacs packages. Of course, it does not actually install\nthe packages, but instead defers to a package manager, like\n`straight.el` (which comes with `use-package` integration by default).\n\nTo use `use-package`, first install it with `straight.el`:\n\n    (straight-use-package \'use-package)\n\nNow `use-package` will use `straight.el` to automatically install\nmissing packages if you provide `:straight t`:\n\n    (use-package el-patch\n      :straight t)\n\nYou can still provide a custom recipe for the package:\n\n    (use-package el-patch\n      :straight (el-patch :type git :host github :repo "raxod502/el-patch"\n                          :fork (:host github\n                                 :repo "your-name/el-patch")))\n\nSpecifying `:straight t` is unnecessary if you set\n`straight-use-package-by-default` to a non-nil value. (Note that the\nvariable `use-package-always-ensure` is associated with `package.el`,\nand you should not use it with `straight.el`.)\n\nTo learn more, see the documentation on [`straight.el`\'s `use-package`\nintegration][#user/integration/use-package].\n\n### Edit packages locally\n\nOne of the biggest strengths of `straight.el` is that editing packages\nlocally is trivial. You literally just edit the files (`find-function`\nand friends all work as you would expect). Packages will be\nautomatically rebuilt if necessary when Emacs next starts up.\n\nYou can even commit your changes and push or pull to various remotes\nusing Git. You have complete control over your packages\' Git\nrepositories.\n\nTo learn more, see the documentation on [the package\nlifecycle][#user/install].\n\n### Automatic repository management\n\nWhile being able to make arbitrary changes to your packages is very\npowerful, it can also get tiring to keep track of the all those\nchanges. For this reason, `straight.el` provides a suite of powerful\ninteractive workflows to perform bulk operations on your packages.\n\n* To restore each package to its canonical state (a clean working\n  directory with the main branch checked out, and the remotes set\n  correctly), run `M-x straight-normalize-package` or `M-x\n  straight-normalize-all`.\n\n* To fetch from each package\'s configured remote, run `M-x\n  straight-fetch-package-and-deps` or `M-x straight-fetch-all`; to\n  also fetch from the upstream for forked packages, supply a prefix\n  argument.\n\n* To merge changes from each package\'s configured remote, run `M-x\n  straight-merge-package-and-deps` or `M-x straight-merge-all`; to\n  also merge from the upstream for forked packages, supply a prefix\n  argument.\n\n* To push all local changes to each package\'s configured remote, run\n  `M-x straight-push-package` or `M-x straight-push-all`.\n\nAll of these commands are highly interactive and ask you before making\nany changes. At any point, you can stop and perform manual operations\nwith Magit or other tools in a recursive edit.\n\nTo learn more, see the documentation on [bulk repository\nmanagement][#user/interactive/vc].\n\n### Configuration reproducibility\n\nTo save the currently checked out revisions of all of your packages,\nrun `M-x straight-freeze-versions`. The resulting file\n(`~/.emacs.d/straight/versions/default.el`), together with your\ninit-file, perfectly define your package configuration. Keep your\nversion lockfile checked into version control; when you install your\nEmacs configuration on another machine, the versions of packages\nspecified in your lockfile will automatically be checked out after the\npackages are installed. You can manually revert all packages to the\nrevisions specified in the lockfile by running `M-x\nstraight-thaw-versions`.\n\nTo learn more, see the documentation on [version\nlockfiles][#user/lockfiles].\n\n## Conceptual overview\n\nThis section describes, at a high level, how the different mechanisms\nin `straight.el` play together. This illustrates how `straight.el`\nmanages to accomplish all of its [guiding principles][#principles].\n\n### TL;DR\n\n`straight.el` operates by cloning Git repositories and then symlinking\nfiles into Emacs\' load path. The collection of symlinked files\nconstitutes the package, which is defined by its recipe. The recipe\nalso describes which local repository to link the files from, and how\nto clone that repository, if it is absent.\n\nWhen you call `straight-use-package`, the recipe you provide is\nregistered with `straight.el` for future reference. Then the package\'s\nrepository is cloned if it is absent, the package is rebuilt if its\nfiles have changed since the last build (as determined by `find(1)`),\nand its autoloads are evaluated.\n\nYou can also provide only a package name, in which case the recipe\nwill be looked up in one of several configurable recipe repositories,\nwhich are just packages themselves (albeit with the build step\ndisabled).\n\n`straight.el` determines which packages are installed solely by how\nand when `straight-use-package` is invoked in your init-file.\n\n### What is a package?\n\nA *package* is a collection of Emacs Lisp (and possibly other) files.\nThe most common case is just a single `.el` file, but some packages\nhave many `.el` files, and some even have a directory structure.\n\nNote that a package is defined only as a collection of files. It\ndoesn\'t necessarily correspond to a Git repository, or an entry on\nMELPA, or anything like that. Frequently there is a relationship\nbetween all of these concepts, but that relationship does not always\nhave to be direct or one-to-one.\n\nA package also has a name, which must be unique. This is the name that\nis used for the folder holding the package\'s files. It is frequently\nthe same as the name of a Git repository, or an entry on MELPA, but\nagain this does not have to be the case.\n\n### Where do packages come from?\n\nIf you really wanted all of your packages to be unambiguously defined,\nyou could just copy and paste all of their files into version control.\nBut that would defeat the purpose of using a package manager like\n`straight.el`. In `straight.el`, packages are defined by two sources\nof information:\n\n* a *local repository*\n* a *build recipe*\n\nThe local repository is just a directory containing some files. Of\ncourse, it also has a name, which may or may not be the same as the\npackage\'s name. Frequently, the local repository is also a Git\nrepository, but this is not necessary.\n\nThe build recipe is not a literal data structure. It is a concept that\nrepresents a certain subset of the package\'s recipe. Specifically, the\n`:files`, `:local-repo`, and `:no-build` keywords.\n\nTo transform this *information* into an actual package that Emacs can\nload, `straight.el` *builds* the package. This means that some\nsymbolic links are created in the package\'s directory that point back\ninto the local repository\'s directory. Exactly how these symlinks are\ncreated is determined by the `:files` directive, and which local\nrepository the symlinks point to is determined by the `:local-repo`\ndirective.\n\nAfter the symlinks are created, the resulting files are byte-compiled,\nand their autoloads are generated and written into a file in the\npackage\'s directory.\n\nIf `:no-build` is specified, however, this entire process is skipped.\nThis mechanism is used for recipe repositories.\n\n### What does this look like on disk?\n\nThe local repositories are kept in `~/.emacs.d/straight/repos`, and\nthe built packages are kept in `~/.emacs.d/straight/build`. If you\nhave initialized `straight.el` and loaded package `el-patch`, then\nyour `~/.emacs.d/straight` directory will look roughly like this (some\nirrelevant details have been omitted for pedagogical purposes):\n\n<!-- longlines-start -->\n\n    straight\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 build\n    \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 el-patch\n    \xe2\x94\x82   \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 el-patch-autoloads.el\n    \xe2\x94\x82   \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 el-patch.el -> ~/.emacs.d/straight/repos/el-patch/el-patch.el\n    \xe2\x94\x82   \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 el-patch.elc\n    \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 straight\n    \xe2\x94\x82       \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 straight-autoloads.el\n    \xe2\x94\x82       \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 straight.el -> ~/.emacs.d/straight/repos/straight.el/straight.el\n    \xe2\x94\x82       \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 straight.elc\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 repos\n        \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 el-patch\n        \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 CHANGELOG.md\n        \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 LICENSE.md\n        \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 README.md\n        \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 el-patch.el\n        \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 straight.el\n            \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 LICENSE.md\n            \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 Makefile\n            \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 README.md\n            \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 bootstrap.el\n            \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 install.el\n            \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 straight.el\n\n<!-- longlines-stop -->\n\nAs you can see, the package names are `el-patch` and `straight`. While\n`el-patch` is built from a local repository of the same name,\n`straight` is built from a local repository by the name `straight.el`.\nAlso note that only `.el` files are symlinked, since only they are\nrelevant to Emacs.\n\n### Where do repositories come from?\n\nLocal repositories provide a way to define packages without specifying\nthe contents of all of their files explicitly. But that\'s not helpful\nwithout a higher-level way to define local repositories without\nspecifying the contents of all of *their* files. In `straight.el`,\nlocal repositories are defined by two sources of information:\n\n* a *fetch recipe*\n* the *version lockfiles*\n\nThe fetch recipe is, like the build recipe, a concept representing a\ncertain subset of the package\'s overall recipe. The situation is more\ninteresting here because `straight.el` supports multiple\nversion-control backends. The version-control backend specified by the\nfetch recipe is determined by the `:type` directive (which defaults to\n`straight-default-vc`). Each version-control backend then accepts some\nset of additional directives. For example, the `git` backend accepts:\n\n* `:repo`\n* `:host`\n* `:branch`\n* `:nonrecursive`\n* `:fork`\n\nIf a local repository is not present, then its fetch recipe describes\nhow to obtain it. This is done using the `straight-vc-clone` function,\nwhich delegates to one of the backend implementations of the `clone`\noperation, according to `:type`. (The option `:type built-in` is a\nspecial case that results in all version-control operations for the\npackage being ignored.)\n\nHowever, even with a particular repository source specified, there is\nstill the question of which version of the repository to use. This is\nwhere the version lockfiles come in. When a local repository is\ncloned, the version lockfiles are searched to see if there is a\nparticular commit specified for that local repository\'s name. If so,\nthat commit is checked out. (For the `git` backend, commits are\n40-character strings representing SHA-1 hashes, but the representation\nof a commit identifier could be different across different backends.)\n\nThe `straight-freeze-versions` and `straight-thaw-versions` methods\nalso use backend-delegating methods; in this case, they are\n`straight-vc-get-commit` and `straight-vc-check-out-commit`.\n\nThe fetch recipe and version lockfiles, together with the\nconfiguration options for `straight.el`, precisely define the state of\na local repository. Of course, you may make any changes you want to\nthe local repository. But this information defines a "canonical" state\nthat you may revert to at any time.\n\nWhen this information is combined with the build recipe, `straight.el`\nis able to construct canonical, universal versions of your Emacs\npackages that will be the same everywhere and forever.\n\nNote that you do not have to provide fetch recipes or version\nlockfiles. You may manage your local repositories manually, if you\nwish, although this has obvious disadvantages in terms of\nrepeatability and maintainability.\n\n### What does it mean to load a package?\n\nA prerequisite to loading a package is making sure the package has\nbeen built. After that is done, loading the package means adding its\ndirectory to the load path and evaluating its autoloads file.\n\nAdding the directory to the load path means that you can use `require`\nto load the package\'s files. Note that `straight.el` does not do this\nfor you, since loading packages immediately is usually not necessary\nand it immensely slows down Emacs startup.\n\nEvaluating the autoloads file means that calling the functions that\nare defined in the autoloads file will automatically `require` the\nfiles that define those functions. All modern packages define their\nfunctions in autoloads and are designed to be loaded on-demand when\nthose functions are called. Antiquated packages may need you to\nexplicitly define autoloads, or to just `require` the package right\naway.\n\n### Where do recipes come from?\n\n`straight-use-package` does not require an actual recipe. You can just\ngive it a package name, and it will look up the recipe. This is done\nusing *recipe repositories*. Recipe repositories are set up as a\nswappable backend system, much like the version-control backend\nsystem.\n\nA recipe repository consists of four parts:\n\n* a fetch recipe for the local repository (this will typically include\n  the `:no-build` directive, since recipe repositories usually do not\n  need to be built)\n* a function that, provided the local repository is already available,\n  returns a list of all packages that have recipes in the recipe\n  repository\n* a function that, given a package name, returns the recipe for that\n  package, or nil if the recipe repository does not provide a recipe\n  for the package\n* an entry in `straight-recipe-repositories` indicating that the\n  recipe provided actually corresponds to a recipe repository\n  (otherwise it would just be a regular package)\n\nNote that recipe repositories are implemented as regular packages!\nThis means that all the usual package management operations work on\nthem as well. It also means that you use `straight-use-package` to\nregister them (although typically you will provide arguments to\n`straight-use-package` so that the recipe repository is only\nregistered, and not cloned until it is needed; see [the section on\n`straight-use-package`][#concepts/straight-use-package]).\n\nIf you give `straight-use-package` just a package name, then each\nrecipe repository in `straight-recipe-repositories` is checked for a\nrecipe for that package. Once one is found, it is used. Otherwise, an\nerror is signaled (unless the package is built-in to Emacs, according\nto `package.el`).\n\nNote that `straight.el` uses its own recipe format which is similar,\nbut not identical, to the one used by MELPA. The recipe repository\nbackends abstract over the formatting differences in different recipe\nsources to translate recipes into the uniform format used by\n`straight.el`. When you run `M-x straight-get-recipe`, the translated\nrecipe is what is returned.\n\n### What happens when I call `straight-use-package`?\n\nThere are three actions that `straight-use-package` can take:\n\n* Register a package\'s recipe with `straight.el`.\n* Clone a package\'s local repository, if it is missing.\n* Build a package, if it has been changed since the last time it was\n  built, and load it.\n\nThese actions must be performed in order. Depending on the arguments\nyou pass to `straight-use-package`, one, two, or all three may be\nperformed.\n\nThe normal case is to do all three. The fetch recipe is only required\nif the local repository is actually missing, but the build recipe is\nalways required.\n\nDeferred installation can be accomplished by telling\n`straight-use-package` to stop if the local repository is not already\navailable. The deferred installation can be triggered by invoking\n`straight-use-package` again, but telling it to go ahead and clone the\nrepository (this is the default behavior). Because\n`straight-use-package` already registered the package\'s recipe the\nfirst time, you don\'t have to provide it again.\n\nIn some extraordinary circumstances (such as when `straight.el` is\nbootstrapping its own installation), it may be desirable to clone a\npackage\'s local repository if it is missing, but to stop before\nbuilding and loading the package. This can also be done by\n`straight-use-package`.\n\n### What does it mean to register a package?\n\nPackage registration is the first action taken by\n`straight-use-package`, before building and cloning. First, if only a\npackage name was provided to `straight-use-package`, a recipe is\nobtained from the configured recipe repositories. Next, the resulting\nrecipe is recorded in various caches.\n\nThis is important, since it allows for several things to happen:\n\n* if you later want to perform another operation on the package using\n  `straight.el`, you do not need to provide the recipe again\n* if you use a custom recipe for Package A, and Package B requires\n  Package A as a dependency, your custom recipe is remembered and\n  re-used when Package A is used as a dependency, to avoid conflicts.\n* when multiple packages are built from the same local repository, and\n  you have specified a custom fetch recipe for one of those packages,\n  `straight.el` can intelligently merge that fetch recipe into the\n  automatically retrieved recipes of dependencies, in order to avoid\n  conflicts.\n* `straight.el` knows which packages you have installed, if you want\n  to perform interactive operations on them.\n* if you accidentally provide two different recipes for the same\n  package, `straight.el` can issue a helpful warning, since this may\n  lead to surprising behavior.\n\n### How does `straight.el` know when to rebuild packages?\n\nWhen you request for `straight.el` to load a package (using\n`straight-use-package`), it first checks if the package needs to be\nrebuilt. This means that some of the files in its local repository\nhave been modified since the last time the package was built.\n`straight.el` uses an optimized `find(1)` command to check for package\nmodifications, and it uses some caching mechanisms to perform bulk\n`find(1)` operations on multiple packages, to speed up these checks\n(although it never performs optimizations that may result in erroneous\nbehavior).\n\nThis check occurs during Emacs init, when your init-file makes calls\nto `straight-use-package`. You may notice a significant delay on the\nfirst `straight-use-package` call, because this is when `straight.el`\nperforms a bulk `find(1)` call and caches the results for later usage\n(this speeds up init considerably). The total delay is likely to be on\nthe order of 100ms for a double-digit number of packages.\n\nThe rebuild detection system is what allows for you to make changes to\npackages whenever you would like, without performing any additional\noperations.\n\n(Packages are also rebuilt when their recipes change, of course.)\n\n### How does `straight.el` know what packages are installed?\n\n`straight.el` does not require you to declare a central list of\npackages anywhere, like Cask does. Instead, it determines what\npackages are to be loaded implicitly, by your invocations of\n`straight-use-package` during Emacs initialization. Furthermore,\n`straight.el` allows you to install packages after initialization\nusing `M-x straight-install-package` (or even by evaluating\n`straight-use-package` forms). However, `straight.el` still provides\nadvanced features such as bulk package management and version locking.\nThis creates some interesting challenges which other package managers\ndo not have to deal with.\n\n`straight.el` solves these problems using a concept called\n*transactions*. The operation of the transaction system is mostly\ntransparent to the user, at least in recent versions of `straight.el`.\nBasically, it provides a way for `straight.el` to keep track of what\nhappens within a single user operation (e.g. evaluate a buffer of\n`straight-use-package` calls, or load the init-file).\n\n`straight.el` uses the transaction system to keep track of what\npackages you request in your init-file. If you invoke\n`straight-use-package` interactively, then this invalidates that\ninformation, since you have now requested a package that is not in\nyour init-file. For this reason, if you have invoked\n`straight-use-package` interactively, running `M-x\nstraight-freeze-versions` will prompt you to first reload your\ninit-file.\n\n## Comparison to other package managers\n\n(Disclaimer: while I try to be as objective and comprehensive as\npossible here, I\'m obviously biased. Please submit corrections if I\nhave unfairly disparaged your favorite package manager!)\n\nThere are many package managers for Emacs, ranging from simple scripts\nto download files from EmacsWiki to full-featured package management\nsolutions like `straight.el`. Here are the most feature-rich\nalternatives to `straight.el`:\n\n* [`package.el`][package.el]: de facto standard, bundled with Emacs.\n* [Quelpa]: allows you to use external sources like GitHub with\n  `package.el`. Essentially a local [MELPA].\n* [Cask]: another `package.el` wrapper. Specify your dependencies in a\n  `Cask` file; can be used for project management or an Emacs\n  configuration.\n* [el-get]: ridiculously OP in terms of how many different sources you\n  can pull packages from (`package.el`, every known VCS, distro\n  package managers, `go get`(!!)).\n* [Borg]: assimilates packages as Git submodules into `.emacs.d`,\n  relying on [Emacsmirror].\n* "Screw package managers! I\'ll just handle it all myself!"\n\n### TL;DR\n\nHere is a summary of the main differences in philosophy between the\npackage managers:\n\n* Use `package.el` if you want package management to be as easy as\n  possible, and do not much care for installing packages from specific\n  sources, keeping track of their versions, or doing local development\n  on them.\n* Use Quelpa if you like `package.el` but really wish you could\n  specify the sources of your packages.\n* Use Cask if you like `package.el` but wish it came with some project\n  management tools, as well.\n* Use el-get if you want to easily install packages from as many\n  different sources as possible.\n* Use Borg if you like a more lightweight approach to package\n  management that leverages existing solutions, if contributing\n  changes to packages upstream is important to you, and if using Git\n  submodules isn\'t a deal-breaker.\n* Use the manual approach if you need to contribute changes to a\n  package that is versioned in something other than Git.\n* Use `straight.el` if you like reproducibility in your Emacs\n  configuration, you regularly contribute changes to packages\n  upstream, you think deferred installation is a really great idea, or\n  you are writing an Emacs configuration to be used by others.\n\nAnd here is a brief list of the main reasons you might not want to use\n`straight.el`:\n\n* `straight.el` is largely unusable if you do not have Git installed,\n  although it is still possible to use the package-building features\n  if you manage your repositories manually (you also cannot use the\n  magic bootstrap snippet, in that case). If you don\'t want to install\n  Git, you\'ll have to use `package.el` or take the manual approach.\n* `straight.el` is not built in to Emacs. If you want something that\n  will work right out of the box, you\'re stuck with `package.el` or\n  the manual approach.\n* `straight.el` takes a minute or two to update all your packages,\n  since it does not rely on a centralized server. If you want quick\n  update checking, you\'ll have to use `package.el`.\n* `straight.el` does not provide any user interface for package\n  management. For that, you\'ll have to use `package.el`, el-get, Cask,\n  or Borg (which expects you to use [`epkg`][epkg] for browsing\n  packages).\n* `straight.el` does not currently support using only stable versions\n  of packages (i.e. tagged revisions), although this is a [planned\n  feature][#31]. If this is important to you, you probably want to go\n  with `package.el` (with GNU ELPA and MELPA Stable), Cask, or Quelpa.\n* `straight.el` does not currently support arbitrary build commands\n  like `make`, although this is a [planned feature][#72]. This feature\n  is supported by el-get and Borg.\n* If you don\'t like having to modify your init-file to do package\n  management, then `straight.el` is absolutely not for you. You want\n  `package.el`, Quelpa, el-get, or Borg.\n* If you really want to contribute changes to packages that are not\n  versioned in Git, then `straight.el` will not help you. You\'ll have\n  to manage the package\'s repository manually. Unfortunately, there is\n  no existing package manager that supports both non-Git\n  version-control systems and contributing changes upstream. You\'ll\n  have to go with the manual approach.\n* `straight.el` does not provide project management tools. It is a\n  package manager. If you want project management tools, check out\n  Cask.\n* `straight.el` is quite new and moving fast. Things might break. The\n  other package managers can generally be ranked as follows, from most\n  active to least active: el-get, Quelpa, Borg, Cask, `package.el`\n  (glacial).\n\n### Comparison to `package.el`\n\n* `package.el` downloads pre-built packages from central servers using\n  a special (undocumented?) HTTP protocol, while `straight.el` clones\n  Git (or other) repositories and builds packages locally.\n\n#### Advantages of `straight.el`\n\n* `straight.el` allows you to install a package from any branch of any\n  Git repository. `package.el` only allows you to install a package\n  from a `package.el`-compliant central server.\n* `straight.el` allows you to check out any Git revision of any\n  package. `package.el` only allows you to install the latest version,\n  and there is no way to downgrade.\n* `straight.el` supports Emacsmirror, while `package.el` does not.\n* `straight.el` uses your init-file as the sole source of truth for\n  package operations. `package.el` loads every package you ever\n  installed at startup, even if some of those packages are no longer\n  referenced by your init-file.\n* `straight.el` supports 100% reproducibility for your Emacs packages\n  with version lockfiles. `package.el` cannot provide reproducibility\n  for the set of packages installed, the central servers they were\n  installed from, or the versions in use.\n* `straight.el` allows you to make arbitrary changes to your packages\n  locally. While it is possible to make local changes to `package.el`\n  packages, these changes cannot be version-controlled and they will\n  be silently overwritten whenever `package.el` performs an update.\n* `straight.el` allows you to perform arbitrary version-control\n  operations on your package\'s Git repositories, including\n  contributing changes upstream. `straight.el` has explicit support\n  for specifying both an upstream and a fork for a package.\n  Contributing changes upstream with `package.el` is impossible.\n* `straight.el` is designed with `emacs -Q` bug reports in mind.\n  `package.el` is unsuitable for minimal bug reproductions, since it\n  automatically loads all of your packages on any package operation,\n  even in `emacs -Q`.\n* `straight.el` operates quietly when all is going well. `package.el`\n  displays all messages, errors, and warnings that come from\n  byte-compilation and autoload generation.\n* `straight.el` considers modifying the user\'s init-file extremely\n  uncouth. `package.el` aggressively inserts a call to\n  `package-initialize` into the init-file if it is not already\n  present, whenever any package management operation is performed.\n* `straight.el` has a profile system that allows users of someone\n  else\'s Emacs configuration to manage an additional subset of\n  packages, or to override upstream package configuration, without\n  forking the upstream. `package.el` has no such concept.\n* `straight.el` is developed openly on GitHub, using a modern [issue\n  tracker][issues] and continuous integration from [Travis\n  CI][travis-build]. It welcomes contributions of any type.\n  `straight.el` is licensed under the permissive MIT license and does\n  not require a copyright assignment. `straight.el` is developed\n  actively and has explicit support for installing development\n  versions of itself, as well as for contributing upstream changes.\n  `package.el` is maintained as a part of Emacs core, meaning that the\n  contribution process is poorly documented and discouraging. Releases\n  of `package.el` coincide with releases of Emacs, which are\n  infrequent and inflexible. There is no issue tracker specifically\n  for `package.el`, only the Emacs bug tracker and the emacs-devel\n  mailing list. Contributing to `package.el` requires a\n  poorly-documented, cumbersome copyright assignment process and is\n  done by submitting patches to an antiquated mailing list,\n  unsupported by modern code review tooling or continuous integration.\n\n#### Advantages of `package.el`\n\n* `package.el` does not require that you have Git installed, since the\n  central server deals with where the packages originally came from.\n  `straight.el` cannot be used at all without Git.\n* `package.el` is built in to Emacs and does not require additional\n  configuration to get started with. `straight.el` requires the use of\n  a 10-line bootstrap snippet in your init-file.\n* `package.el` can perform bulk package updates more quickly since it\n  relies on central servers.\n* `package.el` has a user interface for package management that also\n  displays package metadata. `straight.el` has no user interface for\n  package management; any UI is provided by the user\'s\n  `completing-read` framework.\n* `package.el` does not require you to touch your init-file to install\n  packages, while `straight.el` absolutely refuses to permanently\n  install a package without an explicit reference to it in your\n  init-file (although this may be considered an advantage, depending\n  on your perspective).\n* Using MELPA Stable, `package.el` can install only stable versions of\n  packages. By default, `package.el` also installs only stable\n  versions of packages from GNU ELPA. These modes of operation are\n  unsupported by `straight.el` at this time, although this is a\n  [planned feature][#31].\n\n#### Additional notes\n\n* `package.el` and `straight.el` usually take approximately the same\n  time to install packages, despite the fact that `straight.el` is\n  cloning entire Git repositories. This is because network latency and\n  byte-compilation are the dominant factors.\n* Some `package.el` servers build packages from non-Git upstreams.\n  `package.el` can install these packages, while `straight.el` cannot.\n  However, since `package.el` has no version-control support, this is\n  more or less equivalent to installing those packages from the\n  [Emacsmirror], which `straight.el` can do by default.\n\n### Comparison to Quelpa\n\n* Quelpa allows for fetching packages from arbitrary sources and\n  building them into a format that can be installed by `package.el`.\n  `straight.el` has a philosophy which is fundamentally incompatible\n  with `package.el`, and non-compatibility with `package.el` is one of\n  its design goals.\n\n#### Advantages of `straight.el`\n\n* `straight.el` has out-of-the-box compatibility with MELPA, GNU ELPA,\n  and Emacsmirror, while Quelpa only has support for MELPA. To use GNU\n  ELPA, you must drop down to `package.el`. [Emacsmirror] is not\n  supported by default, although it is easy to specify an Emacsmirror\n  repository in a recipe. While Quelpa allows you to specify custom\n  recipe folders, it does not have support for cloning these folders\n  automatically from version control, nor for generating the recipes\n  in any way other than copying them literally from files.\n  `straight.el` allows you full flexibility in this regard.\n* `straight.el` has integrated support for selecting particular Git\n  revisions of packages. This process is more manual in Quelpa, as it\n  requires placing the commit hash into the recipe, which disables\n  updates.\n* `straight.el` uses your init-file as the sole source of truth for\n  package operations. Since Quelpa is based on `package.el`, it also\n  loads every package you ever installed at startup, even if those\n  packages are no longer referenced by your init-file. Furthermore,\n  there is an additional caching layer, so that deleting a package\n  from the `package.el` interface and removing it from your init-file\n  still does not actually delete it.\n* `straight.el` supports 100% reproducibility for your Emacs packages\n  with version lockfiles. Quelpa can theoretically provide some\n  measure of reproducibility, but this requires significant manual\n  effort since all packages are not associated with specific revisions\n  by default, nor is the revision of MELPA saved anywhere.\n* `straight.el` allows you to make arbitrary changes to your packages\n  locally. While it is possible to make local changes to Quelpa\n  packages, there are two places to do so: the built package, which is\n  the default destination of `find-function`, and the original\n  repository. Changes to the former are not version-controlled and\n  will be silently overwritten by `package.el` operations, while\n  changes to the latter will be silently overwritten by Quelpa\n  operations.\n* `straight.el` has explicit support for configuring both an upstream\n  repository and a fork for the same package. Quelpa does not have\n  such a concept.\n* `straight.el` allows you complete control over how your repositories\n  are managed, and the default behavior is to draw all packages\n  versioned in a single repository from a single copy of that\n  repository. Quelpa is hardcoded to require a separate repository for\n  each package, so that installing Magit requires three copies of the\n  Magit repository.\n* `straight.el` builds packages using symlinks, meaning that\n  `find-function` works as expected. Quelpa builds packages by\n  copying, a feature inherited from MELPA. This means that\n  `find-function` brings you to the built package, instead of the\n  actual repository, which is not version-controlled and will be\n  overwritten whenever `package.el` performs an update.\n* `straight.el` allows you to perform arbitrary version-control\n  operations on your package\'s Git repositories. Quelpa allows this,\n  but all local changes will be silently overridden whenever Quelpa\n  performs an update.\n* `straight.el` is designed with `emacs -Q` bug reports in mind. Since\n  Quelpa is based on `package.el`, it is also unsuitable for minimal\n  bug reproductions, since it automatically loads all of your packages\n  on any package operation, even in `emacs -Q`.\n* `straight.el` operates quietly when all is going well. Since Quelpa\n  is based on `package.el`, it displays all messages, errors, and\n  warnings that come from byte-compilation and autoload generation. It\n  also displays additional messages while cloning Git repositories,\n  downloading files, and building packages from their repositories\n  into `package.el` format.\n* `straight.el` does not modify your init-file. Since Quelpa is based\n  on `package.el`, it inherits the behavior of aggressively inserting\n  a call to `package-initialize` into your init-file on any package\n  management operation.\n* `straight.el` has a profile system that allows users of someone\n  else\'s Emacs configuration to manage an additional subset of\n  packages, or to override upstream package configuration, without\n  forking the upstream. Quelpa has no such concept.\n\n#### Advantages of Quelpa\n\n* Quelpa supports all the version-control systems supported by MELPA,\n  which is to say almost every commonly and uncommonly used VCS.\n  `straight.el` only supports Git, although it is designed to support\n  other version-control backends.\n* Quelpa allows for installing only stable versions of packages, from\n  any source. This mode of operation is unsupported by `straight.el`,\n  although it is a [planned feature][#31].\n* Since Quelpa is based on `package.el`, it inherits a user interface\n  for package management that also displays package metadata.\n  `straight.el` has no such interface.\n\n#### Additional notes\n\n* `straight.el` and Quelpa both allow you to manage your package\'s\n  local repositories manually, if you wish.\n* In principle, `straight.el` and Quelpa have identical package\n  installation times, since they are performing the same operations.\n  In practice, Quelpa is slightly slower since it builds packages by\n  copying rather than symlinking, and it clones multiple copies of the\n  same Git repository when multiple packages are built from it.\n* `straight.el` encourages you to keep a tight handle on your package\n  versions by default. Quelpa encourages you to stick to the latest\n  versions of your packages, and to upgrade them automatically.\n\n### Comparison to Cask\n\nI have not used Cask extensively, so please feel especially free to\noffer corrections for this section.\n\n* Cask installs packages using the `package.el` protocol, based on a\n  `Cask` file written in the Cask DSL. `straight.el` eschews\n  `package.el` entirely, and clones packages from source based on how\n  you invoke `straight-use-package` in your init-file.\n* Cask focuses more on being a build manager, like Maven or Leiningen,\n  while `straight.el` focuses *exclusively* on being a package\n  manager.\n\n#### Advantages of `straight.el`\n\n* `straight.el` has out-of-the-box compatibility with Emacsmirror,\n  while Cask only supports `package.el`-compliant repositories.\n  However, it is easy to specify an Emacsmirror repository in a\n  recipe. Cask does not support custom package sources. `straight.el`\n  supports MELPA, GNU ELPA, and Emacsmirror, and allows you to add any\n  other sources you would like.\n* `straight.el` has integrated support for selecting particular Git\n  revisions of packages. This process is more manual in Cask, as it\n  requires placing the commit hash into the recipe, which disables\n  updates.\n* `straight.el` uses your init-file as the sole source of truth for\n  package operations. Since Cask is based on `package.el`, it loads\n  every package you ever installed at startup, even if some of those\n  packages are no longer referenced by your `Cask` file.\n* `straight.el` determines your package management configuration\n  implicitly by detecting how you call `straight-use-package` in your\n  init-file and making the appropriate changes immediately. Cask\n  requires manual intervention (for example, issuing a `cask install`\n  command when you have updated your `Cask` file). However, both\n  `straight.el` and Cask can be considered declarative package\n  managers.\n* `straight.el` supports 100% reproducibility for your Emacs packages\n  with version lockfiles. Cask can theoretically provide some measure\n  of reproducibility, but this requires significant manual effort\n  since all packages are not associated with specific revisions by\n  default, nor is the revision of Cask saved anywhere.\n* `straight.el` allows you to make arbitrary changes to your packages\n  locally. While it is possible to make local changes to Cask\n  packages, these will not be version-controlled and they will be\n  silently overwritten or shadowed when Cask performs an update.\n* `straight.el` allows you to perform arbitrary version-control\n  operations on your package\'s Git repositories, including\n  contributing changes upstream. `straight.el` has explicit support\n  for specifying both an upstream and a fork for a package.\n  Contributing changes upstream with Cask is impossible.\n* `straight.el` is designed with `emacs -Q` bug reports in mind. Cask\n  appears to be unsuitable for minimal bug reproductions, since there\n  does not appear to be a straightforward way to load a single\n  package, without loading all other packages configured in your\n  `Cask` file.\n* `straight.el` operates quietly when all is going well. Since Cask is\n  based on `package.el`, it displays all messages, errors, and\n  warnings that come from byte-compilation and autoload generation.\n* `straight.el` has a profile system that allows users of someone\n  else\'s Emacs configuration to manage an additional subset of\n  packages, or to override upstream package configuration, without\n  forking the upstream. Cask has no such concept.\n\n#### Advantages of Cask\n\n* Cask provides a useful toolbox of operations for project management,\n  which are completely absent from `straight.el`.\n* Since Cask is based on `package.el`, it does not require that you\n  have Git installed. (It does require Python, however.) `straight.el`\n  is mostly unusable without Git.\n* Since Cask is based on `package.el`, it can perform bulk package\n  updates more quickly than `straight.el`.\n* Since Cask is based on `package.el`, it inherits a user interface\n  for package management that also displays package metadata.\n* Since Cask is based on `package.el`, you can install packages\n  without editing a file manually, although this rather defeats the\n  entire purpose of using Cask instead of `package.el`. `straight.el`\n  absolutely refuses to permanently install a package without an\n  explicit reference to it in your init-file (although this may be\n  considered an advantage, depending on your perspective).\n* Using MELPA Stable, Cask can install only stable versions of\n  packages. By default, Cask also installs only stable versions of\n  packages from GNU ELPA. These modes of operation are unsupported by\n  `straight.el` at this time, although this is a [planned\n  feature][#31].\n* Cask supports more version-control systems than `straight.el` (which\n  only supports Git).\n\n### Comparison to el-get\n\nI have not used el-get extensively, so please feel especially free to\noffer corrections for this section.\n\n* Both el-get and `straight.el` implement their own package management\n  abstractions instead of delegating to `package.el`. However:\n    * el-get goes the route of adding as many package sources as\n      possible (e.g. `package.el`, many different version-control\n      systems, various specific websites, and even system package\n      managers) so that packages can be used very easily.\n    * `straight.el` only supports Git and in doing so is able to\n      provide more advanced package management features.\n\n#### Advantages of `straight.el`\n\n* `straight.el` uses your init-file as the sole source of truth for\n  package operations. el-get has additional metadata stored outside\n  the init-file, although specifying all packages in your init-file is\n  a supported mode of operation.\n* `straight.el` supports 100% reproducibility for your Emacs packages\n  with version lockfiles. el-get can theoretically provide some\n  measure of reproducibility, but this requires significant manual\n  effort since all packages are not associated with specific revisions\n  by default, nor is the revision of el-get saved anywhere.\n* `straight.el` allows you to make arbitrary changes to your packages\n  locally, and conflicts during updates are presented to the user and\n  resolved interactively. While it is possible to make local changes\n  to el-get packages, the el-get manual warns that such changes may\n  break the update mechanism.\n* `straight.el` has explicit support for configuring both an upstream\n  repository and a fork for the same package. el-get does not have\n  such a concept.\n* `straight.el` allows you to perform arbitrary version-control\n  operartions on your package\'s Git repositories. el-get allows this,\n  but local changes will be overwritten when el-get performs an\n  update.\n* `straight.el` provides a suite of powerful interactive workflows for\n  performing bulk operations on your package\'s Git repositories.\n  el-get only allows you to install, uninstall, and update packages.\n* `straight.el` operates quietly when all is going well. el-get\n  reports its progress verbosely.\n* `straight.el` has a profile system that allows users of someone\n  else\'s Emacs configuration to manage an additional subset of\n  packages, or to override upstream package configuration, without\n  forking the upstream. el-get has no such concept.\n\n#### Advantages of el-get\n\n* el-get supports virtually all known version-control systems, as well\n  as system package managers, EmacsWiki, arbitrary HTTP, and even `go\n  get`. `straight.el` supports only Git, although it does allow you to\n  manage your local repositories manually if you would like.\n* el-get has been around since 2010 and is on its fifth major version,\n  whereas `straight.el` was created in January 2017 and is only now\n  approaching a 1.0 release. Clearly, el-get is more stable, although\n  despite its recency `straight.el` is already almost 50% of the size\n  of el-get, by the line count. Both package managers are actively\n  maintained.\n* el-get has a recipe format which is several orders of magnitude more\n  powerful than that of `straight.el`, since it supports many more\n  package sources that can be configured and since it allows for a\n  more complex build process.\n* el-get provides a number of features for running per-package\n  initialization and setup code, including pulling that code from\n  arbitrary sources. `straight.el` does not support this and expects\n  you to use a dedicated tool like [`use-package`][use-package] (with\n  which integration is built in) for that purpose.\n* el-get has a user interface for package management that also\n  displays package metadata, similarly to `package.el`. `straight.el`\n  has no user interface for package management; any UI is provided by\n  the user\'s `completing-read` framework.\n\n### Comparison to Borg\n\n* Borg and `straight.el` are perhaps the two most similar package\n  managers on this list. The difference is that Borg is very minimal\n  and expects you to complement it with other tools such as [Magit],\n  [epkg], [`use-package`][use-package], and [auto-compile]. On the\n  other hand, `straight.el` aspires to be a one-stop package\n  management solution, although it does not try to replace dedicated\n  version-control packages (Magit) or dedicated package\n  *configuration* packages (`use-package`).\n* Borg uses Git submodules, while `straight.el` uses independently\n  managed Git repositories.\n\n#### Advantages of `straight.el`\n\n* `straight.el` supports MELPA, GNU ELPA, Emacsmirror, and custom\n  recipe sources. Borg only supports Emacsmirror and custom recipe\n  sources. However, as the Emacsmirror is a near-complete superset of\n  both GNU ELPA and MELPA, this does not necessarily mean you have\n  access to more packages: it just means you benefit from the recipe\n  maintenance efforts of the MELPA team and the Emacsmirror team,\n  rather than only the latter.\n* Borg, even when combined with related tools, do not allow for the\n  kind of massive interactive repository management provided by\n  `straight.el`.\n* `straight.el` supports deferred and conditional installation. This\n  is not supported by Borg, although it could in principle be\n  implemented via lazy cloning of submodules.\n* `straight.el` provides an API designed for other version-control\n  backends to be added in future. Borg is inextricably tied to Git.\n* The interface for Git submodules has a number of sharp edges.\n* `straight.el` provides dependency management. This is a manual\n  process in Borg.\n* `straight.el` provides mechanisms for updating your packages. This\n  is a manual process in Borg.\n* `straight.el` is configured solely by how you use in your init-file.\n  Configuring Borg requires customizing `~/.emacs.d/.gitmodules`,\n  which means (for example) that you cannot generate recipes\n  dynamically. (However, the handling of configuration is\n  [planned][#95-c1] to be improved in a future release.)\n* `straight.el` has a profile system that allows users of someone\n  else\'s Emacs configuration to manage an additional subset of\n  packages, or to override upstream package configuration, without\n  forking the upstream. Borg has no such concept.\n\n#### Advantages of Borg\n\n* Borg does a heck of a lot less magic, so if you want a solution with\n  simple implementation details, `straight.el` may not be for you.\n  (But see the developer manual and docstrings, first.)\n* Borg supports arbitrary build commands; `straight.el` does not\n  (although this is a [planned feature][#72]).\n\n### Comparison to the manual approach\n\n* The manual approach is to download packages yourself and put them on\n  your `load-path`. `straight.el` is more or less what you get when\n  you take the manual approach, think very hard about the best way to\n  do everything, and then automate all of it.\n\n#### Advantages of `straight.el`\n\n* `straight.el` figures out where to clone your packages from for you.\n* `straight.el` byte-compiles your packages for you and generates\n  their autoloads automatically.\n* `straight.el` frees you from needing to manually recompile and\n  regenerate autoloads.\n* `straight.el` keeps track of dependencies for you.\n* `straight.el` provides tools to manage all your packages in bulk,\n  which would otherwise be a long, tedious process.\n* `straight.el` allows you to get reproducibility for your\n  configuration without needing to keep all of your packages under\n  version control.\n* `straight.el` (when used with [`use-package`][use-package])\n  automates the complex process of deferred installation.\n* `straight.el` links packages into a separate build directories.\n  Running packages directly from their repositories has a number of\n  problems, including:\n    * making it impossible to run only one package, if others are\n      provided in the same repository.\n    * making your working directory dirty when the package author\n      forgot to add their build artifacts like `*.elc` and autoload\n      files to the `.gitignore`.\n    * instantly losing compatibility with MELPA recipes.\n* `straight.el` offers you a single entry point to install only a\n  single package in isolation, for a minimal bug reproduction. With\n  the manual approach this would be more complicated, especially if\n  the package has dependencies.\n* `straight.el` frees you from needing to think about package\n  management, since I already did all the thinking to figure how best\n  to design everything.\n\n#### Advantages of the manual approach\n\n* No dependencies.\n* You learn a lot, if you don\'t give up first.\n* You might end up writing a package manager (case in point).\n* This is the only way to deal with packages that have non-Git\n  upstreams which you need to contribute changes to. (However, you can\n  always use the manual approach for one package and `straight.el` for\n  the rest. Or you can just eschew `straight.el`\'s version-control\n  support for that package, and use it only for building the package.)\n\n## User manual\n\nThis section tells you everything you need to know about the\nuser-facing features of `straight.el`. For implementation details, see\nthe [developer manual][#dev]. It may also be helpful to get some\nperspective on the overarching concepts of `straight.el` from the\n[conceptual overview][#concepts].\n\n### Bootstrapping `straight.el`\n\nIn order to use `straight.el`, you will need to somehow get it loaded\ninto Emacs. (This is easy for `package.el`, since `package.el` is\nbuilt in to Emacs. `straight.el` must work a little harder.)\n\n`straight.el` comes with a file to do just this, `bootstrap.el`. All\nyou need to do is load that file. You can do this with `M-x load-file`\nor by a call to `load` in your init-file. However, there is an obvious\nshortcoming: `bootstrap.el` will only be available once `straight.el`\nis already installed.\n\nYou could just invoke `git clone` from your init-file, if\n`straight.el` is not installed, but then you would have to manually\ntake care of selecting the correct branch, parsing your version\nlockfile to check out the right revision, and so on. Instead, you can\njust use this snippet, which uses a copious amount of magic to take\ncare of all these details for you:\n\n<!-- longlines-start -->\n\n    (defvar bootstrap-version)\n    (let ((bootstrap-file\n           (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))\n          (bootstrap-version 5))\n      (unless (file-exists-p bootstrap-file)\n        (with-current-buffer\n            (url-retrieve-synchronously\n             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"\n             \'silent \'inhibit-cookies)\n          (goto-char (point-max))\n          (eval-print-last-sexp)))\n      (load bootstrap-file nil \'nomessage))\n\n<!-- longlines-stop -->\n\nDespite the reference to `develop`, this snippet actually installs\nfrom the `master` branch by default, just like every other package.\nFurthermore, the correct revision of `straight.el` is checked out, if\nyou have one specified in your lockfile. Even better, you can\n[override the recipe for `straight.el`][#user/overriding/straight.el],\njust like for any other package.\n\n### Installing packages programmatically\n\nThe primary entry point to `straight.el` is the `straight-use-package`\nfunction. It can be invoked interactively (for installing a package\ntemporarily) or programmatically (for installing a package\npermanently). This section covers the programmatic usage; see\n[later][#user/interactive] for interactive usage.\n\nHere is the basic usage of `straight-use-package`:\n\n    (straight-use-package \'el-patch)\n\nThis will ensure that the package `el-patch` is installed and loaded.\n(Note that `straight-use-package` takes a symbol, not a string, for\nthe name of the package.) Precisely, this is what happens:\n\n* If the local Git repository for `el-patch` is not available, it is\n  cloned, and the appropriate revision is checked out (if one is\n  specified in your version lockfiles).\n* If the local Git repository has been modified since the last time\n  the package was built, it is rebuilt. This means:\n    * The `.el` files are symlinked into a separate directory to\n      isolate them from other, irrelevant files.\n    * The main package file is checked for dependencies, which are\n      installed recursively if necessary using `straight-use-package`.\n    * The `.el` files are byte-compiled.\n    * Autoloads are extracted from the `.el` files and saved into a\n      separate file.\n* The package\'s directory is added to Emacs\' `load-path`.\n* The package\'s autoloads are evaluated.\n\nPackage authors should note that `straight.el` checks for dependencies\nthat are specified in the [`package.el` format][package.el-format]. To\nspare you reading that documentation, this is either a\n`Package-Requires` header in `PACKAGENAME.el`, or an argument to a\n`define-package` invocation in `PACKAGENAME-pkg.el`. Despite the [many\nshortcomings][#comparison/package.el/+straight.el] of `package.el`, it\nhas done a good job of creating a standardized format for dependency\ndeclarations.\n\nThere is one exception to the above statement: not all entries\nspecified in the `Package-Requires` header necessarily correspond to\npackages. For example, specifying a minimum Emacs version for a\npackage is done by depending on the `emacs` pseudo-package. Such\npackages are simply ignored by `straight.el`, using the variable\n`straight-built-in-pseudo-packages`.\n\nNote that loading a package does not entail invoking `require` on any\nof its features. If you wish to actually load the files of the\npackage, you need to do this separately. This is because most packages\ndo not need to be loaded immediately, and are better served by the\nautoload system.\n\n#### Installing with a custom recipe\n\n`straight-use-package` can also take a list instead of a symbol. In\nthat case, the first member of the list is a symbol giving the package\nname, and the remainder of the list is a [property\nlist][property-lists] providing information about how to install and\nbuild the package. Here is an example:\n\n    (straight-use-package\n     \'(el-patch :type git :host github :repo "raxod502/el-patch"\n                :fork (:host github\n                       :repo "your-name/el-patch")))\n\nIf you give `straight-use-package` just a package name, then a recipe\nwill be looked up by default (see the section on [recipe\nlookup][#user/lookup]). You can see the default recipe for a package\nby invoking [`M-x straight-get-recipe`][#user/interactive].\n\nIf `straight-allow-recipe-inheritance` is non-nil, then you only need\nto specify the components of the recpie that you want to override. All\nother components will still be looked up in the default recipe. In the\nexample above, we are only interested in changing the `:fork`\ncomponent. Therefore if `straight-allow-recipe-inheritance` is set,\nthe recipe could be simplifed as follows:\n\n    (straight-use-package\n     \'(el-patch :fork (:repo "your-name/el-patch")))\n\nor even simpler:\n\n    (straight-use-package\n     \'(el-patch :fork "your-name/el-patch"))\n\nThe `:files` keyword and all version control keywords support\ninheritance.\n\nTo learn more, see the section on [the recipe format][#user/recipes].\n\n#### Additional arguments to `straight-use-package`\n\nThe full user-facing signature of `straight-use-package` is:\n\n    (straight-use-package PACKAGE-OR-RECIPE &optional NO-CLONE NO-BUILD)\n\nAs discussed [previously][#user/install], by default\n`straight-use-package` will do three things:\n\n* Register the recipe provided with `straight.el`.\n* Clone the package\'s local repository, if it is absent.\n* Rebuild the package if necessary, and load it.\n\nBy providing the optional arguments, you may cause processing to halt\nbefore all three of these tasks are completed. Specifically, providing\n`NO-CLONE` causes processing to halt after registration but before\ncloning, and providing `NO-BUILD` causes processing to halt after\ncloning (if necessary) but before building and loading.\n\n`straight.el` supports lazy-loading by means of a special value for\n`NO-CLONE`, the symbol `lazy`. If this symbol is passed, then\nprocessing will halt at the clone step, unless the package is already\ncloned. This means that the package is built and loaded if it is\nalready installed, but otherwise installation is deferred until later.\nWhen you want to trigger the lazy installation, simply call\n`straight-use-package` again, but without `NO-CLONE`. (There is no\nneed to pass the recipe again; see [recipe lookup][#user/lookup].)\n\nYou can also pass functions for `NO-CLONE` or `NO-BUILD`, which will\nbe called with the package name as a string; their return values will\nthen be used instead.\n\nNote that if it makes no sense to build a package, then you should put\n`:no-build t` in its [recipe][#user/recipes], rather than specifying\n`NO-BUILD` every time you register it with `straight.el`. (This is\nespecially relevant when writing recipes for [recipe\nrepositories][#user/lookup/repos].)\n\n#### Variants of `straight-use-package`\n\nFor convenience, `straight.el` provides some functions that wrap\n`straight-use-package` with particular arguments, to cover all of the\ncommon cases. Each of these functions takes only a package name or\nrecipe, and no additional arguments.\n\n* `straight-register-package`: always stop after the registration\n  step. This may be useful for specifying the recipe for an optional\n  dependency (see [recipe lookup][#user/lookup], but see also [recipe\n  overrides][#user/overriding]).\n* `straight-use-package-no-build`: always stop before the build step.\n  This is used by [`straight-freeze-versions`][#user/lockfiles] to\n  make sure packages are cloned, since building them is unnecessary\n  for writing the lockfiles.\n* `straight-use-package-lazy`: stop at the clone step if the package\'s\n  local repository is not already cloned. This is used for\n  lazy-loading.\n\n#### Customizing when packages are built\n\nBy default, when `straight.el` is bootstrapped during Emacs init, it\nuses a bulk `find(1)` command to identify files that were changed\nsince the last time a package depending on them was built. These\npackages are then rebuilt when they are requested via\n`straight-use-package`. Normally, `straight.el` will try to detect\nwhat sort of `find(1)` program is installed, and issue the appropriate\ncommand. If it makes a mistake, then you can manually customize\n`straight-find-flavor`.\n\nFor about 100 packages on an SSD, calling `find(1)` to detect\nmodifications takes about 500ms. You can save this time by customizing\n`straight-check-for-modifications`. This is a list of symbols which\ndetermines how `straight.el` detects package modifications. The\ndefault value is `(find-at-startup find-when-checking)`, which means\nthat `find(1)` is used to detect modifications at startup, and also\nwhen you invoke `M-x straight-check-package` or `M-x\nstraight-check-all`. If you prefer to avoid this performance hit, or\ndo not have `find(1)` installed, then you can remove these symbols\nfrom the list. In that case, you will probably want to add either\n`check-on-save` or `watch-files` to the list.\n\n`check-on-save` causes `straight.el` to use `before-save-hook` to\ndetect package modifications as you make them (modifications made by\nthe `straight.el` repository management commands are also detected).\nThis reduces init time, but modifications made outside of Emacs (or\nmodifications that bypass `before-save-hook`) are not detected. Pull\nrequests extending the number of cases in which `straight.el` is able\nto detect live modifications are welcome. Also, for the sake of\nefficiency, this form of modification checking is restricted to\nsubdirectories of `~/.emacs.d/straight/repos`, so you must put your\nlocal repositories into that directory for it to work. (Pull requests\nto change this would be welcome.)\n\n`watch-files` causes `straight.el` to automatically invoke a\nfilesystem watcher to detect modifications as they are made, inside or\noutside of Emacs. For this setting to work, you must have\n[`python3`][python] and [`watchexec`][watchexec] installed on your\n`PATH`. By default, the watcher persists after Emacs is closed. You\ncan stop it manually by running `M-x straight-watcher-stop`, and start\nit again by running `M-x straight-watcher-start`. The watcher script\nis designed so that when one instance is started, all the others\ngracefully shut down, so you don\'t have to worry about accidentally\nending up with more than one. There is nothing exciting in the process\nbuffer for the watcher, but if you are interested in it then its name\nis given by `straight-watcher-process-buffer`. (By default, the name\nhas a leading space so that the buffer does not appear in the buffer\nlist.)\n\nThere is probably no good reason to use both `check-on-save` and\n`watch-files` at the same time. Your configuration can dynamically\nswitch between which one is used depending on `(executable-find\n"watchexec")` or similar.\n\nIf you prefer to eschew automatic package rebuilding entirely, you can\njust set `straight-check-for-modifications` to `nil`. In that case,\npackages will only be rebuilt when metadata (e.g. the recipe or the\nEmacs version) changes, or when you manually invoke `M-x\nstraight-rebuild-package` or `M-x straight-rebuild-all`.\n\nRegardless of your preferred setting for\n`straight-check-for-modifications`, you should set it before the\n`straight.el` bootstrap snippet is run, since hooks relating to this\nvariable are set during bootstrap.\n\nOn Microsoft Windows, `find(1)` is generally not available, so the\ndefault value of `straight-check-for-modifications` is instead\n`(check-on-save)`.\n\n##### Custom or manual modification detection\n\nYou can also use the low-level functions for modification detection\ndirectly.\n\nThe function `straight-register-repo-modification` takes a string\n(e.g. `"straight.el"`) corresponding to the name of a local\nrepository, and marks all packages from that local repository to be\nrebuilt at next Emacs startup. This function silently ignores local\nrepositories which contain slashes, a limitation which might be\nremoved in future.\n\nThe function `straight-register-file-modification` takes no arguments\nand checks if the file visited by the current buffer (if any) is\ncontained by any local repository. If so, it delegates to\n`straight-register-repo-modification`. The `check-on-save` value for\n`straight-check-for-modifications` just adds\n`straight-register-file-modification` to `before-save-hook`.\n\n##### Summary of options for package modification detection\n###### `find-at-startup`\n\nSave build timestamps and run `find(1)` at startup to detect changes\n\n* Most reliable, never misses changes\n* Requires `find(1)`\n* Slows down startup\n\n###### `check-on-save`\n\nUse `before-save-hook` to detect changes\n\n* No external dependencies\n* No startup delay\n* No additional CPU or memory impact\n* Doesn\'t catch changes made except via `save-file` inside Emacs\n\n###### `watch-files`\n\nRun filesystem watcher to detect changes\n\n* Requires Python 3 and Watchexec\n* No startup delay\n* Takes a few seconds to build virtualenv the first time\n* Memory and CPU impact of running filesystem watcher\n* Only misses changes if you make them after booting the system but\n  before starting Emacs\n\n---\n\n#### Customizing how packages are built\n\nBy specifying a non-nil value for the `:no-build` attribute in a\npackage\'s [recipe][#user/recipes], you may prevent the package from\nbeing built at all. This is usually useful for recipe repositories\nwhich do not bundle executable Lisp code. (Make sure to use\n[`straight-use-recipes`][#user/lookup/repos] for registering recipe\nrepositories.)\n\nBy specifying a non-nil value for the `:no-autoloads` attribute in a\npackage\'s recipe, you may prevent any autoloads provided by the\npackage from being generated and loaded into Emacs. This is mostly\nuseful if the package provides a large number of autoloads, you know\nyou need only a few of them, and you wish to optimize your startup\ntime (although this is almost certainly premature optimization unless\nyou *really* know what you\'re doing). You can also customize the\nvariable `straight-disable-autoloads` to effect this change on all\nrecipes which do not explicitly specify a `:no-autoloads` attribute.\n\nBy specifying a non-nil value for the `:no-byte-compile` attribute in\na package\'s recipe, you may inhibit byte-compilation. See [this\nissue][#357] for discussion of why this might be useful. You can also\ncustomize the variable `straight-disable-byte-compilation` to effect\nthis change on all recipes which do not explicitly specify a\n`:no-byte-compile` attribute.\n\nUsually, `straight.el` uses symbolic links ("symlinks") to make\npackage files available from the build directory. This happens when\n`straight-use-symlinks` is non-nil, the default. On Microsoft Windows,\nhowever, support for symlinks is not always available, so the default\nvalue of `straight-use-symlinks` is nil on that platform. That causes\ncopying to be used instead, and an advice is placed on `find-file` to\ncause the copied files to act as symlinks if you try to edit them.\n\nIf you want to activate symlink-support on MS Windows 7, 8, or 10, you\nshould ensure the following requirements:\n\n* `straight-use-symlinks` has to be set to non-nil manually.\n\n* Your user-account needs to be assigned the right to create symbolic\n  links. To do so, run "secpol.msc" and in "Local Policies \xe2\x86\x92 User\n  Rights Assignment" assign the right to "Create symbolic links" to\n  your user-account.\n\n* If you have User Account Control (UAC) enabled and your user-account\n  belongs to the the _Administrators_ group you\'ll need to run Emacs\n  in elevated mode to be able to create symlinks (see\n  [here][symlinks-perforce] and [here][symlinks-stackoverflow] and,\n  for an official reference, section Access Token Changes [in this\n  document][symlinks-microsoft].\n\n* [Windows Creators Update][symlinks-creators] supports\n  symlink-creation without any special permission setup.\n\n\n#### Customizing how packages are made available\n\nBy setting the variable `straight-cache-autoloads` to a non-nil value,\nyou can cause `straight.el` to cache the autoloads of all used\npackages in a single file on disk, and load them from there instead of\nfrom the individual package files if they are still up to date. This\nreduces the number of disk IO operations during startup from O(number\nof packages) to O(1), so it should improve performance. No other\nconfiguration should be necessary to make this work; however, you may\nwish to call [`straight-prune-build`][#user/interactive] occasionally,\nsince otherwise this cache file may grow quite large over time.\n\n#### Hooks run by `straight-use-package`\n\nCurrently, `straight-use-package` supports two hooks:\n\n* `straight-use-package-prepare-functions`: The functions in this hook\n  are run just before a package would be built, even if the package\n  does not actually need to be rebuilt. They are passed the name of\n  the package being (maybe) built as a string, and should take and\n  ignore any additional arguments.\n* `straight-use-package-pre-build-functions`: The functions in this\n  hook are run just before building a package (and only if the package\n  needs to be built). They are passed the name of the package being\n  built as a string, and should take and ignore any additional\n  arguments.\n\n### The recipe format\n\nThe general format for a `straight.el` recipe is:\n\n    (package-name :keyword value :keyword value ...)\n\nNote that if you wish to pass a recipe to `straight-use-package`, you\nwill need to quote it. If you need to compute part of the recipe\ndynamically, use backquoting:\n\n    (straight-use-package\n     `(el-patch :type git :repo ,(alist-get \'el-patch my-package-urls)))\n\nHere is a comprehensive list of all keywords which have special\nmeaning in a recipe (unknown keywords are ignored but preserved):\n\n* `:local-repo`\n\n  This is the name of the local repository that is used for the\n  package. If a local repository by that name does not exist when you\n  invoke `straight-use-package`, one will be cloned according to the\n  package\'s [version-control settings][#user/recipes/vc-backends].\n\n  Multiple packages can use the same local repository. If so, then a\n  change to the local repository will cause both packages to be\n  rebuilt. Typically, if multiple packages are drawn from the same\n  repository, both should specify a `:files` directive.\n\n  If you do not provide `:local-repo`, then it defaults to a value\n  derived from the [version-control\n  settings][#user/recipes/vc-backends], or as a last resort the\n  package name.\n\n* `:files`\n\n  This is a list specifying which files in a package\'s local\n  repository need to be symlinked into its build directory, and how to\n  arrange the symlinks. For most packages, the default value\n  (`straight-default-files-directive`) will suffice, and you do not\n  need to specify anything.\n\n  If you do need to override the `:files` directive (this happens most\n  commonly when you are taking a single package from a repository that\n  holds multiple packages), it is almost always sufficient to just\n  specify a list of globs or filenames. All matching files will be\n  linked into the top level of the package\'s build directory.\n\n  In spite of this, the `:files` directive supports an almost\n  comically powerful DSL (with nested excludes and everything!) that\n  allows you full flexibility on how the links are made; see the\n  docstring of `straight-expand-files-directive` for the full details.\n\n* `:flavor`\n\n  If this is non-nil, then it changes the interpretation of the\n  `:files` directive for compatibility with an existing upstream\n  recipe source. See the docstring of\n  `straight-expand-files-directive` for details.\n\n* `:no-build`\n\n  If this is non-nil, then it causes the build step to be skipped\n  entirely and unconditionally. You should specify this for [recipe\n  repository recipes][#user/lookup/repos].\n\n* `:type`\n\n  This specifies the version-control backend to use for cloning and\n  managing the package\'s local repository. It defaults to the value of\n  `straight-default-vc`, which defaults to `git`.\n\n  The only traditional version-control backend currently supported is\n  `git`, although more backends may be added.\n\n  As a special case, however, you may specify the value `built-in`,\n  which results in all version-control operations on the package being\n  ignored. This allows you to tell `straight.el` that a package has\n  already been provided (for example, because a version of it is\n  shipped by Emacs) and does not have a local repository which needs\n  to be cloned, updated, and so on. Here is how you can tell\n  `straight.el` that you would like to use the Emacs-provided copy of\n  Org, rather than cloning it from the upstream repository if another\n  package declares it as a dependency:\n\n      (straight-use-package \'(org :type built-in))\n\n* backend-specific keywords\n\n  Depending on the value of `:type`, additional keywords (relevant to\n  how the package\'s repository is cloned and managed) will be\n  meaningful. See the next section.\n\n  The `built-in` pseudo-backend does not take any other keywords.\n\n#### Version-control backends\n\nDefining a version-control backend consists of declaring a number of\nfunctions named as `straight-vc-BACKEND-METHOD`, where `BACKEND` is\nthe name of the version-control backend being defined and `METHOD` is\na backend API method. The relevant methods are:\n\n* `clone`: given a recipe and a commit object, clone the repository\n  and attempt to check out the given commit.\n* `commit-present-p`: given a recipe and a commit object, return\n  whether the commit can be checked out offline, i.e., without\n  fetching from the remote.\n* `normalize`: given a recipe, "normalize" the repository (this\n  generally means reverting it to a standard state, such as a clean\n  working directory, but does not entail checking out any particular\n  commit).\n* `fetch-from-remote`: given a recipe, fetch the latest version from\n  its configured remote, if one is specified.\n* `fetch-from-upstream`: given a recipe, fetch the latest version from\n  its configured upstream, if the package is forked.\n* `merge-from-remote`: given a recipe, merge the latest version\n  fetched from the configured remote, if any, to the local copy.\n* `merge-from-upstream`: given a recipe, merge the latest version\n  fetched from the configured upstream, if the package is forked, to\n  the local copy.\n* `push-to-remote`: given a recipe, push the current version of the\n  repository to its configured remote, if one is specified.\n* `check-out-commit`: given a recipe and a commit object, attempt to\n  check out that commit in the repository for that recipe.\n* `get-commit`: given a local repository name, return the commit\n  object that is currently checked out.\n* `local-repo-name`: given a recipe, return a good name for the local\n  repository, or nil.\n* `keywords`: return a list of keywords which are meaningful for this\n  version-control backend.\n\nMost of these methods are highly interactive: they don\'t actually do\nanything without prompting you to confirm it, and very often they will\noffer you a number of different options to proceed (including starting\na recursive edit and allowing you to do whatever you would like).\n\nAlso, all of the methods in this section take [`straight.el`-style\nrecipes][#dev/recipe-formats]; see the section on [defining VC\nbackends][#dev/vc-backends] in the developer manual for more details.\n\n#### Git backend\n\nThese are the keywords meaningful for the `git` backend:\n\n* `:repo`: the clone URL for the Git repository.\n* `:host`: either nil or one of the symbols `github`, `gitlab`,\n  `bitbucket`. If non-nil, then `:repo` should just be a string\n  "username/repo", and the URL is constructed automatically.\n* `:branch`: the name of the branch used for primary development, as a\n  string. If your version lockfiles do not specify a commit to check\n  out when the repository is cloned, then this branch is checked out,\n  if possible. This branch is also viewed as the "primary" branch for\n  the purpose of normalization and interaction with the remote.\n* `:remote`: the name to use for the Git remote. If the package is\n  forked, this name is used for the upstream remote.\n* `:nonrecursive`: if non-nil, then submodules are not cloned. This is\n  particularly important for the Emacsmirror recipe repository, which\n  contains every known Emacs package in existence as submodules.\n* `:fork`: a plist which specifies settings for a fork, if desired.\n  This causes the `fetch-from-remote` method to operate on the fork;\n  you can use the `fetch-from-upstream` method to operate on the\n  upstream instead. The allowed keywords are `:repo`, `:host`,\n  `:branch`, and `:remote`.\n* `:depth`: either the symbol `full` or an integer. If `full`, then\n  the repository is cloned with its whole history. If an integer `N`,\n  then the repository is cloned with the option `--depth N`, unless a\n  commit is specified (e.g. by version lockfiles). The default value\n  is `full`.\n\nThis section tells you how the `git` backend, specifically, implements\nthe version-control backend API:\n\n* `clone`: clones the repository, including submodules if\n  `:nonrecursive` is not provided. Checks out the commit specified in\n  your revision lockfile, or the `:branch` (from the `:fork`\n  configuration, if given), or `origin/HEAD`. If a `:fork` is\n  specified, also fetches from the upstream.\n* `commit-present-p`: checks if the commit SHA is among the revisions\n  that are present locally.\n* `normalize`: verifies that remote URLs are set correctly, that no\n  merge is in progress, that the worktree is clean, and that the\n  primary `:branch` (from the `:fork` configuration, if given) is\n  checked out.\n* `fetch-from-remote`: checks that remote URLs are set correctly, then\n  fetches from the primary remote (the fork, if the package is\n  forked).\n* `fetch-from-upstream`: checks that remote URLs are set correctly,\n  then fetches from the upstream remote. If the package is not a fork,\n  does nothing.\n* `merge-from-remote`: performs normalization, then merges from the\n  primary remote (the fork, if the package is forked) into the primary\n  local `:branch`.\n* `merge-from-upstream`: performs normalization, then merges from the\n  upstream remote into the primary local `:branch`. If the package is\n  not a fork, does not attempt to merge.\n* `push-to-remote`: performs normalization, pulls from the primary\n  remote if necessary, and then pushes if necessary. This operation\n  acts on the fork, if the package is forked.\n* `check-out-commit`: verifies that no merge is in progress and that\n  the worktree is clean, then resets the worktree to the specified\n  commit.\n* `get-commit`: returns HEAD as a 40-character string.\n* `local-repo-name`: if `:host` is non-nil, then `:repo` will be of\n  the form "username/repository", and "repository" is used. Otherwise,\n  if the URL is of the form `.../<something>.git`, then `<something>`\n  is used. Otherwise, nil is returned.\n* `keywords`: see the list of keywords above.\n\nYou can customize the following user options:\n\n* `straight-vc-git-default-branch`: if `:branch` is unspecified, then\n  this is used instead. Defaults to "master".\n* `straight-vc-git-default-remote-name`: the name to use for the\n  primary remote, or the upstream remote if the package is forked.\n  Defaults to "origin". The `:remote` keyword may be used to override\n  the value of this variable on a per-repository basis.\n* `straight-vc-git-default-fork-name`: the name to use for the fork\n  remote, if the package is forked. Defaults to "fork". The `:remote`\n  keyword may be used to override the value of this variable on a\n  per-repository basis.\n* `straight-vc-git-default-protocol`: the default protocol to use for\n  automatically generated URLs when `:host` is non-nil. It can be\n  either `https` or `ssh`, and defaults to `https` because this\n  requires less work to set up.\n* `straight-vc-git-force-protocol`: if this is non-nil, then HTTPS and\n  SSH URLs are not treated as equivalent, so that bulk version-control\n  operations will offer to re-set your remote URLs from HTTPS to SSH\n  or vice versa, depending on the value of\n  `straight-vc-git-default-protocol`. This is nil by default.\n* `straight-vc-git-auto-fast-forward`: if this is non-nil, pulling\n  will quietly do fast-forward, to suppress asking for instructions on\n  each package with updates, unless they\'re not trivial. Set to nil if\n  you\'d prefer to inspect all changes.\n* `straight-vc-git-default-clone-depth`: the default value for the\n  `:depth` keyword. It can be either the symbol `full` or an integer,\n  and defaults to `full`. Setting this variable to a small integer will\n  reduce the size of repositories. Note that this variable does *not*\n  affect packages whose versions are locked.\n\n##### Deprecated `:upstream` keyword\n\n`straight.el` previously supported fork configuration in recipes using\nan `:upstream` keyword rather than a `:fork` keyword. For various\nreasons, this was more complex to handle, which is why the change was\nmade. For backwards compatibility, the `:upstream` keyword is still\naccepted, with the following behavior.\n\nWhen `straight.el` processes a recipe which uses the `:upstream`\nkeyword, it moves the `:repo`, `:host`, and `:branch` keywords from\nthat sub-plist to the top level, and moves those top-level keywords to\na new `:fork` sub-plist. Then it sets the top-level and `:fork`\nsub-plist values of `:remote` to the values of the deprecated\nvariables `straight-vc-git-upstream-remote` (defaults to "upstream")\nand `straight-vc-git-primary-remote` (defaults to "origin"),\nrespectively.\n\nFor backwards compatibility, if `straight-vc-git-primary-remote`\ndiffers from its default value of "origin", then its value is used in\nplace of `straight-vc-git-default-remote-name`.\n\n### Recipe lookup\n\nIf you only provide a symbol (package name) to `straight-use-package`,\nthen the recipe is looked up automatically. By default, [MELPA], [GNU\nELPA][gnu-elpa], and [Emacsmirror] are searched for recipes, in that\norder. This means that one or more of them may need to be cloned.\nRecipe repositories are actually just the same as ordinary packages,\nexcept that their recipes specify `:no-build`, so they are not\nsymlinked or added to the `load-path` or anything.\n\nNote that dependencies always use the default recipes, since the only\ninformation `straight.el` gets about a package\'s dependencies are\ntheir names.\n\nThis leads to a few interesting questions regarding requesting a\npackage multiple times. For example, you might need to load two\nfeatures using [`use-package`][use-package] that are provided from the\nsame package, or one of the packages you have installed is also\nrequested as a dependency by another package. `straight.el` uses a\nnumber of heuristics to try to make these interactions as intuitive\nand painless as possible:\n\n* The first time a package is registered with `straight.el`, its\n  recipe (either the recipe that you provided, or the one that was\n  looked up from a recipe repository) is recorded. In future\n  registration, if you just provide the package name to\n  `straight-use-package`, the existing recipe is reused.\n\n  Note, however: *if* you want to use a custom recipe for a given\n  package, you must load it *before* all of its dependencies.\n  Otherwise, the package will first be registered as a dependency,\n  using the default recipe.\n\n* If a package has already been registered with `straight.el`, and you\n  attempt to load it again with an explicit recipe which is different\n  from the one previously registered, the new recipe is used but a\n  warning is signalled.\n\n* If you attempt to register a package which shares a `:local-repo`\n  (either by default, or due to explicit specification) with a\n  previously registered package, and the two packages specify\n  different values for their version-control keywords (see\n  [version-control backends][#user/recipes/vc-backends]), then the new\n  recipe is used but a warning is signalled. If the repository was\n  already cloned, this means the second recipe will have no effect.\n\n  But if the second recipe was fetched automatically from a recipe\n  repository, all of its version-control keywords will be silently\n  overwritten with the ones from the first recipe, to avoid conflicts\n  (although if there are conflicts in other parts of the recipe, a\n  warning will still be displayed).\n\n#### Updating recipe repositories\n\nAs mentioned in the [conceptual overview][#concepts/lookup], recipe\nrepositories are just regular packages, with some extra code to look\nup recipes in the relevant local repository.\n\nThis means that updating a recipe repository is done the same way as\nupdating a regular package, i.e. with [`M-x\nstraight-pull-package`][#user/interactive/vc]. You should do this if\nyou find that a package isn\'t listed by `M-x\nstraight-use-package`\xe2\x80\x94perhaps it was added recently.\n\nNote that there is currently some potentially surprising behavior if\nyou update all packages at once using `M-x straight-pull-all` or `M-x\nstraight-merge-all`, and this bulk update includes recipe repository\nupdates: see [#323].\n\n#### Customizing recipe repositories\n\nThe recipe repository system is designed to be extended. Firstly, you\ncan control which recipe repositories are searched, and in what order\nof precedence, by customizing `straight-recipe-repositories`. The\ndefault value is:\n\n    (org-elpa melpa gnu-elpa-mirror emacsmirror)\n\n##### GNU ELPA\n\nYou can customize the following user options:\n\n* `straight-recipes-gnu-elpa-url`: The Git URL to use for the\n  `gnu-elpa` recipe repository.\n* `straight-recipes-gnu-elpa-use-mirror`: GNU ELPA uses a stupidly\n  complex build system for no good reason, and it\'s unlikely to change\n  any time soon. What this means for you is that you have to run the\n  Elisp-powered Makefile of the GNU ELPA repository (which has a fatal\n  bug last I checked, so you\'d have to patch it locally) *and* have a\n  full checkout of the Emacs source repository (more than 1GB) if you\n  want all the packages to work correctly. To work around this\n  problem, I maintain a [full mirror of GNU ELPA on\n  GitHub][gnu-elpa-mirror]. (The tooling used to maintain this mirror\n  is located [here][gnu-elpa-mirror-tool].) By default, `straight.el`\n  retrieves packages from this mirror instead of the source\n  repository; this behavior is controlled by the value of\n  `straight-recipes-gnu-elpa-use-mirror`. You must do any\n  customization of this variable *before* the `straight.el`\n  [bootstrap][#quickstart]. Note that setting the value of this user\n  option to nil causes the default value of\n  `straight-recipe-repositories` to shift to:\n\n      (org-elpa melpa gnu-elpa emacsmirror)\n\n##### Emacsmirror\n\nYou can customize the following user option:\n\n* `straight-recipes-emacsmirror-use-mirror`: Yes, there is also a\n  mirror for Emacsmirror. This is because the [epkgs] repository\n  contains a (frequently updated) SQLite database in it, which means\n  the Git repository takes *forever* to clone (see [#356]). My\n  solution to this problem is to generate a new repository which\n  contains the information that `straight.el` needs but which is much\n  smaller. By default, `straight.el` uses the official [epkgs]\n  repository to find packages on Emacsmirror, but you can tell it to\n  use my mirror by configuring the value of this variable to non-nil.\n  You must do any customization of this variable *before* the\n  `straight.el` [bootstrap][#quickstart]. Note that setting the value\n  of this user option to non-nil causes the default value of\n  `straight-recipe-repositories` to shift to:\n\n      (org-elpa melpa gnu-elpa-mirror emacsmirror-mirror)\n\n##### Defining new recipe repositories\n\nTo define a new recipe repository called `NAME`, you should do the\nfollowing things:\n\n* Define a function `straight-recipes-NAME-retrieve`, which takes a\n  package name as a symbol and returns a recipe for that package if it\n  is available, else nil. This is used for recipe lookup. This\n  function may assume that the local repository for the recipe\n  repository has already been cloned, and that `default-directory` has\n  been set to that local repository. This is used for recipe lookup\n  during the course of `straight-use-package`.\n* Define a function `straight-recipes-NAME-list`, which takes no\n  arguments and returns a list of strings representing packages for\n  which recipes are available. It is permissible to return some\n  strings for which recipes are actually not available, for\n  performance reasons. However, this is discouraged. (The [MELPA]\n  backend uses this functionality, since all files in the `recipes`\n  directory are potentially recipes, but only the Git-based ones can\n  actually be used.)\n* (Optional) Define a function `straight-recipes-NAME-version` which\n  returns a non-nil value indicating the current version of the logic\n  in your `straight-recipes-NAME-retrieve` function. Each time you\n  change the logic, this version value must be changed. If this\n  function is defined, then `straight.el` automatically and\n  transparently caches calls to `straight-recipes-NAME-retrieve`\n  persistently, using your version value (and its detection of\n  modifications to the recipe repository) to decide when to invalidate\n  the cache.\n* Call `straight-use-recipes` with the recipe for your recipe\n  repository. Make sure to include `:no-build` in the recipe, unless\n  you also want to use the recipe repository as an executable Emacs\n  Lisp package. Alternatively, you can take the manual approach:\n    * Call `straight-use-package-lazy` with the recipe for your recipe\n      repository.\n    * Add the symbol for your recipe repository\'s name (the car of the\n      recipe you provided, that is) to `straight-recipe-repositories`,\n      at the appropriate place.\n\n### Overriding recipes\n\nYou can always use `straight-register-package` to specify a specific\nrecipe for a package without cloning or building it, so that just in\ncase that package is requested later (possibly as a dependency, or in\nsomebody else\'s code) your recipe will be used instead of the default\none. However, this does not help in the case that a specific recipe is\npassed to `straight-use-package`.\n\nAlso, it is obviously impossible to call `straight-register-package`\nbefore `straight.el` has been loaded, so you can\'t use it to specify a\ncustom recipe for `straight.el` itself.\n\nTo remedy these difficulties, `straight.el` provides a mechanism for\nspecifically overriding the recipe for a particular package. You can\nuse it by customizing `straight-recipe-overrides`, or by calling\n`straight-override-recipe`.\n\n`straight-recipe-overrides` is an association list from [profile\nnames][#user/lockfiles/profiles] to *override alists*. If you don\'t\ncare about the profile system, you can just use a single override\nspecification, with the profile name nil. Each override alist is just\na list of recipes. Because the car of a recipe is just the package\nname as a symbol, this list of recipes is also an alist whose keys are\nrecipe names and whose values are the plists for those recipes.\n\nEven if an explicit recipe is supplied to `straight-use-package`, the\none given in `straight-recipe-overrides` will be used instead, if such\na recipe is specified there.\n\nFor convenience, you may add to `straight-recipe-overrides` by passing\na recipe to `straight-override-recipe`. This will register it in the\noverride alist for the current profile. Note that if you do this, you\nwill probably want to explicitly set `straight-recipe-overrides` to\nnil before bootstrapping `straight.el`. This will make it so that if\nyou remove a call to `straight-override-recipe` from your init-file\nand then reload it, the entry will actually be removed from\n`straight-recipe-overrides`.\n\n#### Overriding the recipe for `straight.el`\n\nAs was briefly mentioned earlier, you can actually override the recipe\nof `straight.el` itself using `straight-recipe-overrides`! How does\nthis work? Well, it\'s basically black magic. If you want the details,\ngo read the [developer manual][#dev/recipe-internals]. All you need to\nknow is that you can set `straight-recipe-overrides`, and it will\nmagically work. The only caveat is that if you change the\n`:local-repo` for `straight.el`, then you will also need to adjust the\nvalue of `bootstrap-file` in the [bootstrap snippet][#quickstart]\naccordingly, since otherwise your init-file will not know where to\nfind `straight.el`. (You must use `straight-recipe-overrides` instead\nof `straight-override-recipe`, since the latter function definition\nhasn\'t been loaded yet before `straight.el` is installed and\nbootstrapped.)\n\nHere is the default recipe used for `straight.el`, if you don\'t\noverride it:\n\n    (straight :type git :host github\n              :repo ,(format "%s/straight.el" straight-repository-user)\n              :files ("straight*.el")\n              :branch ,straight-repository-branch)\n\nNote that even though the bootstrap snippet references the `develop`\nbranch of `straight.el`, the default recipe installs from `master`.\n\nIf all you want to do is change which branch you are installing\n`straight.el` from, simply customize the variable\n`straight-repository-branch`, which is provided for this purpose.\n(Although using `straight-recipe-overrides` will work just as well, at\nleast until the recipe happens to be changed upstream and your\ninit-file isn\'t updated.)\n\nSimilarly, if all you want to do is switch to your own fork of\n`straight.el` on GitHub, simply customize the variable\n`straight-repository-user` to your GitHub username.\n\nThere is one minor caveat to the above discussion. If your fork makes\nchanges to the way in which recipes are interpreted, then those\nchanges will not be effective during the interpretation of your own\nrecipe for `straight.el`. If you wish for them to be, then you will\nhave to follow the same procedure that is followed in `straight.el`\nitself for making changes to recipe interpretation. These details are\noutlined in the [developer manual][#dev/recipe-internals]; see also\n`install.el` for an explanation of this aspect of the bootstrap\nmechanism.\n\n### Interactive usage\n\nThe primary usage of `straight.el` is expected to be in your\ninit-file. For example, this is where you will need to put the\nbootstrap code as well as any packages that you always want to be\ninstalled. However, there are three important interactive uses of\n`straight.el`: temporary installation of packages, various helpful\nutility functions, and [version control\noperations][#user/interactive/vc].\n\nTo install a package temporarily, run `M-x straight-use-package`. All\nregistered recipe repositories will be cloned, and you will be\npresented with a combined list of all recipes available from them.\nSimply select a package and it will be cloned, built, and loaded\nautomatically. This does not affect future Emacs sessions.\n\nIf you provide a prefix argument to `M-x straight-use-package`, then\nyou are presented with a list of registered recipe repositories. After\nyou select one, you are shown a list of recipes specifically from that\nrecipe repository. This is helpful if you do not want to clone all\nregistered recipe repositories, or you have a particular recipe\nrepository in mind.\n\nYou can also call `M-x straight-get-recipe`, which has the same\ninterface as `M-x straight-use-package`, except that instead of the\npackage being cloned, built, and loaded, its recipe is copied to the\nkill ring. If you are writing a custom recipe, this may be helpful,\nbecause you may be able to reuse parts of the existing recipe,\nparticularly the `:files` directive.\n\nNormally, packages are rebuilt automatically if needed, when Emacs\nrestarts. If you for some reason want them to be rebuilt at another\ntime, you can call `M-x straight-check-all` to rebuild all packages\nthat have been modified since their last build. Alternatively, use\n`M-x straight-rebuild-all` to unconditionally rebuild all packages.\nNote that this will probably take a while. There are also `M-x\nstraight-check-package` and `M-x straight-rebuild-package`, which\nallow you to select a particular package to check or rebuild.\n\nFinally, you may use `M-x straight-prune-build` in order to tell\n`straight.el` to forget about any packages which were not registered\nsince the last time you loaded your init-file. This may improve\nperformance, although only slightly, and will clean up stale entries\nin the `build` directory. You can call this function in your init-file\nif you really wish your filesystem to be as clean as possible,\nalthough it\'s not particularly recommended as the performance\nimplications are uninvestigated. If you do call it in your init-file,\nbe sure to only call it on a fully successful init; otherwise, an\nerror during init will result in some packages\' build information\nbeing discarded, and they will need to be rebuilt next time.\n\nIf you have enabled [autoloads caching][#user/install/loading], it is\nadvisable to call `straight-prune-build` occasionally, since otherwise\nthe build cache may grow quite large over time.\n\n#### Version control operations\n\n`straight.el` provides a number of highly interactive workflows for\nmanaging your package\'s local repositories, using the configured\n[version-control backends][#user/recipes/vc-backends]. They are as\nfollows:\n\n* `M-x straight-normalize-package`: normalize a package\n* `M-x straight-normalize-all`: normalize all packages\n* `M-x straight-fetch-package`: fetch from a package\'s configured\n  remote; with prefix argument, then for forks also fetch from the\n  upstream\n* `M-x straight-fetch-package-and-deps`: fetch from the configured\n  remotes of a package and all of its dependencies (including the\n  dependencies of its dependencies); with prefix argment, then for\n  forks also fetch from the upstream\n* `M-x straight-fetch-all`: fetch from all packages\' configured\n  remotes; with prefix argument, then for forks also fetch from the\n  upstreams\n* `M-x straight-merge-package`: merge the latest version fetched from\n  a package\'s configured remote into the local copy; with prefix\n  argument, then for forks also merge from the upstream\n* `M-x straight-merge-package-and-deps`: merge the latest versions\n  fetched from the configured remotes of a package and all of its\n  dependencies (including the dependencies of its dependencies); with\n  prefix argment, then for forks also merge from the upstreams\n* `M-x straight-merge-all`: merge the latest versions fetched from\n  each package\'s configured remote into its local copy; with prefix\n  argument, then for forks also merge from the upstreams\n* `M-x straight-pull-package`: combination of `M-x\n  straight-fetch-package` and `M-x straight-merge-package`\n* `M-x straight-pull-package-and-deps`: combination of `M-x\n  straight-fetch-package-and-deps` and `M-x\n  straight-merge-package-and-deps`\n* `M-x straight-pull-all`: combination of `M-x straight-fetch-all` and\n  `M-x straight-merge-all`\n* `M-x straight-push-package`: push a package to its remote, if\n  necessary\n* `M-x straight-push-all`: push all packages to their remotes, if\n  necessary\n\nSee the sections on [version-control\nbackends][#user/recipes/vc-backends] and the [Git\nbackend][#user/recipes/git] in particular for more information about\nthe meanings of these operations.\n\n### Lockfile management\n\n`straight.el` determines your package management configuration from\ntwo, and only two, sources: the contents of your init-file, and your\nversion lockfiles (which are optional). Your init-file specifies the\nconfiguration of `straight.el` (for example, the values of\n`straight-recipe-overrides` and `straight-default-vc`), the packages\nyou want to use, and their recipes. Your version lockfiles specify the\nexact revisions of each package, recipe repository, and even\n`straight.el` itself. Together, they lock down your Emacs\nconfiguration to a state of no uncertainty: perfect reproducibility.\n\nTo write the current revisions of all your packages into version\nlockfiles, run `M-x straight-freeze-versions`. This will first check\nthat `straight.el` has an up-to-date account of what packages are\ninstalled by your init-file, then ensure that all your local changes\nare pushed (remember, we are aiming for perfect reproducibility!). If\nyou wish to bypass these checks, provide a prefix argument.\n\nVersion lockfiles are written into `~/.emacs.d/straight/versions`. By\ndefault, there will be one, called `default.el`. It is recommended\nthat you keep your version lockfiles under version control with the\nrest of your Emacs configuration. If you symlink your init-file into\n`~/.emacs.d` from somewhere else, you should also make sure to symlink\nyour version lockfiles into `~/.emacs.d/straight/versions`. On a new\nmachine, do this *before* launching Emacs: that way, `straight.el` can\nmake sure to check out the specified revisions of each package when\ncloning them for the first time.\n\nTo install the versions of the packages specified in your version\nlockfiles, run `M-x straight-thaw-versions`. Thawing will\ninteractively check for local changes before checking out the relevant\nrevisions, so don\'t worry about things getting overwritten.\n\n#### The profile system\n\n`straight.el` has support for writing multiple version lockfiles,\ninstead of just one. Why? Consider a large Emacs configuration such as\n[Radian], [Spacemacs], or [Prelude], which is used by many different\npeople. There are two parts to the configuration that is actually\nloaded: the "default" part, and the local customizations that each\nuser has added. Generally, these configurations have a mechanism for\nmaking local customizations without forking the entire project.\n\nSo Radian will have some set of packages that it requires, and my\nlocal customizations of Radian have some other set of packages that\nthey require. In order for me to maintain Radian, I need to be able to\nseparate Radian\'s packages (which go into a versions lockfile in the\nRadian repository) from my own local packages (which go into a\nversions lockfile in my own private local dotfiles repository).\n`straight.el` provides this ability through the *profile system*.\n\nThe idea is that whenever a package is registered, either directly or\nas a dependency, it is associated with a given profile. Any given\npackage can be associated with multiple profiles.\n\nWhen you call `straight-use-package`, which profile the registered\npackages are associated with is determined by the value of\n`straight-current-profile`, which defaults to nil. In Radian, for\nexample, `straight-current-profile` is bound to `radian` while the\nRadian libraries are being loaded, and it is bound to `radian-local`\nwhile the user\'s local customizations are being loaded. This results\nin Radian packages being associated with the `radian` profile, and the\nuser\'s local packages being associated with the `radian-local`\nprofile.\n\nWhen you call `M-x straight-freeze-versions`, one or more version\nlockfiles are written, according to the value of `straight-profiles`.\nThis variable is an association list whose keys are symbols naming\nprofiles and whose values are filenames for the corresponding version\nlockfiles to be written into `~/.emacs.d/straight/versions`. You\nshould make sure that each potential value of\n`straight-current-profile` has a corresponding entry in\n`straight-profiles`, since otherwise some packages might not be\nwritten into your lockfiles.\n\nWhen customizing [`straight-recipe-overrides`][#user/overriding], note\nthat if multiple profiles are set to override the same recipe, then\nthe last one listed in `straight-profiles` will take precedence.\nSimilarly, when using `M-x straight-thaw-versions`, if different\nlockfiles specify revisions for the same local repository, the last\none in `straight-profiles` will take precedence.\n\n### Packages and the init-file\n\nPackage managers like `package.el` store mutable state outside your\ninit-file, including the set of packages that are installed.\n`straight.el` does not do this, so it has a rather different way of\ndetermining what packages are installed. To `straight.el`, a package\nis part of your Emacs configuration if it is passed to\n`straight-use-package` when your init-file is loaded.\n\nNote that this means packages installed interactively (using `M-x\nstraight-use-package`) are not considered part of your Emacs\nconfiguration, since the invocation of `straight-use-package` does not\nhappen in your init-file.\n\nThis raises an interesting question: if you *add* a package to your\ninit-file, how can you convince `straight.el` that it really is part\nof your init-file, and not just part of a temporary\n`straight-use-package` form that you evaluated ad-hoc? The answer is\nsimple: *reload your entire init-file*. That way, `straight.el` will\nsee whether or not that package is registered during your init-file.\n\nOne might ask how `straight.el` determines that you have finished\nloading your init-file. The answer is simple: `run-with-idle-timer` is\nused to execute code only after the current interactive operation has\nfinished. The implementation of this concept is part of the\n*transaction system* of `straight.el`, and it is also used to amortize\ncertain performance costs when many calls to `straight-use-package`\nare made sequentially. However, since the transaction system (at least\nin recent versions of `straight.el`) operates transparently, its\ndetails are relegated to the [developer manual][#dev/transactions].\n\n### Using `straight.el` to reproduce bugs\n\nOne of the major reasons I wanted to write `straight.el` was that\nexisting package managers were not good for reproducing bugs. For\ninstance, some of them would load all installed packages when the\npackage manager was initialized! Obviously that is not acceptable for\na "minimal test case".\n\nOn the contrary, bootstrapping `straight.el` does not load anything\nexcept for `straight.el` itself (the default recipe repositories are\nregistered, but not cloned until needed). You should normally be\nloading `straight.el` by means of the [bootstrap\nsnippet][#quickstart], but when you are in `emacs -Q`, here is how you\ncan initialize `straight.el`:\n\n    M-x load-file RET ~/.emacs.d/straight/repos/straight.el/bootstrap.el RET\n\nYou can also do this from the command line, perhaps by creating an\nalias for it:\n\n    $ emacs -Q -l ~/.emacs.d/straight/repos/straight.el/bootstrap.el\n\nLet\'s say you are making a bug report for Projectile. To load just\nProjectile and all of its dependencies, run:\n\n    M-x straight-use-package RET projectile RET\n\nNote that this will use the currently checked-out revisions of\nProjectile and all of its dependencies, so you should take note of\nthose in order to make your bug report.\n\n### Integration with other packages\n#### Integration with `use-package`\n\nBy default, `straight.el` installs a new keyword `:straight` for\n`use-package` which may be used to install packages via `straight.el`.\nThe algorithm is extremely simple. This:\n\n    (use-package el-patch\n      :straight t)\n\nmacroexpands (essentially) to:\n\n    (straight-use-package \'el-patch)\n\nAnd this:\n\n    (use-package el-patch\n      :straight (:host github :repo "raxod502/el-patch"\n                 :branch "develop"))\n\nbecomes:\n\n    (straight-use-package\n     \'(el-patch :host github :repo "raxod502/el-patch"\n                :branch "develop"))\n\nIf the feature you are requiring with `use-package` is different from\nthe package name, you can provide a full recipe:\n\n    (use-package tex-site\n      :straight (auctex :host github\n                        :repo "emacsmirror/auctex"\n                        :files (:defaults (:exclude "*.el.in"))))\n\nAnd you may also provide just the package name:\n\n    (use-package tex-site\n      :straight auctex)\n\nIf you don\'t provide `:straight`, then by default nothing happens. You\nmay customize `straight-use-package-by-default` to make it so that\n`:straight t` is assumed unless you explicitly override it with\n`:straight nil`.\n\nPreviously, `straight.el` used a different syntax for its\n`use-package` integration. For backwards compatibility, you can use\nthis syntax instead by customizing `straight-use-package-version`.\n\nYou can disable `use-package` integration entirely by customizing\n`straight-enable-use-package-integration`.\n\n#### "Integration" with `package.el`\n\nBy default, `package.el` will automatically insert a call to\n`package-initialize` into your init-file as soon as Emacs starts,\nwhich is ridiculous. It will also do this when you perform any package\nmanagement operation. A separate system inserts some `custom` forms\ninto your init-file when you install a package. `straight.el` disables\nall of these "features" by setting `package-enable-at-startup` to nil\nand enabling some advices. You can override this behavior by\ncustomizing `straight-enable-package-integration`, however.\n\nTo help avoid you shooting yourself in the foot by using both\n`:ensure` and `:straight` at the same time in a `use-package` form\n(which would cause the same package to be installed twice using two\ndifferent package managers), `straight.el` will helpfully disable\n`:ensure` whenever you include `:straight` in a `use-package` form.\nSee [#425].\n\n#### Integration with Org\n\nOrg expects you to run `make` in its source repository before you run\nit, but `straight.el` does not yet support running such build systems\nautomatically (see [#72]). This presents two problems:\n\n* Byte-compiling Org without running `make` first produces some\n  annoying warnings.\n* Running `make` generates a file `org-version.el` which provides the\n  functions `org-git-version` and `org-release`. Thus the version of\n  Org provided by `straight.el` does not include these functions, but\n  the obsolete version of Org provided by Emacs (see [the\n  FAQ][#faq/package-versions]) does. This can result in the obsolete\n  version getting partially loaded, which is confusing.\n\nSee [#211] for discussion.\n\nBy default, `straight.el` installs a hack (namely, defining the\nfunctions `org-git-version` and `org-release` itself) whenever you ask\nit to install Org. This functionality is implemented using\n[`straight-use-package-prepare-functions`][#user/install/hooks]. You\ncan disable it by setting the value of the variable `straight-fix-org`\nto nil.\n\n#### Integration with Hydra\n\nSee [the Hydra wiki][hydra-wiki-straight-entry].\n\n### Miscellaneous\n\n* By default, `straight.el` explains what it is doing in the echo\n  area, like this:\n\n      Looking for cider recipe \xe2\x86\x92 Cloning melpa...\n\n  If your terminal does not support Unicode characters nicely, you can\n  customize `straight-arrow` to display something else for the arrow.\n\n* By default, `straight.el` reports process output the\n  `*straight-process*` buffer. You can customize the name of this\n  buffer via the `straight-process-buffer` user option. If you want to\n  hide this buffer by default, consider adding a leading space to the\n  name.\n\n* You can prevent `straight.el` from making any modifications to the\n  filesystem (though it may still read) by customizing the user option\n  `straight-safe-mode` to non-nil. This may be useful for running\n  tasks automatically in batch mode, to avoid multiple concurrent\n  Emacs processes all making changes to the filesystem. For an example\n  of how this feature may be used to safely implement asynchronous\n  byte-compilation of the init-file on successful startup, see\n  [Radian].\n\n## Developer manual\n\nThis section tells you about all the interesting implementation\ndetails and design decisions that power `straight.el` behind the\nscenes. It assumes you have already read the [user manual][#user] and\nthe [conceptual overview][#concepts].\n\nUnfortunately, I haven\'t yet had time to write it. See [#51].\n\n## Trivia\n\nThis section has random, (possibly) interesting tidbits about\n`straight.el` that don\'t fit in the other sections.\n\n### Comments and docstrings\n\nHow did I get that statistic about the percentage of `straight.el`\nthat is comments and docstrings? Simple: by abusing the syntax\nhighlighting.\n\n    (let ((lines (make-hash-table :test #\'equal)))\n      (goto-char (point-min))\n      (while (< (point) (point-max))\n        (when (memq (face-at-point)\n                    \'(font-lock-comment-face\n                      font-lock-doc-face))\n          (puthash (line-number-at-pos) t lines))\n        (forward-char))\n      (* (/ (float (length (hash-table-keys lines)))\n            (line-number-at-pos))\n         100))\n\nNote that you will have to scroll through the entire buffer first,\nsince `font-lock-mode` computes syntax highlighting lazily.\n\n## Contributing\n\nPlease do! Development takes place on the `develop` branch. You can\nswitch to that branch with\n\n    (setq straight-repository-branch "develop")\n\nand base your pull requests from it. If you have an outstanding pull\nrequest whose features you would like to use in your configuration,\nthere is full support for defining `straight.el` as coming from any\nbranch in any fork:\n\n    (setq straight-repository-user "my-github-username")\n    (setq straight-repository-branch "feat/my-cool-feature")\n\nPlease try to follow the style of the surrounding code and\ndocumentation, but anything is welcome.\n\nWe require that the linting pass on all new commits. You can check\nthis easily by installing [Docker] and running\n\n    $ make docker\n\nThen you will be in a shell with the `straight.el` source code, and to\ntest your commits you\'ll be able to run\n\n    $ make lint\n\nor to see what other targets are available\n\n    $ make help\n\nIf you don\'t want to install Docker, you can simply skip the `make\ndocker` step, and everything will work the same! However, you\'ll then\nhave to make sure you have the relevant dependencies installed\nlocally.\n\nWhen you create a pull request, it will be [tested\nautomatically][circleci-build] on [CircleCI] and the status will be\nreported. Please make sure the CI build is passing before asking for\nreview.\n\n## FAQ\n### My init time got slower\n\nYour first step should be to customize the value of\n`straight-check-for-modifications`. The best setting is `(watch-files\nfind-when-checking)`; this is not enabled by default because it is\nimpolite to spawn persistent background processes without asking, and\nbecause you must install [Python 3][python] and\n[`watchexec`][watchexec] for it to work. If you can\'t stand the extra\ndependencies and background process, consider the setting\n`(check-on-save find-when-checking)` instead, which is just as fast\nbut won\'t catch package modifications unless they are made within\nEmacs via the `save-buffer` command.\n\nEven with lazy modification detection, as described above,\n`straight.el` is not quite as fast as `package.el` (by a few\npercentage points). There are some planned changes which will make\n`straight.el` just as fast as `package.el`, if not faster. See [#9].\n\n### How do I update MELPA et al.?\n\nUsing [`M-x straight-pull-package`][#user/interactive/vc], like for\nany other package. [Read more.][#user/lookup/update]\n\n### The wrong version of my package was loaded\n\nTo explain this problem, let us consider a concrete example. In [this\nissue][#355], a user found that the code\n\n    (straight-use-package \'company-lsp)\n    (straight-use-package \'eglot)\n\nsometimes resulted in runtime errors because an old version of Flymake\nwas being used.\n\nThe root problem here is that you want the most recent version of\nFlymake to be installed by `straight.el`, but Emacs also ships an\nolder version, and that older version is getting loaded instead.\n\nThe older version will be loaded if `(require \'flymake)` (or similar)\nis invoked before `straight.el` has made Flymake available (by means\nof `(straight-use-package \'flymake)` or similar). But why would\n`straight.el` not make Flymake available?\n\nThe only way that `straight.el` knows to make Flymake available is if\neither you manually invoke `straight-use-package` in your init-file,\nor if one of the packages that you request in your init-file declares\nFlymake as a dependency. Now, any package that uses Flymake ought to\ndeclare it as a dependency. Thus, there should be no way for a package\nto load the Emacs-provided version of Flymake. However, sometimes\npackage authors overlook this problem (it does not always cause an\nerror, and sometimes package authors do not test exhaustively enough).\n\nIn this case, the problem was that `company-lsp` declared a dependency\non `lsp-mode`, and `lsp-mode` used Flymake without declaring a\ndependency on `flymake`. There are two ways to work around the\nproblem:\n\n* (Preferable) Fix `lsp-mode` to declare a dependency on `flymake`.\n* (Workaround) Manually invoke `(straight-use-package \'flymake)`\n  before `(straight-use-package \'company-lsp)`.\n\nIf you test this yourself, you might find it difficult to reproduce\nthe problem. That is because there is only an issue when Flymake is\nactually loaded, and this doesn\'t necessarily happen when invoking\n`(straight-use-package \'company-lsp)` *unless* `straight.el` needs to\nrebuild the relevant packages (which includes byte-compilation, which\nsometimes means actually loading dependencies). Keep this in mind when\ntesting.\n\nThis problem commonly occurs with Org, since (1) Org is popular, (2)\nEmacs ships an obsolete version of Org, (3) many users want to use the\nup-to-date version, and (4) Org breaks backwards compatibility\nfrequently. To solve it, simply make sure that you invoke\n`(straight-use-package \'org)` or `(straight-use-package\n\'org-plus-contrib)` before running any code that could load Org,\nincluding installing any package that lists it as a dependency. See\nalso the [integration with Org][#user/integration/org] section for\nmore fun problems you can encounter with Org.\n\nSee [this issue][#236] for discussion about ways of mitigating the bad\nUX of this situation.\n\n### I get "could not read username/password" errors\n\nThis is because `straight.el` is not currently able to detect when SSH\nor Git asks for your username and/or password/passphrase and then pipe\nthat prompt through to the minibuffer ([#334]).\n\nTo work around the problem, set up [git-credential-cache] if you use\nHTTPS, and [ssh-agent] if you use SSH. That way, you won\'t be prompted\nfor your username/password. When setting up ssh-agent, be careful to\nmake sure that the relevant environment variables get set in Emacs.\nThis might be tricky since starting Emacs from the desktop (rather\nthan from the command line) sometimes results in it not inheriting any\nenvironment variables from your shell.\n\n### The interactive version-control operations are confusing\n\nThis part of `straight.el` still needs some work; see [#54] about the\nUX of pushing and pulling.\n\n### How do I pin package versions or use only tagged releases?\n\nThis is a planned feature. In the meantime, contributors have proposed\nvarious workarounds. See [#246] and [#31].\n\n`straight-x.el` now contains an experimental solution. In order to use\nit you will need to add similar snippets to your Emacs configuration.\n\nFirst you need to add a new profile to `straight-profiles` which also\nneeds to be the last profile in the list. This should be done before\nyou bootstrap `straight.el`.\n\n    ;; Tell straight.el about the profiles we are going to be using.\n    (setq straight-profiles\n          \'((nil . "default.el")\n            ;; Packages which are pinned to a specific commit.\n            (pinned . "pinned.el")))\n\nAfter straight\'s install procedure you will need to add\n`straight-x.el` and load the required commands.\n\n    (autoload #\'straight-x-pull-all "straight-x")\n    (autoload #\'straight-x-freeze-versions "straight-x")\n\nA variable called `straight-x-pinned-packages` has been defined in\n`straight-x.el` and will contain your list of pinned packages.\n\nFrom now on, you can pin a package to a specific commit like in the\nfollowing example which will pin `org-mode` to the 9.2.3 release\nversion:\n\n    (let ((straight-current-profile \'pinned))\n      (straight-use-package \'org-plus-contrib)\n      (straight-use-package \'org)\n      ;; Pin org-mode version.\n      (add-to-list \'straight-x-pinned-packages\n                   \'("org" . "924308a150ab82014b69c46c04d1ab71e874a2e6")))\n\nIf you invoke `straight-x-freeze-versions` it will first write the\ndefault lockfile and then pinned lockfile which takes precedence over\nthe default one if packages are thawed. `straight-x-pull-all` will\nfirst invoke `straight-pull-all` and then restore all pinned packages.\n\nYou might want to assign the following aliases for more convenience:\n\n    (defalias \'straight-pull-all #\'straight-x-pull-all)\n    (defalias \'straight-freeze-versions #\'straight-x-freeze-versions)\n\nPlease keep in mind that this is only a temporary solution and\nexperimental!\n\n### How can I use the built-in version of a package?\n\nTo tell `straight.el` that you want to use the version of Org shipped\nwith Emacs, rather than cloning the upstream repository:\n\n    (straight-use-package \'(org :type built-in))\n\n[Read more.][#user/recipes]\n\n## News\n### July 6, 2019\n\nThe default value of the user option `straight-emacsmirror-use-mirror`\nis now non-nil.\n\n### May 24, 2019\n\nI have completely rewritten the transaction system. The practical\nimpact of this is that you no longer have to care about it. Simply\nremove all references to the following functions and variables from\nyour configuration, and everything should "just work":\n\n* `straight-transaction`\n* `straight-begin-transaction`\n* `straight-finalize-transaction`\n* `straight-mark-transaction-as-init`\n* `straight-treat-as-init`\n\n### May 22, 2019\n\nI now maintain a mirror of Emacsmirror. (Bear with me here.) The\nadvantage of using my mirror is that cloning it is several orders of\nmagnitude faster than cloning the official Emacsmirror. You can tell\n`straight.el` to do so by customizing the user option\n`straight-emacsmirror-use-mirror` to non-nil.\n\n### May 1, 2019\n\n`straight-thaw-versions` now fetches in a repository if a commit in\nyour lockfile can not be found and normalizes the repository to the\nrecipe\'s default branch. This should ensure that versions you have\nfrozen can be quickly restored and that they can also be saved back to\nthe version lock file. This addresses issues [#58], [#66], and [#294].\n\n### March 15, 2019\n\n`straight.el` [now installs a hack for Org by\ndefault][#user/integration/org], so Org should work out of the box\nwith no compile warnings. If you have code to work around the problem\nin your init-file, you can safely remove it. To avoid installing the\nhack, customize the variable `straight-fix-org`.\n\n### December 22, 2018\n\nThe default value of the user option\n`straight-recipes-gnu-elpa-use-mirror` is now non-nil.\n\n### September 12, 2018\n\n`straight.el` now supports specifying configuration for your fork of a\npackage via the new `:fork` keyword. The previously supported\n`:upstream` keyword is now deprecated, but still works for backwards\ncompatibility. To support this change, the user options\n`straight-vc-git-primary-remote` and `straight-vc-git-upstream-remote`\nare deprecated (but still work for backwards compatibility), as they\nhave been superseded by the new user options\n`straight-vc-git-default-remote-name` and\n`straight-vc-git-default-fork-name`. Your usage should be updated.\n\n### July 19, 2018\n\n`straight.el` now automatically caches the recipes it looks up in\nrecipe repositories. This should lead to a reduction in\n`straight.el`-related startup time of as much as 50% if you also use\nlive modification detection, as disk IO and usage of external\nprocesses are reduced significantly.\n\nNo changes to user configuration are necessary; however, if you define\na custom recipe repository (call it `NAME`) then caching is not\nenabled by default. To enable caching, define a\n`straight-recipes-NAME-version` function which returns a non-nil value\nindicating the current version of the logic in\n`straight-recipes-NAME-retrieve`. This version value needs to be\nchanged each time you change the logic, so that the recipe lookup\ncache for that recipe repository may automatically be invalidated.\n\n### July 12, 2018\n\nI now maintain a [full mirror of GNU ELPA on GitHub][gnu-elpa-mirror].\nYou can tell `straight.el` to use it by customizing the user option\n`straight-recipes-gnu-elpa-use-mirror`, and this will allow you to use\npackages such as AUCTeX correctly, which was previously impossible.\nNote that the user option must be customized *before* the\n`straight.el` [bootstrap][#quickstart].\n\n[#principles]: #guiding-principles\n[#quickstart]: #getting-started\n[#faq]: #faq\n [#faq/package-versions]: #the-wrong-version-of-my-package-was-loaded\n[#concepts]: #conceptual-overview\n [#concepts/lookup]: #where-do-recipes-come-from\n [#concepts/straight-use-package]: #what-happens-when-i-call-straight-use-package\n[#comparison]: #comparison-to-other-package-managers\n [#comparison/package.el]: #comparison-to-packageel\n  [#comparison/package.el/+straight.el]: #advantages-of-straightel\n[#user]: #user-manual\n [#user/install]: #installing-packages-programmatically\n  [#user/install/mod-detection]: #customizing-when-packages-are-built\n  [#user/install/loading]: #customizing-how-packages-are-made-available\n  [#user/install/hooks]: #hooks-run-by-straight-use-package\n [#user/recipes]: #the-recipe-format\n [#user/recipes/vc-backends]: #version-control-backends\n [#user/recipes/git]: #git-backend\n [#user/lookup]: #recipe-lookup\n  [#user/lookup/update]: #updating-recipe-repositories\n  [#user/lookup/repos]: #customizing-recipe-repositories\n [#user/overriding]: #overriding-recipes\n  [#user/overriding/straight.el]: #overriding-the-recipe-for-straightel\n [#user/interactive]: #interactive-usage\n  [#user/interactive/vc]: #version-control-operations\n [#user/lockfiles]: #lockfile-management\n  [#user/lockfiles/profiles]: #the-profile-system\n [#user/integration]: #integration-with-other-packages\n  [#user/integration/use-package]: #integration-with-use-package-1\n  [#user/integration/org]: #integration-with-org\n[#dev]: #developer-manual\n [#dev/vc-backends]: #developer-manual\n [#dev/recipe-formats]: #developer-manual\n [#dev/recipe-internals]: #developer-manual\n [#dev/transactions]: #developer-manual\n[#trivia]: #trivia\n [#trivia/comments]: #comments-and-docstrings\n[#news]: #news\n\n[#9]: https://github.com/raxod502/straight.el/issues/9\n[#31]: https://github.com/raxod502/straight.el/issues/31\n[#51]: https://github.com/raxod502/straight.el/issues/51\n[#54]: https://github.com/raxod502/straight.el/issues/54\n[#58]: https://github.com/raxod502/straight.el/issues/58\n[#72]: https://github.com/raxod502/straight.el/issues/72\n[#95-c1]: https://github.com/raxod502/straight.el/issues/95#issuecomment-316379495\n[#110]: https://github.com/raxod502/straight.el/issues/110\n[#115]: https://github.com/raxod502/straight.el/issues/115\n[#119]: https://github.com/raxod502/straight.el/issues/119\n[#211]: https://github.com/raxod502/straight.el/issues/211\n[#236]: https://github.com/raxod502/straight.el/issues/236\n[#246]: https://github.com/raxod502/straight.el/issues/246\n[#323]: https://github.com/raxod502/straight.el/issues/323\n[#334]: https://github.com/raxod502/straight.el/issues/334\n[#355]: https://github.com/raxod502/straight.el/issues/355\n[#356]: https://github.com/raxod502/straight.el/issues/356\n[#357]: https://github.com/raxod502/straight.el/issues/357\n[#425]: https://github.com/raxod502/straight.el/issues/425\n\n[auto-compile]: https://github.com/tarsius/auto-compile\n[borg]: https://github.com/emacscollective/borg\n[cask]: https://github.com/cask/cask\n[circleci]: https://circleci.com/\n[circleci-build]: https://circleci.com/gh/raxod502/straight.el\n[develop]: https://github.com/raxod502/straight.el/tree/develop\n[docker]: https://www.docker.com/\n[el-get]: https://github.com/dimitri/el-get\n[emacs]: https://www.gnu.org/software/emacs/\n[emacsmirror]: https://emacsmirror.net/\n[emacswiki]: https://www.emacswiki.org/\n[epkg]: https://github.com/emacscollective/epkg\n[epkgs]: https://github.com/emacsmirror/epkgs\n[git-credential-cache]: https://git-scm.com/docs/git-credential-cache\n[gitter-badge]: https://badges.gitter.im/raxod502/straight.el.svg\n[gitter]: https://gitter.im/raxod502/straight.el\n[gnu-elpa-mirror-tool]: https://github.com/raxod502/gnu-elpa-mirror\n[gnu-elpa-mirror]: https://github.com/emacs-straight\n[gnu-elpa]: https://elpa.gnu.org/\n[homebrew]: https://brew.sh/\n[hydra-wiki-straight-entry]: https://github.com/abo-abo/hydra/wiki/straight.el\n[hydra]: https://github.com/abo-abo/hydra\n[issues]: https://github.com/raxod502/straight.el/issues\n[magit]: https://magit.vc/\n[markdown-toc]: https://github.com/jonschlinkert/markdown-toc\n[melpa-recipe-format]: https://github.com/melpa/melpa#recipe-format\n[melpa]: http://melpa.org/#/\n[package.el-format]: https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging-Basics.html\n[package.el]: https://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html\n[prelude]: https://github.com/bbatsov/prelude\n[property-lists]: https://www.gnu.org/software/emacs/manual/html_node/elisp/Property-Lists.html\n[python]: https://www.python.org/\n[quelpa]: https://github.com/quelpa/quelpa\n[radian]: https://github.com/raxod502/radian\n[spacemacs]: http://spacemacs.org/\n[ssh-agent]: https://www.ssh.com/ssh/agent\n[symlinks-creators]: https://blogs.windows.com/buildingapps/2016/12/02/symlinks-windows-10/\n[symlinks-microsoft]: https://msdn.microsoft.com/en-us/library/bb530410.aspx#vistauac_topic8\n[symlinks-perforce]: https://community.perforce.com/s/article/3472\n[symlinks-stackoverflow]: https://stackoverflow.com/a/29065060/3538165\n[travis-badge]: https://travis-ci.org/raxod502/straight.el.svg?branch=develop\n[travis-build]: https://travis-ci.org/raxod502/straight.el\n[use-package]: https://github.com/jwiegley/use-package\n[watchexec]: https://github.com/mattgreen/watchexec\n'