b'# Nimble [![Build Status](https://travis-ci.org/nim-lang/nimble.svg?branch=master)](https://travis-ci.org/nim-lang/nimble)\n\nNimble is a *beta*-grade *package manager* for the [Nim programming\nlanguage](https://nim-lang.org).\n\nInterested in learning **how to create a package**? Skip directly to that section\n[here](#creating-packages).\n\n## Contents\n\n- [Requirements](#requirements)\n- [Installation](#installation)\n- [Nimble usage](#nimble-usage)\n  - [nimble refresh](#nimble-refresh)\n  - [nimble install](#nimble-install)\n  - [nimble uninstall](#nimble-uninstall)\n  - [nimble build](#nimble-build)\n  - [nimble run](#nimble-run)\n  - [nimble c](#nimble-c)\n  - [nimble list](#nimble-list)\n  - [nimble search](#nimble-search)\n  - [nimble path](#nimble-path)\n  - [nimble init](#nimble-init)\n  - [nimble publish](#nimble-publish)\n  - [nimble tasks](#nimble-tasks)\n  - [nimble dump](#nimble-dump)\n- [Configuration](#configuration)\n- [Creating Packages](#creating-packages)\n  - [Project structure](#project-structure)\n    - [Tests](#tests)\n  - [Libraries](#libraries)\n  - [Binary packages](#binary-packages)\n  - [Hybrids](#hybrids)\n  - [Dependencies](#dependencies)\n    - [External dependencies](#external-dependencies)\n  - [Nim compiler](#nim-compiler)\n  - [Versions](#versions)\n    - [Releasing a new version](#releasing-a-new-version)\n- [Publishing packages](#publishing-packages)\n- [.nimble reference](#nimble-reference)\n  - [[Package]](#package)\n    - [Required](#required)\n    - [Optional](#optional)\n  - [[Deps]/[Dependencies]](#depsdependencies)\n    - [Optional](#optional)\n- [Troubleshooting](#troubleshooting)\n- [Nimble\'s folder structure and packages](#nimbles-folder-structure-and-packages)\n- [Repository information](#repository-information)\n- [Contribution](#contribution)\n- [About](#about)\n\n## Requirements\n\nNimble has some runtime dependencies on external tools, these tools are used to\ndownload Nimble packages. For instance, if a package is hosted on\n[GitHub](https://github.com), you need to have [git](https://www.git-scm.com)\ninstalled and added to your environment ``PATH``. Same goes for\n[Mercurial](http://mercurial.selenic.com) repositories on\n[Bitbucket](https://bitbucket.org). Nimble packages are typically hosted in Git\nrepositories so you may be able to get away without installing Mercurial.\n\n**Warning:** Ensure that you have a fairly recent version of Git installed.\nIf the version is older than 1.9.0, then Nimble may have trouble using it.\nSee [this issue](https://github.com/nim-lang/nimble/issues/105) for more\ninformation.\n\n## Installation\n\nNimble is now bundled with [Nim](https://nim-lang.org)\n(since Nim version 0.15.0).\nThis means that you should have Nimble installed already, as long as you have\nthe latest version of Nim installed as well. Because of this **you likely do\nnot need to install Nimble manually**.\n\nBut in case you still want to install Nimble manually, you can follow the\nfollowing instructions.\n\nThere are two ways to install Nimble manually. Using ``koch`` and using Nimble\nitself.\n\n### Using koch\n\nThe ``koch`` tool is included in the Nim distribution and\n[repository](https://github.com/nim-lang/Nim/blob/devel/koch.nim).\nSimply navigate to the location of your Nim installation and execute the\nfollowing command to compile and install Nimble.\n\n```\n./koch nimble\n```\n\nThis will clone the Nimble repository, compile Nimble and copy it into\nNim\'s bin directory.\n\n### Using Nimble\n\nIn most cases you will already have Nimble installed, you can install a newer\nversion of Nimble by simply running the following command:\n\n```\nnimble install nimble\n```\n\nThis will download the latest release of Nimble and install it on your system.\n\nNote that you must have `~/.nimble/bin` in your PATH for this to work, if you\'re\nusing choosenim then you likely already have this set up correctly.\n\n## Nimble usage\n\nOnce you have Nimble installed on your system you can run the ``nimble`` command\nto obtain a list of available commands.\n\n### nimble refresh\n\nThe ``refresh`` command is used to fetch and update the list of Nimble packages\n(see below). There is no automatic update mechanism, so you need to run this\nyourself if you need to *refresh* your local list of known available Nimble\npackages.  Example:\n\n    $ nimble refresh\n    Downloading package list from https://.../packages.json\n    Done.\n\nSome commands may remind you to run ``nimble refresh`` or will run it for you if\nthey fail.\n\nYou can also optionally supply this command with a URL if you would like to use\na third-party package list.\n\nPackage lists can be specified in Nimble\'s config. Take a look at the\nconfig section below to see how to do this.\n\n### nimble check\n\nThe ``check`` command will read your package\'s .nimble file. It will then\nverify that the package\'s structure is valid.\n\nExample:\n\n    $ nimble check\n        Error: Package \'x\' has an incorrect structure. It should contain a single directory hierarchy for source files, named \'x\', but file \'foobar.nim\' is in a directory named \'incorrect\' instead. This will be an error in the future.\n         Hint: If \'incorrect\' contains source files for building \'x\', rename it to \'x\'. Otherwise, prevent its installation by adding `skipDirs = @["incorrect"]` to the .nimble file.\n      Failure: Validation failed\n\n\n\n### nimble install\n\nThe ``install`` command will download and install a package. You need to pass\nthe name of the package (or packages) you want to install. If any of the\npackages depend on other Nimble packages Nimble will also install them.\nExample:\n\n    $ nimble install nake\n    Downloading nake into /tmp/nimble/nake...\n    Executing git...\n    ...\n    nake installed successfully\n\nNimble always fetches and installs the latest version of a package. Note that\nlatest version is defined as the latest tagged version in the Git (or Mercurial)\nrepository, if the package has no tagged versions then the latest commit in the\nremote repository will be installed. If you already have that version installed,\nNimble will ask you whether you wish it to overwrite your local copy.\n\nYou can force Nimble to download the latest commit from the package\'s repo, for\nexample:\n\n    $ nimble install nimgame@#head\n\nThis is of course Git-specific, for Mercurial, use ``tip`` instead of ``head``. A\nbranch, tag, or commit hash may also be specified in the place of ``head``.\n\nInstead of specifying a VCS branch, you may also specify a concrete version or a\nversion range, for example:\n\n    $ nimble install nimgame@0.5\n    $ nimble install nimgame@"> 0.5"\n\nThe latter command will install a version which is greater than ``0.5``.\n\nIf you don\'t specify a parameter and there is a ``package.nimble`` file in your\ncurrent working directory then Nimble will install the package residing in\nthe current working directory. This can be useful for developers who are testing\nlocally their ``.nimble`` files before submitting them to the official package\nlist. See the [Creating Packages](#creating-packages) section for more info on this.\n\n#### Package URLs\n\nA valid URL to a Git or Merurial repository can also be specified, Nimble will\nautomatically detect the type of the repository that the url points to and\ninstall it.\n\nFor repositories containing the Nimble package in a subdirectory, you can\ninstruct Nimble about the location of your package using the ``?subdir=<path>``\nquery parameter. For example:\n\n    $ nimble install https://github.com/nimble-test/multi?subdir=alpha\n\n### nimble develop\n\nThe ``develop`` command allows you to link an existing copy of a package into\nyour installation directory. This is so that when developing a package you\ndon\'t need to keep reinstalling it for every single change.\n\n    $ cd ~/projects/jester\n    $ nimble develop\n\nAny packages depending on ``jester`` will now use the code in\n``~/projects/jester``.\n\nIf you specify a package name to this command, Nimble will clone it into the\ncurrent working directory.\n\n    $ nimble develop jester\n\nThe ``jester`` package will be cloned into ``./jester`` and it will be linked\nto your installation directory.\n\nJust as with the ``install`` command, a package URL may also be specified\ninstead of a name.\n\n### nimble uninstall\n\nThe ``uninstall`` command will remove an installed package. Attempting to remove\na package which other packages depend on will result in an error. You can use the\n``--inclDeps`` or ``-i`` flag to remove all dependent packages along with the package.\n\nSimilar to the ``install`` command you can specify a version range, for example:\n\n    $ nimble uninstall nimgame@0.5\n\n### nimble build\n\nThe ``build`` command is mostly used by developers who want to test building\ntheir ``.nimble`` package. This command will build the package with default\nflags, i.e. a debug build which includes stack traces but no GDB debug\ninformation. The ``install`` command will build the package in release mode\ninstead.\n\n### nimble run\n\nThe ``run`` command can be used to build and run any binary specified in your\npackage\'s ``bin`` list. You can pass any compilation flags you wish by specifying\nthem before the ``run`` command, and you can specify arguments for your binary\nby specifying them after the ``run`` command.\n\n### nimble c\n\nThe ``c`` (or ``compile``, ``js``, ``cc``, ``cpp``) command can be used by\ndevelopers to compile individual modules inside their package. All options\npassed to Nimble will also be passed to the Nim compiler during compilation.\n\nNimble will use the backend specified in the package\'s ``.nimble`` file if\nthe command ``c`` or ``compile`` is specified. The more specific ``js``, ``cc``,\n``cpp`` can be used to override that.\n\n### nimble list\n\nThe ``list`` command will display the known list of packages available for\nNimble. An optional ``--ver`` parameter can be specified to tell Nimble to\nquery remote Git repositories for the list of versions of the packages and to\nthen print the versions. Please note however that this can be slow as each\npackage must be queried separately.\n\n### nimble search\n\nIf you don\'t want to go through the whole output of the ``list`` command you\ncan use the ``search`` command specifying as parameters the package name and/or\ntags you want to filter. Nimble will look into the known list of available\npackages and display only those that match the specified keywords (which can be\nsubstrings). Example:\n\n    $ nimble search math\n    linagl:\n      url:         https://bitbucket.org/BitPuffin/linagl (hg)\n      tags:        library, opengl, math, game\n      description: OpenGL math library\n      license:     CC0\n\n    extmath:\n      url:         git://github.com/achesak/extmath.nim (git)\n      tags:        library, math, trigonometry\n      description: Nim math library\n      license:     MIT\n\nSearches are case insensitive.\n\nAn optional ``--ver`` parameter can be specified to tell Nimble to\nquery remote Git repositories for the list of versions of the packages and\nthen print the versions. However, please note that this can be slow as each\npackage must be queried separately.\n\n### nimble path\n\nThe nimble ``path`` command will show the absolute path to the installed\npackages matching the specified parameters. Since there can be many versions of\nthe same package installed, the ``path`` command will always show the latest\nversion. Example:\n\n    $ nimble path argument_parser\n    /home/user/.nimble/pkgs/argument_parser-0.1.2\n\nUnder Unix you can use backticks to quickly access the directory of a package,\nwhich can be useful to read the bundled documentation. Example:\n\n    $ pwd\n    /usr/local/bin\n    $ cd `nimble path argument_parser`\n    $ less README.md\n\n### nimble init\n\nThe nimble ``init`` command will start a simple wizard which will create\na quick ``.nimble`` file for your project in the current directory.\n\nAs of version 0.7.0, the ``.nimble`` file that this command creates will\nuse the new NimScript format.\nCheck out the [Creating Packages](#creating-packages) section for more info.\n\n### nimble publish\n\nPublishes your Nimble package to the official Nimble package repository.\n\n**Note:** Requires a valid GitHub account with an SSH key attached to it. To upload your public key onto your GitHub account, follow [this link](https://github.com/settings/keys).\n\n### nimble tasks\n\nFor a Nimble package in the current working directory, list the tasks which that\npackage defines. This is only supported for packages utilising the new\nnimscript .nimble files.\n\n### nimble dump\n\nOutputs information about the package in the current working directory in\nan ini-compatible format. Useful for tools wishing to read metadata about\nNimble packages who do not want to use the NimScript evaluator.\n\n## Configuration\n\nAt startup Nimble will attempt to read ``~/.config/nimble/nimble.ini`` on Linux\n(on Windows it will attempt to read\n``C:\\Users\\<YourUser>\\AppData\\Roaming\\nimble\\nimble.ini``).\n\nThe format of this file corresponds to the ini format with some Nim\nenhancements. For example:\n\n```ini\nnimbleDir = r"C:\\Nimble\\"\n\n[PackageList]\nname = "CustomPackages"\nurl = "http://mydomain.org/packages.json"\n\n[PackageList]\nname = "Local project packages"\npath = r"C:\\Projects\\Nim\\packages.json"\n```\n\nYou can currently configure the following in this file:\n\n* ``nimbleDir`` - The directory which Nimble uses for package installation.\n  **Default:** ``~/.nimble/``\n* ``chcp`` - Whether to change the current code page when executing Nim\n  application packages. If ``true`` this will add ``chcp 65001`` to the\n  .cmd stubs generated in ``~/.nimble/bin/``.\n  **Default:** ``true``\n* ``[PackageList]`` + ``name`` + (``url``|``path``) - You can use this section to specify\n  a new custom package list. Multiple package lists can be specified. Nimble\n  defaults to the "Official" package list, you can override it by specifying\n  a ``[PackageList]`` section named "official". Multiple URLs can be specified\n  under each section, Nimble will try each in succession if\n  downloading from the first fails. Alternately, ``path`` can specify a\n  local file path to copy a package list .json file from.\n* ``cloneUsingHttps`` - Whether to replace any ``git://`` inside URLs with\n  ``https://``.\n  **Default: true**\n* ``httpProxy`` - The URL of the proxy to use when downloading package listings.\n  Nimble will also attempt to read the ``http_proxy`` and ``https_proxy``\n  environment variables.\n  **Default: ""**\n* ``nimLibPrefix`` - Specifies the Nim standard library prefix to help Nimble\n  find the Nim standard library.\n  **Default: ""**\n\n## Creating Packages\n\nNimble works on Git repositories as its primary source of packages. Its list of\npackages is stored in a JSON file which is freely accessible in the\n[nim-lang/packages repository](https://github.com/nim-lang/packages).\nThis JSON file provides Nimble with the required Git URL to clone the package\nand install it. Installation and build instructions are contained inside a\nfile with the ``.nimble`` file extension. The Nimble file shares the\npackage\'s name, i.e. a package\nnamed "foobar" should have a corresponding ``foobar.nimble`` file.\n\nThese files specify information about the package including its author,\nlicense, dependencies and more. Without one, Nimble is not able to install\na package.\n\nA .nimble file can be created easily using Nimble\'s ``init`` command. This\ncommand will ask you a bunch of questions about your package, then generate a\n.nimble file for you in the current directory.\n\nA bare minimum .nimble file follows:\n\n```ini\n# Package\n\nversion     = "0.1.0"\nauthor      = "Your Name"\ndescription = "Example .nimble file."\nlicense     = "MIT"\n\n# Deps\n\nrequires "nim >= 0.10.0"\n```\n\nYou may omit the dependencies entirely, but specifying the lowest version\nof the Nim compiler required is recommended.\n\nYou can also specify multiple dependencies like so:\n\n```\n# Deps\n\nrequires "nim >= 0.10.0", "foobar >= 0.1.0"\nrequires "fizzbuzz >= 1.0"\nrequires "https://github.com/user/pkg#5a54b5e"\n```\n\nNimble currently supports installation of packages from a local directory, a\nGit repository and a mercurial repository. The .nimble file must be present in\nthe root of the directory or repository being installed.\n\nThe .nimble file is very flexible because it is interpreted using NimScript.\nBecause of Nim\'s flexibility the definitions remain declarative. With the added\nability of using the Nim language to enrich your package specification.\nFor example, you can define dependencies for specific platforms using Nim\'s\n``when`` statement.\n\nAnother great feature\nis the ability to define custom Nimble package-specific commands. These are\ndefined in the .nimble files of course.\n\n```nim\ntask hello, "This is a hello task":\n  echo("Hello World!")\n```\n\nYou can then execute ``nimble hello``, which will result in the following\noutput:\n\n```\nExecuting task hello in /Users/user/projects/pkg/pkg.nimble\nHello World!\n```\n\nYou can place any Nim code inside these tasks. As long as that code does not\naccess the FFI. The ``nimscript``\n[module](https://nim-lang.org/docs/nimscript.html) in Nim\'s standard library defines\nadditional functionality such as the ability to execute external processes\nwhich makes this feature very powerful.\n\nYou can also check what tasks are supported by the package in the current\ndirectory by using the ``tasks`` command.\n\nNimble provides an API which adds even more functionality. For example,\nyou can specify\npre and post hooks for any Nimble command (including commands that\nyou define yourself). To do this you can add something like the following:\n\n```nim\nbefore hello:\n  echo("About to call hello!")\n```\n\nThat will result in the following output when ``nimble hello`` is executed (you\nmust also specify the ``task`` shown above).\n\n```\nExecuting task hello in /Users/user/projects/pkg/pkg.nimble\nAbout to call hello!\nHello World!\n```\n\nSimilar to this an ``after`` block is also available for post hooks,\nwhich are executed after Nimble finished executing a command. You can\nalso return ``false`` from these blocks to stop further execution.\n\nThe ``nimscriptapi.nim`` module specifies this and includes other definitions\nwhich are also useful. Take a look at it for more information.\n\n### Project structure\n\nFor a package named "foobar", the recommended project structure is the following:\n\n```\n.                   # The root directory of the project\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 LICENSE\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 README.md\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 foobar.nimble   # The project .nimble file\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 src\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 foobar.nim  # Imported via `import foobar`\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 tests           # Contains the tests\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 config.nims\n    \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 tfoo1.nim   # First test\n    \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 tfoo2.nim   # Second test\n\n```\n\nNote that the .nimble file needs to be in the project\'s root directory. This\ndirectory structure will be created if you run ``nimble init`` inside a\n``foobar`` directory.\n\n**Warning:** When source files are placed in a ``src`` directory, the\n.nimble file must contain a ``srcDir = "src"`` directive. The ``nimble init``\ncommand takes care of that for you.\n\nWhen introducing more modules into your package, you should place them in a\nseparate directory named ``foobar`` (i.e. your package\'s name). For example:\n\n```\n.                   # The root directory of the project\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 ...\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 foobar.nimble   # The project .nimble file\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 src\n\xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 foobar\n\xe2\x94\x82   \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 utils.nim   # Imported via `import foobar/utils`\n\xe2\x94\x82   \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 common.nim  # Imported via `import foobar/common`\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 foobar.nim      # Imported via `import foobar`\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 ...\n```\n\n#### Private modules\n\nYou may wish to hide certain modules in your package from the users. Create a\n``private`` directory for that purpose. For example:\n\n```\n.                   # The root directory of the project\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 ...\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 foobar.nimble   # The project .nimble file\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 src\n\xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 foobar\n\xe2\x94\x82   \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 private\n\xe2\x94\x82   \xe2\x94\x82   \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 hidden.nim  # Imported via `import foobar/private/hidden`\n\xe2\x94\x82   \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 utils.nim       # Imported via `import foobar/utils`\n\xe2\x94\x82   \xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 common.nim      # Imported via `import foobar/common`\n\xe2\x94\x82   \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 foobar.nim          # Imported via `import foobar`\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 ...\n```\n\n#### Tests\n\nA common problem that arises with tests is the fact that they need to import\nthe associated package. But the package is in the parent directory. This can\nbe solved in a few different ways:\n\n* Expect that the package has been installed locally into your\n  ``~/.nimble`` directory.\n* Use a simple path modification to resolve the package properly.\n\nThe latter is highly recommended. Reinstalling the package to test an actively\nchanging code base is a massive pain.\n\nTo modify the path for your tests only, simply add a ``nim.cfg`` file into\nyour ``tests`` directory with the following contents:\n\n```\n--path:"../src/"\n```\n\nNimble offers a pre-defined ``test`` task which compiles and runs all files\nin the ``tests`` directory beginning with \'t\' in their filename.\n\nYou may wish to override this ``test`` task in your ``.nimble`` file. This\nis particularly useful when you have a single test suite program. Just add\nthe following to your ``.nimble`` file to override the default ``test`` task.\n\n```nim\ntask test, "Runs the test suite":\n  exec "nim c -r tests/tester"\n```\n\nRunning ``nimble test`` will now use the ``test`` task you have defined.\n\n### Libraries\n\nLibrary packages are likely the most popular form of Nimble packages. They are\nmeant to be used by other library or binary packages.\n\nWhen Nimble installs a library, it will copy all of its files\ninto ``$nimbleDir/pkgs/pkgname-ver``. It\'s up to the package creator to make sure\nthat the package directory layout is correct, this is so that users of the\npackage can correctly import the package.\n\nIt is suggested that the layout be as follows. The directory layout is\ndetermined by the nature of your package, that is, whether your package exposes\nonly one module or multiple modules.\n\nIf your package exposes only a single module, then that module should be\npresent in the root directory (the directory with the .nimble file) of your Git\nrepository, and should be named whatever your package\'s name is. A good example\nof this is the [jester](https://github.com/dom96/jester) package which exposes\nthe ``jester`` module. In this case the jester package is imported with\n``import jester``.\n\nIf your package exposes multiple modules then the modules should be in a\n``PackageName`` directory. This will allow for a certain measure of isolation\nfrom other packages which expose modules with the same names. In this case\nthe package\'s modules will be imported with ``import PackageName/module``.\n\nHere\'s a simple example multi-module library package called `kool`:\n\n```\n.\n\xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 kool\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80 useful.nim\n\xe2\x94\x82\xc2\xa0\xc2\xa0 \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 also_useful.nim\n\xe2\x94\x94\xe2\x94\x80\xe2\x94\x80 kool.nimble\n```\n\nIn regards to modules which you do **not** wish to be exposed. You should place\nthem in a ``PackageName/private`` directory. Your modules may then import these\nprivate modules with ``import PackageName/private/module``. This directory\nstructure may be enforced in the future.\n\nAll files and folders in the directory of where the .nimble file resides will be\ncopied as-is, you can however skip some directories or files by setting\nthe ``skipDirs``, ``skipFiles`` or ``skipExt`` options in your .nimble file.\nDirectories and files can also be specified on a *whitelist* basis, if you\nspecify either of ``installDirs``, ``installFiles`` or ``installExt`` then\nNimble will **only** install the files specified.\n\n### Binary packages\n\nThese are application packages which require building prior to installation.\nA package is automatically a binary package as soon as it sets at least one\n``bin`` value, like so:\n\n```ini\nbin = @["main"]\n```\n\nIn this case when ``nimble install`` is invoked, Nimble will build the ``main.nim``\nfile, copy it into ``$nimbleDir/pkgs/pkgname-ver/`` and subsequently create a\nsymlink to the binary in ``$nimbleDir/bin/``. On Windows a stub .cmd file is\ncreated instead.\n\nOther files will be copied in the same way as they are for library packages.\n\nBinary packages should not install .nim files so include ``skipExt = @["nim"]``\nin your .nimble file, unless you intend for your package to be a binary/library\ncombo.\n\nDependencies are automatically installed before building.\nIt\'s a good idea to test that the dependencies you specified are correct by\nrunning ``nimble build`` or ``nimble install`` in the directory\nof your package.\n\n### Hybrids\n\nOne thing to note about binary packages that contain source files aside from\nthe one(s) specified in `bin` (or that also expose multiple library modules, as\nabove) is that a binary may share the name of the package: this will mean\nthat you will not be able to put your additional .nim files in a ``pkgname``\ndirectory. The reason for this is that binaries on some operating systems do\nnot have an extension, so they will clash with a directory of the same name.\n\nIf this is the case, you should place your additional .nim files in a directory\nwith `pkg` appended after the name of the project. For instance, if you were\nbuilding a binary named `project`, you would put any additional source files in\na directory called `projectpkg`. From within project.nim you would then import\nthose modules namespaced with `projectpkg/`.\n\n### Dependencies\n\nDependencies are specified using the ``requires`` function. For example:\n\n```\n# Dependencies\nrequires "nim >= 0.10.0", "jester > 0.1 & <= 0.5"\n```\n\nDependency lists support version ranges. These versions may either be a concrete\nversion like ``0.1``, or they may contain any of the less-than (``<``),\ngreater-than (``>``), less-than-or-equal-to (``<=``) and greater-than-or-equal-to\n(``>=``) operators.\nTwo version ranges may be combined using the ``&`` operator, for example\n``> 0.2 & < 1.0``, which will install a package with the version greater than 0.2\nand less than 1.0.\n\nSpecifying a concrete version as a dependency is not a good idea because your\npackage may end up depending on two different versions of the same package.\nIf this happens, Nimble will refuse to install the package.\n\nIn addition to versions you may also specify Git/Mercurial tags, branches and commits.\nAlthough these have to be specific; ranges of commits are not supported.\nThis is done with the ``#`` character,\nfor example: ``jester#head``. Which will make your package depend on the\nlatest commit of Jester.\n\n#### External dependencies\n\n**Warning:** This feature is brand new in Nimble v0.8.0. Breaking changes\nrelated to it are more likely to be introduced than for any other Nimble\nfeatures.\n\nStarting with Nimble v0.8.0, you can now specify external dependencies. These\nare dependencies which are not managed by Nimble and can only be installed via\nyour system\'s package manager or downloaded manually via the internet.\n\nAs an example, to specify a dependency on openssl you may put this in your\n.nimble file:\n\n```nim\nwhen defined(nimdistros):\n  import distros\n  if detectOs(Ubuntu):\n    foreignDep "libssl-dev"\n  else:\n    foreignDep "openssl"\n```\n\nThe ``when`` branch is important to support installation using older versions\nof Nimble.\n\nThe [distros module](https://nim-lang.org/docs/distros.html) in Nim\'s\nstandard library contains a list of all the supported Operating Systems and\nLinux distributions.\n\nWith this inside your .nimble file, Nimble will output the following after\ninstalling your package (on macOS):\n\n```\n  Hint: This package requires some external dependencies.\n  Hint: To install them you may be able to run:\n  Hint:   brew install openssl\n```\n\n### Nim compiler\n\nThe Nim compiler cannot read .nimble files. Its knowledge of Nimble is\nlimited to the ``nimblePath`` feature which allows it to use packages installed\nin Nimble\'s package directory when compiling your software. This means that\nit cannot resolve dependencies, and it can only use the latest version of a\npackage when compiling.\n\nWhen Nimble builds your package it actually executes the Nim compiler.\nIt resolves the dependencies and feeds the path of each package to\nthe compiler so that it knows precisely which version to use.\n\nThis means that you can safely compile using the compiler when developing your\nsoftware, but you should use Nimble to build the package before publishing it\nto ensure that the dependencies you specified are correct.\n\n### Compile with `nim` after changing the nimble directory\n\nThe Nim compiler has been preconfigured to look at the default nimble directory while compiling,\nso no extra step is required to use nimble managed packages in your code.\nHowever, if you are using a custom `nimbleDir`, you need to specify the\n`--nimblePath:PATH` option. For example,\nif your `nimble` directory is located at `/some/custom/path/nimble`, this should work:\n\n```\nnim c --nimblePath:/some/custom/path/nimble/pkgs main.nim\n```\n\nSome code editors rely on `nim check` to check for errors under the hood (e.g. VScode),\nand the editor extension may not allow users to pass custom option to `nim check`, which\nwill cause `nim check` to scream `Error: cannot open file:<the_package>`. In this case,\nyou will have to use [Nim compiler\'s configuration files](https://nim-lang.org/docs/nimc.html#compiler-usage-configuration-files). Simply add the line:\n```\nnimblePath = "/some/custom/path/nimble/pkgs"\n```\nto the `nim.cfg` located in any directory listed in the [documentation](https://nim-lang.org/docs/nimc.html#compiler-usage-configuration-files), this should resolve the problem.\n\n### Versions\n\nVersions of cloned packages via Git or Mercurial are determined through the\nrepository\'s *tags*.\n\nWhen installing a package which needs to be downloaded, after the download is\ncomplete and if the package is distributed through a VCS, Nimble will check the\ncloned repository\'s tags list. If no tags exist, Nimble will simply install the\nHEAD (or tip in Mercurial) of the repository. If tags exist, Nimble will attempt\nto look for tags which resemble versions (e.g. v0.1) and will then find the\nlatest version out of the available tags, once it does so it will install the\npackage after checking out the latest version.\n\nYou can force the installation of the HEAD of the repository by specifying\n``#head`` after the package name in your dependency list.\n\n#### Releasing a new version\n\nVersion releases are done by creating a tag in your Git or Mercurial\nrepository.\n\nWhenever you want to release a new version, you should remember to first\nincrement the version in your ``.nimble`` file and commit your changes. Only\nafter that is done should you tag the release.\n\nTo summarise, the steps for release are:\n\n* Increment the version in your ``.nimble`` file.\n* Commit your changes.\n* Tag your release, by for example running ``git tag v0.2.0``.\n* Push your tags and commits.\n\nOnce the new tag is in the remote repository, Nimble will be able to detect\nthe new version.\n\n##### Git Version Tagging\n\nUse dot separated numbers to represent the release version in the git\ntag label.  Nimble will parse these git tag labels to know which\nversions of a package are published.\n\n``` text\nv0.2.0        # 0.2.0\nv1            # 1\nv1.2.3-zuzu   # 1.2.3\nfoo-1.2.3.4   # 1.2.3.4\n```\n\n## Publishing packages\n\nPublishing packages isn\'t a requirement. But doing so allows people to associate\na specific name to a URL pointing to your package. This mapping is stored\nin an official packages repository located\n[here](https://github.com/nim-lang/packages).\n\nThis repository contains a ``packages.json`` file which lists all the published\npackages. It contains a set of package names with associated metadata. You\ncan read more about this metadata in the\n[readme for the packages repository](https://github.com/nim-lang/packages#readme).\n\nTo publish your package you need to fork that repository, and add an entry\ninto the ``packages.json`` file for your package. Then create a pull request\nwith your changes. **You only need to do this\nonce**.\n\nNimble includes a ``publish`` command which does this for you automatically.\n\n## .nimble reference\n\n### [Package]\n\n#### Required\n\n* ``name`` - The name of the package. *(This is not required in the new NimScript format)*\n* ``version`` - The *current* version of this package. This should be incremented\n  **before** tagging the current version using ``git tag`` or ``hg tag``.\n* ``author`` - The name of the author of this package.\n* ``description`` - A string describing the package.\n* ``license`` - The name of the license in which this package is licensed under.\n\n#### Optional\n\n* ``skipDirs`` - A list of directory names which should be skipped during\n  installation, separated by commas.\n* ``skipFiles`` - A list of file names which should be skipped during\n  installation, separated by commas.\n* ``skipExt`` - A list of file extensions which should be skipped during\n  installation, the extensions should be specified without a leading ``.`` and\n  should be separated by commas.\n* ``installDirs`` - A list of directories which should exclusively be installed,\n  if this option is specified nothing else will be installed except the dirs\n  listed here, the files listed in ``installFiles``, the files which share the\n  extensions listed in ``installExt``, the .nimble file and the binary\n  (if ``bin`` is specified). Separated by commas.\n* ``installFiles`` - A list of files which should be exclusively installed,\n  this complements ``installDirs`` and ``installExt``. Only the files listed\n  here, directories listed in ``installDirs``, files which share the extension\n  listed in ``installExt``, the .nimble file and the binary (if ``bin`` is\n  specified) will be installed. Separated by commas.\n* ``installExt`` - A list of file extensions which should be exclusively\n  installed, this complements ``installDirs`` and ``installFiles``.\n  Separated by commas.\n* ``srcDir`` - Specifies the directory which contains the .nim source files.\n  **Default**: The directory in which the .nimble file resides; i.e. root dir of\n  the package.\n* ``binDir`` - Specifies the directory where ``nimble build`` will output\n  binaries.\n  **Default**: The directory in which the .nimble file resides; i.e.\n  root dir of the package.\n* ``bin`` - A list of files which should be built separated by commas with\n  no file extension required. This option turns your package into a *binary\n  package*, Nimble will build the files specified and install them appropriately.\n* ``backend`` - Specifies the backend which will be used to build the files\n  listed in ``bin``. Possible values include: ``c``, ``cc``, ``cpp``, ``objc``,\n  ``js``.\n  **Default**: c\n\n### [Deps]/[Dependencies]\n\n#### Optional\n\n* ``requires`` - Specified a list of package names with an optional version\n  range separated by commas.\n  **Example**: ``nim >= 0.10.0, jester``; with this value your package will\n  depend on ``nim`` version 0.10.0 or greater and on any version of ``jester``.\n\n## Nimble\'s folder structure and packages\n\nNimble stores everything that has been installed in ``~/.nimble`` on Unix systems\nand in your ``$home/.nimble`` on Windows. Libraries are stored in\n``$nimbleDir/pkgs``, and binaries are stored in ``$nimbleDir/bin``. Most Nimble\npackages will provide ``.nim`` files and some documentation. The Nim\ncompiler is aware of Nimble and will automatically find the modules so you can\n``import modulename`` and have that working without additional setup.\n\nHowever, some Nimble packages can provide additional tools or commands. If you\ndon\'t add their location (``$nimbleDir/bin``) to your ``$PATH`` they will not\nwork properly and you won\'t be able to run them.\n\n## Troubleshooting\n\n* ```SSL support is not available. Cannot connect over SSL. [HttpRequestError]```\n\nMake sure that Nimble is configured to run with SSL, adding a ```-d:ssl```\nflag to the file ```src/nimble.nim.cfg```.\nAfter that, you can run ```src/nimble install``` and overwrite the existing\ninstallation.\n\n* ``Could not download: error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure``\n\nIf you are on macOS, you need to set and export the ```DYLD_LIBRARY_PATH``` environment variable to the directory where your OpenSSL libraries are. For example, if you use OpenSSL, you have to set ```export DYLD_LIBRARY_PATH=/usr/local/opt/openssl/lib``` in your ```$HOME/.bashrc``` file.\n\n* ``Error: ambiguous identifier: \'version\' --use nimscriptapi.version or system.version``\n\nMake sure that you are running at least version 0.16.0 of Nim (or the latest nightly).\n\n* ``Error: cannot open \'/home/user/.nimble/lib/system.nim\'.``\n\nNimble cannot find the Nim standard library. This is considered a bug so\nplease report it. As a workaround you can set the ``NIM_LIB_PREFIX`` environment\nvariable to the directory where ``lib/system.nim`` (and other standard library\nfiles) are found. Alternatively you can also configure this in Nimble\'s\nconfig file.\n\n## Repository information\n\nThis repository has two main branches: ``master`` and ``stable``.\n\nThe ``master`` branch is...\n\n* default\n* bleeding edge\n* tested to compile with a pinned (close to HEAD) commit of Nim\n\nThe ``stable`` branch is...\n\n* installed by ``koch tools``/``koch nimble``\n* relatively stable\n* should compile with Nim HEAD as well as the latest Nim version\n\nNote: The travis build only tests whether Nimble works with the latest Nim\nversion.\n\nA new Nim release (via ``koch xz``) will always bundle the ``stable`` branch.\n\n## Contribution\n\nIf you would like to help, feel free to fork and make any additions you see fit\nand then send a pull request.\n\nIf you have any questions about the project, you can ask me directly on GitHub,\nask on the Nim [forum](https://forum.nim-lang.org), or ask on Freenode in\nthe #nim channel.\n\n## Implementation details\n\n### .nimble-link\n\nThese files are created by Nimble when using the ``develop`` command. They\nare very simple and contain two lines.\n\n**The first line:** Always a path to the `.nimble` file.\n\n**The second line:** Always a path to the Nimble package\'s source code. Usually\n``$pkgDir/src``, depending on what ``srcDir`` is set to.\n\nThe paths written by Nimble are **always** absolute. But Nimble (and the\nNim compiler) also supports relative paths, which will be read relative to\nthe `.nimble-link` file.\n\n## About\n\nNimble has been written by [Dominik Picheta](https://picheta.me/) with help from\na number of\n[contributors](https://github.com/nim-lang/nimble/graphs/contributors).\nIt is licensed under the 3-clause BSD license, see [license.txt](license.txt)\nfor more information.\n'