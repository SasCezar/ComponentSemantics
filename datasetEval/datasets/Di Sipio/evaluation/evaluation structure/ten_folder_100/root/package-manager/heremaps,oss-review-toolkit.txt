b'![OSS Review Toolkit Logo](./logos/ort.png)\n\n&nbsp;\n\n| Linux (OpenJDK 10)             | Windows (Oracle JDK 9)          | JitPack (OpenJDK 8)             |\n| :----------------------------- | :------------------------------ | :------------------------------ |\n| [![Linux build status][1]][2]  | [![Windows build status][3]][4] | [![JitPack build status][5]][6] |\n| [![Linux code coverage][7]][8] |                                 |                                 |\n\n| Interact with us!              |\n| :----------------------------- |\n| [![ort-talk][9]][10]            |\n\n[1]: https://travis-ci.com/heremaps/oss-review-toolkit.svg?branch=master\n[2]: https://travis-ci.com/heremaps/oss-review-toolkit\n[3]: https://ci.appveyor.com/api/projects/status/hbc1mn5hpo9a4hcq/branch/master?svg=true\n[4]: https://ci.appveyor.com/project/heremaps/oss-review-toolkit/branch/master\n[5]: https://jitpack.io/v/heremaps/oss-review-toolkit.svg\n[6]: https://jitpack.io/#heremaps/oss-review-toolkit\n[7]: https://codecov.io/gh/heremaps/oss-review-toolkit/branch/master/graph/badge.svg\n[8]: https://codecov.io/gh/heremaps/oss-review-toolkit/\n[9]: https://img.shields.io/badge/slack-ort--talk-blue.svg?longCache=true&logo=slack\n[10]: https://join.slack.com/t/ort-talk/shared_invite/enQtMzk3MDU5Njk0Njc1LThiNmJmMjc5YWUxZTU4OGI5NmY3YTFlZWM5YTliZmY5ODc0MGMyOWIwYmRiZWFmNGMzOWY2NzVhYTI0NTJkNmY\n\n# Introduction\n\nThe OSS Review Toolkit (ORT) assists with verifying Free and Open Source Software license compliance by checking a\nproject\'s source code and its dependencies.\n\nFrom a bird\'s eye, it works by analyzing the project\'s build system for dependencies, downloading the source code of the\ndependencies, scanning all source code for license information, and summarizing the results.\n\nThe different tools that make up ORT are designed as libraries (for programmatic use), with a minimal command line\ninterface (for scripted use).\n\nThe toolkit consists of the following tools:\n\n* [Analyzer](#analyzer) - determines dependencies of a project. Supports multiple package managers and sub-projects. No\n  changes to the projects are required.\n* [Downloader](#downloader) - fetches the source code referred to by the Analyzer result.\n* [Scanner](#scanner) - wraps existing license / copyright scanners to detect findings in local source code directories.\n* [Evaluator](#evaluator) - evaluates license findings an created customizable results or follow-up actions using a\n   rules DSL based on Kotlin.\n* [Reporter](#reporter) - presents results in various formats like visual reports, compliance documents or\n  Bill-Of-Materials (BOMs) to easily identify dependencies, licenses, copyrights or policy violations.\n\nThe following tools are [planned](https://github.com/heremaps/oss-review-toolkit/projects/1) but not yet available:\n\n* *Advisor* - retrieves security advisories based on the Analyzer result.\n* *Documenter* - generates the final outcome of the review process incl. legal conclusions, e.g. annotated\n  [SPDX](https://spdx.org/) files that can be included into the distribution.\n\n# Installation\n\n## From binaries\n\nPreliminary binary artifacts for ORT are currently available via [JitPack](https://jitpack.io/#heremaps/oss-review-toolkit).\nPlease note that due to limitations with the JitPack build environment, the reporter is not able to create the Web App\nreport.\n\n## From sources\n\nInstall the following basic prerequisites:\n\n* Git (any recent version will do).\n\nThen clone this repository. If you intend to run tests, you need to clone with submodules by running\n`git clone --recurse-submodules`. If you have already cloned non-recursively, you can initialize submodules afterwards\nby running `git submodule update --init --recursive`.\n\n### Build using Docker\n\nInstall the following basic prerequisites:\n\n* Docker (and ensure its daemon is running).\n\nChange into the created directory and run `docker/build.sh`.\n\n### Build natively\n\nInstall these additional prerequisites:\n\n* OpenJDK 8 or Oracle JDK 8u161 or later (not the JRE as you need the `javac` compiler); also remember to set the\n  `JAVA_HOME` environment variable accordingly.\n\nChange into the created directory and run `./gradlew installDist` (on the first run this will bootstrap Gradle and\ndownload all required dependencies).\n\n## Basic usage\n\nORT can now be run using\n\n    ./cli/build/install/ort/bin/ort --help\n\nNote that if you make any changes to ORT\'s source code, you would have to regenerate the distribution using either the\n[Build using Docker](#build-using-docker) or [Build natively](#build-natively) steps above.\n\nTo avoid that, you can also build and run ORT in one go (if you have the prerequisites from the\n[Build natively](#build-natively) section installed):\n\n    ./gradlew cli:run --args="--help"\n\nNote that in this case the working directory used by ORT is that of the `cli` project, not directory `gradlew` is\nlocated in (see https://github.com/gradle/gradle/issues/6074).\n\n# Running the tools\n\nLike for building ORT from sources you have the option to run ORT from a Docker image (which comes with all runtime\ndependencies) or to run ORT natively (in which case some additional requirements need to be fulfilled).\n\n## Run using Docker\n\nRun `docker/run.sh "<DOCKER_ARGS>" <ORT_ARGS>` where `<DOCKER_ARGS>` are passed to `docker run` (and need to be quoted\nif spaces are contained) and `<ORT_ARGS>` are passed to ORT. You typically use `<DOCKER_ARGS>` to mount the project\ndirectory to scan into the running container to let ORT access it, for example:\n\n    docker/run.sh "-v /workspace:/project" --info analyze -f JSON -i /project -o /project/ort/analyzer\n\n## Run natively\n\nFirst of all, make sure that the locale of your system is set to `en_US.UTF-8` as using other locales might lead to\nissues with parsing the output of some external tools.\n\nThen install any missing external command line tools as listed by\n\n    ./cli/build/install/ort/bin/ort requirements\n\nor\n\n    ./gradlew cli:run --args="requirements"\n\nThen run ORT like\n\n    ./cli/build/install/ort/bin/ort --info analyze -f JSON -i /project -o /project/ort/analyzer\n\nor\n\n    ./gradlew cli:run --args="--info analyze -f JSON -i /project -o /project/ort/analyzer"\n\n## Running on CI\n\nA basic ORT pipeline (using the analyzer, scanner and reporter) can easily be run on [Jenkins CI](https://jenkins.io/)\nby using the [Jenkinsfile](./Jenkinsfile) in a (declarative) [pipeline](https://jenkins.io/doc/book/pipeline/) job.\n\n## Getting started\n\nPlease see [GettingStarted.md](./docs/GettingStarted.md) for an introduction to the individual tools.\n\n## Configuration\n\nPlease see [Configuration.md](./docs/Configuration.md) for details about the ORT configuration.\n\n# Details on the tools\n\n<a name="analyzer"></a>\n\n[![Analyzer](./logos/analyzer.png)](./analyzer/src/main/kotlin)\n\nThe Analyzer is a Software Composition Analysis (SCA) tool that determines the dependencies of software projects inside\nthe specified input directory (`-i`). It does so by querying the detected package managers; **no modifications** to your\nexisting project source code, like applying build system plugins, are necessary for that to work. The tree of transitive\ndependencies per project is written out as part of an\n[OrtResult](https://github.com/heremaps/oss-review-toolkit/blob/master/model/src/main/kotlin/OrtResult.kt) in YAML (or\nJSON, see `-f`) format to a file named `analyzer-result.yml` in the specified output directory (`-o`). The output file\nexactly documents the status quo of all package-related meta-data. It can be further processed or manually edited before\npassing it to one of the other tools.\n\nCurrently, the following package managers are supported:\n\n* [Bower](http://bower.io/) (JavaScript)\n* [Bundler](http://bundler.io/) (Ruby)\n* [Cargo](https://doc.rust-lang.org/cargo/) (Rust)\n* [Conan](https://conan.io/) (C / C++)\n* [dep](https://golang.github.io/dep/) (Go)\n* [DotNet](https://docs.microsoft.com/en-us/dotnet/core/tools/) (.NET, with currently some [limitations](https://github.com/heremaps/oss-review-toolkit/pull/1303#issue-253860146))\n* [Glide](https://glide.sh/) (Go)\n* [Godep](https://github.com/tools/godep) (Go)\n* [Gradle](https://gradle.org/) (Java)\n* [Maven](http://maven.apache.org/) (Java)\n* [NPM](https://www.npmjs.com/) (Node.js)\n* [NuGet](https://www.nuget.org/) (.NET, with currently some [limitations](https://github.com/heremaps/oss-review-toolkit/pull/1303#issue-253860146))\n* [Composer](https://getcomposer.org/) (PHP)\n* [PIP](https://pip.pypa.io/) (Python)\n* [Pipenv](https://pipenv.readthedocs.io/) (Python)\n* [Pub](https://pub.dev/) (Dart / Flutter)\n* [SBT](http://www.scala-sbt.org/) (Scala)\n* [Stack](http://haskellstack.org/) (Haskell)\n* [Yarn](https://yarnpkg.com/) (Node.js)\n\n<a name="downloader">&nbsp;</a>\n\n[![Downloader](./logos/downloader.png)](./downloader/src/main/kotlin)\n\nTaking an ORT result file with an analyzer result as the input (`-a`), the Downloader retrieves the source code of all\ncontained packages to the specified output directory (`-o`). The Downloader takes care of things like normalizing URLs\nand using the [appropriate VCS tool](./downloader/src/main/kotlin/vcs) to checkout source code from version control.\n\nCurrently, the following Version Control Systems are supported:\n\n* [CVS](https://en.wikipedia.org/wiki/Concurrent_Versions_System)\n* [Git](https://git-scm.com/)\n* [Git-Repo](https://source.android.com/setup/develop/repo)\n* [Mercurial](https://www.mercurial-scm.org/)\n* [Subversion](https://subversion.apache.org/)\n\n<a name="scanner">&nbsp;</a>\n\n[![Scanner](./logos/scanner.png)](./scanner/src/main/kotlin)\n\nThis tool wraps underlying license / copyright scanners with a common API so all supported scanners can be used in the\nsame way to easily run them and compare their results. If passed an ORT result file with an analyzer result (`-a`), the\nScanner will automatically download the sources of the dependencies via the Downloader and scan them afterwards.\n\nCurrently, the following license scanners are supported:\n\n* [Askalono](https://github.com/amzn/askalono)\n* [lc](https://github.com/boyter/lc)\n* [Licensee](https://github.com/benbalter/licensee)\n* [ScanCode](https://github.com/nexB/scancode-toolkit)\n\nFor a comparison of some of these, see this [Bachelor Thesis](https://osr.cs.fau.de/2019/08/07/final-thesis-a-comparison-study-of-open-source-license-crawler/).\n\n## Storage Backends\n\nIn order to not download or scan any previously scanned sources again, the Scanner can use a storage backend to store\nscan results for later reuse.\n\n### Local File Storage\n\nBy default the Scanner stores scan results on the local file system in the current user\'s home directory (i.e.\n`~/.ort/scanner/scan-results`) for later reuse. The storage directory can be customized by passing an ORT configuration\nfile (`-c`) that contains a respective local file storage configuration:\n\n```hocon\nort {\n  scanner {\n    fileBasedStorage {\n      backend {\n        localFileStorage {\n          directory = "/tmp/ort/scan-results"\n        }\n      }\n    }\n  }\n}\n```\n\n### HTTP Storage\n\nAny HTTP file server can be used to store scan results. Custom headers can be configured to provide authentication\ncredentials. For example, to use Artifactory to store scan results, use the following configuration:\n\n```hocon\nort {\n  scanner {\n    fileBasedStorage {\n      backend {\n        httpFileStorage {\n          url = "https://artifactory.domain.com/artifactory/repository/scan-results"\n          headers {\n            X-JFrog-Art-Api = "api-token"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n### PostgreSQL Storage\n\nTo use PostgreSQL to store scan results, use the following configuration:\n\n```hocon\nort {\n  scanner {\n    postgresStorage {\n      url = "jdbc:postgresql://example.com:5444/database"\n      schema = "schema"\n      username = "username"\n      password = "password"\n    }\n  }\n}\n```\n\nThe scanner creates a table called `scan_results` and stores the data in a\n[jsonb](https://www.postgresql.org/docs/current/datatype-json.html) column.\n\n<a name="evaluator">&nbsp;</a>\n\n[![Evaluator](./logos/evaluator.png)](./evaluator/src/main/kotlin)\n\nThe Evaluator is used to perform custom license policy checks on scan results. The rules to check against are implemented\nvia scripting. Currently, Kotlin script with a dedicated DSL is used for that, but support for other scripting languages\ncan be added as well. See [no_gpl_declared.kts](./evaluator/src/main/resources/rules/no_gpl_declared.kts) for a very\nsimple example of a rule written in Kotlin script which verifies that no dependencies that declare the GPL are used.\n\n<a name="reporter">&nbsp;</a>\n\n[![Reporter](./logos/reporter.png)](./reporter/src/main/kotlin)\n\nThe reporter generates human-readable reports from the scan result file generated by the scanner (`-s`). It is designed\nto support multiple output formats.\n\nCurrently, the following report formats are supported (reporter names are case-insensitive):\n\n* [CycloneDX](https://cyclonedx.org/) BOM (`-f CycloneDx`)\n* [Excel](https://products.office.com/excel) sheet (`-f Excel`)\n* [NOTICE](http://www.apache.org/dev/licensing-howto.html) file (`-f Notice`)\n* Static HTML (`-f StaticHtml`)\n* Web App (`-f WebApp`)\n\n# Development\n\nORT is written in [Kotlin](https://kotlinlang.org/) and uses [Gradle](https://gradle.org/) as the build system, with\n[Kotlin script](https://docs.gradle.org/current/userguide/kotlin_dsl.html) instead of Groovy as the DSL.\n\nWhen developing on the command line, use the committed [Gradle wrapper](https://docs.gradle.org/current/userguide/gradle_wrapper.html)\nto bootstrap Gradle in the configured version and execute any given tasks. The most important tasks for this project are:\n\n| Task        | Purpose                                                           |\n| ----------- | ----------------------------------------------------------------- |\n| assemble    | Build the JAR artifacts for all projects                          |\n| detekt      | Run static code analysis on all projects                          |\n| test        | Run unit tests for all projects                                   |\n| funTest     | Run functional tests for all projects                             |\n| installDist | Build all projects and install the start scripts for distribution |\n\nAll contributions need to pass the `detekt`, `test` and `funTest` checks before they can be merged.\n\nFor IDE development we recommend the [IntelliJ IDEA Community Edition](https://www.jetbrains.com/idea/download/) which\ncan directly import the Gradle build files. After cloning the project\'s source code recursively, simply run IDEA and use\nthe following steps to import the project.\n\n1. From the wizard dialog: Select *Import Project*. \n\n   From a running IDEA instance: Select *File* -> *New* -> *Project from Existing Sources...*\n \n2. Browse to ORT\'s source code directory and select either the `build.gradle.kts` or the `settings.gradle.kts` file.\n\n3. In the *Import Project from Gradle* dialog select *Use auto-import* and leave all other settings at their defaults.\n\nTo set up a basic run configuration for debugging, navigate to `Main.kt` in the `cli` module and look for the\n`fun main(args: Array<String>)` function. In the gutter next to it, a green "Play" icon should be displayed. Click on it\nand select `Run \'com.here.ort.Main\'` to run the entry point, which implicitly creates a run configuration. Double-check\nthat running ORT without any arguments will simply show the command line help in IDEA\'s *Run* tool window. Finally, edit\nthe created run configuration to your needs, e.g. by adding an argument and options to run a specific ORT sub-command.\n\n# License\n\nCopyright (C) 2017-2019 HERE Europe B.V.\n\nSee the [LICENSE](./LICENSE) file in the root of this project for license details.\n'