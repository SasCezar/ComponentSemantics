b'# WildDuck Mail Server\n\n![](https://raw.githubusercontent.com/nodemailer/wildduck/master/assets/duck.png)\n\nWildDuck is a scalable no-SPOF IMAP/POP3 mail server. WildDuck uses a distributed database (sharded + replicated MongoDB) as a backend for storing all data,\nincluding emails.\n\nWildDuck tries to follow Gmail in product design. If there\'s a decision to be made then usually the answer is to do whatever Gmail has done.\n\n## Requirements\n\n-   _MongoDB_ to store all data\n-   _Redis_ for pubsub and counters\n-   _Node.js_ at least version 8.0.0\n\n**Optional requirements**\n\n-   Redis Sentinel for automatic Redis failover\n-   Build tools to install optional dependencies that need compiling\n\nWildDuck can be installed on any Node.js compatible platform.\n\n## No-SPOF architecture\n\nEvery component of the WildDuck mail server can be replicated which eliminates potential single point of failures.\n\n![](https://raw.githubusercontent.com/nodemailer/wildduck/master/assets/wd.png)\n\n## Storage\n\nAttachment de-duplication and compression gives up to 56% of storage size reduction.\n\n![](https://raw.githubusercontent.com/nodemailer/wildduck/master/assets/storage.png)\n\n## Usage\n\n### Scripted install\n\nIf you have a blank VPS and a free domain name that you can point to that VPS than you can try out the scripted all-included install\n\n[Installation instructions](./setup)\n\nInstall script installs and configures all required dependencies and services, including Let\'s Encrypt based certs, to run WildDuck as a mail server.\n\nTested on a 10\\$ DigitalOcean Ubuntu 16.04 instance.\n\n![](https://cldup.com/TZoTfxPugm.png)\n\n-   Web interface at https://wildduck.email that uses WildDuck API\n\n### Manual install\n\nAssuming you have MongoDB and Redis running somewhere.\n\n### Step 1\\. Get the code from github\n\n```\n$ git clone git://github.com/nodemailer/wildduck.git\n$ cd wildduck\n```\n\n### Step 2\\. Install dependencies\n\nInstall dependencies from npm\n\n```\n$ npm install --production\n```\n\n### Step 3\\. Run the server\n\nTo use the [default config](./config/default.toml) file, run the following:\n\n```\nnode server.js\n```\n\nOr if you want to override default configuration options with your own, run the following (custom config file is merged with the default, so specify only these\nvalues that you want to change):\n\n```\nnode server.js --config=/etc/wildduck.toml\n```\n\n> For additional config options, see the _wild-config_ [documentation](https://github.com/nodemailer/wild-config).\n\n### Step 4\\. Create a user account\n\nSee [API Docs](https://api.wildduck.email/#api-Users-PostUser) for details about creating new user accounts\n\n### Step 5\\. Use an IMAP/POP3 client to log in\n\nAny IMAP or POP3 client will do. Use the credentials from step 4\\. to log in.\n\n## Goals of the Project\n\n1.  Build a scalable and distributed IMAP/POP3 server that uses clustered database instead of single machine file system as mail store\n2.  Allow using internationalized email addresses\n3.  Provide Gmail-like features like pushing sent messages automatically to Sent Mail folder or notifying about messages moved to Junk folder so these could be\n    marked as spam\n4.  Provide parsed mailbox and message data over HTTP. This should make creating webmail interfaces super easy, no need to parse RFC822 messages to get text\n    content or attachments\n\n# HTTP API\n\nUsers, mailboxes and messages can be managed with HTTP requests against WildDuck API\n\n**[API Docs](https://api.wildduck.email/)**\n\n# FAQ\n\n### Does it work?\n\nYes, it does. You can run the server and get working IMAP and POP3 servers for mail store, LMTP server for pushing messages to the mail store and\n[HTTP API](https://api.wildduck.email/) server to create new users. All handled by Node.js, MongoDB and Redis, no additional dependencies needed. Provided\nservices can be disabled and enabled one by one so, for example you could process just IMAP in one host and LMTP in another.\n\n### How is security implemented in WildDuck?\n\nRead about WildDuck security implementation from the [Wiki](https://github.com/nodemailer/wildduck/wiki/Security-implementation)\n\n### What are the killer features?\n\n1.  **Stateless.** Start as many instances as you want. You can start multiple WildDuck instances in different machines and as long as they share the same\n    MongoDB and Redis settings, users can connect to any instances. This is very different from the traditional IMAP servers where a single user always needs to\n    connect (or be proxied) to the same IMAP server. WildDuck keeps all required state information in MongoDB, so it does not matter which IMAP instance you\n    use.\n2.  **Scalable** as WildDuck uses sharded MongoDB cluster for the backend storage. If you\'re running out of space, add a new shard.\n3.  **No SPOF.** You can run multiple instances of every required service.\n4.  **Centralized authentication** which allows modern features like 2FA, application specific passwords, authentication scopes, revoking authentication tokens,\n    audit logging and even profile files to auto-configure Apple email clients without master password\n5.  **Works on any OS including Windows.** At least if you get MongoDB and Redis running first.\n6.  Focus on **internationalization**, ie. supporting email addresses with non-ascii characters\n7.  **Deduplication of attachments.** If the same attachment is referenced by different messages then only a single copy of the attachment is stored.\n8.  Access messages both using **IMAP and [HTTP API](https://api.wildduck.email/)**. The latter serves parsed data, so no need to fetch RFC822 messages and parse\n    out html, plaintext content or attachments. It is super easy to create a webmail interface on top of this.\n9.  Built in **address labels**: _username+label@example.com_ is delivered to _username@example.com_\n10. Dots in usernames and addresses are informational only. username@example.com is the same as user.name@example.com\n11. **HTTP Event Source** to push modifications in user email account to browser for super snappy webmail clients\n12. **Super easy to tweak.** The entire codebase is pure JavaScript, so there\'s nothing to compile or anything platform specific. If you need to tweak something\n    then change the code, restart the app and you\'re ready to go. If it works on one machine then most probably it works in every other machine as well.\n13. **Better disk usage**. Attachment deduplication and MongoDB compression yield in about 40% smaller disk usage as the sum of all stored email sizes.\n14. **Extra security features** like automatic GPG encryption of all stored messages or authenticating with U2F\n15. **Exposed logs.** Users have access to logs concerning their account. This includes security logs (authentication attempts, changes on account) and also\n    message logs\n\n### Isn\'t it bad to use a database as a mail store?\n\nYes, historically it has [been considered a bad practice](http://www.memoryhole.net/~kyle/databaseemail.html) to store emails in a database. And for a good\nreason. The data model of relational databases like MySQL does not work well with tree like structures (email mime tree) or large blobs (email source).\n\nNotice the word "relational"? In fact document stores like MongoDB work very well with emails. Document store is great for storing tree-like structures and\nwhile GridFS is not as good as "real" object storage, it is good enough for storing the raw parts of the message. Additionally there\'s nothing too GridFS\nspecific, so (at least in theory) it could be replaced with any object store.\n\nHere\'s a list of alternative email servers that also use a database for storing email messages:\n\n-   [DBMail](http://www.dbmail.org/) (MySQL, IMAP)\n-   [Archiveopteryx](http://archiveopteryx.org/) (PostgreSQL, IMAP)\n-   [ElasticInbox](http://www.elasticinbox.com/) (Cassandra, POP3)\n\n### How does it work?\n\nWhenever a message is received WildDuck parses it into a tree-like structure based on the MIME tree and stores this tree to MongoDB. Attachments are removed\nfrom the tree and stored separately in GridStore. If a message needs to be loaded then WildDuck fetches the tree structure first and, if needed, loads\nattachments from GridStore and then compiles it back into the original RFC822 message. The result should be identical to the original messages unless the\noriginal message used unix newlines, these might be partially replaced with windows newlines.\n\nWildDuck tries to keep minimal state for sessions (basically just a list of currently known UIDs and latest MODSEQ value) to be able to distribute sessions\nbetween different hosts. Whenever a mailbox is opened the entire message list is loaded as an array of UID values. The first UID in the array element points to\nthe message nr. 1 in IMAP, second one points to message nr. 2 etc.\n\nActual update data (information about new and deleted messages, flag updates and such) is stored to a journal log and an update beacon is propagated through\nRedis pub/sub whenever something happens. If a session detects that there have been some changes in the current mailbox and it is possible to notify the user\nabout it (eg. a NOOP call was made), journaled log is loaded from the database and applied to the UID array one action at a time. Once all journaled updates\nhave applied then the result should match the latest state. If it is not possible to notify the user (eg a FETCH call was made), then journal log is not loaded\nand the user continues to see the old state.\n\n## E-Mail Protocol support\n\nWildDuck IMAP server supports the following IMAP standards:\n\n-   The entire **IMAP4rev1** suite with some minor differences from the spec. See below for [IMAP Protocol Differences](#imap-protocol-differences) for a complete\n    list\n-   **IDLE** ([RFC2177](https://tools.ietf.org/html/rfc2177)) \xe2\x80\x93 notfies about new and deleted messages and also about flag updates\n-   **CONDSTORE** ([RFC4551](https://tools.ietf.org/html/rfc4551)) and **ENABLE** ([RFC5161](https://tools.ietf.org/html/rfc5161)) \xe2\x80\x93 supports most of the spec,\n    except metadata stuff which is ignored\n-   **STARTTLS** ([RFC2595](https://tools.ietf.org/html/rfc2595))\n-   **NAMESPACE** ([RFC2342](https://tools.ietf.org/html/rfc2342)) \xe2\x80\x93 minimal support, just lists the single user namespace with hierarchy separator\n-   **UNSELECT** ([RFC3691](https://tools.ietf.org/html/rfc3691))\n-   **UIDPLUS** ([RFC4315](https://tools.ietf.org/html/rfc4315))\n-   **SPECIAL-USE** ([RFC6154](https://tools.ietf.org/html/rfc6154))\n-   **ID** ([RFC2971](https://tools.ietf.org/html/rfc2971))\n-   **MOVE** ([RFC6851](https://tools.ietf.org/html/rfc6851))\n-   **AUTHENTICATE PLAIN** ([RFC4959](https://tools.ietf.org/html/rfc4959)) and **SASL-IR**\n-   **APPENDLIMIT** ([RFC7889](https://tools.ietf.org/html/rfc7889)) \xe2\x80\x93 maximum global allowed message size is advertised in CAPABILITY listing\n-   **UTF8=ACCEPT** ([RFC6855](https://tools.ietf.org/html/rfc6855)) \xe2\x80\x93 this also means that WildDuck natively supports unicode email usernames. For example\n    [\xd0\xb0\xd0\xbd\xd0\xb4\xd1\x80\xd0\xb8\xd1\x81@\xd1\x83\xd0\xb0\xd0\xb9\xd0\xbb\xd0\xb4\xd0\xb4\xd0\xb0\xd0\xba.\xd0\xbe\xd1\x80\xd0\xb3](mailto:\xd0\xb0\xd0\xbd\xd0\xb4\xd1\x80\xd0\xb8\xd1\x81@\xd1\x83\xd0\xb0\xd0\xb9\xd0\xbb\xd0\xb4\xd0\xb4\xd0\xb0\xd0\xba.\xd0\xbe\xd1\x80\xd0\xb3) is a valid email address that is hosted by a test instance of WildDuck\n-   **QUOTA** ([RFC2087](https://tools.ietf.org/html/rfc2087)) \xe2\x80\x93 Quota size is global for an account, using a single quota root. Be aware that quota size does not\n    mean actual byte storage in disk, it is calculated as the sum of the [RFC822](https://tools.ietf.org/html/rfc822) sources of stored messages.\n-   **COMPRESS=DEFLATE** ([RFC4978](https://tools.ietf.org/html/rfc4978)) \xe2\x80\x93 Compress traffic between the client and the server\n\nWildDuck more or less passes the [ImapTest](https://www.imapwiki.org/ImapTest/TestFeatures) Stress Testing run. Common errors that arise in the test are\nunknown labels (WildDuck doesn\'t send unsolicited `FLAGS` updates even though it does send unsolicited `FETCH FLAGS` updates) and sometimes NO for `STORE`\n(messages deleted in one session can not be updated in another).\n\nIn comparison WildDuck is slower in processing single user than Dovecot. Especially when fetching messages, which is expected as Dovecot is reading directly\nfrom filesystem while WildDuck is recomposing messages from different parts.\n\nRaw read/write speed for a single user is usually not relevant anyway as fetching entire mailbox content is not something that happens often. WildDuck offers\nbetter parallelization through MongoDB sharding, so more users should not mean slower response times. It is also more important to offer fast synchronization\nspeeds between clients (eg. notifications about new email and such) where WildDuck excels due to the write ahead log and the ability to push this log to\nclients.\n\n### POP3 Support\n\nIn addition to the required POP3 commands ([RFC1939](https://tools.ietf.org/html/rfc1939)) WildDuck supports the following extensions:\n\n-   **UIDL**\n-   **USER**\n-   **PASS**\n-   **SASL PLAIN**\n-   **PIPELINING**\n-   **TOP**\n\n#### POP3 command behaviors\n\nAll changes to messages like deleting messages or marking messages as seen are stored in storage only in the UPDATE stage (eg. after calling QUIT). Until then\nthe changes are preserved in memory only. This also means that if a message is downloaded but QUIT is not issued then the message does not get marked as _Seen_.\n\n##### LIST\n\nPOP3 listing displays the newest 250 messages in INBOX (configurable)\n\n##### UIDL\n\nWildDuck uses message `_id` value (24 byte hex) as the unique ID. If a message is moved from one mailbox to another then it might _re-appear_ in the listing.\n\n##### RETR\n\nIf a messages is downloaded by a client this message gets marked as _Seen_\n\n##### DELE\n\nIf a messages is deleted by a client this message gets marked as Seen and moved to Trash folder\n\n## Message filtering\n\nWildDuck has built-in message filtering. This is somewhat similar to Sieve even though the filters are not scripts.\n\nFilters can be managed via the [WildDuck API](https://api.wildduck.email/#api-Filters).\n\n## IMAP Protocol Differences\n\nThis is a list of known differences from the IMAP specification. Listed differences are either intentional or are bugs that became features.\n\n1.  `\\Recent` flags is not implemented and most probably never will be (RFC3501 2.3.2.)\n2.  `RENAME` does not touch subfolders which is against the spec (RFC3501 6.3.5\\. _If the name has inferior hierarchical names, then the inferior hierarchical\n    names MUST also be renamed._). WildDuck stores all folders using flat hierarchy, the "/" separator is fake and only used for listing mailboxes\n3.  Unsolicited `FLAGS` responses (RFC3501 7.2.6.) and `PERMANENTFLAGS` are not sent (except for as part of `SELECT` and `EXAMINE` responses). WildDuck notifies\n    about flag updates only with unsolicited FETCH updates.\n4.  WildDuck responds with `NO` for `STORE` if matching messages were deleted in another session\n5.  `CHARSET` argument for the `SEARCH` command is ignored (RFC3501 6.4.4.)\n6.  Metadata arguments for `SEARCH MODSEQ` are ignored (RFC7162 3.1.5.). You can define `<entry-name>` and `<entry-type-req>` values but these are not used for\n    anything\n7.  `SEARCH TEXT` and `SEARCH BODY` both use MongoDB [\\$text index](https://docs.mongodb.com/v3.4/reference/operator/query/text/) against decoded plaintext\n    version of the message. RFC3501 assumes that it should be a string match either against full message (`TEXT`) or body section (`BODY`).\n8.  What happens when FETCH is called for messages that were deleted in another session? _Not sure, need to check_\n9.  **Autoexpunge**, meaning that an EXPUNGE is called on background whenever a messages gets a `\\Deleted` flag set. This is not in conflict with IMAP RFCs.\n\nAny other differences are most probably real bugs and unintentional.\n\n## Other Differences\n\n1. Messages retrieved from WildDuck might not be exact copies of messages that were initially stored. This mostly affects base64 encoded attachments and content in multipart mime nodes (eg. text like "This is a multi-part message in MIME format.")\n\n## Testing\n\nCreate an email account and use your IMAP client to connect to it. To send mail to this account, run the example script:\n\n```\nnode examples/push-message.js username@example.com\n```\n\nThis should "deliver" a new message to the INBOX of _username@example.com_ by using the built-in LMTP maildrop interface. If your email client is connected then\nyou should promptly see the new message.\n\n## Outbound SMTP\n\nUse [WildDuck MTA](https://github.com/nodemailer/wildduck-mta) (which under the hood is [ZoneMTA](https://github.com/zone-eu/zone-mta) with the\n[ZoneMTA-WildDuck](https://github.com/nodemailer/zonemta-wildduck) plugin).\n\nThis gives you an outbound SMTP server that uses WildDuck accounts for authentication. The plugin authenticates user credentials and also rewrites headers if\nneeded (if the header From: address does not match user address or aliases then it is rewritten).\n\n## Inbound SMTP\n\nUse [Haraka](http://haraka.github.io/) with [haraka-plugins-wildduck](https://github.com/nodemailer/haraka-plugin-wildduck) to validate recipient addresses and quota usage against the WildDuck users database and to store/filter messages.\n\n#### Spam detection\n\nUse [Rspamd plugin for Haraka](https://github.com/haraka/haraka-plugin-rspamd) in order to detect spam. WildDuck plugin detects Rspamd output and uses this information to send the message either to Inbox or Junk.\n\n## Future considerations\n\n-   Optimize FETCH queries to load only partial data for BODY subparts\n-   Parse incoming message into the mime tree as a stream. Currently the entire message is buffered in memory before being parsed.\n-   Maybe allow some kind of message manipulation through plugins\n-   WildDuck does not plan to be the most feature-rich IMAP client in the world. Most IMAP extensions are useless because there aren\'t too many clients that are\n    able to benefit from these extensions. There are a few extensions though that would make sense to be added to WildDuck:\n\n    -   IMAP4 non-synchronizing literals, LITERAL- ([RFC7888](https://tools.ietf.org/html/rfc7888)). Synchronized literals are needed for APPEND to check mailbox\n        quota, small values could go with the non-synchronizing version.\n    -   LIST-STATUS ([RFC5819](https://tools.ietf.org/html/rfc5819))\n    -   _What else?_ (definitely not NOTIFY nor QRESYNC)\n\n## Operating WildDuck\n\n### Logging\n\nWildDuck sends gelf-formatted log messages to a Graylog server. Set `log.gelf.enabled=true` in [config](https://github.com/nodemailer/wildduck/blob/2019fd9db6bce1c3167f08e363ab4225b8c8a296/config/default.toml#L59-L66) to use it. Also make sure that the same Gelf settings are set for _zonemta-wildduck_ and _haraka-plugin-wildduck_ in order to get consistent logs about messages throughout the system.\n\n> Graylog logging replaces previously used \'messagelog\' database collection\n\n### Import from maildir\n\nThere is a tool to import emails from an existing maildir to WildDuck email database. See the tool [here](https://github.com/nodemailer/import-maildir)\n\n### Sharding\n\nWildDuck supports MongoDB sharding. Consider using sharding only if you know that your data storage is large enough to outgrow single replica. Some actions\nrequire scattered queries to be made that might be a hit on performance on a large cluster but most queries include the shard key by default.\n\nShard the following collections by these keys (assuming you keep attachments in a separate database):\n\n```javascript\nsh.enableSharding(\'wildduck\');\n// consider using mailbox:hashed for messages only with large shard chunk size\nsh.shardCollection(\'wildduck.messages\', { mailbox: 1, uid: 1 });\nsh.shardCollection(\'wildduck.archived\', { user: 1, _id: 1 });\nsh.shardCollection(\'wildduck.threads\', { user: \'hashed\' });\nsh.shardCollection(\'wildduck.authlog\', { user: \'hashed\' });\n\nsh.enableSharding(\'attachments\');\n// attachment _id is a sha256 hash of attachment contents\nsh.shardCollection(\'attachments.attachments.files\', { _id: \'hashed\' });\nsh.shardCollection(\'attachments.attachments.chunks\', { files_id: \'hashed\' });\n\n// storage _id is an ObjectID\nsh.shardCollection(\'attachments.storage.files\', { _id: \'hashed\' });\nsh.shardCollection(\'attachments.storage.chunks\', { files_id: \'hashed\' });\n```\n\n### Disk usage\n\nTests show that the ratio of attachment contents vs other stuff is around 1:10. This means that you can split your database between multiple disks by using\nsmaller SSD (eg. 150GB) for message data and indexes and a larger and cheaper SATA (eg. 1TB) for attachment contents. This assumes that you use WiredTiger with\n`storage.directoryPerDB:true` and `storage.wiredTiger.engineConfig.directoryForIndexes:true`\n\nAssuming that you use a database named `attachments` for attachment contents:\n\n    SSD mount : /var/lib/mongodb\n    SATA mount: /var/lib/mongodb/attachments/collection\n\nMongoDB does not complain about existing folders so you can prepare the mount before even installing MongoDB.\n\n### Redis Sentinel\n\nWildDuck is able to use Redis Sentinel instead of single Redis master for automatic failover. When using Sentinel and the Redis master fails then it might take\na moment until new master is elected. Pending requests are cached during that window, so most operations should succeed eventually. You might want to test\nfailover under load though, to see how it behaves.\n\nRedis Sentinel failover does not guarantee consistency. WildDuck does not store critical information in Redis, so even if some data loss occurs, it should not\nbe noticeable.\n\n### HAProxy\n\nWhen using HAProxy you can enable PROXY protocol to get correct remote addresses in server logs. You can use the most basic round-robin based balancing as no\npersistent sessions against specific hosts are needed. Use TCP load balancing with no extra settings both for plaintext and TLS connections.\n\nIf TLS is handled by HAProxy then use the following server config to indicate that WildDuck assumes to be a TLS server but TLS is handled upstream\n\n```toml\n[imap]\nsecure=true # this is a TLS server\nsecured=true # TLS is handled upstream\n\n[pop3]\nsecure=true # this is a TLS server\nsecured=true # TLS is handled upstream\n```\n\n### Certificates\n\nYou can live-reload updated certificates by sending SIGHUP to the master process. This causes application configuration to be re-read from the disk. Reloading\nonly affects only some settings, for example all TLS certificates are loaded and updated. In this case existing processes continue as is, while new ones use the\nupdated certs.\n\nBeware though that if configuration loading fails, then it ends with an exception. Make sure that TLS certificate files are readable for the WildDuck user.\n\n## License\n\nWildDuck Mail Agent is licensed under the [European Union Public License 1.1](http://ec.europa.eu/idabc/eupl.html) or later.\n'