b'# Ristretto\n[![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg)](http://godoc.org/github.com/dgraph-io/ristretto)\n[![Go Report Card](https://img.shields.io/badge/go%20report-A%2B-brightgreen)](https://goreportcard.com/report/github.com/dgraph-io/ristretto)\n[![Coverage](https://img.shields.io/badge/coverage-100%25-brightgreen)](https://gocover.io/github.com/dgraph-io/ristretto)\n![Tests](https://github.com/dgraph-io/ristretto/workflows/tests/badge.svg)\n\nRistretto is a fast, concurrent cache library built with a focus on performance and correctness.\n\nThe motivation to build Ristretto comes from the need for a contention-free\ncache in [Dgraph][].\n\n[Dgraph]: https://github.com/dgraph-io/dgraph\n\n## Features\n\n* **High Hit Ratios** - with our unique admission/eviction policy pairing, Ristretto\'s performance is best in class.\n\t* **Eviction: SampledLFU** - on par with exact LRU and better performance on Search and Database traces.\n\t* **Admission: TinyLFU** - extra performance with little memory overhead (12 bits per counter).\n* **Fast Throughput** - we use a variety of techniques for managing contention and the result is excellent throughput.\n* **Cost-Based Eviction** - any large new item deemed valuable can evict multiple smaller items (cost could be anything).\n* **Fully Concurrent** - you can use as many goroutines as you want with little throughput degradation. \n* **Metrics** - optional performance metrics for throughput, hit ratios, and other stats.\n* **Simple API** - just figure out your ideal `Config` values and you\'re off and running.\n\n## Status\n\nRistretto is usable but still under active development. We expect it to be production ready in the near future.\n\n## Table of Contents\n\n* [Usage](#Usage)\n\t* [Example](#Example)\n\t* [Config](#Config)\n\t\t* [NumCounters](#Config)\n\t\t* [MaxCost](#Config)\n\t\t* [BufferItems](#Config)\n\t\t* [Metrics](#Config)\n\t\t* [OnEvict](#Config)\n\t\t* [KeyToHash](#Config)\n        * [Cost](#Config)\n* [Benchmarks](#Benchmarks)\n\t* [Hit Ratios](#Hit-Ratios)\n\t\t* [Search](#Search)\n\t\t* [Database](#Database)\n\t\t* [Looping](#Looping)\n\t\t* [CODASYL](#CODASYL)\n\t* [Throughput](#Throughput)\n\t\t* [Mixed](#Mixed)\n\t\t* [Read](#Read)\n\t\t* [Write](#Write)\n* [FAQ](#FAQ)\n\n## Usage\n\n### Example\n\n```go\nfunc main() {\n\tcache, err := ristretto.NewCache(&ristretto.Config{\n\t\tNumCounters: 1e7,     // number of keys to track frequency of (10M).\n\t\tMaxCost:     1 << 30, // maximum cost of cache (1GB).\n\t\tBufferItems: 64,      // number of keys per Get buffer.\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// set a value with a cost of 1\n\tcache.Set("key", "value", 1)\n\t\n\t// wait for value to pass through buffers\n\ttime.Sleep(10 * time.Millisecond)\n\n\tvalue, found := cache.Get("key")\n\tif !found {\n\t\tpanic("missing value")\n\t}\n\tfmt.Println(value)\n\tcache.Del("key")\n}\n```\n\n### Config\n\nThe `Config` struct is passed to `NewCache` when creating Ristretto instances (see the example above). \n\n**NumCounters** `int64`\n\nNumCounters is the number of 4-bit access counters to keep for admission and eviction. We\'ve seen good performance in setting this to 10x the number of items you expect to keep in the cache when full. \n\nFor example, if you expect each item to have a cost of 1 and MaxCost is 100, set NumCounters to 1,000. Or, if you use variable cost values but expect the cache to hold around 10,000 items when full, set NumCounters to 100,000. The important thing is the *number of unique items* in the full cache, not necessarily the MaxCost value. \n\n**MaxCost** `int64`\n\nMaxCost is how eviction decisions are made. For example, if MaxCost is 100 and a new item with a cost of 1 increases total cache cost to 101, 1 item will be evicted. \n\nMaxCost can also be used to denote the max size in bytes. For example, if MaxCost is 1,000,000 (1MB) and the cache is full with 1,000 1KB items, a new item (that\'s accepted) would cause 5 1KB items to be evicted. \n\nMaxCost could be anything as long as it matches how you\'re using the cost values when calling Set. \n\n**BufferItems** `int64`\n\nBufferItems is the size of the Get buffers. The best value we\'ve found for this is 64. \n\nIf for some reason you see Get performance decreasing with lots of contention (you shouldn\'t), try increasing this value in increments of 64. This is a fine-tuning mechanism and you probably won\'t have to touch this.\n\n**Metrics** `bool`\n\nMetrics is true when you want real-time logging of a variety of stats. The reason this is a Config flag is because there\'s a 10% throughput performance overhead. \n\n**OnEvict** `func(hashes [2]uint64, value interface{}, cost int64)`\n\nOnEvict is called for every eviction.\n\n**KeyToHash** `func(key interface{}) [2]uint64`\n\nKeyToHash is the hashing algorithm used for every key. If this is nil, Ristretto has a variety of [defaults depending on the underlying interface type](https://github.com/dgraph-io/ristretto/blob/master/z/z.go#L19-L41).\n\nNote that if you want 128bit hashes you should use the full `[2]uint64`,\notherwise just fill the `uint64` at the `0` position and it will behave like\nany 64bit hash.\n\n**Cost** `func(value interface{}) int64`\n\nCost is an optional function you can pass to the Config in order to evaluate\nitem cost at runtime, and only for the Set calls that aren\'t dropped (this is\nuseful if calculating item cost is particularly expensive and you don\'t want to\nwaste time on items that will be dropped anyways).\n\nTo signal to Ristretto that you\'d like to use this Cost function:\n\n1. Set the Cost field to a non-nil function.\n2. When calling Set for new items or item updates, use a `cost` of 0.\n\n## Benchmarks\n\nThe benchmarks can be found in https://github.com/dgraph-io/benchmarks/tree/master/cachebench/ristretto.\n\n### Hit Ratios\n\n#### Search\n\nThis trace is described as "disk read accesses initiated by a large commercial\nsearch engine in response to various web search requests."\n\n<p align="center">\n\t<img src="https://raw.githubusercontent.com/karlmcguire/karlmcguire.com/master/docs/Hit%20Ratios%20-%20Search%20(ARC-S3).svg?sanitize=true">\n</p>\n\n#### Database\n\nThis trace is described as "a database server running at a commercial site\nrunning an ERP application on top of a commercial database."\n\n<p align="center">\n\t<img src="https://raw.githubusercontent.com/karlmcguire/karlmcguire.com/master/docs/Hit%20Ratios%20-%20Database%20(ARC-DS1).svg?sanitize=true">\n</p>\n\n#### Looping\n\nThis trace demonstrates a looping access pattern.\n\n<p align="center">\n\t<img src="https://raw.githubusercontent.com/karlmcguire/karlmcguire.com/master/docs/Hit%20Ratios%20-%20Glimpse%20(LIRS-GLI).svg?sanitize=true">\n</p>\n\n#### CODASYL\n\nThis trace is described as "references to a CODASYL database for a one hour\nperiod."\n\n<p align="center">\n\t<img src="https://raw.githubusercontent.com/karlmcguire/karlmcguire.com/master/docs/Hit%20Ratios%20-%20CODASYL%20(ARC-OLTP).svg?sanitize=true">\n</p>\n\n### Throughput\n\nAll throughput benchmarks were ran on an Intel Core i7-8700K (3.7GHz) with 16gb\nof RAM.\n\n#### Mixed\n\n<p align="center">\n\t<img src="https://raw.githubusercontent.com/karlmcguire/karlmcguire.com/master/docs/Throughput%20-%20Mixed.svg?sanitize=true">\n</p>\n\n#### Read\n\n<p align="center">\n\t<img src="https://raw.githubusercontent.com/karlmcguire/karlmcguire.com/master/docs/Throughput%20-%20Read%20(Zipfian).svg?sanitize=true">\n</p>\n\n#### Write\n\n<p align="center">\n\t<img src="https://raw.githubusercontent.com/karlmcguire/karlmcguire.com/master/docs/Throughput%20-%20Write%20(Zipfian).svg?sanitize=true">\n</p>\n\n## FAQ\n\n### How are you achieving this performance? What shortcuts are you taking?\n\nWe go into detail in the [Ristretto blog post](https://blog.dgraph.io/post/introducing-ristretto-high-perf-go-cache/), but in short: our throughput performance can be attributed to a mix of batching and eventual consistency. Our hit ratio performance is mostly due to an excellent [admission policy](https://arxiv.org/abs/1512.00727) and SampledLFU eviction policy.\n\nAs for "shortcuts," the only thing Ristretto does that could be construed as one is dropping some Set calls. That means a Set call for a new item (updates are guaranteed) isn\'t guaranteed to make it into the cache. The new item could be dropped at two points: when passing through the Set buffer or when passing through the admission policy. However, this doesn\'t affect hit ratios much at all as we expect the most popular items to be Set multiple times and eventually make it in the cache. \n\n### Is Ristretto distributed?\n\nNo, it\'s just like any other Go library that you can import into your project and use in a single process. \n'