b'# go-cache\n\ngo-cache is an in-memory key:value store/cache similar to memcached that is\nsuitable for applications running on a single machine. Its major advantage is\nthat, being essentially a thread-safe `map[string]interface{}` with expiration\ntimes, it doesn\'t need to serialize or transmit its contents over the network.\n\nAny object can be stored, for a given duration or forever, and the cache can be\nsafely used by multiple goroutines.\n\nAlthough go-cache isn\'t meant to be used as a persistent datastore, the entire\ncache can be saved to and loaded from a file (using `c.Items()` to retrieve the\nitems map to serialize, and `NewFrom()` to create a cache from a deserialized\none) to recover from downtime quickly. (See the docs for `NewFrom()` for caveats.)\n\n### Installation\n\n`go get github.com/patrickmn/go-cache`\n\n### Usage\n\n```go\nimport (\n\t"fmt"\n\t"github.com/patrickmn/go-cache"\n\t"time"\n)\n\nfunc main() {\n\t// Create a cache with a default expiration time of 5 minutes, and which\n\t// purges expired items every 10 minutes\n\tc := cache.New(5*time.Minute, 10*time.Minute)\n\n\t// Set the value of the key "foo" to "bar", with the default expiration time\n\tc.Set("foo", "bar", cache.DefaultExpiration)\n\n\t// Set the value of the key "baz" to 42, with no expiration time\n\t// (the item won\'t be removed until it is re-set, or removed using\n\t// c.Delete("baz")\n\tc.Set("baz", 42, cache.NoExpiration)\n\n\t// Get the string associated with the key "foo" from the cache\n\tfoo, found := c.Get("foo")\n\tif found {\n\t\tfmt.Println(foo)\n\t}\n\n\t// Since Go is statically typed, and cache values can be anything, type\n\t// assertion is needed when values are being passed to functions that don\'t\n\t// take arbitrary types, (i.e. interface{}). The simplest way to do this for\n\t// values which will only be used once--e.g. for passing to another\n\t// function--is:\n\tfoo, found := c.Get("foo")\n\tif found {\n\t\tMyFunction(foo.(string))\n\t}\n\n\t// This gets tedious if the value is used several times in the same function.\n\t// You might do either of the following instead:\n\tif x, found := c.Get("foo"); found {\n\t\tfoo := x.(string)\n\t\t// ...\n\t}\n\t// or\n\tvar foo string\n\tif x, found := c.Get("foo"); found {\n\t\tfoo = x.(string)\n\t}\n\t// ...\n\t// foo can then be passed around freely as a string\n\n\t// Want performance? Store pointers!\n\tc.Set("foo", &MyStruct, cache.DefaultExpiration)\n\tif x, found := c.Get("foo"); found {\n\t\tfoo := x.(*MyStruct)\n\t\t\t// ...\n\t}\n}\n```\n\n### Reference\n\n`godoc` or [http://godoc.org/github.com/patrickmn/go-cache](http://godoc.org/github.com/patrickmn/go-cache)\n'