b'\xef\xbb\xbf<p align="right">\n  <strong>\n    <a href="README.md">English</a> |\n    <a href="README-zh-cn.md">\xe4\xb8\xad\xe6\x96\x87</a> |\n    <a href="README-ru-ru.md">\xd0\xa0\xd1\x83\xd1\x81\xd1\x81\xd0\xba\xd0\xb8\xd0\xb9</a> |\n    <a href="README-th-th.md">\xe0\xb8\xa0\xe0\xb8\xb2\xe0\xb8\xa9\xe0\xb8\xb2\xe0\xb9\x84\xe0\xb8\x97\xe0\xb8\xa2</a> |\n    <a href="README-vi-vn.md">Ti\xe1\xba\xbfng Vi\xe1\xbb\x87t</a>\n  </strong>\n  <br/>\n  <sup><em>(Please contribute translations!)</em></sup>\n</p>\n\n# Unstated Next\n\n> 200 bytes to never think about React state management libraries ever again\n\n- **React Hooks** _use them for all your state management._\n- **~200 bytes** _min+gz._\n- **Familiar API** _just use React as intended._\n- **Minimal API** _it takes 5 minutes to learn._\n- **Written in TypeScript** _and will make it easier for you to type your React code._\n\nBut, the most important question: Is this better than Redux? Well...\n\n- **It\'s smaller.** _It\'s 40x smaller._\n- **It\'s faster.** _Componentize the problem of performance._\n- **It\'s easier to learn.** _You already will have to know React Hooks & Context, just use them, they rock._\n- **It\'s easier to integrate.** _Integrate one component at a time, and easily integrate with every React library._\n- **It\'s easier to test.** _Testing reducers is a waste of your time, make it easier to test your React components._\n- **It\'s easier to typecheck.** _Designed to make most of your types inferable._\n- **It\'s minimal.** _It\'s just React._\n\nSo you decide.\n\n### [See Migration From Unstated docs &rarr;](#migration-from-unstated)\n\n## Install\n\n```sh\nnpm install --save unstated-next\n```\n\n## Example\n\n```js\nimport React, { useState } from "react"\nimport { createContainer } from "unstated-next"\nimport { render } from "react-dom"\n\nfunction useCounter(initialState = 0) {\n  let [count, setCount] = useState(initialState)\n  let decrement = () => setCount(count - 1)\n  let increment = () => setCount(count + 1)\n  return { count, decrement, increment }\n}\n\nlet Counter = createContainer(useCounter)\n\nfunction CounterDisplay() {\n  let counter = Counter.useContainer()\n  return (\n    <div>\n      <button onClick={counter.decrement}>-</button>\n      <span>{counter.count}</span>\n      <button onClick={counter.increment}>+</button>\n    </div>\n  )\n}\n\nfunction App() {\n  return (\n    <Counter.Provider>\n      <CounterDisplay />\n      <Counter.Provider initialState={2}>\n        <div>\n          <div>\n            <CounterDisplay />\n          </div>\n        </div>\n      </Counter.Provider>\n    </Counter.Provider>\n  )\n}\n\nrender(<App />, document.getElementById("root"))\n```\n\n## API\n\n### `createContainer(useHook)`\n\n```js\nimport { createContainer } from "unstated-next"\n\nfunction useCustomHook() {\n  let [value, setValue] = useState()\n  let onChange = e => setValue(e.currentTarget.value)\n  return { value, onChange }\n}\n\nlet Container = createContainer(useCustomHook)\n// Container === { Provider, useContainer }\n```\n\n### `<Container.Provider>`\n\n```js\nfunction ParentComponent() {\n  return (\n    <Container.Provider>\n      <ChildComponent />\n    </Container.Provider>\n  )\n}\n```\n\n### `<Container.Provider initialState>`\n\n```js\nfunction useCustomHook(initialState = "") {\n  let [value, setValue] = useState(initialState)\n  // ...\n}\n\nfunction ParentComponent() {\n  return (\n    <Container.Provider initialState={"value"}>\n      <ChildComponent />\n    </Container.Provider>\n  )\n}\n```\n\n### `Container.useContainer()`\n\n```js\nfunction ChildComponent() {\n  let input = Container.useContainer()\n  return <input value={input.value} onChange={input.onChange} />\n}\n```\n\n### `useContainer(Container)`\n\n```js\nimport { useContainer } from "unstated-next"\n\nfunction ChildComponent() {\n  let input = useContainer(Container)\n  return <input value={input.value} onChange={input.onChange} />\n}\n```\n\n## Guide\n\nIf you\'ve never used React Hooks before, I recommend pausing and going to read\nthrough [the excellent docs on the React site](https://reactjs.org/docs/hooks-intro.html).\n\nSo with hooks you might create a component like this:\n\n```js\nfunction CounterDisplay() {\n  let [count, setCount] = useState(0)\n  let decrement = () => setCount(count - 1)\n  let increment = () => setCount(count + 1)\n  return (\n    <div>\n      <button onClick={decrement}>-</button>\n      <p>You clicked {count} times</p>\n      <button onClick={increment}>+</button>\n    </div>\n  )\n}\n```\n\nThen if you want to share the logic behind the component, you could pull it out\ninto a custom hook:\n\n```js\nfunction useCounter() {\n  let [count, setCount] = useState(0)\n  let decrement = () => setCount(count - 1)\n  let increment = () => setCount(count + 1)\n  return { count, decrement, increment }\n}\n\nfunction CounterDisplay() {\n  let counter = useCounter()\n  return (\n    <div>\n      <button onClick={counter.decrement}>-</button>\n      <p>You clicked {counter.count} times</p>\n      <button onClick={counter.increment}>+</button>\n    </div>\n  )\n}\n```\n\nBut what if you want to share the state in addition to the logic, what do you do?\n\nThis is where context comes into play:\n\n```js\nfunction useCounter() {\n  let [count, setCount] = useState(0)\n  let decrement = () => setCount(count - 1)\n  let increment = () => setCount(count + 1)\n  return { count, decrement, increment }\n}\n\nlet Counter = createContext(null)\n\nfunction CounterDisplay() {\n  let counter = useContext(Counter)\n  return (\n    <div>\n      <button onClick={counter.decrement}>-</button>\n      <p>You clicked {counter.count} times</p>\n      <button onClick={counter.increment}>+</button>\n    </div>\n  )\n}\n\nfunction App() {\n  let counter = useCounter()\n  return (\n    <Counter.Provider value={counter}>\n      <CounterDisplay />\n      <CounterDisplay />\n    </Counter.Provider>\n  )\n}\n```\n\nThis is great, it\'s perfect, more people should write code like this.\n\nBut sometimes we all need a little bit more structure and intentional API design in order to get it consistently right.\n\nBy introducing the `createContainer()` function, you can think about your custom hooks as "containers" and have an API that\'s clear and prevents you from using it wrong.\n\n```js\nimport { createContainer } from "unstated-next"\n\nfunction useCounter() {\n  let [count, setCount] = useState(0)\n  let decrement = () => setCount(count - 1)\n  let increment = () => setCount(count + 1)\n  return { count, decrement, increment }\n}\n\nlet Counter = createContainer(useCounter)\n\nfunction CounterDisplay() {\n  let counter = Counter.useContainer()\n  return (\n    <div>\n      <button onClick={counter.decrement}>-</button>\n      <p>You clicked {counter.count} times</p>\n      <button onClick={counter.increment}>+</button>\n    </div>\n  )\n}\n\nfunction App() {\n  return (\n    <Counter.Provider>\n      <CounterDisplay />\n      <CounterDisplay />\n    </Counter.Provider>\n  )\n}\n```\n\nHere\'s the diff of that change:\n\n```diff\n- import { createContext, useContext } from "react"\n+ import { createContainer } from "unstated-next"\n\n  function useCounter() {\n    ...\n  }\n\n- let Counter = createContext(null)\n+ let Counter = createContainer(useCounter)\n\n  function CounterDisplay() {\n-   let counter = useContext(Counter)\n+   let counter = Counter.useContainer()\n    return (\n      <div>\n        ...\n      </div>\n    )\n  }\n\n  function App() {\n-   let counter = useCounter()\n    return (\n-     <Counter.Provider value={counter}>\n+     <Counter.Provider>\n        <CounterDisplay />\n        <CounterDisplay />\n      </Counter.Provider>\n    )\n  }\n```\n\nIf you\'re using TypeScript (which I encourage you to learn more about if you are not), this also has the benefit of making TypeScript\'s built-in inference work better. As long as your custom hook is typed, then everything else will just work.\n\n## Tips\n\n### Tip #1: Composing Containers\n\nBecause we\'re just working with custom React hooks, we can compose containers inside of other hooks.\n\n```js\nfunction useCounter() {\n  let [count, setCount] = useState(0)\n  let decrement = () => setCount(count - 1)\n  let increment = () => setCount(count + 1)\n  return { count, decrement, increment, setCount }\n}\n\nlet Counter = createContainer(useCounter)\n\nfunction useResettableCounter() {\n  let counter = Counter.useContainer()\n  let reset = () => counter.setCount(0)\n  return { ...counter, reset }\n}\n```\n\n### Tip #2: Keeping Containers Small\n\nThis can be useful for keeping your containers small and focused. Which can be important if you want to code split the logic in your containers: Just move them to their own hooks and keep just the state in containers.\n\n```js\nfunction useCount() {\n  return useState(0)\n}\n\nlet Count = createContainer(useCount)\n\nfunction useCounter() {\n  let [count, setCount] = Count.useContainer()\n  let decrement = () => setCount(count - 1)\n  let increment = () => setCount(count + 1)\n  let reset = () => setCount(0)\n  return { count, decrement, increment, reset }\n}\n```\n\n### Tip #3: Optimizing components\n\nThere\'s no "optimizing" `unstated-next` to be done, all of the optimizations you might do would be standard React optimizations.\n\n#### 1) Optimizing expensive sub-trees by splitting the component apart\n\n**Before:**\n\n```js\nfunction CounterDisplay() {\n  let counter = Counter.useContainer()\n  return (\n    <div>\n      <button onClick={counter.decrement}>-</button>\n      <p>You clicked {counter.count} times</p>\n      <button onClick={counter.increment}>+</button>\n      <div>\n        <div>\n          <div>\n            <div>SUPER EXPENSIVE RENDERING STUFF</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n```\n\n**After:**\n\n```js\nfunction ExpensiveComponent() {\n  return (\n    <div>\n      <div>\n        <div>\n          <div>SUPER EXPENSIVE RENDERING STUFF</div>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nfunction CounterDisplay() {\n  let counter = Counter.useContainer()\n  return (\n    <div>\n      <button onClick={counter.decrement}>-</button>\n      <p>You clicked {counter.count} times</p>\n      <button onClick={counter.increment}>+</button>\n      <ExpensiveComponent />\n    </div>\n  )\n}\n```\n\n#### 2) Optimizing expensive operations with useMemo()\n\n**Before:**\n\n```js\nfunction CounterDisplay(props) {\n  let counter = Counter.useContainer()\n\n  // Recalculating this every time `counter` changes is expensive\n  let expensiveValue = expensiveComputation(props.input)\n\n  return (\n    <div>\n      <button onClick={counter.decrement}>-</button>\n      <p>You clicked {counter.count} times</p>\n      <button onClick={counter.increment}>+</button>\n    </div>\n  )\n}\n```\n\n**After:**\n\n```js\nfunction CounterDisplay(props) {\n  let counter = Counter.useContainer()\n\n  // Only recalculate this value when its inputs have changed\n  let expensiveValue = useMemo(() => {\n    return expensiveComputation(props.input)\n  }, [props.input])\n\n  return (\n    <div>\n      <button onClick={counter.decrement}>-</button>\n      <p>You clicked {counter.count} times</p>\n      <button onClick={counter.increment}>+</button>\n    </div>\n  )\n}\n```\n\n#### 3) Reducing re-renders using React.memo() and useCallback()\n\n**Before:**\n\n```js\nfunction useCounter() {\n  let [count, setCount] = useState(0)\n  let decrement = () => setCount(count - 1)\n  let increment = () => setCount(count + 1)\n  return { count, decrement, increment }\n}\n\nlet Counter = createContainer(useCounter)\n\nfunction CounterDisplay(props) {\n  let counter = Counter.useContainer()\n  return (\n    <div>\n      <button onClick={counter.decrement}>-</button>\n      <p>You clicked {counter.count} times</p>\n      <button onClick={counter.increment}>+</button>\n    </div>\n  )\n}\n```\n\n**After:**\n\n```js\nfunction useCounter() {\n  let [count, setCount] = useState(0)\n  let decrement = useCallback(() => setCount(count - 1), [count])\n  let increment = useCallback(() => setCount(count + 1), [count])\n  return { count, decrement, increment }\n}\n\nlet Counter = createContainer(useCounter)\n\nlet CounterDisplayInner = React.memo(props => {\n  return (\n    <div>\n      <button onClick={props.decrement}>-</button>\n      <p>You clicked {props.count} times</p>\n      <button onClick={props.increment}>+</button>\n    </div>\n  )\n})\n\nfunction CounterDisplay(props) {\n  let counter = Counter.useContainer()\n  return <CounterDisplayInner {...counter} />\n}\n```\n\n#### 4) Wrapping your elements with `useMemo()`\n\n[via Dan Abramov](https://github.com/facebook/react/issues/15156#issuecomment-474590693)\n\n**Before:**\n\n```js\nfunction CounterDisplay(props) {\n  let counter = Counter.useContainer()\n  let count = counter.count\n  \n  return (\n    <p>You clicked {count} times</p>\n  )\n}\n```\n\n**After:**\n\n```js\nfunction CounterDisplay(props) {\n  let counter = Counter.useContainer()\n  let count = counter.count\n  \n  return useMemo(() => (\n    <p>You clicked {count} times</p>\n  ), [count])\n}\n```\n\n## Relation to Unstated\n\nI consider this library the spiritual successor to [Unstated](https://github.com/jamiebuilds/unstated). I created Unstated because I believed that React was really great at state management already and the only missing piece was sharing state and logic easily. So I created Unstated to be the "minimal" solution to sharing React state and logic.\n\nHowever, with Hooks, React has become much better at sharing state and logic. To the point that I think Unstated has become an unnecessary abstraction.\n\n**HOWEVER**, I think many developers have struggled seeing how to share state and logic with React Hooks for "application state". That may just be an issue of documentation and community momentum, but I think that an API could help bridge that mental gap.\n\nThat API is what Unstated Next is. Instead of being the "Minimal API for sharing state and logic in React", it is now the "Minimal API for understanding shared state and logic in React".\n\nI\'ve always been on the side of React. I want React to win. I would like to see the community abandon state management libraries like Redux, and find better ways of making use of React\'s built-in toolchain.\n\nIf instead of using Unstated, you just want to use React itself, I would highly encourage that. Write blog posts about it! Give talks about it! Spread your knowledge in the community.\n\n## Migration from `unstated`\n\nI\'ve intentionally published this as a separate package name because it is a complete reset on the API. This way you can have both installed and migrate incrementally.\n\nPlease provide me with feedback on that migration process, because over the next few months I hope to take that feedback and do two things:\n\n- Make sure `unstated-next` fulfills all the needs of `unstated` users.\n- Make sure `unstated` has a clean migration process towards `unstated-next`.\n\nI may choose to add APIs to either library to make life easier for developers. For `unstated-next` I promise that the added APIs will be as minimal as possible and I\'ll try to keep the library small.\n\nIn the future, I will likely merge `unstated-next` back into `unstated` as a new major version. `unstated-next` will still exist so that you can have both `unstated@2` and `unstated-next` installed. Then when you are done with the migration, you can update to `unstated@3` and remove `unstated-next` (being sure to update all your imports as you do... should be just a find-and-replace).\n\nEven though this is a major new API change, I hope that I can make this migration as easy as possible on you. I\'m optimizing for you to get to using the latest React Hooks APIs and not for preserving code written with `Unstated.Container`\'s. Feel free to provide feedback on how that could be done better.\n'