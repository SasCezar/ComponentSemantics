b"[![NuGet](https://img.shields.io/nuget/v/Microsoft.FASTER.svg)](https://www.nuget.org/packages/Microsoft.FASTER/)\n[![Build Status](https://dev.azure.com/ms/FASTER/_apis/build/status/Microsoft.FASTER)](https://dev.azure.com/ms/FASTER/_build/latest?definitionId=8)\n[![Gitter](https://badges.gitter.im/Microsoft/FASTER.svg)](https://gitter.im/Microsoft/FASTER?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\n\n# Introduction\n\nManaging large application state easily, resiliently, and with high performance is one of the hardest\nproblems in the cloud today. The FASTER project offers two artifacts to help tackle this problem.\n\n* :new: **FASTER Log** is a high-performance concurrent persistent recoverable log, iterator, and random \nreader library in C#. It supports very frequent commit operations at low latency, and can quickly saturate \ndisk bandwidth. It support both sync and async interfaces, handles disk errors, and supports checksums. Learn \nmore about the FASTER Log [here](https://github.com/microsoft/FASTER/blob/master/docs/cs/FasterLog.md) or [here](https://microsoft.github.io/FASTER/docs/fasterlog).\n\n* **FASTER KV** is a concurrent key-value store + cache (available in C# and C++) that is designed for point \nlookups and heavy updates. FASTER supports data larger than memory, by leveraging fast external \nstorage (local or cloud). It also supports consistent recovery using a new checkpointing technique that lets \napplications trade-off performance for commit latency.\n\n\nSome key differentiating features of FASTER KV and FASTER Log include:\n\n1. Latch-free cache-optimized index, in FASTER KV.\n2. A fast persistent recoverable append-only log based on fine-grained epoch protection for concurrency, \nin FASTER Log.\n3. Unique \xe2\x80\x9chybrid record log\xe2\x80\x9d design in FASTER KV, that combines the above log with in-place updates, to \nshape the memory working set and retain performance.\n4. Architecture as a component that can be embedded in multi-threaded cloud apps. \n5. Asynchronous recovery model based on group commit (called [CPR](#Recovery-in-FASTER)).\n6. A rich extensible storage device abstraction called `IDevice`, with implementations for local\nstorage, cloud storage, tiered storage, and sharded storage.\n\nFor standard benchmarks where the working set fits in main memory, we found FASTER KV to achieve\nsignificantly higher throughput than current systems, and match or exceed the performance of pure \nin-memory data structures while offering more functionality. See [the SIGMOD paper](https://www.microsoft.com/en-us/research/uploads/prod/2018/03/faster-sigmod18.pdf) for more details. We also have a detailed\nanalysis of C# FASTER KV performance in a wiki page \n[here](https://github.com/Microsoft/FASTER/wiki/Performance-of-FASTER-in-C%23). The performance of the \nC# and C++ versions of FASTER are very similar. FASTER Log is also extremely fast, capable of saturating modern\nNVMe SSDs using less than a core of CPU, and scaling well in a multi-threaded setting.\n\n# Getting Started\n\nVisit our [research website](http://aka.ms/FASTER) for technical details and papers. For FASTER usage and \ngetting started information, head over to our [GitHub Pages](https://microsoft.github.io/FASTER) website. A \ndetailed guide to getting started with FASTER KV C# is also available in the repository at [this link](https://github.com/Microsoft/FASTER/blob/master/cs/README.md). FASTER C# binaries are available via [NuGet](https://www.nuget.org/packages/Microsoft.FASTER/).\n\nYou can take a look at the project roadmap [here](https://microsoft.github.io/FASTER/roadmap).\n\n# Build and Test\n\nFor C#, click [here](https://github.com/Microsoft/FASTER/tree/master/cs).\n\nFor C++, click [here](https://github.com/Microsoft/FASTER/tree/master/cc).\n\n# Recovery in FASTER KV\n\nBoth the C# and C++ version of FASTER KV support asynchronous checkpointing and recovery, based on a new\nrecovery model called Concurrent Prefix Recovery (CPR for short). You can read more about CPR in our research\npaper [here](https://www.microsoft.com/en-us/research/uploads/prod/2019/01/cpr-sigmod19.pdf) (to appear in \nSIGMOD 2019). Briefly, CPR is based on (periodic) group commit. However, instead of using an expensive \nwrite-ahead log (WAL) which can kill FASTER's high performance, CPR: (1) provides a semantic description of committed\noperations, of the form \xe2\x80\x9call operations until offset Ti in session i\xe2\x80\x9d; and (2) uses asynchronous \nincremental checkpointing instead of a WAL to implement group commit in a scalable bottleneck-free manner.\n\nCPR is available in the C# and C++ versions of FASTER. More documentation on recovery in the C# version is\n[here](https://github.com/Microsoft/FASTER/tree/master/cs#checkpointing-and-recovery). For C++, we only\nhave examples in code right now. The sum-store, located [here](https://github.com/Microsoft/FASTER/tree/master/cc/playground/sum_store-dir), is a good example of checkpointing and recovery.\n\n# Contributing\n\nThis project welcomes contributions and suggestions.  Most contributions require you to agree to a\nContributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us\nthe rights to use your contribution. For details, visit https://cla.microsoft.com.\n\nWhen you submit a pull request, a CLA-bot will automatically determine whether you need to provide\na CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions\nprovided by the bot. You will only need to do this once across all repos using our CLA.\n\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).\nFor more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or\ncontact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.\n"