b'# Mist Cloud Management Platform - Community Edition\n\nMist is an open source platform for managing heterogeneous computing \ninfrastructure, aka a Multi-Cloud Management Platform.\n\nThe managed computing resources may be running on any combination of public \nclouds, private clouds, hypervisors, bare metal servers, container hosts.\n\nMist is developed by Mist.io Inc. The code for the Community Edition is \nprovided under the Apache License. The Enterprise Edition and the Hosted \nService include plugins for Governance, Role Based Access Control & Cost \nInsights. They are available for purchase at __https://mist.io__. Paid support \nplans are available for any edition.\n\n<img src="https://mist.io/landing/images/frontpage/home-dashboard.png" width="768">\n\n# Who needs Mist?\n\n1. Organizations that depend on hybrid or multi-cloud infrastructure\n2. Organizations that provide infrastructure resources to their users on a self-service fashion\n\nThey often end up building silos of distinct tools, processes & teams for each \nsupported platform, introducing operational complexities which can affect both \nsecurity and efficiency.\n\nAs the heterogeneity increases, it\'s becoming increasingly difficult to\n- train users\n- set access control rules\n- set governance policies like quotas and other constraints\n- audit usage\n- monitor/optimize costs\n- automate complex deployments\n- set up metering & billing\n\nMist provides a unified way to operate, monitor & govern these resources. The \nmission statement of the Mist platform is to help commoditize computing by \nalleviating vendor lock-in. \n\n# Features\n\n- Instant visibility of all the available resources across clouds, grouped by tags\n- Instant reporting/estimation of the current infrastructure costs\n- Compare current & past costs, correlate with usage, provide right-sizing recommendations (EE/HS only)\n- Provision new resources on any cloud: machines, volumes, networks, zones, records\n- Perform life cycle actions on existing resources: stop, start, reboot, resize, destroy, etc\n- Instant audit logging for all actions performed through Mist or detected through continuous polling\n- Upload scripts to the library, run them on any machine while enforcing audit logging and centralized control of SSH keys\n- SSH command shell on any machine within the browser or through the CLI, enforcing audit logging and centralized control of SSH keys\n- Enable monitoring on target machines to display real time system & custom metrics and store them for long term access\n- Set rules on metrics or logs that trigger notifications, webhooks, scripts or machine lifecycle actions\n- Set schedules that trigger scripts or machine lifecycle actions\n- Set fine grained access control policies per team/tag/resource/action (EE/HS only)\n- Set governance constraints: e.g. quotas on cost per user/team, required expiration dates (EE/HS only)\n- Upload infrastructure templates that may describe complex deployments and workflows (EE/HS only)\n- Deploy and scale Kubernetes clusters on any supported cloud (EE/HS only)\n\n# Terminology\n\n#### Cloud\nAny service that provides on-demand access to computing resources\n- Public clouds  (e.g. AWS, Azure, Google Cloud, IBM Cloud, DigitalOcean, Linode, Packet)\n- Private clouds (e.g. based on OpenStack, vSphere, OnApp)\n- Hypervisors (e.g. KVM, ESXi),\n- Container hosts / Container clusters\n- Bare metal / Other server\n\n#### Machine\n\nAny computing resource is a machine. There are many types of machines and some machines may contain other machines.\n\n#### Volume\n\nAny physical or virtual data storage device. E.g. Physical HDD/SSD, Cloud disks, EBS volumes, etc. Volumes may be attached on machines. May be provisioned along with machines or independently.\n\n#### Network\n\nPrivate network spaces that machines can join. e.g. AWS VPC\'s\n\n#### Script\n\nAn executable (e.g. bash script) or an Ansible playbook that can run on machines over SSH. Scripts may be added inline or by a reference to a tarball or a Git repository.\n\n#### Template\n\nA blueprint that describes the full lifecycle of an application that may require multiple computing resources, network, storage and additional configurations. E.g. The provided Kubernetes template enables the deployment of a Kubernetes cluster on any cloud and provides workflows to easily scale the cluster up or down. Currently supporting Cloudify blueprints. Terraform support coming soon.\n\n#### Stack\n\nThe deployment of a template is a Stack. A Stack may include resources (e.g. machines, networks, volumes) and provides a set of workflow actions that can be performed. A Stack created by the Kubernetes template refers to a Kubernetes cluster. It includes references to the master and worker nodes and provides scale up & down workflows that can be applied to the cluster.\n\n#### Tunnel\n\nA point to point VPN enabling Mist to manage infrastructure that\'s not on publicly addressable network space.\n\n# Architecture\n\nMist is a cloud native application split into microservices which are packaged as Docker containers. It can be deployed on a single host with Docker Compose, or on a Kubernetes cluster using Helm.\n\nThe most notable components are the following:\n- Mist UI, a web application built with Web Components and Polymer\n- REST API that serves requests from clients\n- WebSocket API, sends real-time updates to connected clients and proxies shell connections\n- Hubshell service, opens SSH connections to machines or shell connections using the Docker API\n- Celery workers, running asynchronous jobs\n- Celery Beat schedulers & pollers that schedule polling tasks, as well as user defined scheduled actions\n- Gocky as the relay to receive and pre-process monitoring metrics\n- RabbitMQ message queue service\n- InfluxDB, Graphite or FoundationDB as a time series database\n- MongoDB or FoundationDB Document Layer as the main database\n- Elasticsearch for storing and searching logs\n- Logstash for routing logs to Elasticsearch\n- Telegraf as a data collection agent, installed on monitored machines\n\n![Architecture.svg](Architecture.svg)\n\nThe user interacts with the RESTful Mist API through client apps like the Mist \nUI in the browser, or command line tools (e.g. cURL,  Mist CLI). The Mist UI, \napart from invoking the RESTful API, also establishes a WebSocket connection, \nwhich is used to receive real time updates and to proxy shell connections to \nmachines. The Mist API server interacts with the respective API\'s of the \ntarget clouds, either directly, or by adding tasks that get executed \nasynchronously by Celery workers. The messaging is following the AMQP protocol \nand gets coordinated by RabbitMQ. The main data store is MongoDB. Logs are \nbeing stored in Elasticsearch. Time series data go to either Graphite, \nInfluxDB or TSFDB, depending on the installation. Schedules and polling tasks \nare triggered by Celery Beat. Whenever a shell connection is required (e.g. \nSSH or Docker Shell), Hubshell establishes the connection and makes it \navailable through the WebSocket API.\n\n## Hardware requirements\n\nRecommended hardware resources are:\n    4 CPU cores\n    8 GB RAM\n    10 GB disk (accessible to /var/lib/docker/)\n\n\n## Installation\n\n\n### Single host\n\nThe easiest way to get started with Mist is to install the latest release \nusing `docker-compose`. So, in order to run it, one needs to install a recent \nversion of [docker](https://docs.docker.com/engine/installation/) and\n[docker-compose](https://docs.docker.com/compose/install/).\n\nTo install the latest stable release, head over to\n[releases](https://github.com/mistio/mist-ce/releases) and follow the\ninstructions there.\n\nAfter a few minutes (depending on your connection) all the mist containers will\nbe downloaded and started in the background.\n\nRun `docker-compose ps`. All containers should be in the UP state, except\nshortlived container elasticsearch-manage.\n\n\n### Kubernetes cluster\n\nUse the available helm chart within the chart directory.\n\n\n\n## Running Mist\n\nMake sure you\'re inside the directory containing the `docker-compose.yml` file.\n\nSwitch to the directory containing the `docker-compose.yml` file and run\n\n    docker-compose up -d\n\nThis will start all the mist docker containers in the background.\n\nTo create a user for the first time, first run\n\n    docker-compose exec api sh\n\nThis should drop you in a shell into one of the mist containers. In there,\nrun\n\n    ./bin/adduser --admin admin@example.com\n\nReplace the email address with yours. Try running `./bin/adduser -h` for more\noptions. The `--docker-cloud` flag will add the docker daemon hosting the\nmist installation as a docker cloud in the created account.\n\nMist binds on port 80 of the host. Visit http://localhost and login with the\nemail and password specified above.\n\nWelcome to Mist! Enjoy!\n\n\n## Configuring\n\nAfter the initial `docker-compose up -d`, you\'ll see that a configuration file\nis created in `./settings/settings.py`. Edit this file to modify configuration.\nAny changes to the `./settings/settings.py` require a restart to take effect:\n\n    docker-compose restart\n\n\n### Required configuration\n\n#### URL\n\nIf running on anything other than `localhost`, you\'ll need to set the\n`CORE_URI` setting in `./settings/settings.py`. Example:\n\n    CORE_URI = "http://198.51.100.12"\n\n\n### Mail settings\n\nIn some cases, such as user registration, forgotten passwords, user invitations\netc, mist needs to send emails. By default, mist is configured to use a\nmock mailer. To see logs sent by mist, run\n\n    docker-compose logs -f mailmock\n\nIf you wish to use a real SMTP server, edit `./settings/settings.py` and modify\n`MAILER_SETTINGS`.\n\nDon\'t forget to restart docker-compose for changes to take effect.\n\n\n### TLS settings\n\nThis section applies if you\'ve installed mist by using the `docker-compose.yml`\nfile of a mist release.\n\nAssuming a certificate `cert.pem` and private key file `key.pem` in the same\ndirectory as the `docker-compose.yml` file:\n\nCreate a `docker-compose.override.yml` file with the following contents:\n```yaml\nversion: \'2.0\'\nservices:\n  nginx:\n    volumes:\n      - ./nginx-listen.conf:/etc/nginx/nginx-listen.conf:ro\n      - ./cert.pem:/etc/nginx/cert.pem:ro\n      - ./key.pem:/etc/nginx/key.pem:ro\n    ports:\n      - 443:443\n```\n\nCreate a `nginx-listen.conf` in the directory of `docker-compose.yml`, with the\nfollowing contents:\n```\n    listen 80;\n    listen 443 ssl;\n    server_name www.example.com;\n    ssl_certificate     /etc/nginx/cert.pem;\n    ssl_certificate_key /etc/nginx/key.pem;\n    if ($scheme != "https") {\n        rewrite ^ https://$host$uri permanent;\n    }\n```\n\nUpdate `CORE_URI` in mist\'s settings (see URL section above).\n\nRun `docker-compose up -d`.\n\n\n## Managing Mist\n\nMist is managed using `docker-compose`. Look that up for details. Some\nuseful commands follow. Keep in mind that you need to run these from inside the\ndirectory containing the `docker-compose.yml` file:\n\n    # See status of all applications\n    docker-compose ps\n\n    # Almost all containers should be in the UP state. An exception to this\n    # is shortlived containers. Currently the only such container is\n    # elasticsearch-manage. This should run for a few seconds and exit 0 if\n    # everything went fine.\n\n    # Restart nginx container\n    docker-compose restart nginx\n\n    # See the logs of the api and celery containers, starting with the last\n    # 50 lines.\n    docker-compose logs --tail=50 -f api celery\n\n    # Stop mist\n    docker-compose stop\n\n    # Start mist\n    docker-compose start\n    # or even better\n    docker-compose up -d\n\n    # Stop and remove all containers\n    docker-compose down\n\n    # Completely remove all containers and data volumes.\n    docker-compose down -v\n\n## Migrating from previous versions\n\n1. Bring down your current installation by running `docker-compose down`.\n2. Download the docker-compose.yml file of the latest release and place it\nwithin the same directory as before. This way the new installation will use the\nsame Docker volumes.\n3. Run `docker-compose up -d` to bring up the new version.\n4. Check that everything is in order by running `docker-compose ps`. Also check\nif your Mist portal works as expected.\n\n## Staging version\n\nIf you want to install the latest bleeding edge build of mist,\nrun the following:\n\n```bash\nmkdir mist-ce && cd mist-ce && echo \'MIST_TAG=staging\' > .env\nwget https://raw.githubusercontent.com/mistio/mist-ce/staging/docker-compose.yml\ndocker-compose up -d\n```\n\n## Development deployment\n\nIf you\'re planning to modify Mist\'s source code, an alternative installation\nmethod is recommended.\n\nClone this git repo and all its submodules with something like:\n\n    git clone --recursive https://github.com/mistio/mist-ce.git\n    cd mist-ce\n    docker-compose up -d\n\nThis may take some time.\n\nThis setup will mount the checked out code into the containers. By cloning the\ndirectory, now there\'s also a `docker-compose.override.yml` file in the current\ndirectory in addition to `docker-compose.yml` and is used to modify the\nconfiguration for development mode.\n\nIf you\'re not interested in frontend development, you can comment out the ui & \nlanding sections within the `docker-compose.override.yml` file and re-run \n`docker-compose up -d`. Otherwise, you\'ll also need to install the ui & \nlanding page dependencies before you can access the Mist UI.\n\nInstall all front-end dependencies with the following commands\n\n    docker-compose exec landing bower install\n    docker-compose exec ui bower install\n\nAnd then build the landing & ui bundles\n\n    docker-compose exec landing polymer build\n    docker-compose exec ui node --max_old_space_size=4096 /usr/local/bin/polymer build\n    docker-compose exec ui cp bower_components/echarts/dist/echarts.common.min.js build/bundled/bower_components/echarts/dist/\n\nWhen doing front-end development, it\'s usually more convenient to serve the \nsource code instead of the bundles. To do that, edit settings/settings.py and \nset `JS_BUILD = False`. Restart the api container for the changes to take \neffect\n\n    ./restart.sh api\n\nThe above instructions for running and managing Mist apply.\n'