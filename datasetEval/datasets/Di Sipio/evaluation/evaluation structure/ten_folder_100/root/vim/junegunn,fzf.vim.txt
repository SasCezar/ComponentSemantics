b'fzf :heart: vim\n===============\n\nThings you can do with [fzf][fzf] and Vim.\n\nRationale\n---------\n\n[fzf][fzf] in itself is not a Vim plugin, and the official repository only\nprovides the [basic wrapper function][run] for Vim and it\'s up to the users to\nwrite their own Vim commands with it. However, I\'ve learned that many users of\nfzf are not familiar with Vimscript and are looking for the "default"\nimplementation of the features they can find in the alternative Vim plugins.\n\nThis repository is a bundle of fzf-based commands and mappings extracted from\nmy [.vimrc][vimrc] to address such needs. They are *not* designed to be\nflexible or configurable, and there\'s no guarantee of backward-compatibility.\n\nWhy you should use fzf on Vim\n-----------------------------\n\nBecause you can and you love fzf.\n\nfzf runs asynchronously and can be orders of magnitude faster than similar Vim\nplugins. However, the benefit may not be noticeable if the size of the input\nis small, which is the case for many of the commands provided here.\nNevertheless I wrote them anyway since it\'s really easy to implement custom\nselector with fzf.\n\nInstallation\n------------\n\nfzf.vim depends on the basic Vim plugin of [the main fzf\nrepository][fzf-main], which means you need to **set up both "fzf" and\n"fzf.vim" on Vim**. To learn more about fzf/Vim integration, see\n[README-VIM][README-VIM].\n\n[fzf-main]: https://github.com/junegunn/fzf\n[README-VIM]: https://github.com/junegunn/fzf/blob/master/README-VIM.md\n\n### Using [vim-plug](https://github.com/junegunn/vim-plug)\n\nIf you already installed fzf using [Homebrew](https://brew.sh/), the following\nshould suffice:\n\n```vim\nPlug \'/usr/local/opt/fzf\'\nPlug \'junegunn/fzf.vim\'\n```\n\nBut if you want to install fzf as well using vim-plug:\n\n```vim\nPlug \'junegunn/fzf\', { \'dir\': \'~/.fzf\', \'do\': \'./install --all\' }\nPlug \'junegunn/fzf.vim\'\n```\n\n- `dir` and `do` options are not mandatory\n- Use `./install --bin` instead if you don\'t need fzf outside of Vim\n- Make sure to use Vim 7.4 or above\n\nCommands\n--------\n\n| Command           | List                                                                    |\n| ---               | ---                                                                     |\n| `:Files [PATH]`   | Files (similar to `:FZF`)                                               |\n| `:GFiles [OPTS]`  | Git files (`git ls-files`)                                              |\n| `:GFiles?`        | Git files (`git status`)                                                |\n| `:Buffers`        | Open buffers                                                            |\n| `:Colors`         | Color schemes                                                           |\n| `:Ag [PATTERN]`   | [ag][ag] search result (`ALT-A` to select all, `ALT-D` to deselect all) |\n| `:Rg [PATTERN]`   | [rg][rg] search result (`ALT-A` to select all, `ALT-D` to deselect all) |\n| `:Lines [QUERY]`  | Lines in loaded buffers                                                 |\n| `:BLines [QUERY]` | Lines in the current buffer                                             |\n| `:Tags [QUERY]`   | Tags in the project (`ctags -R`)                                        |\n| `:BTags [QUERY]`  | Tags in the current buffer                                              |\n| `:Marks`          | Marks                                                                   |\n| `:Windows`        | Windows                                                                 |\n| `:Locate PATTERN` | `locate` command output                                                 |\n| `:History`        | `v:oldfiles` and open buffers                                           |\n| `:History:`       | Command history                                                         |\n| `:History/`       | Search history                                                          |\n| `:Snippets`       | Snippets ([UltiSnips][us])                                              |\n| `:Commits`        | Git commits (requires [fugitive.vim][f])                                |\n| `:BCommits`       | Git commits for the current buffer                                      |\n| `:Commands`       | Commands                                                                |\n| `:Maps`           | Normal mode mappings                                                    |\n| `:Helptags`       | Help tags <sup id="a1">[1](#helptags)</sup>                             |\n| `:Filetypes`      | File types\n\n- Most commands support `CTRL-T` / `CTRL-X` / `CTRL-V` key\n  bindings to open in a new tab, a new split, or in a new vertical split\n- Bang-versions of the commands (e.g. `Ag!`) will open fzf in fullscreen\n- You can set `g:fzf_command_prefix` to give the same prefix to the commands\n    - e.g. `let g:fzf_command_prefix = \'Fzf\'` and you have `FzfFiles`, etc.\n\n(<a name="helptags">1</a>: `Helptags` will shadow the command of the same name\nfrom [pathogen][pat]. But its functionality is still available via `call\npathogen#helptags()`. [\xe2\x86\xa9](#a1))\n\n[pat]: https://github.com/tpope/vim-pathogen\n[f]:   https://github.com/tpope/vim-fugitive\n\nCustomization\n-------------\n\n### Global options\n\nEvery command in fzf.vim internally calls `fzf#wrap` function of the main\nrepository which supports a set of global option variables. So please read\nthrough [README-VIM][README-VIM] to learn more about them.\n\n### Command-local options\n\nA few commands in fzf.vim can be customized with global option variables shown\nbelow.\n\n```vim\n" [Buffers] Jump to the existing window if possible\nlet g:fzf_buffers_jump = 1\n\n" [[B]Commits] Customize the options used by \'git log\':\nlet g:fzf_commits_log_options = \'--graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr"\'\n\n" [Tags] Command to generate tags file\nlet g:fzf_tags_command = \'ctags -R\'\n\n" [Commands] --expect expression for directly executing the command\nlet g:fzf_commands_expect = \'alt-enter,ctrl-x\'\n```\n\n### Advanced customization\n\n#### Vim functions\n\nEach command in fzf.vim is backed by a Vim function. You can override\na command or define a variation of it by calling its corresponding function.\n\n| Command   | Vim function                                                               |\n| ---       | ---                                                                        |\n| `Files`   | `fzf#vim#files(dir, [spec dict], [fullscreen bool])`                       |\n| `GFiles`  | `fzf#vim#gitfiles(git_options, [spec dict], [fullscreen bool])`            |\n| `GFiles?` | `fzf#vim#gitfiles(\'?\', [spec dict], [fullscreen bool])`                    |\n| `Buffers` | `fzf#vim#buffers([spec dict], [fullscreen bool])`                          |\n| `Colors`  | `fzf#vim#colors([spec dict], [fullscreen bool])`                           |\n| `Rg`      | `fzf#vim#grep(command, [has_column bool], [spec dict], [fullscreen bool])` |\n| ...       | ...                                                                        |\n\n(We can see that the last two optional arguments of each function are\nidentical. They are directly passed to `fzf#wrap` function. If you haven\'t\nread [README-VIM][README-VIM] already, please read it before proceeding.)\n\n#### Example: Customizing `Files` command\n\nThis is the default definition of `Files` command:\n\n```vim\ncommand! -bang -nargs=? -complete=dir Files call fzf#vim#files(<q-args>, <bang>0)\n```\n\nLet\'s say you want to a variation of it called `ProjectFiles` that only\nsearches inside `~/projects` directory. Then you can do it like this:\n\n```vim\ncommand! -bang ProjectFiles call fzf#vim#files(\'~/projects\', <bang>0)\n```\n\nOr, if you want to override the command with different fzf options, just pass\na custom spec to the function.\n\n```vim\ncommand! -bang -nargs=? -complete=dir Files\n    \\ call fzf#vim#files(<q-args>, {\'options\': [\'--layout=reverse\', \'--info=inline\']}, <bang>0)\n```\n\nWant a preview window?\n\n```vim\ncommand! -bang -nargs=? -complete=dir Files\n    \\ call fzf#vim#files(<q-args>, {\'options\': [\'--layout=reverse\', \'--info=inline\', \'--preview\', \'cat {}\']}, <bang>0)\n```\n\nIt kind of works, but you probably want a nicer previewer program than `cat`.\nfzf.vim ships [a versatile preview script](bin/preview.sh) you can readily\nuse. It internally executes [bat](https://github.com/sharkdp/bat) for syntax\nhighlighting, so make sure to install it.\n\n```vim\ncommand! -bang -nargs=? -complete=dir Files\n    \\ call fzf#vim#files(<q-args>, {\'options\': [\'--layout=reverse\', \'--info=inline\', \'--preview\', \'~/.vim/plugged/fzf.vim/bin/preview.sh {}\']}, <bang>0)\n```\n\nHowever, it\'s not ideal to hard-code the path to the script which can be\ndifferent in different circumstances. So in order to make it easier to set up\nthe previewer, fzf.vim provides `fzf#vim#with_preview` helper function.\nSimilarly to `fzf#wrap`, it takes a spec dictionary and returns a copy of it\nwith additional preview options.\n\n```vim\ncommand! -bang -nargs=? -complete=dir Files\n    \\ call fzf#vim#files(<q-args>, fzf#vim#with_preview({\'options\': [\'--layout=reverse\', \'--info=inline\']}), <bang>0)\n```\n\nYou can just omit the spec argument if you only want the previwer.\n\n```vim\ncommand! -bang -nargs=? -complete=dir Files\n    \\ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)\n```\n\n#### Example: `git grep` wrapper\n\nThe following example implements `GGrep` command that works similarly to\npredefined `Ag` or `Rg` using `fzf#vim#grep`.\n\n- The second argument to `fzf#vim#grep` is 0 (false), because `git grep` does\n  not print column numbers.\n- We set the base directory to git root by setting `dir` attribute in spec\n  dictionary.\n- [The preview script](bin/preview.sh) supports `grep` format\n  (`FILE_PATH:LINE_NO:...`), so we can just wrap the spec with\n  `fzf#vim#with_preview` as before to enable previewer.\n\n```vim\ncommand! -bang -nargs=* GGrep\n  \\ call fzf#vim#grep(\n  \\   \'git grep --line-number \'.shellescape(<q-args>), 0,\n  \\   fzf#vim#with_preview({\'dir\': systemlist(\'git rev-parse --show-toplevel\')[0]}), <bang>0)\n```\n\n#### Example: Advanced `Rg` command\n\nIn the default implementation of `Rg`, ripgrep process starts only once with\nthe initial query (e.g. `:Rg foo`) and fzf filters the output of the process.\n\nThis is okay in most cases because fzf is quite performant even with millions\nof lines, but we can make fzf completely delegate its search responsibliity to\nripgrep process by making it restart ripgrep whenever the query string is\nupdated. In this scenario, fzf becomes a simple selector interface rather than\na "fuzzy finder".\n\n- `--bind \'change:reload:rg ... {q}\'` will make fzf restart ripgrep process\n  whenever the query string, denoted by `{q}`, is changed.\n- With `--phony` option, fzf will no longer perform search. The query string\n  you type on fzf prompt is only used for restarting ripgrep process.\n- Also note that we enabled previewer with `fzf#vim#with_preview`.\n\n```vim\nfunction! RipgrepFzf(query, fullscreen)\n  let command_fmt = \'rg --column --line-number --no-heading --color=always --smart-case %s || true\'\n  let initial_command = printf(command_fmt, shellescape(a:query))\n  let reload_command = printf(command_fmt, \'{q}\')\n  let spec = {\'options\': [\'--phony\', \'--query\', a:query, \'--bind\', \'change:reload:\'.reload_command]}\n  call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)\nendfunction\n\ncommand! -nargs=* -bang Rg call RipgrepFzf(<q-args>, <bang>0)\n```\n\nMappings\n--------\n\n| Mapping                            | Description                               |\n| ---                                | ---                                       |\n| `<plug>(fzf-maps-n)`               | Normal mode mappings                      |\n| `<plug>(fzf-maps-i)`               | Insert mode mappings                      |\n| `<plug>(fzf-maps-x)`               | Visual mode mappings                      |\n| `<plug>(fzf-maps-o)`               | Operator-pending mappings                 |\n| `<plug>(fzf-complete-word)`        | `cat /usr/share/dict/words`               |\n| `<plug>(fzf-complete-path)`        | Path completion using `find` (file + dir) |\n| `<plug>(fzf-complete-file)`        | File completion using `find`              |\n| `<plug>(fzf-complete-file-ag)`     | File completion using `ag`                |\n| `<plug>(fzf-complete-line)`        | Line completion (all open buffers)        |\n| `<plug>(fzf-complete-buffer-line)` | Line completion (current buffer only)     |\n\n### Usage\n\n```vim\n" Mapping selecting mappings\nnmap <leader><tab> <plug>(fzf-maps-n)\nxmap <leader><tab> <plug>(fzf-maps-x)\nomap <leader><tab> <plug>(fzf-maps-o)\n\n" Insert mode completion\nimap <c-x><c-k> <plug>(fzf-complete-word)\nimap <c-x><c-f> <plug>(fzf-complete-path)\nimap <c-x><c-j> <plug>(fzf-complete-file-ag)\nimap <c-x><c-l> <plug>(fzf-complete-line)\n\n" Advanced customization using Vim function\ninoremap <expr> <c-x><c-k> fzf#vim#complete#word({\'left\': \'15%\'})\n```\n\n### Completion helper\n\n`fzf#vim#complete` is a helper function for creating custom fuzzy completion\nusing fzf. If the first parameter is a command string or a Vim list, it will\nbe used as the source.\n\n```vim\n" Replace the default dictionary completion with fzf-based fuzzy completion\ninoremap <expr> <c-x><c-k> fzf#vim#complete(\'cat /usr/share/dict/words\')\n```\n\nFor advanced uses, you can pass an options dictionary to the function. The set\nof options is pretty much identical to that for `fzf#run` only with the\nfollowing exceptions:\n\n- `reducer` (funcref)\n    - Reducer transforms the output lines of fzf into a single string value\n- `prefix` (string or funcref; default: `\\k*$`)\n    - Regular expression pattern to extract the completion prefix\n    - Or a function to extract completion prefix\n- Both `source` and `options` can be given as funcrefs that take the\n  completion prefix as the argument and return the final value\n- `sink` or `sink*` are ignored\n\n```vim\n" Global line completion (not just open buffers. ripgrep required.)\ninoremap <expr> <c-x><c-l> fzf#vim#complete(fzf#wrap({\n  \\ \'prefix\': \'^.*$\',\n  \\ \'source\': \'rg -n ^ --color always\',\n  \\ \'options\': \'--ansi --delimiter : --nth 3..\',\n  \\ \'reducer\': { lines -> join(split(lines[0], \':\\zs\')[2:], \'\') }}))\n```\n\n#### Reducer example\n\n```vim\nfunction! s:make_sentence(lines)\n  return substitute(join(a:lines), \'^.\', \'\\=toupper(submatch(0))\', \'\').\'.\'\nendfunction\n\ninoremap <expr> <c-x><c-s> fzf#vim#complete({\n  \\ \'source\':  \'cat /usr/share/dict/words\',\n  \\ \'reducer\': function(\'<sid>make_sentence\'),\n  \\ \'options\': \'--multi --reverse --margin 15%,0\',\n  \\ \'left\':    20})\n```\n\nStatus line of terminal buffer\n------------------------------\n\nWhen fzf starts in a terminal buffer (see [fzf/README-VIM.md][termbuf]), you\nmay want to customize the statusline of the containing buffer.\n\n[termbuf]: https://github.com/junegunn/fzf/blob/master/README-VIM.md#fzf-inside-terminal-buffer\n\n### Hide statusline\n\n```vim\nautocmd! FileType fzf\nautocmd  FileType fzf set laststatus=0 noshowmode noruler\n  \\| autocmd BufLeave <buffer> set laststatus=2 showmode ruler\n```\n\n### Custom statusline\n\n```vim\nfunction! s:fzf_statusline()\n  " Override statusline as you like\n  highlight fzf1 ctermfg=161 ctermbg=251\n  highlight fzf2 ctermfg=23 ctermbg=251\n  highlight fzf3 ctermfg=237 ctermbg=251\n  setlocal statusline=%#fzf1#\\ >\\ %#fzf2#fz%#fzf3#f\nendfunction\n\nautocmd! User FzfStatusLine call <SID>fzf_statusline()\n```\n\nLicense\n-------\n\nMIT\n\n[fzf]:   https://github.com/junegunn/fzf\n[run]:   https://github.com/junegunn/fzf/blob/master/README-VIM.md#fzfrun\n[vimrc]: https://github.com/junegunn/dotfiles/blob/master/vimrc\n[ag]:    https://github.com/ggreer/the_silver_searcher\n[rg]:    https://github.com/BurntSushi/ripgrep\n[us]:    https://github.com/SirVer/ultisnips\n'