b'# codi.vim [![Gitter](https://badges.gitter.im/codi-vim/Lobby.svg)](https://gitter.im/codi-vim/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\n\nThe interactive scratchpad for hackers.\n\n![Codi demo.](assets/codi.gif)\n\n_Using Codi as a Python scratchpad through the\n[shell wrapper](#shell-wrapper)_\n\nCodi is an interactive scratchpad for hackers, with a similar interface to\n[Numi](https://numi.io). It opens a pane synchronized to your main buffer\nwhich displays the results of evaluating each line *as you type* (with NeoVim\nor Vim with `+job` and `+channel`, asynchronously). It\'s extensible to nearly\nany language that provides a REPL (interactive interpreter)!\n\nLanguages with built-in support:\nPython, JavaScript, CoffeeScript, Haskell, PureScript, Ruby, OCaml, R,\nClojure/ClojureScript, PHP, Lua, C++, Julia, Elm, Elixir, TypeScript, Mathjs\n\n[Pull requests](https://github.com/metakirby5/codi.vim/pulls)\nfor new language support welcome!\n\n*Note:* without async support, evaluation will trigger on cursor hold rather\nthan text change.\n\nFor more information, check out the [documentation](doc/codi.txt).\nWatch a [screencast](https://ptpb.pw/t/~codi)!\n\n## Installation\n\nUse your favorite package manager\n([vim-plug](https://github.com/junegunn/vim-plug),\n[Vundle](https://github.com/VundleVim/Vundle.vim),\n[pathogen.vim](https://github.com/tpope/vim-pathogen)),\nor add this directory to your Vim runtime path.\n\nFor example, if you\'re using vim-plug, add the following line to `~/.vimrc`:\n\n```\nPlug \'metakirby5/codi.vim\'\n```\n\n### Dependencies\n\n- OS X or Linux (Windows support coming\n  [soon](https://github.com/metakirby5/codi.vim/issues/14)!)\n- Vim 7.4 (with `+job` and `+channel` for asynchronous evaluation) or\n  NeoVim (still in its infancy - please report bugs!)\n- `uname`\n- If not using NeoVim, `script` (BSD or Linux, man page should say at least\n  2013)\n\nEach interpreter also depends on its REPL. These are loaded on-demand. For\nexample, if you only want to use the Python Codi interpreter, you will not\nneed `ghci`.\n\nDefault interpreter dependencies:\n\n  - Python:       `python`\n  - JavaScript:   `node`\n  - CoffeeScript: `coffee`\n  - Haskell:      `ghci` (be really careful with lazy evaluation!)\n  - PureScript    `pulp psci`\n  - Ruby:         `irb`\n  - OCaml:        `ocaml`\n  - R:            `R`\n  - Clojure:      `planck`\n  - PHP:          `psysh`\n  - Lua:          `lua`\n  - C++:          `cling`\n  - Julia:        `julia`\n  - Elm:          `elm`\n  - Elixir:       `iex`\n  - TypeScript:   `tsun`\n  - Mathjs:       `mathjs`\n\n## Usage\n\n- `Codi [filetype]` activates Codi for the current buffer, using the provided\n  filetype or the buffer\'s filetype.\n- `Codi!` deactivates Codi for the current buffer.\n- `Codi!! [filetype]` toggles Codi for the current buffer, using the provided\n  filetype or the buffer\'s filetype.\n\n### Shell wrapper\n\nA nice way to use Codi is through a shell wrapper that you can stick in your\n`~/.bashrc`:\n\n```sh\n# Codi\n# Usage: codi [filetype] [filename]\ncodi() {\n  local syntax="${1:-python}"\n  shift\n  vim -c \\\n    "let g:startify_disable_at_vimenter = 1 |\\\n    set bt=nofile ls=0 noru nonu nornu |\\\n    hi ColorColumn ctermbg=NONE |\\\n    hi VertSplit ctermbg=NONE |\\\n    hi NonText ctermfg=0 |\\\n    Codi $syntax" "$@"\n}\n```\n\n### Options\n\n- `g:codi#interpreters` is a list of user-defined interpreters.\n  See the [documentation](doc/codi.txt) for more information.\n- `g:codi#aliases` is a list of user-defined interpreter filetype aliases.\n  See the [documentation](doc/codi.txt) for more information.\n\nThe below options can also be set on a per-interpreter basis via\n`g:codi#interpreters`:\n\n- `g:codi#autocmd` determines what autocommands trigger updates.\n  See the [documentation](doc/codi.txt) for more information.\n- `g:codi#width` is the width of the Codi split.\n- `g:codi#rightsplit` is whether or not Codi spawns on the right side.\n- `g:codi#rightalign` is whether or not to right-align the Codi buffer.\n- `g:codi#autoclose` is whether or not to close Codi when the associated\n  buffer is closed.\n- `g:codi#raw` is whether or not to display interpreter results without\n  alignment formatting (useful for debugging).\n- `g:codi#sync` is whether or not to force synchronous execution. No reason to\n  touch this unless you want to compare async to sync.\n\n### Autocommands\n\n- `CodiEnterPre`, `CodiEnterPost`: When a Codi pane enters.\n- `CodiUpdatePre`, `CodiUpdatePost`: When a Codi pane updates.\n- `CodiLeavePre`, `CodiLeavePost`: When a Codi pane leaves.\n\n## FAQ\n\n- _Why doesn\'t X work in Codi, when it works in a normal source file?_\n  - Codi is not meant to be a replacement for actually running your program;\n    it supports nothing more than what the underlying REPL supports. This is\n    why Haskell language pragmas don\'t work and OCaml statements must end with\n    `;;`.\n- _Codi leaves a bunch of old processes running, what\'s going on?_\n  - The cause of this issue is still unknown, but it happens infrequently. See\n    `:h codi-introduction-warnings` for more information.\n- _Codi doesn\'t seem to work on my setup._\n  - Check `:h codi-introduction-gotchas`.\n\n## Thanks to\n\n- [@DanielFGray](https://github.com/DanielFGray) and\n  [@purag](https://github.com/purag) for testing, feedback, and suggestions\n- [@Joaquin-V](https://github.com/Joaquin-V) for helping me discover critical\n  bugs with vanilla settings\n- Everyone who has reported an issue or sent in a pull request :)\n'